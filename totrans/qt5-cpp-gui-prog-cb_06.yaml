- en: Chapter 6. XML Parsing Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing XML data using stream reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing XML data using stream writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing XML data using the QDomDocument class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing XML data using the QDomDocument class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google's Geocoding API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML is the file extension of a type of file format called **Extensible Markup
    Language**, which is used to store information in a structured format. The XML
    format is used extensively for the Web, as well as other applications. HTML, for
    instance, is the file format used for creating web pages and is based upon the
    XML format. Starting from Microsoft Office 2007, Microsoft Office uses the XML-based
    file formats, such as `.docx`, `.xlsx`, `.pptx`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Processing XML data using stream reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to process data taken from an XML file and
    extract it using the stream reader.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple program that reads and processes XML files by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, create a new **Qt Widgets Application** project at your desired location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, open up any text editor and create an XML file that looks like the following,
    then save it as `scene.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go back to Qt Creator and open up `mainwindow.h`. Add the following headers
    at the top of the script, right after `#include <QMainWindow>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, open up `mainwindow.ui` and drag a **Push Button** from the widget box
    on the left-hand side to the UI editor. Change the object name of the button to
    `loadXmlButton` and its display text to **Load XML**:![How to do it…](img/B02820_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, right-click on the button and select **Go to slot…**. A window will
    pop up with a list of signals available for selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the default `clicked()` option and press the **OK** button. Qt will now
    insert a slot function in your header and source files called `on_loadXmlButton_clicked()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, add the following code to the `on_loadXmlButton_clicked()` function:![How
    to do it…](img/B02820_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the project now and you see a window popping up that looks like
    the one you made in Step 4:![How to do it…](img/B02820_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Load XML** button and you should see the file selector window
    popping up on screen. Select the XML file you just created in Step 2 and press
    the **Select** button. After that, you should see the following debug text appear
    on the application output window in Qt Creator, which indicates the program has
    successfully loaded the data from the XML file you just selected:![How to do it…](img/B02820_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we're trying to do in this example is to extract and process data from
    an XML file using the `QXmlStreamReader` class. Imagine you're making a computer
    game and you're using XML files to store the attributes of all the objects in
    your game scene. In this case, the XML format plays an important role in storing
    the data in a structured way, which allows for easy extraction.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we need to add the header of the class related to XML to our
    source file, which in this case is the `QXmlStreamReader` class. `QXmlStreamReader`
    is built into Qt's core library, so there is no need to include any additional
    modules with it, which also means that it's the recommended class to use for processing
    XML data in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Once we clicked on the **Load XML** button, the `on_loadXmlButton_clicked()`
    slot will be called; this is where we write the code for processing the XML data.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a file dialog for selecting the XML file we want to process. Then,
    send the selected file's filename, together with its path, to the `QFile` class
    to open and read the text data of the XML file. After that, the file's data is
    sent to the `QXmlStreamReader` class for processing.
  prefs: []
  type: TYPE_NORMAL
- en: We use a while-loop to read through the entire XML file and check every element
    processed by the stream reader. We determine whether the element is a start element
    or an end element. If it's a start element, we will then check the name of the
    element to determine whether the element should contain any data that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will extract the data, either in the form of an attribute or text.
    An element may have more than one attribute, which is why we must loop through
    all the attributes and extract them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the web browser, many commercial game engines and interactive applications
    also use the XML format to store information for in-game scenes, meshes, and other
    forms of asset used in their product. This is because the XML format provides
    many benefits over other file formats, such as a compact file size, high flexibility
    and extendibility, easy file recovery, and a relational tree structure that allows
    it to be used for highly efficient and performance-critical applications such
    as search engines, intelligent data mining servers, scientific simulations, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn a little bit about the format of an XML file. We will use `scene.xml`,
    which we used in the previous example and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In XML, a tag is a line of markup text that starts with a `<` symbol and ends
    with a `>` symbol. For example, `<scene>` is a tag called `scene`, `<object>`
    is a tag called `object` and so on. Tags come in three flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Start tag, for example `<scene>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End tag, for example `</scene>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty-element tag, for example `<scene />`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever you write a start tag, it must end with an end tag, otherwise your
    XML data will be invalid. An empty-element tag, however, is a standalone tag and
    does not need an end tag behind it.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `scene.xml`, you will see a tag called `xml` which stores the
    version of the XML format and the encoding type, which in this case is XML version
    1.0 and UTF-8 (8-bit Unicode) encoding. This line is called XML declaration and
    it must exist in any of your XML files to validate its format.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will see tags that have attributes stored in them, for example
    `<object tag="building">`. This means that the `object` tag contains an attribute
    called `tag`, which contains a value, `building`. You can put as many attributes
    as you like in a tag, for example `<object tag="building" color="red" name="LA
    Community Hospital" coordinate="34.0191757,-118.2567239">`. Each of these attributes
    stores distinctive data that can be retrieved easily using Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, you can also store data between the start tag and the end tag,
    for example `<name>Town Hall</name>`. This method, however, is not relevant to
    the empty-element tag, since it is a standalone tag and isn't followed by a close
    tag. Therefore, you can only store attributes in an empty-element tag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the XML format, visit [http://www.w3schools.com/xml](http://www.w3schools.com/xml).
  prefs: []
  type: TYPE_NORMAL
- en: Writing XML data using Stream Writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have learned how to process data obtained from an XML file in the previous
    recipe, we will move on to learning how to save data to an XML file. We will continue
    with the previous example and add to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will learn how to save data into an XML file through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add another button to `mainwindow.ui` and set its object name as `saveXmlButton`
    and its label as **Save XML**:![How to do it…](img/B02820_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, right-click on the button and select **Go to slot…**. A window will pop
    up with a list of signals available for selection. Select the `clicked()` option
    and click **OK**. A signal function called `on_saveXmlButton_clicked()` will now
    be automatically added to both your `mainwindow.h` and `mainwindow.cpp` file by
    Qt:![How to do it…](img/B02820_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, add the following code to the `on_saveXmlButton_clicked()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the program and you should see an additional button on the program
    UI:![How to do it…](img/B02820_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save XML** button and a save file dialog will appear on the screen.
    Type the filename you desire and click the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up the XML file you just saved with any text editor. The content of the
    file should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The saving process is more or less similar to loading an XML file in the previous
    example. The only difference is instead of using the `QXmlStreamReader` class,
    we switched to using the `QXmlStreamWriter` class instead.
  prefs: []
  type: TYPE_NORMAL
- en: We are still using the file dialog and the `QFile` class to save the XML file.
    This time, we have to change the open mode from `QFile::ReadOnly` to `QFile::WriteOnly`
    before passing the `QFile` class to the stream writer.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing any data to the new XML file, we must set auto formatting
    to `true`, otherwise there will be no spacing; it also adds new lines and indentation
    to the XML file to make it look tidy and easier to read. However, if that is your
    intention (making it harder to read and edit by the user), then you can just ignore
    the `setAutoFormatting()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, start writing the XML file by calling `writeStartDocument()`, followed
    by all the elements you want to save to the file, and at the end we call the `writeEndDocument()`
    function to stop writing.
  prefs: []
  type: TYPE_NORMAL
- en: Each element must have a start and end tag in order for the reading process
    to work properly. The attributes of an element will be stored in the start tag,
    while the text data will be stored between the start and end tags.
  prefs: []
  type: TYPE_NORMAL
- en: If we're writing an element that contains a group of child elements, then we
    must call `writeStartElement()` before writing the child elements. Then, call
    `writeEndElement()` after saving all its child elements to close the group with
    an end tag. The `writetextElement()` function, however, will automatically add
    the end tag for you so you don't have to worry about that one.
  prefs: []
  type: TYPE_NORMAL
- en: You can call the `writeAttribute()` function to add an attribute to an element.
    There is no limit on how many attributes you can add to a particular element.
  prefs: []
  type: TYPE_NORMAL
- en: Processing XML data using the QDomDocument class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt allows multiple ways to parse XML data, including the common method that
    we have covered in the previous examples. This time around, we're going to learn
    how to read data from an XML file using another class, called `QDomDocument`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Processing XML data using the `QDomDocument` class is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to add the XML module to our project by opening the project
    (`.pro`) file and add the text `xml` at the back of `core` and `gui`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then, just like what we did in the first example in this chapter, create a user
    interface that carries a button that says **Load XML**:![How to do it…](img/B02820_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, right-click on the button, choose **Go to slot…**, and select the
    `clicked()` option. Press the **OK** button and Qt will add a slot function to
    your source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `mainwindow.h` and add the following headers so that we can make use
    of these classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next, go to `mainwindow.cpp` and insert the following code to the button's `clicked()`
    slot function:![How to do it…](img/B02820_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the program now. Click on the **Load XML** button and select
    the XML file used in the first example. You should see the following output:![How
    to do it…](img/B02820_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `QXmlStreamReader`, the `QDomDocument` class is less straightforward
    when comes to loading or saving XML data. However, `QDomDocument` does it in a
    strict way by making sure each element is linked to its respective parent element
    recursively, like in a tree structure. Unlike `QXmlStreamReader`, `QDomDocument`
    allows us to save data to an element created earlier, in a later timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: Since `QDomDocument` is not part of the Qt core library, we must add the XML
    module to our project manually. Otherwise, we will not be able to access `QDomDocument`
    and other classes related to it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we load the XML file and extract its content to the `QDomDocument` class.
    Then, we get its document element, which acts as the root document, and obtain
    its direct children. We then convert each of the child nodes to `QDomElement`
    and obtain their tag names.
  prefs: []
  type: TYPE_NORMAL
- en: By checking tag names, we are able to determine the type of data we're expecting
    from each element. Since this is the first layer of elements with the tag name
    `object`, we don't expect any data from them; we repeat Step 3 again but this
    time around, we're going to do it on the element with the tag name `object` and
    obtain all its direct children, which means the grandchildren of the document
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Again, by checking the tag name, we're able to know what data we're expecting
    from its children elements. If the tag name matches the ones we're expecting (in
    this case, `name`, `position`, `rotation`, `scale`) then we can obtain its data
    by calling `QDomElement::text()`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing XML data using the QDomDocument class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to write data to an XML file using the `QDomDocument`
    class. We will continue from the previous example and just add stuff to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn how to save data into an XML file using the `QDomDocument` class,
    let''s do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, add the second button to the UI, called **Save XML**:![How to
    do it…](img/B02820_06_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Save XML** button and select **Go to slot…**. Then, pick
    the **clicked()** option and click **OK**. A new `clicked()` slot function will
    now be added to your source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, write the following code within the button's `clicked()` slot function:![How
    to do it…](img/B02820_06_12.jpg)![How to do it…](img/B02820_06_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the program now and click on the **Save XML** button. Enter
    your desired filename in the save file dialog and click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open up the XML file you just saved in Step 4 with any text editor and you
    should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous example, we first initiate the file dialog and declare
    a `QDomDocument` object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the root element by calling `QDomDocument::createElement()`.
    Any element created from the `QDomDocument` will NOT automatically become its
    direct child unless we append the newly created element as its child.
  prefs: []
  type: TYPE_NORMAL
- en: To create the grandchildren of `QDomDocument`, simply append the newly created
    elements to the root element instead. By utilizing the `append()` function, we
    can easily arrange the XML data in a tree structure without wrapping our head
    around it. This, in my opinion, is the advantage of using `QDomDocument` instead
    of `QXmlStreamReader`.
  prefs: []
  type: TYPE_NORMAL
- en: We can then add attributes to an element by calling `QDomElement::setAttribute()`.
    We can also create a text node by calling `QDomDocument::createTextNode()` and
    appending it to any of the elements in the XML structure.
  prefs: []
  type: TYPE_NORMAL
- en: After we are done structuring the XML data, we can then output all the data
    in the form of text to the `QTextStream` class and allow it to save the data into
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google's Geocoding API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to obtain the full address of a specific
    location by using Google's Geocoding API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a program that utilizes the Geocoding API by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new **Qt Widgets Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open up `mainwindow.ui` and add a couple of text labels, input fields,
    and a button to make your UI to look similar to this:![How to do it…](img/B02820_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up your project (`.pro`) file and add the network module to
    your project. You can do that by simply adding the `network` text after `core`
    and `gui`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open up `mainwindow.h` and add the following headers to the source code,
    right after the line `#include <QMainWindow>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare a slot function manually and call it `getAddressFinished()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after that, declare a `private` variable called `addressRequest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once you are done with that, open up `mainwindow.ui` again, right-click on the
    **Get Address** button, and select **Go to slot…**. Then choose the **clicked()**
    option and press **OK**. A slot function will now be added to both the `mainwindow.h`
    and `mainwindow.cpp` source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open up `mainwindow.cpp` and add the following code to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add the following code to the `getAddressFinished()` slot function
    we declared manually just now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the following code to the `clicked()` slot function created by
    Qt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the program now and you should be able to obtain the address by
    inserting the longitude and latitude values and clicking the **Get Address** button:![How
    to do it…](img/B02820_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try with longitude `-73.9780838` and latitude `40.6712957`. Click the
    **Get Address** button and you will see the following result in the application
    output window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I won't be able to tell you exactly how Google obtains the address from its
    backend system, but I can teach you how to request the data from Google by using
    `QNetworkRequest`. Basically, all you need to do is to set the URL of the network
    request to the URL I used in the previous source code and append both the latitude
    and longitude information to the URL. After that, all we can do is wait for the
    response from the Google API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do notice that we need to specify XML as the desired format when sending the
    request to Google; otherwise, it may return the results in JSON format instead.
    This can be done by adding the `xml` keyword within the network request URL, as
    highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When the program the received the response from Google, the `getAddressFinished()`
    slot function will be called and we will be able to obtain the data sent by Google
    through `QNetworkReply`.
  prefs: []
  type: TYPE_NORMAL
- en: Google usually replies with a long text in XML format, which contains a ton
    of data we don't need. We used `QXmlStreamReader` to parse the data because in
    this case we don't have to care about the parent-child relationship of the XML
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: All we need is the text stored in the `formatted_address` element in the XML
    data. Since there is more than one element by the name of `formatted_address`,
    we just need to find the first one and ignore the rest.
  prefs: []
  type: TYPE_NORMAL
- en: You can also do the reverse by providing an address to Google and obtain the
    location's coordinate from its network response.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google's Geocoding API is part of the Google Maps APIs Web Services, which provides
    geographical data for your map applications. Besides the Geocoding API, you can
    also use their Location API, Geolocation API, Time Zone API, and so on to achieve
    your desired results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information regarding the Google Maps APIs Web Services, visit this
    link: [https://developers.google.com/maps/web-services](https://developers.google.com/maps/web-services)'
  prefs: []
  type: TYPE_NORMAL
