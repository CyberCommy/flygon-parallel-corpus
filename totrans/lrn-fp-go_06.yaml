- en: Applying FP at the Architectural Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Functional programming (FP) books only talk about the code level benefits
    but FP principles provide better returns when applied at the architecture level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss some architectural styles that are based on
    the same ideas and philosophies of FP.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also build a layered application that solves the problem of circular dependencies
    with the aid of Inversion of Control (IoC) to control the flow of logic. The application we
    build allows an admin to move files between two cloud storage service provider
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goals in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the basics of systems engineering and application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss architecture styles that carry the same ideas of FP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent cyclic dependency errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to apply the Hollywood Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the difference between the observer pattern and dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use IoC to control the flow of logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a layered application  architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an effective table-driven framework to test our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss where FP and Go fit into microservice architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Four years ago, I posted an article entitled *Application Architecture Considerations*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5df67aaa-0d02-420a-bdfd-7501dc11430a.png)'
  prefs: []
  type: TYPE_IMG
- en: I had talked about things to consider when evaluating an application's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: For a list of things to consider when designing an application architecture,
    see [http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html](http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these things are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functionality**: Does the application satisfy its business requirements?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Does the application run fast enough? For example, if there
    are any views that take longer than 7 seconds to display, then you need to re-engineer
    something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: How well does your application scale? Can you easily add and
    remove components without affecting your application''s performance or reliability?
    How loosely (or tightly) coupled is your application code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was all high level, mainly discussing nonfunctional requirements and cross-cutting
    concerns, for example, security, error handling, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you are only interested in pure functional programming techniques, you can
    safely skip this chapter. However, if you want to build an application framework
    in which you can place pure function programming components, this will be a good
    chapter for you.
  prefs: []
  type: TYPE_NORMAL
- en: What is software architecture?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Designing software architecture is the process of defining a structured solution
    to address our application's user, business, and system requirements. In each
    case, we must ask, "*What do you need?*" that is, the requirements, and "*Why
    do you need it?*" and document our understanding in a way that the business stakeholders
    understand. Finally, we must implement the "*How?*"*:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29ed662c-f1e7-4ba5-89ee-cb545092e2bc.png)'
  prefs: []
  type: TYPE_IMG
- en: The art of software architecture lies in the ability to understand what is important,
    to make the key decisions in structuring application components and their interfaces,
    and to make the right decisions regarding things that are hard to change.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas the *Application Architecture Considerations *article focused mainly
    on the "*What?*", this chapter focuses on the "*How?*" using Go.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client-server model could be implemented as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ba1004c-b858-4403-a165-bb79ef3c1b4d.png)'
  prefs: []
  type: TYPE_IMG
- en: In our example, the client goes through a load balancer to talk to an application
    server's API. Each application server uses a database API client to interact with
    the database. The small, unlabeled boxes represent an API client. Some clients
    communicate directly to their server, for example, our database client. Others,
    like our application server client, go through intermediaries that provide services,
    for example, load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: APIs expose the functions that are available and define the requirements that
    govern how applications or services can talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we move into cloud-based architectures, our systems begin to look more like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0951a5ea-bd78-4cb4-9898-06ed4ba89f67.png)'
  prefs: []
  type: TYPE_IMG
- en: What do both the client/server and cloud architectures have most in common?
  prefs: []
  type: TYPE_NORMAL
- en: See all the APIs that expose the functionality of the underlying resources?
  prefs: []
  type: TYPE_NORMAL
- en: Go is well suited for server-side applications, that is, everything in the virtual
    network (the big gray box). That's pretty much the entire cloud infrastructure
    and everything running within it.
  prefs: []
  type: TYPE_NORMAL
- en: That's great for the big picture, but what about building applications? How
    much do APIs come into play when building an individual Go application?
  prefs: []
  type: TYPE_NORMAL
- en: It depends. Are we talking about a small utility application or an enterprise
    CRM application?
  prefs: []
  type: TYPE_NORMAL
- en: The interface to a small utility application can simply be defined by the command-line
    parameters that it accepts.
  prefs: []
  type: TYPE_NORMAL
- en: Large **customer relationship management** (**CRM**) applications will be composed
    of layers of functionality, not unlike the virtual network diagram we saw earlier.
    For example, the opportunity management system will need an API to the quote generation
    and electronic signatures components. The service and provisioning system will
    need API access to the billing and invoicing system.
  prefs: []
  type: TYPE_NORMAL
- en: If we intend to build large, complex applications, we must put effort into architecting
    our solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Why does architecture matter?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like large buildings, complex software applications must be built on a
    solid foundation. In software, we sometimes call this our application framework.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not consider the things mentioned in my article; things like functionality,
    security, extensibility, testability, and performance, then we will likely be
    unprepared for the consequences of our lack of forethought.
  prefs: []
  type: TYPE_NORMAL
- en: Our exposure to risk will increase as we find our application becomes more costly
    to test, deploy, and maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: Design takes some time and effort, but it does not take long before that effort
    pays off.
  prefs: []
  type: TYPE_NORMAL
- en: The role of systems engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Systems engineering is a discipline that focuses on the design and application
    of the whole  system, which may be comprised of many parts.
  prefs: []
  type: TYPE_NORMAL
- en: Real systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A real system includes things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IT system specialty groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Systems engineering focuses on identifying requirements early in the development
     life cycle. It considers the entire problem space. Taking all aspects and variables
    into account and relating the social to the technical aspects. Then it  proceeds
    with design synthesis, integrating  all the specialty groups such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disposal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manufacturing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process Improvement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Risk Assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Into a team effort in a structured development process that proceeds from concept,
    design synthesis, validation, deployment to production and operation.
  prefs: []
  type: TYPE_NORMAL
- en: Systems engineering is lean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Systems engineering is all about creating more value for our customer with fewer
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: A lean IT department understands its customer’s business and what  customer
    value means and focuses its efforts to continuously increase it. The goal is to
    provide maximum value to the customer through a perfect value creation process
    that has zero waste.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your customer sells chicken to consumers, then every new project
    must start with this question: Will this project help our customer sell more chicken?'
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, lean thinking changes the focus of management from optimizing
    separate technologies, and vertical departments to optimizing the flow of products
    and services through entire value streams that flow horizontally across technologies
    and departments to customers.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating waste along entire value streams, instead of at isolated points,
    creates processes that requires less human effort, less capital, and less time
    to make products and services at far less costs and with much fewer defects, compared
    with traditional business systems. Lean companies are able to respond to changing
    customer desires with high variety, high quality, low cost, and with fast throughput
    times. Information management becomes simpler and more accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements, scope and terms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everytime we develop software, we address both the business and technical needs
    of our customer with the goal of providing a quality product that meets our users’
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Some requirements are task-specific. For example, if we are required to write
    a script to move a specific log file from one server to another. Other times,
    we need may be required to write a command line input tool to parse the text a
    user types in their console input and count the characters, words, or lines they
    entered. This chapter is not about those types of applications. We'll consider
    system-level requirements only in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Defining terms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by defining a few terms.
  prefs: []
  type: TYPE_NORMAL
- en: Software requirements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Conditions or capabilities needed by our customer to achieve an objective/solve
    problem(s).
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An integrated set of subsystems and/or elements that accomplish a defined objective.
  prefs: []
  type: TYPE_NORMAL
- en: System architecture
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The fundamental properties of a system in its environment embodied in its subsystems,
    elements, relationships along with the principles of its design and evolution.
  prefs: []
  type: TYPE_NORMAL
- en: System elements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Atomic**: elements that cannot to be broken down further'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decomposable**: elements that can to be broken into smaller elements'
  prefs: []
  type: TYPE_NORMAL
- en: System Boundaries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Defines the scope of a system, creating a distinction between the system and
    the environment in which a system exists.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As systems engineers, we must build and integrate elements and subsystems to
    achieve a desired objective. There can be a lot of moving parts: various APIs
    and communication protocols, various data schemas, various security interfaces
    to traverse. Our biggest challenge is, How do we manage all this complexity?'
  prefs: []
  type: TYPE_NORMAL
- en: The best tool for the job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best tool we have  to help manage complexity is composition. Functional
    programming to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88c7e88d-a180-4369-9677-04f62ba0d016.png)'
  prefs: []
  type: TYPE_IMG
- en: Our job is to decompose the elements of our system into atomic parts, fit them
    back together into subsystems and wire them together in a distributed, microservice
    based environment.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know when have we sufficiently decomposed an element?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: When we can treat the element as a black box, i.e., when we do not need
    visibility into the function to understand what it does.'
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FP gives us the tools and techniques we need to divide our monolithic applications
    into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24bc395c-1782-4053-bcab-56fdabd93f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=220&action=edit), *SOLID
    Design in Go*, we learned that our applications should be built from components
    that follow the Unix philosophy of doing one thing well. We follow the same precepts
    when building microservices. Furthermore, following the **Single Responsibility
    Principle** (**SRP**) we treat each microservice as a separate entity that, whose
    entire life cycle is kept separate within its predefined boundaries. This decoupling
    of our microservices is what allows us to create, move and restart our microservice,
    isolated from its surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: '"This is the Unix philosophy: Write programs that do one thing and do it well.
    Write programs to work together." - Doug McIlroy'
  prefs: []
  type: TYPE_NORMAL
- en: Designing for state management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, we find that application APIs are designed properly, giving the illusion
    that the application services are stateless. However, upon closer examination
    we find problems with their architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Add a microservice
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When they add one microservice it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e78e4af-cf17-4557-8161-284b5c440471.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When they add two more it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23cb1b16-c084-4904-8d00-b1f007595ff3.png)'
  prefs: []
  type: TYPE_IMG
- en: They are feeling good about their architecture until they launch their application
    and onboard users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problems begin to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data integrity issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than creating a stateless architecture, what really happened was that
    they pushed their application state down to a single database, which only complicated
    their issues.
  prefs: []
  type: TYPE_NORMAL
- en: All of their so supposedly stateless microservices are now coupled to the single,
    shared monolithic database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a224d3ec-6fdb-4b15-8313-5cd736de0213.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what they should have designed...
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4e5e9a3-5bac-4504-a254-d050e3896eb5.png)'
  prefs: []
  type: TYPE_IMG
- en: … where each microservice owns their own data. Lookup tables can be shared and
    managed with database replication, but the data in their domain remains isolated.
  prefs: []
  type: TYPE_NORMAL
- en: FP influenced architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss a few popular architectures that borrow ideas from FP.
  prefs: []
  type: TYPE_NORMAL
- en: Domain driven design (DDD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event based architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional reactive architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with DDD.
  prefs: []
  type: TYPE_NORMAL
- en: Other names for DDD include Hexagonal Architecture, Clean Architecture, Ports
    and Adapters, Onion Architecture and Applicative-Style-Architecture. We'll call
    it DDD or layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Driven Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create good software, we must understand our customer's business.
    We  cannot create a prospect management software application unless we have a
    good understanding of how a sales pipeline works; We must understand the domain
    of sales. This is what **Domain-Driven Design** (**DDD**) is about. Look for layered
    application architecture diagram later in this chapter. What's in the center?
  prefs: []
  type: TYPE_NORMAL
- en: A firm understanding of our business domain and our requirements is the key
    to successfully engineering a system solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this model we consider two main layers. The inside, with applicative use
    case handlers, and business domain logic and the outside, with all our infrastructure
    code, with database connections, and messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Combining this model with the dependency inversion principle which states that
    high level modules should not depend on low level modules. We see that our dependencies
    should always point inwards towards the domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: Interactions between those two areas are achieved by ports and adapters. Clients
    requests or events arrive from the outside world at an API port and the technology
    specific adapter converts it into a function call or message that can be passed
    into the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One issue that we soon face when building large Go applications is how to manage
    our dependencies. The larger your Go application gets, the more likely we are
    to encounter cyclic dependency errors unless our design accounts for the dependency
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: What is the dependency rule and why does the Go compiler deem it so important?
  prefs: []
  type: TYPE_NORMAL
- en: The dependency rule says that source code in a lower-level layer can make use
    of code in higher-level layers yet higher-level layers may not make use of code
    in lower-level layers. Dependencies may only point in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between a lower-level and a higher-level layer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8292b65d-715d-46eb-98f2-073248ba93de.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll see the code above in action later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In functional terms, the dependency rule says that if function `A` (from package
    `A`) calls function `B` (from package `B`), then function `B` cannot call any
    function from package `A`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the flow of application control could go in nearly any direction (between
    packages).
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, when writing a CRM application, we might find that our marketing
    campaign component may need to reference a function in our opportunity component.
    If our opportunity component needs to reference a function in our campaign component,
    then we could experience a circular dependency error.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A cyclic dependency is a compilation error in Go. It indicates that our code
    has broken the dependency rule. It occurs when a package imports another package
    that in turn imports the original package. This can occur from package `A` to
    `B` to `A` or any combination that results in package `A` getting imported anywhere
    down the call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Working code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let''s look at some example code to illustrate this concept. First, let''s
    look at the working code. The `packageb` package has one, simple public function
    and no imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dependency-rule-good/src/packagea/featurea.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `packagea` package has one, simple public function and imports `packageb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our main function where we run `Atask` from `packagea`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Code with cyclic dependency error
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This time, we will import `packagea` into `featureb.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `featurea.go` file remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main.go` file also remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We violated the dependency rule when we imported `packagea` into `featureb.go`.
  prefs: []
  type: TYPE_NORMAL
- en: The Golang difference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you have spent most of your time up to now programming in other languages
    such as Ruby, you may be surprised when you get cyclic dependency errors.
  prefs: []
  type: TYPE_NORMAL
- en: Why are there no cyclic dependency errors in a language like Ruby?
  prefs: []
  type: TYPE_NORMAL
- en: First, Ruby is an interpreted language, so we will never get a compile error.
    Furthermore, Ruby determines the scope by namespaces. As long as Ruby has a unique
    reference to a block of code and that code has been loaded into memory, there
    should be no dependency reference errors.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean Ruby is better than Go in this respect?
  prefs: []
  type: TYPE_NORMAL
- en: It depends. Do we want to develop as quickly as possible without concerning
    ourselves with the dependency rule? Do we expect our application to grow complex
    over time? Do we want to put more time into design at the beginning of our project?
  prefs: []
  type: TYPE_NORMAL
- en: Go not only encourages us to write better code, like this instance, Go makes
    us write better code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution for cyclic dependencies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How can we write Go code that adheres to the dependency rule and still reflect
    multi-directional flow of control that we frequently encounter in a business application
    logic?
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish this using a layered architecture, an interface-driven development
    and a form of the Hollywood Principle called dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Driven Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use a layered domain driven architecture as a tool for structuring our
    large-scale functional programs in a modular and composable manner. This architecture
    helps us visualize the separate application concerns and enables us to write Go
    code whose source code dependencies only point inwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'All references, that is, import statements must point inwards. An import **domain**
    statement can be found in all other packages. Import **use cases** can be found
    in the **interfaces** and **infrastructure** packages. Import **interfaces** can
    be found in the **infrastructure** package and no package (except the `import_test`
    package that we''ll cover later) is permitted to import the **infrastructure**
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b31599a9-1361-4d6b-9199-f8698d12f332.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram is somewhat of a paradox. The more we move inwards, the
    higher level our software becomes. The **domain** entities are high-level concepts.
    Whereas, the more we move outwards, the more low-level our software is. The **infrastructure**
    is where we interact with the filesystem, cloud provider, or other data repositories,
    for example, databases or cloud storage.
  prefs: []
  type: TYPE_NORMAL
- en: When we adhere to the dependency rule, our source code dependencies only point
    inwards. Our system becomes highly cohesive, that is, components with closely
    related responsibilities are separated into the appropriate layer, thereby increasing
    cohesion. By programming to interfaces and leveraging dependency injection, we
    create a loose coupling that enables us to swap out pieces of the system without
    affecting other components.
  prefs: []
  type: TYPE_NORMAL
- en: Interface-driven development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall the following quote from [Chapter 4](../Text/Ch04.xhtml), *SOLID Design
    in Go*?
  prefs: []
  type: TYPE_NORMAL
- en: '"It makes sense to categorize a thing by its abilities, because everything
    is defined by its actions."'
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a book about functional programming, now would be a good time
    to mention that a major benefit of using interfaces is that they allow us to group
    our application's functions in order to model real-life behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we modeled the behavior of a duck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we will look at manipulating files in the **Google Cloud Platform**
    (**GCP**). Our interface defines the four behaviors of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's not get confused with the `interface` terminology. We just spoke about
    a Go interface, whereas when we talk about the interface layer in a layered architecture
    that is a way of layering our application into separate, cohesive concerns.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on the mechanics of how we accomplish this task using
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: What are our best options for decoupling dependencies between high-level and
    low-level layers?
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at two-candidate solutions, the observer pattern and dependency injection
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Hollywood principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Actors suffer through crushing blows of humiliation in their quest to climb
    one step higher in the Hollywood hierarchy. Who determines whether an actor winds
    up as a stage hand or Brad Pitt? The casting director.
  prefs: []
  type: TYPE_NORMAL
- en: Actors audition for a part in a movie and are advised not to ask whether they
    got the part. The fact is that if the director wants you, he'll find you. That's
    the Hollywood principle of "*Don't call us. We'll call you"*.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional programming, the actor would audition and then ask the director
    if they got the part. That's not how the Hollywood Principle works.
  prefs: []
  type: TYPE_NORMAL
- en: What is required for this inversion of control?
  prefs: []
  type: TYPE_NORMAL
- en: We require an API that exposes public functions and a framework where dependent
    components are bound to a subject during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: What are our framework options?
  prefs: []
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The observer pattern is one option. It works by injecting a callback object
    (observer) into the subject to be observed. The subject simply raises an event
    in all observers when its state changes.
  prefs: []
  type: TYPE_NORMAL
- en: How the observer reacts to the event is outside the scope or care of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91a989bf-e1a9-41c1-95c5-e74222c2c803.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s an implementation of that pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The observer implements the `Callback` interface. We implement a `Notify` method
    for the observer receiver. `Notify` is the observer''s callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The subject implements three methods: `AddObserver`, `DeleteObserver`, and
    `NotifyObservers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `AddObserver` method is where the subscription, that is, the relationship
    between the observer and the subject occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `NotifyObservers` method acts as a simple service locator. It iterates through
    its list of subscribed observers and executes its callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When we remove the observer from our service locator by executing  `subject.DeleteObserver(&Observer{})`,
    all subsequent notifications have no effect since there are no observers subscribed
    to respond to the published events.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**) is a form of Inversion of Control and also
    impacts the flow of control in an application. Although the observer pattern''s
    callback mechanism can modify the flow at many times and in many places in an
    application, DI typically performs the flow of control configuration during application
    initialization.'
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter is mainly about a layered architecture and the management
    of dependencies to prevent circular dependency errors, we will not explore pub/sub
    architectures and the observer pattern. Instead, we will choose DI to reconcile
    our dependencies in our main function.
  prefs: []
  type: TYPE_NORMAL
- en: A cloud bucket application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pictures are worth a thousand words, right? Let's use some diagrams to help
    describe our basic application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see the high-level architecture of our application that we'll
    call `onion`. (An onion has layers, so we'll use that metaphor to remind us of
    the layers.)   It moves files from the **SOURCE Cloud Bucket** to the local filesystem
    and then to the **SINK Cloud Bucket**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purple API box in the following diagram represents the web services API
    that our `onion.go` application exposes for the administrative user. The red API
    represents the Google Cloud Platform storage API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cef5c64-f499-4839-8e76-b5866b134ea9.png)'
  prefs: []
  type: TYPE_IMG
- en: The admin will direct the `onion.go` application to download a log file from
    the **SOURCE Cloud Bucket** to the local filesystem. The admin can subsequently
    tell `onion.go` to upload the file to the **SINK Cloud Bucket**.
  prefs: []
  type: TYPE_NORMAL
- en: The purple paths, for example, `/health`, `/list-source-buckets`, and `/list-sink-buckets` are
    the web service APIs that our onion application exposes to the administrative
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The directory structure of our application looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The source code for our project is `main.go`, which lives in the project root.
    The rest of our application is separated into directories corresponding to our
    application's architectural layers (domain, use cases, interfaces, and infrastructure).
  prefs: []
  type: TYPE_NORMAL
- en: Before looking into the details of the other layers, let's see how we tie them
    together. That work is done in our `main.go` file. We start by initializing our
    configuration options with `GetOptions()`.
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s have a look at the contents of `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We direct `Debug` statements to standard out if our  `log_debug_info` setting
    is true; otherwise, we discard them. We hardcode the name of the log file for
    simplicity, but we could have used a config value or a function call to dynamically
    generate the filename.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in our `init` function is to change our application's working
    directory to our project root directory. If there is an error doing so, the `HandlePanic()`
    function from our `utils` package will display a stack trace for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We find the `HandlePanic()` function in our utils package. Unlike most functions,
    we do not return an error from `HandlePanic()`. We handle it by adding the filename
    and line number of the source code file where the error originated and alert.
  prefs: []
  type: TYPE_NORMAL
- en: func HandlePanic
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is our `HandlePanic()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that we import our utils package by prefacing it with a
    period like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to reference public functions (starting with capital letters)
    without including the `utils` package name.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the decorator chapter, we looked at inversion of control. We saw how a decorator,
    for example, the **FaultTolerance**, can be injected into the flow (of main) by
    our decorator framework using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47b40c88-4039-48cb-91c5-69952c4b9869.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use the same concept of dependency injection to wire up our application
    and to provide control over function calls and the data that flows between our
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember our electrician analogy? This is a great time to revisit the concept.
    Our work is much like the electrician who first turns off the power to the house:
    who lays the wires and subsequently turns the power on. After the power is turned
    on, our electrician can test the switches to verify that the home''s electrical
    system has been wired properly.'
  prefs: []
  type: TYPE_NORMAL
- en: We create the interfaces that connect the layers of our application. In the
    main function we instantiate our interactors. Our interactors use the interfaces
    through which we call functions and thereby control the flow of data between the
    parts of our loosely coupled system.
  prefs: []
  type: TYPE_NORMAL
- en: We have two interactors--one for interacting with the Google Cloud Platform,
    the `GcpInteractor`, and the other, `LocalInteractor`, for reading and writing
    files to the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: func main()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s go through the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We inject both our interactors into our web service handler, which allows our
    admin user to manipulate our repositories via our public web service APIs, for
    example, `/list-source-buckets`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that DI occurs at object creation time. Contrast DI with parameterized
    functions or the use of a context--that contains all pertinent information for
    a single function invocation—that can be passed through a chain of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: DI typically occurs once during the lifetime of an application. Parameterized
    functions and the passing of context, occurs many times.
  prefs: []
  type: TYPE_NORMAL
- en: Layers in the architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are building an application framework based on a layered achitecture that
    will allow us to grow our application with less difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: After building a solid application framework based on a layered architecture,
    we'll return to pure functional programming topics and techniques in subsequent
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will separate our Onion application into four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss them in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Domain layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the layers in our layered architecture. The
    arrow indicates that we only import packages in one direction. Domain will never
    import from use cases, interfaces, or infrastructure. The red background in the
    **domain** layer indicates that we''re looking into that layer in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa399ec9-f454-4fe4-aa0a-52276702dca1.png)'
  prefs: []
  type: TYPE_IMG
- en: The **domain** layer is where we define our business entities. These are the
    core business objects that we would initially think of when defining the essence
    of what our application does.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our following type definitions, we quickly glean that our application
    moves files to and from buckets of a cloud storage provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `LocalRepository` and `BucketRepository` do not refer to specific implementations.
    The **domain** layer does not care whether the bucket is Google bucket or an AWS
    bucket. The term repository is used. To the **domain** layer a repository is just
    a place in which files are persisted and retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let’s look at the contents of the log files we’re moving
    around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `.jsonl` file comprises three JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of each line is defined in our `domain/log_file.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We define one function to convert our JSON text into a Go struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a method to operate on a `LogFile` object, transforming it into a
    JSON text representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that in both cases we wrap the underlying error with our own
    more specific error message before returning the error to our function’s caller.
  prefs: []
  type: TYPE_NORMAL
- en: The fewer packages our application references the easier the job will be to
    maintain our application. Third-party packages can be frequently updated, which
    is usually a good thing, for example, if they fix a security issue, but can be
    a bad thing for our application if they change their public interfaces in such
    a way as to break our application.
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/pkg/errors` package is one of the few packages that is worththe
    trouble. It allows us to add context to the error message without changing or
    hiding the original error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Package errors ([https://github.com/pkg/errors](https://github.com/pkg/errors))
    provide simple error handling primitives. You can also refer to: [https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Write` method allows us to write the content of a `LogFile` object to
    disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In `file.go`, we define our `File` struct, which comprises file attributes.
    For example, filename and bytes. It also has the `LogFile` defined as an embedded
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define structs for manipulating the `.jsonl` files that we receive
    from (and send to) GCP buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file.go` file also contains the following functions for manipulating a
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewFile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NameOnly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exists`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Read`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `api.go` file defines the structs we use to communicate whether a file
    exists or whether operations performed on our files were successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use cases layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s look at the use cases layer now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2708c46e-6efc-467b-84e8-a2b795e7bc3f.png)'
  prefs: []
  type: TYPE_IMG
- en: The use cases layer has to do with what the user wants to do, that is, their
    use cases for using this application.
  prefs: []
  type: TYPE_NORMAL
- en: It references the repositories, local filesystem, and the source and sink buckets
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: We can directly reference domain entities and we can reference interface entities
    via the local and GCP interactors.
  prefs: []
  type: TYPE_NORMAL
- en: If we can reference an infrastructure entity in any way, then our design is
    broken. For example, we should be able to swap out the Google Cloud Platform storage
    APIs with AWS S3 bucket APIs and without our use case layer changing in any way.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, a user may want to check whether a local file exists or
    get the file, in order to upload it to a bucket in GCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalInteractor` struct controls the flow to and from the local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GcpInteractor` struct controls the flow of files and information regarding
    files in a cloud bucket. *Doing things* with buckets includes things such as listing
    the files in a bucket, checking whether a file exists, uploading, and downloading
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There are two types of buckets. One acts as a source of files and the other
    acts as the sink (or destination) for files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can reference the `BucketRepository` struct from the `usecases`
    package, but there will be no reference to `usecases` in any file in the `domain`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GcpInteractor` methods in `usecases.go` define the use cases for manipulating
    files in our Google Cloud account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DownloadFile` and `UploadFile` methods are arguably our most important
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The logic in this layer is very lean. When we develop more complex applications
    that have business rules to enforce, these use cases would likely be the best
    place to put them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we had implemented security in our application, we could define
    the following rules as:'
  prefs: []
  type: TYPE_NORMAL
- en: Only users in the sink group or above can list the files in a sink bucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only users in the `source-downloads` group can download files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only users in the `super-admins` group can upload files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we'd likely put our authorization logic here in the use cases layer.
  prefs: []
  type: TYPE_NORMAL
- en: Compatible interfaces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order for the dependency injection to work, our application must have compatible
    interfaces, for example, `FileExists(fileName string) (fileExists bool, err error)` 
    in `domain.go` and `gcphandler.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line `return interactor.SourceBucketRepository.FileExists(fileName)` is
    delegating the `FileExists` behavior to the interface, which is implemented by
    `gcphandler.go` and then injected into the interactor. Below, we define our interface
    for our BucketRepository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BucketRepository` interface is compatible with the `GcpHandler` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s not forget the wiring up that occurred in main, that associated the
    `/source-file-extsts` URL end point with the `GcpInteractor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the crux of the framework that performs the dependency injection and
    allows us to write code that spans the layers of our application without violating
    the dependency rule.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we will be looking at the interfaces layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d2a4bfd-ac95-4061-944f-cccb6fc0f977.png)'
  prefs: []
  type: TYPE_IMG
- en: The interfaces layer provides a means to communicate with external repositories,
    for example, cloud bucket or local files storage. If our external repositories
    need to communicate events back to our application, for example, out of disk space,
    these events would flow through this interfaces layer.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by defining our interface, that is, the functions that our interfaces
    layer supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file contains handlers for interfacing with the **Google Cloud Platform’s**
    (**GCP**) storage API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To simplify our implementation, we’ll only define one `GcpHandler` interface
    for both source and sink buckets. The consequence is that `DownloadFile` will
    be available, but not useful for the sink bucket and `UploadFile` will not be
    useful for the source bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a structure in which we can register our interface handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have two types of GCP repositories. A source bucket and a sink bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we provided the interface that satisfies the needs of the use cases.
    In the following code, we implement the code that injects that actual implementation
    (at run time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How can the code above be improved?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our NewSinkBucketRepo function could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See the difference? Note that, unlike in C, it's perfectly OK to return the
    address of our local variable `SourceBucketRepo`.  When we return our `SourceBucketRepo`
    composite literal, the expression is evaluated  and Go will allocate a fresh instance
    of `SourceBucketRepo`. So, the storage associated with our `SourceBucketRepo`
    variable will survive after our `NewSourceBucketRepo` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for wiring up the injection to handle the sink bucket dependencies
    is very similar to the source bucket code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The local storage interface is similar to the GCP bucket interface. Both have
    a means to check whether a file exists and to retrieve a file. We have added some
    logic that shows that this would be a good place to implement a caching mechanism
    in order to increase performance (at the expense of additional RAM requirements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We see the same dependency injection logic in the `NewLocalRepo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we implement the `FileExists()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to implement file caching, we could create a `FileCache` global
    variable in the interfaces layer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We could initialize it in the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: But if we did, what else should we do?
  prefs: []
  type: TYPE_NORMAL
- en: What if two requests occur at the same time to upload a file? What could happen?
  prefs: []
  type: TYPE_NORMAL
- en: What if we implemented a `DeleteFile` function?
  prefs: []
  type: TYPE_NORMAL
- en: Some form of resource locking and race condition mitigation would be needed.
  prefs: []
  type: TYPE_NORMAL
- en: The big win for us is that now we have a place to put this caching logic. The
    layering helps when the time comes to extend our application's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll have a look at the `interfaces/webservice.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define an `Api` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We've seen how we used the `Api` struct to associate our application endpoints
    with their corresponding web service implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.go` file defines an `enpoint` struct that embeds this `Api` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In main, we initialize the `endpoints` slice with our web service endpoint
    (handler and URL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Later in main, we iterate through our endpoints and associate our URLs with
    their respective handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a `printApiExample()` helper function to print the following in
    our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define our interactor interfaces. There is only one for our local
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We define five interfaces for our GCP buckets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `WebserviceHandler` struct to provide access to both local files
    and cloud bucket files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '**Health API**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Health is a useful, simple utility web service, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want the JSON results, it is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we only need the HTTP header status code, it is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**File exists APIs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a web service method for checking whether a local file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s one for checking whether a file exists in our source cloud bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Extending functionality**'
  prefs: []
  type: TYPE_NORMAL
- en: We could easily extend our application by adding `WebserviceHandler` methods
    that could access both source and sink buckets as well as the local filesystem,
    all in the same function invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Our design using interfaces is flexible in other ways, too. For example, using
    a testing configuration setting when starting our application we could instruct
    our application’s main function to use a test mock implementation when wiring
    up the interactors. This could enable our tests to interact with a speedy test
    stub bucket interface that provides canned responses to test the control flow
    within our application rather than taking time to initialize connections and deal
    with the latency of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll look at the `interfaces/webservice_helpers.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `sf` variable to be the `fmt.Sprintf` function. This allows
    us to abbreviate our code, replacing `sf` with `fmt.Sprintf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define one of the few global variables in our application. This is
    the standard response we return to the web clients when an error is encountered.
    This value never changes. So, it is for all intents and purposes a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we implement a function to determine the format of the
    data to return to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Granted, we’ve hardcoded the value to `json`, but we could have just as easily
    pulled the value from a query parameter. The idea to remember is that we use a
    function to return this value. The value returned from the function can change
    from one request to the next. We do not need to write code to synchronize results
    to ensure that each format returned corresponds properly with each request. Neither
    do we need data modification locking logic nor do we need to write code to prevent
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: What if we had defined format to be a global string? What errors might that
    cause? Could we use it to scale this application horizontally?
  prefs: []
  type: TYPE_NORMAL
- en: The general rule is, only if a value is constant, use a global reference. Otherwise,
    we should return all results via a function call. Why? Because using global variables
    that change makes our application state unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: Why global variables are bad
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*, we
    briefly discussed immutable variables, but did not dive much into why they are
    so bad. Let's do that now that we have a concrete example in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional impurity**'
  prefs: []
  type: TYPE_NORMAL
- en: Also covered in [Chapter 1](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=362&action=edit#post_47), *Pure
    Functional Programming in Go*, pure functions always return the same result, given
    the same inputs and never have side effects. Global variables cause any function
    that references it to be impure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code complexity and bugs**'
  prefs: []
  type: TYPE_NORMAL
- en: Global variables by definition are available to a number of functions. It quickly
    becomes difficult to understand the cause and effect aspects of program flow when
    a function behaves differently based on its value and other functions are changing
    that global value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance and race conditions**'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable global variables require a locking mechanism to allow only one function
    at a time to update its value. This is often difficult to program and frequently
    results in race conditions, where a number of functions, that want to update the
    global variable, must wait in line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing difficulties**'
  prefs: []
  type: TYPE_NORMAL
- en: Testing must take into account the value of global variables. This typically
    means that each tester must be aware of the global variable's existence, it's
    permissible values, and do the work of initializing the global variable's value
    prior to running each test.
  prefs: []
  type: TYPE_NORMAL
- en: Format the response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In each web service request handler, we use the `setFormat` function in conjunction
    with the `getFormat` function to format the response data. We are simply using
    JSON in our example code, it is easy to see how we could extend our implementation
    to include formats such as XML and CSV.
  prefs: []
  type: TYPE_NORMAL
- en: '(We''re still in `interfaces/webservice_helpers.go`.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The handler helpers are similar in format. Let’s first look at how we handle
    a success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: Our function signature contains seven arguments. That’s a lot, which makes it
    a likely candidate for a refactoring. In the next chapter, we’ll study how we
    can simplify complex APIs by passing functions instead of simple values.
  prefs: []
  type: TYPE_NORMAL
- en: Since `debugMsg` and `msg` are both strings, they share a single `string` declaration.
    Similarly, `err`, `error`, and `success` are all of the type `bool`; `bool` only
    needs to be typed once after the list of bool arguments. This is idiomatic Go.
    It is a style of programming, unique to Go, that helps us write simpler, more
    easily understood code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `handleSuccess()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `handleSuccess()` function is called by the `SourceFileExists()` function
    in `webservices.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with a `Debug.Printf` statement. It takes the first parameter from
    a web service handler method such as `SourceFileExists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s worth noting that the `sf` function is defined as a function variable
    at the top of our `webservice_helpers.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Prior to calling our `handleExists` helper function, we pull the `fileName`
    value from a query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we call `exists, err := handler.GcpInteractor.SourceFileExists(fileName)`
    ?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the series of function calls that will eventually return our results.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we visit `usecases.go` in the `usecases` layer. The `SourceFileExists`
    is a `GcpInteractor` method linked to `SourceBucketRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'That call to `FileExists` brings us back the interfaces layer and calls the
    `FileExists` method in the infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**The /source-file-exists API flow of control**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following chart and the upcoming diagram show the call stack starting from
    main where the `SourceExists` API is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The flow of control goes from main.go to** |  | **Layer** |'
  prefs: []
  type: TYPE_TB
- en: '| `webservices.go` (`SourceFileExists`) | to | interfaces (to user) |'
  prefs: []
  type: TYPE_TB
- en: '| `usecases.go` (`SourceFileExists`) | to **1** | use cases |'
  prefs: []
  type: TYPE_TB
- en: '| `gcpstorage.go` (`FileExists`) | to **2** | interfaces (to GCP) |'
  prefs: []
  type: TYPE_TB
- en: '| `gcphandler.go` (`FileExists`) | to **3** | infrastructure |'
  prefs: []
  type: TYPE_TB
- en: '| `file.go` (`NewFile`) | to **4** | domain |'
  prefs: []
  type: TYPE_TB
- en: '![](img/23e06acf-12b0-452f-b5a8-ecb34a8c400b.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the interfaces layer is traversed twice during this API call. The
    function call to `SourceFileExists` in `webservices.go` provides the programmatic
    interface between the user that requested the `/source-file-exists` end point
    and the use cases layer’s analogous `SourceFileExists` function, which defines
    what the user wants to do. The next interface in this call stack interacts with
    the Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: '**The /source-file-exists API call stack**'
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows a single API call to the `/source-file-exists`
    web service. The call originates in main, where the web service endpoint is associated
    with the `SourceFileExists` function in `webservices.go`.
  prefs: []
  type: TYPE_NORMAL
- en: See how the flow of control moves from a user requesting a web service endpoint
    (in main) and flows upwards, from layer to layer?--`interfaces` | `use cases`
    | `interfaces` | `interfaces` | `infrastructure` | `domain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a powerful form of flow control that allows us to build complex applications,
    with many multidirectional logic flows and still adheres to the dependency rule,
    that is, we only import packages in one direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5af7d15-91b8-432b-886b-ccb50af3b818.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing our interfaces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In order to test our application, we'll create an `interfaces_test` directory
    inside our `interfaces` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Since `interfaces_test` is a different package than `interfaces`, we are unable
    to access the private functions and other symbols within the `interfaces` package.
    We are able to change our web service internals without breaking any tests. This
    also helps us focus on the API. We see just what any other client of our API will
    see when it's deployed and it simplifies our task of creating tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `testing` package from the Go standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare `fileName` and `WebserviceHandler` that we populate in our following `init()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We reuse the `Api` struct that we used in our main. Instead of associating
    our APIs with a sample URL, we associate our `Api` with `expectedBody`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need one function to test our end points. We use an anonymous struct
    and a set of composite literals to create a group to test our data together in
    a simple, readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As we iterate over our slice of endpoints, we call each `Api.Url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a `ResponseRecorder` type that satisfies the `http.ResponseWriter`
    interface to record the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our handlers implement `http.Handler`, we can call their `ServeHTTP`
    method directly and fail the test if the status code is not okay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we compare the returned response with the value we stored in the `expectedBody`
    field of endpoint (`ep`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have any errors, the output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Infrastructure layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This section will now talk about the infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4abc0fc-146a-4b1c-9bf0-75268165894a.png)'
  prefs: []
  type: TYPE_IMG
- en: The infrastructure layer is where the code that communicates with the external
    services exists, such as databases, cloud storage, or even a local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Since our code is separated into layers, we should be able to take all the functions
    from a layer and use them in a different application. The functions in our infrastructure
    layer have the least to do with our current problem domain, making them more applicable
    to other applications that need to interact with the Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: While our `source` and `sink` functions in our interfaces layer may only make
    sense to our business and what we want to accomplish, the functions in the infrastructure
    layer such as `FileExists` and `ListBuckets` are less specific and hence more
    reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of what we find in Go’s standard library, as shown in the following list,
    would belong in the infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`database/sql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log/syslog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/rpc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/snmp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/textproto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a package potentially handles interactions with external systems, then it
    likely belongs in the infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function signature is also Go idiomatic. It takes a single parameter and
    returns two values. The first is the results, while the second is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The `FileExists()` function returns `true` if the files exist in the specified
    Google Cloud provider bucket. We build a function call chain to retrieve the bucket
    reader. In Go idiomatic fashion, it returns two values--one for the bucket reader
    and the other for a potential error.
  prefs: []
  type: TYPE_NORMAL
- en: Context object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We must pass a context object that is passed to a `withContext` function that
    creates a new request object, based on the context. However, since the context
    is empty, this is what we might refer to as **code ceremony**. Note that in the
    next chapter on functional APIs we’ll cover passing request contexts in more depth.
    In this case, `ctx` is something we must pass so that our code compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `errors` package allows us to wrap our error with a specific error message
    and not lose the error message from GCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Again, we see the idiomatic return of two values—the result and the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use another idomatic Go construct using a `defer` call to close our bucket
    reader. This is yet another example of how Go helps us write better code by making
    it easy to do the right thing. In languages that do not have a `defer` statement,
    we must remember to close our connection after performing our work. With Go, we
    can grab a handle to a data reader and immediately tell the application to close
    the connection when the function exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Typically, when we encounter an error, it is best practice to wrap the error
    with a message that makes sense in context and to immediately return the error
    and whatever makes sense for the result value. In this case, since this is a call
    to `FileExists`, we return `false` if any error is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: If we make it to the last return statement, then the file in question exists
    and is of nonzero length. If the GCP API had a public `FileExists` function, we
    could call it, but this method will suffice for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We design each layer to be as simple and concise as possible. The interfaces
    layer's job is to move and possibly transform data as it flows between use cases
    and the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll look at the `infrastructure/localhandler.go` file. Since there
    is only one local filesystem in our example, we do not need to provide a key to
    register `NewLocalHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `FileExists()` function calls the standard library `os.Stat` function. All
    files in our example application will be stored in the `download` directory. Since
    the names of two return values have been defined in the `FileExists()` function
    signature, we only need to set their values where appropriate and execute a bare
    return statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetLocalInteractor` function ties its repository (the local filesystem)
    to its interfaces. Our small example has only one method, `FileExists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Granted, this is a lot of code for wiring up just one method, but a typical
    enterprise application has external persistence dependencies each with a potentially
    large number of methods. Our layered architecture provides the structure required
    to extend a large application with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, a layered architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides the structure required to extend a large application with minimal effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforces high cohesion, based on a layered approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeps components loosely coupled by managing function references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adheres to the dependency rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the Hollywood Principle by injecting dependencies during application initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application is growing large and you are having issues with cyclic dependencies,
    the layered architecture is worth your consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of DDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the benefits of DDD technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Adaptability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DDD makes adding a new ways to interact with our application easy. We simply
    add a new interactor, that is, our port/adapter, to our `WebServiceHandler`. In
    our onion.go application, we have two different ways to communicate with our application:
    the local file system and the Google Cloud Platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Sustainability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By decoupling our application business logic from the tools we are using, for
    example, Google Cloud Platform, we make it less vulnerable vendor lock-in and
    issues and dependency on services that become defunct or out dated.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The use of interactors eases the usage of mocks in order to test our applicative
    services and domain code. Tests can be written for our application service layer
    before we decide which technology (REST, Messaging, etc.) to be plugged with its
    corresponding port/adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensibility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The applicative use case layer clearly indicates our application's functional
    intentions.
  prefs: []
  type: TYPE_NORMAL
- en: A solid architectural foundation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layered architecture can form the basis for supporting additional architectural
    patterns including REST, CQRS, event driven architectures and event sourcing.
    That's why we focused on DDD.
  prefs: []
  type: TYPE_NORMAL
- en: FP and Micyoservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look hints of FP philosophies in microservices and related architecturesof 
    event driven architectures, CQRS, Lambda Architecture and  functional reactive
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architectures we will consider leverage FP philosophies in different ways
    to achieve their goals of being:'
  prefs: []
  type: TYPE_NORMAL
- en: Event driven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message passing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These architectures frequently employ fanout strategies to improve performance.
    For example, an application might have a series of requests that block while performing
    each request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d83ac674-1eb8-4779-ac18-4da55628db0f.png)'
  prefs: []
  type: TYPE_IMG
- en: If each request takes 1 second the total time required to send, receive and
    compose all responses will be 3 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'When possible, we should opt to perform each request asynchronously by fanning
    out our requests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/459d9aa2-b05d-4362-b00f-8b2b3e50cf62.png)'
  prefs: []
  type: TYPE_IMG
- en: This would reduce the time required to process all requests from 3 seconds to
    1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing takes less time which frees up our resources faster.
    This minimizes latency and reduces contention for our shared resources. We have
    just solved one of the biggest hurdles to scalability and improved overall throughput
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: All parties must participate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to reap the full benefits of non-blocking execution all parts in a
    request/response chain needs to participate in the non-blocking asynchronous call.
    If any resource, whether inside or outside the service boundary blocks, then we’ve
    got a problem.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the problem with blocking?
  prefs: []
  type: TYPE_NORMAL
- en: Usually resources provide access via a processing thread. Threads are limited.
    If all the threads are busy, subsequent requests must wait until one becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous message passing helps us focus on workflows and interaction patterns
    between our services.
  prefs: []
  type: TYPE_NORMAL
- en: Communication across boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When communicating between our independent, isolated services we can only request
    its state. Each service responds to requests with immutable data that reflects
    its current state.
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot Persistence
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each service may use different storage repository technologies such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Eventlog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RDBMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeseries DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The storage technology does not matter. What's important is that each service
    is responsible for its state, providing access to immutable data only via its
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Lambda architecture is a generic, scalable and fault-tolerant data processing
    architecture that handles data at-rest as well as data in-motion. It’s comprised
    of three layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layer for real time processing. The Realtime views may not be as accurate
    or complete as the ones eventually produced by the batch layer, but they are available
    as soon as data is received and can be replaced when the batch layer's views for
    the same data becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Batch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This layer can store a large amount of data. Output is typically stored in a
    read-only database. Any errors can be fixed by recomputing based on a complete
    data set at which time views can be updated. Apache Hadoop is the de facto standard
    batch-processing system used in most high-throughput architectures. Response times
    can be measured in minutes or even hours.
  prefs: []
  type: TYPE_NORMAL
- en: Servicing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output from the batch and speed layers are stored in the serving layer, which
    responds to ad-hoc queries by returning precomputed views or building views from
    processed data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc46f13d-2264-4643-b254-9d38e92254c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Some Lambda implementations have various storage and technology decisions, but
    they all have a batch and a real time components that both consume the same data
    and a real time view that can be updated by corrected data from batch processing.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this architecture is that the same data is ingested by both
    the Speed and by the Batch layer and typically stored in two separate databases,
    Cassandra and HBASE in the example above. Plus, extra processing occurs when the
    batch jobs return fixed up batch view data that needs to be merged into the related
    real time views.
  prefs: []
  type: TYPE_NORMAL
- en: Next generation big data architecture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next generation big data architecture has dropped the batch layer completely.
    The purely real time system brings stream processing directly into the services
    architecture where the data is stored via event logging. The most current data
    is stored in the database and the history of events is stored in the event logs.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is an architecture
    style that separates read operations from write operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the same data model is used to query and update a database. However,
    more complex applications, problems with this shared data model appear. For example,
    To satisfy the write requirements our data model need to contain complex validation
    and business logic. Our read requirements will have no need for that extra logic.
    Instead, it may need to perform many different queries, using data structures
    that are needed by our write component. Complexity is increased on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS addresses these problems by separating reads and writes into separate models,
    using commands to update data, and queries to read data.
  prefs: []
  type: TYPE_NORMAL
- en: Commands are based on tasks, rather than specific create or update commands.
    For example, *Upgrade Car*, rather than *append LX* to `model_name` field. Commands
    are placed on a queue for asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: Queries return plain data objects that have no behavior or domain knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be42284f-92d4-46a7-85c7-33e8bcbfaf61.png)'
  prefs: []
  type: TYPE_IMG
- en: Benefits of CQRS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CQRS **optimizes performance**. The command service/event store side can be
    optimized for updates while the query service/materialized view side can be optimized
    for queries.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS **simplifies queries** by storing a materialized view in the read database.
    Complex joins can be avoided and performance improved.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS **separates** of writing and reading which greatly simplifies the business
    logic in the query model and puts the complex validation and business logic in
    the command model where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS allows the reads and writes to **scale****independently.**
  prefs: []
  type: TYPE_NORMAL
- en: CQRS relies on messaging which is a good fit for message-based microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c7791c2-e632-46e8-9bd1-5c3c655992ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Above, microservice1 writes to its database which publishes a write event. Microservice2
    and microservice3 subscribe to microservice1's write event and get updated every
    time that event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Developing an isolated microservice is very easy in comparison to designing,
    developing and configuring its infrastructure. Infrastructure includes things
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and ingesting logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Balancing loads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking application health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting storage systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming and discovering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrating/Coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating application instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Horizontal Autoscaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share nothing architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A share nothing architecture (SN) is a distributed computing architecture where
    each node is independent and self-sufficient. Nodes do not share data storage
    and there is no single point of contention across the system. Sounds a lot like
    a microservice, right?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with SN architectures is that join operation between the nodes can
    be time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: SN eliminates shared mutable state, minimizes resource contention and increases
    scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservices have no control over other microservices externally or internally.
    It is important that our digital fabric of microservices agree on acceptable communication
    protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Agreed upon protocol
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The protocol should enforce policies regarding security, the direction and velocity
    of the flow of data as well as flow control.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to prevent cascading failures there should be mechanisms in place
    such as  fail fast circuit breakers. Management of retries for failed requests
    should consider things like:'
  prefs: []
  type: TYPE_NORMAL
- en: How long should we wait to retry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we monitor the endpoint and wait for it to get back online and then try
    again?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When do we notify devops about the failure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional reactive architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional reactive architecture (FRP) is similar to other architectures in
    that it embraces many of the FP concepts such as immutable data structures, event
    streaming and data transformation, but different in that it is a front-end architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Functional Programming (RFP) incorporates aspects from both Reactive
    Programming (RP) and Functional Programming (FP).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b97bc3a-fbfb-40e9-b756-826dcc2a45ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s look at an example to get a better appreciation for the connection between
    FRP and FP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a User Interface (UI) application that sums two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91fce353-6b82-4274-a0e2-7f0540c523d9.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot more to RFP (immutable data structures, memoization, state and
    event management, and so on). Since this is a front end technology the logic will
    not be Go, but rather JavaScript (which is one of my specialties).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you like my style of writing and would like me to write a book combining
    Go, ReactJS and some distributed data store technology let me hear from you. Please
    post your feedback here: [https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW](https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW)'
  prefs: []
  type: TYPE_NORMAL
- en: Go is ideal for building microservices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Distributed computing involves the horizontal scaling our our microservices.
    We have seen that when we can dramatically improve performance by running our
    tasks in parallel.  In order to manage, order and orchestrate our workloads we
    need a simple mechanism.   What simpler solution exists for creating and running
    applications concurrently? (Answer: None.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''re some of Go''s features that make it ideal for microservice environments:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking/gRPC/Protocol buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systems programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is built upon the philosophy of simplicity. To write go code is to write
    practical code.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is baked into the Go language in the form of goroutines and channels.
  prefs: []
  type: TYPE_NORMAL
- en: For a coding example using goroutines and channels see [Chapter 5](../Text/Ch05.xhtml), *Adding
    Functionality with Decoration*.
  prefs: []
  type: TYPE_NORMAL
- en: Go's compile times are extremely fast. Once compiled, Go binaries are native
    executables.
  prefs: []
  type: TYPE_NORMAL
- en: There are no virtual environments to install, configure, import dependencies
    from, deploy and manage. The only footprint is a small native executable. That's
    less surface area for attackers to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Size matters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s face it. Size matters. If you are paying for the resources (CPU, storage,
    networking, and so on) which would you prefer to pay for:'
  prefs: []
  type: TYPE_NORMAL
- en: 1,000 of these?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18b3dc63-c403-465f-9d82-fb3c95356e23.png)'
  prefs: []
  type: TYPE_IMG
- en: Or 1,000 of these?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0deec193-8365-46e0-839f-34bb874a5377.png)'
  prefs: []
  type: TYPE_IMG
- en: Benefits of gRPC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you need to employ a request/response architecture, using gRPC with protocol
    buffers is the way to go. gRPC allow us to easily release SDKs. Now integration
    is a matter of and asking the other developers to copy-paste example code written
    in their language. This represents a big win for companies what want to integrate
    with our products, while not requiring us to implement entire SDKs in all the
    various languages that our vendors and partners use.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is built on HTTP/2 HTTP/2's client-side and/or server-side streaming allow
    for faster response times and support for bulk ingestion and bi-directional streaming.
    We can asynchronously stream requests/responses; The server would stream back
    status messages, allowing for easy checkpoint operations. This allows us to process
    uploads as fast as possible without blocking for confirmations.
  prefs: []
  type: TYPE_NORMAL
- en: By using protocol buffers with gRPC, we'll improve serialization and deserialization
    performance. Clients receive typed objects rather than free form JSON. This allows
    our clients can reap the benefits of type-safety, auto-completion in their IDEs,
    and improved version management.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC enables us to write one interface definition, in the proto format, for
    both the client and server side of our APIs. Interface driven development enables
    both development teams to work in parallel. That makes us leaner, providing more
    value faster.
  prefs: []
  type: TYPE_NORMAL
- en: Who is using Go?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A short list of  systems and infrastructure tools being built in Go includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: InfluxDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Etcd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSQ,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned the importance of the dependency rule. We learned
    that we can only import packages in one direction. We learned how to separate
    a complex application into layers.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use dependency injection to interact between our application
    layers and implemented an application using a layered architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The key to selecting the right architecture is a deep understanding our system's
    requirements, existing components and the capabilities of available technologies
    choices.  At the end of the day it’s the system engineer’s job to ensure the entire
    system works properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about functors, monoids, type classes, and
    other functional programming concerns.
  prefs: []
  type: TYPE_NORMAL
