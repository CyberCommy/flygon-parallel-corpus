- en: Chapter 11. Android Game Development Using C++ and OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen the differences between an Android application and an Android
    game. The Android SDK is very capable of taking care of both. Certainly, the question
    that arises is "What is the requirement of a separate development toolset in native
    languages such as C and C++?" Compared to Java, C and C++ are much more difficult
    to manage and write code in. The answer lies in the question itself. The Java
    architecture runs on JVM, which is associated with the Android operating system.
    This creates an extra latency, which has a performance lag. The scale of the lag
    depends on the scale of the application.
  prefs: []
  type: TYPE_NORMAL
- en: A highly CPU-intensive application may cause a significant amount of visible
    lag in Java architecture. Native language code can be processed faster. Moreover,
    native code can be varied depending on the CPU/platform architecture, which is
    not possible in the case of the Java architecture used by the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Android uses the OpenGL rendering system. So, an application made in OpenGL
    can also choose Android as the target platform. Native code helps directly structure
    the application using OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a detailed look at these aspects in this chapter through the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the 3Android NDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ for games—pros and cons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native code performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering using OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different CPU architecture support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Android NDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is actually based on the Java architecture. However, part of an Android
    application can be developed using native languages such as C and C++. This is
    where the Android NDK comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: The Android NDK is a toolset used to develop a module of an application that
    will interact with hardware much faster. It is a well-known fact that C and C++
    have the ability to interact with a native component directly, which reduces the
    latency between the application and hardware.
  prefs: []
  type: TYPE_NORMAL
- en: How the NDK works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Android native code segment interacts with main application through the **Java
    Native Interface** (**JNI**). The Android NDK comes with a build script that converts
    native code into binary and includes it in the main Android application.
  prefs: []
  type: TYPE_NORMAL
- en: This binary is basically a native code library that can be used in any Android
    application as per requirement. An NDK build script creates `.so` files and adds
    them to the application path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android build process creates Dalvik Executable files (`.dex`) to run on
    the Dalvik Virtual Machine (or ART) of the Android OS. The Java executable recognizes
    the native library and loads the implemented methods. The native methods are declared
    with the `native` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The method always has public access, because the native library is always treated
    as an external source. Here, the developer should always keep in mind that there
    should never be multiple definitions of a method for the same declaration collectively
    for all the included native libraries. This will always create a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The native building process can build the native project into two types of
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Native shared library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native static library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native shared library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The native build script creates `.so` files from C++ files, which is termed
    as the native shared library. However, it is not always shared between applications
    in the true sense. An Android application is a Java application, but a native
    application can be triggered through a native shared library.
  prefs: []
  type: TYPE_NORMAL
- en: For game development, if the game is written in a native language, then the
    game code is included in the shared library.
  prefs: []
  type: TYPE_NORMAL
- en: Native static library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Native static libraries are basically collections of compiled objects and represented
    by `.a` files. These libraries are included in other libraries. A compiler can
    remove unused code during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Build dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android SDK is capable of building and packaging an Android application project
    into an APK file with the support of Java. However, the NDK is not sufficient
    to build and package APK files. Here are the dependencies for creating an Android
    application APK other than the NDK:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cygwin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android applications are basically Java applications. Hence, it is absolute
    necessary to have Android SDK in order to create an Android application package.
  prefs: []
  type: TYPE_NORMAL
- en: C++ compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A native Android application is written in C++, so a C++ compiler is required
    to compile the code base on the development platform. C++ compilers are platform
    dependent, so it may not be the same C++ compiler on each platform.
  prefs: []
  type: TYPE_NORMAL
- en: For example, on a Windows machine, the C++11 compiler is used currently in the
    development industry, whereas the GC++ compiler is used on Linux machines.
  prefs: []
  type: TYPE_NORMAL
- en: These may create different code bases for the actual development project in
    terms of syntax and API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is a separate development language. It can be used to create applications
    for Android and can support multiple platforms by converting the source into native
    language. In the case of Android NDK development, Python is used for the conversion
    of C++ code to native binary.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gradle is used by the build script and the Android native build tool to convert
    native code to a shared library. It also provides a virtual Unix environment to
    make application packages.
  prefs: []
  type: TYPE_NORMAL
- en: Cygwin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android requires a Unix environment to build an NDK application project. The
    Windows system does not have a Unix environment. Cygwin is required to provide
    a virtual Unix environment to support the building platform.
  prefs: []
  type: TYPE_NORMAL
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Last but not least is the requirement of Java to create an Android application
    package. However, Java is always required for any type of Android development.
  prefs: []
  type: TYPE_NORMAL
- en: Native project build configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Android project needs the following configurations in order to create an
    application package from native source code. A native project build depends on
    the configuration defined in these two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Android.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application.mk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android.mk configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Location**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Android.mk` file can be located at `<Application Project Path>/jni/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration options**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Android.mk` file contains the following options to create an application
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CLEAR_VARS`: This clears the local and user-defined variables. This option
    is invoked by the `include $(CLEAR_VARS)` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_SHARED_LIBRARY`: This includes all local files, defined in `LOCAL_MODULE`
    and `LOCAL_SRC_FILES`, in a shared library. It is invoked by the `include $(BUILD_SHARED_LIBRARY)`
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_STATIC_LIBRARY`: This specifies static libraries to create `.a` files
    used by the shared libraries. It is invoked by the `include $(BUILD_STATIC_LIBRARY)`
    syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREBUILT_SHARED_LIBRARY`: This indicates a prebuilt shared library at a specific
    path to build a dependent shared library from local includes. It is invoked by
    the `include $(PREBUILT_SHARED_LIBRARY)` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREBUILT_STATIC_LIBRARY`: This indicates a prebuild static library at a specific
    path to build a dependent shared library from local includes. It is invoked by
    the `include $(PREBUILT_STATIC_LIBRARY)` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TARGET_ARCH`: This indicates the basic type of processor architecture family
    such as ARM, x86, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TARGET_PLATFORM`: This defines the target Android platform. The mentioned
    platform must be installed in the development system through the Android SDK manager.
    It indicates the Android API level in order to create the application package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TARGET_ARCH_ABI`: This indicates the specific ABI for target processor architecture,
    such as armeabi, armeabi-v7, x86, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_PATH`: This points to the current file directory. This variable does
    not get cleared by the `CLEAR_VARS` command. It is invoked by the `LOCAL_PATH
    := $ (call my-dir)` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE`: This indicates all the unique local module names. It is invoked
    by the `LOCAL_MODULE := "<module name>"` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_MODULE_FILENAME`: This indicates the library name that contains the
    defined `LOCAL_MODULE`. It is invoked by the `LOCAL_MODULE_FILENAME := "<module
    library file name>"` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL_SRC_FILES`: This indicates all the native source code file paths to
    be compiled into a shared library. It is invoked by the `LOCAL_SRC_FILES := <Local
    source file path>` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other optional configurations that can be set in this file, such as
    `LOCAL_C_INCLUDES`, `LOCAL_CFLAGS`, `LOCAL_CPP_EXTENSION`, `LOCAL_CPP_FEATURES`,
    `LOCAL_SHARED_LIBRARIES`, `LOCAL_STATIC_LIBRARIES`, and `LOCAL_EXPORT_CFLAGS`.
  prefs: []
  type: TYPE_NORMAL
- en: Application.mk configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Location**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Application.mk` file can be located at `<Application Project Path>/jni/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration options**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Application.mk` file contains the following options to create an application
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`APP_PROJECT_PATH`: This is the absolute path to the project root directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_OPTIM`: This indicates the optional setting to create the build package
    as release or debug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_CFLAGS`: This defines a set of C-compiler flags for the build instead
    of changing in the `Android.mk` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_CPPFLAGS`: This defines a set of C++-compiler flags for the build instead
    of changing in the `Android.mk` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_BUILD_SCRIPT`: This is an optional setting to specify a build script other
    than the default `jni/Android.mk` script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_ABI`: This option specifies the set of ABIs to be optimized for the Android
    application package. Here is the complete list and keywords for each ABI support:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARMv5: `armeabi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARMv7: `armeabi-v7a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARMv8: `arm64-v8a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intel 32-bit: `x86`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intel 64-bit: `x86_64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MIPS 32-bit: `mips`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MIPS 64-bit: `mips64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALL-SET: `all`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_PLATFORM`: This option specifies the target Android platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NDK_TOOLCHAIN_VERSION`: This option specifies the version of the GCC compiler.
    By default, versions 4.9 and 4.8 are used for compilation in 64 bit and 32 bit,
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_STL`: This is an optional configuration to link alternative C++ implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APP_LDFLAGS`: In the case of building a shared library and executables, this
    option is used to link flags to the build system to link the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ for games – pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a never-ending debate between C++ and Java. However, we will not go
    into the controversy and will try to look at them from the perspective of game
    development. C++ has a slight performance edge over Java, and Java is known for
    its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: There may be many programmers who are more comfortable in C++ than Java, or
    vice versa. In game development, personal choice of programming language does
    not matter. Hence, using NDK or SDK has to be determined depending on the requirements.
    It is always recommended that you use the Android SDK to develop an application
    rather than using the NDK.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the advantages and disadvantages of using native language for
    game programming.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first have a look at the positive side of using C++ for game programming
    through the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Universal game programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross platform portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU architecture support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal game programming language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of game development, C++ is widely used for many platforms, especially
    for consoles and PC game development. This is the reason many game engines opted
    for C++ as the primary programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is difficult to learn many programming languages to work on different
    platforms with different architecture. C++ provides a most common solution to
    this problem, as most of the programmers are familiar with C++ library and API
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform portability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same C++ code is compiled into a library targeting a specific operating
    platform. Thus, the same project can be compiled for different platforms. Hence,
    it is super easy to port a game to various platforms if it is written in C++.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the famous and effective cross-platform game engine Cocos2d-x uses
    C++ as the development language. Hence, the same game is easily ported for many
    platforms such as Android, iOS, Mac OS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Faster execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ is well capable of interacting with platform hardware, and writing games
    in C++ helps boost their performance. However, in the case of Android, the performance
    boost is hardly noticeable if the game is not CPU intensive.
  prefs: []
  type: TYPE_NORMAL
- en: CPU architecture support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ code can be compiled for specific target CPU architectures such as x86,
    ARM, Neon, or MIPS. This specification indicates better performance on that particular
    processor.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler configuration for CPU architecture in Android NDK ensures the best
    possible result in each platform. However, it is not always necessary to define
    each and every platform to avoid extra compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of using C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the other side of the coin through these points:'
  prefs: []
  type: TYPE_NORMAL
- en: High program complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-dependent compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High program complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ comes with extra program complexity. In the case of Java programming, JVM
    takes care of memory completely and follows the OOP concept. C++ lags in providing
    this feature. Thus, it becomes extra overhead for the developer to take care of
    every programming aspect.
  prefs: []
  type: TYPE_NORMAL
- en: C++ itself has a complex architecture compared to Java. The chances of facing
    exceptions and errors increases if C++ is used.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-dependent compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going cross platform is easy when using C++. However, configuring the build
    script can be a pain in most of the cases. It is a very common scenario that the
    same game fails to run on a ported platform due to the wrong configuration. Moreover,
    it becomes difficult to find out the issue as the game is successfully running
    on some other platform.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, different platforms use different C++ compilers. So, it requires
    an extra effort to identify platform-specific code and find out an alternative
    for each platform, if required.
  prefs: []
  type: TYPE_NORMAL
- en: Manual memory management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java does not require memory management to be implemented by the developer,
    and the memory is efficiently managed by JVM (DVM in the case of Android). So,
    there is no chance of facing memory leakage or fragmentation. JVM runs the garbage
    collector to free the unused memory automatically. However, garbage collector
    invocation costs a bit of performance, and frequent garbage collector calls can
    cause a severe drop in performance.
  prefs: []
  type: TYPE_NORMAL
- en: The developer should use optimum memory, because the garbage collector cannot
    identify unused memory block if there is any active reference in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ has its own advantages. However, when it comes to game programming for Android,
    it does not help much in the technical sense. So, if we compare the amount of
    effort and risk taken by opting for C++ than coding in Java for Android, Java
    should always be preferred for Android. DVM runs Java code efficiently enough
    to achieve reasonable performance on Android devices. Moreover, the Android NDK
    library is not actually designed to develop a standalone Android application.
    Even though it has native activity support, which acts as a middle layer between
    DVM and native application written in C++, it does not help much.
  prefs: []
  type: TYPE_NORMAL
- en: If the developer chooses not to go for cross platform and keeps the game scope
    within Android only, then it is recommended that you use Android SDK rather Android
    NDK. It will decrease the development hustle and complexity with a negligible
    amount of performance loss.
  prefs: []
  type: TYPE_NORMAL
- en: Native code performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already know, native code can run faster with better processing speed.
    This can be further optimized for a specific CPU architecture. The main reason
    behind this performance boost is the use of pointers in memory operations. However,
    it depends on the developer and the coding style.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a simple example where we can have a better understanding of performance
    gain in native language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the address of 1000 fields in the array is handled by JVM (DVM
    in the case of an Android Dalvik system). So, the interpreter parses to the *i^(th)*
    position and performs an assignment operation each time, which takes a lot of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the same functionality using native C/C++ language and
    use pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the interpreter does not need to parse to the target memory
    location. The address of the location is pointed out by `ptrArray`. Hence, the
    value can be directly assigned to the memory location.
  prefs: []
  type: TYPE_NORMAL
- en: Especially for multi-dimensional arrays, a significant performance gain can
    be observed in the case of properly written native code for the same functionality.
    Other important use of native code is binary data processing and image processing,
    where a huge amount of data is processed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering using OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android uses OpenGL for rendering. Android SDK libraries include the OpenGL
    libraries, specially optimized for Android. Android started supporting OpenGL
    from API level 4 and then increased its support as the level increased. Currently,
    the maximum supported version of OpenGL is OpenGL ES 3.1 from API level 21.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Different OpenGL versions have a different set of features. Versions 1.0 and
    2.0 have a lot of differences in terms of coding style, API convenience, functionality,
    and feature support. Let''s discuss the following OpenGL ES versions that are
    significant to Android development:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 1.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL ES 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGL 1.x
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenGL version 1.x has been supported from Android API level 4 with a shared
    OpenGL ES 1.x library, `libGLESv1.so`. The headers `gl.h` and `glext.h` contain
    all the necessary APIs for OpenGL functionality.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the current industry, a developer prefers to use OpenGL ES 2.0 for games,
    because almost every device supports this OpenGL version, and it provides vertex
    and fragment shaders useful for games. OpenGL ES 2.0 can be used in Android native
    development projects by including the `libGLESv2.so` shared library in the project,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The headers are `gl2.h` and `gl2ext.h`. OpenGL ES 2.0 is supported from Android
    API level 5.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL 3.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From Android API level 21, OpenGL ES 3.0 is supported. The developer can include
    `libGLESv3.so` to use OpenGL 3.1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The headers are `gl3.h` and `gl3ext.h`.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL 3.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From Android API level 21, OpenGL ES 3.1 is supported. The developer can include
    `libGLESv3.so` to use OpenGL 3.1, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The headers are `gl31.h` and `gl3ext.h`.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL ES 3.0 and OpenGL ES 3.1 are not supported by many Android devices. If
    a developer intends to use them, then there should be an OpenGL version check
    before using the version. Also, proper version of OpenGL ES must be used to run
    the game on that particular device. The latest Android N has support for OpenGL
    ES 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and setting the OpenGL version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This piece of Android Java code can be used to implement proper OpenGL ES support
    for an Android game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Texture compression and OpenGL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Texture compression has a significant effect on the rendering process handled
    by OpenGL. It can increase or decrease performance for different types of texture
    compression. Let''s have a quick look at some of the important texture compression
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: ATC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PVRTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DXTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ATI texture compression is often called ATITC. This compression supports RGB
    with and without an alpha channel. This is the most common and widely used compression
    technique for Android.
  prefs: []
  type: TYPE_NORMAL
- en: PVRTC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Power VR texture compression uses 2-bit and 4-bit pixel compression with or
    without an alpha channel. This is used by many game developers across the globe.
  prefs: []
  type: TYPE_NORMAL
- en: DXTC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DXTC is also called S3 texture compression, which is also used for OpenGL. This
    uses a 4-bit or 8-bit ARGB channel.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL manifest configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android requires the version definition of OpenGL used in the application, along
    with other required options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the version declaration syntax for OpenGL ES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the target version options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0x00010000` for version 1.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00010001` for version 1.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00020000` for version 2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00030000` for version 3.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00030001` for version 3.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x00030002` for version 3.2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the optional setting for texture compression declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the compression type options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GL_OES_compressed_ETC1_RGB8_texture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_OES_compressed_paletted_texture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_s3tc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_IMG_texture_compression_pvrtc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_dxt1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_dxt2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_dxt3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_dxt4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_dxt5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_AMD_compressed_3DC_texture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_EXT_texture_compression_latc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_AMD_compressed_ATC_texture`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GL_ATI_texture_compression_atitc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, not all texture compressions are supported by every device. The developer
    should always choose the target texture compression depending on the hardware
    and Android version requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google does the filtration process of devices automatically if the target device
    does not support the declared texture format or formats.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the target OpenGL ES version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have already learned, not all devices support all OpenGL versions. So,
    it is very important to choose the correct OpenGL version before developing the
    game. Here are a few factors that should be evaluated while choosing the OpenGL
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming comfort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is noticed that OpenGL version 3.x is faster than OpenGL version 2.x, which
    is way faster than OpenGL 1.x. So, it is always better to use the latest possible
    version in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Texture support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Texture compression support varies with OpenGL versions. Older versions support
    older texture compression factors. Also, Android version support is not universal
    for all OpenGL versions. Again, it is better to use the latest possible version
    for texture support.
  prefs: []
  type: TYPE_NORMAL
- en: Device support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This constraint keeps a developer's feet on the ground. The latest versions
    of OpenGL are not supported by all devices. So, in order to target a bigger range
    of devices, the user should change the OpenGL version to 2.0 as most devices support
    this version.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the version of OpenGL increases, the feature list becomes an important factor
    while choosing the OpenGL version. The developer must know the support required
    for developing the application and accordingly, they must choose the version.
  prefs: []
  type: TYPE_NORMAL
- en: Programming comfort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a huge coding style and API change among the versions of OpenGL. The
    developer should choose the version if it can actually be developed in the company
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Different CPU architecture support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developer has the opportunity to optimize an Android application for a separate
    processor architecture. At a high-level point of view, it is a great feature.
    However, this feature comes at a significant cost. Let's have a look at the details
    of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Available CPU architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the architectures currently supported by the NDK build:'
  prefs: []
  type: TYPE_NORMAL
- en: ARM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MIPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ARM** stands for **Acorn RISC Machine**. This is a **RISC** (**Reduced Instruction
    Set Computing**) based processor, mainly targeting embedded or mobile computing.
    As the base says, it is highly efficient for an operating system such as Android.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, most used processors of the Android platform are from the ARM family.
    It can be further sub-categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ARMv5TE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARMv7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARMv8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intel introduced the **x86** architecture for processors. At first, these processors
    were mainly used for desktop/laptop PCs. However, they were optimized to be used
    in mobile devices in the form of Celeron or Atom processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two types of x86 architecture can be set for the Android NDK build:'
  prefs: []
  type: TYPE_NORMAL
- en: i686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: x86-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Neon** architecture is based on ARM technology to optimize it further
    for mobile computation. The Android build also can be optimized for this specific
    architecture. All Cortex processors are basically Neon-based processors.
  prefs: []
  type: TYPE_NORMAL
- en: MIPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**MIPS** stands for **Microprocessor without Interlocked** **Pipeline Stages**.
    There is a variation of 32- and 64-bit processors in this category. As the name
    says, this architecture is used in microprocessors in embedded devices for small-scale
    computation. Later, it was introduced to Android with a 64-bit architecture. However,
    this type of processor is rarely used in Android systems today.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and disadvantages of integrating multiple architecture support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android mobile devices have different configurations in terms of memory and
    processing capacity. Including separate architecture support may increase the
    performance that comes with greater build size.
  prefs: []
  type: TYPE_NORMAL
- en: The native build tool builds a separate shared library for each target processor
    and includes it in the build package.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some advantages and disadvantages of providing separate processor architecture
    support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the advantages first:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster operation**: Separate architecture for a separate processor results
    in a faster processing speed of game instructions. If the processor architecture
    is supported by the Android application, then the processor does not need to perform
    any conversions and can run the instructions at a faster speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimum use of processor**: The operating system always looks for the specific
    architecture for an integrated processor. The same architecture makes optimum
    use of the processor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimum power consumption**: Optimum processing directly implies optimum
    and minimum power usage for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimum memory usage**: The processor does not need to use extra runtime
    memory to execute instructions if the same processor architecture is supported
    by the Android application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the disadvantages now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Larger build size**: Using a separate shared library for a separate architecture
    increases the build package size significantly. The entire native instruction
    code is rewritten in a separate shared library with different processor optimization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced target device count**: If the size of the APK is large, it creates
    more problems to accommodate it for a low storage device. Hence, device support
    becomes less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at Android NDK briefly in this chapter and cleared a few doubts on
    native development. There are many developers who think that developing games
    in a native language gives enormous processing power. This is, however, not always
    true. Processing and performance depend on the development style and standard.
    In most common scenarios, the difference between native development and SDK development
    is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL works with Android in any scenario. The backend rendering is based on
    OpenGL for both NDK and SDK. We have already discussed all the technical aspects
    of OpenGL. Here, you learned which version of OpenGL works with Android and what
    we should use. Clearly, OpenGL ES 2.0 is a good choice as most Android devices
    support it. On the other hand, OpenGL ES 1.0 is obsolete, and OpenGL ES 3.0 is
    not supported by most Android devices yet.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have covered almost every aspect of Android game development.
    However, finishing the implementation for the game does not define the completion
    of the development cycle. Developers need to polish the game after it comes to
    a release-ready state to improve its overall quality. We will discuss game polishing
    in the next chapter to indicate the completion of the game development process.
  prefs: []
  type: TYPE_NORMAL
