- en: Build a House Listing Application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the taglines for development with React is *learn once, write anywhere,* which
    is due to the existence of React Native. With React Native, you can write native
    mobile applications using JavaScript and React while using the same features as
    React for things such as state management. Building on the React knowledge that
    you've already gathered from this book, you'll start exploring React Native from
    this chapter on. As React and React Native share a lot of similarities, it's advised
    that you have another look at some of the previous chapters whenever you feel
    insecure about your React knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll create a mobile application using React Native, which
    uses the same syntax and patterns that you've seen in the previous chapters. You'll
    set up basic routing, explore the differences between development for iOS and
    Android, and learn about styling React Native components with `styled-components`.
    Also, a toolchain called **Expo** will be used to run and deploy your React Native
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a React Native project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing for mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycles in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling components in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a house listing application that shows an overview
    of the available houses with a detail page of every listing, with `styled-components`
    for styling and **React Navigation** for routing. The data is fetched from a mock
    API.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 1.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have the Expo Client application installed on your iOS or Android
    device to be able to run the application that you'll create in this chapter. Expo
    Client is available in both the Apple App Store and the Google Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've downloaded the application, you need to create an Expo account to
    make the development process smoother. Make sure you store your account details
    somewhere safe, as you'll need these later on in this chapter. **Don't forget
    to verify your email address by clicking the link that was sent to you by email.**
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch8](https://github.com/PacktPublishing/React-Projects/tree/ch8)[.](https://github.com/PacktPublishing/React-Projects/tree/ch7)
  prefs: []
  type: TYPE_NORMAL
- en: This application was created using **Expo SDK version 33.0.0** and so you need
    to make sure the version of Expo you're using on your local machine is similar.
    Since React Native and Expo are updated frequently, make sure that you're working
    with this version to ensure the patterns described in this chapter behave as expected. In
    case your application won't start or you're receiving errors, make sure to check
    the Expo documentation to learn more about updating the Expo SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Building a house listing application with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll build a house listing application with React Native
    and Expo, which allows you to use the same syntax and patterns you already know
    from React, as it's using the React library. Also, Expo makes it possible to prevent
    having to install and configure Xcode (for iOS) or Android Studio to start creating
    native applications on your machine. Therefore, you can write applications for
    both the iOS and Android platforms from any machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run a React Native application in the browser using Expo web to
    create **Progressive Web Applications** (**PWAs**). However, developing for iOS,
    Android, and the web at the same time is still experimental and might need a lot
    of performance and architectural fixes. Also, not all the packages that work in
    React Native on mobile devices will work on Expo web as well.
  prefs: []
  type: TYPE_NORMAL
- en: Expo combines React APIs and JavaScript APIs with the React Native development
    process in order to allow features such as JSX components, Hooks, and native features
    such as camera access. Roughly, the Expo toolchain consists of multiple tools
    that help you with React Native, such as the Expo CLI, which allows you to create
    React Native projects from your Terminal, with all of the dependencies that you
    need to run React Native. With the Expo Client, you can open these projects from
    iOS and Android mobile devices that are connected to your local network. Expo
    SDK is the package that contains all of the libraries that make it possible to
    run your application on multiple devices and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Create a React Native project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, the starting point of every new React project in this book was
    using Create React App to create a boilerplate for your application. For React
    Native, a similar boilerplate is available, which is part of the Expo CLI, and
    it can be set up just as easily:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to globally install the Expo CLI with the following command using
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the installation process, which can take some time as it will
    install the Expo CLI with all of its dependencies that help you develop mobile
    applications. After this, you''re able to create a new project using the `init`
    command from the Expo CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Expo will now create the project for you but, first, it will ask you to answer
    the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will ask you whether to create just a blank template, a blank template with
    TypeScript configuration, or a sample template with some example screens set up.
    For this chapter, you''ll need to choose the first option: blank (`expo-template-blank`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting a template, you need to type in the name of your application,
    which is house listing in this case. This name will be added to the `app.json`
    file with configuration information about your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expo automatically detects whether you have Yarn installed on your machine.
    If so, it will ask you to use Yarn to install other dependencies that are needed
    to set up your computer. If you have Yarn installed, select `yes`; otherwise, `npm`
    will be used by default. For this chapter, it's advised to use `npm` instead of
    Yarn so that you're consistent with the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, your application will be created using the settings you''ve selected.
    This application can now be started by moving into the directory that was just
    created by Expo using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start Expo and give you the ability to start your project both from
    the Terminal or from your browser, making it possible to either run the application
    on your mobile device or by using the iOS or Android Emulator. In your Terminal,
    there are multiple ways to open the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in using the username from your Expo Client on Android or iOS. Your projects
    will automatically appear in the Projects tab on your mobile device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan the displayed QR Code from your mobile device that runs on Android or iOS. If
    you're using an Android device, you can scan the QR Code directly from the Expo
    Client application. On iOS, you need to use your camera to scan the code that
    will ask you to open Expo Client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press `a` to open the Android Emulator or `i` for the iOS Emulator. Keep in
    mind that you need to have Xcode and/or Android Studio installed to use either
    one of the emulators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By pressing `e` to send a link to you by email, this link can be opened from
    a mobile device that has the Expo Client application installed on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, running the `npm start` command will open your browser on the
    `http://localhost:19002/` URL, showing the Expo Developer Tools. This page will
    look like this, assuming you have the version of the Expo SDK installed that was
    mentioned in the *Getting started* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6a61b79f-7752-49fc-897c-ad7f75cba8ae.png)'
  prefs: []
  type: TYPE_IMG
- en: On this page, you can see a sidebar on the left and the logs from your React
    Native application on the right. This sidebar contains buttons so that you can
    start the iOS or Android Emulator, for which you need to have either Xcode or Android
    Studio installed. Otherwise, you can also find a button to send a link to open
    the application by email or a QR Code on your mobile device using the Expo application
    you've previously installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your application should look as follows. This screenshot was
    taken from an iOS device. It shouldn''t matter if you''ve opened the application
    using the emulator for iOS or Android or from an iOS or Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f4e5ce7-020e-42af-9b8e-bf29cf94ba4a.png)'
  prefs: []
  type: TYPE_IMG
- en: This application was created using **Expo SDK version 33.0.0** and so you need
    to make sure the version of Expo you're using on your local machine is similar.
    Since React Native and Expo are updated frequently, make sure that you're working
    with this version to ensure the patterns described in this chapter behave as expected. In
    case your application won't start or you're receiving errors, make sure to check
    the Expo documentation to learn more about updating the Expo SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure from this React Native application, which we created
    with Expo, is quite similar to the React projects you''ve created in the previous
    chapters. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `assets` directory, you can find the images that are used for the application
    icon on the home screen once you've installed this application on your mobile
    device, as well as the image that will serve as the splash screen, which is displayed
    when you start the application. The `App.js` file is the actual entry point of
    your application, where you'll return the component that will be rendered when
    the application mounts. Configurations for your application, for example, for
    the App Store are placed in `app.json`, while `babel.config.js` holds specific
    Babel configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up routing in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, the `App.js` file is the entry point of your application,
    which is defined by Expo. If you open this file, you will see it consists of components
    and that `StyleSheet` has been imported directly from `react-native`. The syntax
    of writing styles in React Native is different from React being used in a browser,
    so you'll have to install `styled-components` later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes with React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s proceed by installing React Navigation. There are many packages available
    to help you handle routing in React Native, but this is one of the most popular
    and advised to use by Expo. Besides React Navigation, you must also install the
    related packages, called `react-navigation-stack` and `react-navigation-tabs`,
    which are needed to create the navigators for your application. React Navigation
    and its dependencies can be installed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To add routing to your React Native application, you will need to understand
    the difference between routing in a browser and a mobile application. History
    in React Native doesn't behave the same way as it does in a browser, where users
    can navigate to different pages by changing the URL in the browser and the previously
    visited URLs will be added to the browser history. Instead, you will need to keep
    track of transitions between pages yourself and store a local history in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With React Navigation, you can use multiple different navigators to help you
    do this, including a stack navigator and a tab navigator. The stack navigator
    behaves in a way that is very similar to the browser as it stacks pages after
    transitioning between them and lets you navigate using native gestures and animations
    for iOS and Android:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set up a stack navigator by passing an object containing routing configuration
    to the `createStackNavigator` method, which can be imported from `react-navigation-stack` in
    the `App.js` file. Also, you will need to import `createAppContainer` from `react-navigation`,
    which helps you return a component that wraps all of the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of returning a component called `App`, you need to return the component
    that was created with `createStackNavigator`, which holds all of the routes for
    your application. This `StackNavigator` component needs to be exported using `createAppContainer`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application now has one route, which is `Home`, and renders the `Home` component.
    You can also add `title` for this screen by setting the `navigationOptions` field in
    the object that''s passed to `createStackNavigator` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To create another route, you can copy this process by adding a `Detail` component
    and add a route that renders this component as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have two screens in your application, you will also need to set
    a default route that will be rendered when the application first mounts. You can
    do this by extending the routing configuration object passed to `createStackNavigator` using
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `Detail` route is also rendering by changing the value
    for `initialRouteName` to `Detail`, and checking whether the screen that is rendered
    in your application has the title `Detail`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of this section, you'll learn how to transition between the
    different screens that are created by this navigator.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning between screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transitioning between screens in React Native also works a bit differently
    than in the browser because again, there are no URLs. Instead, you need to use
    the `navigation` prop, which is available from components that are rendered by
    the stack navigator. The `navigation` prop can be used to handle routing by making
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the `navigation` prop in this example from the `Home` and `Detail`
    components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `navigation` prop holds multiple values, including the `navigate` function,
    which  takes a route name as a parameter. You can use this function as an event
    on, for example, a `Button` component that you can import from `react-native`.
    Compared to what you''re used to with React, you can click a button by calling
    an `onPress` event handler instead of `onClick`. Also, the `Button` component
    doesn''t take any children as a prop but a `title` prop instead. To do this, change
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you press the button with the `Go to Detail` title, you''ll transition
    to the `Detail` screen. The header of this screen will also render a `Return`
    button, which will send you back to the `Home` screen when you press it. You can
    also create a custom return button by using the `goBack` function from the `navigation`
    prop, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, it''s good practice to store these components in a different directory
    and only use the `App.js` file to make your application more readable. To achieve
    this, you need to create a new directory called `Screens` in the root directory
    of your application, where you need to add a file for each of the two screens
    you''ve just created. Let''s learn how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `Home.js` in the `Screens` directory and add the `Home` component
    to this file, including the imports of the used modules. The code for the `Home`
    component is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to do the same for the `Detail` screen by creating the `Screens/Detail.js` file
    and adding the code for the `Detail` component and the used modules to this file.
    You can do this by adding the following code block to that new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App.js` file, you need to import the `Home` and `Detail` components
    and remove the code blocks that created these two components previously, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Your application only uses the `App.js` file to create the routes and set up
    the stack navigator. Many applications use multiple types of navigators next to
    each other, which is something that will be shown in the next part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple navigators together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more complex applications, you don''t want all of your routes to be stacked
    on top of each other; you only want these stacks to be created for routes that
    are related to each other. Luckily, you can use different types of navigators
    next to each other with React Navigation. Using multiple navigators for the application
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common ways of navigation in mobile applications is by using
    tabs; React Navigation can also create a tab navigator for you. Therefore, you''d
    need to pass a routing object to the `createBottomTabNavigator` method, which
    you can import from `react-navigation-tabs` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you want the `Home` screen and the adjoining `Detail` screen to be
    available on the same tab—you''d need to rename the stack navigator for these
    screens. This stack navigator should be added to the routing object that is passed
    to `createBottomTabNavigator`, which creates the tab navigator. The declaration
    of the initial route that is loaded is now also linked to the tab navigator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The main navigation for your application is now the tab navigator, which has
    only one tab, called `Home`. This tab will render the stack navigator that contains
    the `Home` and `Detail` routes, meaning you can still navigate to the `Detail`
    screen without having to leave the `Home` tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily add another tab to the tab navigator that renders either a component
    or another stack navigator. Let''s create a new screen called `Settings`, for
    which you''ll first need to create a new component in the `Screens/Settings.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Import this component in `App.js` to add the new `Screens` route to the tab
    navigator. This screen renders the `Settings` component after you make these changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application now has a tab called `Settings`, which will render the `Settings` component.
    However, it isn''t possible to customize, for example, `title` of this screen.
    Therefore, you will need to create another stack navigator that only has the `Settings`
    route by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ve now added both a stack navigator and a tab navigator to your application,
    which allows you to navigate between screens and tabs at the same time. If you''re
    running your application using the iOS Emulator or on a device that runs iOS,
    it will look exactly like the following screenshot. For Android, the application
    should look very similar at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a45f6bb-5a7a-4303-a513-1b6b9a2b3586.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you'll load data from the mock API and use React life cycles
    to load this data in the different screens.
  prefs: []
  type: TYPE_NORMAL
- en: Using life cycles in React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start adding styling to your React Native components, you need to
    fetch some data in your application that will be displayed by these components.
    Therefore, you will need to use life cycles to retrieve this data and add it to
    the local state of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch data, you''ll use the `fetch` API again and combine this with the
    `useState` and `useEffect` Hooks to retrieve this data within the life cycles.
    Once the data has been fetched from the mock API, it can be displayed in a React
    Native `FlatList` component. Life cycle methods can be added to your React Native
    application using Hooks by making the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use the `useState` Hook to set the constants for the loading indicator,
    error message, and displaying the data, where the `loading` constant should initially
    be true, the `error` constant should be empty, and the `data` constant should
    be an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to create an asynchronous function to retrieve the data from
    the mock API and call this function from a `useEffect` Hook that is invoked when
    the application mounts. The `fetchAPI` function will change both of the constants
    for `loading`, `error`, and `data` when the API request is successful. If not,
    the error message will be added to the `error` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This data constant can now be added as a prop to a `FlatList` component, which
    iterates over the data and renders components that display this data. `FlatList` returns
    an object that contains a field called `item`, which contains the data of each
    iteration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we can with React, when using a `map` or `forEach` function, you
    need to specify a `key` prop on each iterated component. `FlatList` automatically
    looks for a `key` field in your `data` object, but if you don''t have a specific
    `key` field, you need to set this using the `keyExtractor` prop. It''s important
    to know that the value that''s used for the key should be a string, so you need
    to transform the `id` field that''s returned by the mock API into a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your application will display a list with titles of house listings from
    the mock API, without any routing to a specific listing or styling. This will
    make your application look as follows, where the differences between Android and
    iOS should be limited since we haven''t added any significant styling to the application
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/841776ec-33b6-4991-8327-ba35ae187dab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add the navigation to the `Detail` route again, you need to return a component
    from `FlatList`, which supports `onPress` events. These are, for example, the
    `Button` component you used previously and the `TouchableOpacity` component. This
    last component can be used as a replacement for a `View` component, which doesn''t
    support `onPress` events. Creating navigation here is done by making the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to import the `TouchableOpacity` component from `react-native` and
    wrap the `Text` component returned by `FlatList` with this component. The `onPress` event
    will call the `navigate` function from the `navigation` prop and navigate to the
    `Detail` route if we change the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on any of the titles that are displayed in your application,
    you''ll navigate to the `Detail` route. However, you want this screen to display
    the item you''ve just pressed. Therefore, you will need to pass parameters to
    this route once the `TouchableOpacity` components are pressed. To do this, you
    will need to pass these parameters inside an object to the `navigate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'From the component that is rendered by the `Detail` route, you can take this
    parameter object from the `navigation` prop and use this to display the item.
    To get the parameters from the `navigation` prop, you can use the `getParam` function,
    where you need to specify the name of the parameter you want to get and a fallback
    value for this parameter. Just like we did for the `Home` route, you can display `title`
    of the listing, which in this case should be `title` from the `item` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Instead of passing the entire object containing the data from the item you've
    clicked, you could just send the ID of the item. That way, you could fetch the
    mock API to get the data for this listing and display it on the `Detail` route
    as well. To get an individual listing, you need to send a request to the `'listings/:id'` route.
  prefs: []
  type: TYPE_NORMAL
- en: You're now able to view both a list of all of the listings from the mock API
    and a specific listing from this API. Styling will be added in the next section
    using `styled-components`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling React Native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax you''ve used so far to style React Native components in this application
    looks a bit different from what you''ve used already. Therefore, you can install
    `styled-components` to use the syntax for writing styles you''re already familiar
    with. To install this, you need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the `styled-components` package, after which you can proceed
    by creating styling for the components that are already present in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by transforming the `View` and `FlatList` components in the `Screens/Home.js` file into
    `styled-components`. To do this, you need to import `styled` from `styled-components/native` as
    you only want to import the specific native parts of the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`StyleSheet` at the bottom of the file creates the styling for the `View` component,
    which should be transformed into a component styled with `styled-components`.
    As we saw in the previous chapters, you can extend the style of existing components
    as well. Most of the styling rules can be copied and changed to the `styled-components`
    syntax, as seen in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be done for the `FlatList` component, that is, by extending the
    style for this component with `styled` from `styled-components` and setting custom
    styling rules like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`FlatList` is currently only returning a `Text` component with `title`, while
    more data can be displayed. To do this, you need to create a new component that
    returns multiple components containing the listings data from the mock API. You
    can do this in a new directory called `Components`, which contains another directory
    called `Listing`. In this directory, you need to create the `ListingItem.js` file and
    place the following code block in there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, you import `styled` from `styled-components/native` and
    the components from React Native that you want to style. The `ListingItem` component
    that is exported at the bottom of the file takes an `item` and a `navigation`
    prop to display this data within the created components and handle navigation.
    As we saw with the styled `Image` component, a `source` prop is been given an
    object to display the thumbnail from the mock API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ListingItem` component should now be imported into `Screens/Home.js`,
    where it will be used by `FlatList` to display the listings. This component takes
    both `item` and `navigation` as props, which is done in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In React Native, styling rules are scoped to components, meaning a `Text` component
    can only take styling rules that are specified for this component by React Native.
    When you try to add a styling rule that isn't supported, you'll receive an error
    and a list of all the possible styling rules for this component. Note that `styled-components` automatically
    renames styling rules for you to match the syntax for styling in React Native.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, you''ll have added the first `styled-components` to your
    application. Your application should look as follows when you''re using either
    the iOS Emulator or a device that runs on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6a3a96c-c928-4c90-ac6d-f7a551f9cc5a.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, the styling should look similar on both iOS and Android since we haven't
    added any platform-specific styling to the application yet. This will be done
    in the next part of this section, where you'll explore multiple ways to add styling
    that differs based on the platform that your application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Differences in styling for iOS and Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When styling your application, you might want to have different styling rules
    for iOS and Android, for example, to match the styling of the Android operating
    system better. There are multiple ways to apply different styling rules to different
    platforms; one of them is by using the `Platform` module,  which can be imported
    from React Native.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this by adding icons to the tabs in the `navigator` tab and have
    different icons for iOS and Android:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the icons from Expo into the `App.js` file. There are a lot of
    icon sets available from Expo. For this application, you''ll import the `Ionicons` icon
    set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the tab navigator, you can define which icons should be added
    to the tabs for each route. Therefore, you need to create a `defaultNavigationOptions`
    field in the routing object that should contain a `tabBarIcon` field. In this
    field, you need to take the current route from the `navigation` prop and return
    the icon for this route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '3\. To make a distinction between iOS and Android, you need to import the `Platform` module from
    `react-native`. With this module, you can check whether your mobile device is
    running iOS or Android by checking whether the value of `Platform.OS` is either `ios` or `android`.
    The module must be imported into the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Platform` module, you can change the icon that is being rendered
    for each of the tabs in the navigator. Besides icons designed for iOS, `Ionicons`
    also has icons designed for Android based on Material Design and can be used like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When you're running the application on a mobile device with Android, the `navigator`
    tab will display the icons based on Material Design. If you're using an Apple
    device, it will display different icons; you can change the `Platform.OS === 'ios'` condition to `Platform.OS
    === 'android'` to add the Material Design icons to iOS instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The displayed icons are colored black, while the labels for the active and
    inactive tabs have a different color. You can  specify the colors of the icons
    and the labels in the active and inactive state by changing the configuration
    object. After the `tabBarIcon` field, you can create a new field called `tabBarOptions`
    and add the `activeTintColor` and `inActiveTintColor` fields to them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This only changes the value for the label, but the values for the active and
    inactive tint color are also available on the `tabBarIcon` field it will take
    the `tintColor` prop. This value can be passed to `Ionicons` to change the color
    of the icon as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you view the Home screen, both the tab icon and label are colored
    blue, while the Settings tab will be colored gray. Also, there will be a difference
    in the icons that are displayed on either iOS or Android no matter whether you''re
    running the application on the emulator or a mobile device. If you''re using iOS,
    the application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9222c634-8eda-4ae6-b05d-2ed7a4a6279d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another page that can be styled is the `Detail` screen. For this screen, you
    can also choose to have differences in styling between iOS and Android. As mentioned
    before, there are multiple ways to do this; besides using the `Platform` module,
    you can also use platform-specific file extensions. Any file that has the `*.ios.js`
    or `*.android.js` extension will only be rendered on the platform specified in
    the extension. Not only can you apply different styling rules, but also have changes
    in functionality on different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a specific `Detail` screen for mobile devices running Android, you
    need to create a new file called `Components/Listing/ListingDetail.android.js`.
    This file will have the following code inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, some components will be rendered by the `ListingDetail` component.
    Also, the `Dimensions` module is imported from `react-native`. This module can
    help you get the screen size of the device that which the application is running
    on. By getting the width, you can display an image over the entire width of the
    user's screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For devices running iOS, you can do the same, but this time you need to create
    a new file called `Components/Listing/ListingDetail.ios.js`. This file will contain
    a variant of the code that''s running on Android, where the image will be displayed
    over the entire height of the screen using the `Dimensions` module. The `ListingDetail`
    component for iOS can be created by pasting the following code block into that
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To display one of these components in your application, some changes need to
    made to the `Screens/Detail.js` file. The `ListingDetail` component should be
    imported into this file and returned with the `item` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application now has two different versions of the Detail screen for iOS
    and Android, and React Native will make sure that the file with the right extension
    will run on that operating system. You can check this by comparing the application
    that runs on your Android Emulator or mobile device with the following screenshot,
    which was taken from an iOS device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb97a0eb-ee44-4098-946e-699afe265f14.png)'
  prefs: []
  type: TYPE_IMG
- en: With these last changes, you've created your first React Native application
    that will run on both Android and iOS devices and has basic routing and styling
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a house listing application with React Native for
    both iOS and Android mobile devices. Expo was used to create the first version
    of the application and provides a lot of functionality to smoothen the developer
    experience. The `react-navigation` package is used to handle different kinds of
    routing for mobile applications, while `styled-components` is utilized to handle
    styling for this React Native application.
  prefs: []
  type: TYPE_NORMAL
- en: Since this was probably your first introduction to React Native, you shouldn't
    feel bad if not everything was clear from the start. The basics you learned about
    in this chapter should provide a proper baseline so that we can continue your
    journey into the world of mobile app development. The project you'll create in
    the next chapter will build upon these principles further and handle features
    such as animations while we create a *Tic-Tac-Toe* game.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find out more about custom headers in React Navigation, check out this link: [https://reactnavigation.org/docs/en/headers.html](https://reactnavigation.org/docs/en/headers.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a list of Expo icons here: [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
