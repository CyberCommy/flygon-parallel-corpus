- en: Chapter 9. Network Interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network interoperability refers to the ability of systems that differ in implementation
    technology to reliably and accurately interchange information. This means that
    the factors, such as the underlying hardware, operating system, and implementation
    language, may differ between platforms, yet they will not adversely affect the
    ability of these systems to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: There are several factors that can impact interoperability. These range from
    low-level issues, such as the byte order that is used by primitive data types,
    to higher-level technologies, such as web services that largely hide much of their
    implementation details. In this chapter, we will explore many of these factors.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a discussion of the byte order that is used to support primitive
    data types. This is fundamental to the transfer of data. Different byte orders
    will result in significant differences in how information is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how Java applications can interact with applications that
    are written in different languages. These may be JVM-based languages or languages
    that are radically different from Java.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental network communication construct is the socket. This entity typically
    functions in a TCP/IP environment. We will demonstrate how Java sockets can interact
    with sockets that are written in different languages, specifically C#.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant support for interoperability exists in the form of communications
    standards that are typified by web services. These applications support communication
    between disparate systems using standardized middleware. Much of the details of
    communication are hidden by these middleware implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will investigate the following interoperability topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How Java handles byte order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with other languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware to achieve interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start with a discussion of byte order and how it can impact interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: Byte order in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of byte order: **big endian**, and **little endian**. These
    terms refer to the order that a multi-byte quantity is stored in memory. To illustrate
    this, consider how an integer is stored in memory. As an integer consists of 4
    bytes, these bytes are assigned to a 4-byte region of memory. However, these bytes
    can be stored in different ways. Big endian places the most significant byte first,
    while little endian places the least significant byte first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declaration and initialization of an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the four bytes of memory are shown using big endian,
    assuming that the integer has been allocated to address `1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Byte |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 01 |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 23 |'
  prefs: []
  type: TYPE_TB
- en: '| 1002 | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| 1003 | 67 |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows how the integer will be stored using little endian:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Byte |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 67 |'
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 45 |'
  prefs: []
  type: TYPE_TB
- en: '| 1002 | 23 |'
  prefs: []
  type: TYPE_TB
- en: '| 1003 | 01 |'
  prefs: []
  type: TYPE_TB
- en: 'The endianness varies by machines in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Intel-based processors uses little endian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM processors may use little endian or big endian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motorola 68K processors use big endian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motorola PowerPC use big endian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sun SPARK processors use big endian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data, such as ASCII strings, is not an issue because these bytes are
    stored in consecutive order. For other data types, such as floats, and longs,
    it can be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to know which representation the current machine supports, the `ByteOder`
    class in the `java.nio` package can determine the current byte order. The following
    statement will display the endianness for the current platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For a Windows platform, it will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DataOutputStream` class''s methods automatically use big endian. The `ByteBuffer`
    class also uses big endian by default. However, as shown next, the order can be
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BIG_ENDIAN**'
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once established, other methods, such as the `slice` method, do not change
    the byte order that is used, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  prefs: []
  type: TYPE_NORMAL
- en: The endianness is normally handled automatically on a machine. However, when
    we transfer data between machines that use different endianness, we can have a
    problem. It is possible that the bytes transferred will be in the wrong order
    at their destination.
  prefs: []
  type: TYPE_NORMAL
- en: Networks typically use big endian, which is also known as **network byte order**.
    Any data sent through a socket should use big endian. When sending information
    between Java applications, the endianness is not normally an issue. However, the
    endianness is more significant when interacting with non-Java technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with other languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to access libraries that are written in a different
    language. While this is not exclusively a network issue, Java provides support
    in a number of ways. Direct interface with other languages does not take place
    across a network, but rather occurs on the same machine. We will briefly examine
    some of these interface issues.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using another Java library, then we simply need to load the classes.
    If we need to interface with non-Java languages, then we can use the **Java Native
    Interface** (**JNI**) API or some other library. However, if this language is
    a JVM-based language, then the process is much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with JVM based languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Java Virtual Machine** (**JVM**) executes Java byte codes. However, this
    is not the only language that uses a JVM. Other languages include the following
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nashorn**: This uses JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clojure**: This is a Lisp dialect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groovy**: This is a scripting language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scala**: This combines the object-oriented and functional programming approaches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JRuby**: This is the Java implementation of Ruby'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jthon**: This is the Java implementation of Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jacl**: This is the Java implementation of Tcl'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TuProlog**: This is the Java-based implementation of Prolog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more complete list of JVM-based languages can be found at [https://en.wikipedia.org/wiki/List_of_JVM_languages](https://en.wikipedia.org/wiki/List_of_JVM_languages).
    Using the same JVM base will facilitate the sharing of code and libraries. Often,
    it is possible to not only use libraries that were developed in a different JVM-based
    language, but to also derive from classes that were developed in different languages.
  prefs: []
  type: TYPE_NORMAL
- en: Many languages have been ported to JVM because it is easier to use the JVM than
    create multiple compilers or interpreters for different platforms. For example,
    Ruby and Python have JVM implementations for this reason. These languages can
    take advantage of the JVM's portability and its **Just-In-Time** (**JIT**) compilation
    process. In addition to this, the JVM has a large library of well-tested code
    to build upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nashorn is a JavaScript engine that is built on top of the JVM and was added
    in Java 8\. This allows JavaScript code to be readily integrated into a Java application.
    The following code sequence illustrates this process. An instance of the JavaScript
    engine is obtained and then JavaScript code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing JavaScript code**'
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated JavaScript processing is possible. More details about this
    technology can be found at [https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/](https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/).
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with non-JVM languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common technique to access code in a different language is through the JNI
    API. This API provides a means of accessing C/C++ code. This approach is well
    documented and will not be demonstrated here. However, a good introduction to
    this API can be found at [http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html](http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to access .NET code from Java. One technique uses JNI to access
    C#. An example of how to access C++, managed C++, and C# code is found at [http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program](http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program).
  prefs: []
  type: TYPE_NORMAL
- en: Communication through simple sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to transfer information between applications that are written
    in different languages using sockets. The socket concept is not unique to Java
    and has been implemented in many languages. As sockets work at the TCP/IP level,
    they can communicate without much effort.
  prefs: []
  type: TYPE_NORMAL
- en: The primary interoperability consideration concerns the data that is transmitted.
    Incompatibilities can occur when the internal representation of data differs significantly
    between two different languages. This may be due to the use of big endian versus
    little endian in how a data type is represented internally, and whether a particular
    data type even exists in another language. For example, in C there is no distinct
    Boolean data type. It is represented using an integer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a server in Java and a client in C#. To demonstrate
    the use sockets, a string will be transferred between these two applications.
    We will find that transferring even a simple data type, such as strings, can be
    more difficult than it seems.
  prefs: []
  type: TYPE_NORMAL
- en: The Java server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server is declared in the `JavaSocket` class, as shown next. It looks very
    similar to previous versions of the echo server that was developed in this book.
    A server socket is created and then blocks until the `accept` method returns with
    a socket connected to a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Scanner` class is used to read messages that are sent from a client. A
    `PrintWriter` instance is used to reply to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nextLine` method retrieves a message, which is displayed and sent back
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The server will then terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine the C# application.
  prefs: []
  type: TYPE_NORMAL
- en: The C# client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CSharpClient` class, as shown next, implements the client. C# is similar
    in form and syntax to Java, though the class libraries are often different. We
    will not provide a detailed explanation of the code, but we will cover the important
    features of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` statement corresponds to the import statement in Java. Similar
    to Java, the first method to execute is the `Main` method. C# typically uses a
    different indention style and name convention than Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IPEndPoint` variable represents an Internet address, and the `Socket`
    class, as you may expect, represents a socket. The `Connect` method connects to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Console` class''s `Write` method displays information in a command window.
    Here, the user is prompted for a message to send to the server. The `ReadLine`
    method reads in the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Send` method will transmit data to the server. However, it requires the
    data to be placed into a byte buffer, as shown next. The message and an appended
    carriage return/line feed character is encoded and inserted into the buffer. The
    appended character is needed so that the server can read the string correctly
    and know when the string is terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Receive` method reads the server''s response. Similar to the `Send` method,
    it requires a byte buffer. This buffer was created with a size of 32 bytes. This
    limits the size of the message, but we will discuss how to overcome this limitation
    shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The receiving buffer is converted into a string and displayed. The beginning
    and closing brackets are used to clearly delineate the buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The socket is closed and the application terminates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The client/server in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the server and then the client. The client's user will be prompted for
    a message. Enter a message. The message will be sent and the response will be
    displayed in the client window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server output is displayed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client connection completed**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server received: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server sent: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client side appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter message: The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client received: [The message**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Press any key to continue . . .**'
  prefs: []
  type: TYPE_NORMAL
- en: You will note that the received message is larger than expected. This is because
    the client's receive byte buffer was 32 bytes long. This implementation used a
    fixed-size buffer. As the size of the response from the server may not always
    be known, the buffer needs to be large enough to hold responses. A size of 32
    was used to limit the server's output.
  prefs: []
  type: TYPE_NORMAL
- en: This limitation can be overcome in a number of ways. One approach appends a
    special character at the end of the string and then uses this marker to construct
    the response. Another approach sends the length of the response first, followed
    by the response. The receiving buffer can be allocated based on the response's
    length.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a string is useful to transmit formatted information. For example, the
    message that was sent could have been an XML or JSON document. This will facilitate
    the transmission of more sophisticated content.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability through middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network technologies have evolved considerably over the last 20 years. Low-level
    socket support provides the foundation for most of these technologies. However,
    they are hidden from the user through multiple layers of software. These layers
    are referred to as **middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability is achieved through middleware, such as JMI, SOAP, and JAX-WS—to
    mention a few. The Java EE edition is aimed primarily at supporting these middleware-type
    technologies. Java EE started with **servlets**, a Java application that was used
    to support web pages. It has evolved to include **Java Server Pages** (**JSP**)
    and eventually to **Faclets** both of which hide underlying Servlets.
  prefs: []
  type: TYPE_NORMAL
- en: These technologies are concerned with providing services to users whether they
    are a human at a browser or another application. The users are not necessarily
    aware of how the service is implemented. Communication is achieved through a number
    of different standards and data is frequently encapsulated in language neutral
    XML documents. Thus, a server and a client can be written in different languages
    and run in different execution environments promoting interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of technologies that are available, there are two
    common approaches that are used: RESTful Web Services, and SOAP-based Web Services.
    **REpresentational State Transfer Web Services** (**RESTful Web Services**) use
    HTTP and the standard commands (`PUT`, `POST`, `GET`, `DELETE`) to support the
    distribution of web pages and other resources. Its intent is to simplify how these
    types of services can be created. The interaction between the client and the server
    is stateless. That is, what was previously processed will not affect how the current
    request will be handled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SOAP-based Web Services** uses the **Simple Object Access Protocol** (**SOAP**)
    to exchange structured information. It uses application layer protocols, such
    as HTTP, and SMTP, and communicates using XML. We will focus on JAX-RS.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Java API for RESTful Web Services** (**JAX-RS**) is an API supporting
    the development of RESTful services. It uses a series of annotations to map resources
    to Java implementations. To demonstrate how this technology works, we will create
    a simple RESTful application using NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create the server first and then a simple console-based application
    to access the server. We will use NetBeans IDE 8.0.2 to develop this service.
    NetBeans can be downloaded from [https://netbeans.org/downloads/](https://netbeans.org/downloads/).
    Choose the Java EE Edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once NetBeans has been installed, start it and then create a new project from
    the **File** | **New Project…** menu item. This will bring up the **New Project**
    dialog box, as shown next. Select the **Java Web** category and the **Web Application**
    project. Then, select the **Next** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Give the project a name. In the following figure, we used `SimpleRestfulService`
    as its name. Choose an appropriate location to save the project and then select
    **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Server and Settings** step, choose the GlassFish server and Java EE7
    Web. GlassFish is a web server that we will use to host the service. The **Context
    Path** field will become part of the URL passed to the server. Click on **Next**
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can choose from one of three design patterns to create our RESTful service.
    For this example, choose the first one, **Simple Root Resource**, and then click
    on **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the **Specify Resource Classes** step, complete the dialog box, as shown
    next. The resource package is where the Java classes will be placed. The path
    is used to identify the resource to the user. The class name field will be the
    name of the Java class supporting the resource. When done, click on **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The IDE will then generate the files, including the `ApplicationConfig.java`
    and `SimpleRestfulService.java` files. The `ApplicationConfig.java` file is used
    to configure the service. Our main interest is the `SimpleRestfulService.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SimpleRestfulService` class is the `getHtml` method, as duplicated
    next. Its purpose is to generate a response to the `GET` command. The first annotation
    designates this method as the method to call when the `HTTP GET` command is used.
    The second annotation specifies that the intended output of this method is HTML
    text. The return statement that is generated by the IDE has been replaced with
    a simple HTML response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the service is requested with a `GET` command, the HTML text will be returned.
    All of the intermediate steps, including the use of sockets, are hidden, simplifying
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RESTful service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will develop a client application to access this resource. However, we can
    test the resource using built-in facilities. To test the service, right-click
    on the project''s name in the **Project Explorer** window and select the **Test
    RESTful Web Services** menu item. This will bring up the following window. Click
    on **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may receive a security alert on Windows as follows. Select the **Allow
    access** button if this occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your default browser will display the test page, as shown next. Select the
    **packt** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The resource will then appear on the right-hand side, as shown next. This allows
    us to select the test method. As the `GET` command has been chosen by default,
    click on the **Test** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `GET` command is then sent to the server and the response is displayed,
    as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More sophisticated processing can be performed using JAX_RS. However, this illustrates
    the basic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RESTful service can be called by any number of applications that are written
    in various languages. Here, we will create a simple Java client to access this
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and select the **RESTful Java Client** option from the
    **Web Services** category, as shown next. Then click on **Next**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful client](img/B04915_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Name and Location** step dialog box will appear, as shown in the following
    screenshot. We need to select the RESTful resource. We can perform this by clicking
    on the **Browse…** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful client](img/B04915_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Available REST Resources** dialog will appear, as shown next. Expand
    our RESTful project and select the resource, as shown in the next screenshot,
    and then click on **OK**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful client](img/B04915_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The completed dialog box should appear as follows. Click on **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful client](img/B04915_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `RestfulClient` class is then generated. We are interested in the `getHtml`
    method, as shown next. This will return the HTML text from the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the application, add the following `main` met`hod, which invokes the
    `getHtml` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the GlassFish server is running, and execute the program. The
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<html><body><h1>Simple Restful Example</body></h1></html>**'
  prefs: []
  type: TYPE_NORMAL
- en: While we will not normally display HTML text in a console, this illustrated
    the process that we use to obtain information from a RESTful service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored many of the factors that impact network interoperability.
    At a low-level, the byte order becomes important. We learned that systems either
    use a big endian or a little endian byte order. The order can be determined and
    controlled by Java applications. Network communication normally uses big endian
    when transferring data.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to communicate with other languages, we found that JVM-based languages
    are easier to work with because they share the same byte code base. If we need
    to work with other languages, then JNI is commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: A socket is not a Java-unique concept. It normally is used in a TCP/IP environment,
    which implies that a socket that is written in one language can easily communicate
    with a socket that is written in a different language. We demonstrated this ability
    using a Java server and a C# client.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored how middleware can support interoperability by abstracting
    much of the low-level communication detail. Using concepts, such as web services,
    we learned that the details of low-level socket interactions are hidden. We demonstrated
    this using JAX-RS, which supports a RESTful approach where HTTP commands, such
    as GET, and POST, are mapped to specific Java functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Network interoperability is an important consideration in enterprise-level applications
    where the enterprise's functionality is distributed using various technologies.
    This interoperability is possible through the use of standard middleware protocols
    and products.
  prefs: []
  type: TYPE_NORMAL
