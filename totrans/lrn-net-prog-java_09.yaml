- en: Chapter 9. Network Interoperability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network interoperability refers to the ability of systems that differ in implementation
    technology to reliably and accurately interchange information. This means that
    the factors, such as the underlying hardware, operating system, and implementation
    language, may differ between platforms, yet they will not adversely affect the
    ability of these systems to communicate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There are several factors that can impact interoperability. These range from
    low-level issues, such as the byte order that is used by primitive data types,
    to higher-level technologies, such as web services that largely hide much of their
    implementation details. In this chapter, we will explore many of these factors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We start with a discussion of the byte order that is used to support primitive
    data types. This is fundamental to the transfer of data. Different byte orders
    will result in significant differences in how information is interpreted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how Java applications can interact with applications that
    are written in different languages. These may be JVM-based languages or languages
    that are radically different from Java.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental network communication construct is the socket. This entity typically
    functions in a TCP/IP environment. We will demonstrate how Java sockets can interact
    with sockets that are written in different languages, specifically C#.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The most significant support for interoperability exists in the form of communications
    standards that are typified by web services. These applications support communication
    between disparate systems using standardized middleware. Much of the details of
    communication are hidden by these middleware implementations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'We will investigate the following interoperability topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: How Java handles byte order
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing with other languages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using middleware to achieve interoperability
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start with a discussion of byte order and how it can impact interoperability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Byte order in Java
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of byte order: **big endian**, and **little endian**. These
    terms refer to the order that a multi-byte quantity is stored in memory. To illustrate
    this, consider how an integer is stored in memory. As an integer consists of 4
    bytes, these bytes are assigned to a 4-byte region of memory. However, these bytes
    can be stored in different ways. Big endian places the most significant byte first,
    while little endian places the least significant byte first.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following declaration and initialization of an integer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following example, the four bytes of memory are shown using big endian,
    assuming that the integer has been allocated to address `1000`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Byte |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 01 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 23 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| 1002 | 45 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| 1003 | 67 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: 'The following table shows how the integer will be stored using little endian:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '| Address | Byte |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| 1000 | 67 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| 1001 | 45 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| 1002 | 23 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| 1003 | 01 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: 'The endianness varies by machines in the following ways:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Intel-based processors uses little endian
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM processors may use little endian or big endian
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motorola 68K processors use big endian
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motorola PowerPC use big endian
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sun SPARK processors use big endian
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data, such as ASCII strings, is not an issue because these bytes are
    stored in consecutive order. For other data types, such as floats, and longs,
    it can be an issue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to know which representation the current machine supports, the `ByteOder`
    class in the `java.nio` package can determine the current byte order. The following
    statement will display the endianness for the current platform:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For a Windows platform, it will display the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DataOutputStream` class''s methods automatically use big endian. The `ByteBuffer`
    class also uses big endian by default. However, as shown next, the order can be
    specified:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will display the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**BIG_ENDIAN**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Once established, other methods, such as the `slice` method, do not change
    the byte order that is used, as demonstrated here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**LITTLE_ENDIAN**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The endianness is normally handled automatically on a machine. However, when
    we transfer data between machines that use different endianness, we can have a
    problem. It is possible that the bytes transferred will be in the wrong order
    at their destination.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Networks typically use big endian, which is also known as **network byte order**.
    Any data sent through a socket should use big endian. When sending information
    between Java applications, the endianness is not normally an issue. However, the
    endianness is more significant when interacting with non-Java technologies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with other languages
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to access libraries that are written in a different
    language. While this is not exclusively a network issue, Java provides support
    in a number of ways. Direct interface with other languages does not take place
    across a network, but rather occurs on the same machine. We will briefly examine
    some of these interface issues.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: If we are using another Java library, then we simply need to load the classes.
    If we need to interface with non-Java languages, then we can use the **Java Native
    Interface** (**JNI**) API or some other library. However, if this language is
    a JVM-based language, then the process is much easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with JVM based languages
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Java Virtual Machine** (**JVM**) executes Java byte codes. However, this
    is not the only language that uses a JVM. Other languages include the following
    ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Nashorn**: This uses JavaScript'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clojure**: This is a Lisp dialect'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groovy**: This is a scripting language'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scala**: This combines the object-oriented and functional programming approaches'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JRuby**: This is the Java implementation of Ruby'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jthon**: This is the Java implementation of Python'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jacl**: This is the Java implementation of Tcl'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TuProlog**: This is the Java-based implementation of Prolog'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more complete list of JVM-based languages can be found at [https://en.wikipedia.org/wiki/List_of_JVM_languages](https://en.wikipedia.org/wiki/List_of_JVM_languages).
    Using the same JVM base will facilitate the sharing of code and libraries. Often,
    it is possible to not only use libraries that were developed in a different JVM-based
    language, but to also derive from classes that were developed in different languages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Many languages have been ported to JVM because it is easier to use the JVM than
    create multiple compilers or interpreters for different platforms. For example,
    Ruby and Python have JVM implementations for this reason. These languages can
    take advantage of the JVM's portability and its **Just-In-Time** (**JIT**) compilation
    process. In addition to this, the JVM has a large library of well-tested code
    to build upon.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Nashorn is a JavaScript engine that is built on top of the JVM and was added
    in Java 8\. This allows JavaScript code to be readily integrated into a Java application.
    The following code sequence illustrates this process. An instance of the JavaScript
    engine is obtained and then JavaScript code is executed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of this sequence is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing JavaScript code**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: More sophisticated JavaScript processing is possible. More details about this
    technology can be found at [https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/](https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/nashorn/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with non-JVM languages
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common technique to access code in a different language is through the JNI
    API. This API provides a means of accessing C/C++ code. This approach is well
    documented and will not be demonstrated here. However, a good introduction to
    this API can be found at [http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html](http://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to access .NET code from Java. One technique uses JNI to access
    C#. An example of how to access C++, managed C++, and C# code is found at [http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program](http://www.codeproject.com/Articles/13093/C-method-calls-within-a-Java-program).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Communication through simple sockets
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to transfer information between applications that are written
    in different languages using sockets. The socket concept is not unique to Java
    and has been implemented in many languages. As sockets work at the TCP/IP level,
    they can communicate without much effort.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The primary interoperability consideration concerns the data that is transmitted.
    Incompatibilities can occur when the internal representation of data differs significantly
    between two different languages. This may be due to the use of big endian versus
    little endian in how a data type is represented internally, and whether a particular
    data type even exists in another language. For example, in C there is no distinct
    Boolean data type. It is represented using an integer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a server in Java and a client in C#. To demonstrate
    the use sockets, a string will be transferred between these two applications.
    We will find that transferring even a simple data type, such as strings, can be
    more difficult than it seems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The Java server
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The server is declared in the `JavaSocket` class, as shown next. It looks very
    similar to previous versions of the echo server that was developed in this book.
    A server socket is created and then blocks until the `accept` method returns with
    a socket connected to a client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Scanner` class is used to read messages that are sent from a client. A
    `PrintWriter` instance is used to reply to the client:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `nextLine` method retrieves a message, which is displayed and sent back
    to the client:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The server will then terminate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine the C# application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The C# client
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CSharpClient` class, as shown next, implements the client. C# is similar
    in form and syntax to Java, though the class libraries are often different. We
    will not provide a detailed explanation of the code, but we will cover the important
    features of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The `using` statement corresponds to the import statement in Java. Similar
    to Java, the first method to execute is the `Main` method. C# typically uses a
    different indention style and name convention than Java:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `IPEndPoint` variable represents an Internet address, and the `Socket`
    class, as you may expect, represents a socket. The `Connect` method connects to
    the server:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Console` class''s `Write` method displays information in a command window.
    Here, the user is prompted for a message to send to the server. The `ReadLine`
    method reads in the user input:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Send` method will transmit data to the server. However, it requires the
    data to be placed into a byte buffer, as shown next. The message and an appended
    carriage return/line feed character is encoded and inserted into the buffer. The
    appended character is needed so that the server can read the string correctly
    and know when the string is terminated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Receive` method reads the server''s response. Similar to the `Send` method,
    it requires a byte buffer. This buffer was created with a size of 32 bytes. This
    limits the size of the message, but we will discuss how to overcome this limitation
    shortly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The receiving buffer is converted into a string and displayed. The beginning
    and closing brackets are used to clearly delineate the buffer:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The socket is closed and the application terminates:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The client/server in action
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start the server and then the client. The client's user will be prompted for
    a message. Enter a message. The message will be sent and the response will be
    displayed in the client window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'The server output is displayed here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Started**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Client connection completed**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '**Server received: The message**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Server sent: The message**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Terminated**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The client side appears as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Started**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter message: The message**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Client received: [The message**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**Client Terminated**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Press any key to continue . . .**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: You will note that the received message is larger than expected. This is because
    the client's receive byte buffer was 32 bytes long. This implementation used a
    fixed-size buffer. As the size of the response from the server may not always
    be known, the buffer needs to be large enough to hold responses. A size of 32
    was used to limit the server's output.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: This limitation can be overcome in a number of ways. One approach appends a
    special character at the end of the string and then uses this marker to construct
    the response. Another approach sends the length of the response first, followed
    by the response. The receiving buffer can be allocated based on the response's
    length.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Sending a string is useful to transmit formatted information. For example, the
    message that was sent could have been an XML or JSON document. This will facilitate
    the transmission of more sophisticated content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability through middleware
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network technologies have evolved considerably over the last 20 years. Low-level
    socket support provides the foundation for most of these technologies. However,
    they are hidden from the user through multiple layers of software. These layers
    are referred to as **middleware**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability is achieved through middleware, such as JMI, SOAP, and JAX-WS—to
    mention a few. The Java EE edition is aimed primarily at supporting these middleware-type
    technologies. Java EE started with **servlets**, a Java application that was used
    to support web pages. It has evolved to include **Java Server Pages** (**JSP**)
    and eventually to **Faclets** both of which hide underlying Servlets.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: These technologies are concerned with providing services to users whether they
    are a human at a browser or another application. The users are not necessarily
    aware of how the service is implemented. Communication is achieved through a number
    of different standards and data is frequently encapsulated in language neutral
    XML documents. Thus, a server and a client can be written in different languages
    and run in different execution environments promoting interoperability.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of technologies that are available, there are two
    common approaches that are used: RESTful Web Services, and SOAP-based Web Services.
    **REpresentational State Transfer Web Services** (**RESTful Web Services**) use
    HTTP and the standard commands (`PUT`, `POST`, `GET`, `DELETE`) to support the
    distribution of web pages and other resources. Its intent is to simplify how these
    types of services can be created. The interaction between the client and the server
    is stateless. That is, what was previously processed will not affect how the current
    request will be handled.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '**SOAP-based Web Services** uses the **Simple Object Access Protocol** (**SOAP**)
    to exchange structured information. It uses application layer protocols, such
    as HTTP, and SMTP, and communicates using XML. We will focus on JAX-RS.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The **Java API for RESTful Web Services** (**JAX-RS**) is an API supporting
    the development of RESTful services. It uses a series of annotations to map resources
    to Java implementations. To demonstrate how this technology works, we will create
    a simple RESTful application using NetBeans.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful service
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create the server first and then a simple console-based application
    to access the server. We will use NetBeans IDE 8.0.2 to develop this service.
    NetBeans can be downloaded from [https://netbeans.org/downloads/](https://netbeans.org/downloads/).
    Choose the Java EE Edition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Once NetBeans has been installed, start it and then create a new project from
    the **File** | **New Project…** menu item. This will bring up the **New Project**
    dialog box, as shown next. Select the **Java Web** category and the **Web Application**
    project. Then, select the **Next** button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Give the project a name. In the following figure, we used `SimpleRestfulService`
    as its name. Choose an appropriate location to save the project and then select
    **Next**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'In the **Server and Settings** step, choose the GlassFish server and Java EE7
    Web. GlassFish is a web server that we will use to host the service. The **Context
    Path** field will become part of the URL passed to the server. Click on **Next**
    again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'We can choose from one of three design patterns to create our RESTful service.
    For this example, choose the first one, **Simple Root Resource**, and then click
    on **Next**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'In the **Specify Resource Classes** step, complete the dialog box, as shown
    next. The resource package is where the Java classes will be placed. The path
    is used to identify the resource to the user. The class name field will be the
    name of the Java class supporting the resource. When done, click on **Finish**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful service](img/B04915_09_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: The IDE will then generate the files, including the `ApplicationConfig.java`
    and `SimpleRestfulService.java` files. The `ApplicationConfig.java` file is used
    to configure the service. Our main interest is the `SimpleRestfulService.java`
    file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SimpleRestfulService` class is the `getHtml` method, as duplicated
    next. Its purpose is to generate a response to the `GET` command. The first annotation
    designates this method as the method to call when the `HTTP GET` command is used.
    The second annotation specifies that the intended output of this method is HTML
    text. The return statement that is generated by the IDE has been replaced with
    a simple HTML response:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the service is requested with a `GET` command, the HTML text will be returned.
    All of the intermediate steps, including the use of sockets, are hidden, simplifying
    the development process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RESTful service
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will develop a client application to access this resource. However, we can
    test the resource using built-in facilities. To test the service, right-click
    on the project''s name in the **Project Explorer** window and select the **Test
    RESTful Web Services** menu item. This will bring up the following window. Click
    on **OK**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'You may receive a security alert on Windows as follows. Select the **Allow
    access** button if this occurs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'Your default browser will display the test page, as shown next. Select the
    **packt** node:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_08.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'The resource will then appear on the right-hand side, as shown next. This allows
    us to select the test method. As the `GET` command has been chosen by default,
    click on the **Test** button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: The `GET` command is then sent to the server and the response is displayed,
    as shown next.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the RESTful service](img/B04915_09_10.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: More sophisticated processing can be performed using JAX_RS. However, this illustrates
    the basic approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful client
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RESTful service can be called by any number of applications that are written
    in various languages. Here, we will create a simple Java client to access this
    service.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project and select the **RESTful Java Client** option from the
    **Web Services** category, as shown next. Then click on **Next**:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a RESTful client](img/B04915_09_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'The **Name and Location** step dialog box will appear, as shown in the following
    screenshot. We need to select the RESTful resource. We can perform this by clicking
    on the **Browse…** button:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称和位置**步骤对话框将显示如下截图所示。我们需要选择RESTful资源。我们可以通过单击**浏览...**按钮来执行此操作：'
- en: '![Creating a RESTful client](img/B04915_09_12.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_12.jpg)'
- en: 'The **Available REST Resources** dialog will appear, as shown next. Expand
    our RESTful project and select the resource, as shown in the next screenshot,
    and then click on **OK**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用的REST资源**对话框将显示如下。展开我们的RESTful项目并选择资源，如下截图所示，然后单击**确定**：'
- en: '![Creating a RESTful client](img/B04915_09_13.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_13.jpg)'
- en: 'The completed dialog box should appear as follows. Click on **Finish**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的对话框应如下所示。单击**完成**：
- en: '![Creating a RESTful client](img/B04915_09_14.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![创建RESTful客户端](img/B04915_09_14.jpg)'
- en: 'The `RestfulClient` class is then generated. We are interested in the `getHtml`
    method, as shown next. This will return the HTML text from the service:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后生成`RestfulClient`类。我们对`getHtml`方法感兴趣，如下所示。这将从服务返回HTML文本：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To test the application, add the following `main` met`hod, which invokes the
    `getHtml` method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试应用程序，请添加以下`main`方法，调用`getHtml`方法：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Make sure that the GlassFish server is running, and execute the program. The
    output will be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 确保GlassFish服务器正在运行，并执行程序。输出将如下所示：
- en: '**<html><body><h1>Simple Restful Example</body></h1></html>**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**<html><body><h1>简单的Restful示例</body></h1></html>**'
- en: While we will not normally display HTML text in a console, this illustrated
    the process that we use to obtain information from a RESTful service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常不会在控制台中显示HTML文本，但这说明了我们从RESTful服务获取信息的过程。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored many of the factors that impact network interoperability.
    At a low-level, the byte order becomes important. We learned that systems either
    use a big endian or a little endian byte order. The order can be determined and
    controlled by Java applications. Network communication normally uses big endian
    when transferring data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了许多影响网络互操作性的因素。在低级别上，字节顺序变得重要。我们了解到系统使用大端或小端字节顺序。顺序可以由Java应用程序确定和控制。网络通信在传输数据时通常使用大端。
- en: If we need to communicate with other languages, we found that JVM-based languages
    are easier to work with because they share the same byte code base. If we need
    to work with other languages, then JNI is commonly used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要与其他语言通信，我们发现基于JVM的语言更容易使用，因为它们共享相同的字节码基础。如果我们需要与其他语言一起工作，那么通常使用JNI。
- en: A socket is not a Java-unique concept. It normally is used in a TCP/IP environment,
    which implies that a socket that is written in one language can easily communicate
    with a socket that is written in a different language. We demonstrated this ability
    using a Java server and a C# client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字不是Java独有的概念。它通常用于TCP/IP环境，这意味着用一种语言编写的套接字可以轻松地与用另一种语言编写的套接字进行通信。我们使用Java服务器和C#客户端演示了这种能力。
- en: We also explored how middleware can support interoperability by abstracting
    much of the low-level communication detail. Using concepts, such as web services,
    we learned that the details of low-level socket interactions are hidden. We demonstrated
    this using JAX-RS, which supports a RESTful approach where HTTP commands, such
    as GET, and POST, are mapped to specific Java functionality.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了中间件如何通过抽象化大部分低级通信细节来支持互操作性。使用诸如Web服务之类的概念，我们了解到低级套接字交互的细节被隐藏起来。我们使用JAX-RS进行了演示，它支持RESTful方法，其中HTTP命令（如GET和POST）被映射到特定的Java功能。
- en: Network interoperability is an important consideration in enterprise-level applications
    where the enterprise's functionality is distributed using various technologies.
    This interoperability is possible through the use of standard middleware protocols
    and products.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 网络互操作性是企业级应用程序中的重要考虑因素，企业的功能是通过各种技术进行分布的。通过使用标准中间件协议和产品，可以实现这种互操作性。
