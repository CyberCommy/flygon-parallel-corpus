- en: RxCpp – the Key Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we were introduced to the RxCpp library and its programming
    model. We wrote some programs to understand workings of the library and  also
    covered the most essential elements of the RxCpp library. In this chapter, we
    will cover, in some depth, the key elements of reactive programming , which includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observers and their variants (Subscribers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In effect, the key aspects of reactive programming are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables are Streams to which Observers can subscribe for notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Subject is a combination of Observable and Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulers execute the Action associated with Operators and help the flow of
    data from Observables to Observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators are functions that take an Observable and emit another Observable
    (well, almost!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created Observables from the  scratch and  subscribed
    to those Observables. In all of our examples, the Observables created an instance
    of the  (data)  `Producer` class. The `Producer` class produces an event Stream.
    In other words, Observables are functions that connect Subscribers (Observers)
    to Producers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, let''s dissect an Observable and the core activities related
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: An Observable is a function that takes an Observer as a parameter and returns
    a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Observable connects an Observer to a Producer (Producer is opaque to the
    Observer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Producer is a source of values for an Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Observer is an object that has the `on_next`, `on_error`, and `on_completed`
    methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a Producer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell,A Producer is a source of value for an Observable. Producers can
    be  GUI windows, Timers, WebSockets, DOM trees, Iterators over collections/containers,
    and so on. They can be anything that can be a source of values that can be passed
    on to  OnNext method of the  Observer ( In `RxCpp`, `observer.on_next(value)`.)
    . Of course, values can passed on to Operators,which in turn will be passed on
    to the internal Observer of Operators .
  prefs: []
  type: TYPE_NORMAL
- en: Hot versus Cold Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most  examples in the previous chapter, we saw that Producers were created
    in Observable functions. A Producer can also  be created outside an Observable
    function, and a reference to the Producer can be put inside the Observable function.
    An Observable that refers to a Producer which was created outside its scope is
    called a hot Observable. Any Observable where we created a Producer instance inside
    (an Observable)  is called a cold Observable. To make matters clear, let''s write
    a program to demonstrate a cold Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above code, the interval method created a cold Observable, as the Producer
    for the event Stream is instantiated int the `interval` function. A cold Observable
    will emit data when a Subscriber or an Observer is attached to it. Even if there
    is a delay in subscription between two Observers, the result will be consistent.
    This means both Observers we will get all the data emitted by the Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output emitted by the program is given below. For each run, the order of
    content in the console may change, as we are scheduling the execution of  Observer
    methods in the same thread. But, there won''t be any data loss, due to the delay
    in subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Hot Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can convert a cold Observable into a hot Observable by invoking the Observable''s
    `publish` method. The consequence of converting a cold Observable to a hot Observable
    will be the fact that data can be missed by later subscriptions. A hot Observable
    emits data whether there is a subscription or not. The following program demonstrates
    the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we will take a look at the `publish_synchronized` mechanism
    supported by  the  `RxCpp library.` From a programming interface perspective,
    this is just a small change. Take a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows. We can see that the output is well
    synchronized, that is, the output is displayed in the correct order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hot Observables and the replay mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A hot Observable emits data, whether there is a Subscriber available or not.
    This can be an issue in scenarios where we expect, subscribers to receive data
    consistently. There is a mechanism within reactive programming to cache data so
    that later subscribers can be notified of the data available with an Observable.
    We can use the `.replay()` method to create such an Observable. Let''s write a
    program that will demonstrate the replay mechanism, which is useful when writing
    programs involving hot Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When writing reactive programs, you really need to understand the semantic difference
    between hot and cold Observables. We have only touched up on  some aspects of
    this topic. Please refer to the RxCpp documentation and ReactiveX documentation
    to learn more. about hot and cold Observables There are countless articles available
    on internet about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Observers and their variants (Subscribers)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Observer subscribes to an Observable and waits for events to be notified.
    Observers were already covered in the previous chapter. Hence, we will be focusing
    on Subscribers, which are a combination of Observers and subscriptions. A  Subscriber
    has the facility to unsubscribe from the Observer,where as  with a "vanilla" 
    Observer, you can only subscribe. The following program explain these concepts
    very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For writing nontrivial programs with concurrency and dynamism (asynchronous
    time varying events), the ability to subscribe and unsubscribe can be very handy.
    Take a deeper look at the topic by consulting the RxCpp documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A  Subject is an entity that is both an Observer and an Observable. It helps
    to relay notifications from one Observable (typically)  to a set of Observers.
    We can implement sophisticated techniques such as the caching and buffering of
    data using a Subject. We can also use a Subject to transform a hot Observable
    into a cold Observable. There are four variants of subjects implemented in `RxCpp
    library.` They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SynchronizeSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's write a simple program that will demonstrate the work of a Subject. The
    code listing will demonstrate how we can push data to a Subject and retrieve them
    using the Observer side of the Subject.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`The BehaviorSubject` is a variant of Subject that stores the last emitted
    (current) value as part of its implementation. Any new Subscriber will get the
    *current value* immediately. Otherwise, it behaves like a normal Subject. The `BehaviorSubject`
    is also called a property or a cell in some realm. It is useful in scenarios where
    we update a particular cell or memory area with a series of data, such as in a
    transaction context. Let''s write a program that demonstrates the workings of
    `BehaviorSubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`The ReplaySubject` is a variant of Subject that stores data that has already
    been emitted. We can specify parameters to indicate how many values have to be
    retained by a Subject. This is very handy when dealing with hot Observables. The
    function prototypes  of various replay overloads are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a program to understand the semantics of `ReplaySubject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have covered three variants of a Subject in this section. The primary use
    case is harnessing events and data from different sources by using the Observable
    interface and allowing a group of subscribers to consume the harnessed data. A`SimpleSubject`
    can act as both an Observable and an Observer to process a stream of values. The `BehaviorSubject`
    is useful for monitoring changes in a property or variable over a period of time
    and a`ReplaySubject` will help you to avoid loss of data due to latency in a subscription.
    Finally, a `SynchronizeSubject` is a subject that has synchronization logic built
    into its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RxCpp library has got a declarative threading mechanism, thanks to the robust
    scheduling subsystem packaged with it. From an Observable, data can be streamed
    through different paths along the change propagation graph. By giving hints to
    the Stream processing pipeline, we can schedule the execution of Operators and
    Observer methods in the same thread,different threads,  or a background thread.
    This helps to capture the intent of the programmer much better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declarative scheduling model in RxCpp is possible because of the immutability
    of the Streams in an Operator''s implementation. A Stream Operator takes an Observable
    as a parameter and returns a fresh Observable as the result. The input parameter
    is not mutated at all ( the behavior is implicitly expected from the Operator
    implementation). This helps in out-of-order execution. The scheduling subsystem
    of RxCpp contains the following constructs: ( specific to Rxcpp v2)'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TimeLine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Version 2 of RxCpp borrows its scheduling architecture from the `RxJava`
    system. It relies on Scheduler and Worker idioms used by `RxJava`. Here are some
    important facts about Scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: The Scheduler has a timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Scheduler can create lot of Workers in the timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Worker owns a queue of schedulable in the timeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `schedulable` owns a function (often called `Action`) and has a lifetime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Coordination` functions as a  factory for a coordinator and has a Scheduler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every Coordinator has a Worker and is a factory for the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinated `schedulable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinated Observables and subscribers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have been using Rx Schedulers in our programs, without bothering about how
    they work under the hood. Let''s write a toy program, which will help us understand
    how scheduling works under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In `RxCpp`, all Operators that take multiple streams as input, or deal with
    tasks that have a bearing on time, take a `Coordination` function as a parameter.
    Some of the `Coordination` functions using a particular Scheduler are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`identity_immediate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identity_current_thread()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`identity_same_worker(worker w)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialize_event_loop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialize_new_thread()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialize_same_worker(worker w)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observe_on_event_loop()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observe_on_new_thread()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous program, we manually scheduled an Action (which, in fact, is
    nothing but a lambda). Let''s move on to the declarative aspects of the Scheduler.
    We will write a program that will schedule tasks using a `Coordination` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We created a hot Observable using the replay mechanism to take care of the late
    subscription by some Observers. We also created a Worker to do the scheduling
    for subscription and to connect the Observers with the Observable. The previous
    program demonstrates how the Scheduler works in `RxCpp`.
  prefs: []
  type: TYPE_NORMAL
- en: ObserveOn versus SubscribeOn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ObserveOn` and `SubscribeOn` operators behave in a different manner, and
    this has been a source of confusion for reactive programming newbies. The `ObserveOn`
    operator changes the thread of the Operators and Observers below it. In the case
    of `SubscribeOn`, it affects Operators and methods that are above and below it
    as well. The following program demonstrates subtle changes in the runtime  behavior 
    of a program, caused by the way the `SubscribeOn` and `ObserveOn` operators behave.
    Let''s write a program that uses the `ObserveOn` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program clearly shows that map worked in the primary
    thread and the `subscribe` methods got scheduled in a secondary thread. This clearly
    shows that `ObserveOn` only worked on Operators and Subscribers below it. Let''s
    write a more or less identical program that uses the `SubscribeOn` operator instead
    of the `ObserveOn` operator. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding program shows that both map and subscription methods
    worked in the secondary thread. This clearly shows that `SubscribeOn` changes
    the threading behavior of items before and after it.
  prefs: []
  type: TYPE_NORMAL
- en: The RunLoop Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxCpp library does not have a notion of  built-in main thread Scheduler.
    The closest you can do is to leverage the `run_loop` class to simulate scheduling
    in the main thread. In the following program, the Observable executes in a background
    thread, and the subscription methods run in the main thread. We are using `subscribe_on`
    and `observe_on` to achieve this objective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can see that map was scheduled in the worker thread and subscription methods
    were executed in the main thread. This is enabled because of the judicious placement
    of the subscribe_on and observe_on  Operators, which we covered in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Operator is a function that applies on an Observable to produce a new Observable.
    In the process, the original Observable is not mutated  and can be considered 
    as  a pure function. We have already covered lot of Operators in our  sample programs
    that we have written. In [Chapter 10](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), *Creating
    Custom Operators in Rxcpp*, we will learn how to create custom Operators which
    work on Observables. The fact that an Operator does not mutate an (input) Observable
    is the  reason why declarative scheduling works in the Rx programming model. Rx
    Operators can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error-handling Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utility Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some more Operators available that do not fall into  any of these
    categories. We will provde a list of  key Operators from preceding categories
    , as a table for quick reference. As a developer one can pick Operators depending
    on the context, by consulting the tables given below
  prefs: []
  type: TYPE_NORMAL
- en: Creational Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These Operators will help a developer  to create various kind of Observables,from 
    the input data. We have already demonstrated the use of create, from, interval,
    and range Operators in our example code. Consult those examples and the RxCpp
    documentation to learn more about them. A table containing some of the Operators
    are given below :'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | Create an observable by calling the Observer method programmatically
    |'
  prefs: []
  type: TYPE_TB
- en: '| `defer` | Create a fresh Observable for each Observer/Subscriber |'
  prefs: []
  type: TYPE_TB
- en: '| `empty` | Create an Observable that does not emit anything (emits only on_completed)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `from` | Create an Observable based on the parameters (Polymorphic) |'
  prefs: []
  type: TYPE_TB
- en: '| `interval` | Create an Observable that emits a sequence of values in a time
    interval |'
  prefs: []
  type: TYPE_TB
- en: '| `just` | Create an Observable that emits a single value |'
  prefs: []
  type: TYPE_TB
- en: '| `range` | Create an Observable that emits a range of values |'
  prefs: []
  type: TYPE_TB
- en: '| `never` | Create an Observable that never emits anything |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat` | Create an Observable that repeats a stream of values |'
  prefs: []
  type: TYPE_TB
- en: '| `timer` | Create an Observable that emits a value after a delay factor, which
    can be specified as a parameter |'
  prefs: []
  type: TYPE_TB
- en: '| `throw` | Create an Observable that emits an error |'
  prefs: []
  type: TYPE_TB
- en: Transformation Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These Operators help developers to create a new Observable without modifying
    the source Observable. They act on individual items in the source Observable by
    applying a lambda or a functor on them. A table containing some of the most useful
    transformation Operators are given below.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `buffer` | Observable that collects values in the past and emits them when
    signaled |'
  prefs: []
  type: TYPE_TB
- en: '| `flat_map` | Observable that emits results of applying a function to a pair
    of values emitted by the source Observable and the collection Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `group_by` | Observable that helps to group values from an Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | Observable that emits items from the source Observable, transformed
    by the specified function |'
  prefs: []
  type: TYPE_TB
- en: '| `scan` | Observable that emits results of each call to the accumulator function
    |'
  prefs: []
  type: TYPE_TB
- en: '| `window` | Observable that emits connected, non-overlapping windows of items.
    Each window will contain a particular number of item, which is given as a parameter.
    The parameter name is count.  |'
  prefs: []
  type: TYPE_TB
- en: Filtering Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to filter Streams is a common activity in Stream processing. It
    is not unusual that the Rx programming model defines a lot of Operators in the
    filtering category. Filtering operators are mostly predicate functions or lambdas.
    The following table contains a list of filtering  Operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `debounce` | Observable that emits an item if a particular time span has
    passed without emitting another item from the source Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `distinct` | Observable that emits those items from the source Observable
    that are distinct |'
  prefs: []
  type: TYPE_TB
- en: '| `element_at` | Observable that emits an item located at a specified index
    location |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | Observable that emits only those items emitted by the source Observable
    that the filter evaluates as true |'
  prefs: []
  type: TYPE_TB
- en: '| `first` | Observable that emits only the very first item emitted by the source
    Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore_eleements` | Observable that emits a termination notification from
    the source Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `last` | Observable that emits only the very last item emitted by the source
    Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `sample` | Observable that emits the most recent items emitted by the source
    Observable within a periodic time interval. |'
  prefs: []
  type: TYPE_TB
- en: '| `skip` | Observable that is identical to the source Observable, except that
    it does not emit the first t items that the source Observable emits |'
  prefs: []
  type: TYPE_TB
- en: '| `skip_last` | Observable that is identical to the source Observable, except
    that it does not emit the last t items that the source Observable emits |'
  prefs: []
  type: TYPE_TB
- en: '| `take` | Observable that emits only the first t items emitted by the source
    Observable, or all of the items from the source Observable if that Observable
    emits fewer than t items |'
  prefs: []
  type: TYPE_TB
- en: '| `take_last` | Observable that emits only the last t items emitted by the
    source Observable |'
  prefs: []
  type: TYPE_TB
- en: Combining Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the primary goals of the Rx programming model is to decouple the event
    source from event sinks. Obviously, there is a need for Operators that can combine
    Streams from various sources. The RxCpp library implements a set of such Operators.
    The following table outlines a set of commonly used combining Operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `combine_latest` | When an item is emitted by either of two Observables,
    combine the latest item emitted by each Observable via a specified function and
    emit items based on the results of this function |'
  prefs: []
  type: TYPE_TB
- en: '| `merge` | This combines multiple Observables into one by merging their emissions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `start_with` | This emits a specified sequence of items before beginning
    to emit the items from the source Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `switch_on_next` | This converts an Observable that emits Observables into
    a single Observable that emits the items emitted by the most recently emitted
    of those Observables |'
  prefs: []
  type: TYPE_TB
- en: '| `zip` | This combines the emissions of multiple Observables together via
    a specified function and emits single items for each combination based on the
    results of this functions |'
  prefs: []
  type: TYPE_TB
- en: Error-handling Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are operators that help  us to do error recovery when exceptions  occur 
    while pipeline execution is going on.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Catch` | Not supported by `RxCpp` |'
  prefs: []
  type: TYPE_TB
- en: '| `retry` | An observable that mirrors the source Observable, resubscribing
    to it if it calls `on_error` up to a specified number of retries |'
  prefs: []
  type: TYPE_TB
- en: Observable utility Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is a toolbox of useful  utility Operators for working with Observables:.
    The observe_on and subscribe_on Operators  help us to do declarative scheduling.
    We have already covered them in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `finally` | Observable that emits the same items as the source Observable,
    then invokes the given action |'
  prefs: []
  type: TYPE_TB
- en: '| `observe_on` | Specify the Scheduler on which an Observer will observe this
    Observable |'
  prefs: []
  type: TYPE_TB
- en: '| `subscribe` | Operate upon the emissions and notifications from an Observable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `subscribe_on` | Specify the Scheduler an Observable should use when it is
    subscribed to |'
  prefs: []
  type: TYPE_TB
- en: '| `scope` | Create a disposable resource that has the same lifespan as the
    Observable |'
  prefs: []
  type: TYPE_TB
- en: Conditional and Boolean Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Conditional and Boolean Operators  are Operators that evaluate one or more
    Observables or items emitted by Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | Observable that emits true if every item emitted by the source Observable
    satisfies a specified condition; otherwise, it emits false |'
  prefs: []
  type: TYPE_TB
- en: '| `amb` | Observable that emits  same sequence as whichever of  source Observables
    first emitted an item or sent a termination notification |'
  prefs: []
  type: TYPE_TB
- en: '| `contains` | An Observable that emits true if the source Observable emitted
    a specified item; otherwise it emits false |'
  prefs: []
  type: TYPE_TB
- en: '| `default_if_empty` | An Observable that emits true if the source Observable
    emitted a specified item; otherwise it emits false |'
  prefs: []
  type: TYPE_TB
- en: '| `sequence_equal` | Observable that emits true only if both sequences terminate
    normally after emitting the same sequence of items in the same order; otherwise,
    it will emit false |'
  prefs: []
  type: TYPE_TB
- en: '| `skip_until` | Discard items emitted by an Observable until a second Observable
    emits an item |'
  prefs: []
  type: TYPE_TB
- en: '| `skip_while` | Discard items emitted by an Observable until a specified condition
    becomes false |'
  prefs: []
  type: TYPE_TB
- en: '| `take_until` | Discard items emitted by an Observable after a second Observable
    emits an item or terminates |'
  prefs: []
  type: TYPE_TB
- en: '| `take_while` | Discard items emitted by an Observable after a specified condition
    becomes false |'
  prefs: []
  type: TYPE_TB
- en: Mathematical and Aggregate operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These Mathematical and Aggregate  Operators are a category of Operators which 
    operate on an  entire sequence of items emitted by an Observable: They basically
    reduce an Observable<T> to some value of the type T. They do not return  an  Observable.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `average` | Calculate the average of numbers emitted by an Observable and
    emit this average |'
  prefs: []
  type: TYPE_TB
- en: '| `concat` | Emit the emissions from two or more Observables without interleaving
    them |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Count the number of items emitted by the source Observable and
    emit only this value |'
  prefs: []
  type: TYPE_TB
- en: '| `max` | Determine and emit the maximum-valued item emitted by an Observable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `min` | Determine and emit the minimum-valued item emitted by an Observable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `reduce` | Apply a function to each item emitted by an Observable, sequentially,
    and emit the final value |'
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Calculate the sum of numbers emitted by an Observable and emit this
    sum |'
  prefs: []
  type: TYPE_TB
- en: Connectable Observable Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Connectable Observable are special Observables that have more precisely
    controlled subscription dynamics. The following table lists some key Operators
    with advanced subscription semantics
  prefs: []
  type: TYPE_NORMAL
- en: '| **Observables** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `connect` | Instruct a Connectable Observable to begin emitting items to
    its subscribers |'
  prefs: []
  type: TYPE_TB
- en: '| `publish` | Convert an ordinary Observable into a Connectable Observable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ref_count` | Make a Connectable Observable behave like an ordinary Observable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `replay` | Ensure that all Observers see the same sequence of emitted items,
    even if they subscribe after the Observable has begun emitting items. This Operator
    is used with hot Observables |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an understanding of how pieces of the Rx programming
    model fits together. We started with Observables and quickly moved on to the topic
    of hot and cold Observables. Then, we covered the subscription mechanism and its
    use. We then moved on to the important topic of Subjects and understood how a
    number of variants of Scheduler implementation works. Finally, we classified various
    Operators available with the RxCpp system. In the next chapter, we will learn
    how we can use the knowledge gained so far, to write GUI programs in a reactive
    manner, using the Qt framework.
  prefs: []
  type: TYPE_NORMAL
