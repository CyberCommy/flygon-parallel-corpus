- en: Effective ML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've learned the basics of Reason. We've seen how having a sound type
    system can make refactoring a safer, less stressful endeavor. When changing an
    implementation detail, the type system helpfully alerts us to the other areas
    of the codebase that need to be updated. In this chapter, we'll learn how to hide
    implementation details to make refactoring even easier. By hiding implementation
    details, we guarantee that changing them won't affect other areas of your codebase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll also learn how the type system can help us enforce business rules in our
    application. Hiding implementation details also gives us a nice way to enforce
    business rules by guaranteeing that modules are not being misused by the user. We'll
    illustrate this point throughout much of this chapter using simple code examples
    that are included in this book's GitHub repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, start from `Chapter05/app-start`. These examples are isolated
    from the app we've been building.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go to the GitHub repository for this book using the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember, all modules are global and all of a module''s types and bindings
    are exposed by default. As we''ll soon see, module signatures can be used to hide
    a module''s types and/or bindings from other modules. In this chapter, we''ll
    also learn about advanced type system features, including the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phantom types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic variants
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module signatures
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module signature constrains a module in a similar way to how an interface
    can constrain a class in object-oriented programming. A module signature can require
    that a module implements certain types and bindings and can also be used to hide
    implementation details. Say that we had a module called `Foo` defined in `Foo.re`.
    Its signature can be defined in `Foo.rei`. Any type or binding listed in a module''s
    signature is exposed to other modules. Any type or binding listed in a module
    is hidden if a module signature exists and that type or binding isn''t present
    in the module signature. Given a binding `let foo = "foo";` in `Foo.re`, that
    binding can be both required and exposed by its module signature by including `let
    foo: string;` in `Foo.rei`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `Foo.rei` requires `Foo.re` to have a `let` binding named `foo` of the
    `string `type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'If a module''s `.rei` file exists and is empty, then everything within the
    module is hidden, as shown in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A module''s signature requires the module to include any types and/or bindings
    listed in the signature, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in the following compilation error because the module signature
    requires a `bar` binding of the `string` type that isn''t defined in the module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Module types
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module signature can also be defined using the `module type` keyword instead
    of using a separate `.rei` file. The module type must start with a capital letter.
    Once defined, a module can be constrained by a module type using the `module <Name>
    : <Type>` syntax, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same module type can be used for multiple modules, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can think of module signatures as interfaces in the object-oriented sense.
    The interface defines the properties and methods that a module must define. In
    Reason, however, module signatures also hide bindings and types. But perhaps one
    of the most useful features of module signatures is the ability to expose abstract
    types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstract types are type declarations that don''t have a definition. Let''s
    explore why this would be useful. In addition to bindings, module signatures can
    include types. In the following code, you''ll notice that the module signature
    of `Foo` includes a `person` type, and now `Foo` must include this `type` declaration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `person` type is exposed in the same way as if there were no module signature
    defined. As you''d expect, if a signature is defined and the type is not listed,
    the type isn''t exposed to other modules. There is also the option to leave the
    type abstract. We only keep what''s left of the equals sign. Let''s look at the
    following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the `person` type is exposed to other modules, but no other modules can
    directly create or manipulate a value of the `person `type. The `person` type
    is required to be defined in `Foo`, but it can have any definition. This means
    that the `person` type can change over time, and no modules outside of `Foo` would
    ever know the difference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore abstract types further in the following section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Using module signatures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we''re building an invoice-management system and we have
    an `Invoice` module that defines an `invoice` type along with a function that
    other modules can use to create values of that type. This arrangement is shown
    in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s also suppose that we have another module that is responsible for sending
    emails to customers, as shown in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the `Invoice.t` type is exposed, the invoice can be manipulated by `Email`,
    as shown in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Despite the `Invoice.t` type being immutable, there is nothing preventing `Email`
    from shadowing the invoice binding with some altered fields. However, if we made
    the `Invoice.t` type abstract, this wouldn't be possible because `Email` wouldn't
    be able to manipulate the abstract type. None of the functions that the `Email`
    module has access to would work with an `Invoice.t` type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, compiling gives us the following error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we decide to allow other modules to add discounts to invoices, we would
    need to create a function and include it in the module signature of `Invoice`.
    Let''s suppose we want to only allow one discount per invoice and also restrict
    the discount amount to ten, fifteen, or twenty percent. We could implement this
    in the following way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, as long as the `Invoice` module''s public API (or module signature) doesn''t
    change, we''re free to refactor the `Invoice` module however we''d like without
    needing to worry about breaking code in other modules. To prove this point, let''s
    refactor `Invoice.t` to be a tuple instead of a record, as shown in the following
    code. As long as we don''t change the module signature, the `Email` module won''t
    need to change at all:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Also, thanks to the `Invoice.t` abstract type, we are guaranteed that an invoice
    can only be discounted once, and only by specified percentages. We could take
    this example further by requiring all changes to an invoice to be logged. Traditionally,
    this sort of requirement would be solved by adding a side effect after a database
    transaction because, in JavaScript, we wouldn't otherwise be sure that we would
    be logging all changes to an invoice. With module signatures, we have the option
    to solve these kinds of requirements in the application layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at our previous implementation, it would be nice if we didn't have to
    check whether an invoice has been discounted at runtime. Is there a way we could
    check whether an invoice has been discounted at compile time instead? With phantom
    types, we can.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Phantom types are types that have a type variable, but this type variable isn''t
    used in its definition. To better understand, let''s look again at the `option`
    type, as shown in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `option` type has a type variable, `'a`, and the type variable is being
    used in its definition. As we've already learned, `option` is a polymorphic type
    because it has a type variable. On the other hand, a phantom type doesn't use
    the type variable in its definition. Let's see how this is useful with our invoice
    management example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `Invoice` module''s signature to use a phantom type, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The abstract `type t` is now `type t(''a)`. We also have two more abstract
    types, as shown in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型`t`现在是`type t('a)`。我们还有两个更多的抽象类型，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, note that the `make` function now returns `t(undiscounted)` (instead of
    just `t`) and the `discount` function now accepts `t(undiscounted)` and returns `t(discounted)`.
    Remember that the abstract `t('a)` accepts a `type` variable, and that the `type`
    variable just so happens to be either the `discounted` type or the `undiscounted` type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`make`函数现在返回`t(undiscounted)`（而不仅仅是`t`），`discount`函数现在接受`t(undiscounted)`并返回`t(discounted)`。记住，抽象`t('a)`接受一个`type`变量，而`type`变量恰好是`discounted`类型或`undiscounted`类型。
- en: 'In the implementation, we can now get rid of the runtime check we had previously,
    as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，我们现在可以摆脱之前的运行时检查，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, this check is done at compile time since the `discount` function only
    accepts `undiscounted` invoices, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个检查是在编译时进行的，因为`discount`函数只接受`undiscounted`发票，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is just one more way that a type system can help us focus more on logic
    and less on error handling. Previously, trying to discount an invoice twice would
    just return the original invoice unchanged. Let''s now try to discount an invoice
    twice in `Email.re` using the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是类型系统可以帮助我们更多地关注逻辑而不是错误处理的另一种方式。以前，尝试两次打折发票只会返回原始发票。现在，让我们尝试在`Email.re`中两次打折发票，使用以下代码：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, trying to discount an invoice twice will result in a lovely compile-time
    error, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试两次打折发票将导致一个可爱的编译时错误，如下所示：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is absolutely beautiful. Suppose, however, that you''d like to be able
    to email any invoice—discounted or not. Does our use of phantom types cause a
    problem? How would we write a function that takes any invoice type? We''ll, remember
    that our invoice type is `Invoice.t(''a)` and if we want to accept any invoice,
    we keep the type parameter, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对美丽。然而，假设你想能够给任何发票发送电子邮件，无论是否打折。我们使用幻影类型会导致问题吗？我们如何编写一个接受任何发票类型的函数？我们的发票类型是`Invoice.t('a)`，如果我们想接受任何发票，我们保留类型参数，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So we can have our cake and eat it too.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以两全其美。
- en: Polymorphic variants
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态变体
- en: 'We''ve already briefly looked at polymorphic variants in the previous chapter.
    To recap, we learned about them when we used the `[@bs.unwrap]` decorator to bind
    to some existing JavaScript. The idea was that `[@bs.unwrap]` can be used to bind
    to an existing JavaScript function where its arguments can be of different types.
    For example, let''s say we want to bind to the following function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章简要地看过多态变体。简而言之，我们在使用`[@bs.unwrap]`装饰器绑定到一些现有的JavaScript时学到了它们。这个想法是`[@bs.unwrap]`可以用于绑定到现有的JavaScript函数，其中它的参数可以是不同的类型。例如，假设我们想绑定到以下函数：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s say this function should only accept arguments of the `string` type or
    `int` type and nothing else. We could bind to this example function as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个函数只接受`string`类型或`int`类型的参数，不接受其他类型。我们可以这样绑定这个示例函数：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, our binding would then allow invalid argument types (such as `bool`).
    It would be better if our compiler could help us out by preventing invalid argument
    types. One way to do this is to use `[@bs.unwrap]` with a polymorphic variant.
    Our binding would then appear as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的绑定将允许无效的参数类型（如`bool`）。如果我们的编译器能够通过阻止无效的参数类型来帮助我们，那将更好。其中一种方法是使用多态变体与`[@bs.unwrap]`。我们的绑定将如下所示：
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''d use the binding like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会这样使用绑定：
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, if we tried to pass an invalid argument type, the compiler would let us
    know, as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试传递无效的参数类型，编译器会让我们知道，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The trade-off here is that we'll need to pass in arguments by wrapping them
    in the polymorphic variant constructors rather than directly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的折衷是我们需要通过将参数包装在多态变体构造函数中而不是直接传递参数。
- en: 'Right off the bat, you''ll notice the following two differences between normal
    variants and polymorphic variants:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，你会注意到普通变体和多态变体之间的以下两个不同之处：
- en: We did not need to explicitly declare a type for the polymorphic variant
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要显式声明多态变体的类型
- en: Polymorphic variants begin with a backtick character ([PRE29]
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态变体以反引号字符（[PRE29]
- en: type validArgs =
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: type validArgs =
- en: '| Int(int)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| Int(int)'
- en: '| Str(string);'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '| Str(string);'
- en: '[@bs.val] external dynamic : validArgs => string = "";'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[@bs.val] external dynamic : validArgs => string = "";'
- en: dynamic(Int(1));
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: dynamic(Int(1));
- en: '```'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The problem with the preceding implementation is that `Int(1)` does not compile
    to a JavaScript number. Normal variants are compiled to an `array` and our `dynamic`
    function returns `undefined` instead of `"Number: 42"`. The function returns `undefined`
    because no cases on the switch statement were matched.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '前面实现的问题是`Int(1)`不会编译为JavaScript数字。普通变体编译为`array`，我们的`dynamic`函数返回`undefined`而不是`"Number:
    42"`。函数返回`undefined`是因为在switch语句上没有匹配到任何情况。'
- en: With polymorphic variants, BuckleScript compiles `dynamic(`Int(42))` to `dynamic(42)` and
    the function works as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态变体，BuckleScript将`dynamic(`Int(42))`编译为`dynamic(42)`，函数按预期工作。
- en: Advanced type system features
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级类型系统特性
- en: Reason's type system is quite full-featured and has been refined over the last
    couple of decades. What we've seen so far is only an introduction to Reason's
    type system. In my opinion, you should become familiar with the basics before
    continuing to more advanced type system features. It's hard to appreciate things
    such as type safety without having experienced bugs that a sound type system would
    have prevented. It's hard to appreciate advanced type system features without
    getting slightly frustrated with what you've learned so far in this book. It's
    beyond the scope of this book to discuss advanced type system features in too
    much detail, but I want to make sure that those of you who are evaluating Reason
    as an option know that there's much more to its type system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Reason的类型系统非常全面，并在过去的几十年中得到了完善。到目前为止，我们所看到的只是对Reason类型系统的介绍。在我看来，你应该在继续学习更高级的类型系统功能之前熟悉基础知识。没有经历过合理的类型系统本应阻止的错误，很难欣赏诸如类型安全之类的东西。没有对到目前为止在本书中学到的内容感到略微沮丧，很难欣赏高级类型系统功能。本书的范围不包括对高级类型系统功能进行过多详细讨论，但我想确保那些正在评估Reason作为一个选项的人知道它的类型系统还有更多内容。
- en: In addition to phantom types and polymorphic variants, Reason has **generalized
    algebraic datatypes** (**GADTs**). Modules can be dynamically created using functors
    (that is, module functions that operate somewhere in between compile time and
    runtime). Reason also has classes and objects—the O in OCaml stands for objective.
    OCaml's predecessor was a language called Caml that first appeared in the mid
    1980s. What we've learned so far in this book is specifically useful in the context
    of typical React applications. Personally, I like that Reason is a language that
    I can grow into while being productive.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了幻影类型和多态变体之外，Reason还具有**广义代数数据类型**（**GADTs**）。模块可以使用函数器（即，在编译时和运行时之间操作的模块函数）动态创建。Reason还具有类和对象——OCaml中的O代表objective。OCaml的前身是一种称为Caml的语言，最早出现在20世纪80年代中期。到目前为止，在本书中学到的东西在典型的React应用程序的上下文中特别有用。就我个人而言，我喜欢Reason是一种我可以在其中不断成长并保持高效的语言。
- en: If you find yourself frustrated with the type system, then reach out to the
    experts on the Discord channel and someone will likely help you work through your
    problem. I'm constantly amazed at how helpful the community is. And don't forget,
    if you just want to move on, you can always drop into raw JavaScript if you need
    to and come back to the problem when you're ready.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己对类型系统感到沮丧，那么可以在Discord频道上寻求专家的帮助，有人很可能会帮助你解决问题。我对社区的乐于助人感到不断惊讶。而且不要忘记，如果你只是想继续前进，你总是可以转到原始的JavaScript，如果需要的话，等你准备好了再回来解决问题。
- en: 'You can find the Reason Discord channel here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到Reason的Discord频道：
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
- en: It's also perfectly valid to not use the fancier features of Reason's type system.
    What we've learned so far provides a lot of value in terms of adding type safety
    to our React applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用Reason类型系统的更高级功能也是完全有效的。到目前为止，我们所学到的内容在为我们的React应用程序添加类型安全方面提供了很大的价值。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By now, we've seen how Reason can help us build safer, more maintainable codebases
    with the help of its type system. Variants allow us make invalid states unrepresentable.
    The type system helps make refactoring a less scary, less painful process. Module
    signatures can help us to enforce business rules in our application. Module signatures
    also serve as basic documentation that lists what a module exposes and gives you
    a basic idea of how the module is meant to be used based on exposed function names
    and their argument types, as well as exposed types.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到Reason如何帮助我们使用其类型系统构建更安全、更易维护的代码库。变体允许我们使无效状态不可表示。类型系统有助于使重构过程变得不那么可怕、不那么痛苦。模块签名可以帮助我们强制执行应用程序中的业务规则。模块签名还可以作为基本文档，列出模块公开的内容，并根据公开的函数名称和其参数类型以及公开的类型，给出模块的基本使用方式的概念。
- en: In [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml), *CSS-in-JS (in Reason)*,
    we'll look at how we can use Reason's type system to enforce valid CSS using a
    CSS-in-Reason library that wraps Emotion ([https://emotion.sh](https://emotion.sh)),
    called `bs-css`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml)中，*CSS-in-JS（在Reason中）*，我们将看看如何使用Reason的类型系统来强制执行有效的CSS，使用一个包装Emotion（[https://emotion.sh](https://emotion.sh)）的CSS-in-Reason库，名为`bs-css`。
