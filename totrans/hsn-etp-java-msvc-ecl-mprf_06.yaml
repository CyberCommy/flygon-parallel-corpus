- en: MicroProfile Health Check and JWT Propagation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the MicroProfile Health Check and **JSON
    Web Token** (**JWT**) Propagation projects. The Health Check project is concerned
    with exposing the application-defined health to the outside world, and JWT Propagation
    is concerned with defining an interoperable security token and use of that token
    in an application. In this chapter, you will learn the concerns that these specifications
    address, their constructs, and how to use them in your application. The code snippets
    throughout this chapter are for reference only. If you would like a working code
    version of this specification, please refer to [Chapter 8](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml),
    *A Working Eclipse MicroProfile Code Sample*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What a health check is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How MicroProfile Health Check exposes the health check endpoint and the format
    of a query to that endpoint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a MicroProfile Health Check for your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The required format for the tokens in MicroProfile JWT Propagation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can leverage MicroProfile JWT Propagation for security decisions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build and run the samples in this chapter, you need Maven 3.5+ and a Java
    8 JDK. The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck) and
    [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)
    for the MicroProfile Health Check and MicroProfile Propagation JWT sections, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Understanding health checks and how MicroProfile handles them
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cloud-native architectures, health checks are used to determine whether a
    computing node is alive and ready to perform work. The concept of readiness describes
    the state when containers start up or roll over (that is, redeployment). During
    this time, the cloud platform needs to ensure that no network traffic is routed
    to that instance before it is ready to perform work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Liveness, on the other hand, describes the state of a running container; that
    is, can it still respond to requests? If either the liveness or readiness states
    are seen as invalid, the computing node will be discarded (terminated or shut
    down) and eventually replaced by another, healthy, instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Health checks are an essential contract with the orchestration framework and
    scheduler of the cloud platform. The check procedures are provided by the application
    developer and the platform uses these to continuously ensure the availability
    of your application or service.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Health Check 1.0 (MP-HC) supports a single health check endpoint
    that can be utilized for either a liveness or readiness check. MicroProfile Health
    Check 2.0 plans to add support for multiple endpoints to allow an application
    to define both liveness and readiness probes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The MP-HC specification details two elements: a protocol along with a response
    wire format part and a Java API for defining the response content.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the MP-HC feature is modeled as an application that consists
    of zero or more health check procedures that are logically linked together with
    `AND` to derive the overall health check status. A procedure represents an application-defined
    check of a required condition that has a name, state, and, optionally, data about
    the check.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The Health Check protocol and wire format
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MP-HC specification defines the requirement to support the HTTP GET requests
    against a logical `/health` REST endpoint that may return any one of the following
    codes to represent the endpoint''s status:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`200`: It is up and healthy.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: It is unhealthy due to an unknown error.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`503`: It is down and not ready to respond to requests.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that many cloud environments simply look at the request return code as
    either success or failure, so the differentiation between a `500` and `503` code
    may not be distinguishable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The payload of a `/health` request must be a JSON object that matches the schema
    given in the following (for more information on the JSON schema syntax see [http://jsonschema.net/#/](http://jsonschema.net/#/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Following is ...
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The Health Check Java API
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the plumbing is performed by the application framework that implements
    the MP-HC specification. Your part is to decide how liveness or readiness are
    determined through the health check procedures that your microservice defines
    using the MP-HC API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you need to implement a health check procedure by implementing one
    or more instances of the `HealthCheck` interface using beans that are marked with
    a `Health` annotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HealthCheck` interface is provided in the following code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code for the `Health` annotation is provided in the following code block:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An example `HealthCheck` implementation that represents the status of a hypothetical
    disk space check is shown in the following example. Note that the check includes
    the current free space as part of the response data. The `HealthCheckResponse` class
    supports a builder interface to populate the response object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a hypothetical disk space `HealthCheck` procedure implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we created a health response that is named `diskspace` with
    a status of `up` and custom data named `free` with a string value of `780mb`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Another health check example representing some service endpoint is shown in
    the following.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'A hypothetical service `HealthCheck` procedure implementation is shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we created a health response named `service-check` with a
    status of `up` that includes the following additional data:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: A `port` item with an integer value of `12345`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `isSecure` item with a Boolean value of `true`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `hostname` item with a string value of `service.jboss.com`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CDI-managed health checks are discovered and registered automatically by
    the application runtime. The runtime automatically exposes an HTTP endpoint, `/health`,
    used by the cloud platform to poke into your application to determine its state.
    You can test this by building the `Chapter04-healthcheck` application and running
    it. You will see the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the server has started, test the health checks by querying the health
    endpoint:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This shows the overall health to be `UP`. The overall status is the logical
    `OR` of all of the health check procedures found in the application. In this case,
    it is `AND` of the two health check procedures we have seen: `diskspace` and `service-check`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the cloud platform
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most cloud platforms support both TCP- and HTTP-based checks. To integrate health
    checks with your selected cloud platform, you need to configure your cloud deployment
    to point to the HTTP entry point, `/health`, on the node that hosts your application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The cloud platform will invoke a `GET` query on the HTTP entry point; all checks
    that are registered will be performed and the sum of individual checks determines
    the overall outcome.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the response payload is ignored by the cloud platform and it only looks
    at the HTTP status code to determine the liveness or readiness of your application.
    A successful outcome, `UP`, will be mapped to `200` and `DOWN` to `503`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Human operators
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary use case for the JSON response payload is to provide a way for
    operators to investigate the application state. To support this, health checks
    allow for additional data to be attached to a health check response as we have
    seen in the `CheckDiskspace` and `ServiceCheck` examples. Consider the following
    fragment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the additional information about `free-heap` is provided and will become
    part of the response payload, as shown in this response fragment. The JSON response
    fragment showing `memory-check` procedure content is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we see the `memory-check` procedure with its `UP` state and additional
    `free-heap` data item of the string type with the value of `64mb`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse resources/GitHub coordinates for MP-Health**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The MP-Health project source code can be found at [https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Health Check response messages
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile Health Check 3.0 introduced changes to the message format of health
    check JSON responses. Specifically, the field's outcome and state have been replaced
    by the field status.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `@Health` qualifier was deprecated in the Health Check 3.0
    release, while the `@Liveness` and `@Readiness` qualifiers were introduced. For
    the two qualifiers, the `/health/live` and `/health/ready` endpoints were also
    introduced to call all the liveliness and readiness procedures, respectively.
    Lastly, for backward compatibility, `/health` endpoint now calls all the procedures
    that have `@Health`, `@Liveness`, or `@Readiness` qualifiers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It's time to discuss JWT Propagation now.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON Web Token Propagation in MicroProfile
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **JSON Web Token** (**JWT**) is a common format for carrying security information
    that is used by many different web-based security protocols. However, there is
    a lack of standardization around exactly what the contents of the JWT are and
    what security algorithms are used with signed JWTs. The **MicroProfile JWT** (**MP-JWT**) Propagation
    project specification looked at the **OpenID Connect** (**OIDC**)-based ([http://openid.net/connect/](http://openid.net/connect/)) JWT
    ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)) specifications
    and built upon those to define a set of requirements to promote interoperability
    of JWTs for use in MicroProfile-based microservices, along with APIs to access
    information from the JWTs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: For a description of how OIDC and JWT work, including how an application/microservice
    intercepts bearer tokens, please refer to the *Basic Client Implementer's Guide*
    at [http://openid.net/connect/](http://openid.net/connect/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The claims and signature algorithms from OIDC and JWT specifications that were
    required for interoperability
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JWTs for **Role-Based Access Control** (**RBAC**) of microservice endpoints
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the MP-JWT APIs to access a JWT and its claim values
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations for interoperability
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maximum utility of MP-JWT as a token format depends on the agreement between
    both identity providers and service providers. This means identity providers—responsible
    for issuing tokens—should be able to issue tokens using the MP-JWT format in a
    way that service providers can understand to inspect the token and gather information
    about a subject. The primary goals for MP-JWT are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: It should be usable as an authentication token.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be usable as an authorization token that contains application-level
    roles indirectly granted via a group's claim.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can support additional standard claims described in IANA JWT Assignments
    ([https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)),
    as well as non-standard ...
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required MP-JWT claims
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The required set of MP-JWT claims for which an implementation needs to provide
    support contains the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`typ`: This header parameter identifies the token type and is required to be
    `JWT`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alg`: This header algorithm was used to sign the JWT and must be specified
    as `RS256`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kid`: This header parameter provides a hint about which public key was used
    to sign the JWT.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iss`: This is the issuer and signer of the token.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: This identifies the subject of the JWT.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: This identifies the expiration time on, or after, which the JWT MUST
    NOT be accepted for processing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: This identifies the time at which the JWT was issued and can be used
    to determine the age of the JWT.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti`: This provides a unique identifier for the JWT.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upn`: This MP-JWT custom claim is the preferred way to specify a user principal
    name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups`: This MP-JWT custom claim is the list of group or role names assigned
    to the JWT principal.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumericDate` used by `exp`, `iat`, and other date-related claims is a JSON
    numeric value representing the number of seconds from `1970-01-01T00:00:00Z` UTC
    until the specified UTC date/time, ignoring leap seconds. Additionally, more details
    about the standard claims may be found in the MP-JWT specification ([https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1))
    and the JSON Web Token RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'An example basic MP-JWT in JSON would be a sample header and payload of an
    MP-JWT compatible JWT, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example shows the header with `typ=JWT`, `alg=RS256`, and `kid=abc-1234567890`.
    The body includes the `iss`, `jti`, `exp`, `iat`, `sub`, `upn`, and `groups` claims.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The high-level description of the MP-JWT API
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MP-JWT project introduces the following API interfaces and classes under
    the `org.eclipse.microprofile.jwt` package namespace:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`JsonWebToken`: This is a `java.security.Principal` interface extension that
    makes the set of required claims available via get-style accessors, along with
    general access to any claim in the JWT.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Claims`: This is an enumeration utility class that encapsulates all of the
    standard JWT-related claims along with a description and the required Java type
    for the claim as returned from the `JsonWebToken#getClaim(String)` method.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Claim`: This is a qualifier annotation used to signify an injection point
    for `ClaimValue`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClaimValue<T>`: This is a `java.security.Principal` interface extension ...'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample code that uses MP-JWT
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic usage of the MP-JWT API is to inject `JsonWebToken`, its `ClaimValue`,
    or both. In this section, we present snippets of typical usage. This book's code
    for this section is available at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Injection of JsonWebToken information
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code sample illustrates access of the incoming MP-JWT token as `JsonWebToken`,
    the raw JWT token string, the `upn` claim, and integration with JAX-RS `SecurityContext`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Injection of JWT claim values
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code snippet in this section illustrates the injection of individual JWT
    claim values. There are several different formats we can use for the injected
    value. Standard claims support the object subtypes defined in the `Claim#getType`
    field and `JsonValue` subtypes. Custom claim types only support the injection
    of the `JsonValue` subtypes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates injection of the standard `groups` and
    `iss` claims, along with `customString`, `customInteger`, `customDouble`, and
    `customObject` custom claims:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The eight commented injections are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Injection of the standard `groups` claim as its default `Set<String>` type
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `iss` claim as its default String type
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `groups` claim as its default `JsonArray` type
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `iss` claim as its default `JsonString` type
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customString` claim as a `JsonString` type
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customInteger` claim as a `JsonNumber` type
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customDouble` claim as a `JsonNumber` type
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customObject` claim as a `JsonString` type
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring authentication of JWTs
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To accept a JWT as representing an identity that should be authenticated and
    therefore trusted, we need to configure the MP-JWT feature with the information
    to verify who signed and who issued the JWT. This is done via MP-Config properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.jwt.verify.publickey`: This provides the embedded key material of the public
    key for the MP-JWT signer, typically in PKCS8 PEM format.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mp.jwt.verify.issuer`: This specifies the expected value of the `iss` claim
    found in the JWT.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example `microprofile-configuration.properties` file for this book is as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Running the samples
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples we looked at can be deployed to Thorntail and accessed via command-line
    queries against the endpoints to validate the expected behaviors. Since authentication
    against the endpoints marked with security constraints requires a valid JWT, we
    need a way to generate a JWT that will be accepted by the Thorntail server.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code provides an `io.packt.jwt.test.GenerateToken` utility
    that will create a JWT signed by a key that has been configured with the Thorntail
    server. The claims included in the JWT are defined by the `src/test/resources/JwtClaims.json`
    document of this chapter''s project. You run the utility using the `mvn exec:java`
    command, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The utility outputs the claims that were added and then prints out the base64-encoded
    JWT. You would use this JWT as the value in the `Authorization: Bearer …` header
    of the `curl` command line you used to access the server endpoints.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up the Thorntail server with the example endpoints, `cd` into the `Chapter04-jwtpropagation` project
    directory and then run `mvn` to build the executable JAR:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The resulting executable JAR is located at `target/jwt-propagation-thorntail.jar`.
    You start up the Thorntail server with this chapter''s sample deployment using
    `java -jar …`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, we can query the server endpoints. There is one endpoint that
    we defined that does not require any authentication. This is the `jwt/openHello`
    endpoint of the `io.pckt.jwt.rest.SecureEndpoint` class. Run the following command
    to validate that your Thorntail server is running as expected:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, try the secured endpoint. It should fail with a 401 Not authorized error
    because we are not providing any authorization information:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we need to generate a fresh JWT and pass that along with the curl command
    in the `Authorization` header, so let''s try that. We will save the JWT generated
    by the mvn command in a JWT environment variable to simplify the curl command
    line:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the previous code snippet, for Windows users, please install a bash-compatible
    shell for Windows; otherwise, you will get an error due to the `echo` command.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This time, the query succeeds and we see that the username, `upn` claim value,
    scheme, and `isUserInRole("User")` check are as expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try accessing the `/jwt/printClaims` endpoint that illustrated the injection
    of standard and non-standard claims as different types:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that, if you begin to experience `Not authorized errors` after a while,
    the problem is that the JWT has expired. You either need to generate a new token
    or generate a token with a longer expiration. You can do this by passing in the
    expiration in seconds to the `GenerateToken` utility. For example, to generate
    a token that is valid for a full hour''s use, perform the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These samples should give you a feel for the interaction between the microservice
    client and how the use of JWTs to secure microservice endpoints allows for stateless
    authentication and RBAC, as well as custom authorization based on claims in the
    JWT.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the MicroProfile Health Check and JWT Propagation
    projects. You should now understand what a health check is and how to add application-specific
    checks, known as procedures. These allow your microservice to describe its non-trivial
    health requirements in a cloud environment. You should also understand how JWTs
    can be used to provide an authentication and authorization capability on top of
    your microservices to control access to your endpoints. You should also understand
    how content from the JWT can be used to augment your microservice in user-specific
    ways.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了MicroProfile Health Check和JWT传播项目。您现在应该了解什么是健康检查，以及如何添加应用程序特定的检查，即过程。这些允许您的微服务在云环境中描述其非平凡的健康需求。您还应该了解JWT如何用于在微服务顶部提供身份验证和授权功能，以控制对端点的访问。您还应该了解JWT中的内容如何用于以用户特定的方式增强您的微服务。
- en: The next chapter will introduce the MicroProfile Metrics and OpenTracing features.
    These allow your microservices to provide additional information ...
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍MicroProfile Metrics和OpenTracing功能。这些功能允许您的微服务提供额外的信息...
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is the MP-HC wire format useful in all environments?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP-HC线格式在所有环境中都有用吗？
- en: Can an MP-HC response contain arbitrary properties?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MP-HC响应是否可以包含任意属性？
- en: What if my application has different types of services that need to report health
    status?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我的应用程序有不同类型的服务需要报告健康状态怎么办？
- en: What is a JWT?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是JWT？
- en: What is a claim?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是声明？
- en: Are there restrictions on what can be in a JWT?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT中可以包含什么限制？
- en: What is/are the main step(s) in authenticating a JWT?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证JWT的主要步骤是什么？
- en: Beyond the security annotations, how might we perform an authorization check
    using JWTs?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了安全注释之外，我们如何使用JWT执行授权检查？
