- en: Chapter 5. Effective Data Structures beyond STL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ Standard Library provides a rich set of **generic containers** that
    can be employed for a wide variety of common programming tasks. These include
    sequence containers like `std::vector`, `std::deque`, `std::list`, `std::forward_list`,
    and ordered and unordered associative containers like `std::map`, `std::set`,
    `std::unordered_map`, `std::unordered_set`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are traversed, and their individual elements accessed, using **iterators**.
    C++ defines a hierarchy of iterator categories based on the kind of access they
    provide to the elements of the container (read, write, forward traversal, bidirectional
    traversal, and random access). The type of iterator available for traversing a
    container is dependent on the internal structure of a container.
  prefs: []
  type: TYPE_NORMAL
- en: Available alongside the containers is a library of **generic algorithms** that
    read and manipulate generic containers, using one or more iterators. These libraries
    heavily rely on **generic programming**, in which program interfaces are abstracted
    from and are parameterized in terms of data types.
  prefs: []
  type: TYPE_NORMAL
- en: This collection of generic containers, algorithms, and a bunch of accompanying
    utilities originated in the **Standard Template Library** or **STL**, developed
    at HP Labs by Alexander Stepanov and Meng Lee, and were accepted as part of the
    C++ Standard Library in 1994\. The name STL has stuck on for those parts of the
    Standard Library that originated in this work, and we will loosely use it to mean
    such parts of the library. STL containers and algorithms have been heavily used
    in C++ software ever since, but have had several limitations. Before C++11, you
    could only store copyable objects in containers. Certain classes of containers
    like hash-based associative containers, were absent in the Standard Library while
    others, like priority queues, were under-represented.
  prefs: []
  type: TYPE_NORMAL
- en: As of C++14, there are no containers yet in the Standard Library suitable for
    storing pointers to dynamically-allocated objects, though with the availability
    of `std::unique_ptr`, this is easier to deal with since C++11\. You cannot efficiently
    search the contents of an associative container, like `std::map` by value rather
    than key, nor can you easily write iterators for your custom container classes
    that work well with STL algorithms. There is no easy library to read property
    sets or key-value pairs from various standard formats (XML, JSON, etc.) into in-memory
    data structures. There are many more such routine uses that require significant
    effort if you are limited to the Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter and the next, we will look at the leading Boost libraries that
    fill many of these gaps. The chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The Boost Container library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast lookups using Boost Unordered containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers for dynamically-allocated objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressive initialization and assignment using Boost.Assign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration patterns with Boost.Iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter should provide you a solid foundation for using the wide variety
    of data structure libraries in Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Boost Container library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boost Container library implements majority of the STL container templates
    in addition to providing a few nifty nonstandard containers. So, what is the point
    of reimplementing STL containers? To understand this, let us look at what kind
    of objects can be stored in STL containers and what kind cannot be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store objects of type `T` in a `std::vector`, for example, the type `T`
    must be a complete type (that is, must be completely defined, not just declared)
    at the point where the object of type `std::vector<T>` is defined. Moreover, in
    pre-C++11, objects of type `T` must be copyable and assignable. These requirements
    generally hold for other STL containers besides `std::vector`. In general, till
    before C++11, STL was a copy-intensive framework: you copied objects into STL
    containers to store them, the containers copied them around while being resized
    or restructured, and the containers destroyed those copies when they went out
    of scope. Copying being an expensive operation in terms of time and memory is
    also more error prone and thus the exception safety of several operations on STL
    containers was weak.'
  prefs: []
  type: TYPE_NORMAL
- en: C++11 introduced move semantics that made it possible to **move-construct**
    new objects by moving or usurping the state of an existing object, typically by
    only exchanging integers and pointers and completely avoiding any non-trivial
    and error-prone copy operations. Likewise, the state or contents of an object
    could be moved into another existing object in an operation called **move-assignment**.
    Move semantics are applied by default when constructing or assigning from a temporary
    object while it can be explicitly enforced when copying from an l-value object
    (see [Appendix](apa.html "Appendix A. C++11 Language Features Emulation"), *C++11
    Language Features Emulation*). These capabilities allow operations on Standard
    Library containers in C++11 to be significantly optimized and independent of **copy
    semantics**. The objects stored in C++11 STL containers need not be **copyable**
    if they are **move constructible**. C++11 also allows objects to be constructed
    in-place in the container's layout instead of requiring them to be constructed
    first and then copied.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost Container library provides move-aware implementations of Standard
    Library containers that work not only with C++11 compilers, but also with Boost
    move emulation for C++03 compilers (see [Appendix](apa.html "Appendix A. C++11
    Language Features Emulation"), *C++11 Language Features Emulation emulation*).
    In addition, they also support in-place construction of objects. This is a significant
    functionality if you are on a C++03 compiler. In addition, the containers in Boost
    Container library can hold objects of incomplete types, making it possible to
    define interesting recursive structures that are simply not possible with the
    standard containers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the standard containers, the Boost Container library also implements
    several useful nonstandard containers that are useful for various specific uses.
  prefs: []
  type: TYPE_NORMAL
- en: Move-awareness and in-place construction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following class for encapsulating `char` strings, which is movable
    but not copyable. We use the Boost move emulation macros to define its move semantics.
    In a C++11 environment, this code translates to C++11 move syntax, while on C++03,
    it emulates the move semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.1: Movable but not copyable String**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On a pre-C++11 compiler, trying to store instances of `String` in a standard
    container will result in compiler errors because `String` is not copyable. Here
    is some code that moves String instances into a `boost::container::vector`, which
    is the Boost counterpart of `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.2: Pushing String objects onto Boost vectors**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create a Boost `vector` (line 6) and append a temporary
    String `"Hello"` to it (line 9). This automatically invokes move semantics, as
    the expression `String("Hello")` is an **rvalue**. We construct a `String` variable
    called `world` (line 7), but if we tried to append it to `strVec`, it would fail
    because it would try to copy `world`, but it is not copyable (line 11).
  prefs: []
  type: TYPE_NORMAL
- en: In order to put `world` into `strVec`, we need to explicitly move it, using
    `boost::move` (line 13). Once `world` is moved into `strVec`, its contents are
    moved out into a `String` object stored in `strVec`, and hence, its contents become
    null (line 15).Finally, we construct a `String` object in-place by calling the
    `emplace_back` member of the vector and passing it the constructor arguments of
    String (line 17). The code in listings 5.1 and 5.2 will compile and work correctly
    on pre-C++11 compilers as well as C++11\. Moreover, on C++11, the Boost macros
    for move emulation simply translate to the C++ rvalue reference syntax. Note that
    we use the `BOOST_FOREACH` macro instead of a C++11 range-based for-loop to iterate
    through the vector (see [Appendix](apa.html "Appendix A. C++11 Language Features
    Emulation"), *C++11 Language Features Emulation*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code prints the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the range-based for-loop, the loop variable `str` is introduced
    using `auto&`. If we did not use the trailing ampersand after `auto`, the compiler
    would try to generate code to copy each element of `strVec` into `str`, which
    would fail because `String` is not copyable. Using the trailing ampersand ensures
    that `str` is a reference to successive elements.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `vector`, the Boost Container library implements other standard
    containers, like `deque`, `list`, `set`, `multiset`, `map` and `multimap`, and
    also `basic_string`. These are move-aware containers that are very similar to
    their C++11 counterparts and can be used in pre-C++11 environments using move
    emulation (via Boost.Move).
  prefs: []
  type: TYPE_NORMAL
- en: Nonstandard containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the standard containers, the Boost Container library provides
    several useful nonstandard containers. This section is a quick overview of these
    containers and their applicability.
  prefs: []
  type: TYPE_NORMAL
- en: Flat associative containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two flavors of the standard associative containers: **ordered** and
    **unordered**. Ordered containers like `std:set`, `std::multiset`, `std::map`,
    and `std::multimap` are typically implemented using a balanced search tree (an
    optimized Red-Black Tree implementation is **de facto**). Thus, they store their
    elements in sorted order. The unordered containers `std::unordered_set`, `std::unordered_multiset`,
    `std::unordered_map`, and `std::unordered_multimap`, are based on hash tables.
    They originated in the Boost Container library before becoming part of the C++TR1
    release and C++11 Standard Library. These containers store objects in an array
    of buckets called a **hash table**, based on hash value computed for the object.
    There is no inherent ordering in how the objects are stored in the hash tables,
    hence the name unordered containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Associative containers support fast lookup. Ordered containers use balanced
    search trees which support logarithmic time searches, and unordered containers
    use hash tables which support amortized constant-time searches. These are not
    the only data structures that support fast lookups. Binary search on a sorted
    sequence that allows random positional access to its elements also performs in
    logarithmic time. The four flat associative containers: `flat_set`, `flat_multiset`,
    `flat_map`, and `flat_multimap` use a sorted vector to store data and use binary
    search on the vector to perform lookups. They are drop-in replacements for their
    ordered and unordered counterparts from the Standard Library but have different
    performance characteristics for insertions and lookups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.3: Using flat maps**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This first example lists a set of countries, whose capitals were moved in the
    last few decades. If you thought Lagos is still Nigeria's capital, you're in for
    a surprise. Geography apart, there isn't a whole lot surprising going on in the
    preceding code. We create a `typedef` for `boost::container::flat_map<std::string,
    std::string>`, and instantiate a map `newCapitals` of this type, inserting string
    pairs of countries and their new capitals. If we replace `boost::container::flat_map`
    with `std::map`, the code will work without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: The flat associative containers can store objects that are either copyable or
    movable. Objects are stored in a contiguous layout without using pointers for
    indirection. Thus, in order to store a given number of objects of a certain type,
    the flat containers will less memory than the tree-based and hash-based containers
    too. Insertions maintain sorted order and are thus costlier than in the other
    associative containers; in particular, for value types that are copyable but not
    movable. Also, unlike with the standard associative containers, all the iterators
    are invalidated by insertion of any new element or deletion of existing elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterations and lookups tend to be faster, and cache performance better than
    that of the standard containers due to the contiguous layout and faster performance
    of binary search. Insertions into flat containers can cause reallocations and
    elements to get moved or copied if the initial capacity of flat containers is
    exceeded. This can be prevented by reserving sufficient space using the `reserve`
    member function before performing insertions. The following example illustrates
    this aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.4: Using flat sets**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example shows one way to figure out how the internal layout of the flat
    associative containers changes with successive insertions. We define a `flat_set`
    container called `someStrings` (line 18) and insert names of eight string instruments.
    The `printContainer` template is called on the container after each insertion
    to print out the successive address in the internal vector, where each string
    is present. We reserve capacity for eight elements before the insertion (line
    19), and insert eight elements thereafter. As there is sufficient capacity at
    the outset, none of the insertions should trigger reallocations and you should
    see a fairly stable set of addresses with only the order of strings changing to
    maintain sorted order. If we commented out the call to reserve (line 19) and ran
    the code, we might see reallocations and changing addresses.
  prefs: []
  type: TYPE_NORMAL
- en: slist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `boost::container::slist` container is a singly-linked list abstraction
    similar to a container template of the same name that was available in the SGI
    STL implementation but never made it to the standard. The `std::list` container
    is a doubly linked list. C++ finally got its own singly linked list with `std::forward_list`
    introduced in C++11\. The `slist` is move-aware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singly-linked lists have a lesser memory overhead than doubly linked lists,
    although the time complexity of certain operations goes from constant to linear.
    If you need a sequence container that should support relatively frequent insertions
    and you do not need backward traversals, singly linked lists are a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.5: Using slist**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, we use an `slist` to store successive geologic eras.
    Unlike the standard sequence container `std::list`, `slist` does not have a `push_back`
    method to append an element to the end of the list. This is because computing
    the end of the list for each append would make it a linear operation instead of
    a constant one. Instead, we use the `push_front` member to add each new element
    at the head of the list. The final order of the strings in the list is the reverse
    of the order of insertion (and in the chronological order of the periods, oldest
    first).
  prefs: []
  type: TYPE_NORMAL
- en: Certain operations on singly-linked lists have higher time-complexity than their
    equivalents on doubly linked lists. The `insert` method which inserts an element
    before another is constant time in `std::list` but is linear time in `slist`.
    This is because the element preceding the position of insertion can be located
    using the link to the previous element in a doubly linked list like `std::list`
    but would require traversal from the beginning of the list in `slist`. For the
    same reason, the `erase` member function for erasing an element at a given position
    and the `emplace` member function for the in-place construction of an element
    *before* another also have linear complexity compared to their `std::list` counterparts.
    For this reason, `slist` provides member functions `insert_after`, `erase_after`,
    and `emplace_after` that provide similar functionality with slightly altered semantics
    of inserting, erasing, and emplacing objects in constant time after a given position.
    In order to allow these functions to add an element to the beginning of an `slist`,
    you can use the `before_begin` member function to get an iterator to a `head`
    pointer—a non-dereferenceable iterator which when incremented, points to the first
    element in the `slist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now rewrite listing 5.5 to insert the geologic periods into the `slist`
    in chronological order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.6: Adding elements to the end of slist**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Splicing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Besides `insert` and `emplace`, you can also add elements at any given position
    in an `slist` using an operation called `splice`. Splicing is a useful operation
    on linked lists in which one or more successive elements from one given list are
    moved to a particular position in another linked list or to a different position
    in the same list. The `std::list` container provides a `splice` member function
    that allows you to do this in constant time. In an `slist`, the time complexity
    of the `splice` member function is linear in the number of elements spliced, due
    to the need for linear traversal to locate the element before the position of
    insertion. The `splice_after` member function, like `insert_after` and `emplace_after`,
    moves elements into a list after a specified position:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.7: Splicing slists**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code example, we have an array of eight dinosaur names, starting with
    the first eight letters of the English alphabet (lines 13-16). It is a sorted
    list, which is rotated by four positions, so it starts with `Elasmosaurus` and
    has `Appatosaurus` somewhere in the middle. We make an `slist` out of these, using
    `insert_after` (line 20), and then locate the pivot at which the lexically smallest
    string lies (lines 29-30). At the end of the loop, `iter` points to the lexically
    smallest string in the `dinos` list and `last` points to the element immediately
    before `iter`. Here is the prototype of the `splice_after` overload we want to
    use to move the tail of the list to the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The sequence of elements that are to be moved from the source container to the
    target starts at the element following `start_after` and ends at `end`, both ends
    inclusive, that is, the half-open interval (`start_after`, `end`). These elements
    are inserted into the target `slist` after the position is identified by `add_after`.
    We can use the iterator `last` for the third argument. For the fourth argument,
    we compute the position of the last element in the list (lines 36-40). The iterator
    `itend` now points to the last element in the list. Using the chosen `splice_after`
    overload, we move all elements, following `last` and till the end of the list,
    to the beginning of the list (lines 43-44).
  prefs: []
  type: TYPE_NORMAL
- en: The `std::forward_list` container does not provide a `size` member function
    to return the number of elements in a list. This helps ensure that its `splice_after`
    implementation is constant time. Otherwise, during each `splice_after` operation,
    the number of elements transferred to the list would need to be counted, and the
    total count of elements need to be incremented by that much. Solely to support
    this, `splice_after` would have to be linear in the number of elements transferred
    instead of constant time. The `slist` container provides a `size` member and several
    overloads of `splice_after`. The overload of `splice_after` that we used is linear
    in the number of elements transferred, as it computes this number using a linear
    traversal. However, if we computed this number in our code without extra loops
    and passed it to the `splice_after` function, then it could avoid iterating again
    and use the passed number. There are two overloads of `splice_after` that take
    the count of the elements from the user and avoid the linear computation, thus
    providing constant-time splice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slightly altered snippet to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We compute `count` while determining the iterator range to move, and pass that
    to `splice_after`. We must make sure that our computation of `count` is correct,
    or the behavior will be undefined. This overload is useful because we had a way
    to determine the count without increasing the complexity of our calling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `std::forward_list`, the `splice_after` signature differs slightly in semantics
    from that of `boost::container::slist`. Here is the prototype of one overload
    of the `splice_after` member of `std::forward_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The iterators `before_first` and `after_last` identify an open interval, and
    the actual elements transferred would be the sequence starting at the element
    following `before_first` and ending at the element before `after_last`, that is,
    the open interval (`before_first`, `after_last`). Using this function, we would
    not need to write the loop to determine the last element in this case because
    we could simply use `dinos.end()` as the marker for one-past-the-end position.
    If `dinos` were an instance of `std::forward_list`, we would have edited listing
    5.7, thus saving six lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All `splice_after` overloads in `std::forward_list` that transfer a range of
    elements are linear in the number of elements transferred. While we saw a constant-time
    overload in `boost::container::slist`, we had to write linear complexity logic
    to pass the correct count of elements to it. So, in many cases, code using `std::forward_list`
    might be more maintainable and no less efficient if you can make do without the
    constant-time `size` member function.
  prefs: []
  type: TYPE_NORMAL
- en: stable_vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `std::vector` container stores objects in contiguous memory. The `vector`
    reallocates internal storage and copies or moves objects to new storage as needed,
    so as to accommodate additional new objects. It allows fast random access to the
    stored objects using an index. Inserting elements at arbitrary positions in the
    vector is expensive compared to appending elements at the end, because insertion
    requires elements after the point of insertion to be moved in order to make room
    for the new element. There is one more implication of this behavior. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.8: Iterator invalidation in std::vector**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `vector` of integers `v` and initialize
    it with four integers (line 5). The brace-enclosed list of comma-separated values
    used to initialize the vector is a very handy C++11 construct called **initializer
    list**. In pre-C++11, you had to manually append values or, as we will see later
    in this chapter, use the `Boost.Assign` library. We then compute the iterator
    to the last element of the object as an offset from the first iterator (line 7).
    We assert that the last element is 5 (line 8). Next, we insert an element before
    the last element (line 9). Past this point, the iterator `last` will be invalidated
    and any access of the iterator `last` will be undefined behavior. In fact, in
    the two random access containers, vectors and deques, iterator invalidations happen
    all too often. Any write operation on the vector can invalidate iterators. For
    example, if you erase an element at a particular iterator position, all existing
    iterators to later positions are invalidated. Even appending an element to the
    end of the vector could trigger a resize of the vector''s internal storage, requiring
    elements to be moved. Such an event will invalidate all existing iterators. The
    Standard Library `vector` is an **unstable container**. The `boost::container::stable_vector`
    is a sequence container that provides random access coupled with stable iterators,
    which are not invalidated unless the element they point to is erased. Have a look
    at the following image from the Boost documentation pages on stable_vector ([http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector](http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![stable_vector](img/1217OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As illustrated here, `stable_vector` does not store the objects in a contiguous
    memory layout. Instead, each object is stored in a separate node, and a contiguous
    array stores pointers to these nodes in the order of insertion. Each node contains
    the actual object and also a pointer to its position in the array. The iterators
    point to these nodes rather than to positions in the array. Thus, nodes with existing
    objects do not change after insertion of new objects or deletion of some existing
    objects and their iterators also remain valid. Their back pointers are updated
    however when they change positions due to insertions/removals. The contiguous
    array of node pointers still allows random access to elements. Because of the
    extra pointers and indirections, `stable_vector` tends to be slower than `std::vector`,
    but that is the trade-off for stable iterators. Here is some code to boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.9: Stable vector example**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using `stable_vector` is no different from using `vector`, and it is move-aware
    too. In the preceding example, we want to store the names of different types of
    clouds in a `stable_vector` of `std::string`. There are eight cloud names present
    in an array called `cloud_names` (lines 7-9). We create a `stable_vector` called
    `clouds` to store these names, and reserve a capacity for only four elements (lines
    12-13). What we want to show is that once we add elements beyond the capacity
    of the `stable_vector`, requiring an expansion of the underlying array and movement
    of the existing data, iterators computed before the change in capacity still remain
    valid. It is entirely possible for `reserve` to allocate more capacity than that
    requested, and if this is more than the total number of cloud names we have, our
    example is moot.
  prefs: []
  type: TYPE_NORMAL
- en: We first store names of clouds (lines 18-21) without overshooting the capacity,
    and compute the iterator to the first element (line 23). We then append remaining
    cloud names, if any (lines 25-27). If there were any remaining cloud names, then
    they would have caused a resize when the first of them got stored.
  prefs: []
  type: TYPE_NORMAL
- en: We compute the iterator to the sixth element (line 29), erase the fifth element
    (line 32), and insert two more cloud names before the fourth element (lines 34-35).
    After all this, the iterator `first` still points to the first element (line 37).
    At the time we computed the iterator `sixth`, it pointed to the sixth element
    and its value was `"cirrocumulus"`, the sixth string in the `cloud_names` array.
    Now with one deletion and two insertions before it, it should be the seventh element
    (line 38), but its value should remain unchanged (line 39)—as stable as iterators
    get!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Boost 1.54, the `capacity` member function of `stable_vector` returns
    an incorrect value for the capacity after a call to `reserve`. By calling the
    `resize` member function with an argument as large as what was passed to `reserve`
    (line 13) before calling `capacity`, we can circumvent the bug and ensure that
    a subsequent call to `capacity` returns the correct value. Once the bug is fixed
    in a later release, the call to `resize` following the call to `reserve` should
    not be needed.
  prefs: []
  type: TYPE_NORMAL
- en: static_vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `boost::container::static­_vector` template is a vector-like container with
    an upper limit on the size defined at compile time. It allocates a fixed size,
    uninitialized storage in its layout, rather than dynamically in a separate buffer.
    It does not try to value-initialize all the elements upon instantiation, unlike
    `vector` or `stable_vector`, both of which try to value-initialize elements when
    an initial size is specified as a constructor argument. The absence of heap allocation
    and value-initialization makes `static_vector` instantiation almost zero overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `static_vector` is used just as a regular vector with one important caveat.
    Trying to insert one element too many into a `static_vector` would result in a
    runtime error, so you should always make sure that there is enough room in the
    `static_vector` before trying to insert an additional element:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.10: Using a static_vector**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We construct a `static_vector` of `ChattyInit` objects, `ChattyInit` being
    a simple class whose constructor prints its own name. The fixed size of the `static_vector`
    is specified as a numeric template argument (line 15). Running the preceding code
    prints the following on my GNU Linux box with a g++ 4.9 compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that no objects are created as part of `static_vector` initialization,
    and individual objects are instantiated as they are appended. We make sure that
    the total number of elements inserted does not exceed the capacity of the container
    (line 18). Because the elements of `static_vector` are not value-initialized by
    default, the `size` member function returns zero when no elements are explicitly
    added. Compare this with `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we actually tried appending one element too many (line 22), the program would
    crash. `boost::container::static_vector` is a useful container if you are looking
    for a fast, size-bounded `vector` replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Fast lookups using Boost Unordered containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The four standard associative containers in C++03: `std::set`, `std::map`,
    `std::multiset`, and `std::multimap` are ordered containers and store their keys
    in some sorted order using balanced binary search trees. They require an ordering
    relationship to be defined for their keys and provide logarithmic complexity insertions
    and lookups. Given the ordering relationship and two keys, A and B, we can determine
    whether A precedes B or B precedes A in the relationship. If neither precedes
    the other, the keys A and B are said to be equivalent; this does not mean A and
    B are equal. In fact, the ordered containers are agnostic to equality and there
    need not be a notion of equality defined at all. This is the reason, such a relation
    is called a **strict weak ordering**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We define a type `Person` that represents a human individual, using the fields
    `name`, `age`, `profession`, and `nationality` (lines 3-9), and then define an
    ordering relation using the `operator<` that does not take the `profession` field
    into account (lines 11-15). This allows `Person` objects to be ordered, but not
    compared for equality. Two `Person` objects `p1` and `p2` would be deemed equivalent
    if `!(p1 < p2)` and `!(p2 < p1)` both hold. This would be true of any two `Person`
    objects with the same `name`, `age`, and `nationality`, irrespective of their
    `profession`. The ordered container `std::set` does not allow multiple keys that
    are equivalent to each other while `std::multiset` does. Likewise, `std::map`
    does not allow multiple key-value pairs, whose keys are equivalent, while `std::multimap`
    does. Thus, adding a key-value pair to a `std::map` that already contains an equivalent
    key overwrites the older value.
  prefs: []
  type: TYPE_NORMAL
- en: The ordered containers are implemented using a kind of balanced binary search
    tree known as Red-Black Trees, with several optimizations. They offer one key
    capability besides the ability to lookup and insert keys in logarithmic time—an
    ordered traversal of the keys in the container. However, if you do not need ordered
    traversal, then there are more efficient alternatives available—hash tables being
    the most obvious one. Appropriate implementations of hash tables support constant-time
    lookups on average, and amortized constant-time inserts that outperform the ordered
    containers with better cache performance, while having a somewhat higher space
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boost Unordered library introduced four hash table-based counterparts of
    the ordered containers: `boost::unordered_set`, `boost::unordered_map`, `boost::unordered_multiset`,
    and `boost::unordered_multimap`, which became part of the C++ TR1 release in 2007
    and were included in the Standard Library in C++11\. Of course, you can use Boost
    Unordered even with a C++03 compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unordered containers require the notion of equality to be defined for the objects
    they store, but not the notion of ordering. Thus, for unordered containers, equivalence
    is defined in terms of equality rather than ordering. In addition, unordered containers
    need a way to compute a hash value of each key to determine the position in the
    table, where the key is stored. In the following code examples, we will see how
    to use unordered containers and compute hash values for objects, reusing the `Person`
    type we introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.11: Using unordered_sets**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how an `unordered_set` is used to store objects
    of the user-defined type `Person` that we defined in the earlier listing. We define
    an `unordered_set` of `Person` objects (line 31), create two `Person` objects
    `p` and `p1`, and insert them into the `unordered_set` called `Persons` (lines
    34, 37). We define a third `Person` object `p2`, which is a copy of `p`, and try
    to insert this element but fail (line 43). The container being a set (`unordered_set`)
    contains unique elements. Since `p2` is a copy of `p` and is equal to it, its
    insertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways for the `unordered_set` to compute the hash value
    of each object it stores. We demonstrate one such way: open the `boost` namespace
    (line 14) to define a specialization for the function template `boost::hash` for
    the type `Person` in question (line 21-24). To compute the hash of a `Person`
    object, we consider only two of its fields: `name` and `nationality`. We use the
    utility functions `boost::hash_value` and `boost::hash_combine` (to generate the
    hash values for individual fields and combine them). Since we only consider the
    name and nationality of a person while determining the hash value for that `Person`
    object, the objects `p` and `p1`, both of which represent individuals with the
    same name and nationality, end up having the same hash value. However, they are
    not equal, as their other fields are different, and therefore, both objects are
    successfully added to the set. On the other hand, the object `p2` is a copy of
    `p`, and when we try inserting `p2` into the `persons` set, the insertion fails
    because sets do not contain duplicates and `p2` is a duplicate of `p`. The `boost::unordered_multiset`
    and `boost::unordered_multimap` containers are hash-based containers that can
    store duplicate objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Computing good hash values is important in ensuring that objects are well distributed
    in the hash table. While the `boost::hash_value` and `boost::hash_combine` utility
    function templates help compute hash values for more complex objects, their indiscriminate
    application can result in inefficient hashing algorithms. For user-defined types,
    it may be better in many cases to roll out a mathematically validated hashing
    algorithm that exploits the semantics of the user-defined type. If you use primitives
    or standard types like `std::string` as keys in your `unordered_set` or `unordered_map`,
    then you need not roll out your own hash function, as `boost::hash` does an adequate
    job.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up values is typically done using the `find` and `count` member functions
    of the unordered associative containers. While `find` returns an iterator to the
    actual object stored in the container, corresponding to the key passed, `count`
    returns just the count of occurrences of the key. The `equal_range` member function
    of `unordered_multiset` and `unordered_multimap` return the range of matching
    objects. For `unordered_set` and `unordered_map`, the count member function can
    never return a value greater than 1.
  prefs: []
  type: TYPE_NORMAL
- en: Containers for dynamically-allocated objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming relies heavily on using polymorphic base class references
    to manipulate objects of an entire class hierarchy. More often than not, these
    objects are dynamically allocated. When dealing with a whole collection of such
    objects, STL containers come a cropper; they store concrete objects of a single
    type and require copy or move semantics. It is impossible to define a single container
    that can store objects of different classes across a hierarchy. While you may
    store polymorphic base class pointers in containers, pointers are treated as POD-types
    and with little support for deep-copy semantics. The life cycle of dynamically-allocated
    objects is none of STL's business. But it is unwieldy to define a container of
    pointers whose lifetimes have to be managed separately without any help from the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost Pointer Container library addresses these gaps by storing pointers
    to dynamically-allocated objects and deallocating them at the end of the container's
    life. The pointer containers provide an interface through which you can operate
    on the underlying objects without the need for pointer indirection. As they store
    pointers to objects, these containers naturally support polymorphic containers
    without any extra machinery.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows pointer containers and their Standard Library counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pointer container from Boost | Standard Library container |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_array | std::array |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_vector | std::vector |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_deque | std::deque |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_list | std::list |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_set / boost::ptr_multiset | std::set / std::multiset |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_unordered_set / boost::ptr_unordered_multiset | std::unordered_set
    / std::unordered_multiset |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_map / boost::ptr_multimap | std::map / std::multimap |'
  prefs: []
  type: TYPE_TB
- en: '| boost::ptr_unordered_map / boost::ptr_unordered_multimap | std::unordered_map
    / std::unordered_multimap |'
  prefs: []
  type: TYPE_TB
- en: 'Boost defines the pointer container equivalents for all the standard containers.
    These containers can be used to store polymorphic pointers, and the underlying
    objects pointed to by the stored pointers need not be copyable or movable. Here
    is a basic example to get started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.12: Using Boost pointer containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `AbstractJob` is an abstract base class (line 5) which
    defines two private pure virtual functions `doStep1` and `doStep2` (lines 16,
    17), and a non-virtual public function `doJob` which calls these two functions
    (line 10). `JobA` and `JobB` are two concrete implementations of `AbstractJob`,
    which implement the virtual functions `doStep1` and `doStep2`. The `override`
    keyword trailing the function signature (lines 22, 26, 33, and 37) is a C++11
    feature that clarifies that a particular function overrides a virtual function
    in the base class. In the main function, we create a `ptr_vector` of `AbstractJobs`.
    Note that the template argument is not the pointer type (line 44). We then append
    two concrete instances of `JobA` and `JobB` to the vector (lines 46 and 47). We
    access the first and last elements in the vector using the `front` (line 49) and
    `back` (line 50) member functions, both of which return references to the underlying
    objects rather than their pointers. Finally, we read off the stored objects in
    a range-based for-loop (line 52). The loop variable `job` is declared as a reference
    (`auto&`), not a pointer. Member functions of the pointer containers as well as
    iterators return references not to the stored pointers but to the underlying objects
    they point to, providing for syntactic ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'While range-based for-loops and `BOOST_FOREACH` make it easy to iterate through
    collections, you can also use the iterator interface directly if you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, notice that the iterator returns a reference to the underlying
    object, not to the pointer (line 53), even though the container stores pointers.
    The variable `job` is a reference because `AbstractJob` is abstract and cannot
    be instantiated. But what if the base class was not abstract? Consider the following
    example of a non-abstract polymorphic base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.13: Pitfalls of copyable concrete base classes**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code compiles cleanly but may not do what you expect it to do.
    In the body of the for-loop, we assign each object of a derived class to a base
    class instance (line 29). The copy constructor of `ConcreteBase` takes effect,
    and what we get is a sliced object and incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, it is a good idea to prevent copying at the outset by deriving the base
    class itself from `boost::noncopyable`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This would prevent slicing due to an inadvertent copy by causing such code to
    be flagged as compilation error. Note that this would make all classes in the
    hierarchy noncopyable. We will look at ways of adding copy semantics to such a
    hierarchy in the next section. But before that, a look at using associative pointer
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store dynamically-allocated objects, including polymorphic objects in
    `boost::ptr_set` or `boost::ptr_multiset`. Since these are ordered containers,
    we must define a strict weak ordering relation for the value-type stored in the
    container. This is typically done by defining the `bool operator<` for the type.
    If you store polymorphic pointers to objects of a class hierarchy, you must define
    an ordering relationship for all objects of the hierarchy, not just among objects
    of a particular concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.14: Using associative pointer containers – ptr_set**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the use of `std::ptr_set` to store polymorphic pointers to dynamically-allocated
    objects. The `Animal` abstract base declares a pure virtual function `name`. Two
    two derived classes, `SnowLeopard` and `Puma`, (representing two real mammal species)
    override them. We define a `ptr_set` of `Animal` pointers called `animals` (line
    53). We create two pumas named `Kaju` and `Juki` and a snow leopard named `Rongi`,
    inserting them into the set `animals` (lines 54-56). When we iterate through the
    list, we get references to the dynamically-allocated objects, not pointers (lines
    58, 59). The `operator<` (line 46) compares any two animals and orders them lexically
    by name. Without this operator, we would not be able to define the `ptr_set`.
    Here is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The three animals are listed in the first three lines, and then the destructor
    of each object is invoked and prints its identity as the `ptr_set` container instance
    goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common use of associative pointer containers is to store polymorphic
    objects in a map or a multimap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.15: Using associative pointer containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a multimap called `animals` (line 6) that keeps the species name
    as a key of type `std::string`, and stores one or more polymorphic pointers to
    animals of that species for each key (lines 10-12). We use the same `Animal` hierarchy
    we used in listing 5.14\. We loop through all the entries in the multimap, printing
    the name of the species followed by the given name of the specific animal. Here
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Each `Animal` entry is of type `std::pair<std::string, Animal*>`, and thus the
    key and value are accessed using the members `first` and `second`. Note that `entry.second`
    returns the stored pointer, not a reference to the underlying object (line 16).
  prefs: []
  type: TYPE_NORMAL
- en: Ownership semantics of pointer containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen that pointer containers "own" the dynamically-allocated
    objects we store in them, in the sense that the container takes care of deallocating
    them at the end of its own life. The objects themselves need to support neither
    copy nor move semantics, so it is natural to wonder what it would mean to copy
    a pointer container. Actually, the pointer containers are copyable and support
    simple copy semantics—upon copy-construction or copy assignment of a pointer-container,
    it dynamically allocates a copy of each object in the source container and stores
    the pointer to that object. This works fine for any non-polymorphic type that
    is either a POD-type or has a copy constructor. For polymorphic types, this behavior
    leads to slicing or failure to compile when the base classes are abstract or noncopyable.
    In order to create deep copies of containers with polymorphic objects, the objects
    must support the clone interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support creating copies of objects of a polymorphic type `T`, in a namespace
    `X`, you must define a free function in the namespace `X` with the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `new_clone` is found via **Argument Dependent Lookup** (**ADL**)
    and is expected to return a copy of the object `obj` passed to it, whose runtime
    type should be the same as that of `obj`. We can extend the animal example; we
    can do this by defining a `clone` virtual function that is overridden in each
    subclass of `Animal` to return a copy of the object. The `new_clone` free function
    then simply has to call the clone function on the passed object and return the
    cloned pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.16: Making objects and pointer containers cloneable**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For full generality, we put the `Animal` and its derived classes into a namespace
    called `nature` (line 6), and add a pure virtual function called `clone` in `Animal`
    (line 13). We override the clone method in each of the two derived classes (line
    33, 42), and implement the `new_clone` free function in terms of the `clone` method.
    We declare two `ptr_vector` containers of `nature::Animal` pointers: `animals`
    and `animals2` (line 51), initialize `animals` with three furry mammals (lines
    53-55), and finally, assign the clone of `animals` to `animals2` (line 57). What
    if instead of the call to `clone`, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the line would fail to compile because `Animal` is abstract and
    noncopyable, and the preceding line would try to slice each stored object in `animals`
    and copy it to `animals2`. If `Animal` was copyable and nonabstract, such a line
    would have compiled, but `animals2` would contain some hapless, sliced `Animals`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pointer containers support moving ownership of objects from one container
    to another, even when the containers are of different types. You can move a single
    element, a range of elements, or the entire contents of one container to another,
    in operations reminiscent of `slice` in Standard Library `std::list`. The following
    example illustrates some of these techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.17: Moving pointers between containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example illustrates all the different techniques of moving elements
    from one container to another. Two `Puma`s (`Kaju` and `Juki`) and two `SnowLeopard`s
    (`Rongi` and `Turo`) are on mountain A, so the vector `mountA` stores the animals
    on mountain A. The four animals decide to move to mountain B; the vector `mountB`
    is empty to start with. Then, the four `Animals` move to mountain B, so we move
    the contents of `mountA` to `mountB`, using the release method of `mountA` (line
    25). Following this, there are no more `Animals` in `mountA` (line 26) while `mountB`
    contains all four (line 27). Now the animals want to cross over to mountain C,
    and it is a different kind of mountain that is difficult to climb. The animals
    on mountain C are tracked in a `ptr_list` called `mountC` (rather than a `ptr_vector`).
    To start with, `Rongi`, the snow leopard (the second element in `mountB`) shows
    the way and is the first to climb mountain C. So we move the second element of
    `mountB` to the beginning of `mountC`, using the `transfer` member function of
    `mountC` (line 30). Next, Turo, the other snow leopard ventures to cross over
    to C. We move the last element of `mountB` to the end of `mountC` by first popping
    it off the end of `mountB` (line 35), then calling `release` on the `popped` object,
    and appending the returned pointer to `mountC` (line 36). At this point, there
    are two more `Animals` on `mountB` (line 39). The remaining elements (two pumas)
    are moved from `mountB` to the end of `mountC` by a call to the `transfer` member
    function of `mountC` (lines 42, 43), thus completing the exodus of the animals
    (line 45).
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `transfer` is the iterator identifying the position in
    the destination container, where the moved elements are inserted. In the three-parameter
    overload (line 30), the second argument identifies the iterator to the element
    in the source container, which needs to be moved, and the third argument is a
    reference to the source container. In the four-parameter overload, the second
    and third arguments identify the range of elements from the source container that
    need to be moved, and the fourth argument is the reference to the source container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on pre-C++11, you cannot use the `auto` keyword to do away with
    type names you do not care about (line 35). In that case, you will need to store
    the result of `pop_back()` (or other methods that remove and return an element
    from the container) in a variable of type `container::auto_type`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Null pointers in pointer containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the fact that pointer containers store pointers and give out references
    to the underlying objects, what happens if you store a null pointer? By default,
    pointer containers do not allow null pointers and trying to store a null pointer
    would duly cause an exception to be thrown at runtime. You can override this behavior
    and tell the compiler to allow storing nulls. To do this, you have to modify your
    container definition slightly, to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages are limited, and you have to additionally make sure you do not
    dereference a potential null pointer. Your code becomes complex, and it becomes
    difficult to use range-based for-loops. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is best to avoid storing null pointers, and instead, use the Null Object
    Pattern that the library author recommends. You can see the Boost online documentation
    for more details on the Null Object Pattern ([http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the Boost Pointer Containers are a full-featured set of containers
    for pointers to dynamically-allocated objects and are well suited for handling
    polymorphic objects. In C++11, one alternative way of achieving similar semantics
    is via containers of `std::unique_ptr<T>`. With sufficient optimization, the overhead
    of the `unique_ptr` wrapper is likely to be minimal, and the performance comparable
    to that of Boost's pointer container. While using containers of `boost::shared_ptr<T>`
    (`T` being the type of the dynamically-allocated objects) serves the use cases
    described here, they have higher memory and runtime overhead and are not optimal
    unless shared ownership semantics are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Expressive initialization and assignment using Boost.Assign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initializing an object or assigning some literal value to it using a single
    statement is a succinct way of generating the contents of the object. It is easy
    to do this for simple variables like numeric variables or strings, because there
    are readily available literals. On the other hand, there are no simple syntactic
    means of initializing containers with arbitrary sets of values. This is because
    expressing more complex objects with nontrivial internal data structures as literals
    is difficult. Using some ingenious patterns and overloaded operators, the Boost.Assign
    library makes it possible to initialize and assign values to a whole host of STL
    and Boost containers, using a very expressive syntax.
  prefs: []
  type: TYPE_NORMAL
- en: With the availability of the new **initializer list** and **uniform initialization**
    syntax in C++11, these tasks can be accomplished without Boost.Assign. Still Boost.Assign
    is the only means of getting the job done on pre-C++11, and also provides some
    nifty additional capabilities not easily available via initializer lists and uniform
    initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning lists of values to containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Boost.Assign is one of those nifty little libraries in Boost, which you get
    into the habit of using at the smallest opportunity. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.18: Assigning a list of values to a vector**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning a list of values to a vector was never as much fun as with Boost.Assign.
    By overloading the comma operator (`operator,`) and `operator+=`, the Boost Assign
    library provides an easy way to append a list of values to a vector. In order
    to use the operators, we include `boost/assign.hpp` (line 3). The `using namespace`
    directive makes the operators defined in Boost Assign available in the global
    scope (line 6). Without this, we would not be able to freely use the operators
    and the expressiveness would be gone. We append three "good morning" greetings
    in English, French, and Italian to the vector `greetings` (line 11), and then
    three more in Hebrew, German, and French (line 12). The net effect is a vector
    with six strings (line 14). We could have replaced the vector with a deque and
    this would have still worked. If you wanted an alternate mode of insertion like
    inserting at the head of a list or deque or inserting into a map, Boost Assign
    can still work for you. Here is one more example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.19: Assigning elements to other containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see examples of assigning values to three different kinds of containers.
    We first push six "good night" greets in different languages into the head of
    a `std::deque` (lines 13-14). We do this using the `push_front` adaptor from Boost
    Assign which invokes the method of the same name `push_front` on the deque `greets`.
    It should be clear that after this operation, the last string in the list (`"Bonne
    nuit"`) sits at the front of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have had a thing for rock ''n'' roll and are as old as I am, you would
    perhaps identify the characters in the next example: an `std::map` of characters
    from rock ''n'' roll songs and albums, and what they did (according to those songs).
    Using the `insert` adaptor, which calls the method of the same name, on the map
    `rockCharacters`, we insert five pairs of strings—each mapping a character to
    an act (lines 17-22). The `insert` adaptor and other adaptors like it return an
    object with an overloaded `operator()` which can be chained. By chaining calls
    to this operator, the list of values is created.'
  prefs: []
  type: TYPE_NORMAL
- en: The last container we use is a `std::list`, and for fun, we keep a list of famous
    trios from fiction. The `boost::tuple` template can be used to define tuples of
    an arbitrary number of elements of different types. Here, we use a `boost::tuple`
    of three strings to represent a trio, and keep a list of such trios in the variable
    `trios` (line 24). The `push_back` adaptor from Boost Assign is used to append
    the trios to the end of the list. The operator `+=` used in listing 5.17 with
    `std::vector` calls `push_back` on the underlying container. However, in this
    case, the `push_back` adaptor needs to be used to allow tuples of values to be
    pushed into the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we print the content of the data structures. To access each element of
    each tuple in the list `trios`, we use the `boost::get` template that accesses
    the elements in tuples by a 0-based index (lines 44-45). Running this code prints
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Initializing containers with lists of values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we saw various ways of appending or inserting values
    into a container, but Boost.Assign also lets you initialize containers with values
    at the time of construction. The syntax is slightly different from what is used
    for assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.20: Aggregate initialization with Boost Assign**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example constructs a vector of the first ten Catalan Numbers.
    The nth Catalan number (`n` being a nonnegative integer) equals the number of
    permutations of a string containing `n` left parentheses and `n` right parentheses
    in which all parentheses are correctly matched. We use the `list_of` adaptor from
    the `boost::assign` namespace to construct the list of first ten Catalan numbers
    with which the vector `catalan` is initialized (lines 10-11). We use an `ostream_iterator`
    to print this list (lines 13-14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a `std::map` containing the first eight Bernoulli numbers:
    the keys are the ordinal positions and the values are the numbers themselves.
    Bernoulli numbers are a sequence of rational numbers (expressible as a ratio of
    two integers) that arise in number theory and combinatorics. For initializing
    such a map, we use the `map_list_of` adaptor passing keys and values as shown
    (lines 17-25). For representing a rational number, we use the `boost::rational`
    template defined in the header `boost/rational.hpp`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, you can also create anonymous sequences using Boost Assign.
    These sequences can be constructed either as a sequence of non-constant l-value
    references or as a sequence of const l-value references that can admit literals.
    They are more efficient to construct than `list_of` and can be used in its place
    for initializing sequence containers like vectors. These sequences comply with
    the Boost Range concept and can be used anywhere a range can be used. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.21: Creating anonymous sequences**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We create an anonymous sequence of size ten using the `cref_list_of` adaptor,
    but actually put only eight values in it (line 22). If we had variables to put
    in the sequence instead of character literals, we could have used the `ref_list_of`
    adaptor, and this would have created a mutable sequence. We use `boost::size`,
    `boost::begin` and `boost::end` functions for operating on ranges to determine
    the length of the sequence (line 9) and its first and last elements (lines 12-13).
    Next, we use an anonymous list of string pairs to initialize a `std::map` (lines
    26-29). Note that `value_type` nested typedef in a map represents the type of
    each key-value pair in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 introduces the very handy aggregate initialization syntax using which
    arbitrary containers can be initialized. It is syntactically simpler to perform
    initialization using the aggregate initializer syntax than Boost Assign and is
    likely more efficient. In pre-C++11 environments, Boost Assign''s initialization
    syntax remains the only choice. Here are a few examples of C++11 aggregate initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows the way to use a comma-separated list of values enclosed
    in curly braces to initialize collections. The `scholars` vector is initialized
    with names of four Muslim scholars from the Middle Ages, and then the `scholarsFrom`
    map is initialized with the names of those scholars as keys and their places of
    origin as the values. Note how each key-value pair is enclosed in braces in a
    comma-separated list of such pairs. Also, note that we freely use l-values (like
    `scholars[0]`) as well as literals in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing pointer containers and assigning values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boost Assign library provides special support for assigning values to pointer
    containers and initializing pointer containers in an exception-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following short example summarizes the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.22: Boost Assign with pointer containers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define a type `WorkShift` that represents a shift at a
    workplace and encapsulates information about work hours for a particular shift.
    Its constructor takes two arguments, the start and end time of the shift, and
    defaults them to 9.30 and 17.30 (line 12). We create a `ptr_vector` of `WorkShift`
    objects and initialize them, using the `ptr_list_of` adaptor. Instead of passing
    constructed objects, we pass constructor arguments for two objects: a shift between
    6.00 and 14.00 and another shift with a default start and end time (line 28).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The template argument to `ptr_list_of` denotes which type to instantiate. We
    add two more shifts to the `ptr_vector` called `shifts`, using the `ptr_push_back`
    adaptor. Next, we make a `ptr_map` called `shiftMap` with string keys, identifying
    the type of shifts and pointers to shift objects for values (line 31). We then
    use the `ptr_map_insert` adaptor to insert the elements into the map. We create
    each entry by invoking `operator()`, passing the string key as the first argument
    and the constructor arguments for the `WorkShift` object as the remaining arguments
    (lines 32-33). We print the contents of the `ptr_map` (line 35-38), using the
    overloaded streaming operator for `WorkShift` (line 19). The following is the
    output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to understand why a separate class of adaptors is used for
    initializing pointer containers. The following, for example, is a perfectly a
    valid code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in this example, the user of the library (that is us) manually allocates
    two new `WorkShift` objects. The order in which these get allocated is not guaranteed
    by the compiler. Only the order in which they are appended to `shifts` is guaranteed
    (via calls to the overloaded `operator()` in the adaptor returned by `boost::assign::push_back`).
    So, for the preceding sample, the compiler could generate code roughly equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If the constructor of `WorkShift` threw while `w2` was constructed (line 3),
    then `w1` would be leaked. In order to ensure exception-safety, we should use
    `ptr_push_back`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Instead, the overloaded `operator()` in the `boost::assign::ptr_push_back` adaptor
    takes the constructor arguments for each `WorkShift` object that needs to be in
    the `shifts` container and constructs each `WorkShift` object, forwarding those
    arguments to the `WorkShift` constructor. The call returns only after the constructed
    object is in the container. This ensures that at the time of construction of a
    `WorkShift` object, all previously constructed `WorkShift` objects are already
    part of the container. So if the constructor throws, the container along with
    the previously-constructed objects are released.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration patterns using Boost.Iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Iteration is a fundamental task in most programming problems, whether it is
    iterating through the elements of a container, a series of natural numbers, or
    the files in a directory. By abstracting how a collection of values is iterated
    through, we can write generic code to process such a collection without depending
    on methods of iteration specific to each collection.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard Library containers expose iterators for this purpose, and the generic
    algorithms in the Standard Library can operate on any conforming container through
    its iterators, without depending on the specific type of the container or its
    internal structure.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost.Iterator library provides a framework for writing iterators for custom
    classes that conform to the standards and are compatible with algorithms in the
    Standard Library. It also helps generalize iteration concepts to more abstract
    object collections, not limited to containers.
  prefs: []
  type: TYPE_NORMAL
- en: Smart iteration using Boost.Iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Boost Iterator library provides a number of iterator adaptors that make
    iterating over containers and sequences of values more expressive and efficient.
    An iterator adaptor wraps an iterator to produce another iterator. The adapted
    iterator may or may not iterate over the entire range of elements addressed by
    the underlying iterator. Also, they can be designed to return a different value,
    potentially of a different type than the underlying iterator. In this section,
    we look at a few examples of such iterator adaptors from Boost.
  prefs: []
  type: TYPE_NORMAL
- en: Filter Iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The filter iterators iterate over a subsequence of an underlying sequence of
    elements. They wrap an underlying iterator sequence and take a unary Boolean predicate,
    which is used to determine which elements to include from the underlying range,
    and which ones to skip. The predicate takes an element of the underlying sequence
    as a single argument and returns true or false. The ones for which true is returned
    are included in the iteration, the rest are filtered out; hence the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create filter iterators by using the `boost::make_filter_iterator`
    function template. You pass it a unary function object (functor, lambda, or function
    pointer) that returns `bool`. You also pass it not one, but two iterators: the
    one it wraps and another one marking the end of sequence. In the following example,
    we have a list of `Person` objects, and we need to write code to make a payout
    of 100 dollars to the bank account of each person who is seventy years of age
    or older:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.23: Using filter iterators**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the function `payout` takes an account number and an amount
    and initiates a payment to the account (line 17). The function `creditSum` takes
    a pair of iterators defining a sequence of `Person` objects and an amount, and
    initiates a payment of that amount to each `Person` in the sequence, calling `payout`
    for each (line 23-24). We have a vector of `Person` objects (line 39), which we
    initialize with the details of five people, using the uniform initialization syntax
    from C++11\. We cannot directly call `creditSum` on the entire range of elements
    in the vector because we only want to credit it to people who are seventy or older.
    To do this, we first define the predicate function `seventyOrOlder` (line 32)
    that helps us select the candidate entries, and then define the filter iterators
    `first` and `last` (lines 45-49). Finally, we call `creditSum` with the pair of
    filter iterators and the sum to credit (line 51).
  prefs: []
  type: TYPE_NORMAL
- en: Transform Iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transform iterators allow you to traverse a sequence, and when dereferenced,
    return the result of applying a unary function to the underlying element of the
    sequence. You can construct transform iterators using `boost::make_tranform_iterator`,
    passing it the unary function object and the underlying iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider `std::map` objects containing subject names as keys and subjects scores
    as values. We use transform iterators to compute the sum of the scores in all
    the subjects, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.24: Using transform iterators**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The map `subjectScores` contains the scores in individual subjects stored against
    each subject name. We use the C++11 uniform initialization syntax to initialize
    the map (lines 25-26). We want to iterate through the values in this map and compute
    their sum. Iterating through `subjectScores` will give us key-value pairs of subject
    names and scores. To extract the score from a pair, we define a functor `GetScore`
    (lines 14-15). We then define a pair of transform iterators `first` and `last`,
    each constructed using an instance of the `GetScore` functor and the underlying
    iterator, and pointing to the beginning and end of the `subjectScores` map (lines
    28-31). By calling `std::accumulate` from `first` to `last`, we sum over the scores
    in the map (line 33) and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `GetScore` derives from `std::unary_function<ArgType, RetType>`,
    where `ArgType` is the type of the functor's single argument and `RetType` is
    return type of the functor. This is not required for C++11, and you do not need
    to derive `GetScore` from any specific class in C++11.
  prefs: []
  type: TYPE_NORMAL
- en: Like `boost::transform_iterator`, the `std::transform` algorithm allows applying
    a transform to each element in a sequence, but you must also store the results
    in a sequence. The transform iterator allows you to create a lazy sequence whose
    elements are evaluated, as they are accessed without the binding need to store
    them anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Function Output Iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function output iterators apply a unary function to each element that is
    assigned to them. You can create a function output iterator using the `boost::make_function_output_iterator`
    function template, passing it a unary function object. You can then use `std::copy`
    or a similar algorithm to assign elements from a sequence to the function output
    iterator. The function output iterator simply calls the function on each element
    assigned to it. You can encapsulate any logic in the function object you provide,
    print them enclosed in quotes, add them to another container, keep a count of
    elements processed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have a list of directory names, and using the
    `boost::function_output_iterator`, we concatenate them together separated by spaces,
    making sure to quote any strings with embedded spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.25: Using function output iterators**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We define a functor `StringCat` that stores a non-const reference to a `std::string`
    passed to its constructor (line 12) in a member called `result_`. It defines a
    unary `operator()`, which takes a single string parameter and appends it to `result_`.
    If the passed string has embedded spaces or tabs, it is quoted and appended with
    a leading space (line 14). Otherwise it is appended with a leading space without
    quoting (line 16).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a list of directory names called `dirs` (line 25-27), and we want to
    append them following this scheme to a string called `dirString` (line 28). To
    do this, we create an instance of `StringCat`, passing it a reference to `dirString`
    (line 31), and pass this to `boost:: make_function_output_iterator`, which returns
    an output iterator (line 30). We use `std::copy` to copy the elements from `dirs`
    into the output iterator returned, which has the effect of concatenating the strings
    by making repeated calls to the `StringCat` functor. When `std::copy` returns,
    `dirString` has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `personal docs`, which is the name of a single directory, is
    appropriately quoted.
  prefs: []
  type: TYPE_NORMAL
- en: There are other iterator adaptors besides the ones listed above that we did
    not cover here, including `boost::indirect_iterator`, `boost::function_input_iterator`,
    `boost::zip_iterator`, `boost::counting_iterator`, and `boost::permutation_iterator`.
    Use the documentation on the Boost website to familiarize yourself with the patterns
    of their uses, and explore how you can use them in your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator adaptors provide a set of common idioms from functional programming
    languages and libraries like Python's **itertools**. Iterator adaptors are particularly
    useful when you have APIs that take a pair of iterators but have no option to
    filter or adapt the elements via functors or predicates. Much of what iterator
    adaptors enable can also be achieved by using the more modern Boost Range Adaptors,
    perhaps with less verbose syntax. However, if your APIs expect iterators instead
    of ranges, then these iterator adaptors will be handy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating conforming iterators for custom classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to providing iterator adaptor templates, the Boost.Iterator library
    provides a framework for creating conforming iterators. In this section, we will
    use the Boost.Iterator library to create conforming iterators for a threaded binary
    search tree. A binary search tree is an abstract data type that stores elements
    in a tree structure. Loosely speaking, each node in the tree has zero, one, or
    two children. All elements in the left sub-tree of a node are smaller than the
    node, and all elements in the right sub-tree of a node are larger than the node.
    Nodes with zero children are called leaves. A threaded binary search tree is optimized
    for traversing its elements in a sorted order, the so-called **inorder traversal**.
  prefs: []
  type: TYPE_NORMAL
- en: We implement a naïve version of a threaded binary search tree, in which we will
    maintain pointers to the predecessor and successor of a node in each node. We
    will then provide a bidirectional iterator interface that will allow forward and
    reverse traversal of the tree in the order of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing 5.26: A naïve threaded binary search tree**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `BinarySearchTree` template in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This example helps us illustrate the techniques for creating custom iterators
    for a not too trivial data structure, using the Boost Iterator framework. The
    threaded tree implementation is made deliberately simple to aid understanding.
    `TreeNode<T>` represents each node in a tree containing values of a parameterized
    type `T`. `BinarySearchTree<T>` represents a binary search tree that supports
    inorder traversal. It stores three pointers of type `TreeNode<T>`: the root of
    the tree, the pointer `first` to the smallest element, and a sentinal pointer
    `last`, representing the end of the traversal (lines 68-70). Finally, `BSTIterator<T>`
    represents the type of a bidirectional iterator to `BinarySearchTree<T>`, one
    that allows inorder traversal through the elements of the tree in both directions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TreeNode<T>` stores two pointers to its `left` and `right` children and two
    more to its nodes that precede (`prev`) and follow (`next`) it in order of the
    values they store (lines 12-13). A new node is always inserted as a leaf node,
    and the `prev` and `next` pointers of the new node and the ones that precede and
    follow it in a traversal order are readjusted appropriately. New elements are
    inserted into the tree using the `insert` public method, and the actual logic
    for insertion is in the private overload of the `insert` method (lines 72-102).The
    `begin` and `end` methods of `BinarySearchTree` return iterators to the first
    element in the tree and another node, marking the end of traversal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BSTIterator` template, which is the iterator implementation that we are
    most interested in, derives from a specialization of `boost::iterator_facade`
    (lines 29-30). The specialization takes three arguments: `BSTIterator<T>` itself,
    the type parameter `T`, and a tag `boost::bidirectional_traversal_tag` to identify
    the type of traversal the iterator supports (bidirectional in this case). The
    base template taking the derived class as an argument is a well-known C++ idiom
    called **Curiously Recurring Template Parameter** and is used to achieve the effect
    of virtual method calls without the runtime cost of it. We now define a set of
    members to finish the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BSTIterator` template keeps a `TreeNode<T>` pointer to a node in the tree
    (line 40). This is initialized using a default constructor and the one that takes
    a node pointer (lines 33-35). Also, importantly, we must make `BSTIterator` copyable
    (lines 36-37). We define a set of private member functions, which are accessed
    by the Boost Iterator framework. The framework code accesses these functions via
    a class called `boost::iterator_core_access`, which is therefore defined as a
    `friend` class (line 42). The functions `increment` (line 44) and `decrement`
    (line 45) are called when we increment or decrement the iterator using `operator++`
    or `operator--`. They change the internal node pointer to point to the next or
    previous node in the traversal order (inorder). The function `dereference` is
    called when we dereference the iterator using `operator*`. It returns a reference
    to the data element stored in each node (line 51). The `equal` method is used
    to check whether two iterators are equal to each other. This is invoked when,
    for example, you check if an iterator has reached the end of the sequence of values
    in a container with code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to do to define a fully functional iterator. There is one
    additional bit of work that has to be done inside the container. We define the
    `begin` and `end` methods that return the start and end of the sequence of values
    in the container (lines 77-78). These pointers, `first` (line 89) and `last` (line
    90), are maintained as additional members and suitably updated by the `BinarySearchTree`
    template. The pointer `first` is updated each time a new smallest element is inserted
    into the container. The pointer `last`, which represents a sentinel beyond which
    the forward traversal can never proceed, is created initially and never updated
    (line 69). Each time a new largest element is added to the tree, its `next` pointer
    points to `last`. The const versions of `begin` and `end` member functions (lines
    80-85) are provided to ensure that calling them on a constant container give immutable
    iterators. Following essentially the same pattern, you can roll out your own iterators
    for your containers that are compliant with the Standard Library's iterator concepts.
    A number of Standard Library algorithms may be used on your custom container via
    such an iterator interface. The concise implementation of the iterator (lines
    27-51) is made possible by the abstractions provided by the Boost Iterator framework.
  prefs: []
  type: TYPE_NORMAL
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For multiple choice questions, choose all the options that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are true for flat associative containers compared to
    ordered/unordered associative containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Require less memory
  prefs: []
  type: TYPE_NORMAL
- en: b. Insertion is faster
  prefs: []
  type: TYPE_NORMAL
- en: c. Traversal is slower
  prefs: []
  type: TYPE_NORMAL
- en: d. Lookups are faster
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::forward_list` does not provide a `size()` member function because:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Linear time size members cannot be supported for singly-linked lists
  prefs: []
  type: TYPE_NORMAL
- en: b. Both splice and size members cannot be constant time
  prefs: []
  type: TYPE_NORMAL
- en: c. It would be thread-unsafe
  prefs: []
  type: TYPE_NORMAL
- en: d. All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Where is the internal memory of a `static_vector` allocated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Stack
  prefs: []
  type: TYPE_NORMAL
- en: b. Depends on where the static vector is created
  prefs: []
  type: TYPE_NORMAL
- en: c. Free store
  prefs: []
  type: TYPE_NORMAL
- en: d. Depends on the allocator used
  prefs: []
  type: TYPE_NORMAL
- en: In order to store objects of type X in an unordered container, which of the
    following must be defined/available for objects of type X?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Ordering relation
  prefs: []
  type: TYPE_NORMAL
- en: b. Hash function
  prefs: []
  type: TYPE_NORMAL
- en: c. Equality comparison
  prefs: []
  type: TYPE_NORMAL
- en: d. Copy constructor
  prefs: []
  type: TYPE_NORMAL
- en: Which data structure allows random access to its elements and supports iterators
    that are not invalidated upon insertion and erase of other elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `static_vector`
  prefs: []
  type: TYPE_NORMAL
- en: b. `unordered_map`
  prefs: []
  type: TYPE_NORMAL
- en: c. `stable_vector`
  prefs: []
  type: TYPE_NORMAL
- en: d. `circular_buffer`
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter laid out a wide array of Boost libraries that provide different
    kinds of containers or make it easier to work with them. We looked at several
    useful nonstandard containers that extend the Standard Library containers, looked
    at containers designed to store dynamically-allocated object pointers, saw some
    expressive ways of assigning elements to containers, learned about hash-based
    unordered containers, and learned different patterns of iterating over collections
    and enabling iteration for custom collections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our study of container libraries from
    Boost and focus on specialized containers that support efficient lookup of objects
    based on multiple criteria.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Avoid null-pointers in containers (if possible): [http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)'
  prefs: []
  type: TYPE_NORMAL
