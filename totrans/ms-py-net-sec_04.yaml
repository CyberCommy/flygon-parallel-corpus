- en: HTTP Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduces you to the HTTP protocol and covers how we can
    retrieve and manipulate web content using Python. We will also review the `urllib`
    standard library and `requests` package. `urllib2` is a Python module for fetching
    URLs. It offers a very simple interface, in the form of the `urlopen` function.
    The request package is a very useful tool if we want to make requests to API endpoints
    to streamline HTTP workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the HTTP Protocol and building HTTP clients in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `urllib` package to query a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `requests` package to query a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different authentication mechanisms and how they are implemented
    in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 4` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.)'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install Python distribution in your local machine and have
    some basic knowledge about the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP protocol and building HTTP clients in python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to introduce the HTTP protocol and how we can
    build HTTP clients with httplib. HTTP is an application-layer protocol that basically
    consists of two elements: a request made by the client, which requests from the
    server a specific resource specified by a URL, and a response, sent by the server,
    that supplies the resource that the client requested.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to  the HTTP Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP protocol is a stateless hyper-text data-transfer protocol that does
    not store the information exchanged between the client and server. This protocol
    defines the rules that clients, proxies, and servers must follow to exchange information.
  prefs: []
  type: TYPE_NORMAL
- en: Being a stateless protocol for storing information related to an HTTP transaction,
    it is necessary to resort to other techniques, such as cookies (values stored
    on the client side) or sessions (temporary memory spaces reserved to store information
    about one or more HTTP transactions on the server side).
  prefs: []
  type: TYPE_NORMAL
- en: The servers returns an HTTP code indicating the result of an operation requested
    by the client; in addition, headers can be used in the requests to include extra
    information in both requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol uses the sockets at the lowest level to establish a connection
    between the client and server. In Python, we have the possibility of using a module
    of a higher level that abstracts us from the operation of the sockets at a low
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Building an HTTP Client with httplib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides a series of modules to create an HTTP client. The modules that
    Python provides in the standard library are `httplib`, `urllib`, and `urllib2`.
    These modules have different capabilities among all of them, but they are useful
    for most of your web tests. We can also find `httplib` packages and requests that
    provide some improvements over the standard `httplib` module.
  prefs: []
  type: TYPE_NORMAL
- en: This module defines a class that implements the `HTTPConnection` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class accepts a host and a port as parameters. The host is required and
    the port is optional. An instance of this class represents a transaction with
    an HTTP server. It must be instantiated by passing a server identifier and an
    optional port number. If the port number is not specified, the port number of
    the server-identification string is extracted if it has the form host: port, otherwise
    the default HTTP port (80) is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `request_httplib.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Building an HTTP Client with urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use `urllib2` and how we can build HTTP
    clients with that module.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`urllib2` can read data from a URL using various protocols, such as HTTP, HTTPS,
    FTP, or Gopher. This module provides `urlopen` function used to create an object
    similar to a file with which can to read from the URL. This object has methods
    such as `read()`, `readline()`, `readlines()`, and `close()`, which work exactly
    the same as in the file objects, although in reality we are working with a wrapper
    that abstracts us from using a socket at low level.'
  prefs: []
  type: TYPE_NORMAL
- en: The `read` method, as you will remember, is used to read the complete "file"
    or the number of bytes specified as a parameter, readline to read a line, and
    readlines to read all the lines and return a list with them.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a couple of `geturl` methods, to get the URL of the one we are
    reading (which can be useful to check whether there was a redirection) and info
    that returns an object with the server response headers (which can also be accessed
    through the headers attribute).
  prefs: []
  type: TYPE_NORMAL
- en: In the next example we open a web page using `urlopen()`. When we pass a URL
    to the `urlopen()` method, it will return an object, we can use the `read()` attribute
    to get the data from this object in a string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `urllib2_basic.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When working with `urllib2` module, also we need manage errors and exception
    type `URLError`.  If we work with HTTP, we can also find errors in the subclass
    of `URLError` `HTTPError`, which are thrown when the server returns an HTTP error
    code, such as 404 error when the resource is not found.
  prefs: []
  type: TYPE_NORMAL
- en: The `urlopen` function has an optional data parameter with which to send information
    to HTTP addresses using POST (parameters are sent in the request itself), for
    example to respond to a form. This parameter is a properly-encoded string, following
    the format used in the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Response objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore the response object in detail. We can see in the previous example
    that `urlopen ()` returns an instance of the `http.client.HTTPResponse` class.
    The response object returns information about the requested resource data, and
    the properties and metadata of the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code makes a simple request with urllib2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `read()` method allows us to read the requested resource data and return
    the specified number of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can read the status code of a response using its **status** property. The
    value of 200 is an HTTP status code that tells us that the request is OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Status codes are classified into the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**100:** Informational'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**200:** Success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**300:** Redirection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400:** Client error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500:** Server error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking HTTP headers with urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP requests consist of two main parts: headers and a body. Headers are the
    lines of information that contain specific metadata about the response that tells
    the client how to interpret it. With this module we can check whether the headers
    can provide information about the web server.'
  prefs: []
  type: TYPE_NORMAL
- en: The `http_response.headers` statement provides the header of the web server.
    Before we access this property, we need to check whether the code response is
    equal to `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `urllib_headers_basic.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the script executing for the python.org
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3bff218f-4c01-4cae-8d3d-815f784da3ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can get details on headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8da41655-5f6d-4a6f-bdda-0625c41acb8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to retrieve response headers is by using the `info()` method from
    the response object, which will return a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89591d31-8be7-41e9-8a6b-043834987c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the `**keys()**`method to get all the response header keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using the urllib2 Request class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `urlopen` function of `urllib2` can also take a Request object as a parameter,
    instead of the URL and the data to send. The Request class defines objects that
    encapsulate all the information related to a request. Through this object, we
    can make more complex requests, adding our own headers, such as the User-Agent.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest constructor for the Request object only takes one string as an
    argument, indicating the URL to connect to, so using this object as a parameter
    of urlopen would be equivalent to using a string with the URL directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Request constructor also has as optional parameters a data string
    for sending data by POST and a dictionary of headers.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing requests with urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can customize a request to retrieve a specific version of a website. For
    this task, we can use the Accept-Language header, which tells the server our preferred
    language for the resource it returns.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to see how to add our own headers using the User-Agent
    header. User-Agent is a header used to identify the browser and operating system
    that we are using to connect to that URL. By default, urllib2 is identified as
    "Python-urllib / 2.5";  if we wanted to identify ourselves, for example, as a
    Chrome browser, we could redifine the headers parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create the same GET request using the Request class by
    passing as parameter a custom HTTP User-Agent header:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`urllib_requests_headers.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the Request class of the `urllib` module, it is possible to create custom
    headers, for this it is necessary to define in the headers argument a header dictionary
    with the key and value format. In the previous example, we set the agent header
    configuration and assign it the Chrome value and supplied the headers as a dictionary
    to the Request constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting emails from a URL with urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example we can see how extract emails using urllib2 and regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`get_emails_from_url.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this screen capture, we can see the script in execution for the packtpub.com
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44ec2eea-dcbe-4720-bd07-2d0de1bdd9dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting links from a URL with urllib2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this script, we can see how to extract links using `urllib2` and `HTMLParser`.
    `HTMLParser` is a module that allows us to parse text files formatted in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information at [https://docs.python.org/2/library/htmlparser.html](https://docs.python.org/2/library/htmlparser.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`get_links_from_url.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the script in execution for the python.org
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/276cc13e-834b-4a2a-bedf-942e292279d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Building an HTTP Client with requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to interact with RESTful APIs based on HTTP is an increasingly common
    task in projects in any programming language. In Python, we also have the option
    of interacting with a REST API in a simple way with the `Requests` module. In
    this section, we review the different ways in which we can interact with an HTTP-based
    API using the `Python Requests` package.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best options within the Python ecosystem for making HTTP requests
    is a library of third-party requests. You can install the requests library in
    your system in a easy way with `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This module is available on the PyPi repository as the `requests` package. It
    can either be installed through Pip or downloaded from [http://docs.python-requests.org](http://docs.python-requests.org),
    which hosts the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To test the library in our script, you just have to import it like the other
    modules. Basically, request is a wrapper of `urllib2` along with other Python
    modules to provide us with simple methods with the REST structure, because we
    have the "post," "get," "put," "patch," "delete," "head," and "options" methods,
    which are all the necessary methods to communicate with a RESTful API without
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module has a very simple form of implementation, for example, a `GET`
    query using requests would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, the requests.get method is returning a "response" object;
    in this object you will find all the information corresponding to the response
    of our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main properties of the response object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**response.status_code**: This is the HTTP code returned by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**response.content**: Here we will find the content of the server response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**response.json()**: In the case that the answer is a JSON, this method serializes
    the string and returns a dictionary structure with the corresponding JSON structure.
    In the case of not receiving a JSON for each response, the method triggers a exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this script, we can also view the request properties through the response
    object in the python.org domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the  **`requests_headers.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following screen capture, we can see the script in execution for the
    python.org domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last line of the execution, we can highlight the presence of **python-requests**
    in the U**ser-Agent** header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93c9b235-8b16-44cd-b09d-2aeb8299b1ae.png)'
  prefs: []
  type: TYPE_IMG
- en: In a similar way, we can obtain only `keys()` from the object response dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`requests_headers_keys.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Requests advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Among the main advantages of the `requests` module, we can notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Library focused on the creation of fully-functional HTTP clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports all methods and features defined in the HTTP protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is "Pythonic," that is, it is completely written in Python and all operations
    are done in a simple way and with just a few lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks such as integration with web services, the pooling of HTTP connections,
    coding of POST data in forms, and handling of cookies. All these feature are handled
    automatically using Requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making GET Requests with the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For testing requests with this module, we can use the [http://httpbin.org](http://httpbin.org)
    service and try these requests, executing each type separately. In all cases,
    the code to execute to get the desired output will be the same, the only thing
    that will change will be the type of request and the data that is sent to the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36067bfe-7767-42c3-9d83-1dfe4f7538b4.png)'
  prefs: []
  type: TYPE_IMG
- en: '[http://httpbin.org](http://httpbin.org) [offers a service that lets you test
    REST requests through predefined endpoints using the get, post, patch, put, and
    delete methods.](http://httpbin.org)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `testing_api_rest_get_method.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code, you should see the following output with the
    headers obtained for request and response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6a89921-2970-40b9-9434-a6c6a7ab02af.png)'
  prefs: []
  type: TYPE_IMG
- en: Making POST Requests with the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the GET method that sends the data in the URL, the POST method allows
    us to send data to the server in the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we have a service to register a user to whom you must pass
    an ID and email. This information would be passed through the data attribute through
    a dictionary structure.The post method requires an extra field called "data,"
    in which we send a dictionary with all the elements that we will send to the server
    through the corresponding method.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to simulate the sending of an HTML form through
    a POST request, just like browsers do when we send a form to a website. Form data
    is always sent in a key-value dictionary format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The POST method is available in the [http://httpbin.org/post](http://httpbin.org/post)
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cc80100-be73-4344-9850-b8124eb1d97e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following code we define a data dictionary that we are using with post
    method for passing data in the body request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are cases where the server requires that the request contains headers
    indicating that we are communicating with the JSON format; for those cases, we
    can add our own headers or modify existing ones with the **"headers"** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, in addition to using the POST method, you must pass the data
    that you want to send to the server as a parameter in the data attribute. In the
    answer, we see how the ID is being sent in the form object.
  prefs: []
  type: TYPE_NORMAL
- en: Making Proxy Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting feature offered by the `requests` module is the possibility to
    make requests through a proxy or intermediate machine between our internal network
    and the external network.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy is defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a request through a proxy, the proxies attribute of the get method
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The proxy parameter must be passed in the form of a dictionary, that is, you
    have to create a dictionary type where we specify the protocol with the IP address
    and the port where the proxy is listening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Managing exceptions with requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Errors in requests are handled differently from other modules. The following
    example generates a 404 error indicating that it cannot find the requested resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `requests` module returns a 404 error. To see the **exception**
    generated internally, we can use the`raise_for_status ()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event of making a request to a host that does not exist, and once the
    timeout has been produced, we get a `ConnectionError` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this screen capture, we can see the execution of the previous commands in
    Python idle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f4f5df0-2856-4f83-8f5d-ec1217064cd3.png)'
  prefs: []
  type: TYPE_IMG
- en: The request library makes it easier to use HTTP requests in Python compared
    to urllib. Unless you have a requirement to use urllib, I would always recommend
    using Requests for your projects in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication mechanisms with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authentication mechanisms supported natively in the HTTP protocol are **HTTP
    Basic** and **HTTP Digest**. Both mechanisms are supported in Python through the
    requests library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP Basic authentication mechanism is based on forms and uses Base64 to
    encode the user composed with the password separated by a "colon" (user: password).'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Digest authentication mechanism uses MD5 to encrypt user, key, and
    realm hashes. The main difference between both methods is that the Basic only
    encodes, without actually encrypting, while the Digest encrypts the user's information
    in the MD5 format.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with the requests module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `requests` module, we can connect with servers that support Basic and
    Digest authentication. With basic authentication, the information about the user
    and password is sent in `base64` format, and with digest the information about
    the user and password is sent in hash with the `md5` or `sha1` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP Basic is a simple mechanism that allows you to implement basic authentication
    over HTTP resources. The main advantage is the ease of implementing it in Apache
    web servers, using standard Apache directives and the httpasswd utility.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this mechanism is that it is relatively simple with a Wireshark
    sniffer to obtain the user's credentials since the information in sent in plain
    text; for an attacker, it would be enough to decode the information in Base64
    format. If the client knows that a resource is protected with this mechanism,
    you can send the login and password in the Authorization header with Base64 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic-access authentication assumes that the client will be identified by a
    username and a password. When the browser client initially accesses a site using
    this system, the server replies with a response of type 401, which contains the
    "**WWW-Authenticate**" tag, with the "Basic" value and the name of the protected
    domain (such as WWW-Authenticate: Basic realm = "www.domainProtected.com").'
  prefs: []
  type: TYPE_NORMAL
- en: 'The browser responds to the server with an "Authorization" tag, which contains
    the "Basic" value and the concatenation in base64 encoding of the login, the colon
    punctuation mark (":"), and the password (for example, Authorization : Basic b3dhc3A6cGFzc3dvcmQ
    =).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have a URL protected with this type of authentication, in
    Python with the `requests` module, it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can use this script to test the access to a protected resource with **basic
    authentication. **In this example, we apply a **brute-force process** to obtain
    the user and password credentials over the protected resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `BasicAuthRequests.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Digest Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP Digest is a mechanism used to improve the basic authentication process
    in the HTTP protocol. MD5 is normally used to encrypt user information, key, and
    realm, although other algorithms, such as SHA, can also be used in its different
    variants, which improve the security. It is implemented in Apache web servers
    with the `mod_auth_digest` module and the `htdigest` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process that a client must follow to send a response that results in access
    to a protected resource is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hash1= MD5(“user:realm:password”)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hash2 = MD5(“HTTP-Method-URI”)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response = MD5(Hash1:Nonce:Hash2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digest-based access authentication extends basic-access authentication by using
    a one-way hashing cryptographic algorithm (MD5) to first encrypt authentication
    information, and then add a unique connection value.
  prefs: []
  type: TYPE_NORMAL
- en: This value is used by the client browser in the process of calculating the password
    response in the hash format. Although the password is obfuscated by the use of
    a cryptographic hash and the use of the unique value prevents the threat of a
    replay attack, the login name is sent in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have a URL protected with this type of authentication, in Python
    it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can use this script to test the access to a protected-resource **digest authentication. **In
    this example, we apply a brute-force process to obtain the user and password credentials
    over the protected resource. The script is similar to the previous one with basic
    authentication. The main difference is the part where we send the username and
    password  over the protectedResource URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `DigestAuthRequests.py`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the `httplib` and `urllib` modules, and requests
    for building HTTP clients. The `requests` module is a very useful tool if we want
    to consume API endpoints from our Python application. In the last section, we
    reviewed the main authentication mechanisms and how to implement them with the
    `request` module.At this point, I would like to emphasize that it is very important
    to always read the official documentation of all the tools with which we work,
    since that is where you can resolve more specific questions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter](40fd3a5e-4f71-4067-a0ce-6f0ba212af70.xhtml), we will explore
    network programming packages in Python to analyze network traffic using the `pcapy`
    and `scapy` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which module is the easiest to use since it is designed to facilitate requests
    to a REST API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a POST request made by passing a dictionary-type data structure that
    would be sent in the body of the request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the correct way to make a POST request through a proxy server and modify
    the information of the headers at the same time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What data structure is necessary to mount if we need to send a request with
    requests through a proxy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we obtain the code of an HTTP request returned by the server if in the
    response object we have the response of the server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With which module can we indicate the number of connections that we are going
    to reserve using the PoolManager class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module of the requests library offers the possibility of performing Digest-type
    authentication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What coding system does the Basic authentication mechanism use to send the username
    and password?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which mechanism is used to improve the basic authentication process by using
    a one-way hashing cryptographic algorithm (MD5)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which header is used to identify the browser and operating system that we are
    using to send requests to a URL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the mentioned tools and
    the official Python documentation for some of the commented modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/httplib.html](https://docs.python.org/2/library/httplib.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/urllib2.html](https://docs.python.org/2/library/urllib2.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://urllib3.readthedocs.io/en/latest/](http://urllib3.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/htmlparser.html](https://docs.python.org/2/library/htmlparser.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.python-requests.org/en/latest](http://docs.python-requests.org/en/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
