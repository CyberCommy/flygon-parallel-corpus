- en: Introduction to Building C++ Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages differ by their program execution model; the most common
    are interpreted and compiled languages. Compilers translate source code into machine
    code, which a computer can run without intermediary support systems. Interpreted
    language code, on the other hand, requires support systems, interpreters, and
    the virtual environment to work.
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a compiled language, which makes programs run faster than their interpreted
    counterparts. While C++ programs should be compiled for each platform, interpreted
    programs can operate cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss the details of a program-building process, starting
    with the phases of processing the source code – done by the compiler- and ending
    with the details of the executable file (the compiler's output). We will also
    learn why a program built for one platform won't run on another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to C++20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of the C++ preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood of the source code compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the linker and its functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of loading and running an executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the option `-std=c++2a` is used to compile the examples
    throughout the chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ has evolved over the years and now it has a brand-new version, C++20\. Since
    C++11, the C++ standard has grown the language feature set tremendously. Let's
    look at notable features in the new C++20 standard.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concepts are a major feature in C++20 that provides a set of requirements for
    types. The basic idea behind concepts is the compile-time validation of template
    arguments. For example, to specify that the template argument must have a default
    constructor, we use the `default_constructible` concept in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we missed the `typename` keyword. Instead, we set a concept
    that describes the `T` parameter of the `template` function.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that concepts are types that describe other types – meta-types, so
    to speak. They allow the compile-time validation of template parameters along
    with a function invocation based on type properties. We will discuss concepts
    in detail in [Chapter 3](c0982ed5-7e38-4bd3-9c4d-37b0d2f01691.xhtml), *Details
    of Object-Oriented Programming*, and [Chapter 4](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml),
    *Understanding and Designing Templates*.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coroutines are special functions able to stop at any defined point of execution
    and resume later. Coroutines extend the language with the following new keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`co_await` suspends the execution of the coroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`co_yield` suspends the execution of the coroutine while also returning a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`co_return` is similar to the regular `return` keyword; it finishes the coroutine
    and returns a value. Take a look at the following classic example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A coroutine is associated with a `promise` object. The `promise` object stores
    and alerts the *state* of the coroutine. We will dive deeper into coroutines in
    [Chapter 8](fc8fb840-e179-4725-9e44-403b63be460d.xhtml), *Concurrency and Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ranges` library provides a new way of working with ranges of elements.
    To use them, you should include the `<ranges>` header file. Let''s look at `ranges`
    with an example. A range is a sequence of elements having a beginning and an end.
    It provides a `begin` iterator and an `end` sentinel. Consider the following vector
    of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges accompanied by range adapters (the `|` operator) provide powerful functionality
    to deal with a range of elements. For example, examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we filtered the range for even integers using `ranges::view::filter()`.
    Pay attention to the range adapter `|` applied to the elements vector. We will
    discuss ranges and their powerful features in [Chapter 7](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml), *Functional
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: More C++20 features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++20 is a new big release of the C++ language. It contains many features that
    make the language more complex and flexible. **Concepts**, **ranges**, and **coroutines**
    are some of the many features that will be discussed throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most anticipated features is **modules**, which provide the ability
    to declare modules and export types and values within those modules. You can consider
    modules an improved version of header files with the now redundant include-guards. We'll
    cover C++20 modules in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides notable features added in C++20, there is a list of other features
    that we will discuss throughout the book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The spaceship operator: `operator<=>()`. The verbosity of operator overloading
    can now be controlled by leveraging `operator<=>()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constexpr` conquers more and more space in the language. C++20 now has the `consteval`
    function, `constexpr std::vector` and `std::string`, and many more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math constants, such as `std::number::pi` and `std::number::log2e`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major updates to the Thread library, including stop tokens and joining threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator concepts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move-only views and other features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand some new features and also dive into the essence of the
    language, we will introduce the language's core starting from previous versions.
    This will help us to find better uses for new features compared to older ones,
    and will also help in supporting legacy C++ code. Let's now start by gaining an
    understanding of the C++ application building-process.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use any text editor to write code, because, ultimately, code is just
    text. To write code, you are free to choose between simple text editors such as
    *Vim*, or an advanced **integrated development environment** (**IDE**) such as
    *MS Visual Studio*. The only difference between a love letter and source code
    is that the latter might be interpreted by a special program called a **compiler**
    (while the love letter cannot be compiled into a program, it might give you butterflies
    in your stomach).
  prefs: []
  type: TYPE_NORMAL
- en: To mark the difference between a plain text file and source code, a special
    file extension is used. C++ operates with the `.cpp` and `.h` extensions (you
    may also occasionally encounter `.cxx` and `.hpp` as well). Before getting into
    the details, think of the compiler as a tool that translates the source code into
    a runnable program, known as an executable file or just an **executable**. The
    process of making an executable from the source code is called **compilation**.
    Compiling a C++ program is a sequence of complex tasks that results in machine
    code generation. **Machine code** is the native language of the computer— that's
    why it's called machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a C++ compiler parses and analyzes the source code, then generates
    intermediate code, optimizes it, and finally, generates machine code in a file
    called an **object file**. You may have already encountered object files; they
    have individual extensions – `.o` in Linux and `.obj` in Windows. The created
    object file contains more than just machine code that can be run by the computer.
    Compilation usually involves several source files, and compiling each source file
    produces a separate object file. These object files are then linked together by
    a tool called the **linker** to form a single executable file. The linker uses
    additional information stored in object files to link them properly (linking will
    be discussed later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts the program-building phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5d04f78-da90-4c83-88ac-d152f1e9d2b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The C++ application-building process consists of three major steps: **preprocessing**,
    **compiling**, and **linking**. All of these steps are done using different tools,
    but modern compilers encapsulate them in a single tool, thereby providing a single
    and more straightforward interface for programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: The generated executable file persists on the hard drive of the computer. In
    order to run it, it should be copied to the main memory, the RAM. The copying
    is done by another tool, named the **loader**. The loader is a part of the operating
    system that knows what and where should be copied from the contents of the executable
    file. After loading the executable file to the main memory, the original executable
    file won't be deleted from the hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: The loading and running of a program is done by the **operating system** (**OS**).
    The OS manages the execution of the program, prioritizes it over other programs,
    unloads it when it's done, and so on. The running copy of the program is called
    a **process**. A process is an instance of an executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding preprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **preprocessor** is intended to process source files to make them ready for
    compilation. A preprocessor works with preprocessor **directives**, such as `#define`, `#include`,
    and so on. Directives don''t represent program statements, but they are commands
    for the preprocessor, telling it what to do with the text of the source file.
    The compiler cannot recognize those directives, so whenever you use preprocessor
    directives in your code, the preprocessor resolves them accordingly before the
    actual compilation of the code begins. For example, the following code will be
    changed before the compiler starts to compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything that is defined using the `#define` directive is called a **macro**.
    After preprocessing, the compiler gets the transformed source in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As already mentioned, the preprocessor is just processing the text and does
    not care about language rules or its syntax. Using preprocessor directives, especially
    macro definitions, as in the previous example, `#define NUMBER 41` is error-prone,
    unless you realize that the preprocessor simply replaces any occurrence of `NUMBER` with `41`without
    interpreting `41` as an integer. For the preprocessor, the following lines are
    both valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the compiler starts compilation, it finds the assignment `t = 41` erroneous
    because there is `no viable conversion from 'int' to 'T'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even dangerous to use macros that are correct syntactically but have
    logical errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preprocessor will replace any occurrence of `DOUBLE_IT(arg)` with `(arg * arg)`,
    therefore the following code will output `16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will receive this code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Problems arise when we use complex expressions as a macro argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitively, this code will produce `25`, but the truth is that the preprocessor
    doesn''t do anything but text processing, and in this case, it replaces the macro
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This outputs `9`, and `9` is obviously not `25`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the macro definition, surround the macro argument with additional parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the expression will take this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is strongly suggested to use `const` declarations instead of macro definitions
    wherever applicable.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, avoid using macro definitions. Macros are error-prone and
    C++ provides a set of constructs that make the use of macros obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same preceding example would be type-checked and processed at compile time
    if we used a `constexpr` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `constexpr` specifier to make it possible to evaluate the return value
    of the function (or the value of a variable) at compile time. The example with
    the `NUMBER` definition would be better rewritten using a `const` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Header files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common use of the preprocessor is the `#include` directive, intended
    to include header files in the source code. Header files contain definitions for
    functions, classes, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose the header file `rect.h` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is contained in `rect.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preprocessor examines `main.cpp` and `rect.cpp`, it replaces the `#include` directives
    with corresponding contents of `iostream` and `rect.h` for `main.cpp` and `rect.h` for
    `rect.cpp`. C++17 introduces the `__has_include` preprocessor constant expression. `__has_include` evaluates
    to `1` if the file with the specified name is found and `0` if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring header files, it''s strongly advised to use so-called *include-guards*
    (`#ifndef, #define, #endif`) to avoid double declaration errors. We are going
    to introduce the technique shortly. Those are, again, preprocessor directives
    that allow us to avoid the following scenario: type `Square` is defined in `square*.*h`,
    which includes `rect.h` in order to derive `Square` from `Rect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Including both `square.h` and `rect.h` in `main.cpp` leads to including `rect.h`
    twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After preprocessing, the compiler will receive `main.cpp` in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will then produce an error because it encounters two declarations
    of type `Rect`. A header file should be guarded against multiple inclusions by
    using include-guards in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the preprocessor meets the header for the first time, `RECT_H` is not defined
    and everything between `#ifndef` and `#endif` will be processed accordingly, including
    the `RECT_H` definition. The second time the preprocessor includes the same header
    file in the same source file, it will omit the contents because `RECT_H` has already
    been defined.
  prefs: []
  type: TYPE_NORMAL
- en: These include-guards are part of directives that control the compilation of
    parts of the source file. All of the conditional compilation directives are `#if`, `#ifdef`, `#ifndef`, `#else`, `#elif`,
    and `#endif`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional compilation is useful in many cases; one of them is logging function
    calls in so-called **debug** mode. Before releasing the program, it is advised
    to debug your program and test against logical flaws. You might want to see what
    happens in the code after invoking a certain function, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each function calls the `log()` function, which is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `log()` function will print the `msg` if `DEBUG` is defined. If you compile
    the project enabling `DEBUG` (using compiler flags, such as `-D` in g++), then
    the `log()` function will print the string passed to it; otherwise, it will do
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules in C++20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules fix header files with annoying include-guard issues. We can now get
    rid of preprocessor macros. Modules incorporate two keywords, `import` and `export`.
    To use a module, we `import` it. To declare a module with its exported properties,
    we use `export`. Before listing the benefits of using modules, let''s look at
    a simple usage example. The following code declares a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line declares the module named `test`. Next, we declared the `twice()`
    function and set it to `export`. This means that we can have functions and other
    entities that are not exported, thus, they will be private outside of the module.
    By exporting an entity, we set it `public` to `module` users. To use `module`,
    we import it as done in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Modules are a long-awaited feature of C++ that provides better performance
    in terms of compilation and maintenance. The following features make modules better
    in the competition with regular header files:'
  prefs: []
  type: TYPE_NORMAL
- en: A module is imported only once, similar to precompiled headers supported by
    custom language implementations. This reduces the compile time drastically. Non-exported
    entities have no effect on the translation unit that imports the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules allow expressing the logical structure of code by allowing you to select
    which units should be exported and which should not. Modules can be bundled together
    into bigger modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting rid of workarounds such as include-guards, described earlier. We can
    import modules in any order. There are no more concerns for macro redefinitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules can be used together with header files. We can both import and include
    headers in the same file, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When creating modules, you are free to export entities in the interface file
    of the module and move the implementations to other files. The logic is the same
    as in managing `.h` and `.cpp` files.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ compilation process consists of several phases. Some of the phases
    are intended to analyze the source code, and others generate and optimize the
    target machine code. The following diagram shows the phases of compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f00317-dd05-467d-af51-d4c5a14858a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at each of these phases in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tokenization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The analysis phase of the compiler aims to split the source code into small
    units called tokens. A **token** may be a word or just a single symbol, such as
    `=` (the equals sign). A token is the *smallest unit* of the source code that
    carries meaningful value for the compiler. For example, the expression `int a
    = 42;` will be divided into the tokens `int`, `a`, `=`, `42`, and `;`. The expression
    isn''t just split by spaces, because the following expression is being split into
    the same tokens (though it is advisable not to forget the spaces between operands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The splitting of the source code into tokens is done using sophisticated methods
    using regular expressions. It is known as **l****exical analysis**, or **tokenization**
    (dividing into tokens). For compilers, using a tokenized input presents a better
    way to construct internal data structures used to analyze the syntax of the code.
    Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When speaking about programming language compilation, we usually differentiate
    two terms: syntax and semantics. The syntax is the structure of the code; it defines
    the rules by which tokens combined make structural sense. For example, *day nice*
    is a syntactically correct phrase in English because it doesn''t contain errors
    in either of the tokens. **Semantics**, on the other hand, concerns the actual
    meaning of the code. That is, *day nice* is semantically incorrect and should
    be corrected as *a nice day*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax analysis is a crucial part of source analysis, because tokens will be
    analyzed syntactically and semantically, that is, as to whether they bear any
    meaning that conforms to the general grammar rules. Take the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It may not make sense for us, because adding zero to the variable won''t change
    its value, but the compiler doesn''t look on logical meaning here—it looks for
    the *syntactic correctness* of the code (a missing semicolon, a missing closing
    parenthesis, and more). Checking the syntactic correctness of the code is done
    in the syntax analysis phase of compilation. The lexical analysis divides the
    code into tokens; **syntax analysis** checks for syntactic correctness, which
    means that the aforementioned expression will produce a syntax error if we have
    missed a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: g++ will complain with the `expected ';' at end of declaration` error.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the previous expression was something like `it b = a + 0; `, the compiler
    would divide it into the tokens `it`, `b`, `=`, and others. We already see that
    `it` is something unknown, but for the compiler, it is fine at this point. This
    would lead to the compilation error `unknown type name "it"` in g++. Finding the
    meaning behind expressions is the task of **semantic analysis **(parsing).
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all the analysis is completed, the compiler generates intermediate code
    that is a light version of C++ mostly C. A simple example would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After analyzing the code, *intermediate code* will be generated (this is an
    abstract example meant to show the idea of the intermediate code generation; compilers
    may differ in implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating intermediate code helps the compiler to make optimizations in the
    code. Compilers try to optimize code a lot. Optimizations are done in more than
    one pass. For example, take the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be optimized into this during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This again will be optimized into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Some programmers have no doubt that, nowadays, compilers code better than programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Machine code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiler optimizations are done in both intermediate code and generated machine
    code. So what is it like when we compile the project? Earlier in the chapter,
    when we discussed the preprocessing of the source code, we looked at a simple
    structure containing several source files, including two headers, `rect.h` and `square.h`,
    each with its `.cpp` files, and `main.cpp`*, *which contained the program entry
    point (the `main()` function). After the preprocessing, the following units are
    left as input for the compiler: `main.cpp`, `rect.cpp`, and `square.cpp`*, *as
    depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168390a7-7c88-4574-adb4-af6fce28f5ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The compiler will compile each separately. Compilation units, also known as
    source files, are *independent* of each other in some way. When the compiler compiles
    `main.cpp`, which has a call to the `get_area()` function in `Rect`, it does not
    include the `get_area()` implementation in `main.cpp`. Instead, it is just sure
    that the function is implemented somewhere in the project. When the compiler gets
    to `rect*.*cpp`, it does not know that the `get_area()` function is used somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the compiler gets after `main.cpp` passes the preprocessing phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After analyzing `main.cpp`, the compiler generates the following intermediate
    code (many details are omitted to simply express the idea behind compilation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will remove the `Square` struct with its constructor function (we
    named it `_Square_init_`) while optimizing the code because it was never used
    in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the compiler operates with `main.cpp` only, so it sees that we
    called the `_Rect_init_` and `_Rect_get_area_` functions but did not provide their
    implementation in the same file. However, as we did provide their declarations
    beforehand, the compiler trusts us and believes that those functions are implemented
    in other compilation units. Based on this trust and the minimum information regarding
    the function signature (its return type, name, and the number and types of its
    parameters), the compiler generates an object file that contains the working code
    in `main.cpp` and somehow marks the functions that have no implementation but
    are trusted to be resolved later. The resolving is done by the linker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have the simplified variant of the generated object
    file, which contains two sections—code and information. The code section has addresses
    for each instruction (the hexadecimal values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the `information` section. The compiler marks all the functions
    used in the code section that were not found in the same compilation unit with
    `????`. These question marks will be replaced by the actual addresses of the functions
    found in other units by the linker. Finishing with `main.cpp`, the compiler starts
    to compile the `rect.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same logic here, the compilation of this unit produces the following
    output (don''t forget, we''re still providing abstract examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This output has all the addresses of the functions in it, so there is no need
    to wait for some functions to be resolved later.
  prefs: []
  type: TYPE_NORMAL
- en: Platforms and object files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The abstract output that we just saw is somewhat similar to the actual object
    file structure that the compiler produces after the compilation of a unit. The
    structure of an object file depends on the platform; for example, in *Linux,*
    it is represented in *ELF* format (*ELF* stands for *Executable and Linkable Format*).
    A **platform** is an environment in which a program is executed. In this context,
    by platform, we mean the combination of the computer architecture (more specifically,
    the *instruction set architecture*) and operating system. Hardware and operating
    systems are designed and created by different teams and companies. Each of them
    has different solutions to design problems, which leads to major differences between
    platforms. Platforms differ in many ways, and those differences are projected
    onto the executable file format and structure as well. For example, the executable
    file format in Windows systems is **Portable Executable** (**PE**), which has
    a different structure, number, and sequence of sections than the ELF format in
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: An object file is divided into **sections**. Most important for us are the code
    sections (marked as `.text`) and the data section (`.data`). The` .text` section
    holds the program instructions and the `.data` section holds the data used by
    instructions. Data itself may be split into several sections, such as *initialized*,
    *uninitialized*, and *read-only* data.
  prefs: []
  type: TYPE_NORMAL
- en: An important part of the object files in addition to the `.text` and `.data`
    sections is the **symbol table**. The symbol table stores the mappings of strings
    (symbols) to locations in the object file. In the preceding example, the compiler-generated
    output had two portions, the second portion of which was marked as `information:`,
    which holds the names of the functions used in the code and their relative addresses.
    This `information:` is the abstract version of the actual symbol table of the
    object file. The symbol table holds both symbols defined in the code and symbols
    used in the code that need to be resolved. This information is then used by the
    linker in order to link the object files together to form the final executable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler outputs an object file for each compilation unit. In the previous
    example, we had three `.cpp` files and the compiler produced three object files.
    The task of the linker is to combine these object files together into a single
    object file. Combining files together results in relative address changes; for
    example, if the linker puts the `rect.o` file after `main.o`, the starting address
    of `rect.o` becomes `0x04` instead of the previous value of `0x00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The linker correspondingly updates the symbol table addresses (the `information:`
    section in our example). As mentioned previously, each object file has its symbol
    table, which maps the string name of the symbol to its relative location (address)
    in the file. The next step of linking is to resolve all the unresolved symbols
    in the object file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the linker has combined `main.o` and `rect.o` together, it knows the
    relative location of unresolved symbols because they are now located in the same
    file. The `printf` symbol will be resolved the same way, except this time it will
    link the object files with the standard library. After all the object files are
    combined together (we omitted the linking of `square.o` for brevity), all addresses
    are updated, and all the symbols are resolved, the linker outputs the one final
    object file that can be executed by the operating system. As discussed earlier
    in the chapter, the OS uses a tool called the loader to load the contents of the
    executable file into the memory.
  prefs: []
  type: TYPE_NORMAL
- en: Linking libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A library is similar to an executable file, with one major difference: it does
    not have a `main()` function, which means that it cannot be invoked as a regular
    program. Libraries are used to combine code that might be reused with more than
    one program. You already linked your programs with the standard library by including
    the `<iostream>` header, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries can be linked with the executable file either as **static** or **dynamic**
    libraries. When you link them as a static library, they become a part of the final
    executable file. A dynamically linked library should also be loaded into memory
    by the OS to provide your program with the ability to call its functions. Let''s
    suppose we want to find the square root of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ standard library provides the `sqrt()` function, which returns the
    square root of its argument. If you compile the preceding example, it will produce
    an error insisting that the `sqrt` function has not been declared. We know that
    to use the standard library function, we should include the corresponding `<cmath>` header.
    But the header file does not contain the implementation of the function; it just
    declares the function (in the `std` namespace), which is then included in our
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The compiler marks the address of the `sqrt` symbol as unknown, and the linker
    should resolve it in the linking stage. The linker will fail to resolve it if
    the source file is not linked with the standard library implementation (the object
    file containing the library functions).
  prefs: []
  type: TYPE_NORMAL
- en: The final executable file generated by the linker will consist of both our program
    and the standard library if the linking was static. On the other hand, if the
    linking is dynamic, the linker marks the `sqrt` symbol to be found at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we run the program, the loader also loads the library that was dynamically
    linked to our program. It loads the contents of the standard library into the
    memory as well and then resolves the actual location of the `sqrt()` function
    in memory. The same library that is already loaded into the memory can be used
    by other programs as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on a few of the many new features of C++20 and are
    now ready to dive deeper into the language. We discussed the process of building
    a C++ application and its compilation phases. This includes analyzing the code
    to detect syntactical and grammatical errors, generating intermediate code to
    make optimizations, and finally, generating the object file that will be linked
    together with other generated object files to form the final executable file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about C++ data types, arrays, and pointers.
    We will also gain an understanding of what pointers are and look at low-level
    details of conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a compiler and an interpreter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the program compilation phases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the preprocessor do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the tasks of the linker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between statically and dynamically linked libraries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information, refer to *A**dvanced C and C++ Compiling* at [https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/](https://www.amazon.com/Advanced-C-Compiling-Milan-Stevanovic/dp/1430266678/)
  prefs: []
  type: TYPE_NORMAL
- en: LLVM Essentials, https://www.packtpub.com/application-development/llvm-essentials
  prefs: []
  type: TYPE_NORMAL
