- en: Creating User Logins and API Authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last two chapters, we started working on session and **JSON Web Token**
    (**JWT**) authentication in Nuxt apps. We used sessions for authentication in
    [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding a Vuex Store*,
    to exercise `nuxtServerInit`. Then we used sessions and tokens together for authentication
    in [Chapter 11](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml), *Writing Route Middlewares
    and Server Middleware*s, to exercise per-route middleware, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: They may seem overwhelming if you are new to web authentication but fear not.
    In a nutshell, authentication is the process of verifying who you are. An authentication
    system allows you to access a resource when your credentials match the credentials
    in a database or a data authentication server. There are several authentication
    methods. Session-based and token-based authentication are the most common, or
    a combination of these two. So, let’s dive into them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating backend authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating frontend authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing in with Google OAuth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding session-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HyperText Transfer Protocol** (**HTTP**) is stateless. Hence, all HTTP requests
    are stateless. That means it does not remember anything or any user we have authenticated,
    and our application wouldn''t know whether it is the same person from the previous
    request. So, we would have to authenticate again on the next request. This is
    not ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: So, session-based and cookie-based authentication (usually referred to only
    as session-based authentication) were introduced to store user data between HTTP
    requests to put away the stateless nature of HTTP requests. They make the authentication
    process "stateful." That means an authenticated record or session is stored on
    both the server and client sides. The server can keep the active sessions in a
    database or the server memory, thus it is known as session-based authentication.
    The client can create a cookie to hold the session identifier (session ID), so
    it is known as cookie-based authentication.
  prefs: []
  type: TYPE_NORMAL
- en: But what are sessions and cookies anyway? Let's jump into them in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: What are sessions and cookies?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A session is a piece of temporary information interchanged between two or more
    communicating devices, or between a computer and user. It is established at a
    certain time and then expires at a future time. It also expires when the user
    closes the browser or when leaving a website. When a session is established, a
    file is created in a temporary directory (or in a database or the server memory)
    on the server to store the registered session values. This data is then available
    throughout the website during the visit, and the browser receives a session ID,
    which is to be sent back, either by a cookie or by the `GET` variable, to the
    server for validation.
  prefs: []
  type: TYPE_NORMAL
- en: In short, cookies and sessions are just data. Cookies are only stored on the
    client-side machine, while sessions get stored on the client as well as on the
    server. Sessions are considered more secure than cookies because the data can
    be kept solely on the server. Cookies are often created when the session is established
    and they are saved on the client computer. They can be the name, age, or ID of
    the authenticated user and they are sent back to the server by the browser to
    identify the user. Let's take a look at how they work in the next section with
    an example flow.
  prefs: []
  type: TYPE_NORMAL
- en: The session authentication flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Session-based and cookie-based authentication can be understood in the following
    example authentication flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The user sends their credentials, for example, username and password, from the
    client app on their browser to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server checks the credentials and sends a unique token (session ID) to the
    client. Also, this token will be saved in a database or memory on the server side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app stores the token in cookies on the client side and will use it
    in every HTTP request and send it back to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives the token and authenticates the user and then returns the
    requested data to the client application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app destroys the token when the user logs out. Before logging out,
    the client can also send a request to the server to remove the session, or the
    session will end by itself depending on the expiration time that has been set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In session-based authentication, the server does all the heavy lifting. It is
    stateful. It associates the session identifier with the user account (for example,
    in a database). The disadvantage of session-based authentication is the scalability
    when there is a large number of users using the system at the same time because
    sessions are stored in the server's memory, so it involves large memory usage.
    Also, cookies work great on a single domain or subdomains but are disabled by
    the browser normally on cross-domain sharing (cross-origin resource sharing).
    So, this causes an issue for the client when making API requests that are served
    from a different domain. But this issue can be overcome with token-based authentication,
    which we will walk through in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Token-based authentication is simpler. There are a few implementations of tokens,
    however, JSON Web Tokens is the most common one. Token-based authentication is
    stateless. That means no session is persisted on the server side because the state
    is stored inside the token on the client side. The responsibility of the server
    is only to create a JWT with a secret and send it to the client. The client stores
    the JWT in local storage, or a client-side cookie, and includes it in the header
    whenever making a request. The server then validates the JWT and sends a response.
  prefs: []
  type: TYPE_NORMAL
- en: But what is a JWT and how does it work? Let's find out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: What are JSON Web Tokens?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how a JWT works, we should understand what it is first. In short,
    a JWT is a string of a hashed JSON object composed of a header, a payload, and
    a signature. A JWT is generated with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The header typically consists of two parts: type and algorithm. The type is
    JWT, and the algorithm can be HMAC, SHA256, or RSA, which is a hashing algorithm
    that uses a secret key to sign the token, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The payload is the part where the information (or claims) is stored inside
    a JWT, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we only include two claims in the payload. You can put as many
    claims as you like. The more claims you include, the bigger the JWT size, which
    may affect performance. There are other optional claims, such as `iss` (issuer),
    `sub` (subject), and `exp` (expiration time).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more details about the JWT standard fields, please visit [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519).
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature is computed using the encoded header, the encoded payload, a
    secret, and the algorithm specified in the header. Whatever algorithm you choose
    in the header part, you must use that algorithm to encrypt the first two parts
    of the JWT: `base64(header) + ''.'' + base64(payload)`, for example, in this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is the only part of the JWT that is not publicly readable because
    it is encrypted with a secret key. Unless someone has the secret key, they cannot
    decrypt this information. So, the example output from the preceding pseudocode
    is three Base64-URL strings separated by dots that can be passed easily in HTTP
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at how this token authentication works in the next section,
    with an example flow.
  prefs: []
  type: TYPE_NORMAL
- en: The token authentication flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Token-based authentication can be understood with the following example authentication
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: The user sends their credentials, for example, username and password, from the
    client app on their browser to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server checks the username and password and returns a signed token (the
    JWT) if the credentials are correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This token is stored on the client side. It can be stored in local storage,
    session storage, or in a cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app generally includes this token as an additional header on any
    subsequent request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server receives and decodes the JWT and then allows request access if the
    token is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The token is destroyed on the client side when the user logs out and no further
    interaction with the server is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In token-based authentication, generally, you should not include any sensitive
    information in the payload and the token should not be kept over a long period.
    The additional header that you use to include the token should be in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Scalability in token-based authentication is not an issue because the token
    is stored on the client side. Cross-domain sharing is not an issue either because
    JWT is a string with all the necessary information, included in the request header,
    that is checked on each request made by the client to the server. In Node.js apps,
    we can use one of the Node.js modules, such as `jsonwebtoken`, to generate the
    token for us. Let's take a look at how we can use this Node.js module in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Node.js modules for JWT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned previously, `jsonwebtoken` can be used to generate JWTs on
    the server side. You can use this module synchronously or asynchronously in the
    following simplified steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `jsonwebtoken` via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Import and sign a token on the server side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Asynchronously verify the token coming from the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to find out more information about this module, please visit [https://github.com/brianloveswords/node-jws](https://github.com/brianloveswords/node-jws).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now you have a basic understanding of session-based and token-based authentication,
    we will guide you on how to apply them in server-side and client-side apps that
    use Koa and Nuxt. In this chapter, we will use token-based authentication to create
    two authentication options in our apps: local authentication and Google OAuth
    authentication. Local authentication is the option where we authenticate the user
    within our apps internally and locally, while Google OAuth authentication is the
    option where we authenticate the user using Google OAuth. So, let''s find out
    in the coming sections!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating backend authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous exercises in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding
    a Vuex Store*, and [Chapter 11](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml), *Writing
    Route Middlewares and Server Middlewares*, we used a dummy user for our backend
    authentication, particularly in `/chapter-11/nuxt-universal/route-middleware/per-route/`
    for per-route middlewares, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But in this chapter, we are going to use a database with some user data for
    authentication. Also, in [Chapter 9](232649f7-ae3b-43d7-a74e-55b481c4830c.xhtml),
    *Adding a Server-Side Database*, we used MongoDB as our database server. But this
    time, let's try a different database system for the sake of diversity – **MySQL**.
    So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL as the server database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be sure you have the MySQL server installed on your local machine. The latest
    MySQL version is 5.7 at the time of writing this book. Depending on what operating
    system you are using, you can find out the specific guidelines for your system
    at [https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/installing.html](https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/installing.html).
    If you are using Linux, you can find out the installation guide for your Linux
    distribution at [https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/linux-installation.html](https://dev.mysql.com/doc/mysql-installation-excerpt/5.7/en/linux-installation.html).
    If you are on Linux Ubuntu and using the APT repository, you can follow the guide
    at [https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/apt-repo-fresh-install](https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#apt-repo-fresh-install).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can install the MariaDB server instead of the MySQL server
    to use the **relational database management system** (**DBMS**) in your projects.
    Again, depending on what operating system you are using, you can find out the
    specific guidelines for your system at [https://mariadb.com/downloads/](https://mariadb.com/downloads/).
    If you are using Linux, you can find the guide for your specific Linux distribution
    at [https://downloads.mariadb.org/mariadb/repositories/](https://downloads.mariadb.org/mariadb/repositories/).
    If you are on Linux Ubuntu 19.10, you can follow the guide at [https://downloads.mariadb.org/mariadb/repositories/#distro=Ubuntu&distro_release=eoan--ubuntu_eoan&mirror=bme&version=10.4](https://downloads.mariadb.org/mariadb/repositories/#distro=Ubuntu&distro_release=eoan--ubuntu_eoan&mirror=bme&version=10.4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever you choose, it is convenient to have an administration tool to manage
    your MySQL databases from a browser. You can use phpMyAdmin or Adminer ([https://www.adminer.org/latest.php](https://www.adminer.org/latest.php));
    both require PHP installed on your machine. If you are new to PHP, you can use
    the installation guide in [Chapter 16](387f7a98-77fc-4480-8b75-664d73962901.xhtml),
    *Creating a Framework-Agnostic PHP API for Nuxt*. Adminer is preferred in this
    book. You can download the program at [https://www.phpmyadmin.net/downloads/](https://www.phpmyadmin.net/downloads/).
    If you want to use phpMyAdmin, please visit [https://www.phpmyadmin.net/](https://www.phpmyadmin.net/)
    to find out more. As soon as you have the administration tool, take the following
    steps to set up the database that we will need throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database, for example, "nuxt-auth", using Adminer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following table and sample data in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The user password in the preceding sample data is `123123` and is bcrypted as
    `$2a$10$pyMYtPfIvE.PAboF3cIx9.IsyW73voMIRxFINohzgeV0I2BxwnrEu`. We will install
    and use the `bcryptjs` Node.js module to hash and validate this password on the
    server side. But before jumping to `bcryptjs`, let's take a look at the structure
    for the app that we will create in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a copy of the database we have exported as `nuxt-auth.sql` in `/chapter-12/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring cross-domain app directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been making Nuxt apps for single domains. Our server-side APIs have
    been tightly coupled with Nuxt since [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*, in which we used Koa as the server-side framework and
    API for handling and serving data for the Nuxt apps. If you take a look back in `/chapter-8/nuxt-universal/koa-nuxt/`
    in our GitHub repository, you should remember we have kept our server-side programs
    and files in the `/server/` directory. We have also kept our package/module dependencies
    in one `package.json` file and installed them in the same `/node_modules/` directory.
    It can be confusing eventually, when our apps get larger, mixing the module dependencies
    for two frameworks (Nuxt and Koa) in the same `package.json` file. It can make
    the debugging process harder too. So separating our single app that's made of
    Nuxt and Koa (or any other server-side frameworks, such as Express) into two individual
    apps probably is better for scalability and maintenance. Now, it is time to make
    a cross-domain Nuxt app. We will reuse and restructure our Nuxt apps from [Chapter
    8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding a Server-Side Framework*.
    Let's call our Nuxt app a frontend app and the Koa app a backend app. We will
    add new modules separately in these two apps as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The backend app will do the backend authentication, while the frontend app
    will do the frontend authentication separately, but they will act as one eventually.
    And to make this learning and restructuring process easier for you, we will use
    JWT only for authentication. So, let''s create our new working directories in
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project directory and name it anything you like with two subdirectories
    in it. One is called `frontend` and the other is called `backend`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Nuxt app with the scaffolding tool, `create-nuxt-app`, in the `/frontend/`
    directory so you get the Nuxt directories that you are already familiar with,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `package.json` file, a `backpack.config.js` file, a `/static/` folder,
    and an `/src/` folder in the `/backend/` directory, followed by other files and
    subfolders (we will go through them in more detail in the upcoming section) in
    the `/src/` folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The backend directory is where our API is, which can be made using Express or
    Koa. We will still use Koa, which you are already familiar with. We will install
    server-side dependencies in this directory, such as `mysql`, `bcryptjs`, and `jsonwebtoken` so
    that they don't get mixed up with the frontend modules for the Nuxt app.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in this new structure, we managed to separate and decouple our
    API from the Nuxt app completely. There are benefits of this for debugging and
    development. Technically, we will now develop and test an app at a time. Developing
    two apps in a single environment can be confusing and it can be difficult to collaborate
    when the apps get larger – just as we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Before looking into how we can use JWT on the server side, let's first take
    a deeper look at how we can structure the API routes and modules in the `/src/`
    directory in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating API public/private routes and their modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that it is **not** mandatory to follow the directory structure suggested
    here in this book. There are no arbitrary or official rules for how we should
    structure our app with Koa. There are some skeletons, boilerplates, and frameworks
    contributed by the Koa community, which you can take a look at by visiting [https://github.com/koajs/koa/wiki](https://github.com/koajs/koa/wiki).
    Now let''s take a closer look at the directory structure in the `/src/` directory,
    where we will develop our API source code, in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following folders and empty `.js` files in the `/src/` directory
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `/src/` directory, the `/middlewares/` directory is where all middlewares
    are kept, such as `authenticate.js`, which we want to register with the Kao `app.use`
    method, while the `/modules/` directory is where all the groups of API endpoints
    are kept, such as `home`, `user`, and `login`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two main directories, `private` and `public`**,** with subdirectories
    in each of them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/public/` directory is used for public access without JWT, such as the login
    route, while the `/private/` directory is used for access that requires JWT to
    protect the modules. As you can see, we have separated API routes into two main
    groups, so the `/private/` group will be handled in `routes-private.js`, and the
    `/public/` group will be handled in `routes-public.js`. We have the `/config/` directory
    to keep all config files, and the `/core/` directory to keep the abstract programs
    or modules that can be shared and used throughout the app, such as the mysql connection
    pool that you will discover later in this chapter. So, from the preceding directory
    tree, we will use these public modules in our API: `home`, `user`, `login`, and
    one private module: `home`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In each module, for example, in the `user` module, create a `/_routes/` directory
    to configure all the routes (or endpoints) that belong to this particular module
    (or group):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `user`, module, the `/user/index.js` file is where all routes of this
    module are assembled and grouped in the module route, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The value of `/users` that is set to the `prefix` key is the module route for
    this user module. Inside each imported child route is where we develop our code,
    such as the code for the login route.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each `.js` file in each module, for example, in the `user` module, add the
    following basic code structure for building our code in the later stages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `home` module, which will return a response with a `''Hello
    World!''` message as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is only one route from the `home` module, but we still need to assemble
    this route in an `index.js` file in this module so that we can keep our code consistent
    with other modules, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no prefix added to this `home` module, so we can access its
    only route directly at `localhost:4000/public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `routes-public.js` file in the `/src/` directory and import all
    the public routes from the public modules in the `/modules/` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we imported the `home` module that we have just created in the
    previous steps. We will create the `user` and `login` modules in the coming sections.
    After importing these modules, we should register their routes to the router and
    then export the router. Notice that a prefix, `/public`, is added to these routes.
    Also, notice that every route is looped and registered to the router with the
    plain JavaScript `for` loop function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `routes-private.js` file in the `/src/` directory and import all
    the private routes from the private modules in the `/modules/` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this file, you can see that we will create a private `home` module only in
    the coming sections. Also, an `authenticate` middleware is imported in this file
    and added to the private route so that the private module can be protected.  After
    that, we should export the private route with the router and prefix it with `/private`.
    We will create this `authenticate` middleware in the coming section as well. For
    now, let's configure our module file paths with Backpack and install the essential
    Node.js modules that our API essentially depends on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following additional file paths (`./src`, `./src/core`, and `./src/modules`)
    to the webpack configuration through the Backpack config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With these additional file paths, we can import our module simply with `import
    pool from ''core/database/mysql''`, instead of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For more information about resolving modules by using the `modules` option in
    webpack, please visit [https://webpack.js.org/configuration/resolve/#resolvemodules](https://webpack.js.org/configuration/resolve/#resolvemodules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should install Backpack in our project, as well as the other basic and
    essential Node.js modules that we will need in order to develop this backend app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You should be familiar with these modules as you have learned about them and
    installed them in [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework, *which you can revisit in `/chapter-8/nuxt-universal/koa-nuxt/`
    in our GitHub repository, and also, in [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml),
    *Adding a Vuex Store*, in `/chapter-10/nuxt-universal/nuxtServerInit/`, and [Chapter
    11](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml), *Writing Route Middlewares and
    Server Middlewares*, in `/chapter-11/nuxt-universal/route-middleware/per-route/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following run scripts in `package.json` in the `/backend/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So, the `"dev"` run script is used for developing our API, the `"build"` run
    script is used for building our API when it is completed, and the `"start"` script
    is used for serving the API after it is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following server configuration to the `index.js` file in the `/config/`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This config file only has a very simple configuration, which is the server,
    configured to run at port `4000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the following modules that you have just installed and register them
    as middlewares in the `middlewares.js` file in the `/src/` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a middleware that handles the HTTP response with a `200` HTTP status
    in the `/middlewares/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following JSON output if the response is OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a middleware that handles an HTTP error status, such as `400`, `404`,
    and `500`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following JSON response for a `400` error response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a middleware that handles the HTTP 404 response specifically by throwing
    a `''Not found''` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following JSON output for an unknown route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Import these three middlewares into `middlewares.js` and register them to the
    Koa instance just like the other middlewares:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we arrange these middlewares in sequence – even though the `errorHandler` middleware
    is registered first, it is the last middleware that will be re-executed in the
    upstream cascading in Koa if there is an error in the HTTP response. The upstream
    cascading will stop at the `okOutput` middleware if the HTTP response status is
    `200`. Also, note that these middlewares must be registered after the `static`,
    `favicon`, and `bodyparser` middlewares, which must be called and served publicly
    first in the downstream cascading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the public and private routes from `routes-public.js` and `routes-private.js`
    and register them after the preceding middlewares as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Import Koa, all middlewares from the `middlewares.js` file, and the server
    configuration in the `index.js` file in the `/config/` directory, instantiate
    a Koa instance and pass it to the `middlewares.js` file, and then start the server
    with this Koa instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this API with `npm run dev` and you should see the app running on your
    browser at `localhost:4000`. You should get the following output on your browser
    when you are on `localhost:4000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because there is no route set on `/` anymore – we have prefixed all
    our routes with `/public` or `/private`. But if you navigate to `localhost:4000/public`,
    you will get the following JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the response from the `home` module we have just created in the preceding
    steps. Also, you should see that your favicon and assets are served correctly
    at `localhost:4000` – if you have placed any of them inside the `/static/` and
    `/assets/` directories, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can see your files in these two directories at `localhost:4000`. That is
    because the `static` and `favicon` middlewares are installed and registered to
    be executed first in the middleware stacks when the downstream cascading in Koa
    is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! Now you have the new working directories ready and a basic API running
    just like in [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*. Next, you will need to install the other server-side
    dependencies in the `/backend/` directory and start adding code to the routes
    in the public `user` and `login` modules and the private `home` module. Let's
    start with `bcryptjs` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the example app with the preceding structure in `/chapter-12/nuxt-universal/cross-domain/jwt/axios-module/backend/` in
    our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using the bcryptjs module for Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned before, `bcryptjs` is used to hash and validate passwords.
    Please take a look at the simplified steps for further advice on how to use this
    module in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the bcryptjs module via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Hash a password by adding `salt` with the password sent from the client in
    the request body (request), for example, during a new user creation in the `user`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that to speed up our authentication lesson in the chapter, we skip the
    process of creating a new user. But in a more complete CRUD, you can use this
    step to hash the password provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify a password by comparing the password sent from the client (request)
    with the one stored in the database, for example, during the login authentication
    process in the `login` module as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can find out how this step is applied in our backend app in `/chapter-12/nuxt-universal/cross-domain/jwt/axios-module/backend/src/modules/public/login/_routes/local.js` in
    our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: We will show you how to use `bcryptjs` to verify the incoming password from
    the client in the coming section. But before hashing and verifying the password
    from the client, first, we need to connect to our MySQL database in order to establish whether
    to inject the new user or query the existing ones. For that, we will need the
    next Node.js module in our app: mysql - a MySQL client. So let's move on to the
    next section to see how you can install and use it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find more information about this module and some asynchronous
    examples, please visit [https://github.com/dcodeIO/bcrypt.js](https://github.com/dcodeIO/bcrypt.js).
  prefs: []
  type: TYPE_NORMAL
- en: Using the mysql module for Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the MySQL server that we installed in the previous section. Now we
    will need a MySQL client that we can connect to the MySQL server and perform SQL
    queries from our server-side program. mysql is the standard MySQL Node.js module
    that implements the MySQL protocol, thus we can use this module for handling MySQL
    connection and SQL queries, whether you are on MySQL server or MariaDB server.
    So, let''s get it started in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `mysql` module via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the MySQL connection instance in a `mysql.js` file with your MySQL connection
    details in the subdirectories in the `/src/` directory as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the code we just created in the following notes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'mysql does not support `async/await`, so we wrapped MySQL''s `pool.query` with
    the `promisify` utility from Node.js. `pool.query` is the function from mysql
    that handles our SQL query and it returns the result in a callback, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With the promisify utility, we have eliminated the callback and now we can
    use `async/await` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`pool.query` is a shortcut function for these three functions, `pool.getConnection`,
    `connection.query`, and `connection.release`, that we should use together to perform
    a SQL query in the connection pooling in the mysql module. By using `pool.query`,
    the connection is automatically released back to the pool when you are done with
    it. This is the basic underlying structure of the `pool.query` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this mysql module, instead of creating and managing the MySQL connections
    one by one by using `mysql.createConnection`, which can be an expensive operation,
    we can use `mysql.createPool` for connection pooling, which is a cache of reusable
    database connections to reduce the cost of establishing fresh connections whenever
    we want to connect to the database. For more information about connection pooling,
    please visit [https://github.com/mysqljs/mysqlpooling-connections](https://github.com/mysqljs/mysql#pooling-connections).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we have abstracted the MySQL connection into the preceding file in the
    `/core/` directory. Now we can use it to fetch the list of users in the `user` module
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we use the samecode structure that we have laid out in the
    previous section to send our request to the MySQL server via the MySQL connection
    pool. In the query that we send, we tell the MySQL server to return only the fields
    of `id`, `name`, and `created_on` from the `users` table in the result for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you visit the user route at `localhost:4000/public/users`, you should get
    the following output on your screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the mysql module for connecting to the MySQL server and databases,
    and the bcryptjs module for hashing and verifying passwords from the client, so
    we can refactor and improve the login code that we created roughly in the previous
    chapter. Let's find out how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more information about the mysql module, please visit [https://github.com/mysqljs/mysql](https://github.com/mysqljs/mysql).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring login code on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have gathered all the essential ingredients in the previous sections, and
    as soon as we have the MySQL connection pool created, we can refactor and improve
    our login code from [Chapter 10](808b1fa6-d397-4c97-b45a-95de8238497a.xhtml), *Adding
    a Vuex Store*, and [Chapter 11](b24caa1b-6337-40ee-9c1a-c8586db1f3b2.xhtml), *Writing
    Route Middlewares and Server Middlewares*, in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import all the dependencies, such as `koa-router`, `jsonwebtoken`, `bcryptjs`,
    and the MySQL connection pool for the login route as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We imported the config file here for the configuration options of our API, which
    contains the MySQL database connection details, the options for the server and
    the static directory, and the secret code for the JWT that we will need later
    for signing a token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate the user inputs inside the `post` method for the login route to ensure
    they are defined and not empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the username and password to variables for querying the database when
    they pass the validation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the stored password and the password from the user with bcryptjs if
    there are results from the MySQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign a JWT and send it to the client if the user passes all the previous steps
    and validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the API with `npm run dev` and test the previous route manually with `curl`
    on your terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following result if you have logged in successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you will get a different token in the preceding response whenever
    it is signed successfully. Now you have managed to refactor and improve the login
    code. Next, we will look at how we can verify the preceding token, which will
    be sent back in the request header from the client side, in the next section.
    So, keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the incoming token on the server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully signed a token and returned it to the client when the credentials
    match what we have stored in the database. But that is only half of the story.
    We should verify this token each time the client makes a request with it, to access
    all protected routes guarded by the server-side middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create the middleware and the protected route in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a middleware file in the `/middlewares/` directory inside the `/src/` directory
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if` condition, `!ctx.headers.authorization`, is used to ensure that the
    client has included the token in the request headers. Since `authorization` comes
    in with the value in the format `Bearer: [token]`, which has a single space in
    it, we split the value by that space and only take `[token]` for verification
    in the `try` and `catch` blocks. If the token is valid, then we let the request
    through to the next route with `await next()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import and inject this middleware to the group of routes that we want to secure
    with JWT:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this API, we want to secure all routes that fall under the `/private` route.
    So we will import any routes that we want to secure in this file, for example,
    the preceding `/home` route. Therefore, when you request this route with `/private/home`,
    you must include the token in the request to headers to access this route.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. You have managed to create and verify the JWT on the server side.
    Next, we should look at how we can complete the JWT authentication with Nuxt on
    the client side in the next section. Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Creating frontend authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find this section easy and familiar because you have built a few authentication
    Nuxt apps with the dummy backend authentication in the previous two chapters.
    The difference in this chapter is that we are making cross-domain apps instead
    of single-domain apps like in the previous two chapters. You can revisit these
    single-domain Nuxt apps in `/chapter-10/nuxt-universal/nuxtServerInit/` and in
    `/chapter-11/nuxt-universal/route-middleware/per-route/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we will once again use the Nuxt modules that we already covered
    in [Chapter 6](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml), *Writing Plugins and
    Modules*: `@nuxtjs/axios` and `@nuxtjs/proxy`. You can revisit the Nuxt app that
    adopts these two modules in `/chapter-6/nuxt-universal/module-snippets/top-level/`.
    But for now, let''s get them installed and configured for this Nuxt app, which
    we will refactor from the previous chapters, to create the client-side authentication
    in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `@nuxtjs/axios` and `@nuxtjs/proxy` via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure these two modules in the Nuxt config file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since we know the remote API server that we created in the previous sections
    is running at `localhost:4000`, in this configuration, we assign this API address
    to the `/api/` key in the `proxy` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove any `import` statement that we used to import the axios Node.js module
    previously; for example, on the secured page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is because we are now using `@nuxtjs/axios` (the Nuxt Axios module) and
    we will not need to import the vanilla axios Node.js module directly in our code
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call the Nuxt Axios module by using `$axios` and replace `axios` (from the
    vanilla axios Node.js module), which we used previously in our code for HTTP requests;
    for example, on the secured page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The Nuxt Axios module is loaded to our Nuxt app via the Nuxt config file in
    *step 2*, so we can access it from the Nuxt context or `this` by using `$axios`.
  prefs: []
  type: TYPE_NORMAL
- en: We also should refactor the rest of the code in the store and middleware in
    this app with these two Nuxt modules – `@nuxtjs/axios` and `@nuxtjs/proxy`, and
    the cookies, Node.js modules (client- and server-side). So let's get to it in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using cookies on the (Nuxt) client side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this app, we no longer use sessions to "remember" the authenticated data.
    Instead, we will use the `js-cookie` Node.js module to create cookies to store
    the data from the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to use this Node.js module to create a cookie that presents
    across the entire site; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following format to set a cookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the code for if you want to create a cookie that expires 30 days from
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following format to read the cookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how easy it is using this Node.js module – all you need is the
    `set` and `get` methods to set and retrieve your cookies on the client side. So,
    let''s refactor the code in our store in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `if` ternary condition to import the js-cookie Node.js module when
    our Nuxt app is processed on the client side only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `set` function from js-cookie to store the data from the server as
    `auth` in the `login` action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `remove` function from js-cookie to delete the `auth` cookie in the
    `logout` action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very simple, isn''t it? But, you may ask: what do we use this `auth`
    cookie for, and how? Let''s find out in the next section on using cookies on the
    Nuxt server side.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information and code examples of the Node.js module, please visit [https://github.com/js-cookie/js-cookie](https://github.com/js-cookie/js-cookie).
  prefs: []
  type: TYPE_NORMAL
- en: Using cookies on the (Nuxt) server side
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since our authenticated data with JWT has been hashed and stored in a cookie
    by `js-cookie` as `auth`, we will need to read and parse this cookie whenever
    we need it. This is where the Node.js module, `cookie`, comes in. Again, we have
    used this Node.js module in past chapters but we haven't talked about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cookie Node.js module is an HTTP cookie parser and serializer for HTTP
    servers. It is used to parse the cookie header on the server side. Let''s take
    a look at how we can use it on the `auth` cookie in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `if` ternary condition to import the cookie Node.js module when our
    Nuxt app is processed on the server side only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `parse` function from the cookie Node.js module to parse the `auth`
    cookie in the HTTP request headers in the `nuxtServerInit` action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `setHeader` function from the Nuxt Axios module via `$axios` to include
    the token (JWT) in the HTTP header in the token middleware for accessing the private
    API routes on the remote server as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Run the Nuxt app with `npm run dev`. You should get the app running on your
    browser at `localhost:3000`. You can log in with credentials on the login page
    and then access the restricted secured page, which is protected by the JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done! You have completed the token-based local authentication. You have
    refactored the code in the store and middleware to get the `js-cookie` and `cookie`
    Node.js modules to work together and complement each other perfectly on the client
    and server sides in the Nuxt app for frontend authentication. Also, you have managed
    to decouple the Nuxt app from the API with the cross-domain approach.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using the `js-cookie` and `cookie` Node.js modules for frontend
    authentication is easy and great. But it also can be achieved with Google OAuth,
    which we will look into in the next section. Adding Google OAuth to the frontend
    authentication can give the user an extra option to log in to your app. So, let's
    get to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code of this Nuxt app in `/chapter-12/nuxt-universal/cross-domain/jwt/axios-module/frontend/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: For more information and code examples of the `cookie` Node.js module, please
    visit [https://github.com/jshttp/cookie](https://github.com/jshttp/cookie).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about helpers, such as the `setHeader` helper from the
    Nuxt Axios module, please visit [https://axios.nuxtjs.org/helpers](https://axios.nuxtjs.org/helpers).
  prefs: []
  type: TYPE_NORMAL
- en: Signing in with Google OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth is an open delegated authorization protocol that grants access between
    websites or apps without exposing user passwords to the parties that have been
    granted access. It is a very common access delegation used by many companies and
    websites to identify users with parties such as Google and Facebook that provide
    OAuth authorization. Let''s let our users log in to our app with Google OAuth.
    This option requires a client ID and a client secret from the Google Developer
    Console. They can be obtained with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in the Google Developer Console at [https://console.developers.google.com/](https://console.developers.google.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select External on the OAuth consent screen tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select OAuth client ID from the Create Credentials drop-down options on the
    Credentials tab, and then select Web application for the Application type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the name of your OAuth client ID in the Name field and the redirect
    URIs in the Authorized redirect URIs field for Google to redirect the user after
    authenticating on the Google consent page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the Google People API, which provides access to information about profiles
    and contacts in the API Library from the Library tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have a developer account set up and get the **client ID** and **client
    secret** created by following the previous steps, you are ready to add Google
    OAuth to the backend authentication in the next section. Let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Google OAuth to the backend authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For us to sign someone into Google, we need to send them to the Google Login
    page. From there, they will sign into their account and will be redirected to
    our app with their Google sign-in details, from which we will extract the Google
    code and send it back to Google to obtain the user data that we can use in our
    app. This process requires the `googleapis` Node.js module, which is a client
    library for using Google APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get it installed and adopted in our code with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `googleapis` Node.js module via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file with your credentials so Google knows who is making the requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note you must replace the preceding `<client ID>` and `<client secret>` values
    with the ID and secret that you obtain from the Google Developer Console. Also,
    note that the URL in the `redirect` option must match the redirect URIs in Authorized
    redirect URIs in your Google app API settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a Google authentication URL with Google OAuth for sending the user
    to the Google consent page to get permissions from the user to retrieve an access
    token as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Scopes determine what information and permissions we want from the user when
    they sign in and then generate the URL. In our case, we want permission to retrieve
    the information of the user email and profile: `userinfo.email` and `userinfo.profile`.
    After the user has authenticated on the Google consent page, Google will redirect
    the user back to our app with a bunch of authenticated data and an authorization
    code for accessing the user data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the value in the `code` parameter from the authenticated data appended
    by Google in the returned URL in the previous step. We will come back to the Node.js
    module, which can help us to extract the `code` parameter from the URL query later,
    in the next section. Now, let''s assume we have extracted the `code` value and
    sent it to the server side to request tokens with the Google OAuth2 instance in
    the following basic code structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain tokens from Google with the code we just extracted and pass them to
    Google People, `google.people`, to get the user data with the `get` method and
    specify what fields relating to the person need to be returned in the `personFields`
    query parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we want only two fields relating to the person from Google
    in our preceding code, which are `names` and `emailAddresses`. You can find out
    what other fields relating to the person you want from Google at [https://developers.google.com/people/api/rest/v1/people/get](https://developers.google.com/people/api/rest/v1/people/get).
    We should get the user data in the JSON format from Google if access is successful,
    and then we can extract the email from that data to ensure it will match a user
    in our database in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the first email only from the Google person data and query our database
    to see whether there is any user with that email already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Send a `''signup required''` message to the client side with the user data
    from Google if there is no user with that email and ask the user to sign up for
    an account in our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Sign a JWT with a payload and the JWT secret if there is a match, and then
    send the token (JWT) to the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: That's it. You have managed to add Google OAuth on the server side in the preceding
    few steps. Next, we should look at how we can complete the authentication with
    Nuxt on the client side for Google OAuth in the next section. Let's get going.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the googleapis Node.js module, please visit [https://github.com/googleapis/google-api-nodejs-client](https://github.com/googleapis/google-api-nodejs-client).
  prefs: []
  type: TYPE_NORMAL
- en: Creating frontend authentication for Google OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Google redirects the user back to our app, we will get a bunch of data
    on the redirect URL, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'It is quite difficult to read and decipher when you first look at it, but it
    is just a query string with parameters appended to our redirect URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a Node.js module, `query-string`, to parse the query string in the
    URL, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you will get the following JavaScript object in your browser''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `code` parameter is what we are interested in the most in the preceding redirect
    URL as we will need to send it to the server side as you learned in the previous
    section, in order to obtain the Google user data through the googleapis Node.js
    module. So, let''s get `query-string` installed and create the frontend authentication
    in our Nuxt app in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `query-string` Node.js module via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a button on the login page and bind a method called `loginWithGoogle`
    to dispatch the `getGoogleUrl` method in the store as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `/api/public/login/google/url` route in the API in the `getGoogleUrl`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `/api/public/login/google/url` route will send back a Google URL and then
    we can use it to redirect the user to the Google Login page. From there, the user
    will decide which Google account to log in to if they have more than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the query part from the returned URL and send it to the `loginWithGoogle`
    method in the store when Google redirects the user back to the login page as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the code from the `code` parameter in the preceding query part with
    `query-string` and send it to our API, `/api/public/login/google/me`, using `$axios`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: We will redirect the user to a sign-up page when we get the `'signup required'` message
    from the server. But if we get the message with JWT, then we can set a cookie
    and the authenticated data to the store state. We will leave the sign-up page
    to your imagination and own effort because it is a form to collect data from the
    user to be stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, run the Nuxt app with `npm run dev`. You should get the app running
    on your browser at `localhost:3000`. You can log in with Google and then access
    the restricted page, which is protected by the JWT – just like the local authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, there you go – these are the basic steps you take to sign the user in with
    the Google OAuth API. It is not hard at all, is it? We can also use the Nuxt Auth
    module to achieve almost the same as we have accomplished here. With this module,
    you can sign the user in with Auth0, Facebook, GitHub, Laravel Passport, and Google.
    If you are looking for quick, simple, and zero-boilerplate authentication support
    for Nuxt, it could be a good option for your project. For more information about
    this Nuxt module, please visit [https://auth.nuxtjs.org/](https://auth.nuxtjs.org/).
    Now let's summarize what you have learned in this chapter in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding login option with Google OAuth in `/chapter-12/nuxt-universal/cross-domain/jwt/axios-module/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the usage of the `query-string` Node.js module, visit
    [https://www.npmjs.com/package/query-string](https://www.npmjs.com/package/query-string).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! You have made it this far. After all, it is not difficult to work
    on web authentication. In this chapter, you have learned what session-based authentication
    and token-based authentication are, particularly about the JSON Web Token (JWT).
    You should now know the differences between them and the constituents of a JWT,
    and how to generate a JWT with the `jsonwebtoken` Node.js module. We have also
    covered the MySQL Node.js module and used it as part of our authentication system.
    You have also integrated Google OAuth for signing the user in and then creating
    the frontend authentication using Nuxt.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write end-to-end tests in your Nuxt
    apps. You will learn about the tools you can install and use for writing your
    end-to-end tests, notably AVA and Nightwatch. Besides this, you will also learn
    how to use a Node.js module, which is `jsdom`, to make your end-to-end testing
    possible on the server side. This is because Nuxt technically is a server-side
    technology and renders our HTML pages on the server side, but there is no DOM
    on the server side, so we can leverage `jsdom` for that. But rest assured, we
    will walk you through the steps to get all these tools set up and write your tests.
    So, stay tuned!
  prefs: []
  type: TYPE_NORMAL
