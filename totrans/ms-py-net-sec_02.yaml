- en: System Programming Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at the main modules we can find in Python
    for working with the Python interpreter, the operating system, and executing commands.
    We will review how to work with the file system, reading, and creating files.
    Also, we'll review threads-management and other modules for multithreading and
    concurrency. We'll end this chapter with a review about the `socket.io` module
    for implementing asynchronous servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing system modules in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading and concurrency in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python `Socket.io`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 2` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.)'
  prefs: []
  type: TYPE_NORMAL
- en: You will need some basic knowledge about command-execution in operating systems,
    and to install the Python distribution on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing system modules in python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this section, we'll explain the main modules you can find in Python
    for working with the Python interpreter, the operating system, and executing commands
    with the sub-procces module.
  prefs: []
  type: TYPE_NORMAL
- en: The system module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sys` module will allow us to interact with the interpreter and it contains
    most of the information related to the execution in progress, updated by the interpreter,
    as well as a series of functions and low-level objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`**sys.argv**` contains the list of parameters for executing a script. The
    first item in the list is the name of the script followed by the list of parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: We may, for example, want to parse command-line arguments at runtime. The sys.argv
    list contains all the command-line arguments. The first sys.argv[0] index contains
    the name of the Python interpreter script. The remaining items in argv array contain
    the next command-line arguments. Thus, if we are passing three additional arguments,
    sys.argv should contain four items.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `**sys_arguments.py**` file in :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous script can be executed with some parameters, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the previous script with three parameters, we can see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65980509-35c9-4adc-abe0-556185adc047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we obtain many system variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75dd2dae-c18d-4937-a697-07d4de09d0b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the main attributes and methods to recover that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sys.platform**: Returns the current operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sys.stdin,sys,stdout,sys.stderr**: File objects that point respectively to
    the standard input, standard output, and standard error output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sys.version**: Returns the interpreter version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sys.getfilesystemencoding()**: Returns the encoding used by the filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sys.getdefaultencoding()**: Returns the default encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sys.path**: Returns a list of all the directories in which the interpreter
    searches for the modules when the import directive is used or when the names of
    the files are used without their full path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information on the Python online module documents at [http://docs.python.org/library/sys](http://docs.python.org/library/sys).
  prefs: []
  type: TYPE_NORMAL
- en: The operating system module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The operating system(os) module is the best mechanism to access the different
    functions in our operating system. The use of this module will depend on the operating
    system that is used. If we use this module, we will have to adapt the script if
    we go from one operating system to another.
  prefs: []
  type: TYPE_NORMAL
- en: This module allows us to interact with the OS environment, filesystem, and permissions.
    In this example, we check whether the name of a text file passed as a command-line
    argument exists as a file in the current execution path and the current user has
    read permissions to that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `check_filename.py` file in `os` module
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Contents of the current working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, the `os` module is used to list the contents of the current
    working directory with the `os.getcwd()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `show_content_directory.py` file in the `os`
    module subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the main steps for the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `os` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `os` module, call the  `**os.getcwd()**` method to retrieve the current
    working directory path, and store that value on the pwd variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the the list of directories from the current directory path. Use the
    `**os.listdir()**` method to obtain the file names and directories in the current
    working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the list directory to get the files and directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the main methods for recovering information from the operating
    system module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**os.system()**: Allows us to execute a shell command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**os.listdir(path)**: Returns a list with the contents of the directory passed
    as an argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**os.walk(path)**: Navigates all the directories in the provided path directory,
    and returns three values: the path directory, the names for the sub directories,
    and a list of filenames in the current directory path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we check the files and directories inside the current path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `check_files_directory.py`** file
    in `os` module subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Determining the operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next script determines whether the code is running on Windows OS or the
    Linux platform. The `**platform.system()**` method informs us of the running operating
    system. Depending on the return value, we can see the ping command is different
    in Windows and Linux. Windows OS uses ping –n 1 to send one packet of the ICMP
    ECHO request, whereas Linux or another OS uses ping –c 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `operating_system.py`** file in `os`
    module subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Subprocess module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard subprocess module allows you to invoke processes from Python and
    communicate with them, send data to the input (stdin), and receive the output
    information (stdout). Using this module is the recommended way to execute operating
    system commands or launch programs (instead of the traditional `os.system ()`)
    and optionally interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a child process with your subprocess is simple. Here, the **Popen**
    constructor **starts the process**. You can also pipe data from your Python program
    into a subprocess and retrieve its output. With the **help(subprocess)** command,
    we can see that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5cb9d517-d7b9-4466-80cc-23aadaf26abc.png)'
  prefs: []
  type: TYPE_IMG
- en: The simplest way to execute a command or invoke a process is via the `call()`
    function (from Python 2.4 to 3.4) or `run()` (for Python 3.5+). For example, the
    following code executes a command that list files in the current path.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find this code in the** `SystemCalls.py`** file in subprocess subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to use the terminal commands (such as clear or cls to clean the
    console, cd to move in the directory tree, and so on), it is necessary to indicate
    shell = True parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it asks the user to write their name and then print a greeting
    on the screen. Via a subprocess we can invoke it with Popen method, enter a name
    programmatically, and get the greeting as a Python string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Popen ()` instances incorporate the `terminate ()` and `kill ()` methods
    to terminate or kill a process, respectively. Distributions of Linux distinguish
    between the SIGTERM and SIGKILL signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Popen function it gives more flexibilty if we compare with the call function
    since it executes the command as a child program in a new process. For example,
    on Unix systems, the class uses `os.execvp()`. and on Windows, it uses the Windows
    `CreateProcess()` function.
  prefs: []
  type: TYPE_NORMAL
- en: You can get more information about the Popen constructor and methods that provide
    Popen class in the official documentation: [https://docs.python.org/2/library/subprocess.html#popen-constructor](https://docs.python.org/3.5/library/subprocess.html#popen-constructor).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using the `subprocess` module to call the `ping` command
    and obtain the output of this command to evaluate whether a specific IP address
    responds with `ECHO_REPLY`. Also, we use the `sys` module to check the operating
    system where we are executing the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `PingScanNetWork.py`** file in subprocess
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this script, we need to pass the network we are analyzing and the
    machine number we want to check as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of scanning the 129.168.56 network and one machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6b324c6f-76c0-4706-88dc-bd48a61849d2.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with the filesystem in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this section, we explain the main modules you can find in Python
    for working with the filesystem, accessing files and directories, reading and
    creating files, and operations with and without the context manager.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how we can work with the filesystem and perform tasks
    such as browsing directories or reading each file individually.
  prefs: []
  type: TYPE_NORMAL
- en: Recursing through directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, it is necessary to iterate recursively through the main directory
    to discover new directories. In this example, we see how we can browse a directory
    recursively and retrieve the names of all files within that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a specific path is a file or directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can check whether a certain string is a file or directory. For this, we
    can use the `os.path.isfile()` method, which returns `True` if it is a file and
    `False` if it is a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a file or directory exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to check whether a file exists in the current working path directory,
    you can use the `os.path.exists()` function, passing the file or directory you
    want to check as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating directories in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create your own directory using the `os.makedirs()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code checks whether the my_dir directory exists; if it does not exist,
    it will call  `os.makedirs` **('**`my_dir`**')** to create the directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you create the directory after verifying that the directory does not exist,
    before your call to `os.makedirs` ('`my_dir`') is executed, you may generate an
    error or an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to be extra careful and catch any potential exceptions, you can
    wrap your call to os.makedirs(''`my_dir`'') in a **try...except** block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing files in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are going to review the methods for reading and writing files.
  prefs: []
  type: TYPE_NORMAL
- en: File methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are the functions that can be used on a file object.
  prefs: []
  type: TYPE_NORMAL
- en: '**file.write(string)**: Prints a string to a file, there is no return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**file.read([bufsize])**: Reads up to “bufsize” number of bytes from the file.
    If run without the buffer size option, reads the entire file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**file.readline([bufsize])**: Reads one line from the file (keeps the newline).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**file.close()**: Closes the file and destroys the file object. Python will
    do this automatically, but it’s still good practice when you’re done with a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic way of working with files is to use the `open()` method. This method
    allows you to open a file, returning an object of the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '**open(name[, mode[, buffering]])**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opening modes of the file can be r(read), w(write), and a(append). We can
    add to these the b (binary), t (text), and + (open reading and writing) modes.
    For example, you can add a "+" to your option, which allows read/write to be done
    with the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a file, we have several possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readlines()` method that reads all the lines of the file and joins them
    in a sequence. This method is very useful if you want to read the entire file
    at once: ` >>> allLines = file.readlines()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to read the file line by line, we can use the `readline()` method.
    In this way, we can use the file object as an iterator if we want to read all
    the lines of a file one by one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With a Context Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways to create files in Python, but the cleanest way to do
    this is by using the **with** keyword, in this case we are using the **Context
    Manager Approach**.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Python provided the open statement to open files. When we are using
    the open statement, Python delegates into the developer the responsibility to
    close the file when it's no longer need to use it. This practice lead to errors
    since developers sometimes forgot to close it. Since Python 2.5, developers can
    use the with statement to handle this situation safely. The **with statement**
    automatically closes the file even if an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The with command allows many operations on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we have the advantage: the file is closed automatically and we
    don’t need to call the `close()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the below code in the filename `**create_file.py**`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous script uses the context manager to open a file and returns this
    as a file object. Within this block,  we then call file.write ("this is a test
    file"), which writes it to our created file. In this case, the with statement
    then handles closing the file for us and we don’t have to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the with statement, you can check out the official
    documentation at [https://docs.python.org/2/reference/compound_stmts.html#the-with-statement](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement).
  prefs: []
  type: TYPE_NORMAL
- en: Reading a file line by line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can iterate over a file in a line-by-line way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we join all these functionalities with exception-management
    when we are working with files.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `create_file_exceptions.py`** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Threads in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to introduce the concept of threads and how we
    can manage them with `Python` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threads are streams that can be scheduled by the operating system and can be
    executed across a single core in a concurrent way or in parallel way across multiple
    cores. Threads can interact with shared resources, such as memory, and they can
    also modify things simultaneously or even in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Types of threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two distinct types of threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel-level threads**: Low-level threads, the user can not interact with
    them directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-level threads**: High-level threads, we can interact with them in our
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes vs Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Processes are full programs.They have their own PID (process ID) and PEB (Process
    Environment Block).These are the main features of processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes can contain multiple threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a process terminates, the associated threads do as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Threads are a concept similar to processes: they are also code in execution.
    However, the threads are executed within a process, and the threads of the process
    share resources among themselves, such as memory. These are the main features
    of threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Threads can only be associated with one Process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes can continue after threads terminate (as long as there is at least
    one thread left).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thread is the mechanism for a program to perform a task several times in parallel.
    Therefore, in a script, we can launch the same task on a single processor a certain
    number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For working with threads in Python, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: The thread module provides primitive operations to write multithreaded programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The threading module provides a more convenient interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `thread` module will allow us to work with multiple threads:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create four threads, and each one prints a different message
    on the screen that is passed as a parameter in the `thread_message (message)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `threads_init.py`** file in threads
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see more information about the `start_new_thread()` method if we invoke
    the help(thread) command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9fa9be64-d35f-47de-a4fb-d15a493af04b.png)'
  prefs: []
  type: TYPE_IMG
- en: Threading module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the `thread` module, we have another approach to using the `threading`
    module. The threading module relies on the `thread` module to provide us a higher
    level, more complete, and object-oriented API. The threading module is based slightly
    on the Java threads model.
  prefs: []
  type: TYPE_NORMAL
- en: The threading module contains a Thread class that we must extend to create our
    own threads of execution. The run method will contain the code that we want the
    thread to execute. If we want to specify our own constructor, it must call threading.
    `Thread .__ init __ (self)` to initialize the object correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating a new thread in Python, we review the Python Thread class init
    method constructor and see what parameters we need to pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Thread class constructor accepts five arguments as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**group**: A special parameter that is reserved for future extensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**target**: The callable object to be invoked by the run method().'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**name**: Our thread''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**args**: Argument tuple for target invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kwargs**: Dictionary keyword argument to invoke the base class constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get more information about the `init()` method if we invoke the **help(threading)**
    command in a Python interpreter console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0c2a3d8-c36e-4ec1-9e17-1c6c8ab60a9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s create a simple script that we’ll then use to create our first thread:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `threading_init.py`** file in threads
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order for the thread to start executing its code, it is enough to create
    an instance of the class that we just defined and call its start method. The code
    of the main thread and that of the one that we have just created will be executed
    concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: We have to instantiate a Thread object and invoke the `start()` method. Run
    is our logic that we wish to *run* in parallel inside each of our threads, so
    we can use the `run()` method to launch a new thread. This method will contain
    the code that we want to execute in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we are creating four threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `threading_example.py`** file in threads
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the `thread.join()` method to wait until the thread terminates.
    The join method is used so that the thread that executes the call is blocked until
    the thread on which it is called ends. In this case, it is used so that the main
    thread does not finish its execution before the children, which could result in
    some platforms in the termination of the children before finishing its execution.
    The join method can take a floating point number as a parameter, indicating the
    maximum number of seconds to wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `threading_join.py`** file in threads
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Multithreading and concurrency in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to introduce the concepts of multithreading and
    concurrency and how we can manage them with python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind multithreading applications is that they allow us to have copies
    of our code and execute them on additional threads. This allows a program to execute
    multiple operations simultaneously. In addition, when a process is blocked, for
    example to wait for input/output operations, the operating system can allocate
    computation time to other processes.
  prefs: []
  type: TYPE_NORMAL
- en: When we mention multiprocess processors, we're referring to a processor that
    can execute multiple threads simultaneously. These typically have two or more
    threads that actively compete for execution time within a kernel and when one
    thread is stopped, the processing kernel starts executing another thread.
  prefs: []
  type: TYPE_NORMAL
- en: The context changes between these subprocesses very quickly and gives the impression
    that the computer is running the processes in parallel, which gives us the ability
    to multitask.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has an API that allow us to write applications with multiple threads. To
    get started with multithreading, we are going to create a new thread inside a
    `python` class and call it** `ThreadWorker.py`.** This class extends from `threading.Thread`
    and contains the code to manage one thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our thread worker class, we can start to work on our main
    class. Create a new python file, call it `main.py`, and put the following code
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Documentation about the threading module is available at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  prefs: []
  type: TYPE_NORMAL
- en: Limitations with classic python threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main problems with the classic implementation of Python threads is
    that their execution is not completely asynchronous. It's known that the execution
    of python threads is not completely parallel and adding multiple threads often
    multiplies the execution times. Therefore, performing these tasks reduces the
    time of execution.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of the threads in Python is controlled by the GIL (Global Interpreter
    Lock) so that only one thread can be executed at the same time, independently
    of the number of processors with which the machine counts.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it possible to write C extensions for Python much more easily, but
    it has the disadvantage of limiting performance a lot, so in spite of everything,
    in Python, sometimes we may be more interested in using processes than threads,
    which do not suffer from this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the thread change is performed every 10 bytecode instructions, although
    it can be modified using the sys.setcheckinterval function. It also changes the
    thread when the thread is put to sleep with time.sleep or when an input/output
    operation begins, which can take a long time to finish, and therefore, if the
    change is not made, we would have the CPU long time without executing code,waiting
    for the I/O operation to finish.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize the effect of GIL on the performance of our application, it is convenient
    to call the interpreter with the -O flag, which will generate an optimized bytecode
    with fewer instructions, and, therefore, less context changes. We can also consider
    using processes instead of threads, as we discussed, such as the `ProcessPoolExecutors`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: More about the **GIL** can be found at [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock).
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in python with ThreadPoolExecutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review the **ThreadPoolExecutor** class that provides an
    interface to execute tasks asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ThreadPoolExecutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define our **ThreadPoolExecutor** object with the init constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can create our ThreadPoolExecutor if we pass to the constructor the maximum
    number of workers as the parameter. In this example, we have defined five as the
    maximum number of threads, which means that this group of subprocesses will only
    have five threads working simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use our `ThreadPoolExecutor`, we can call the `submit()` method,
    which takes a function for executing that code in an asynchronous way as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`executor.submit(myFunction())`'
  prefs: []
  type: TYPE_NORMAL
- en: ThreadPoolExecutor in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we analyze the creation of an object of the `ThreadPoolExecutor`
    class. We define a `view_thread()` function that allows us to display the current
    thread identifier with the `threading.get_ident()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We define our main function where the executor object is initialized as an instance
    of the ThreadPoolExecutor class and over this object we execute a new set of threads.
    Then we obtain the thread has been executed with the `threading.current_thread()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `**threadPoolConcurrency.py**` file
    in concurrency subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that the three different values in the script output are three different
    thread identifiers, and we obtain three distinct daemon threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/459803de-3951-439d-8852-1c26a2480765.png)'
  prefs: []
  type: TYPE_IMG
- en: Executing ThreadPoolExecutor with Context Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to instantiate ThreadPoolExecutor to use it as a context manager
    with the `with` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`with ThreadPoolExecutor(max_workers=2) as executor:`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, within our main function, we use our ThreadPoolExecutor as
    a context manager and then call `future = executor.submit(message, (message))`
    twice to process each message in the threadpool.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `threadPoolConcurrency2.py` file in concurrency
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Python Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how we can use the socket.io module to create a webserver
    based in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets is a technology that offers realtime communication between a client
    and server through a TCP connection, and eliminates the need for customers to
    be continually checking whether API endpoints have updates or new content. Clients
    create a single connection to a WebSocket server and remain pending to listen
    for new events or messages from the server.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of websockets is that they are more efficient as they reduce
    the network load and send information to a large number of clients in the form
    of messages.
  prefs: []
  type: TYPE_NORMAL
- en: aiohttp and asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: aiohttp is a library to build server and client applications built in asyncio.
    The library uses the advantages of websockets natively to communicate different
    parts of the application asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is available at [http://aiohttp.readthedocs.io/en/stable](http://aiohttp.readthedocs.io/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: asyncio is a python module that helps to do concurrent programming of a single
    thread in python. Already in python 3.6, the documentation is available at [https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Server with socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Socket.IO server is available in the official python repository and can
    be installed via pip: `pip install python-socketio.`
  prefs: []
  type: TYPE_NORMAL
- en: The full documentation is available at [https://python-socketio.readthedocs.io/en/latest/](https://python-socketio.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that works in python 3.5 where we implement a Socket.IO
    server using the aiohttp framework for asyncio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we implemented a server based on socket.io that uses the
    aiohttp module. As you can see in the code, we define two methods, the `index
    ()` method, which will return a response message upon receiving a request on the
    "/" root endpoint, and a `print_message ()` method that contains the `@socketio.on`
    (' message ') annotation. This annotation causes the function to listen for message-type
    events, and when these events occur, it will act on those events.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the main system modules for python programming,
    such as os for working with the operating system, sys for working with the filesystem,
    and sub-proccess for  executing commands. We also reviewed how to work with the
    filesystem, reading and creating files, managing threads, and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter](bd1e16c1-2ce3-4edc-b61d-9845d978c2bd.xhtml), we will explore
    the socket package for resolving IP addresses and domains, and implement client
    and servers with TCP and UDP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main module that allows us to interact with the python interpreter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main module that allows us to interact with the OS environment,
    filesystem, and permissions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the module and the method used to list the contents of the current
    working directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the module to execute a command or invoke a process via the call() function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the approach that we can follow in python to handle files and manage
    exceptions in an easy and secure way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between processes and threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main modules in python for creating and managing threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the limitation that python has when working with threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class provides a high-level interface for executing input/output tasks
    in an asynchronous way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function in the threading module that determines which thread has
    performed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the mentioned tools and
    the official python documentation for some of the modules we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/tutorial/inputoutput.html](https://docs.python.org/3/tutorial/inputoutput.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/concurrent.futures.html](https://docs.python.org/3/library/concurrent.futures.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers interested in web server programming with technologies such aiohttp
    and asyncio should look to frameworks such as Flask ([http://flask.pocoo.org](http://flask.pocoo.org))
    and Django ([https://www.djangoproject.com](https://www.djangoproject.com)).
  prefs: []
  type: TYPE_NORMAL
