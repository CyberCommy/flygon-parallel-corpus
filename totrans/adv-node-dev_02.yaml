- en: MongoDB, Mongoose, and REST APIs – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're going to learn how to connect your Node applications
    to the MongoDB database you've been running on your local machine. This means
    that we'll be able to issue database commands right inside of our Node apps to
    do stuff like insert, update, delete, or read data. This is going to be critical
    if we're ever going to make that Todo REST API. When someone hits one of our API
    endpoints, we want to manipulate the database, whether it's reading all of the
    Todos or adding a new one. Before we can do any of that though, we have to learn
    the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB and writing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to our MongoDB database from inside of Node.js, we''re going to
    be using an npm module created by the MongoDB team. It''s called node-mongodb-native,
    but it includes all of the features you''ll need to connect to and interact with
    your database. To get to it, we''re going to Google `node-mongodb-native`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2d25ad4-75ae-45ac-ba0e-26abbda50968.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The GitHub repo, which should be the first link, is the one we want—the node-mongodb-native
    repository—and if we scroll down, we can take a look at a few important links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c02996e6-da4d-4ffa-8612-721523ea48e4.png)'
  prefs: []
  type: TYPE_IMG
- en: First up we have documentation, and we also have our api-docs; these are going
    to be critical as we start exploring the features that we have inside of this
    library. If we scroll down further on this page, we'll find a ton of examples
    on how to get started. We'll be going through a lot of this stuff in this chapter,
    but I do want to make you aware of where you can find other resources because
    the mongodb-native library has a ton of features. There are entire courses dedicated
    to MongoDB, and they don't even begin to cover everything that's built-in to this
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to be focusing on the important and common subset of MongoDB that
    we need for Node.js apps. To get started, let''s go ahead and open up the documentations,
    which are shown in the preceding image. When you go to the docs page, you have
    to pick your version. We''ll be using version 3.0 of the driver, and there''s
    two important links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Reference link:** This includes guide-like articles, things to get you
    started, and other various references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The API link:** This includes the details of every single method available
    to you when you''re working with the library. We''ll be exploring some of the
    methods on this link as we start creating our Node Todo API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now though, we can get started by creating a new directory for this project,
    and then we're going to go ahead and install the MongoDB library and connect to
    the database we have running. I am going to assume that you have your database
    running for all the sections in this chapter. I have it running in a separate
    tab in my Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: If you're on Windows, refer to the instructions in the Windows installation
    section to start your database if you forget. If you're on a Linux or macOS operating
    system, use the instructions I have already mentioned, and don't forget to also
    include that `dbpath` argument, which is essential for booting up your MongoDB
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a directory for the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick things off, I''m going to make a new folder on the Desktop for the
    Node API. I''ll use `mkdir` to create a new folder called `node-todo-api`. Then,
    I can go ahead and use `cd` to go into that directory, `cd node-todo-api`. And
    from here, we''re going to run `npm init`, which creates our `package.json` file
    and lets us install our MongoDB library. Once again, we''re going to be using
    enter to skip through all of the options, using the defaults for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08418c55-f4af-4d52-8f3c-239701eb5c9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we get to the end we can confirm our selections, and now our `package.json`
    file is created. The next thing we're going to do is open up this directory inside
    of Atom. It's on the Desktop, `node-todo-api`. Next up, inside of the root of
    the project we're going to create a new folder, and I'm going to call this folder
    `playground`. Inside of this folder, we'll store various scripts. They're not
    going to be scripts related to the Todo API; they'll be scripts related to MongoDB,
    so I do want to keep them in the folder, but I don't necessarily want them to
    be part of the app. We'll use the `playground` folder for that, like we have in
    the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `playground` folder, let''s go ahead and make a new file, and we''ll
    call this file `mongodb-connect.js`. Inside of this file, we''re going to get
    started by loading in the library and connecting to the database. Now in order
    to do that, we have to install the library. From the Terminal, we can run `npm
    install` to get that done. The new library name is `mongodb`; all lowercase, no
    hyphens. Then, we''re going to go ahead and specify the version to make sure we''re
    all using the same functionality, `@3.0.2`. This is the most recent version at
    the time of writing. After the version number, I am going to use the `--save`
    flag. This is going to save it as a regular dependency, which it already is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We're going to need this to run the Todo API application.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the mongodb-connect file to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With MongoDB now installed, we can move it to our `mongodb-connect` file and
    start connecting to the database. The first thing we need to do is pull something
    out of the library that we just installed, which is the `mongodb` library. What
    we''re looking for is something called the `MongoClient` constructor. The `MongoClient`
    constructor lets you connect to a Mongo server and issue commands to manipulate
    the database. Let''s go ahead and kick things off by creating a constant called
    `MongoClient`. We''re going to set that equal to `require`, and we''re going to
    require the library we just installed, `mongodb`. From that library, we''re going
    to pull off `MongoClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `MongoClient` now in place, we can call `MongoClient.connect` to connect
    to the database. This is a method, and it takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a string, and this is going to be the URL where your database
    lives. Now in a production example, this might be an Amazon Web Services URL or
    a Heroku URL. In our case, it's going to be a localhost URL. We'll talk about
    that later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is going to be a callback function. The callback function
    will fire after the connection has either succeeded or failed, and then we can
    go ahead and handle things appropriately. If the connection failed, we'll print
    a message and stop the program. If it succeeded, we can start manipulating the
    database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a string as the first argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first argument in our case, we''re going to start off with `mongodb://`.
    When we connect to a MongoDB database, we want to use the mongodb protocol like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, it''s going to be at localhost since we''re running it on our local
    machine, and we have the port, which we have already explored: `27017`. After
    the port, we need to use `/` to specify which database we want to connect to.
    Now, in the previous chapter, we used that test database. This is the default
    database that MongoDB gives you, but we could go ahead and create a new one. After
    the `/`, I''m going to call the database `TodoApp`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding the callback function as the second argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up, we can go ahead and provide the callback function. I''m going to use
    an ES6 arrow (`=>`) function, and we''re going to get past two arguments. The
    first one is going to be an error argument. This may or may not exist; just like
    we''ve seen in the past, it''ll exist if an error actually happened; otherwise
    it won''t. The second argument is going to be the `client` object. This is what
    we can use to issue commands to read and write data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Error handling in mongodb-connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we write any data, I''m going to go ahead and handle any potential
    errors that come about. I''ll do that using an `if` statement. If there is an
    error, we''re going to print a message to the console, letting whoever is looking
    at the logs know that we were unable to connect to the database server, `console.log`,
    then inside of quotes put something like `Unable to connect to MongoDB server`.
    After the `if` statement, we can go ahead and log out a success message, which
    will be something like `console.log`. Then, inside of quotes, we''ll use `Connected
    to MongoDB server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you're handling errors like this, the success code is going to run
    even if the error block runs. What we want to do instead is add a `return` statement
    right before the `console.log('Unable to connect to MongoDB server');` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `return` statement isn''t doing anything fancy. All we''re doing is using
    it to prevent the rest of the function from executing. As soon as you return from
    a function, the program stops, which means if an error does occur, the message
    will get logged, the function will stop, and we''ll never see this `Connected
    to MongoDB server` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An alternative to using the `return` keyword would be to add an `else` clause
    and put our success code in an `else` clause, but it's unnecessary. We can just
    use the `return` syntax, which I prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we run this file, there is one more thing I want to do. At the
    very bottom of our callback function, we''re going to call a method on db. It''s
    called `client.close`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This closes the connection with the MongoDB server. Now that we have this in
    place, we can actually save the `mongodb-connect` file and run it inside of the
    Terminal. It doesn't do much yet, but it is indeed going to work.
  prefs: []
  type: TYPE_NORMAL
- en: Running the file in the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the Terminal, we can run the file using `node playground` as the directory,
    with the file itself being `mongodb-connect.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this file, we get `Connected to MongoDB server` printing to the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9407d5a3-011f-4cbe-90eb-9c4a31b55d58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we head over into the tab where we have the MongoDB server, we can see we
    got a new connection: connection accepted. As you can see in the following screenshot,
    that connection was closed down, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f1192b4-66da-47e3-bde5-7f094bbc762f.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Mongo library we were able to connect, print a message, and disconnect
    from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might have noticed that we changed the database name in the `MongoClient.connect`
    line in Atom, and we never actually did anything to create it. In MongoDB, unlike
    other database programs, you don't need to create a database before you start
    using it. If I want to kick up a new database I simply give it a name, something
    like `Users`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I have a `Users` database, I can connect to it and I can manipulate
    it. There is no need to create that database first. I'm going to go ahead and
    change the database name back to `TodoApp`. If we head into the Robomongo program
    and connect to our local database, you'll also see that the only database we have
    is `test`. The `TodoApp` database was never even created, even though we connected
    to it. Mongo is not going to create the database until we start adding data into
    it. We can go ahead and do that right now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of Atom, before our call to `db.close`, we''re going to insert a new
    record into a collection. This is going to be the Todo application. We''re going
    to have two collections in this app:'
  prefs: []
  type: TYPE_NORMAL
- en: a `Todos` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `Users` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can go ahead and start adding some data to the `Todos` collection by calling
    `db.collection`. The `db.collection` method takes the string name for the collection
    you want to insert into as its only argument. Now, like the actual database itself,
    you don''t need to create this collection first. You can simply give it a name,
    like `Todos`, and you can start inserting into it. There is no need to run any
    command to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to use a method available in our collection called `insertOne`.
    The `insertOne` method lets you insert a new document into your collection. It
    takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is going to be an object. This is going to store the various key-value
    pairs we want to have in our document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is going to be a callback function. This callback function will
    get fired when things either fail or go well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You''re going to get an error argument, which may or may not exist, and you''ll
    also get the result argument, which is going to be provided if things went well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the error callback function itself, we can add some code to handle
    the error, and then we''ll add some code to print the object to the screen if
    it was added successfully. First up, let''s add an error handler. Much like we
    have done previously, we''re going to check if the error argument exists. If it
    does, then we''ll simply print a message using the `return` keyword to stop the
    function from executing. Next, we can use `console.log` to print `Unable to insert
    todo`. The second argument I''m going to pass to the `console.log` is going to
    be the actual `err` object itself, so if someone''s looking at the logs, they
    can see exactly what went wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to our `if` statement, we can add our success code. In this case, all
    we''re going to do is pretty-print something to the `console.log` screen, and
    then I''m going to call `JSON.stringify`, where we''re going to go ahead and pass
    in `result.ops`. The `ops` attribute is going to store all of the docs that were
    inserted. In this case, we used `insertOne`, so it''s just going to be our one
    document. Then, I can add my other two arguments, which are `undefined` for the
    filter function, and `2` for the indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now go ahead and execute our file and see what happens.
    Inside of the Terminal, I''m going to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When I execute the command, we get our success message: `Connected to MongoDB
    server`. Then, we get an array of documents that were inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc451fb0-aae9-404f-9d73-cb56589083ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Now as I mentioned, in this case we just inserted one document, and that shows
    up as shown in the preceding screenshot. We have the `text` property, which gets
    created by us; we have the `completed` property, which gets created by us; and
    we have the `_id` property, which gets automatically added by Mongo. The `_id`
    property is going to be the topic of the following section. We're going to talk
    in depth about what it is, why it exists and why it's awesome.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''re going to go ahead and just note that it''s a unique identifier.
    It''s an ID given to just this document. That is all it takes to insert a document
    into your MongoDB database using Node.js. We can view this document inside of
    Robomongo. I''m going to right-click the connection, and click Refresh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3618889d-f9e2-4b28-9548-d34f9e2f0315.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This reveals our brand new `TodoApp` database. If we open that up, we get our
    `Collections` list. We can then go into the `Collections`, view the documents,
    and what do we get? We get our one Todo item. If we expand it, we can see we have
    our _id, we have our text property, and we have our completed Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/952d1c7e-fe2e-40e3-a249-8ac9ca3e4b68.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the Todo is not completed, so the completed value is false. Now,
    what I want you to do is add a new record into a collection. This is going to
    be your challenge for the section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new record into a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside of Atom, what I'd like you to do is take the code all the way from `db.collection`
    down to the bottom of our callback, and comment it out. Then, we're going to go
    ahead and add something following it. Right previous `db.close()`, you're going
    to type `Insert new doc into the Users collection`. This doc is going to have
    a few properties. I want you to give it a `name` property; set that equal to your
    name. Then, we're going to give it an `age` property, and last but not least we
    can give it a `location` string. I want you to insert that doc using `insertOne`.
    You're going to need to pass in the new collection name into the collection method.
    Then, further down, you're going to add some error-handling code, and you're going
    to print the ops to the screen. Once you rerun the file, you should be able to
    view your record in the Terminal and you should be able to refresh things. Over
    in Robomongo, you should see the new Users collection, and you should see your
    user with the name, age, and location you specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopefully, you were able to insert a new document into the Users collection.
    What you needed to do in order to get this done is call `db.collection` so we
    can access the collection we want to insert into, which in this case is `Users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we have to call a method to manipulate the `Users` collection. We
    want to insert a new document, so we''re going to use `insertOne`, just like we
    did in the previous sub-section. We''re going to pass our two arguments into `insertOne`.
    The first one is the document to insert. We''re going to give it a `name` property;
    I''ll set that equal to `Andrew`. Then, we can go ahead and set the `age` equal
    to something like `25`. Lastly, we''ll set the `location` equal to my current
    location, `Philadelphia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next argument we want it to pass in is our callback function, which is
    going to get called with the error object as well as the results. Inside of the
    callback function itself, we''re going to first handle the error. If there was
    an error, we''re going to go ahead and log it to the screen. I''m going to return
    `console.log`, and then we can put the message: `Unable to insert user`. Then,
    I''ll add the error argument as the second argument for `console.log`. Next up,
    we can add our success case code. If things go well, all I''m going to do is use
    `console.log` to print `result.ops` to the screen. This is going to show us all
    of the records that were inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now go ahead and rerun the file inside of the Terminal using the *up*
    arrow key and the *enter* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1efe9b45-0509-4625-9bcf-cf85ef2e1968.png)'
  prefs: []
  type: TYPE_IMG
- en: We get our array of inserted documents, and we just have one. The `name`, `age`,
    and `location` properties all come from us, and the `_id` property comes from
    MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, I want you to verify that it was indeed inserted by viewing it in
    Robomongo. In general, when you add a new collection or a new database, you can
    just right-click the connection itself, click Refresh, and then you should be
    able to see everything that was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/029bbfea-6826-4ece-ac25-f10f834c5966.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we have our Users collection. I can view
    the documents for Users. We get our one document with the name set to Andrew,
    age set to 25, and location set to Philadelphia. With this in place, we are now
    done. We've been able to connect to our MongoDB database using Node.js, and we've
    also learned how to insert documents using this mongo-native library. In the next
    section, we're going to take an in-depth look at ObjectIds, exploring exactly
    what they are and why they're useful.
  prefs: []
  type: TYPE_NORMAL
- en: The ObjectId
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have inserted some documents into your MongoDB collections, I want
    to take a moment to talk about the `_id` property in the context of MongoDB because
    it's a little different than the IDs that you're probably used to if you've used
    other database systems, like Postgres or MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The _id property in the context of MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick off our discussion of the `_id` property, let''s go ahead and rerun
    the `mongodb-connect` file. This is going to insert a new document into the Users
    collection, like we''ve defined in the `db.collection` line. I''m going to go
    ahead and do that by running the file through the node. It''s in the `playground`
    folder, and the file itself is called `mongodb-connect.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to run the command, and we''re going to print out the document that
    got inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc75c923-aecb-4897-9cde-e6938420c025.png)'
  prefs: []
  type: TYPE_IMG
- en: As we've seen in the past, we get our three attributes as well as the one added
    by Mongo.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you'll notice about this is that it is not an auto incrementing
    integer, kind of like it is for Postgres or MySQL, where the first record has
    an ID of 1 and the second one has an ID of 2\. Mongo does not use this approach.
    Mongo was designed to scale out really easily. Scaling out means that you can
    add on more database servers to handle that extra load.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a web app that gets about 200 users a day and your current
    servers are ready for that traffic. Then, you get picked up by some news outlet
    and 10,000 people flood your site. With MongoDB, it's really easy to kick up new
    database servers to handle that extra load. When we use a randomly generated ID,
    we don't need to constantly communicate with the other database servers to check
    what the highest incrementing value is. Is it 7? Is it 17? It doesn't really matter;
    we're simply going to generate a new random ObjectId and use that for the document's
    unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the ObjectId itself is made up of a few different things. It's a 12-byte
    value. The first four bytes are a timestamp; we'll talk about that later. That
    means that we have a timestamp built into the data that refers to the moment in
    time the ID was created. This means that in our documents, we don't need to have
    a `createdAt` field; it's already encoded in the ID.
  prefs: []
  type: TYPE_NORMAL
- en: The next three bytes are machine identifiers. This means that if two computers
    generate ObjectIds, their machine ID is going to be different, and this is going
    to ensure that the ID is unique. Next up, we have two bytes, the process ID, which
    is just another way to create a unique identifier. Last up, we have a 3-byte counter.
    This is similar to what MySQL would do. This is only 3 bytes of the ID. As we
    have already mentioned, we have a timestamp which is going to be unique; a machine
    identifier; a process ID; and lastly, just a random value. That is what makes
    up an ObjectId.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ObjectId is the default value for `_id`. If nothing is provided, you can
    indeed do whatever you like with that property. For example, inside of the `mongodb-connect`
    file, I can specify an `_id` property. I''m going to give it a value, so let''s
    go with `123`; add a comma at the end; and that is perfectly legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can save the file, and rerun the script using the *up* arrow key and the
    *enter* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfbb1afb-2704-4061-b756-9cdefb890c9e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our record, where the `_id` property is `123`. The `ObjectId` is the
    default way MongoDB creates IDs, but you can do anything you like for ID creation.
    Inside of Robomongo, we can give our Users collection a refresh, and we get our
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/201195b7-8371-478d-a7a1-988e81213e14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have the one we created in the previous section and the two we just made
    now, all with a unique identifier. This is why unique IDs are really important.
    In this example, we have three properties: name, age and location, and they''re
    the same for all the records. This is a reasonable thing to do. Imagine two people
    need to do the same thing, like buy groceries. That string alone is not going
    to be enough to uniquely identify a Todo. ObjectIds, on the other hand, are going
    to be unique, and that is what we''re going to use to associated things like Todos
    with things like `Users`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up, I want to take a look at some things we can do with the ID inside of
    our code. As I mentioned earlier, a timestamp is embedded inside of here, and
    we can actually pull that out. Inside of Atom, what we're going to do is remove
    the `_id` property. The timestamp is only going to be available when you're using
    the `ObjectId`. Then, inside of our callback, we can go ahead and print the timestamp
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, `result.ops` is an array of all the documents that got inserted.
    We''re only inserting one, so I''m going to access the first item in the array,
    and then we''re going to access the `_id` property. This is going to do exactly
    what you might think:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save the file and rerun the script over from the Terminal, all we get
    is the `ObjectId` printing to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/288d7028-2bd9-4e7e-8fc1-fab1a9e60a0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now though, we can call a method on the `_id` property.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the .getTimestamp function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''re going to call is `.getTimestamp`. The `getTimestamp` is a function,
    but it doesn''t take any arguments. It simply returns the timestamp that the ObjectId
    was created at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we go ahead and rerun our program, we get a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d48f1c5-d083-463a-859e-3c4a91749924.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I can see that the ObjectId was created on February
    16th 2016 at 08:41 Z, so this timestamp is indeed correct. This is a fantastic
    way to figure out exactly when a document was created.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we don't have to rely on MongoDB to create our ObjectIds. Inside of the
    MongoDB library, they actually give us a function we can run to make an ObjectId
    whenever we like. For the moment, let's go ahead and comment out our call to insert
    one.
  prefs: []
  type: TYPE_NORMAL
- en: At the very top of the file, we're going to change our import statement to load
    in something new off of MongoDB, and we're going to do this using an ES6 feature
    known as object destructuring. Let's take a quick second to talk about that before
    we actually go ahead and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using object destructuring ES6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object destructuring lets you pull out properties from an object in order to
    create variables. This means that if we have an object called `user` and it''s
    set equal to an object with a `name` property set to `andrew` and an age property
    set to `25`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily pull out one of these into a variable. Let''s say, for example,
    we want to grab name and create a `name` variable. To do that using object destructuring
    in ES6, we''re going to make a variable and then we''re going to wrap it inside
    of curly braces. We''re going to provide the name we want to pull out; this is
    also going to be the variable name. Then, we''re going to set it equal to whatever
    object we want to destructure. In this case, that is the `user` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully destructured the `user` object, pulling off the `name`
    property, creating a new `name` variable, and setting it equal to whatever the
    value is. This means I can use the `console.log` statement to print `name` to
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to rerun the script and we get `andrew`, which is exactly what you''d
    expect because that is the value of the `name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/724333b0-a6d8-4e53-b09d-2266f7b30fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: ES6 destructuring is a fantastic way to make new variables from an object's
    properties. I'm going to go ahead and delete this example, and at the top of the
    code, we're going to change our `require` statement so that it uses destructuring.
  prefs: []
  type: TYPE_NORMAL
- en: Before we add anything new, let's go ahead and take the MongoClient statement
    and switch it to destructuring; then, we'll worry about grabbing that new thing
    that's going to let us make ObjectIds. I'm going to copy and paste the line and
    comment out the old one so we have it for reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What we're going to do is remove our `.MongoClient` call after `require`. There's
    no need to pull off that attribute because we're going to be using destructuring
    instead. That means over here we can use destructuring, which requires us to add
    our curly braces, and we can pull off any property from the MongoDB library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the only property we had was `MongoClient`. This creates a variable
    called `MongoClient`, setting it equal to the `MongoClient` property of `require('mongodb')`,
    which is exactly what we did in the previous `require` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new instance of objectID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some destructuring in place, we can easily pull more things
    off of MongoDB. We can add a comma and specify something else we want to pull
    off. In this case, we're going to pull off uppercase, `ObjectID`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ObjectID` constructor function lets us make new ObjectIds on the fly.
    We can do anything we like with them. Even if we''re not using MongoDB as our
    database, there is some value in creating and using ObjectIds to uniquely identify
    things. Next, we can make a new ObjectId by first creating a variable. I''ll call
    it `obj`, and we''ll set it equal to `new ObjectID`, calling it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `new` keyword, we can create a new instance of `ObjectID`. Next up,
    we can go ahead and log that to the screen using `console.log(obj)`. This is a
    regular ObjectId:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rerun the file over from the Terminal, we get exactly what you''d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f429516c-25b3-4fae-8689-052b7c4c1ceb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get an ObjectId-looking thing. If I rerun it again, we get a new one; they
    are both unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2b1feb5-0446-44b9-b276-e57ae9a9279e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this technique, we can incorporate ObjectIds anywhere we like. We could
    even generate our own, setting them as the `_id` property for our documents, although
    I find it much easier to let MongoDB handle that heavy lifting for us. I''m going
    to go ahead and remove the following two lines since we won''t actually be using
    this code in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have learned a bit about ObjectIds, what they are, and why they're useful.
    In the following sections, we're going to be taking a look at other ways we can
    work with MongoDB. We'll learn how to read, remove, and update our documents.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to insert data into your database, let's go ahead and
    talk about how we can fetch data out of it. We're going to be using this technique
    in the Todo API. People are going to want to populate a list of all the Todo items
    they need, and they might want to fetch the details about an individual Todo item.
    All of this is going to require that we can query the MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching todos in Robomongo file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''re going to create a new file based off of `mongodb-connect`. In this
    new file, instead of inserting records, we''ll fetch records from the database.
    I''m going to create a duplicate, calling this new file `mongodb-find`, because
    `find` is the method we''re going to use to query that database. Next, we can
    go ahead and remove all of the commented-out code that currently inserts records.
    Let''s get started by trying to fetch all of the Todos out of our Todos collection.
    Now, if I head over to Robomongo and open up the `Todos` collection, we have just
    one record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2f51586-1c3b-4789-bdef-5628eaa6ce3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to make this querying a little more interesting, we''re going to go
    ahead and add a second one. Right in the Robomongo window, I can click Insert
    Document. Robomongo can delete, insert, update, and read all of your documents,
    and this makes it a fantastic tool for debugging. We can add a new document on
    the fly, with a `text` property equal to `Walk the dog`, and we can also tack
    on a `completed` value. I''m going to set `completed` equal to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now by default, we''re not going to provide an `_id` prop. This is going to
    let MongoDB automatically generate that ObjectId, and right here we have our two
    Todos:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98401436-3619-4b3e-ade6-1924c766d1fe.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, let's go ahead and run our first query inside of Atom.
  prefs: []
  type: TYPE_NORMAL
- en: The find method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Atom, what we''re going to do is access the collection, just like we did
    inside of the `mongodb-connect` file using `db.collection`, passing in the collection
    name as the string. This collection is going to be the `Todos` collection. Now,
    we''re going to go ahead and use a method available on collections called `find`.
    By default, we can call `find` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we''re not providing a query, so we''re not saying we want to fetch
    all `Todos` that are completed or not completed. We''re just saying we want to
    fetch all `Todos`: everything, regardless of its values. Now, calling find is
    only the first step. `find` returns a MongoDB cursor, and this cursor is not the
    actual documents themselves. There could be a couple of thousand, and that would
    be really inefficient. It''s actually a pointer to those documents, and the cursor
    has a ton of methods. We can use those methods to get our documents.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common cursor methods we're going to be using is `.toArray.`
    It does exactly what you think it does. Instead of having a cursor, we have an
    array of the documents. This means we have an array of objects. They have ID properties,
    text properties, and completed properties. This `toArray` method gets us exactly
    what we want back, which is the documents. `toArray` returns a promise. This means
    we can tack on a `then` call, we can add our callback, and when things go right,
    we can do something like print those documents to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to get the documents as the first and only argument here, and
    we can also add an error handler. We''ll get passed an error argument, and we
    can simply print something to the screen like `console.log(Unable to fetch todos)`;
    as the second argument, we''ll pass in the `err` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, for the success case, what we're going to do is print the documents to
    the screen. I'm going to go ahead and use `console.log` to print a little message,
    `Todos`, and then I'll call `console.log` again. This time, we'll be using the
    `JSON.stringify` technique. I'll be passing in the documents, `undefined` for
    our filter function and `2` for our spacing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a script that is capable of fetching the documents, converting
    them into an array, and printing them to the screen. Now, for the time being,
    I''m going to comment out the `db.close` method. Currently, that would interfere
    with our previous bit of code. Our final code would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run it from the Terminal. Inside of the Terminal, I''m going
    to go ahead and run our script. Obviously, since we connected to the database
    with Robomongo, it is running somewhere; it''s running in this other tab. In the
    other tab, I can run the script. We''re going to run it through `node`; it''s
    in the `playground` folder, and the file itself is called `mongodb-find.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When I execute this file, we''re going to get our results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c47a41b-466f-4f2a-8554-d765a66781ee.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our `Todos` array with our two documents. We have our `_id`, our `text`
    properties, and our `completed` Boolean values. We now have a way to query our
    data right inside of Node.js. Now, this is a very basic query. We fetch everything
    in the `Todos` array, regardless of whether or not it has certain values.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a query to fetch certain values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to query based on certain values, let''s go ahead and switch up our
    `Todos`. Currently, both of them have a `completed` value equal to `false`. Let''s
    go ahead and change the `Walk the dog` completed value to `true` so we can try
    to just query items that aren''t completed. Over in Robomongo, I''m going to right-click
    the document and click Edit Document, and there we can edit the values. I''m going
    to change the `completed` value from `false` to `true`, and then I can save the
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3502cf4-287e-423b-bd7e-91e512b9dc29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside of the Terminal, I can rerun the script to prove that it has changed.
    I''m going to shut down the script by running *control* + *C*, and then I can
    rerun it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b94e60a9-afce-4a1a-b615-bc1a35291560.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we have our two `Todos`, one with a `completed`
    value of `false` and one with a `completed` value of `true`. By default, a Todo
    app is probably only going to show you the `Todos` collection you haven't completed.
    The ones you have completed, like `Walk the dog`, will probably be hidden, although
    they could be accessible if you clicked a button like Show all Todos. Let's go
    ahead and write a query that just fetches the `Todos` collection that have a `completed`
    status set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a query to fetch completed todos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get this done, inside of Atom, we''re going to make a change to how we call
    find. Instead of passing in `0` arguments, we''re going to pass in `1`. This is
    what''s known as our query. We can start specifying how we want to query the `Todos`
    collection. For example, maybe we want to query only `Todos` that have a `completed`
    value equal to `false`. All we have to do to query by value is set up the key-value
    pairs, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If I rerun our script over in the Terminal after shutting it down, we get just
    our one Todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c632bdf-9012-4b71-acf5-fdccbb9420ad.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our item with the `text` equal to `Something to do`. It has a `completed`
    status of `false`, so it shows up. Our other Todo with a `text` property of `Walk
    the dog` is not showing up because that one has been completed. It doesn't match
    the query, so MongoDB does not return it. This is going to come in handy as we
    start querying our documents based off of completed values, text properties, or
    IDs. Let's take a quick moment to look at how we can query one of our `Todos`
    by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Qureying todos by id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is remove everything from our query object; we
    no longer want to query by the `completed` value. Instead, we're going to query
    by the `_id` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to illustrate this, I''m going to grab the ID of the Todo with
    the `completed` value of `false` from the Terminal. I''m going to copy it using
    *command* + *C*. If you''re on Windows or Linux, you might need to right-click
    after highlighting the ID, and click Copy text. Now that I have the text inside
    of the clipboard, I can head over to the query itself. Now, if we try to add the
    ID like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is not going to work as expected because what we have inside of the ID property
    is not a string. It's an ObjectId, which means that we need to use the `ObjectID`
    constructor function that we imported previously in order to create an ObjectId
    for the query.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how that's going to happen, I'm going to go ahead and indent our
    object. This is going to make it a little easier to read and edit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I''m going to remove the string and call `new ObjectID`. The `new ObjectID`
    constructor does take an argument: the ID, in this case, we have it stored as
    a string. This is going to work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing here is we''re querying the Todos collection, looking for
    any records that have an `_id` property equal to the ID we have. Now, I can go
    ahead and save this file, give things a refresh by running the script again, and
    we''ll get the exact same Todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c40589de-95cc-48bc-bcfd-25d7c72ee229.png)'
  prefs: []
  type: TYPE_IMG
- en: I can go ahead and change it for the `Walk the dog` Todo by copying the string
    value, pasting that inside of the ObjectID constructor function, and rerunning
    the script. When I do this, I get the `Walk the dog` Todo returned because that
    was the ObjectId I queried.
  prefs: []
  type: TYPE_NORMAL
- en: Now, querying in this fashion is one of the ways we'll be using find, but there
    are other methods other than `toArray` that are available on our cursors. We can
    explore other ones by heading over to the docs for the native driver. Inside of
    Chrome, have the MongoDB docs pulled up—these are the docs I showed you how to
    access in the previous chapter—and on the left-hand side, we have the Cursor section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click that, we can view a list of all the methods available to us on
    that cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd2e42a1-88bf-4fc0-a885-e024cf5e2cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is what comes back from find. At the very bottom of the list, we have our
    `toArray` method. The one that we're going to look at right now is called count.
    From previous, you can go ahead and click count; it's going to bring you to the
    documentation; the documentation for the native driver is actually really good.
    There is a complete list of all the arguments that you can provide. Some of them
    are optional, some of them are required, and there is usually a real-world example.
    Next, we can figure out exactly how to use `count`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the count method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we're going to go ahead and implement `count` over inside of Atom. What
    I'm going to do is take the current query, copy it to the clipboard, and then
    comment it out. I'm going to go ahead and replace our call to `toArray` with a
    call to `count`. Let's go ahead and remove the query that we pass in to find.
    What we're going to do here is count up all of the Todos in the `Todos` collection.
    Instead of having a call to `toArray`, we're going to have a call to count instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw inside of the examples for count, they call count like this: calling
    count, passing in a callback function that gets called with an error, or the actual
    count. You can also have a promise as a way to access that data, which is exactly
    what we did with `toArray`. In our case, instead of passing a callback function
    like this, we''re going to use the promise instead. We already have the promise
    set up. All we need to do to fix this is change `docs` to `count`, and then we''re
    going to remove the `console.log` caller where we print the docs to the screen.
    Right after we print Todos, we''re going to print `Todos count`, with a colon
    passing in the value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is not a template string, but I am going to go ahead and swap it out with
    one, replacing the quotes with [PRE44]
  prefs: []
  type: TYPE_NORMAL
- en: db.collection('Todos').find({}).count().then((count) => {
  prefs: []
  type: TYPE_NORMAL
- en: 'console.log(`Todos count: ${count}`);'
  prefs: []
  type: TYPE_NORMAL
- en: '}, (err) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Unable to fetch todos', err);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'db.collection(''Users'').find({name: ''Andrew''})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'db.collection(''Users'').find({name: ''Andrew''}).toArray().then((docs) =>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(JSON.stringify(docs, undefined, 2));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: node_modules/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: git add .
  prefs: []
  type: TYPE_NORMAL
- en: git commit -m 'Init commit'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: git remote add origin https://github.com/garygreig/node-course-2-todo-api.git
  prefs: []
  type: TYPE_NORMAL
- en: git push -u origin master
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'text: ''Eat lunch'','
  prefs: []
  type: TYPE_NORMAL
- en: 'completed: false'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: //deleteMany
  prefs: []
  type: TYPE_NORMAL
- en: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: //deleteMany
  prefs: []
  type: TYPE_NORMAL
- en: 'db.collection(''Todos'').deleteMany({text: ''Eat lunch''}).then((result) =>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: node playground/mongodb-delete.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: //deleteOne
  prefs: []
  type: TYPE_NORMAL
- en: 'db.collection(''Todos'').deleteOne({text: ''Eat lunch''}).then((result) =>
    {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: //findOneAndDelete
  prefs: []
  type: TYPE_NORMAL
- en: 'db.collection(''Todos'').findOneAndDelete({completed: false}).then((result)
    => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  prefs: []
  type: TYPE_NORMAL
- en: db.collection('Users').findOneAndDelete({
  prefs: []
  type: TYPE_NORMAL
- en: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
  prefs: []
  type: TYPE_NORMAL
- en: '})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'db.collection(''Users'').deleteMany({name: ''Andrew''});'
  prefs: []
  type: TYPE_NORMAL
- en: db.collection('Users').findOneAndDelete({
  prefs: []
  type: TYPE_NORMAL
- en: '_id: new ObjectID("5a86978929ed740ca87e5c31")'
  prefs: []
  type: TYPE_NORMAL
- en: '}).then((results) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(JSON.stringify(results, undefined, 2));
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: git commit -m 'Add delete script'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: db.collection('Todos').findOneAndUpdate({
  prefs: []
  type: TYPE_NORMAL
- en: '_id: new ObjectID(''5a86c378baa6685dd161da6e'')'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '$set: {'
  prefs: []
  type: TYPE_NORMAL
- en: completed:true
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: 'returnOriginal: false'
  prefs: []
  type: TYPE_NORMAL
- en: '}).then((result) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: node playground/mongodb-update.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: db.collection('Todos').findOneAndUpdate({
  prefs: []
  type: TYPE_NORMAL
- en: '_id: new ObjectID(''57bc4b15b3b6a3801d8c47a2'')'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '$set: {'
  prefs: []
  type: TYPE_NORMAL
- en: completed:true
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: 'returnOriginal: false'
  prefs: []
  type: TYPE_NORMAL
- en: '}).then((result) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: db.collection('Users').findOneAndUpdate({
  prefs: []
  type: TYPE_NORMAL
- en: '_id: new ObjectID(''57abbcf4fd13a094e481cf2c'')'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: '$set: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: ''Andrew'''
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '$inc: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'age: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, {'
  prefs: []
  type: TYPE_NORMAL
- en: 'returnOriginal: false'
  prefs: []
  type: TYPE_NORMAL
- en: '}).then((result) => {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log(result);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: git add .
  prefs: []
  type: TYPE_NORMAL
- en: git commit -m 'Add update script'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: git push
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: With updating in place, we now have all of the basic CRUD (Creating, Reading,
    Updating, and Deleting) operations down. Up next, we're going to talk about something
    called Mongoose, which we'll be using for the Todo API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with connecting to MongoDB and writing data. We
    then went ahead to understand the `id` property in the context of MongoDB. After
    learning more about fetching data, we explored different methods to delete data
    in the documents.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to play more with Mongoose, MongoDB, and
    REST APIs.
  prefs: []
  type: TYPE_NORMAL
