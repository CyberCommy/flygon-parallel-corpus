- en: Chapter 2. Writing Your First Modular Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use modular programming techniques to implement a
    non-trivial program. Along the way, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the *divide and conquer* approach to program design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the tasks our program needs to perform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the information our program will need to store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply modular techniques to break our program down into individual parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure out how each part can be implemented as a separate Python module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the various modules work together to implement our program's functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow this process to implement a simple but complete inventory control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how modular techniques allow you to add functionality to your program while
    minimizing the changes that need to be made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inventory control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have been asked to write a program that allows the user to
    keep track of the company''s inventory—that is, the various items the company
    has available for sale. For each inventory item, you have been asked to keep track
    of the product code and the item''s current location. New items will be added
    as they are received, and existing items will be removed once they have been sold.
    Your program will also need to generate two types of reports: a report listing
    the company''s current inventory, including how many of each type of item there
    are in each location, and a report that is used to re-order inventory items once
    they have been sold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at these requirements, it is clear that there are three different types
    of information that we will need to store:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of the different types of **products** that the company has for sale.
    For each product type, we will need to know the **product code** (sometimes called
    an SKU number), a **description**, and the **desired number of items** that the
    company should have in its inventory for that type of product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A list of the **locations** where inventory items can be held. These locations
    might be individual shops, warehouses, or storerooms. Alternatively, a location
    might identify a particular shelf or aisle within a shop. For each location, we
    need to have a **location code** and a **description** identifying that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, a list of the **inventory items** that the company currently holds.
    Each inventory item has a **product code** and a **location code**; these identify
    the type of product and where the item is currently held.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When running the program, the end user should be able to perform the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new item to the inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an item from the inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a report of the current inventory items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate a report of the inventory items that need to be re-ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quit the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this program is not too complicated, there are enough features here to
    benefit from a modular design, while still keeping our discussion relatively brief.
    Now that we have taken a look at what our program needs to do and the information
    we need to store, let's start applying modular programming techniques to the design
    of our system.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the inventory control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you step back and review our inventory control program''s functionality,
    you can see that there are three fundamental types of activity that this program
    needs to support:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is very general, this breakdown is helpful because it suggests a
    possible way of organizing our program code. For example, the part of the system
    responsible for storing information could store the lists of products, locations,
    and inventory items and make this information available as required. Similarly,
    the part of the system responsible for interacting with the user could prompt
    the user to choose an action to perform, ask them to select a product code, and
    so on. Finally, the area of the system responsible for generating reports would
    be able to generate each of the desired types of report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about the system in this way, it becomes clear that each of these
    three *parts* of the system could be implemented as a separate module:'
  prefs: []
  type: TYPE_NORMAL
- en: The part of the system responsible for storing information could be called the
    **data storage** module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part of the system responsible for interacting with the user could be called
    the **user interface** module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part of the system responsible for generating reports could be called the
    **report generator** module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the names suggest, each of these modules perform a particular purpose. In
    addition to these special-purpose modules, we are going to need one more part
    to our system: a Python source file that the user executes to start up and run
    the inventory control system. Because this is the part the user actually runs,
    we will call this the **main program**, which is often stored in a Python source
    file named `main.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have four parts to our system: three modules plus a main program. Each
    of these parts will have a particular job to do, and the various parts will often
    interact to perform a particular function. For example, the report generator module
    will need to obtain a list of the available product codes from the data storage
    module. These various interactions are represented by arrows in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the inventory control system](graphics/B05012_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an idea of the overall structure for our program, let's take
    a closer look at each of these four parts to see how they will work.
  prefs: []
  type: TYPE_NORMAL
- en: The data storage module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module will be responsible for storing all of our program''s data. We
    already know that we''ll need to store three types of information: a list of **products**,
    a list of **locations**, and a list of **inventory items**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep our program as simple as possible, we will make two major design decisions
    regarding the data storage module:'
  prefs: []
  type: TYPE_NORMAL
- en: The lists of products and locations will be hardwired into our program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will hold the list of inventory items in memory and save it to disk whenever
    the list changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more sophisticated implementation of our inventory control system would store
    this information in a database and allow the user to view and edit the lists of
    product codes and locations. In our case, however, we are more interested in the
    overall structure of our program, so we want to keep the implementation as simple
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the list of product codes will be hardwired, we don''t necessarily want
    to build this list into the data storage module itself. The data storage module
    is responsible for storing and retrieving information—it isn''t the data storage
    module''s job to define the list of product codes. Because of this, we are going
    to need a function within the data storage module that can be called to set the
    list of product codes. This function will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already decided that for each product, we want to store the **product
    code**, a **description**, and the **desired number of items** that the user wants
    to keep in their inventory for that type of product. To support this, we''re going
    to define the list of products (as supplied in the `products` parameter to our
    `set_products()` function) as a list of `(code, description, desired_number)`
    tuples. For example, our list of products might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the list of products have been defined, we can provide a function to return
    this list as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This would simply return the list of products, allowing your code to work with
    this list as needed. For example, you can scan through the list of products using
    the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These two functions allow us to define the (hardwired) list of products and
    retrieve this list whenever we need it. Let's now define the equivalent two functions
    for the list of locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a function to set the hardwired list of locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each item in the `locations` list will be a `(code, description)` tuple, where
    `code` is the code for a location and `description` is a string describing the
    location so that the user knows where it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need a function to retrieve this list of locations as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this returns the list of locations, allowing us to work with these
    locations as required.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to decide on how the data storage module will allow the user to
    store and retrieve the list of inventory items. An inventory item is defined as
    a product code plus a location code. In other words, an inventory item is a particular
    type of product at a particular location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the list of inventory items, we''ll use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Following the design we used for the `products()` and `locations()` functions,
    the `items()` function will return a list of the inventory items, where each inventory
    item is a `(product_code, location_code)` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the lists of products and locations, however, the list of inventory
    items will not be hardwired: the user will be able to add and remove inventory
    items. To support this, we''re going to need two more functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one more part of our data storage module that we need to design:
    since we know that we''ll be storing the list of inventory items in memory and
    saving them to disk as required, we''re going to need some way of loading the
    inventory items from disk into memory when the program starts. To support this,
    we''re going to define an **initialization function** for our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve now decided on a total of eight functions for the data storage module.
    These eight functions make up the **public interface** for our module. In other
    words, the other parts of the system will *only* interact with our module using
    these eight functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The data storage module](graphics/B05012_2_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the process we went through here: we started by looking at what our
    module needed to do (in this case, storing and retrieving information) and then
    designed the module''s public interface based on those requirements. For the first
    seven functions, we used our business requirements to help us design the interface,
    while for the final function, `init()`, we used our knowledge of how the module
    will work internally to change the interface so that the module can do its job.
    This is a common way of working: both the business requirements and the technical
    requirements will help shape the module''s interface and how it interacts with
    the rest of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've designed our data storage module, let's repeat the process for
    the other modules in our system.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user interface module will be responsible for interacting with the user.
    This includes asking the user for information, as well as displaying information
    on the screen. To keep things simple, we will use a simple text-based interface
    for our inventory control system, using `print()` statements to display information
    and `input()` to ask the user to enter something.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated implementation of our inventory control system would use
    a graphical user interface with windows, menus, and dialog boxes. Doing this would
    make the inventory control system much more complicated and is well beyond the
    scope of what we are trying to achieve here. However, because of the modular design
    of the system, if we were to rewrite the user interface to use menus, windows,
    and the like, we would only be changing this one module—the rest of the system
    would be unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is actually a slight oversimplification. Replacing a text-based interface
    with a GUI requires many changes to the system, and would probably require us
    to change the module's public functions slightly, just like we had to add an `init()`
    function to the data storage module to allow for the way it worked internally.
    However, because of the modular way we're designing our system, the other modules
    would not be affected if we rewrote the user interface module to use a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about the various tasks our inventory control system needs to
    perform from the point of view of the user''s interaction with the system:'
  prefs: []
  type: TYPE_NORMAL
- en: The user needs to be able to select an action to perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user wants to add a new inventory item, we need to prompt the user
    for the details of the new item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user wants to remove an inventory item, we need to prompt the user
    for the details of the inventory item to remove.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user wishes to generate a report, we need to be able to display the
    contents of the report to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s work through these interactions one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To select an action to perform, we''ll have a `prompt_for_action()` function
    which returns a string identifying the action that the user wishes to perform.
    Let''s define the codes that this function can return for the various actions
    the user can perform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Action | Action code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Add an inventory item | `ADD` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove an inventory item | `REMOVE` |'
  prefs: []
  type: TYPE_TB
- en: '| Generate a report of the current inventory items | `INVENTORY_REPORT` |'
  prefs: []
  type: TYPE_TB
- en: '| Generate a report of the inventory items that need to be re-ordered | `REORDER_REPORT`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Quit the program | `QUIT` |'
  prefs: []
  type: TYPE_TB
- en: 'To add an inventory item, the user will need to be prompted for the details
    of the new item. Because an inventory item is defined as a given product at a
    given location, we actually need to prompt the user to choose both the product
    and the location for the new item. To prompt the user to select a product, we
    will use the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The user will be shown a list of the available products and then choose an item
    from the list. If they cancel, `prompt_for_product()` will return `None`. Otherwise,
    it will return the product code for the selected product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, to prompt the user to select a location, we will define the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this displays a list of the available locations, and the user can
    choose a location from the list. If they cancel, we return `None`. Otherwise,
    we return the location code for the selected location.
  prefs: []
  type: TYPE_NORMAL
- en: Using these two functions, we can ask the user to identify a new inventory item,
    and then we use the data storage module's `add_item()` function to add it to the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are implementing this as a simple text-based system, the process
    of removing an inventory item is almost identical to the process used to add an
    item: the user will be prompted for the product and location, and the inventory
    item at that location will be removed. Because of this, we won''t need any additional
    functions to implement this feature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate a report, we will simply call the report generator module to do
    the work, and then we display the resulting report to the user. To keep things
    simple, our reports won''t take any parameters, and the resulting report will
    be displayed in plain-text format. Because of this, the only user interface function
    that we will need is a function to display the plain-text contents of the report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `report` parameter will simply be a list of strings containing the generated
    report. All the `show_report()` function needs to do is print out these strings,
    one at a time, to show the contents of the report to the user.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our design for the user interface module. There are a total of
    four public functions which we will need to implement for this module.
  prefs: []
  type: TYPE_NORMAL
- en: The report generator module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The report generator module is responsible for generating reports. Since there
    are two types of report that we need to be able to generate, we are simply going
    to have two public functions in the report generator module, one for each type
    of report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Each of these functions will generate a report of the given type, returning
    the report's contents as a list of strings. Note that there are no parameters
    to these functions; because we are keeping things as simple as possible, the reports
    won't use any parameters to control how they are to be generated.
  prefs: []
  type: TYPE_NORMAL
- en: The main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main program isn't a module. Instead, it is a standard Python source file
    that the user runs to start the system. The main program will import the various
    modules it needs, and call the functions we have defined to do all the work. In
    a sense, our main program is the glue that binds together all the other parts
    of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, when a source file is intended to be run (as opposed to being imported
    and used by other modules or from the Python command line), it is common to use
    the following structure for the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: All of the program's logic is written inside the `main()` function, which is
    then called by the final two lines in the file. The `if __name__ == "__main__"`
    line is a piece of Python magic that basically means *if this program is being
    run*. In other words, if the user is running this program, call the `main()` function
    to do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could put all the program's logic beneath the `if __name__ == "__main__"`
    statement, but there are some advantages to putting our program's logic in a separate
    function. By using a separate function, we can simply return from this function
    when we want to exit. It also makes error handling easier, and the code is better
    organized because our main program code is separate from the code that checks
    whether we are actually running the program.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use this design for our main program, putting all the actual
    functionality within a single function called `main()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main()` function is going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `init()` function for the various modules which need to be initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the hardwired lists of products and locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask the user interface module to prompt the user for a command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respond to the command entered by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 3 and 4 will be repeated indefinitely until the user quits.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the inventory control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good idea of the overall structure for our system, what our
    various modules will be, and what functionality they will provide, it's time for
    us to start implementing the system. Let's start with the data storage module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data storage module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a directory somewhere convenient where you can store the source code
    for the inventory control system. You might want to call this directory `inventoryControl`
    or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this directory, we will place our various modules and files. Start by
    creating a new, empty Python source file named `datastorage.py`. This Python source
    file will hold our data storage module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When selecting the name for our modules, we are following the Python convention
    of using all lowercase letters. You might find this a bit awkward at first, but
    it soon becomes easy to read. Please refer to [https://www.python.org/dev/peps/pep-0008/#package-and-module-names](https://www.python.org/dev/peps/pep-0008/#package-and-module-names)
    for more information about these naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that we are going to need eight different functions to make
    up the public interface to this module, so go ahead and add the following Python
    code to this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `pass` statements allow us to leave the functions empty—these are just placeholders
    for the code we are going to write.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement the `init()` function. This initializes the data storage
    module when the system is run. Because we are holding the list of inventory items
    in memory and saving them to disk when they change, our `init()` function is going
    to have to load the inventory items from a file on disk back into memory so that
    they will be available when we need them. To do this, we'll define a private function,
    which we'll call `_load_items()`, and call this from our `init()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that a leading underscore means that something is private. This means
    that the `_load_items()` function won't be part of the public interface for our
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your definition of the `init()` function to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_load_items()` function is going to load the list of inventory items from
    a file on disk into a private global variable, which we''ll call `_items`. Let''s
    go ahead and implement this function now, by adding the following to the end of
    the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we store the list of inventory items in a file named `items.json`,
    and that we are using the `json` module to convert the `_items` list from a text
    file into a Python list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON is an excellent way of saving and loading Python data structures, and the
    resulting text file is easy to read. Since the `json` module is built into the
    Python Standard Library, we might as well make use of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are now using some modules from the Python Standard Library, you''ll
    need to add the following `import` statements to the top of your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, let''s write a function to save the list of inventory items
    to disk. Add the following to the end of your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have loaded the list of inventory items into a private global variable
    named `_items`, we can now implement the `items()` function to make this data
    available. Edit your definition of the `items()` function to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement the `add_item()` and `remove_item()` functions to let
    the rest of the system manipulate our list of inventory items. Edit these functions
    so they look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `remove_item()` function returns `True` if the item was successfully
    removed and `False` otherwise; this tells the rest of the system if an attempt
    to remove an inventory item was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: We've now implemented all the functions within the `datastorage` module that
    relate to inventory items. Next, we'll implement the product-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know we''re going to hardwire the list of products, the `set_products()`
    function is going to be trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply store the list of products in a private global variable named `_products`.
    We can then make this list available via the `products()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can now implement the `set_locations()` function to set the hardwired
    list of locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can implement the `locations()` function to make this information
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This completes our implementation of the `datastorage` module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user interface module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the user interface module is going to be kept as simple
    as possible, using `print()` and `input()` statements to interact with the user.
    In a more comprehensive implementation of this system, we would use a graphical
    user interface (GUI) to display and ask the user for information, but we want
    to keep our code as simple as we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s go ahead and implement the first of our user interface
    module functions. Create a new Python source file named `userinterface.py` to
    hold our user interface module, and add the following to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we prompt the user to type a letter corresponding to each action,
    displaying the list of available actions and returning a string which identifies
    the action the user selected. This is not a great way of implementing a user interface,
    but it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we want to implement is `prompt_for_product()`, which asks
    the user to select a product from the list of available product codes. To do this,
    we are going to have to ask the data storage module for the list of products.
    Add the following code to the end of your `userinterface.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we display a list of the products along with a number beside
    each product. The user then enters the number for the desired product, and we
    return the product code to the caller. If the user didn't enter anything, we return
    `None`—this lets the user press the *Enter* key without entering anything if they
    don't want to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s implement the equivalent function which asks the
    user to identify a location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this function displays a number beside each location and asks the
    user to enter the number for the desired location. We then return the location
    code for the selected location, or `None` if the user cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since these two functions make use of the data storage module, we''re going
    to have to add the following `import` statement to the top of our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one more function we need to implement: the `show_report()` function.
    Let''s do this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are implementing this using a text interface, this function is almost
    ludicrously simple. It does serve an important purpose though: by implementing
    the process of showing a report as a separate function, we can re-implement this
    function to show the report in a more useful way (for example, displaying it in
    a window within a GUI) without affecting the rest of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the report generator module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The report generator module is going to have two public functions, one to generate
    each type of report. Without further ado, let''s implement this module, which
    we will store in a Python source file named `reportgenerator.py`. Create this
    file, and enter the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about the details of these functions. As you can see, we
    take the list of inventory items, the list of products, and the list of locations
    from the data storage module, and generate a simple text-based report based on
    the contents of these lists.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final part of the system we need to implement is our main program. Create
    another Python source file named `main.py`, and enter the following into this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just the overall template for our main program: we import the various
    modules we created, define a `main()` function where all the work will be done,
    and call it when the program is run. We now need to write our `main()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first task is to initialize the other modules and define the hardwired
    lists of products and locations. Let''s do this now, by rewriting our `main()`
    function to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to ask the user for the action they wish to perform, and then
    respond appropriately. We''ll start by asking the user for the action, using a
    `while` statement so that this can be done repeatedly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We next need to respond to the action that the user selected. Obviously, we
    need to do this for each possible action. Let''s start with the `QUIT` action:'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` statement will exit the `while True` statement, which has the effect
    of leaving the `main()` function and shutting down the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to implement the `ADD` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we call the user interface functions to prompt the user for a product
    and then a location code, only proceeding if the function didn't return `None`.
    This means we only prompt for a location or add the item if the user didn't cancel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the equivalent function for the `REMOVE` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost identical to the logic for adding an item, with one exception:
    the `datastorage.remove_item()` function can fail (by returning `False`) if there
    is no inventory item for that product and location code. As the comment beside
    the `pass` statement suggests, we are going to have to do something when this
    happens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now reached a very common point in the modular programming process:
    we designed all the functionality that we thought we needed, but then discovered
    that we missed something. When the user attempts to remove a non-existent inventory
    item, we will want to display an error message so the user knows what went wrong.
    Because all user interaction takes place within the `userinterface.py` module,
    we will want to add this functionality to that module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do that now. Go back and edit the `userinterface.py` module, and add
    the following function to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, this is an embarrassingly simple function, but it lets us keep
    all user interaction within the `userinterface` module (and allows for the possibility
    of rewriting our program later on to use a GUI). Let''s now replace that `pass`
    statement within our `main.py` program with some appropriate error-handling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Having to go back and change the functionality for a module is extremely common.
    Fortunately, modular programming makes this process much more self-contained,
    so you're less likely to get side-effects and other errors when you do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the user can add and remove inventory items, there are just two more
    actions we need to implement: the `INVENTORY_REPORT` action, and the `REORDER_REPORT`
    action. For both of these actions, all we need to do is call the appropriate report
    generator function to generate the report, followed by the user interface module''s
    `show_report()` function to display the results. Let''s do this now, by adding
    the following code to the end of our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This completes the implementation of our `main()` function, and indeed the implementation
    of our entire inventory control system. Go ahead and run it. Try entering a few
    inventory items, removing an inventory item or two, and generating both types
    of report. If you have entered the code as presented in this book or downloaded
    the example code for this chapter, the program should work, giving you a simple
    but complete inventory control system—but more importantly, showing you how to
    implement a program using modular programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed and implemented a non-trivial program to keep track
    of a company's inventory. Using the divide-and-conquer approach, we split the
    program into individual modules and then looked at the functionality that each
    module would need to provide. This led us to a more detailed design of the functions
    within each module, and we were then able to implement the overall system one
    step at a time. We discovered that some functionality had been overlooked and
    had to be added after the design was complete, and saw how modular programming
    makes it less likely for these types of changes to break your system. Finally,
    we had a quick play with the inventory control system to make sure it works.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about the nuts and bolts of how modules
    and packages work within Python.
  prefs: []
  type: TYPE_NORMAL
