- en: Sound FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current state of sound on the web is a bit of a mess and has been for quite
    a while. For a long time, there were issues with loading MP3 versus OGG files
    based on which browser you were using. Recently, there have been issues with browsers
    blocking sounds that play automatically to prevent annoying audio spam. This feature
    in Chrome sometimes seems to create problems when playing audio in our game. I
    have noticed that, if Chrome does not initially play the audio, it will usually
    play if you reload the page. I have not had this problem on Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to include several images and audio files in your build to make
    this project work. Make sure that you include the `/Chapter12/sprites/` folder
    as well as the `/Chapter12/audio/` folder from the project's GitHub. If you haven't
    yet downloaded the GitHub project, you can get it online at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).
  prefs: []
  type: TYPE_NORMAL
- en: Emscriptenâ€™s support for audio playback is not as good as I would like it to
    be. On the message boards, Emscripten's defenders are quick to blame the state
    of audio on the web as opposed to Emscripten itself, and there is some truth to
    that assessment. Emscripten's FAQ claims that Emscripten supports the use of SDL1
    Audio, SDL2 Audio, and OpenAL, but, in my experience, I have found that using
    a very limited set of SDL2 Audio provides the best outcomes. I am going to keep
    our use of SDL2 Audio to a minimum, using the audio queue instead of mixing sound
    effects. You may wish to expand on or modify what I have done here. OpenAL, in
    theory, should work with Emscripten, although I have not had much luck with it.
    Also, you may wish to look into `SDL_MixAudio` ([https://wiki.libsdl.org/SDL_MixAudio](https://wiki.libsdl.org/SDL_MixAudio))
    and `SDL_AudioStream` ([https://wiki.libsdl.org/Tutorials/AudioStream](https://wiki.libsdl.org/Tutorials/AudioStream))
    to improve the audio system in your game, but be aware that performance and support
    for streaming and mixing audio on the web may not be ready for prime time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Where to get sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple audio with Emscripten
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sound to our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where to get sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of great places to get music and sound effects online. I generated
    the sound effects we use in this chapter with SFXR ([http://www.drpetter.se/project_sfxr.html](http://www.drpetter.se/project_sfxr.html)),
    which is a tool used to generate old school 8-bit sound effects that sound like
    something you would hear in an NES game. These kinds of sound effects may not
    be to your taste. OpenGameArt.org also has a large collection of sound effects
    ([https://opengameart.org/art-search-advanced?keys=&field_art_type_tid%5B%5D=13&sort_by=count&sort_order=DESC](https://opengameart.org/art-search-advanced?keys=&field_art_type_tid%5B%5D=13&sort_by=count&sort_order=DESC))
    and music ([https://opengameart.org/art-search-advanced?keys=&field_art_type_tid%5B%5D=12&sort_by=count&sort_order=DESC](https://opengameart.org/art-search-advanced?keys=&field_art_type_tid%5B%5D=12&sort_by=count&sort_order=DESC))
    with a variety of open licenses, so make sure that you look over the license of
    any sounds or art on that website before you use it.
  prefs: []
  type: TYPE_NORMAL
- en: Simple audio with Emscripten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add sound effects to our main game, I will show you how to make an
    audio player in the `audio.c` file to demonstrate how **SDL Audio** can be used
    to play sound effects in a WebAssembly application. This application will take
    five sound effects that we will use in our game and allow the user to press number
    keys one to five to play all of the chosen sound effects. I will first show you
    the code broken into two sections, and then I will walk you through what everything
    does. Here is all of the code in `audio.c` with the exception of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `audio.c` file we have our `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have seen the entire audio.c file, let''s take a look at all of
    its parts. At the top of this file, we have our `#include` and `#define` macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have our SDL specific-global variables. We need an `SDL_AudioDeviceID`
    for our audio output. `SDL_Window`, `SDL_Renderer` and `SDL_Event` have been used
    in most of the earlier chapters and should be familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are working on a C program, not a C++ program, so we will be using a structure
    to hold our audio data instead of a class. We will create a C structure called
    `audio_clip` that will hold all of the information for the audio we will be playing
    in our application. This information includes a string holding the filename. It
    contains an `SDL_AudioSpec` object that holds the audio specification. It also
    contains the length of the audio clip and a pointer to an 8-bit data buffer, which
    holds the waveform data of the audio clip. After the `audio_clip` structure is
    defined, five instances of that structure are created that we will later be able
    to use to play these sounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After we define the `audio_clip` structure, we need to create a function to
    play the audio in that structure. This function calls `SDL_QueueAudio` passing
    in the global `device_id`, a pointer to the waveform buffer, and the length of
    the clip. The `device_id` is a reference to the audio device (sound card). The
    `clip->buf` variable is a pointer to a buffer that contains the waveform data
    of the `.wav` file we will be loading. The `clip->len` variable contains the length
    of time that the clip plays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function we need is the function that initializes our `audio_clip`
    so that we can pass it into the `play_audio` function. This function sets the
    filename of our `audio_clip` and loads a wave file setting the `spec`, `buf`,
    and `len` values in our `audio_clip`. If the call to `SDL_LoadWAV` fails, we print
    out an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input_loop` should look pretty familiar by now. The function calls the
    `SDL_PollEvent` and uses the event it returns to check for a keyboard key release.
    It checks to see which key is released. If that key is one of the number keys
    from one to five, a switch statement is used to call the `play_audio` function,
    passing in a specific `audio_clip`. The reason we are using the key release instead
    of the key press is to prevent the key repeat when the user holds the key down.
    We could easily prevent this, but I am trying to keep the code for this application
    as short as possible. Here is the `input_loop` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, the `main` function does all of the initialization for our application.
    In addition to the initialization that we executed in previous applications, we
    need a new initialization for our audio. This is what the new version of the `main`
    function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we changed was our call to `SDL_Init`. We needed to add a flag
    telling SDL to initialize the audio subsystem. We did this by adding `|SLD_INIT_AUDIO`
    to the parameter we passed in, which performs a bitwise operation on the parameter
    with the `SDL_INIT_AUDIO` flag. Following the new version of `SDL_Init`, we will
    create the window and renderer, which we have done many times at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init_audio` calls are all new and initialize our `audio_clip` structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to call `SDL_OpenAudioDevice` and retrieve a device ID. Opening
    an audio device requires a default spec, which informs the audio device of the
    quality of sound clip that you would like to play. Make sure that you pick a sound
    file with a quality level that is a good example of what you would like to play
    in your game. In our code, we chose `enemy_laser_snd`. We also need to call `SDL_PauseAudioDevice`.
    Whenever you create a new audio device, it is paused by default. Calling `SDL_PauseAudioDevice`
    and passing in `0` as the second parameter unpauses the audio device we just created.
    I found this a little confusing at first, but keep in mind that the following
    call to `SDL_PauseAudioDevice` is actually unpausing the audio clip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we will do before returning is set our loop to be the `input_loop`
    function we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our code, we should compile and test our `audio.c` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We need to preload the audio folder so that we have access to the `.wav` files
    in our virtual filesystem. Then, load `audio.html` in a web browser, serving the
    file with emrun, or with an alternative web server. When you load the application
    in Chrome, you may run into some minor difficulties. New versions of Chrome have
    added checks to prevent unrequested audio from playing to prevent some of the
    irritating spam that has been going around. Sometimes, this check is a little
    too sensitive, and this can prevent the audio in our game from running. If this
    happens to you, try reloading the page in the Chrome browser. Sometimes, this
    fixes the problem. Another way to prevent this from happening is to switch over
    to Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an understanding of how to get SDL Audio to work on the web,
    we can start adding sound effects to our game. We will not be using a mixer in
    our game, so only one sound effect will play at a time. Because of this, we will
    need to classify some sounds as **priority** sound effects. If a priority sound
    effect is triggered, the sound queue will clear, and that sound effect will run.
    We also want to prevent our sound queue from becoming too long, so we will clear
    our sound queue if there are more than two items in it. Do not fear! I will repeat
    all of this when we get to that part of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating game.hpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will need to change is our `game.hpp` file. We need to add
    a new `Audio` class, as well as other new code to support audio in our game. Near
    the top of the `game.hpp` file, we will add a series of `#define` macros to define
    the location of our sound effect `.wav` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of our list of class declarations, we should add a new declaration
    of a class called `Audio`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then define the new `Audio` class, which will be very similar to the
    `audio_clip` structure that we used in our `audio.c` file. This class will have
    a filename, a spec, a length (in runtime), and a buffer. It will also have a priority
    flag that, when set, will give it priority over everything else that is currently
    in our audio queue. Finally, we will have two functions in this class; a constructor
    that will initialize the sound, and a `Play` function that will actually play
    the sound. This is what the class definition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to define some external audio related to global variables.
    These global variables will be references to the variables that will appear in
    our `main.cpp` file. Most of these are instances of the `Audio` class, which will
    be used in our game to play audio files. The last of these variables is a reference
    to our audio device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Updating main.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do in our `main.cpp` file is define the audio-related
    global variables that we defined as external variables at the end of the `game.hpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of these sound effects are related to explosions that occur when there
    is a collision in our game. Because of this, we will be adding calls to play these
    sound effects throughout our `collisions` function. This is what the new version
    of our `collisions` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Sounds will now play after several explosions and collisions; for example,
    after the player explodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sound will also play when the enemy ship explodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After an asteroid explodes, we will want the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If an enemy shield is hit, we want to play the `hit` sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the player''s shield is hit, we will, again, want to play the
    `hit` sound:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the `main` function to initialize our audio. Here
    is the entire `main` function code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first change we need to make to the `main` function is to the `SDL_Init`
    call to include the initialization of the audio subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The other change we need to make is the addition of the new `Audio` objects
    and the call to `SDL_OpenAudioDevice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Updating ship.cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ship.cpp` file has one minor change to it. We are adding a call to play
    a sound when the ship launches a projectile. That happens in the `Ship::Shoot()`
    function. You will notice that the call to `player_laser_snd->Play()` occurs after
    the call to `projectile->Launch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new audio.cpp file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are adding a new `audio.cpp` file to implement the `Audio` class constructor
    function and the `Audio` class `Play` function. Here is the `audio.cpp` file in
    its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first function in this file is the constructor for the `Audio` class. This
    function sets the `FileName` attribute to the value passed and sets the `priority`
    value. It also loads the wave file from the filename passed in and uses the `SDL_LoadWAV`
    file to set the `spec`, `buf`, and `len` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Audio::Play()` function first looks to see whether this is high-priority
    audio, or whether the size of the audio queue is greater than two sounds. If either
    of these is the case, we clear out the audio queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We are doing this because we do not want to mix the audio. We are playing the
    audio sequentially in a queue. If we have a priority audio clip, we want to clear
    out the queue so that the audio plays immediately. We also want to do this if
    the queue is too long. We will then call `SDL_QueueAudio` to queue up this sound
    to play as soon as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should be ready to compile and run our code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have made all the necessary changes to our code, we can compile
    and run our new code with Emscripten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are no new flags added to allow us to use the SDL Audio library. However,
    we need to add a new `--preload-file audio` flag to load the new `audio` directory
    into our virtual filesystem. Once you have compiled the new version of the game,
    you can run it using emrun (assuming that you included the necessary emrun flag
    when you compiled). If you prefer, you can choose a different web server to serve
    these files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the current (messy) state of audio on the web and have looked
    at the audio libraries available to Emscripten. I mentioned a few places where
    you can get free sound effects. We created a simple audio application using C
    and Emscripten that allowed us to play a series of audio files. We then added
    sound effects to our game, which included explosion and laser sounds. We modified
    our initialization code inside the `main()` function to initialize the SDL Audio
    subsystem. We added a new `Shoot` function to be used by our spaceships when they
    shoot projectiles. We also created a new `Audio` class to help us play our audio
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how we can add some physics to our game.
  prefs: []
  type: TYPE_NORMAL
