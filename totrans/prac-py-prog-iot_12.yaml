- en: Measuring Temperature, Humidity, and Light Levels
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we explored two methods of making color with RGB LEDs
    – using a common RGB LED and with an addressable APA102 RGB LED strip. We also
    learned how to use a simple OLED display and how PWM can be used to play music
    using a passive buzzer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at some common components and circuits for
    collecting environmental data, including temperature, humidity, whether it's dark
    or light, and how to detect moisture.
  prefs: []
  type: TYPE_NORMAL
- en: The circuits and code examples we will learn will be useful for building and
    experimenting with your own environmental monitoring projects. These circuits
    can be considered input or sensor circuits that measure environmental conditions.
    By way of example, you could combine the circuit ideas and examples from [Chapter
    7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning Things On and Off*, to
    switch on a pump to water a plant when the soil is dry, or switch on a low-voltage
    LED lamp when it gets dark. In fact, we have an example of a visualization platform
    in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml), *IoT Visualization
    and Automation Platforms*, where we will capture, record, and visualize historical
    temperature and humidity data using one of the circuits from this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, throughout this chapter, we will see practical examples of analog
    electronics and associated concepts such as a voltage divider, which we learned
    about in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer. *
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring temperature and humidity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting light
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting moisture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter09` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO Library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PiGPIO DHT**: DHT11 and DHT22 sensor library ([https://pypi.org/project/pigpio-dht](https://pypi.org/project/pigpio-dht))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adafruit ADS1115**: ADS1115 ADC library ([https://pypi.org/project/Adafruit-ADS1x15](https://pypi.org/project/Adafruit-ADS1x15))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x DHT11 (lower accuracy) or a DHT22 (higher accuracy) temperature and humidity
    sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x **LDR** (**Light Dependent Resistor**, also known as a photocell or photoresistor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resistors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 200 Ω resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 10kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 1kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 100kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x ADS1115 analog-to-digital converter module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External power sources – at a minimum, a 3.3 V/5 V breadboard-mountable power
    supply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring temperature and humidity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The measurement of temperature and related environmental properties is a common
    task, and there are many different types of sensors available for measuring these
    properties, including thermistors (a temperature-dependent resistor), sophisticated
    breakout modules that connect via SPI and I2C, and sensor varieties such as the
    DHT11 or DHT22 sensors, which we will be using for our example.
  prefs: []
  type: TYPE_NORMAL
- en: All sensors have their relative strengths and weaknesses when it comes to accuracy,
    response times (how fast we can rapidly get data from them), and cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'DHT sensors, as illustrated in *Figure 9.1,* are inexpensive, durable, and
    easy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c253eb8e-399c-433c-89a1-0b75bcae27fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – DHT11 and DHT22 temperature and humidity sensors
  prefs: []
  type: TYPE_NORMAL
- en: 'The DHT11 is a very common low-cost sensor. The DHT22 is its higher-accuracy
    cousin. Both are pin-compatible and will be suitable for our example. The pinouts
    of these sensors as illustrated in the preceding figure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vcc**: 3- to 5-volt power source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: Data pin that connects to a GPIO pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NC**: Not connected, meaning that this pin is not used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: Connects to ground'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the core similarities and differences between the DHT11 and DHT22:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **DHT 11** | **DHT 22** |'
  prefs: []
  type: TYPE_TB
- en: '| **Operating Voltage** | 3 to 5 volts | 3 to 5 volts |'
  prefs: []
  type: TYPE_TB
- en: '| **Operating Current** | µA (microamps) | µA (microamps) |'
  prefs: []
  type: TYPE_TB
- en: '| **Temperature Range** | 0 to 50° Celsius |  - 40 to 125° Celsius |'
  prefs: []
  type: TYPE_TB
- en: '| **Temperature Accuracy** | ±2% | ±0.5% |'
  prefs: []
  type: TYPE_TB
- en: '| **Humidity Range** | 20 - 80% | 0 - 100% |'
  prefs: []
  type: TYPE_TB
- en: '| **Humidity Accuracy** | ±5% | ±2% to 5% |'
  prefs: []
  type: TYPE_TB
- en: '| **Maximum Sampling Rate** | Faster – once every 1 second (1Hz) | Slower –
    once every 2 seconds (0.5Hz) |'
  prefs: []
  type: TYPE_TB
- en: As mentioned, the DHT11 and DHT22 sensors are pin-compatible. They differ only
    in their measurement accuracy and range. Either sensor will be suitable for the
    circuit we are about to create for measuring temperature and humidity.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DHT11/DHT22 circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin by creating the circuit illustrated in *Figure 9.2* on our breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/01dd0045-dc16-4245-9518-4e925dc9564a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – DHT sensor schematic
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the breadboard layout for this circuit that we are about to
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4420680a-9c43-4d09-94b5-4b8f6e40df03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – DHT sensor circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow, which match the numbered black circles in *Figure
    9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place your DHT11 or DHT22 sensor into your breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the 10kΩ resistor (R1) into the breadboard. One end of the resistor shares
    the same row as the DHT sensor's DATA pin. We will discuss this resistor and why
    it's marked as optional in *Figure 9.2* after we complete the circuit build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 3.3-volt pin on your Raspberry Pi to the positive rail of the power
    rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 10kΩ resistor (R1) to the positive power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the DHT Vcc pin to the positive power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin on your Raspberry Pi to the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND pin on the DHT sensor to the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the DHT sensor's DATA pin to the GPIO 21 on your Raspberry
    Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This now completes our DHT sensor circuit build.
  prefs: []
  type: TYPE_NORMAL
- en: In our circuit, Vcc is connected to 3.3 volts, which makes the DHT data pin
    operate at this voltage. DHT11 and DHT22 are rated for 5 volts; however, if you
    connected Vcc to 5 volts, the data pin becomes a 5-volt logic pin, which is not
    safe for use with the Raspberry Pi's 3.3-volt GPIO pin.
  prefs: []
  type: TYPE_NORMAL
- en: The 10kΩ pull-up resistor is optional because the DHT software library we are
    using already enables Raspberry Pi's internal pull-up resistor by default. I've
    included the pull-up resistor in the circuit schematic because it's included in
    the circuit examples in many DHT11/DHT22 datasheets. If you need a refresher on
    pull-up resistors, please revisit [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer.*
  prefs: []
  type: TYPE_NORMAL
- en: In our circuit and for the DHT11/DHT22, the leg labeled **NC** means **Not Connected**.
    NC is a common abbreviation used to indicate that a leg or terminal of a sensor,
    IC, or component is not internally connected to anything. However, when we are
    dealing with switches – including relays – a component leg or terminal labeled
    NC means the **Normally Closed** connection path...so always interpret NC in the
    context of the component you are looking at.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your circuit, we are ready to run and explore the code
    to measure temperature and humidity.
  prefs: []
  type: TYPE_NORMAL
- en: Running and exploring the DHT11/DHT22 code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the code found in the `chapter09/dht_measure.py` file, and the measured
    temperature and humidity will be printed to your terminal, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`temp_c` is the temperature in degrees Celsius.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temp_f` is the temperature in degrees Fahrenheit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`humidity` is the relative humidity percentage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid` indicates whether the reading is considered valid by way of an internal
    sensor checksum check. Readings where `value == False` must be abandoned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in the source file is concise and is fully replicated here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line 1, we import the DHT sensor library and instantiate it in line 2\.
    Update the line to match the DHT11 or DHT22 sensor you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In lines 3 and 4, we use the `pigpio-dht` library to request a temperature and
    humidity measurement from the sensor. A call to `read()` will query the sensor
    for measurement and will keep retrying for `retries` times if the measurements
    come back as `valid == False`. An alternative method for measurement is the `sample()`
    method, which will take many individual samples of the temperature and humidity
    and return a normalized measurement.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of `sample()`, especially for the less-accurate DHT11 sensor,
    is a more consistent temperature and humidity readings since outlier readings
    (random spikes) are removed; however, it does significantly increase the time
    it takes to read measurements – refer back to the *Maximum Sampling Rate* row
    in the table at the start of this section.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, for a DHT11 with a maximum sampling rate of 1 second, for 5 samples,
    the `sample(samples=5)` call will take approximately *1 second x 5 samples = 5
    seconds* to return, while a DHT22 with a 2-second sample rate will take about
    10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: DHT11 and DHT22 are pin-compatible; however, they are not software-compatible
    due to the way each sensor encodes its data while mixing up the software driver
    and sensor. For example, while a DHT22 sensor using a DHT11 library will generate
    results, they will be inaccurate (and it'll be pretty obvious – for example, saying
    your room is 650+ degrees Celsius!)
  prefs: []
  type: TYPE_NORMAL
- en: How easy was that! The DHT series are popular low-cost sensors that measure
    both temperature and humidity. For those cases where you need to perform more
    rapid readings, or you need to mount a sensor in hostile environments, such as
    in water or outside, directly exposed to the elements, you will certainly be able
    to find a sensor for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick rundown of the other ways temperature (and similar environmental)
    sensors can connect to your Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thermistors **are temperature-sensitive resistors that are very small and
    ideal for tight spaces, and you can get them in sealed packages for outside and
    in-liquid use. You can use them with a voltage-divider circuit (similarly to the
    **Light-Dependent-Resistor** (**LDR**) we will cover in the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many varieties of I2C and SPI sensors available that can be queried
    fast and may also have other additional on-board sensors, such as air pressure.
    These modules are typically larger and are probably best not exposed directly
    to the elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1-wire** temperature sensors are also compact and easily sealable and have
    the advantage that they can have long wires (100 meters plus).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we come to the end of this section on measuring temperature and humidity.
    Many environmental monitoring projects require you to measure temperature and
    humidity, and using a DHT11 or DHT22 with Raspberry Pi is an easy and cost-effective
    way to achieve this. We will revisit our DHT11/22 circuit again in [Chapter 13](861a1e79-2f40-4a60-bb40-82101ee42e63.xhtml),
    *IoT Visualization and Automation Platforms*, where we will integrate this sensor
    with an IoT platform to collect and monitor the temperature and humidity.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored temperature sensors, let's learn how to detect light.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting light
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting the presence or absence of light is easily achieved with a special
    type of resistor known as an **LDR**. LDRs are a low-cost light sensor, and we
    find them in many applications, from light-activated switches and lamps or as
    part of the circuit that dims your alarm clock display when it's dark, to part
    of alarm circuits on cash boxes and safes.
  prefs: []
  type: TYPE_NORMAL
- en: You may also find LDRs referred to as photoresistors or photocells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a typical LDR component, together with a few varieties
    of LDR schematic symbols. If you examine the symbols, you will notice that they
    are a resistor symbol with inward-pointing arrows. You can think of these arrows
    as representing light falling on the resistor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/717fa3cd-02f4-48cc-9136-f523fba717be.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – A physical LDR component and a variety of schematic symbols
  prefs: []
  type: TYPE_NORMAL
- en: 'An LDR varies its resistance with the relative light it detects. If you placed
    the terminals of your multimeter in Ohms mode across an LDR, you will find (roughly
    after a few seconds) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When the LDR is in the dark (for example, if you cover it up), its resistance
    will typically measure many mega-ohms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a normally lit room (for example, on the table with the ceiling lights on),
    the LDR's resistance will measure in kilo-ohms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an LDR is in bright light (direct sunlight or shining a torch on it), its
    resistance will measure a few hundred-ohms or less.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives us distinct regions where it becomes possible to work out the presence
    or absence of light. With calibration and a little tuning, we can easily identify
    a point between dark and light that we can use to trigger an event. For example, you
    could use an LDR circuit such as the one we will create next to programmatically
    control the switching circuits we created in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml),
    *Turning Things On and Off*.
  prefs: []
  type: TYPE_NORMAL
- en: LDRs are only good at measuring relative light levels – the presence or absence
    of light. If you want absolute measurements such as lux levels, or even to detect
    color, there is a range of ICs in the I2C or SPI breakout module form that can
    achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Using this basic understanding, we will build our LDR circuit to detect light.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an LDR light-detecting circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed, an LDR varies its resistance in relation to the relative light
    it detects. To detect varying resistance with our Raspberry Pi, we need to take
    a few steps that were covered in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to turn the varying resistance into a varying voltage because our Raspberry
    Pi GPIO pins work on voltage, not resistance. This is an application of Ohms law
    and a voltage-divider circuit, which we learned about in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our Raspberry Pi GPIO pins can only read digital signals – for example, a high
    (~3.3 volts) or low (~0 volts) signal. To measure a varying voltage, we can attach
    an **Analog-to-Digital Converter** (**ADC**) such as an ADS1115\. We covered the
    ADS1115 and accompanying Python code in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are about to create the circuit illustrated in *Figure 9.5* on your breadboard.
    This circuit and the accompanying code will illuminate the LED when it detects
    a certain level of darkness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eaeb9aaa-1cbf-494a-ae23-69a89cc62619.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – LDR circuit with the ADS1115 ADC schematic
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build our circuit in two parts. For the first part, we will place the
    components onto our breadboard, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3020fc7b-87db-4fd3-a3fa-54e718e837ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – LDR circuit with ADS1115 ADC circuit (part 1 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow, which match the numbered black circles in *Figure
    9.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the LDR onto the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 10kΩ resistor (R1) onto the breadboard. One end of this resistor shares
    the same row as one of the LDR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the ADS1115 ADC onto the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 200kΩ resistor (R2) onto the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place an LED onto the breadboard, paying careful attention to connect the LED's
    cathode leg to the same row shared by one of the legs of the 200kΩ resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have placed our components, we will wire them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32db5243-eb85-4ab3-bbc8-a737284be308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – LDR circuit with ADS1115 ADC circuit (part 2 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow; this time they match the numbered black circles
    in *Figure 9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the positive rail of the power rail to the LDR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a 3.3-volt pin from your Raspberry Pi to the positive rail of the power
    rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect a GND pin from your Raspberry Pi to the negative tail of the power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative power rail to the 10kΩ resistor (R1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Vdd terminal of the ADS1115 to the positive power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the GND terminal of the ADS1115 to the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the junction of the LDR and 10kΩ resistor (R1) to port A0 on the ADS1115
    (can you see how the LDR and resistor are creating a voltage divider, with the
    varying voltage output now attached to A0?).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Raspberry Pi's SDA pin to the ADS1115 SDA terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Raspberry Pi's SCL pin to the ADS1115 SCL terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative power rail to the 200kΩ resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode leg of the LED to your Raspberry Pi's GPIO 21 pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I hope you were able to see the voltage divider that was formed by the LDR and
    the 10kΩ resistor R1\. We will cover the reasoning behind the 10kΩ resistor later
    in the chapter in the section titled *LDR configuration summary.*
  prefs: []
  type: TYPE_NORMAL
- en: As the light detected by the LDR varies, its resistance varies. The effect of
    this is to alter the relative ratios of R1 (fixed resistor) and the LDR's resistance
    (varying resistance), which in turn changes the voltage measured at the interception
    of the LDR and R1 (that's where A (analog-in) of our ADS1115 is attached to measure
    this varying voltage).
  prefs: []
  type: TYPE_NORMAL
- en: Don't place your LED too close to your LDR. When it illuminates, the LED is
    a source of light that is detectable by the LDR, and it could interfere with your
    LDR readings in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have created the LDR circuit, we will calibrate and run our example
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Running the LDR example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are about to run two programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter09/ldr_ads1115_calibrate.py`, which will help us calibrate our LDR
    readings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter09/ldr_ads1115.py`, which monitors the light level and switches on
    the LED when the light falls below a configurable level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we should check that the ADS1115 is connected correctly and can be seen
    by your Raspberry Pi. Run the `i2cdetect` command in a Terminal. If your output
    does not include a number (for example `48`), then please verify your wiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We first covered the ADS1115 analog-to-digital converter and the `i2cdetect`
    utility in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting
    Your Raspberry Pi to the Physical World*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the examples, starting with the calibration program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code found in the `chapter09/ldr_ads1115_calibrate.py` file, and follow
    the instructions that appear on your terminal, which are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Place the LDR in the light and press Enter`: Use the ambient room light for
    this exercise, and be careful that you are not casting a shadow over the LDR.
    When you are building your application, you will want to use the source of light
    that makes sense for your purposes, be it direct sunlight, room light, or shining
    a bright torch into the LDR, for example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Place the LDR in the dark and press Enter`: I''d suggest completely covering
    the LDR with a dark cloth or cup. Using your finger is not always ideal as a sensitive
    LDR may still detect a level of light through your finger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The calibration program takes a number of samples (by default, `100`) from the
    ADS1115 in both the dark and light conditions and calculates the average reading.
    Next, the program writes the results (also shown in the terminal) into the `ldr_calibration_config.py` file.
    This is a Python source file for our example, imported into our actual LDR and
    LED example, as we will see in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program found in the `chapter09/ldr_ads1115.py` file, and observe the
    output on the terminal, which displays the voltage read by the ADS1115:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, the output should read `triggered = False`, and the LED should be
    off. If this is not the case, try repeating the calibration process in *step 1*,
    or read on and you'll discover how to adjust the trigger point in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradually move your hand nearer and nearer to the LDR restrict the amount of
    light reaching it. As you move your hand, you will notice the `voltage` reading
    on the terminal change, and at a certain voltage level, the trigger point will
    be reached and the LED will illuminate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What you are witnessing is the function of the voltage divider varying the voltage
    as the LDR's resistance changes in response to the light it detects. This voltage
    is then read by the ADS1115.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the voltage produced is not the full range of ~0 volts
    to ~3.3 volts as it was when we used a potentiometer with our ADS1115 back in[Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World.* Our restricted range is a side-effect and limitation of
    our fixed resistor (R1) and varying-resistance (LDR) circuit, which cannot vary
    resistance to the extremes necessary to reach ~0 or ~3.3 volts. You will encounter
    this restriction in voltage divider circuits since they will by design include
    a fixed resistor value. By contrast, our potentiometers are *two* variable resistors
    creating a voltage divider, and we can effectively zero-out (get close to 0 Ω)
    one side of the divider, depending on which direction we turn the potentiometer's
    dial, allowing us to get near to both 0 volts and 3.3 volts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen this code running, let's see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: LDR code walkthrough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bulk of the code in both `chapter09/ldr_ads1115_calibrate.py` and `chapter09/ldr_ads1115_calibrate.py`
    is the boilerplate code to set up and configure the ADS1115 and set up the LED
    using PiGPIO. We will not recover the common code here. If you need a refresher
    on the ADS1115-related code, please review the exercise found in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the Python code that makes our LDR work.
  prefs: []
  type: TYPE_NORMAL
- en: In line 1, we see that we are importing the `ldr_calibration_config.py` file that
    we created with our calibration program previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in line 2, we are assigning the calibration values to the `LIGHT_VOLTS`
    (the voltage detected by the ADS1115 when the LDR was in the light) and `DARK_VOLTS`
    (the voltage detected when you covered up the LDR) variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In line 3, we create a trigger point. This is a voltage point we will use later
    in code to switch on and off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust and experiment with the formula or value of `TRIGGER_VOLTS` to
    change the lighting condition that causes the code to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: The `TRIGGER_BUFFER` variable at line 4 is used to create a buffer or lag in
    our trigger, better known in electronic terms as *hysteresis.* This value creates
    a small window range where the detected voltage can vary without causing a trigger
    or un-trigger event. Without this *hysteresis,* the trigger (and LED) would turn
    on and off rapidly as the detected voltage oscillates around the `TRIGGER_VOLTS` trigger
    voltage.
  prefs: []
  type: TYPE_NORMAL
- en: To experience this effect practically, set `TRIGGER_BUFFER = 0` and you will
    find that as you move your hand above the LDR, the LED is very sensitive to on
    and off, and at a certain point may even appear to blink. As you increase the
    value of `TRIGGER_BUFFER`, you will notice that the hand movement required to
    switch the LED becomes on and off greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, in line 5, we come to the code that determines whether our trigger
    point has been reached. The `update_trigger()` function compares the voltage detected
    by the ADS1115 to the `TRIGGER_VOLTS` value adjusted for `TRIGGER_BUFFER`, and
    updates the `triggered` global variable if the triggering point is breached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Near the end of the source file, we have a `while` loop in line 6\. We are
    reading in the ADS1115 detected voltage, updating the global `triggered` variable,
    before printing the results to the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in line 7, we toggle the LED on or off depending on the value of `triggered`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how we detect light with our LDR circuit and Python code,
    I want to briefly cover how the series resistor is chosen for the LDR circuit.
  prefs: []
  type: TYPE_NORMAL
- en: LDR configuration summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have realized while working with the LDR circuit and code that there
    are a few tunable parameters that influence how the circuit and code work, and
    did you wonder why we used a 10kΩ resistor?
  prefs: []
  type: TYPE_NORMAL
- en: No two LDRs will give the same resistance-to-light measurement and their resistance-to-light
    range is not linear. The implication of this is that your LDR, plus the lighting
    conditions you plan to use it in, can influence a suitable fixed resistor value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rough guide to selecting an appropriate fixed resistor:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want the LDR to be more sensitive in **darker conditions**, use a **higher
    value** resistor (for example, try 100kΩ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want your LDR to be more sensitive in **brighter conditions**, use a **lower
    value** resistor (for example, try 1kΩ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that these are just suggestions, so feel free to try different resistances
    for your own needs. Plus, whenever you change the value of the fixed resistor,
    rerun the calibration code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a formula known as Axel Benz that can be used to calculate a
    reference resistance value for an analog component such as an LDR. The formula
    is expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cdf9980b-f0bc-40f1-b3b3-fc0dd8f1e862.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The parameters in the formula are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: R[ref] is the value of the fixed resistor, R1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R[max] is the maximum resistance of the LDR (when in dark). A typical value
    might be 10 Ω.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R[min] is the minimum resistance of the LDR (when in bright light). A typical
    value might be 10M Ω.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we use the typical values, we get the 10kΩ value we used for R1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/481f9d9c-b9b5-41e0-8472-fb56b9fefc1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Measure the extremes on your LDR with a multimeter and see what value you calculate.
    Do not be surprised if your measurements vary widely from the typical 10kΩ. When
    you consider we are working with an LDR ohmic range of ~10 Ω to ~10,000,000 Ω,
    the difference may still only be a fraction of a percent!
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw previously in the code that two variables influence how our code
    triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the value of `TRIGGER_VOLTS` to change the point at which the code triggers
    – for example, turns on or off the LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the value of `TRIGGER_BUFFER` to alter how sensitive the trigger is to
    changing light conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, remember that an LDR detects light logarithmically, not linearly –
    for example, as you gradually lower your hand or an object over the LDR to restrict
    light, the voltages reported by the LDR will not necessarily change in proportion
    to the amount of light you are restricting. This is a reason why we need to change
    the fixed resistor value if we want the LDR to be more sensitive in darker or
    brighter conditions.
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with replacing the fixed resistor, R1, with a variable resistor
    (for example, replace the fixed 10kΩ with a 20kΩ variable resistor set to 10kΩ.
    We choose 20kΩ because we can adjust it above and below 10kΩ. A 10kΩ variable
    resistor would only let us adjust down resistance). After code calibration at
    10kΩ and defining a trigger point in code, you can then fine-tune the trigger
    point by adjusting the variable resistor.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of LDRs. We have seen how to build a simple LDR
    circuit together with an ADS1115 ADC, and how to detect light with Python. You
    could use this simple circuit and accompanying code for any project where the
    detection of light or darkness is the desired input trigger – for example, a light-activated
    switch.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to detect moisture.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting moisture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Guess what...we have already done the grunt work to detect moisture! It's just
    another application of the LDR circuit and code, only we replace the LDR with
    probes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you can create a set of probes using two pieces of wire
    (with the ends stripped), and attach them in place of the LDR, as shown in *Figure
    9.8**.* This is the same circuit we built in the previous section and showed in *Figure
    9.7*, only this time, we have replaced the LDR with two wires. Let''s make this
    slight change now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8c00b245-fcee-4d98-8535-500def610e4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Moisture detection circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow, which match the numbered black circles in *Figure
    9.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the LDR from the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire (with both ends stripped) into a breadboard row that previously
    connected to one of the LDR's legs (in the illustration, this new wire connects
    back to 3.3 volts on your Raspberry Pi).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place another wire (with both ends stripped) into a breadboard row that previously
    connected the LDR's other leg (in the illustration, this new wire connects to
    the row shared by the 10kΩ resistor (R1)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This small change – replacing the LDR with bare wires – turns our circuit into
    a basic moisture-detecting circuit. Let's try the circuit out!
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter09` folder, you will find two files, named `moisture_calibrate.py`
    and `moisture_ads1115.py`. These files are almost identical to the LDR file set
    we used in the previous section, except I've changed the wording and variable
    names from `Light`/`Dark` to `Wet`/`Dry`. The core differences are marked by comments
    in the respective files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the similarity, we will not cover these source files and the moisture
    circuit in detail; however, for reference, these are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure the probe is dry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `moisture_calibrate.py` and follow the instructions to perform a voltage
    calibration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `moisture_ads1115.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the terminal output indicates `trigger=False` (the code triggers
    on the wet condition).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the probe in a cup of water (yes, it's safe to do this) and observe the
    voltage reading on the terminal change (It's also OK if the probes get shorted
    accidentally as it will not cause any damage).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the probes immersed in water, check whether the terminal output reads `trigger=True` (probe
    wet condition).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the trigger is still `True`, you will need to adjust the value of `TRIGGER_VOLTS` in
    the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also place the probe in dry dirt and observe the voltage readings. Slowly
    wet the dirt and the voltage reading should change. We now have the basis of a
    program to tell you when your plant needs watering!
  prefs: []
  type: TYPE_NORMAL
- en: So, why does this work? Simple – water is a conductor of electricity and is
    behaving like a resistor between our two probes.
  prefs: []
  type: TYPE_NORMAL
- en: Different water in different parts of the world and from different sources –
    for example, tap versus bottle – may conduct electricity differently. This means
    you might need to play with the value of the R1 resistor if your circuit is not
    responding well with the 10kΩ resistor. In addition, you can also experiment with
    the distance between the probe wires and their size.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude our discussion on moisture detection by comparing what we have
    just created with an off-the-shelf moisture detector that you can purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing detection options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How do our simple circuit and wire probes compare to a *water/moisture detection
    module* that you can find on retail sites such as eBay? These products typically
    contain a probe of some sort, plus a small electronic module. A picture of one
    of these modules, plus a few probes, are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1572e442-d4f1-43ee-8782-5104d3305278.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Moisture detection module and probes
  prefs: []
  type: TYPE_NORMAL
- en: The three probes pictured each have two terminals and are simply an exposed
    copper trace on a circuit board, analogous to the exposed wires we saw in our
    circuit in *Figure 9.8.* A key difference is that these probes expose a larger
    surface area and are therefore more sensitive. Furthermore, they are also likely
    to be less prone to corrosion (at least in the short-to-medium term) than two
    stripped wires.
  prefs: []
  type: TYPE_NORMAL
- en: You can connect these probes directly to the exposed wires in our circuit shown
    in *Figure 9.8 *to expand and enhance the detection capabilities of the circuit!
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss the electronic module (zoomed in and labeled in *Figure 9.9 *on
    the right-hand side).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a Vcc/Vin and a GND terminal, these modules *often* (not always,
    but often) have two output terminals or pins, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An *analog* output (in our example, this is labeled **A**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A  *digital* output (labeled **S**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that I am not providing instructions on how to connect the previously
    pictured module to your Raspberry Pi, but rather, I will keep the discussion general.
    There are many variations of these modules available and while their operation
    is similar, there can be differences in how they need to be wired. At this stage
    of the book, if you are comfortable with the basic principles of analog versus
    digital, voltage dividers, and ADC, you have all you need to understand and make
    an informed decision on how to interface these modules to a device such as a Raspberry
    Pi. A good starting place will be your modules' datasheet or any information provided
    at the place of purchase.
  prefs: []
  type: TYPE_NORMAL
- en: The *analog output* is a pass-through to the probe. You connect it directly
    into a voltage divider circuit and measure a varying voltage with an ADC such
    as the ADS1115 – the exact scenario we created in *Figure 9.8*. If you use the
    analog pass-through, you are bypassing all the other circuitry on the module (hence
    why you can just connect the probes directly into our example circuit).
  prefs: []
  type: TYPE_NORMAL
- en: The *digital output* is what uses the module circuitry. A typical module circuit
    includes, at a minimum, an integrated circuit known as a voltage comparator, a
    fixed resistor, and a variable resistor, which is a trigger-point trim adjustment.
    The fixed resistor together with the probe creates a voltage divider. The voltage
    comparator is responsible for monitoring the voltage across the voltage divider and
    triggering the digital output (for example, transition from `LOW` to `HIGH`) at
    a point determined by trim adjustment. An example of a trim adjustment variable
    resistor can be seen in *Figure 9.9*.
  prefs: []
  type: TYPE_NORMAL
- en: If this voltage comparison and triggering sounds a little familiar, you are
    correct. This module with its voltage comparator and configurable trigger point
    is, in principle, a purely electronic version of the LDR and moisture circuits
    and Python code we have created. And yes, you could use the LDR in one of these
    modules instead of a probe!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to conclude, what''s better – using an ADS1115 and voltage divider type
    circuit such as that shown in *Figure 9.8*, or using a module such as that pictured
    in *Figure 9.9*? There is no one best answer; however, the following points will
    help you make your own decision:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a circuit such as that in *Figure 9.8* is an analog approach. The raw
    voltage detected by the sensor is passed directly to your Raspberry Pi. One simple
    advantage of this approach is that you have full control over a *trigger* point
    in code. You could, as an example, remotely adjust the trigger point from a web
    page. The downside of this approach is that you need a more complex circuit that
    involves an ADS1115 and a voltage divider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a module such as that pictured in *Figure 9.9* as a digital approach promotes
    a simpler interfacing circuit to your Raspberry Pi in that you can connect the
    digital output terminal directly to a GPIO pin (as long as the digital output
    of the module 3.3-volts). The caveat is that you must have physical access to
    the module and the adjustment trim to change the trigger point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to measure temperature and humidity using the
    common DHT11 and/or DHT22 sensors. We also looked at how to use an LDR to detect
    light, and this allowed us to explore voltage divider circuits and ADCs in greater
    detail. We concluded by retrofitting our LDR circuit so that we could detect moisture.
  prefs: []
  type: TYPE_NORMAL
- en: The example circuits and code we covered in this chapter provide practical examples
    of measuring environmental conditions with readily available sensors and simple
    circuits. Your understanding of these sensors and circuits now means you can adapt
    the examples for your own environmental monitoring projects, including using them
    as input triggers together with Python to control other circuits.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw new practical applications of voltage divider circuits and how they
    are used in analog circuits to turn variable resistance into a variable voltage
    for use with an ADC. These examples and your understanding of them represent an
    important skill that you can adapt and use with other analog-based sensors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to go deeper into DC motor control and
    learn how to control a servo.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you list two differences between a DHT11 and DHT22 temperature and humidity
    sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the external 10kΩ pull-up resistor optional in our DHT11/22 circuit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe the basic electronic principle used with an LDR to measure light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make an LDR more or less sensitive to certain lighting conditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have created an LDR circuit and calibrated the Python code. Now, you change
    the LDR and find that the voltages readings and in-code trigger point behave slightly
    differently. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does placing two wires in water work as a basic moisture detector when used
    with a voltage divider and ADS1115 circuit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
