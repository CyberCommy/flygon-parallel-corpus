- en: Chapter 2. Analyzing Network Traffic with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traffic analysis is the process of intercepting and analyzing network traffic
    in order to deduce information from communication. The size of the packets exchanged
    between two hosts, details of the systems communicating, time and duration of
    communication are some of the valuable information to an attacker. In this chapter,
    we will learn how to analyze network traffic with Python scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Networking basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raw socket programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet sniffing with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet injection with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse DNS traffic with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS fingerprinting with Scapy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network sockets is a way to talk to other computers using standard Unix file
    descriptors, which allow communication between two different processes on the
    same or different machines. A socket is almost similar to a low-level file descriptor,
    because commands such as `read()` and `write()` also work with sockets as they
    do with files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two basic sockets modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Socket**: The standard BSD sockets API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SocketServer**: A server-centric module that defines classes for handling
    synchronous network requests that simplify the development of network servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `socket` module has almost everything you need to build a socket server
    or client. In the case of Python, the `socket` returns an object to which the
    socket methods can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Methods in socket module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The socket module has the following class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.socket(family, type)`: Create and return a new socket object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.getfqdn(name)`: Convert a string IP address to a fully qualified domain
    name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.gethostbyname(hostname)`: Resolve a hostname to an IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance methods** require a socket instance returned from `socket`. The
    `socket` module has the following instance methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sock.bind( (address, port) )`: Bind the socket to the address and port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.accept()`: Return a client socket with peer address information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.listen(backlog)`: Place the socket into the listening state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.connect( (address, port) )`: Connect the socket to the defined host and
    port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.recv( bufferLength[, flags] )`: Receive data from the socket, up to `buflen`
    (maximum bytes to receive) bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.recvfrom( bufferLength[, flags] )`: Receive data from the socket, up
    to `buflen` bytes, also returning the remote host and port from which the data
    came'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.send( data[, flags] )`: Send data through the socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.sendall( data[, flags] )`: Send data through the socket, and continues
    to send data until either all data has been sent or an error occurred'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.close()`: Close the socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.getsockopt( lvl, optname )`: Get the value for the specified socket option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sock.setsockopt( lvl, optname, val )`: Set the value for the specified socket
    option'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a socket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A socket can be created by making a call to the class method `socket()` in
    the `socket` module. This will return a socket in the domain specified. The parameters
    to the method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address family**: Python supports three address families.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AF_INET**: Used for IP version 4 or IPv4 Internet addressing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AF_INET6**: Used for IPv6 Internet addressing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AF_UNIX**: Used for **UNIX domain sockets** (**UDS**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Socket type**: Usually, socket type can be either `SOCK_DGRAM` for **User
    Datagram Protocol** (**UDP**) or `SOCK_STREAM` for **Transmission Control Protocol**
    (**TCP**). `SOCK_RAW` is used to create raw sockets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: Generally left at the default value. Default value is 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example for creating a socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to a server and sending data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The socket created can be used in both server-side or client-side.
  prefs: []
  type: TYPE_NORMAL
- en: The `connect()` method of socket object is used to connect the client to a host.
    This *instance method* accepts either the host name or a tuple, which contains
    the host name/address and port number as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding code to send a message to the server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Receiving data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need a server to receive data. To use a socket on the server side, the `bind()`
    method of the `socket` object binds a socket to an address. It takes a tuple as
    the input parameter, which contains the address to the socket and the port to
    listen for incoming requests. The `listen()` method puts the socket into listening
    mode and the method `accept()` waits for an incoming connection. The `listen()`
    method accepts a parameter representing the maximum number of queued connections.
    So by specifying this parameter to `3`, it means that if three connections are
    waiting to process, then the fourth connection will be rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Method `accept()` will return an active connection between the server and client.
    Data can be read from the connection using the `recv()` method, and can be transmitted
    using `sendall()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be better to keep the server live by putting `socket_accept` in a
    loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this to `server.py` and start the server as follows in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then server terminal might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Receiving data](img/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can modify the client script to receive a response from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this to `client.py` and run. Please make sure the server script is running.
    The client-side terminal might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Receiving data](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling multiple connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, we used the while loop to handle different clients;
    this can only interact with one client at a time. To make the server interact
    with multiple clients, we have to use multi-threading. When the `main` program
    accepts a connection, it creates a new thread to handle communication for this
    connection, and then goes back to accept more connections.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the threads module to create thread handlers for each connection
    that the server accepts.
  prefs: []
  type: TYPE_NORMAL
- en: '`start_new_thread()` takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A function name to be run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tuple of arguments to that function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how we can rewrite the preceding example with threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on socket modules, go to [https://docs.python.org/2.7/library/socket.html](https://docs.python.org/2.7/library/socket.html).
  prefs: []
  type: TYPE_NORMAL
- en: SocketServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SocketServer` is an interesting module, which is a framework for creating
    network servers. It has pre-defined classes for handling synchronous requests
    using TCP, UDP, UNIX streams, and UNIX datagrams. We can also create forking and
    threading versions of each type of server using the mix-in classes. In many cases,
    you can simply use one of the existing server classes. Five different server classes
    defined in `SocketServer` module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseServer`: Defines the API, not used directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TCPServer`: Uses TCP/IP sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UDPServer`: Uses datagram sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnixStreamServer`: Unix-domain stream sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnixDatagramServer`: Unix-domain datagram sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To construct a server with this module, we have to pass the address to listen
    (a tuple consisting of the address and port number) and a request handler class.
    Request handlers will receive incoming requests and decide what action to take.
    This class must have a method, which overrides any of the following `RequestHandler`
    methods; mostly, we can simply override a `handle()` method. A new instance of
    this class is created for each and every request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setup()`: Called before the `handle()` method to prepare the request handler
    for the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle()`: Parses the incoming requests, processes the data, and responds
    to the requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish()`: Called after the `handle()` method to clean up anything created
    during `setup()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple server with the SocketServer module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following script shows how we can use `SocketServer` to create a simple
    echo server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the script imports the `SocketServer` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we created a request handler that inherits the `SocketServer.StreamRequestHandler`
    class and overrides the `handle()` method to handle the requests for the server.
    The method `handle()` receives the data, prints it, and then responds the same
    to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This request handler class is instantiated for every request to the server.
    This server is created using the `SocketServer.TCPServer` class, where we provide
    the address to which the server will be bound and request the handler class. It
    will return a `TCPServer` object. Finally, we called the `serve_forever()` method
    to start the server and handle requests until we send an explicit `shutdown()`
    request (keyboard interrupt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on Socket module, go to [http://xahlee.info/python_doc_2.7.6/library/socketserver.html](http://xahlee.info/python_doc_2.7.6/library/socketserver.html).
  prefs: []
  type: TYPE_NORMAL
- en: Raw socket programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything we send and receive on the Internet involves packets; every web
    page and e-mail we receive comes as a series of packets, and everything we send
    leaves as a series of packets. Data breaks into packets of a certain size in bytes.
    Each packet carries the information to identify its destination, source, and other
    details of the protocols that the Internet uses, along with a part of the body
    of our data. Network packets are split into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header**: This contains the instructions about the data carried by the packet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload**: This is the data of a packet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trailer**: This is the trailer, notify the end of the packet to receiving
    device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers for protocols like TCP/IP are provided by the kernel or operating system
    stack, but we can provide custom headers to this protocol with raw sockets. Raw
    sockets have support in the native socket API in Linux, but support is absent
    in Windows. Even though raw sockets are rarely used in applications, they are
    extensively used in network security applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'All packets are structured in the same format consisting of, IP headers and
    a variable-length data field. First we have the Ethernet header, which is of a
    fixed size of 14 bytes, followed by the IP header if it is an IP packet, or TCP
    header if it is a TCP packet, based on the Ethernet type specified in the last
    two bytes of the Ethernet header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raw socket programming](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Ethernet header, the first six bytes are the destination host, followed
    by a six-byte source host. The final two bytes are the Ethernet type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raw socket programming](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The IP header is 20 bytes long; the first 12 bytes include version, **IHL**,
    **Total** **Length**, **Flags**, and so on, and the next four bytes represent
    the source address. Finally, the last four bytes are the destination address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raw socket programming](img/image_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on IP packet structure, go to [http://www.freesoft.org/CIE/Course/Section3/7.htm](http://www.freesoft.org/CIE/Course/Section3/7.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a raw socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a raw socket with Python, the application must have root privileges
    on the system. The following example creates a `IPPROTO_RAW` socket, which is
    a raw IP packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After creating a `raw` socket, we have to construct the packet which is to be
    sent. These packets are similar to structures in C, which are not available in
    Python, hence we have to use a Python `struct` module to pack and unpack packets
    in the structure specified previously.
  prefs: []
  type: TYPE_NORMAL
- en: Basic raw socket sniffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic form of a `raw` socket sniffer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we imported the socket module in the first line. Later we created
    a socket with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter indicates that the packet interface is `PF_PACKET(Linux
    specific, we have to use AF_INET for Windows)` and the second parameter specifies
    it is a raw socket. The third argument indicates the protocol we are interested
    in. The value `0x0800` specifies we are interested in the IP protocol. After that,
    we call the `recvfrom` method to receive the packet in an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can parse the `packet`, as the first 14 bytes are the Ethernet header,
    of which the first six bytes are the destination host and the next six bytes are
    the source host. Let''s rewrite the infinite loop and add code to parse the destination
    host and source host from the Ethernet header. First we can rip off the Ethernet
    header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can parse and unpack the header with `struct`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a tuple with three hex values in it. We can convert it to
    the hex value with `hexlify` in `binascii` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can get the IP header, which is the next 20 bytes in the packet.
    The first 12 bytes include version, IHL, Length, Flags, and so on, which we are
    not interested in, but the next eight bytes are the source and destination IP
    address as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The final script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will output the source and destination MAC addresses of the network card,
    as well as the source and destination IP of the packets. Make sure the packet
    interface set properly. `PF_PACKE` is Linux-specific, we have to use `AF_INET`
    for Windows. Similarly, we can parse the TCP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on the `struct` module, read [https://docs.python.org/3/library/struct.html](https://docs.python.org/3/library/struct.html).
  prefs: []
  type: TYPE_NORMAL
- en: Raw socket packet injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can send custom crafted packets with a raw socket. As we did before, we
    can create a raw socket with a socket module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To inject packets, we need to bind the socket to an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create an Ethernet packet using the pack method in `struct`, with
    the source address, destination address, and Ethernet type in it. Also, we can
    add some data to the packet and send it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole script to inject an IP packet will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Investigate network traffic with Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous sections, we sniffed and injected packets with raw sockets, where
    we have to do parsing, decoding, creating, and injecting packets all by ourselves.
    Also, raw sockets are not compatible with all operating systems. There are many
    third-party libraries that will help us to work with packets. Scapy is a very
    powerful interactive packet manipulation library and tool that stands out from
    all these libraries. Scapy provides us different commands, from basic level to
    advanced level, for investigating a network. We can use Scapy in two different
    modes: interactively within a terminal window, and programmatically from a Python
    script by importing it as a library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start Scapy using the interactive mode. Interactive mode is like Python
    shell; to activate this, just run Scapy with root privileges in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return an interactive terminal in Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Investigate network traffic with Scapy](img/image_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are some basic commands for interactive usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls()`: Displays all the protocols supported by Scapy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsc()`: Displays the list of commands supported by Scapy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf`: Displays all configurations options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help()`: Display help on a specific command, for example, `help(sniff)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show()`: Display the details about a specific packet, for example, `Newpacket.show()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scapy helps to create custom packets based on the huge set of protocols it
    supports. Now we can create simple packets with Scapy in an interactive Scapy
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a packet; now we can see the packet using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This use of the packet is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Investigate network traffic with Scapy](img/image_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Scapy creates and parses packets by the layers in each packet and by the fields
    in every layer. Each layer is encapsulated inside the parent layer. Packets in
    Scapy are Python dictionaries, so each packet is a set of nested dictionaries
    with each layer being a child dictionary of the parent layer. The `summary()`
    method will provide the details of the packet''s layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The layer structure of a packet can be better seen with the nesting of brackets
    (`<` and `>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can dig into a specific layer by its name or its index number in the list
    index. For example, we can get the UDP layer of the preceding packets with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can get the UDP layer using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With Scapy, we can parse the value of fields within each layer. For example,
    we can get the source field in the Ethernet layer with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Packet sniffing with Scapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Scapy, it is very simple to `sniff` packets with the `sniff` method. We
    can run the following command in a Scapy shell to `sniff` in interface `eth0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get three packets from the `eth0` interface. With `hexdump()`, we
    can dump the packet in `hex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet sniffing with Scapy](img/image_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The arguments for the `sniff()` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count`: Number of packets to capture, but 0 means infinity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iface`: Interface to sniff; sniff for packets only on this interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prn`: Function to run on each packet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`: Whether to store or discard the sniffed packets; set to 0 when we
    only need to monitor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: Stops sniffing after a given time; the default value is none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: Takes BPF syntax filters to filter sniffing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to see more of the packet contents, the `show()` method is good.
    It will display the packet in a cleaner and produce a formatted print out, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet sniffing with Scapy](img/image_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the sniffed packets in realtime, we have to use the lambda function,
    along with the `summary()` or `show()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it is possible to write the packets to a `pcap` file with Scapy. To write
    the packets to a `pcap` file, we can use the `wrpcap()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will write the packets to a `pkt-output.cap` file. We can read from the
    `pcap` file with `rdpcap()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Packet injection with Scapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before injecting, we have to create a spoofed packet. With Scapy, it is very
    simple to create a packet if we know the packet''s layered structure. To create
    an IP packet, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To add more child layers to this packet, we can simply add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a packet with an IP layer, `ICMP` layer, and raw payload,
    as `"Hello Packt"`. The `show()` method will display this packet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To send the packet, we have two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sendp()`: Layer-2 send; sends layer-2 packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`send()`: Layer-3 send; only sends layer-3 packets like IPv4 and Ipv6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main arguments for send commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iface`: The interface to send packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inter`: The time in between two packets (in seconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: To keep sending packets endlessly, set this to `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packet`: Packet or a list of packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are using a layer-2 send, we have to add an Ethernet layer and provide
    the correct interface to send the packet. But with layer-3, sending all this routing
    stuff will be handled by Scapy itself. So let''s send the previously created packet
    with a layer-3 send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet we send can be sniffed using another Scapy interactive terminal.
    The output will be like this, the second packet is the response we received from
    `packtpub.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packet injection with Scapy](img/image_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, to send a layer-2 packet, we have to add the Ethernet header and
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Scapy send and receive methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These methods are used to send a packet or group of packets when we expect
    a response back. There are four different types of send and receive methods. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sr()`: Layer-3 send and receive, returns both answers and unanswered packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sr1()`: Layer-3 send and receive, returns only answers or sent packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`srp()`: Layer-2 send and receive, returns both answers and unanswered packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`srp1()`: Layer-2 send and receive, returns only answers or sent packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods are almost similar to the `send()` method. To send a packet and
    receive its response, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, while waiting for the response, Scapy got three packets and exited when
    the response received. If we used `sr1()`, this will wait only for one response
    and print the response packet. Similarly, we can send layer-2 packets with the
    `srp()` and `srp1()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Programming with Scapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we were using Scapy in interactive mode. But in some cases, we may
    need to use Scapy in scripts. Scapy can be used as a library if it is imported
    in our programs. We can import all Scapy functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can import specific packages if we only need a few of the functions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For example we can create a DNS request. With `sr1()` method, we can create
    and get the response for a DNS request. As DNS packets are built from IP and UDP
    packets, we can create a DNS packet with IP and UDP layers in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to run this script with root privileges. If the verbose option is `1`,
    the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To parse DNS packets, we can use the `sniff()` method. The `prn` argument in
    `sniff()` can be used to change the output by Scapy for each packet. It helps
    to replace the default Scapy printout with our own function, thus we can decide
    how Scapy will print the output for each packet. Here, in the following example,
    we are using the `select_DNS()` function each time a matched packet is identified
    by the filter and sniffed with Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we imported the necessary modules, Scapy and datetime, in the first
    two lines; later, we declared the interface to sniff and the filter to get the
    `udp` packet from port `53` with the **Berkeley Packet Filter** (**BPF**) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we declared the function to be called when each packet is sniffed with
    the `sniff()` method. This will modify the default printout summary in `sniff()`
    and provide custom output. Here, it will check the DNS packet and output its source
    destination and time. The `prn` argument is used to bind this function to the
    `sniff()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Finally we will call the `sniff()` method with a `select_DNS()` function as
    a `prn` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on Berkeley Packet Filter (BPF) syntax, read [http://biot.com/capstats/bpf.html](http://biot.com/capstats/bpf.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check another example in OS fingerprinting; we can do this by two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Nmap fingerprinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: p0f
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Nmap is installed on your system, we can utilize its active OS fingerprinting
    database with Scapy. Make sure the signature database is located in the path specified
    in `conf.nmap_base`. If you are using the default installation directory, Scapy
    will automatically detect the fingerprints file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load `nmap` module with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then we can use `nmap_fp()` function to start fingerprinting the OS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have `p0f` installed, we can use this to identify the OS. Make sure the
    configuration `conf.p0f_base` is correct. We can guess the OS from a single captured
    packet with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on Scapy, read [http://www.secdev.org/projects/scapy/doc/usage.html](http://www.secdev.org/projects/scapy/doc/usage.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the basics of packet crafting and sniffing with various
    Python modules, and saw that Scapy is very powerful and easy to use. By now we
    have learned the basics of socket programming and Scapy. During our security assessments,
    we may need the raw outputs and access to basic levels of packet topology so that
    we can analyze and make decisions ourselves. The most attractive part of Scapy
    is that it can be imported and used to create networking tools without going to
    create packets from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss application fingerprinting with Python in more detail in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
