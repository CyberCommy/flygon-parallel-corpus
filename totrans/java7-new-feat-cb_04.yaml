- en: Chapter 4. Managing Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling how a file is copied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing temporary files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting time-related attributes of a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing file ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing ACL file permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing POSIX attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing symbolic links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often necessary to perform file manipulations such as creating files,
    manipulating their attributes and contents, or removing them from the filesystem.
    The addition of the `java.lang.object.Files` class in Java 7 simplifies this process.
    This class relies heavily on the use of the new `java.nio.file.Path` interface,
    which is discussed in depth in [Chapter 2](ch02.html "Chapter 2. Locating Files
    and Directories Using Paths"), *Locating Files and Directories Using Paths*. The
    methods of the class are all static in nature, and generally assign the actual
    file manipulation operations to the underlying filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the operations described in this chapter are atomic in nature, such
    as those used to create and delete files or directories. Atomic operations will
    either execute successfully to completion or fail and result in an effective cancellation
    of the operation. During execution, they are not interrupted from the standpoint
    of a filesystem. Other concurrent file operations will not impact the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute many of the examples in this chapter, the application needs to run
    as administrator. To run an application as administrator under Windows, right-click
    on the **Command Prompt** menu and choose **Run as administrator**. Then navigate
    to the appropriate directory and execute using the `java.exe` command. To run
    as administrator on a UNIX system, use the `sudo` command in a terminal window
    followed by the `java` command.
  prefs: []
  type: TYPE_NORMAL
- en: Basic file management is covered in this chapter. The methods required for the
    creation of files and directories are covered in the *Creating Files and Directories*
    recipe. This recipe focuses on normal files. The creation of temporary files and
    directories is covered in the *Managing temporary files and directories* recipe,
    and the creation of linked files is covered in the *Managing symbolic links* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The options available for copying files and directories are found in the *Controlling
    how a file is copied* recipe. The techniques illustrated there provide a powerful
    way of dealing with file replication. Moving and deleting files and directories
    are covered in the *Moving a file or directory* and *Deleting files and directories*
    recipes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Setting time-related attributes of a file or directory* recipe illustrates
    how to assign time attributes to a file. Related to this effort are other attributes,
    such as file ownership and permissions. File ownership is addressed in the *Managing
    file ownership* recipe. File permissions are discussed in two recipes: *Managing
    ACL file permissions* and *Managing POSIX file permissions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating new files and directories is greatly simplified in Java
    7\. The methods implemented by the `Files` class are relatively intuitive and
    easy to incorporate into your code. In this recipe, we will cover how to create
    new files and directories using the `createFile` and `createDirectory` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, we are going to use several different methods to create a `Path`
    object that represents a file or directory. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directory using the `Files` class' `createDirectory` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file using the `Files` class' `createFile` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FileSystem` class' `getPath` method can be used to create a `Path` object
    as can the `Paths` class' `get` method. The `Paths` class' static `get` method
    returns an instance of a `Path` based on a string sequence or a `URI` object.
    The `FileSystem` class' `getPath` method also returns a `Path` object, but only
    uses a string sequence to identify the file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code that creates a `Path` object for the directory `/home/test`
    in the `C` directory. Within a try block, invoke the `createDirectory` method
    with your `Path` object as the parameter. This method will throw an `IOException`
    if the path is invalid. Next, create a `Path` object for the file `newFile.txt`
    using the `createFile` method on this `Path` object, again catching the `IOException`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Directory created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the new file and directory exists in your filesystem. Next, add
    a catch block prior to the `IOException` after both methods, and catch a `FileAlreadyExistsException:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the program again, your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File or directory already exists!**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first `Path` object was created and then used by the `createDirectory` method
    to create a new directory. After the second `Path` object was created, the `createFile`
    method was used to create a file within the directory, which had just been created.
    It is important to note that the `Path` object used in the file creation could
    not be instantiated before the directory was created, because it would have referenced
    an invalid path. This would have resulted in an `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: When the `createDirectory` method is invoked, the system is directed to check
    for the existence of the directory first, and if it does not exist, create it.
    The `createFile` method works in a similar fashion. The method fails if the file
    already exists. We saw this when we caught the `FileAlreadyExistsException`. Had
    we not caught that exception, an `IOException` would have been thrown. Either
    way, the existing file would not be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createFile` and `createDirectory` methods are atomic in nature. The `createDirectories`
    method is available to create directories as discussed next. All three methods
    provide the option to pass file attribute parameters for more specific file creation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the createDirectories method to create a hierarchy of directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `createDirectories` method is used to create a directory and potentially
    other intermediate directories. In this example, we build upon the previous directory
    structure by adding a `subtest` and a `subsubtest` directory to the `test` directory.
    Comment out the previous code that created the directory and file and add the
    following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Verify that the operation succeeded by examining the resulting directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating temporary files and directories is covered in the *Managing temporary
    files and directories* recipe. The creation of symbolic files is illustrated in
    the *Managing symbolic links* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how a file is copied
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of copying files is also simplified in Java 7, and allows for control
    over the manner in which they are copied. The `Files` class' `copy` method supports
    this operation and is overloaded providing three techniques for copying which
    differ by their source or destination.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, we are going to create a new file and then copy it to another
    target file. This process involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new file using the `createFile` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a path for the destination file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the file using the `copy` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence to create a new file. Specify two `Path` objects,
    one for your initial file and one for the location where it will be copied. Then
    add the `copy` method to copy that file to the destination location as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File copied successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createFile` method created your initial file, and the `copy` method copied
    that file to the location specified by the `copiedFile` variable. If you were
    to attempt to run that code sequence twice in a row, you would have encountered
    an `IOException`, because the `copy` method will not, by default, replace an existing
    file. The `copy` method is overloaded. Use the copy method with the `java.lang.enum.StandardCopyOption`
    enumeration value of `REPLACE_EXISTING` to allow the file to be replaced, as shown
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three enumeration values for `StandardCopyOption` are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ATOMIC_MOVE` | Perform the copy operation atomically |'
  prefs: []
  type: TYPE_TB
- en: '| `COPY_ATTRIBUTES` | Copy the source file attributes to the destination file
    |'
  prefs: []
  type: TYPE_TB
- en: '| `REPLACE_EXISTING` | Replace the existing file if it already exists |'
  prefs: []
  type: TYPE_TB
- en: 'Replace the `copy` method call in the previous example with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the code executes, the file should be replaced. Another example of the
    use of the copy options is found in the *There's more..*. section of the *Moving
    a file and directory* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the source file and the destination file are the same, then the method completes,
    but no copy actually occurs. The `copy` method is not atomic in nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other overloaded `copy` methods. One copies a `java.io.InputStream`
    to a file and the other copies a file to a `java.io.OutputStream`. In this section,
    we will examine, in more depth, the processes of:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying a symbolic link file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying an input stream to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a file to an output stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a symbolic link file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a symbolic link file is copied, the target of the symbolic link is copied.
    To illustrate this, create a symbolic link file called `users.txt` in the `music`
    directory to the `users.txt` file in the `docs` directory. This can be done either
    by using the process described in the *Managing symbolic links* recipe in [Chapter
    2](ch02.html "Chapter 2. Locating Files and Directories Using Paths"), *Locating
    Files and Directories Using Paths*, or using the methods illustrated in the *Managing
    symbolic links* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code sequence to perform the copy operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Symbolic link file copied successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the resulting `music` directory structure. The `user2.txt` file has
    been added and is not connected to either the linked file or the original target
    file. Modification of the `user2.txt` does not affect the contents of the other
    two files.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a directory is copied, an empty directory is created. The files in the
    original directory are not copied. The following code sequence illustrates this
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this sequence is executed, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory copied successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the `tmp` directory. It should be empty as any files in the source directory
    are not copied.
  prefs: []
  type: TYPE_NORMAL
- en: Copying an input stream to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `copy` method has a convenient overloaded version that permits the creation
    of a new file based on the input from an `InputStream`. The first argument of
    this method differs from the original `copy` method, in that it is an instance
    of an `InputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses this method to copy the `jdk7.java.net` website
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code executes, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Site copied successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: A `java.lang.Object.URI` object was created to represent the website. Using
    the `URI` object instead of a `java.lang.Object.URL` object immediately avoids
    having to create a separate try-catch block to handle the `MalformedURLException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `URL` class' `openStream` method returns an `InputStream` which is used
    as the first parameter of the `copy` method. Notice the use of the try-with-resource
    block. This try block is new to Java 7 and is illustrated in the *Using the try-with-resource
    block to improve exception handling code* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*.
  prefs: []
  type: TYPE_NORMAL
- en: The `copy` method was then executed. The new file can now be opened with a browser
    or otherwise can be processed as needed. Notice that the method returns a long
    value representing the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file to an output stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The third overloaded version of the `copy` method will open a file and write
    its contents to an `OutputStream`. This can be useful when the content of a file
    needs to be copied to a non-file object such as a `PipedOutputStream`. It can
    also be useful when communicating to other threads or writing to an array of bytes
    as illustrated here. In this example, the content of the `users.txt` file is copied
    to an instance of a `ByteArrayOutputStream`. Its `toByteArray` method is then
    used to populate an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this sequence. The output will depend on the contents of your file,
    but should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The contents of users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bob**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jennifer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sally**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tom**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ted**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the try-with-resources block that handles the opening and
    closing of the file. It is always a good idea to close the `OutputStream` when
    the copy operation is complete or exceptions occur. The try-with-resources block
    handles this nicely. The method may block until the operation is complete in certain
    situations. Much of its behavior is implementation-specific. Also, the output
    stream may need to be flushed since it implements the `Flushable` interface. Notice
    that the method returns a long value representing the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Managing symbolic links* recipe for more details on working with symbolic
    links.
  prefs: []
  type: TYPE_NORMAL
- en: Managing temporary files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of creating temporary files and directories can be an essential
    part of many applications. Temporary files may be used for intermediate data or
    as a temporary store to be cleaned up later. The process of managing temporary
    files and directories can be accomplished simply via the `Files` class. In this
    recipe, we will cover how to create temporary files and directories using the
    `createTempDirectory` and `createTempFile` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, we are going to create a temporary directory and then create
    a temporary file within the directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `Path` objects representing the temporary file and directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a temporary directory using the `createTempDirectory` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a temporary file using the `createTempFile` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application with a `main` method. In the `main` method, create
    a `Path` object `rootDirectory` using the `getPath` method. Invoke the `createTempDirectory`
    method using `rootDirectory` as the first argument, and an empty string as the
    second argument. Then use the `toString` method to convert the returning `Path`
    object `dirPath` to a `String` and print it to the screen. Next, add the `createTempFile`
    method using `dirPath` as the first argument with empty strings as the second
    and third arguments. Use the `toString` method again to print out this resulting
    path as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sequence will result in an output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Temporary directory created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\home\docs\7087436262102989339**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Temporary file created successfully!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\home\docs\7087436262102989339\3473887367961760381**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createTempDirectory` method creates an empty directory and returns a `Path`
    object representing the location of this new directory. Likewise, the `createTempFile`
    method creates an empty file and returns a `Path` object representing this new
    file. In our previous example, we used the `toString` method to see the path where
    our directory and file were created. The previous numeric directory and filenames
    are assigned by the system and are platform-specific.
  prefs: []
  type: TYPE_NORMAL
- en: This `createTempDirectory` method requires at least two parameters, namely,
    the `Path` object directing the location for the new directory, and a `String`
    variable specifying the directory prefix. In our previous example, we left the
    prefix blank. However, if we had wanted to specify text to precede the filename
    assigned by the system, the second variable could have been populated with this
    prefix string.
  prefs: []
  type: TYPE_NORMAL
- en: The `createTempFile` method works in a similar manner as the `createTempDirectory`
    method, and had we wanted to assign a prefix to our temporary file, we could have
    used the second parameter to specify the string. The third parameter of this method
    could have also been used to specify a suffix, or file type, for our file, such
    as `.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that, although in our example we specified the `Path`
    in which we wanted our directory and file created, there is another version of
    each method in which the initial argument, the `Path` object, could be omitted,
    and the directory and/or file would be created in the system's default temporary
    directory. Additionally, these methods do not check for the file or directory's
    existence before creating them, and will overwrite any existing file or directory
    with the same temporary, system-assigned name.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File attribute names can also be passed to the overloaded `createTempDirectory`
    or `createTempFile` methods. These attributes are optional, but can be used to
    specify how the temporary files will be handled, such as whether the file should
    be deleted upon closing. The creation of a file attribute is described in the
    *There's more..*. section of the *Managing POSIX file permissions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `createTempDirectory` and the `createTempFile` methods are intended to have
    a limited existence. If it is desirable to delete these files or directories automatically,
    a shutdown hook or the `java.io.File` class' `deleteOnExit` method can be used.
    These two techniques will result in the deletion of the element when the application
    or the JVM terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Setting time-related attributes of a file or directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The timestamp for a file can be critical for some applications. For example,
    the order in which operations execute may be dependent on the time a file was
    last updated. There are three dates supported by the `BasicFileAttributeView:`
  prefs: []
  type: TYPE_NORMAL
- en: The last modified time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last access time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be set using the `BasicFileAttributeView` interface's `setTimes` method.
    As we will see in the *There's more..*. section, the `Files` class can be used
    to set or get only the last modified time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to set the times using the `setTimes` method. We need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the file of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a `BasicFileAttributeView` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `FileTime` objects for the times needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use these `FileTime` objects as arguments of the `setTimes` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application using the following `main` method. We will
    update the last modified time of our favorite file `users.txt` to the current
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Unless you have access to a time machine, or have
    otherwise manipulated your system''s clock, your output should reflect a time
    later than the time shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**2011-09-24T21:34:55.012Z**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Path` was first created for the `users.txt` file. Next, an instance of the
    `BasicFileAttributeView` interface was obtained using the `getFileAttributeView`
    method. A try block was used to catch any `IOExceptions` that might be thrown
    by the `readAttributes` or `setTimes` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Within the try block, `FileTime` objects were created for each of the three
    types of time. The `lastModifedTime` and `createTime` times were not changed for
    the file. These were obtained using the corresponding methods of the `BasicFileAttributes`
    class, which was obtained using the `view` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `currentTime` long variable was assigned the current time expressed in milliseconds.
    Its value was obtained using the `getTimeInMillis` method executed against an
    instance of the `Calendar` class. The three `FileTime` objects were then used
    as arguments to the `setTimes` method, effectively setting these time values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is more to the use of the `FileTime` class than presented so far. In
    addition, the `Files` class provides alternative approaches for maintaining times.
    Here we will further explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the `FileTime` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Files` class' `setLastModifiedTime` to maintain the last modified
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Files` class' `setAttribute` method to set individual attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the FileTime class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `java.nio.file.attribute.FileTime` class represents the time for use with
    several of the `java.nio` package methods. To create a `FileTime` object, we need
    to use either of the following two static `FileTime` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `from` method, which accepts a long number representing a duration and a
    `TimeUnit` object representing a unit of time measurement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `fromMillis` method, which accepts a long argument representing the number
    of milliseconds based on the epoch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeUnit` is an enumeration found in the `java.util.concurrent` package. It
    represents a time duration as defined in the following table. It is used in conjunction
    with another parameter whose combination represents a time duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Enumeration Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| NANOSECONDS | One thousandth of a microsecond |'
  prefs: []
  type: TYPE_TB
- en: '| MICROSECONDS | One thousandth of a millisecond |'
  prefs: []
  type: TYPE_TB
- en: '| MILLISECONDS | One thousandth of a second |'
  prefs: []
  type: TYPE_TB
- en: '| SECONDS | A second |'
  prefs: []
  type: TYPE_TB
- en: '| MINUTES | Sixty seconds |'
  prefs: []
  type: TYPE_TB
- en: '| HOURS | Sixty minutes |'
  prefs: []
  type: TYPE_TB
- en: '| DAYS | Twenty four hours |'
  prefs: []
  type: TYPE_TB
- en: The `from` method returns a `TimeUnit` object. Its value is computed by adding
    the first long argument, whose unit of measure is specified by the second `TimeUnit`
    argument, to the epoch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The epoch is 1970-01-01T00:00:00Z, which is the base time used for specifying
    time on most computers. This base time represents midnight, **Coordinate Universal
    Time** on January 1, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `from` method can be used to present a point in time, which
    is 1000 days from the epoch using the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1972-09-27T00:00:00Z**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fromMillis` method is used to create a `FileTime` object, whose time is
    represented by adding its argument to the epoch where the argument is a long number
    representing a value in milliseconds. If we used the following `fromMillis` method
    instead of the `from` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will get the same results. Notice that the first argument is a long literal,
    which forces the result of the expression to be a long number. If we did not promote
    our results to be long values, we would have received an integer value, which
    would have resulted in overflow and an incorrect date. The first argument of either
    method can be negative.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details regarding the use of time in Java, see [http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html](http://www3.ntu.edu.sg/home/ehchua/programming/java/DateTimeCalendar.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Files class' setLastModifiedTime to maintain the last modified time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Files` class'' `getLastModifiedTime` and `setLastModifiedTime` methods
    provide an alternative approach for setting the last modified attribute of a file.
    In the following code sequence, the `setLastModifiedTime` method uses the `lastModifedTime`
    object to set the time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Files` class'' `getLastModifiedTime` returns a `FileTime` object. We could
    have this method to assign a value to the `lastModifedTime` variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The method has an optional `LinkOption` argument that indicates whether symbolic
    links should be followed or not.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Files class' setAttribute method to set individual attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `setAttribute` method provides a flexible and dynamic approach for setting
    certain file attributes. To set the last modified time, we could have used the
    following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The *Obtaining a single attribute at a time using the getAttribute method* recipe
    in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*, details the other attributes that
    can be set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing symbolic links* recipe discusses the use of symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: Managing file ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The owner of a file or directory can be modified after the file has been created.
    This is accomplished by using the `java.nio.file.attribute.FileOwnerAttributeView`
    interface's `setOwner` method, which can be useful when ownerships change and
    need to be controlled programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: A `java.nio.file.attribute.UserPrincipal` object is used to represent a user.
    A `Path` object is used to represent a file or directory. Using these two objects
    with the `Files` class' `setOwner` method enables us to maintain file ownerships.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to change the owner of a file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the file or directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Path` as the argument to the `getFileAttributeView` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `UserPrincipal` object representing the new owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `FileOwnerAttributeView` interface's `setOwner` method to change the
    file's owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will assume that the current owner of the `users.txt` file
    is `richard`. We will change the owner to a user called `jennifer`. To do this,
    create a new user on your system called `jennifer`. Create a new console application
    with the following `main` method. In the method, we will use the `FileOwnerAttributeView`
    and a `UserPrincipal` object to change the owner as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to modify the ownership of a file, we must have appropriate privileges.
    The introduction to this chapter explains how to get administrator privileges.
    When the application is executed using Windows 7, the output should reflect the
    PC name and the file''s owners shown as follows. The PC name is separated from
    the owner with a backslash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Owner: Richard-PC\Richard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner: Richard-PC\Jennifer**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Path` was first created for the `users.txt` file. Next, an instance of the
    `FileOwnerAttributeView` interface was obtained using the `getFileAttributeView`
    method. Within the try block, a `UserPrincipalLookupService` object was created
    using the default `FileSystem` class' `getUserPrincipalLookupService` method.
    The `lookupPrincipalByName` method was passed the string `jennifer`, which returned
    a `UserPrincipal` object representing that user.
  prefs: []
  type: TYPE_NORMAL
- en: The last step was to pass the `UserPrincipal` object to the `setOwner` method.
    It then used the `getOwner` method to retrieve the current owner verifying the
    change.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any interface derived from `FileOwnerAttributeView` can use the `getOwner` or
    `setOwner` methods. These include the `AclFileAttributeView` and `PosixFileAttributeView`
    interfaces. In addition, the `Files` class' `setOwner` method can also be used
    to change ownership of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Files class' setOwner method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Files` class' `setOwner` method works in the same way as the `FileOwnerAttributeView`
    interfaces' `setOwner` method. It differs in that it has two arguments, a `Path`
    object representing the file and a `UserPrincipal` object. The following sequence
    illustrates the process of setting the owner of the `users.txt` file to `jennifer:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Managing ACL file permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will examine how ACL permissions can be set. The ability
    to set these permissions is important for many applications. For example, when
    we need to control who can modify or execute a file, we can affect this change
    programmatically. What we can change is indicated by the `AclEntryPermission`
    enumeration values listed later.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set a new ACL permission for a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object for the file whose attributes we want to change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain an `AclFileAttributeView` for that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a `UserPrincipal` object for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a list of ACL entries currently assigned to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `AclEntry.Builder` object holding the permission that we want to
    add.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the permission to the ACL list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `setAcl` method to replace the current ACL list with a new one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application with the following `main` method. In this
    method, we will initially simply display the current ACL list for the file `users.txt`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the process of adding and deleting ACL attributes, we will use
    a series of helper methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`displayAclEntries:` This displays the principal and entry type and then calls
    the other two helper methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayEntryFlags:` This displays the entry flags if present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayPermissions:` This displays the entry permissions if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the methods as shown in the following code to your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The ACL list contains the ACL entries for a file. When the `displayAclEntries`
    method is executed, it will display the number of entries as a convenience and
    then each entry will be separated by a blank line. The following illustrates a
    possible list for the `users.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Owner: Richard-PC\Richard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry List size: 4**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Principal Name: BUILTIN\Administrators**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry Type: ALLOW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No ACL Entry Flags present**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**READ_DATA DELETE READ_NAMED_ATTRS READ_ATTRIBUTES WRITE_OWNER DELETE_CHILD
    WRITE_DATA APPEND_DATA SYNCHRONIZE EXECUTE WRITE_ATTRIBUTES WRITE_ACL WRITE_NAMED_ATTRS
    READ_ACL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Principal Name: NT AUTHORITY\SYSTEM**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry Type: ALLOW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No ACL Entry Flags present**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**READ_DATA DELETE READ_NAMED_ATTRS READ_ATTRIBUTES WRITE_OWNER DELETE_CHILD
    WRITE_DATA APPEND_DATA SYNCHRONIZE EXECUTE WRITE_ATTRIBUTES WRITE_ACL WRITE_NAMED_ATTRS
    READ_ACL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Principal Name: BUILTIN\Users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry Type: ALLOW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No ACL Entry Flags present**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**READ_DATA SYNCHRONIZE EXECUTE READ_NAMED_ATTRS READ_ATTRIBUTES READ_ACL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Principal Name: NT AUTHORITY\Authenticated Users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry Type: ALLOW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No ACL Entry Flags present**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**APPEND_DATA READ_DATA DELETE SYNCHRONIZE EXECUTE READ_NAMED_ATTRS READ_ATTRIBUTES
    WRITE_ATTRIBUTES WRITE_NAMED_ATTRS READ_ACL WRITE_DATA**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the `UserPrincipalLookupService` class'' `lookupService` method to
    return an instance of the `UserPrincipalLookupService` class. Use its `lookupPrincipalByName`
    method to return a `UserPrincipal` object based on a user''s name. Add the following
    code after the `displayAclEntries` method is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code to create and set up an `AclEntry.Builder` object.
    This will be used to add `WRITE_ACL and DELETE` permissions for the user. Add
    the entry to the ACL list and use the `setAcl` method to attach it to the current
    file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. In order to modify some ACL attributes of a file,
    we must have the appropriate privileges. The introduction to this chapter gives
    the details of how to run the application as the administrator. Next, comment
    out the code that adds the ACL entry and verify that the ACL entry has been made.
    You should see the following entry added to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ACL Entry List size: 5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**User Principal Name: BUILTIN\Users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACL Entry Type: ALLOW**'
  prefs: []
  type: TYPE_NORMAL
- en: '**No ACL Entry Flags present**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WRITE_ACL DELETE**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, we created the `Path` object, and then used it to obtain
    an instance of the `java.nio.file.attribute.AclFileAttributeView` interface. The
    file represented by the `Path` object was the `users.txt` file. The `AclFileAttributeView`
    object can be used for several purposes. Here, we were only interested in using
    its `getAcl` method to return a list of the ACL attributes associated with the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We displayed the list of current ACLs only to see what they were, and to eventually
    verify that the attributes for the file have been changed. ACL attributes are
    associated with a user. In this example, we created a `UserPrincipal` object that
    represented users.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new ACL entry can be created using the `build` method of the `java.nio.file.attribute.AclEntry.Builder`
    class. The static `newBuilder` method created an instance of an `AclEntry.Builder`
    class. The `setPrincipal` method was executed to set users as the principal for
    the attribute. The `setPermissions` method takes either a set of `AclEntryPermission`
    objects or a variable number of `AclEntryPermission` objects. In this example,
    we used a list consisting of two permissions separated by a comma: `AclEntryPermission.WRITE_ACL`
    and `AclEntryPermission.DELETE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `AclEntry.Builder` object was then added to the existing ACL for the file.
    The entry was added at the beginning of the list. The last step was to use the
    `setAcl` method to replace the old ACL list with this new one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To remove an ACL attribute, we need to obtain the current list and then identify
    the position of the attribute that we want to remove. We can use the `java.util.List`
    interface's `remove` method to remove that item. The `setAcl` method can then
    be used to replace the old list with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'ACL attributes are explained in more detail in the **RFC 3530: Network File
    System (NFS) version 4 Protocol**. The following tables provide additional information
    and insight into the ACL permissions that are available. The enumeration `AclEntryType`
    has the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ALARM` | Results in an alarm being generated in a system-specific manner,
    when an attempt is made to access the attributes specified |'
  prefs: []
  type: TYPE_TB
- en: '| `ALLOW` | Grants permissions |'
  prefs: []
  type: TYPE_TB
- en: '| `AUDIT` | Logs the access requested in a system-dependent way, when an attempt
    is made to access the attributes specified |'
  prefs: []
  type: TYPE_TB
- en: '| `DENY` | Denies access |'
  prefs: []
  type: TYPE_TB
- en: 'The `AclEntryPermission` enumeration values are summarized in the table that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `APPEND_DATA` | Ability to append data to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Ability to delete the file |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE_CHILD` | Ability to delete a file or directory within a directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `EXECUTE` | Ability to execute a file |'
  prefs: []
  type: TYPE_TB
- en: '| `READ_ACL` | Ability to read the ACL attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `READ_ATTRIBUTES` | Ability to read (non-ACL) file attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `READ_DATA` | Ability to read the data of the file |'
  prefs: []
  type: TYPE_TB
- en: '| `READ_NAMED_ATTRS` | Ability to read the named attributes of a file |'
  prefs: []
  type: TYPE_TB
- en: '| `SYNCHRONIZE` | Ability to access files locally at the server with synchronous
    reads and writes |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE_ACL` | Ability to write the ACL attribute |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE_ATTRIBUTES` | Ability to write (non-ACL) file attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE_DATA` | Ability to modify the file''s data |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE_NAMED_ATTRS` | Ability to write the named attributes of a file |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE_OWNER` | Ability to change the owner |'
  prefs: []
  type: TYPE_TB
- en: 'The `AclEntryFlag` enumeration is applied to directory entries. There are four
    values summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DIRECTORY_INHERIT` | The ACL entry should be added to each new directory
    created |'
  prefs: []
  type: TYPE_TB
- en: '| `FILE_INHERIT` | The ACL entry should be added to each new non-directory
    file created |'
  prefs: []
  type: TYPE_TB
- en: '| `INHERIT_ONLY` | The ACL entry should be added to each new file or directory
    created |'
  prefs: []
  type: TYPE_TB
- en: '| `NO_PROPAGATE_INHERIT` | The ACL entry should not be placed on the newly
    created directory, which is inheritable by subdirectories of the created directory
    |'
  prefs: []
  type: TYPE_TB
- en: Currently, there are no flags associated with the `AclEntryType.AUDIT` or `AclEntryType.ALARM`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing POSIX attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The POSIX attributes available include a group owner, a user owner, and a set
    of permissions. In this recipe, we will investigate how to maintain these attributes.
    The management of these attributes makes it easier to develop applications designed
    to execute on multiple operating systems. While the number of attributes is limited,
    they may be sufficient for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three approaches that can be used to manage POSIX attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.nio.file.attribute.PosixFileAttributeView` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Files` class' set/get POSIX file permission methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Files` class' `setAttribute` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The approach used to gain access to the `PosixFileAttributes` object using the
    `PosixFileAttributeView` interface is detailed in the [Chapter 3](ch03.html "Chapter 3. Obtaining
    File and Directory Information") recipe *Using the PosixFileAttributeView to maintain
    POSIX file attributes*. Here, we will illustrate how to use the `PosixFileAttributeView`
    interface approach first, and demonstrate the last two approaches in the *There's
    more..*. section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To maintain POSIX permission attributes for a file we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the file or directory of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a `PosixFileAttributes` object for that file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a set of permissions for that file using the permissions method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the set of permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the permission using the `setPermissions` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an application that obtains a `PosixFileAttributes` object and
    uses it to display the current permissions set for the `users.txt` file, and then
    add the `PosixFilePermission.OTHERS_WRITE` permission to the file. Create a new
    console application and add the following `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application on a system that supports POSIX. When executed under
    **Ubuntu 11.04** you should get results similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Permissions: GROUP_READ OWNER_WRITE OTHERS_READ OWNER_READ**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permissions: GROUP_READ OWNER_WRITE OTHERS_WRITE OTHERS_READ OWNER_READ**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, we obtained a `Path` for the `users.txt` file and then
    used the `getFileAttributeView` method to get an instance of the `PosixFileAttributeView`.
    The `readAttributes` method was then used to obtain an instance of the `PosixFileAttributes`
    object representing the file's POSIX attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The `listPermissions` method was used to list the permissions for the file.
    This method was executed once before and once after the new permission was added
    to the file. We did this simply to show the change in permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PosixFilePermission.OTHERS_WRITE` permission was added to the permission
    set using the `add` method. The following table lists the `PosixFilePermission`
    enumeration values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Level | Permission Granted |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GROUP_EXECUTE` | Group | Execute and search |'
  prefs: []
  type: TYPE_TB
- en: '| `GROUP_READ` |   | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `GROUP_WRITE` |   | Write |'
  prefs: []
  type: TYPE_TB
- en: '| `OTHERS_EXECUTE` | Others | Execute and search |'
  prefs: []
  type: TYPE_TB
- en: '| `OTHERS_READ` |   | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `OTHERS_WRITE` |   | Write |'
  prefs: []
  type: TYPE_TB
- en: '| `OWNER_EXECUTE` | Owner | Execute and search |'
  prefs: []
  type: TYPE_TB
- en: '| `OWNER_READ` |   | Read |'
  prefs: []
  type: TYPE_TB
- en: '| `OWNER_WRITE` |   | Write |'
  prefs: []
  type: TYPE_TB
- en: In this example, we added a `PosixFilePermission.OTHERS_WRITE` permission. In
    the next section, we will illustrate how to remove a permission.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several other operations of interest including:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing a file permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the POSIX ownership of a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Files` class' `set/get` POSIX file permission methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Files` class' `setAttribute` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `PosixFilePermissions` class to create `PosixFilePermissions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a file permission
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Removing a permission is simply a matter of:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a set of permissions for the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Set` interface's `remove` method to remove the permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassigning the set to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is illustrated in the following code sequence, where the `PosixFilePermission.OTHERS_WRITE`
    permission is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the POSIX ownership of a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The POSIX owners are specified at the group and user level. The `PosixFileAttributes`
    method's group and owner will return objects representing the group and user owners
    of the file. The `setGroup` and `setOwner` methods will set the corresponding
    memberships.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example that follows, the owners for the `users.txt` file are displayed
    and then changed. The `UserPrincipal` objects are created to support the `set`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed your output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting owner for users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Old Group: richard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Old Owner: richard**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Group: jennifer**'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Owner: jennifer**'
  prefs: []
  type: TYPE_NORMAL
- en: You may need to execute the code as an administrator, as detailed in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Files class' set/get POSIX file permission methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This approach uses the `Files` class'' `setPosixFilePermissions` and `getPosixFilePermissions`
    methods. The `getPosixFilePermissions` method returns a set of `PosixFilePermissions`
    for the file specified by its first argument. Its second argument is a `LinkOption`,
    which is used to determine how symbolic link files are handled. Links are not
    normally followed, unless the `LinkOption.NOFOLLOW_LINKS` is used. We could use
    the following code sequence to list the permissions associated with a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setPermissions` method takes a `Path` object representing the file and
    a set of `PosixFilePermission`. Instead of using the previous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Files` class'' `setPosixFilePermissions` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `Files` class simplifies the process by avoiding the creation
    of a `PosixFileAttributes` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Files class' setAttribute method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Files` class'' `getAttribute` method is detailed in the *Obtaining a single
    attribute at a time using the getAttribute method* recipe found in [Chapter 3](ch03.html
    "Chapter 3. Obtaining File and Directory Information"). The `setAttribute` method
    will set an attribute and has the following four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Path` object representing the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `String` containing the attribute to be set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object representing the value of the attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `LinkOption` value specifying how symbolic links are handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following illustrates adding the `PosixFilePermission.OTHERS_WRITE` permission
    to the `users.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `LinkOption` value was not used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PosixFilePermissions class to create PosixFilePermissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PosixFilePermissions` class possesses three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`asFileAttribute`, which returns a `FileAttribute` object that contains a set
    of `PosixFilePermissions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fromString`, which also returns a set of `PosixFilePermissions` based on a
    `String` argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString`, which performs the inverse operation of the `fromString` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three methods are static. The first method returns a `FileAttribute` object,
    which can be used with the `createFile` or `createDirectory` method as discussed
    in the *Creating files and directories* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: On Unix systems, file permissions are frequently expressed as a nine-character
    string. The string is grouped in three character groups. The first set represents
    permission of the user, the second represents permission of the group, and the
    last set represents the permission of all others. Each of the three character
    groups represent the read, write, or execute permissions granted for that set.
    An `r` in the first position grants read permission, a `w` in the second position
    indicates write permission, and an `x` in the last position grants execute permission.
    A `-` in any of these positions means that the permission is not set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate these methods, execute the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OTHERS_READ OWNER_READ GROUP_READ OWNER_WRITE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OTHERS_READ OWNER_READ OWNER_WRITE GROUP_READ**'
  prefs: []
  type: TYPE_NORMAL
- en: '**rw-r--r--**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OWNER_READ OWNER_WRITE GROUP_READ GROUP_WRITE OTHERS_READ**'
  prefs: []
  type: TYPE_NORMAL
- en: The first section of the code obtains a set of permissions for the `users.txt`
    file as detailed earlier in this recipe. The permissions were then displayed.
    Next, the `asFileAttribute` method was executed to return the `FileAttribute`
    for the file. The `value` method was used to obtain a set of the attributes, which
    were then displayed. The two sets of permissions were displayed but in a different
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `toString` method was used to display this same set of permissions
    as a string. Notice each character reflects a permission granted for the `users.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The last code segment created a new set of permissions using the `fromString`
    method. These permissions were then displayed to verify the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a file and a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving a file or directory can be useful when reorganizing the structure of
    a user space. This operation is supported by the `Files` class' `move` method.
    When moving a file or directory there are several factors to consider. These include
    whether the symbolic link files are present, whether the `move` should replace
    existing files, and whether the move should be atomic.
  prefs: []
  type: TYPE_NORMAL
- en: A move may result in the renaming of the resource if the move occurs on the
    same file store. The use of this method will sometimes use the `Path` interface's
    `resolveSibling` method. This method will replace the last part of a path with
    its argument. This is useful when renaming files. The `resolveSibling` method
    is detailed in the *There's more..*. section of the *Combining paths using path
    resolution* recipe in [Chapter 2](ch02.html "Chapter 2. Locating Files and Directories
    Using Paths"), *Locating Files and Directories Using Paths*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to move a file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the file or directory to move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the destination of the move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the copy options to control the move.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `move` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application using the following `main` method. We will
    move the `users.txt` file to the `music` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. Examine the contents of the `docs` and `music` directories.
    The `users.txt` file should be absent from the `docs` directory, but present in
    the `music` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `move` method used these two `Path` objects and did not use a third optional
    argument. This argument is used to determine how the copy operation works. When
    it is not used, the file copy operation defaults to a simple copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StandardCopyOption` enumeration implements the `CopyOption` interface
    and defines the types of copy operation supported. The `CopyOption` interface
    is used with the `Files` class'' `copy` and `move` methods. The following table
    lists these options. These options are explained in more detail in the *There''s
    more..*. section:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ATOMIC_MOVE` | The move operation is atomic in nature |'
  prefs: []
  type: TYPE_TB
- en: '| `COPY_ATTRIBUTES` | The source file attributes are copied to the new file
    |'
  prefs: []
  type: TYPE_TB
- en: '| `REPLACE_EXISTING` | The destination file is replaced if it exists |'
  prefs: []
  type: TYPE_TB
- en: If the destination file already exists, then the `FileAlreadyExistsException`
    exception is thrown. However, if the `CopyOption.REPLACE_EXISTING` is used as
    the third argument of the `move` method, the exception is not thrown. When the
    source is a symbolic link, the link is copied and not the target of the link.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several variations and issues that need to be covered. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Trivial uses of the `move` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The meaning of the `StandardCopyOption` enumeration values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `resolveSibling` method with the `move` method to affect a rename
    operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trivial uses of the move method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the source file and the destination files are the same, the method will
    not have any effect. The following code sequence will have no effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: No exception will be thrown and the file will not be moved.
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of the StandardCopyOption enumeration values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `StandardCopyOption` enumeration values require a bit more explanation.
    A value of the `StandardCopyOption.REPLACE_EXISTING` will replace the existing
    file if present. If the file is a symbolic link, then only the symbolic link file
    is replaced, not its target.
  prefs: []
  type: TYPE_NORMAL
- en: A value of `StandardCopyOption.COPY_ATTRIBUTES` will copy all of the attributes
    of the file. A value of `StandardCopyOption.ATOMIC_MOVE` specifies that the move
    operation is to be performed in an atomic fashion. All other enumeration values
    are ignored. However, if the destination file already exists, then either the
    file will be replaced or an `IOException` will be thrown. The result is implementation-dependent.
    If the move cannot be performed in an atomic fashion, then an `AtomicMoveNotSupportedException`
    is thrown. An atomic move may fail due to differences in the file store of the
    source and destination files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the following code sequence is executed on Windows 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then an `AccessDeniedException` exception is thrown if the destination file
    already exists. If the file does not exist, its execution will result in the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.nio.file.AtomicMoveNotSupportedException: C:\home\docs\users.txt ->
    E:\home\music\users.txt: The system cannot move the file to a different disk drive**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the resolveSibling method with the move method to affect a rename operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `resolveSibling` method will replace the last part of a path with a different
    string. This can be used to affect a rename operation when using the `move` method.
    In the following sequence, the `users.txt` file is effectively renamed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The file has been renamed to `users.txt.bak`. Notice that the source file path
    was used twice. To rename the file and replace its extension, we can use an explicit
    name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A more sophisticated approach might use the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `substring` method returned a new filename starting with the first character
    and ending with the character immediately preceding the period.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a directory is moved on the same file store, then the directory and subdirectories
    are moved. The following will move the `docs` directory, its files, and its subdirectories
    to the `music` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'However, executing this code sequence, where the `docs` directory is to be
    moved to a similar file structure on the `E` drive will result in a `DirectoryNotEmptyException`
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Moving a directory across file stores will result in an exception if the directory
    is not empty. If the `docs` directory had been empty in the previous example,
    the `move` method would have executed successfully. If you need to move a non-empty
    directory across file stores, then this will normally involve a copy operation
    followed by a delete operation.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files or directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting files or directories when they are no longer needed is a common operation.
    It will save space on a system and result in a cleaner filesystem. There are two
    methods of the `Files` class that can be used to delete a file or directory: `delete`
    and `deleteIfExists`. They both take a `Path` object as their argument and may
    throw an `IOException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a file or directory, the following needs to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the file or directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use either the `delete` or `deleteIfExists` methods to delete the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and use the following `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. If the `users.txt` file existed in the directory when
    the program ran, it should not be there after the program executes. If the file
    did not exist, then your program output should appear similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**java.nio.file.NoSuchFileException: C:\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is simple to use. We created a `Path` object representing the `users.txt`
    method. We then used it as an argument to the `delete` method. Since `delete`
    method may throw an `IOException`, the code was enclosed in a try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid an exception that would be thrown if the file did not exist, we could
    have used the `deleteIfExists` method instead. Replace the `delete` method invocation
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the file does not exist and then execute this code. The program
    should terminate normally without any exceptions being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we try to delete a directory, the directory must first be empty. If the
    directory is not empty, then a `DirectoryNotEmptyException` exception will be
    thrown. Execute the following code sequence in lieu of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the `docs` directory is not empty, the application should throw
    a `DirectoryNotEmptyException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of an empty directory is dependent on the filesystem implementation.
    On some systems where the directory only contains special files or symbolic links,
    the directory may be considered to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: If a directory is not empty and needs to be deleted, then it will be necessary
    to delete its entries first using the `walkFileTree` method as illustrated in
    the *Using the SimpleFileVisitor class to traverse file systems* recipe in [Chapter
    5](ch05.html "Chapter 5. Managing Filesystems"), *Managing File Systems*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the file to be deleted is a symbolic link, only the link is deleted, not
    the target of the link. Also, it may not be possible to delete a file if the file
    is open or in use by other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Managing symbolic links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbolic links are files, which are not real files, but rather links to or points
    to the real file typically called the target file. These are useful when it is
    desirable to have a file appearing to be in more than one directory without actually
    having to duplicate the file. This saves space and keeps all of the updates isolated
    to a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Files` class possesses the following three methods for working with symbolic
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: The `createSymbolicLink` method, which creates a symbolic link to a target file
    that may not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createLink` method creates a hard link to an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `readSymbolicLink` retrieves a `Path` to the target file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links are typically transparent to the users of the file. Any access to the
    symbolic link is redirected to the referenced file. Hard links are similar to
    symbolic links, but have more restrictions. These types of links are discussed
    in more detail in the *There's more..*. section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a symbolic link to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a `Path` object, which represents the target file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use these paths as the argument to the `createSymbolicLink` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application. Add the following `main` method to the application.
    In this application, we will create a symbolic link in the `music` directory to
    the actual `users.txt` file in the `docs` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. If the application does not have sufficient privileges,
    then an exception will be thrown. An example of this when executed on Windows
    7 is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**java.nio.file.FileSystemException: C:\home\music\users.txt: A required privilege
    is not held by the client.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that a new file called `users.txt` exists in the `music` directory.
    Check the properties of the file to verify that it is a symbolic link. On Windows
    7, right-click on the filename and select **Properties**. Next, select the **Shortcut**
    tab. It should appear as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the target specified is the `users.txt` file in the `docs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created two `Path` objects. The first represented the target file in the
    `docs` directory. The second represented the link file to be created in the `music`
    directory. Next, we used the `createSymbolicLink` method to actually create the
    symbolic link. The entire code sequence was enclosed in a try block to catch any
    `IOExceptions` that may be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument of the `createSymbolicLink` method can be one or more `FileAttribute`
    values. These are intended to be used to set attributes of the link file when
    it is created. However, it is currently not fully supported. Future versions of
    Java will enhance this capability. A `FileAttribute` can be created as detailed
    in the *There's more..*. section of the *Managing POSIX file permissions* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we will look more carefully at the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hard link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a symbolic link to a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the target of a link file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a hard link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hard links have more restrictions placed upon them as opposed to symbolic links.
    These restrictions include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The target must exist. If not, an exception is thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard link cannot be made to a directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard links can only be established within a single filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard links behave like a regular file. There are no overt properties of the
    file that indicate that it is a link file, as opposed to a symbolic link file
    which has a shortcut tab. All of the attributes of the hard link are identical
    to that of the target file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hard links are not used as frequently as soft links. `Path` class methods work
    with hard links and do not require any special considerations. A hard link is
    created using the `createLink` method. It accepts two arguments: a `Path` object
    for the link file and for the target file. In the following example, we create
    a hard link in the `music` directory instead of a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Execute the application. If you examine the properties of the link file, you
    observe that it is not displayed as a symbolic link. However, modifying the contents
    of either file will cause the other file to be modified also. They are effectively
    one and the same.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a symbolic link to a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a symbolic link to a directory uses the same methods as it did for
    files. In the following example, a new directory `tmp` is created, which is a
    symbolic link to the `docs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: All of the files in the `tmp` directory are effectively the symbolic links to
    the corresponding files in the `docs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the target of a link file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `isSymbolicLink` method, as discussed in the *Managing symbolic links* recipe
    in [Chapter 2](ch02.html "Chapter 2. Locating Files and Directories Using Paths"),
    *Locating Files and Directories Using Paths* determines whether a file is a symbolic
    link or not. The `readSymbolicLink` method accepts a `Path` object representing
    the link file and returns a `Path` object representing the target of the link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sequence illustrates this, where the `users.txt` file in
    the `music` directory is a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the `users.txt` link file is a hard link, as created with the `createLink`
    method, we get the following exception when the code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.nio.file.NotLinkException: The file or directory is not a reparse point**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reparse point is an **NTFS** filesystem object that associates specific data
    to an application with a file or directory. A filesystem filter can be associated
    with the reparse point type. When the filesystem opens the file, it will pass
    this information to the filesystem filter for processing. This approach is a way
    of extending the functionality of the filesystem.
  prefs: []
  type: TYPE_NORMAL
