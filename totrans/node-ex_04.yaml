- en: Chapter 4. Developing the Model-View-Controller Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to prepare the assets needed by our
    application. It is time to move forward and start writing the base levels of our
    social network. In this chapter, we will use the Model-View-Controller pattern
    and prepare our code base to implement the future of our application. Here is
    what we will talk about in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the code from the previous chapter to a better file structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a router that works in both backend and frontend environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly introducing Ractive.js—a framework that we will use in the client-side
    part of the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the main file of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing controller, view, and model classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolving the current setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing software is difficult. Often, it's a process of change. In order to
    evolve and extend our systems, we have to make changes in the code. We will take
    the code from the previous chapter and introduce a couple of new folders and files.
    We will change the architecture a bit so that it fits in the development afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a common practice to split the logic into frontend and backend. We are
    going to follow the same approach. Here is the new file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Directory structure](img/image00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `backend` directory will contain files used in the Node.js environment.
    As we can see, we moved the files that were previously in the main directory to
    the `frontend` folder. These are the files that produce the resources placed in
    the `static` directory. We still have the necessary `gulpfile.js`, `package.json`,
    and `server.js` files that contain the code of the Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: Forming the main server handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, our server only has one request handler—`assets`. Here is how we started
    our server in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the serving assets, we have to add two other handlers, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API handler**: The client-side part of our application will communicate with
    the backend via the REST API. We introduced this concept in [Chapter 2](part0020.xhtml#aid-J2B81
    "Chapter 2. Architecting the Project"), *Architecting the Project*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page handler**: If the request that comes to the server is not for an asset
    or API resource, we will serve an HTML page, which is the page that normal users
    will see.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s not really a good idea to keep everything in a single file. So, the first
    step is to extract the `assets` function to its own module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will follow a similar approach and create a `backend/API.js` file. It will
    be responsible for the REST API. We will use JSON as a format to transfer data.
    The simplest code that we can use for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting the correct `Content-Type` value is important. If it is missing or if
    it is a wrong value, then the browser that receives the response may not process
    the result properly. In the end, we are returning a minimal empty JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Towards the end, we will add `backend/Default.js`. This is the file that will
    generate the HTML page that users will see in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of `Default.js` looks similar to `API.js`. We will again set the
    `Content-Type` value and use the `end()` method of the `response` object. However,
    here we load the HTML Unicode string from an external file, which is stored in
    `backend/tpl/page.html`. The reading of the file is synchronous, and it happens
    only once in the beginning. Here is the code of `page.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a basic HTML5 boilerplate code containing head, body tag, CSS, and
    JavaScript imports. Our application will only need the following two JavaScript
    files to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ractive.js`: This is the framework that we will use in the client-side. More
    about this will be discussed in the next few sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.js`: This is our client-side JavaScript. As seen in a previous chapter,
    it is produced by the Gulp setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having mentioned the handlers in the backend, we are ready to jump into the
    code that will be run in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every web application needs a router, which is a component that acts
    as a front door and accepts the incoming queries. It analyzes the parameters of
    the request and decides which module of our system will serve the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using JavaScript language in the backend (via Node.js) and frontend
    (interpreted by the web browser). In this section, we will write a router that
    works in both the sides of our application. Let''s start examining what the Node.js
    part needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Router.js` exports two methods. The first one registers routes by accepting
    a path and a handler function, which will be called if the current URL matches
    the path. The `check` function simply performs the actual check.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the `add` method looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can skip the `path` parameter and just register a function that matches every
    route. It is nice to support such behavior in cases where we want to define a
    default route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check` function is slightly more complex. It not only covers simple string-to-string
    matching, but should also support dynamic parameters. We are going to use `:id`
    for these dynamic parameters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/home`: This matches `http://localhost/home`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/feed`: This matches `http://localhost/user/feed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/:id/profile`: This matches `http://localhost/user/45/profile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/user/:id/:action`: This matches `http://localhost/user/45/update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to implement this functionality, we will use regular expressions in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through the function line by line. The arguments of the method are
    `f` and `parameters`. The fragment is actually a path. This is the URL against
    which we run the check. In the `add` method, we added a handler that should be
    fired once we have a match. It would be nice if we were able to send additional
    variables to this method. The `parameters` argument covers this functionality.
    We can send an array, which is later translated to the parameters of the handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function continues with the checking whether the fragment is defined. In
    the Node.js environment, we have to send the URL. However, since we will use the
    same code in the browser, we define a `getFragment` helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main idea of this helper is to get the current URL of the browser by using
    the global `window.location` object. You may notice another `clearSlashes` function.
    It does exactly what its name suggests. It removes the unnecessary slashes from
    the beginning and end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get back to the `check` function. We will continue looping over the
    registered routes. For every route, we perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We prepare a regular expression by extracting the dynamic parts (if any); for
    example, `users/:id/:action` is transformed to `test/([\w-]+)/([\w-]+)`. We will
    use this later in the book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check whether the regular expression matches the fragment. If it does, then
    we compose an array of parameters and call the route's handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's interesting that if we pass our own path (the fragment), we can use the
    same JavaScript in both the Node.js and browser environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client side of the application will need two other methods. So far, we
    have routes'' registration and checking whether these rules match the URL specifically.
    This may work for the backend, but in the frontend, we need to constantly monitor
    the current browser location. That''s why we will add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By using `setInterval`, we will run the `fn` closure again and again. It checks
    whether the current URL has changed, and if it has, then it fires the `check`
    method, which has already been explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last addition to the class is the `navigate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will probably want to change the current page from within our code. The router
    is a good instrument for this. Once we change the browser's URL, the class automatically
    calls the right handler. The preceding code uses the HTML5 history API ([http://diveintohtml5.info/history.html](http://diveintohtml5.info/history.html)).
    The `pushState` method changes the string of the browser's address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `navigate` method, we finalized our router, which is a module that
    can be used in the backend as it is in the frontend. Before we continue with the
    Model-View-Controller components, we will briefly introduce Ractive.js—the framework
    that we will use as a driving power for user interface development.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Ractive.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ractive.js is a framework developed by TheGuardian, a well-known news organization
    ([http://www.theguardian.com/](http://www.theguardian.com/)). It simplifies the
    DOM interaction and provides features like two-way data binding and custom component
    creation. We are not going to cover all the capabilities of the framework now.
    A new feature will be introduced in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In complex web applications like ours, it is extremely important to split different
    logical parts into components. Thankfully, Ractive.js provides an interface for
    this. Here is how a typical component looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `template` property contains an HTML markup or (as in our case) a precompiled
    template. The data object is accessible inside our templates. Ractive.js uses
    **mustache** ([http://mustache.github.io/](http://mustache.github.io/)) as a template
    language. We can add another property called `el` and directly choose where the
    component will be rendered after initialization. However, there is another way—the
    `render` method. This method accepts a DOM element. In the preceding code, this
    is just the body of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, like the DOM tree in the browser, we will need the nesting of the
    components. This is nicely handled by the framework by introducing a custom tag
    definition, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Every component may have a hash map object (`components`) that defines our
    custom tags. We can nest as many components as we want. The HTML produced by the
    preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways to establish communication between different Ractive.js
    components. The most convenient one involves triggering and listening to events.
    Let''s check the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We brought up a few new concepts. First, we defined a public function—`notifyTheOutsideWorld`.
    Ractive.js allows you to register custom methods. With the `on` method, we subscribed
    to a specific event, and with `fire`, we dispatched events.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used another method that has not been explained
    so far. The `set` function modifies the data object of the component. We will
    use this function regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing about Ractive.js that we will mention in this chapter is its
    function of observing the changes in the component''s data properties. The following
    code demonstrates the observation of the `title` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows an `alert` window with the `Hello!` text. Let's
    continue with the process of defining the main application's file, or in other
    words, the client-side entry point of our social network.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the entry point of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we were constructing the Gulp setup, we created a task for JavaScript
    bundling. Browserify needs an entry point to resolve dependencies. We set `frontend/js/app.js`.
    Similarly, for the backend, we will build our logic around the router. The following
    code sets two routes and provides a helper function to render the Ractive.js component
    on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We require the `Router` variable at the top. Along with this, we need to fetch
    the controller responsible for the home page. We will learn more about this in
    the next section. For now, we will just say that it is a Ractive.js component.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to run any JavaScript until the resources of the page are fully
    loaded. So, we will wrap our bootstrapping code in a `window.onload` handler.
    The holder of the Ractive.js components will be the `body` tag and we will create
    a reference to it. We defined a helper function called `showPage`. Its job is
    to render the current page and make sure that the page that was last added is
    removed properly. The `teardown` method is a built-in function of the framework.
    It unrenders the component and removes all the event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will have only one page—the home page. We will use the
    router that we created for the backend and register a `/home` route. The second
    handler that we pass to the `add` function is basically called in case there is
    no matching route. What we did was immediately forward the user to the `/home`
    URL. In the end, we triggered the router's listening and fired the initial check.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will define our first controller—the component that
    will control our home page.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The role of controllers in our context will be to orchestrate the pages. In
    other words, they will act as page wrappers that manage the processes that happen
    between subcomponents. The content of the `controllers/Home.js` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before you go through the properties of the template and components, we have
    to say a few words about `onrender`. The Ractive.js components provide an interface
    to define handlers for processes that happen internally at each stage of the component's
    life cycle. For example, we will need to perform some actions almost every time
    after the component is rendered on the page. Also, there are `onconstruct`, `onteardown`,
    or `onupdate`. This is surely a nice way to implement business logic. All properties
    such as these are listed in the official documentation of the framework at [http://docs.ractivejs.org/latest/options](http://docs.ractivejs.org/latest/options).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already mentioned the `template` property while introducing you to Ractive.js.
    However, in the following code we do not have a string as a value. We require
    another JavaScript file—the precompiled HTML template. The precompilation is done
    by the build system Gulp in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get all the HTML files from the `frontend/tpl` directory and convert
    them to JavaScript files that Ractive.js and Browserify understand. In the end,
    Gulp creates a file with the same name in the same directory but with a different
    extension. For example, the template for our home page can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `gulp` in the terminal, we will get `frontend/tpl/home.js` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We do not have to fully understand what these properties mean. The conversion
    of the JavaScript file to HTML is a job that is reserved for the framework.
  prefs: []
  type: TYPE_NORMAL
- en: If you check the template and component definition in the preceding code, you
    will notice that there are two subcomponents, `navigation` and `appfooter`. Let's
    see how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: Managing our views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, the views are Ractive.js components. They have their own templates. In
    fact, the `Home.js` module can also be called a view. The Model-View-Controller
    pattern in the browser is often transformed, and it does not follow the exact
    definitions. This is the case with our application because we are using a framework
    that has some rules and which provides specific functionalities that do not align
    with the typical MVC. Of course, there is nothing wrong with this. As long as
    we separate the responsibilities, our architecture will be in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `navigation` view is fairly simple. It just defines the template that needs
    rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make things more interesting and introduce the model''s definition,
    we will display a version number in the footer. This number will come from a model
    created in `models/Version.js`. Here is the code of the `views/Footer.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before explaining what exactly happened with `bindComponent`, let''s check
    what we have in `tpl/footer.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have a dynamic variable, `version`. In case we do not use a model, we have
    to define it in the `data` property of the component or use `this.set('data',
    value)`. However, the `FooterModel` module will make our life easier and update
    the variables of the component that are bound to it. This is why we are passing
    this module to `bindComponent`. The `fetch` method, as we will see in the next
    section, synchronizes the model's data with the data in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will probably have several models and all of them will share the same methods.
    Normally, the models make HTTP requests to the server and get data. So, this is
    something that we need to abstract. Thankfully, Ractive.js makes it possible for
    you to extend components. Here is the code for the `models/Version.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have `models/Base.js`, the file that will contain these common functions.
    It will be a base class that we will later inherit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We defined two methods—`fetch` and `bindComponent`. The first one uses a helper
    Ajax wrapper. We are not going to go into the details of this for now. It's similar
    to jQuery's `.ajax` method and it implements the promise interface pattern. The
    actual source code can be found in the files that came with this book.
  prefs: []
  type: TYPE_NORMAL
- en: The component that extends the `Base` module should provide a URL. This is the
    endpoint where the model will make requests. In our case, this is `/api/version`.
    Our backend will serve content on this URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back and check what we did with the URLs starting with `/api`, we
    will see that the result is just an empty object. Let''s change this and cover
    the implementation of the `/api/version` route. We will update `backend/API.js`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We used the same router to map the URL to the specific response. So, after this
    change, our model will fetch `0.1` as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s reveal the magic that happens in the `bindComponent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We observe the local `data` property value for changes. It is updated after
    a successful `fetch` method call. The new value is passed to the handler and we
    simply transfer the variables to the component. They are just a few lines of code,
    but they manage to bring about a nice abstraction. In the actual model definition,
    we only have to specify the URL. The `Base` module takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we constructed the base of our application. We also created
    the base of our system—the router. The controllers are now nicely bound to routes
    and the views are rendered on the page, updating the display automatically when
    changes are made to the values in the model. We also introduced a simple model
    that gets data from the backend's API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement a real working feature—we will manage
    the users of our system.
  prefs: []
  type: TYPE_NORMAL
