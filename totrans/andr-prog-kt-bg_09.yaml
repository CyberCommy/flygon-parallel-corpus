- en: Chapter 9. Kotlin Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are the building blocks of our apps. We write functions that do specific
    tasks, and then call them when we need to execute that specific task. As the tasks
    we need to perform in our apps will be quite varied, our functions need to cater
    to this and be very flexible. Kotlin functions are very flexible, more so than
    the other Android-related languages. We therefore need to spend a whole chapter
    learning about them. Functions are intimately related to object-oriented programming,
    and once we understand the basics of functions, we will be in a good position
    to take on the wider learning of object-oriented programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we have in store for this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Function basics and recap
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function return types and the return keyword
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-expression functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default arguments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More function-related topics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know a little bit about functions already, so a recap is in order.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Function basics and recap
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen and used functions. Some were provided for us by the Android
    API, such as `onCreate` and the other lifecycle functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: We wrote others ourselves; for example, `topClick` and `bottomClick`. However,
    we haven't explained them properly, and there is more to functions than we have
    seen so far.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will often hear another term that is closely related and almost synonymous
    with functions. This is especially the case if you have previously learned Java
    or another object-oriented language. The word I am referring to is **method**.
    The distinction between a method and a function is rarely important from a technical
    point of view, and the difference is, in part, where in our code the function/method
    is declared. If you want to be programmatically correct, you can read this article,
    which goes into some depth and provides multiple opinions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function](https://stackoverflow.com/questions/155609/whats-the-difference-between-a-method-and-a-function)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I will refer to all methods/functions as functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The basic function declaration
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example of a very simple function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We could call the `printHello` function like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result would be this output in the logcat window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line of the function is the **declaration**, and all the code contained
    within the opening and closing curly brackets is the function **body**. We use
    the `fun` keyword, followed by the name of the function, followed by an opening
    and closing bracket. The name is arbitrary, but it is good practice to use names
    that describe what the function does.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Function parameter lists
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The declaration can take many forms, and this gives us lots of flexibility
    and power. Let''s look at some more examples:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding `printSum` function could be called as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result of calling the `printSum` function is that the following message
    would be output to the logcat window:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the `2` and `3` values that are passed to the function are arbitrary.
    We could pass any values we like, provided they are of the `Int` type.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the declaration `(a: Int, b: Int)` is called the **parameter list**,
    or just **parameters**. It is a list of types that the function expects and needs
    in order to execute successfully. The parameter list can take many forms, and
    any Kotlin type can be part of the parameter list, including having no parameters
    at all (as we saw in the first example).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a function with a parameter list, we must supply arguments that
    match whenever we call it. Here are a few other possible ways we could call the
    preceding `printSum` function example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown in the previous examples, any combination of values that amount to
    two `Int` values are acceptable as arguments. We can even use expressions as arguments,
    provided they are equal to an `Int` value. This call is also fine, for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous example, 50 is subtracted from 100, the result (50) is passed
    as the first argument, and `number1` is added to `number2` and the result is passed
    as the second argument.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another couple of functions with various parameters, followed by examples
    of how we might call them:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before we discuss the code, let''s have a look at the output we get from it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we declare two functions. The first is called `printName`,
    and it has two `String` parameters. The declaration, along with highlighted parameter
    names, is shown again next. The names are arbitrary, but using meaningful names
    will make the code easier to understand:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Attempting to call the function with anything other than two `String` values
    as arguments will result in an error. When we call this function, the `first`
    and `second` parameters are initialized as variables that we then use in a String
    template to print the joined-up name to the logcat window. The line of code that
    achieves this is shown again as follows, with the variables highlighted:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the space in between `$first` and `$second` in the code. Note that this
    space is also present in the output we saw previously.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function is `printAreaCircle`. It has one `Float` parameter called
    `radius`. Here it is again for easy reference:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function uses the `radius` variable, which is initialized when the function
    is called to calculate the area of a circle using the formula `3.14 * (radius
    * radius)`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The code then proceeds to call the first function twice and the second function
    once. This is shown again in the following code snippet (with helpful comments
    removed for focus):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we can call functions with literal values or variables, provided
    they are of the correct type that matches the declared parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, the function declarations are outside of any other functions, but
    are inside the class opening and closing curly brackets. The function calls are
    inside the `onCreate` function. As our apps get more complex, we will call functions
    from all over our code (even other code files). The `onCreate` function is just
    a handy place to use while discussing these topics.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to examine the code structure more closely, the file that contains
    this code is in the `Chapter09/Functions Demo` folder. Create a new Empty Activity
    project and you can copy and paste the code to play around with it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Another point, which is perhaps obvious but is well worth mentioning, is that
    when we write functions for real apps, they can contain as much code as is practical;
    they won't just be a single line of code like these examples. Any code we learned
    about in the previous chapters can go into our functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to another function-related topic that gives us even more
    options.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The return type and the return keyword
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Very often, we will need to get a result from a function. It is not always
    enough just to have the function know the result. Functions can be declared to
    have a **return type**. Look at this next function declaration:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, look at the highlighted part after the closing bracket
    of the parameter list. The `:Int` code means the function can and must return
    a value of the `Int` type to the code that called it. The line of code inside
    the function body uses the `return` keyword to achieve this. The `return a + b`
    code returns the sum of `a` and `b`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the `getSum` function in the same way we do a function without
    a return type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding line of code will work, but is a little pointless because we
    don''t do anything with the returned value. This next code shows a more likely
    call to the `getSum` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding function, the value returned from the function is used to initialize
    the `answer` variable. As the return type is `Int`, Kotlin infers that `answer`
    is also of type `Int`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also use `getSum` in other ways – one such example is shown next:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code uses the `getSum` function in another way, by printing the
    returned value using a String template to print to the logcat window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Any type can be returned from a function. Here are a few examples; first the
    declarations, followed by some of the ways we might call them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the output that those two function calls would produce:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see that the area of a circle is retrieved and printed, and the first
    and last names joined together are retrieved and printed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a quick sanity check, it is worth pointing out that we don't actually need
    to write functions just to add numbers together or join Strings. It is just a
    useful way to demonstrate various aspects of functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the `return` keyword has its uses even when the
    function doesn't have a return type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the `return` keyword to return from a function early.
    All our previous function examples (without return types) automatically returned
    to the calling code when the last line of code in the body had executed. Here
    is an example where we use the `return` keyword:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Look at the output when we run the preceding code, and then we will discuss
    how it works:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the function body, the `if` expression checks whether `aNumber` is bigger
    than three, and, if it is, prints a disgruntled comment and uses the `return`
    keyword to go back to the calling code and avoid printing the value to the logcat.
    From the program output, we can see that when `aNUmber` was one, two, or three,
    it was dutifully printed by the `printUpTo3` function, but as soon as we passed
    in the value of four, we got the alternative result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Function bodies and single-expression functions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function body can be as complex or simple as we need it to be. All the examples
    I have shown so far were deliberately overly simplistic, so that we could concentrate
    on functions specifically rather than the code within them. As the book progresses
    through more real-world examples, we will see the code in the function bodies
    grow longer and more complex. However, function bodies should stick to performing
    one specific task. If you have a function that takes up a whole screen in Android
    Studio, it is likely a sign that it should be split into multiple functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a function with a very simple body containing just a single expression,
    Kotlin allows us to shorten the code by using a single-expression syntax. As an
    example, the `getSum` function could be changed to the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we have shed the curly brackets that usually wrap
    the code in the body, and we have inferred the return type, because adding `a`
    to `b` could only result in an `Int` variable because `a` and `b` are, themselves,
    `Int` variables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Making functions flexible
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As functions are the building blocks of our code, they need to be versatile
    to cater for anything we might need to do. We have already seen how we can create
    very varied parameter lists and return types, as well as deciding in code when
    to return to the calling code. As we progress, you will see that we need even
    more options. What follows is a quick glance at some more Kotlin function options
    that we will introduce now, and then get around to using for real at various points
    throughout the book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Default and named arguments
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **default parameter** is where we the programmers provide a value (default)
    for a parameter that will be used if the code that calls the function does not
    provide it. A **named argument** is when the code calling a function specifies
    a name along with a value. Note that providing a value is optional. Just because
    a default value for a parameter is given does not prevent the calling code from
    overriding it by providing it. Have a look at the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we first declare a function called `orderProduct`. Observe
    that amongst the parameter list, we have declared two default values, as reprinted
    and highlighted next for clarity:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we call the function, we can do so without specifying values for `giftwrap`
    and/or `postalService`. The first function call in the following code makes this
    clear:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that, when we do so, we need to specify the name of the argument, which
    must match the name in the parameter list as well as the type. In the second function
    call, we specify a value for `giftwrap` and `product`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the third, we specify a value for all three arguments, as seen again in
    the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, in the fourth, we specify the final two arguments:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code inside the function itself starts by declaring a `var` variable called
    `details`, which is a `String` value. If the value of `giftwrap` is true, then
    `Gift Wrapped` is appended to `Product details`. Next, the value of `product`
    is appended to `details`, and finally the value of `postalService` is appended
    with a literal `String` value on either side.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, this is the output in the logcat window:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The varied ways we can call the function are extremely useful. In other programming
    languages, when you want to be able to call the same named function in different
    ways, you must supply multiple versions of the function. While learning about
    named arguments and default parameters might add a little complexity, it certainly
    beats having to write four versions of the `orderProduct` function. This, along
    with type inference, are just two of the reasons you will often hear programmers
    extolling Kotlin's succinct nature.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using named arguments and default parameters, we can choose to supply as much
    or as little data as the function allows. Simply put, if we provide values for
    all parameters without default values, it will work.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to play with this code, then all the examples from this chapter
    are in the `Chapter09` folder. Create an Empty Activity project, then copy and
    paste the functions into the `MainActivity` class and the function calls into
    the `onCreate` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: There are some caveats when we do this, and we will see them as we progress
    with some more real-world examples throughout the book.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Even more on functions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to functions, such as top-level functions, local functions, and
    variable argument functions, as well as function access levels, but these are
    best discussed alongside or after the topic of classes and object-oriented programming.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we made good progress with learning about functions. Although
    functions have been lurking in our code since the first chapter, we finally got
    to study and understand them formally. We learned about the different parts of
    a function: the name, the parameters, and the return type. We have seen that what
    the function actually does goes inside the opening and closing curly brackets,
    and is called the function body.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can return from a function at any time by using the `return`
    keyword, and that we can also use the return type in conjunction with the `return`
    keyword to make data from the function available to the code that called the function
    in the first place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We learned how we can use default and named arguments to provide different versions
    of the same function without writing multiple functions. This makes our code more
    succinct and manageable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered that there is even more to functions than we covered in this
    chapter, but that it is best to learn about these topics as they arise in the
    various projects sprinkled throughout this book.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will move on to the most trailed chapter. I have constantly referred
    and deferred to [Chapter 10](ch10.html "Chapter 10. Object-Oriented Programming"),
    *Object-Oriented Programming*. Finally, it is here, and we will see the real power
    of classes and objects combined with Kotlin. We will quickly see over the next
    few chapters that classes and objects are the key to unleashing the power of the
    Android API. We will soon be able to make our user interfaces come to life, and
    will build some real, usable apps that we can publish to the Play store.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向最受关注的章节。我一直在参考和推迟到[第10章](ch10.html "第10章 面向对象编程")，“面向对象编程”。最后，它来了，我们将看到类和对象与Kotlin结合的真正力量。在接下来的几章中，我们很快就会看到类和对象是释放Android
    API力量的关键。我们很快就能让我们的用户界面栩栩如生，并且将构建一些真正可用的应用程序，我们可以发布到Play商店。
