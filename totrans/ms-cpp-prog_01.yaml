- en: C++17 Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will be learning the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: C++17 background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is new in C++17?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What features are deprecated or removed in C++17?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++17 background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, the C++ language is the brain child of Bjarne Stroustrup, who developed
    C++ in 1979\. The C++ programming language is standardized by International Organization
    for Standardization (ISO).
  prefs: []
  type: TYPE_NORMAL
- en: The initial standardization was published in 1998, commonly referred to as C++98,
    and the next standardization C++03 was published in 2003, which was primarily
    a bug fix release with just one language feature for value initialization. In
    August 2011, the C++11 standard was published with several additions to the core language,
    including several significant interesting changes to the **Standard Template Library**
    (**STL**); C++11 basically replaced the C++03 standard. C++14 was published in
    December, 2014 with some new features, and later, the C++17 standard was published
    on July 31, 2017\.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, C++17 is the latest revision of the ISO/IEC
    standard for the C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter requires a compiler that supports C++17 features: gcc version
    7 or later. As gcc version 7 is the latest version at the time of writing this
    book, I''ll be using gcc version 7.1.0 in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you haven''t installed g++ 7 that supports C++17 features, you can
    install it with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo add-apt-repository ppa:jonathonf/gcc-7.1'
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get update
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get install gcc-7 g++-7`
  prefs: []
  type: TYPE_NORMAL
- en: What's new in C++17?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete list of C++17 features can be found at [http://en.cppreference.com/w/cpp/compiler_support#C.2B.2B17_features](http://en.cppreference.com/w/cpp/compiler_support#C.2B.2B17_features).
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a high-level idea, the following are some of the new C++17 features:'
  prefs: []
  type: TYPE_NORMAL
- en: New auto rules for direct-list-initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_assert` with no messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested namespace definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes for namespaces and enumerators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ exceptions specifications are part of the type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved lambda capabilities that give performance benefits on servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NUMA architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using attribute namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation for over-aligned data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template argument deduction for class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-type template parameters with auto type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteed copy elision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New specifications for inheriting constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct-list-initialization of enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stricter expression evaluation order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_mutex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, there are many new interesting features that were added to the core
    C++ language: STL, lambadas, and so on. The new features give a facelift to C++,
    and starting from `C++17`, as a C++ developer, you will feel that you are working
    in a modern programming language, such as Java or C#.'
  prefs: []
  type: TYPE_NORMAL
- en: What features are deprecated or removed in C++17?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following features are now removed in C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: The `register` keyword was deprecated in C++11 and got removed in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `++` operator for `bool` was deprecated in C++98 and got removed in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic exception specifications were deprecated in C++11 and and got removed
    in C++17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features in C++17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore the following C++17 key features one by one in the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Easier nested namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New rules for type detection from the braced initializer list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified `static_assert`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::invoke`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` and `switch` local-scoped variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template type auto-detection for class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier nested namespace syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until the C++14 standard, the syntax supported for a nested namespace in C++
    was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Every namespace level starts and ends with curly brackets, which makes it difficult
    to use nested namespaces in large applications. C++17 nested namespace syntax
    is really cool; just take a look at the following code and you will readily agree
    with me:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output remains the same as the previous program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: New rules for type auto-detection from braced initializer list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 introduced new rules for auto-detection of the initializer list, which
    complements C++14 rules. The C++17 rule insists that the program is ill-formed
    if an explicit or partial specialization of `std::initializer_list` is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Simplified static_assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `static_assert` macro helps identify assert failures during compile time.
    This feature has been supported since C++11; however, the `static_assert` macro
    used to take a mandatory assertion failure message till, which is now made optional
    in C++17.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of `static_assert` with and without
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can see that the message, `Assertion failed`,
    appears as part of the compilation error, while in the second compilation the
    default compiler error message appears, as we didn't supply an assertion failure
    message. When there is no assertion failure, the assertion error message will
    not appear as demonstrated in `static_assert ( x == y )`.  This feature is inspired
    by the C++ community from the BOOST C++ library.
  prefs: []
  type: TYPE_NORMAL
- en: The std::invoke( ) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::invoke()` method can be used to call functions, function pointers,
    and member pointers with the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `std::invoke( )` method is a template function that helps you seamlessly
    invoke callable objects, both built-in and user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: Structured binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can now initialize multiple variables with a return value with a really
    cool syntax, as shown in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, the code highlighted in **bold** is the structured
    binding feature introduced in C++17. Interestingly, we have not declared the `string
    name` and `int age` variables. These are deduced automatically by the C++ compiler
    as `string` and `int`, which makes the C++ syntax just like any modern programming
    language, without losing its performance and system programming benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If and Switch local scoped variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an interesting new feature that allows you to declare a local variable
    bound to the `if` and `switch` statements'' block of code. The scope of the variable
    used in the `if` and `switch` statements will go out of scope outside the respective
    blocks. It can be better understood with an easy to understand example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Template type auto-deduction for class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m sure you will love what you are about to see in the sample code.  Though
    templates are quite useful, a lot of people don''t like it due to its tough and
    weird syntax. But you don''t have to worry anymore; take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inline variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the inline function in C++, you could now use inline variable definitions.
    This comes in handy to initialize static variables, as shown in the following
    sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you got to know interesting new features introduced in C++17\.
    You learned the super simple C++17 nested namespace syntax. You also learned datatype
    detection with a braced initializer list and the new rule imposed in the C++17
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: You also noticed that `static_assert` can be done without assert failure messages.
    Also, using `std::invoke()`, you can now invoke global functions, function pointers,
    member functions, and static class member functions. And, using structured binding,
    you could now initialize multiple variables with a return value.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned that the `if` and `switch` statements can have a local-scoped
    variable right before the `if` condition and `switch` statements. You learned
    about auto type detection of class templates. Lastly, you used `inline` variables.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more C++17 features, but this chapter attempts to cover the most
    useful features that might be required for most of the developers.  In the next
    chapter, you will be learning about the Standard Template Library.
  prefs: []
  type: TYPE_NORMAL
