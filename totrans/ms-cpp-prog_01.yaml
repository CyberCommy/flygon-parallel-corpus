- en: C++17 Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will be learning the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: C++17 background
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is new in C++17?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What features are deprecated or removed in C++17?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features in C++17
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++17 background
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, the C++ language is the brain child of Bjarne Stroustrup, who developed
    C++ in 1979\. The C++ programming language is standardized by International Organization
    for Standardization (ISO).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The initial standardization was published in 1998, commonly referred to as C++98,
    and the next standardization C++03 was published in 2003, which was primarily
    a bug fix release with just one language feature for value initialization. In
    August 2011, the C++11 standard was published with several additions to the core language,
    including several significant interesting changes to the **Standard Template Library**
    (**STL**); C++11 basically replaced the C++03 standard. C++14 was published in
    December, 2014 with some new features, and later, the C++17 standard was published
    on July 31, 2017\.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, C++17 is the latest revision of the ISO/IEC
    standard for the C++ programming language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter requires a compiler that supports C++17 features: gcc version
    7 or later. As gcc version 7 is the latest version at the time of writing this
    book, I''ll be using gcc version 7.1.0 in this chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you haven''t installed g++ 7 that supports C++17 features, you can
    install it with the following commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo add-apt-repository ppa:jonathonf/gcc-7.1'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get update
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get install gcc-7 g++-7`
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: What's new in C++17?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete list of C++17 features can be found at [http://en.cppreference.com/w/cpp/compiler_support#C.2B.2B17_features](http://en.cppreference.com/w/cpp/compiler_support#C.2B.2B17_features).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a high-level idea, the following are some of the new C++17 features:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: New auto rules for direct-list-initialization
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_assert` with no messages'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested namespace definition
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline variables
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes for namespaces and enumerators
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ exceptions specifications are part of the type system
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved lambda capabilities that give performance benefits on servers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NUMA architecture
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using attribute namespaces
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation for over-aligned data
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template argument deduction for class templates
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-type template parameters with auto type
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guaranteed copy elision
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New specifications for inheriting constructors
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct-list-initialization of enumerations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stricter expression evaluation order
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_mutex`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String conversions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, there are many new interesting features that were added to the core
    C++ language: STL, lambadas, and so on. The new features give a facelift to C++,
    and starting from `C++17`, as a C++ developer, you will feel that you are working
    in a modern programming language, such as Java or C#.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: What features are deprecated or removed in C++17?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following features are now removed in C++17:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `register` keyword was deprecated in C++11 and got removed in C++17
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `++` operator for `bool` was deprecated in C++98 and got removed in C++17
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dynamic exception specifications were deprecated in C++11 and and got removed
    in C++17
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key features in C++17
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore the following C++17 key features one by one in the following
    sections:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Easier nested namespace
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New rules for type detection from the braced initializer list
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified `static_assert`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::invoke`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured binding
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` and `switch` local-scoped variables
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template type auto-detection for class templates
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline variables
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier nested namespace syntax
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until the C++14 standard, the syntax supported for a nested namespace in C++
    was as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every namespace level starts and ends with curly brackets, which makes it difficult
    to use nested namespaces in large applications. C++17 nested namespace syntax
    is really cool; just take a look at the following code and you will readily agree
    with me:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output remains the same as the previous program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: New rules for type auto-detection from braced initializer list
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++17 introduced new rules for auto-detection of the initializer list, which
    complements C++14 rules. The C++17 rule insists that the program is ill-formed
    if an explicit or partial specialization of `std::initializer_list` is declared:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simplified static_assert
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `static_assert` macro helps identify assert failures during compile time.
    This feature has been supported since C++11; however, the `static_assert` macro
    used to take a mandatory assertion failure message till, which is now made optional
    in C++17.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates the use of `static_assert` with and without
    the message:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding output, you can see that the message, `Assertion failed`,
    appears as part of the compilation error, while in the second compilation the
    default compiler error message appears, as we didn't supply an assertion failure
    message. When there is no assertion failure, the assertion error message will
    not appear as demonstrated in `static_assert ( x == y )`.  This feature is inspired
    by the C++ community from the BOOST C++ library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The std::invoke( ) method
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `std::invoke()` method can be used to call functions, function pointers,
    and member pointers with the same syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `std::invoke( )` method is a template function that helps you seamlessly
    invoke callable objects, both built-in and user-defined.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Structured binding
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can now initialize multiple variables with a return value with a really
    cool syntax, as shown in the following code sample:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding program, the code highlighted in **bold** is the structured
    binding feature introduced in C++17. Interestingly, we have not declared the `string
    name` and `int age` variables. These are deduced automatically by the C++ compiler
    as `string` and `int`, which makes the C++ syntax just like any modern programming
    language, without losing its performance and system programming benefits.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If and Switch local scoped variables
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is an interesting new feature that allows you to declare a local variable
    bound to the `if` and `switch` statements'' block of code. The scope of the variable
    used in the `if` and `switch` statements will go out of scope outside the respective
    blocks. It can be better understood with an easy to understand example, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Template type auto-deduction for class templates
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m sure you will love what you are about to see in the sample code.  Though
    templates are quite useful, a lot of people don''t like it due to its tough and
    weird syntax. But you don''t have to worry anymore; take a look at the following
    code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the program is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inline variables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the inline function in C++, you could now use inline variable definitions.
    This comes in handy to initialize static variables, as shown in the following
    sample code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以编译，并且可以使用以下命令查看输出：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you got to know interesting new features introduced in C++17\.
    You learned the super simple C++17 nested namespace syntax. You also learned datatype
    detection with a braced initializer list and the new rule imposed in the C++17
    standard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了C++17引入的有趣的新特性。您学会了超级简单的C++17嵌套命名空间语法。您还学会了使用大括号初始化列表进行数据类型检测以及C++17标准中引入的新规则。
- en: You also noticed that `static_assert` can be done without assert failure messages.
    Also, using `std::invoke()`, you can now invoke global functions, function pointers,
    member functions, and static class member functions. And, using structured binding,
    you could now initialize multiple variables with a return value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还注意到，`static_assert`可以在没有断言失败消息的情况下完成。此外，使用`std::invoke()`，您现在可以调用全局函数、函数指针、成员函数和静态类成员函数。并且，使用结构化绑定，您现在可以用返回值初始化多个变量。
- en: You also learned that the `if` and `switch` statements can have a local-scoped
    variable right before the `if` condition and `switch` statements. You learned
    about auto type detection of class templates. Lastly, you used `inline` variables.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学到了`if`和`switch`语句可以在`if`条件和`switch`语句之前有一个局部作用域的变量。您了解了类模板的自动类型检测。最后，您使用了`inline`变量。
- en: There are many more C++17 features, but this chapter attempts to cover the most
    useful features that might be required for most of the developers.  In the next
    chapter, you will be learning about the Standard Template Library.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++17有许多更多的特性，但本章试图涵盖大多数开发人员可能需要的最有用的特性。在下一章中，您将学习标准模板库。
