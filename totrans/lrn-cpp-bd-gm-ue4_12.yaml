- en: Building Smarter Monsters with Advanced AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The monsters we have so far don't really do a lot. They stand in one place until
    they get in range to see you, and then they head over to you and either do a melee
    attack or a shooting attack, depending on what you have set up. In a real game,
    you want your characters to do a lot more than that so they seem more real. That's
    where **Artificial Intelligence** (**AI**) comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'AI is a huge topic that has entire books devoted to it, but we''ll be covering
    a few ways UE4 supports making AI programming easier so you can easily create
    more realistic monsters. We''ll be doing a quick overview of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigation - Pathfinding and the NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior Trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment Query Systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine Learning and Neural Networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Genetic Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're interested in learning more after all that, there are many great books
    you can look at for a more in-depth look at what else you can do with AI.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation – pathfinding and the NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the monsters we've created only move in one direction—in a straight
    line directly toward your position. But what if there are mountains, buildings,
    trees, rivers, or other objects in the way? In many cases, a straight line just
    isn't possible. Right now, if the monster runs into a wall, it'll just stay there,
    which isn't very realistic. This is where pathfinding comes in.
  prefs: []
  type: TYPE_NORMAL
- en: What is pathfinding?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pathfinding is a way to figure out a path (usually the shortest and/or easiest
    one) to a destination. Picture the entire environment as a grid, with numbers
    in each cell saying how difficult it is to navigate. So a cell with a wall blocking
    the way would have a very high value, and a steep path could have a higher value
    than an easy path. The goal of pathfinding is to find the path with the lowest
    overall value when you add up all the cells along that path.
  prefs: []
  type: TYPE_NORMAL
- en: There are different algorithms, or methods, for handling pathfinding available.
    The most well-known one is called A* (pronounced *A star*).
  prefs: []
  type: TYPE_NORMAL
- en: What is A*?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We won't be using A* here, but you should at least be familiar with it if you
    plan on doing AI programming in the future, so I'll do a brief overview. A* basically
    searches the cells surrounding the character, prioritizing the ones with the lowest
    cost. It calculates the cost of the path so far (by adding up the costs up until
    that point) plus a heuristic, a guess on the cost from that point to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways of calculating a heuristic. It could be something as simple
    as the distance directly to the goal (as the crow flies, you might say). It's
    better for the results if the heuristic is actually lower than what the actual
    cost will turn out to be, so that works well.
  prefs: []
  type: TYPE_NORMAL
- en: Once you find the cell with the lowest cost, then go one step further and look
    at the cells surrounding that cell. You continue until you reach the goal. If
    you find yourself at a cell you've been to before and the total path cost this
    way is lower, you can replace it with the lower-cost path. This helps you get
    a shorter path. Once you get to the goal, you can follow the path backward and
    you'll have a complete path to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: You can find much more information on A* and other pathfinding algorithms online
    or in books on AI. You will need to know them if you do this in more complex projects,
    but for this, UE4 has a much simpler and easier way: using a `NavMesh`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `NavMesh` is an object in UE4 that you can place in your world to tell it
    what parts of the environment you want characters to be able to navigate. To do
    this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some obstacles. You can add cubes, cylinders, or anything else you want
    to add to block movement, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ba19b29-326b-4b73-ac0b-5da49506bf4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you've set up the level the way you want it, in the Modes window, go to
    Volumes, find Nav Mesh Bounds Volume, drag it onto the level, and scale it to
    cover the entire area you want the monsters to be able to navigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you try it now, you'll still see the monsters walk into walls and just stop.
    That's because we need to change the way movement is handled. We'll do this by
    creating our own `AIController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AIController class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow a step-by-step procedure to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class. In this case, you''ll need to check the Show All Classes
    checkbox and search to find `AIController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8be786b7-f5e5-466a-90c5-b5bef7eb9eb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name the class `MonsterAIController`. Your `MonsterAIController.h` should look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`MonsterAIController.cpp` should implement that function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also make sure to add `#include "Kismet/GameplayStatics.h"` at the top of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back into the `Tick()` function in `Monster.cpp`. Find the following line
    in the `else` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete this line and replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also add `#include "MonsterAIController.h"` at the top of the file, and go into
    `BP_Monster` and change the Ai Controller class to `MonsterAIController`. Now
    the monsters can find their way around the walls to you. If they don't move, check
    to make sure the `NavMesh` covers the area and is tall enough to cover the characters.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, all the logic for controlling your monsters is in the `Tick()` function
    in `Monster.cpp`. But what you've done so far is pretty simple. In large, complex
    games, the monsters will have a lot more behaviors. They could patrol an area
    until they see you, or even communicate with you and only attack if the conversation
    doesn't go well. The logic for all this would get much too complicated to keep
    everything in one function, or even in the `AMonster` class.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, UE4 has another way of managing complex tasks, and that is a Behavior
    Tree. A Behavior Tree lets you visually set up a series of tasks to make them
    easier to manage. Since we're focused on C++ here, we'll be creating the tasks
    themselves that way, but the overall tree seems to be easier to manage in Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behavior Trees are primarily controlled by two different types of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selectors**: Selector will run through its children, from left to right,
    until one succeeds, and then goes back up the tree. Think of it like an `or` statement—once
    it finds one true argument, the `or` itself is true so it is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequences**: Sequences instead go through the children from left to right
    until one fails. This is more like an `and` statement that keeps going until something
    comes up as false, rendering the whole statement false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if you want to run multiple steps, you will use Sequences, whereas if you
    just want to run one successfully and stop, you will use Selector.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Behavior Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, you need to go into your library (put it in a folder name that makes
    sense so you''ll remember where to find it, or Blueprints will work) and, from
    Add New, select Artificial Intelligence | Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45cc7752-e2b6-4b38-932b-a2cbbc892b6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I named mine `MonsterBT`. You will also need to create a Blackboard. This stores
    the data you will use in the Behavior Tree and lets you transfer it easily between
    the AI Controller and the Behavior Tree. You create that by going to Add New and
    this time selecting Artificial Intelligence | Blackboard. I named this one `MonsterBlackboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aed7c42b-29df-495d-9c15-63837eff7415.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up Blackboard values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, you''ll want to set up values in the Blackboard you just created. You
    do this by selecting New Key and then selecting a type (in this case, Bool). For
    this, I''ve added two of them, IsInAttackRange and IsInFollowRange:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd5fe05d-6f94-4222-a2f7-ebe86f1eefe7.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also give each one a description of what it is used for.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a BTTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be creating a C++ task to handle following the player. To do this,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new C++ class and base it off BTTaskNode (you will need to view all classes
    and search for it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb9cd044-3520-4c1a-b69a-dbefc762d5e9.png)'
  prefs: []
  type: TYPE_IMG
- en: I named the new class `BTTask_FollowPlayer`
  prefs: []
  type: TYPE_NORMAL
- en: 'In `BTTaskFollowPlayer.h`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We won't be using `OnGameplayTaskActivated`, but, without declaring it, your
    code may not compile (if you get a complaint about it not being there, that's
    why)
  prefs: []
  type: TYPE_NORMAL
- en: 'In `BTTaskFollowPlayer.cpp`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Once you have this working, you can go back and create another `BTTask` to handle
    attacking too, as well as any other behaviors you might want.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Behavior Tree itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have the task set up, it''s time to set up the tree itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on it to open the Blueprints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4985b890-0951-4a29-b528-09c21619402f.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the yellow area on the bottom of Root and drag it out to create a new
    node (it's black but turns yellow when the mouse rolls over it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the type from the menu that comes up (we''ll use Selector):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f26c5c77-9cbf-4f45-a37d-4cdfc6d342bb.png)'
  prefs: []
  type: TYPE_IMG
- en: The selector icon in the center tab
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e7d45c8-0303-4cd9-ac6a-6c502be69764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned before, the Selector will go through nodes in left-to-right order
    until one succeeds, and then stop. In this case, we have three possible states:
    in attack range, in sight range, and neither (ignore the player). First, you want
    to check whether you''re close enough to attack, which means you''ll want to check
    IsInAttackRange in your Blackboard.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't do follow first because the attack range is still technically in follow
    range, but you don't want to use the follow functionality, so the Selector will
    stop after checking for follow range because that's the first check it makes,
    so it will never check for attack range (which is what it should really be checking).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check which state it needs to be in, you''ll need to check the Blackboard
    value, which you do by using a decorator. To do this, click the bottom of the
    Selector and drag off a new node to the left like you did when you created that
    node, and choose a Composite Selector node this time. This node allows you to
    right-click; choose Add Decorator..., and make sure you choose the Blackboard
    type. Once you add it, you can select the blue Decorator on top. You should be
    able to check the Key Query IsSet and select the value you want to check, in this
    case IsInAttackRange (if it doesn''t show up, make sure MonsterBlackboard is set
    in the details as the blackboard; it should be set automatically normally):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b101c01b-ea3c-4dfc-8234-78df2ae18134.png)'
  prefs: []
  type: TYPE_IMG
- en: The attack node will eventually go to an Attack task, but for now, I just put
    in a Wait as a placeholder (a built-in task that allows you to specify a wait
    time in seconds).
  prefs: []
  type: TYPE_NORMAL
- en: To the right of it, you'll also want to add another Composite with a Decorator
    that checks for IsInFollowRange. This will use the new task you created (if it
    doesn't show up, make sure you have compiled your code and that there aren't any
    errors).
  prefs: []
  type: TYPE_NORMAL
- en: 'To the right of that, I added a Wait task in the event that both cases fail.
    When you''re done, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/195cf009-e901-4bed-a965-f8228644e407.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you're ready to go back and modify your existing code to use all this.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the MonsterAIController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll be adding a lot more functionality to your `AIController` class now
    to support the Behavior Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new `MonsterAIController.h` should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Also make sure you add `#include "BehaviorTree/BehaviorTreeComponent.h"` at
    the top of the file. Here, you are overriding the constructor as well as the `Possess`
    and `UnPossess` classes. The `SetFollowRange` and `SetAttackRange` functions are
    new and let you set the Blackboard values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following functions to `MonsterAIController.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the following lines at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`StartFollowingPlayer` remains the same so it is not listed here, but make
    sure you leave that in there! Now it''s time to update your `Monster` class (you
    won''t be able to compile until you do that).'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Monster class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be doing the following updates in the `Monster` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Monster.h`, the only change you''ll be making is to add the following lines
    of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Monster.cpp`, you''ll be making some big changes to the `Tick()` function,
    so here is the full version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The changes are to set the values for both the attack and follow ranges. The
    code for attacking is still in there, but if you move TimeSinceLastStrike and
    AttackTimeout into the Blackboard, you can use that to move all that functionality
    into a `BTTask`. Now make sure everything compiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it compiles, you need to open the `BP_Monster` Blueprint and set the Behavior
    Tree like this (it can also be set on individual Monsters if you want them to
    be different):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c3c7768e-704d-47e1-a96d-31ae6e04bce5.png)'
  prefs: []
  type: TYPE_IMG
- en: Also make sure the AI Controller is set to MonsterAIController. If you run the
    game at this point, the functionality should be the same, but the Behavior Tree
    will be controlling the following of the player.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to learn more, look into moving the `Attack` code into a `BTTask`
    class, and also look into what the monsters can do while you're out of range (read
    the next section for something that might help with that).
  prefs: []
  type: TYPE_NORMAL
- en: Environment Query Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Environment Query Systems** (**EQS**) are new and still experimental. They
    allow you to create a query in your Behavior Tree to search through the items
    in a level and find one that best fits the criteria you set up. Maybe you want
    your monsters to wander between set waypoints you set up instead of standing still
    when the player is out of range. You can set up a query to look for the closest
    one, or use some other criteria. EQS allow you to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to enable this in the Settings to be able to use them. To do this,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Edit | Editor Preferences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6395ceb-67fc-4d78-84d0-f29c8e2ee2c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under Experimental | AI, check off Environment Querying System:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e30ed859-293d-4372-8471-864a91f53b5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a new query by going to Add New | Artificial Intelligence. Environment
    Query will now appear under Behavior Tree and Blackboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/18186d59-76d5-4cf2-bf62-995a0863e37a.png)'
  prefs: []
  type: TYPE_IMG
- en: You also need to create a `Context` and a `Generator` in Blueprints (the `Generator`
    will get all the items of a specific type, such as waypoints). To actually run
    the query, you create a Run EQS Query task node in your Behavior Tree. For more
    information on how Environment Query Systems work, see the Unreal documentation
    at [https://docs.unrealengine.com/en-us/Engine/AI/EnvironmentQuerySystem](https://docs.unrealengine.com/en-us/Engine/AI/EnvironmentQuerySystem).
  prefs: []
  type: TYPE_NORMAL
- en: Flocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a lot of monsters on the screen all moving at once, you'll want
    them to move in a way that looks realistic. You don't want them walking into each
    other or all going off in different directions.
  prefs: []
  type: TYPE_NORMAL
- en: AI researchers have looked into this and come up with algorithms to handle this
    realistically. They're called flocking algorithms because they're based on the
    behavior of a flock of birds.
  prefs: []
  type: TYPE_NORMAL
- en: When moving together, monsters have to think of more than just getting to the
    same goal. They also have to take into account the monsters they are moving with.
    They have to make sure they don't get too close to the monsters immediately surrounding
    them, nor should they move too far away or they'll drift apart.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, there is one monster selected as the leader. That monster heads
    toward the goal, and the others focus on following that leader.
  prefs: []
  type: TYPE_NORMAL
- en: There are many good references on flocking online. It's not built into UE4,
    but you can buy extensions or program your own flocking system.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to machine learning and neural networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine learning and neural networks are huge topics, so I'll only be giving
    a brief introduction here. Machine Learning is how you can teach a program to
    figure out how to respond to something, instead of just giving it rules. There
    are many different algorithms for doing this, but they all require a lot of sample
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, you give the learning program a large amount of example cases (the
    more the better), *and* the best results for each case. You can rate them in different
    ways. By looking at so many cases, it can make the best guess on similar cases
    based on results it has seen in the past. With enough training data, the results
    can be very good, although you can still run into cases it won't work well for.
  prefs: []
  type: TYPE_NORMAL
- en: Since this requires so much data (not to mention processing power), except in
    rare cases, this is done by game companies before the game is shipped (if it's
    done at all—this sort of thing tends to get cut in favor of deadlines). The training
    is done offline, and the program has already learned what to do.
  prefs: []
  type: TYPE_NORMAL
- en: Neural Networks are a specific type of machine learning made to emulate the
    way the brain processes data. There are nodes that work like neurons. There can
    be multiple layers of nodes and each layer processes the results of the previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Data is sent across multiple nodes, and each node adjusts that data based on
    some threshold amount. Only data can be passed back (or forward) to the nodes,
    which then adjust those threshold values to get more accurate results to the training
    data. Once they've been trained, those threshold values can be used for future
    decisions.
  prefs: []
  type: TYPE_NORMAL
- en: While we're still very far from making a true AI, neural networks have been
    used with interesting results. Neural networks have been trained on music of a
    specific genre and have then generated very impressive (and original) music that
    sounds similar to the genre it was trained on. I've also heard of neural networks
    being written to attempt to write books. I think we're still a long way from a
    neural network that can write UE4 programs, though!
  prefs: []
  type: TYPE_NORMAL
- en: Genetic algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall your high school biology; you probably learned about genetics. Chromosomes
    from two different parents combine to create a child that combines the DNA from
    both parents, and random genetic mutations can also make changes. Genetic algorithms
    are based on the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like in Darwin''s survival of the fittest, you can do something very similar
    in code. Genetic algorithms have three basic principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selection**: You pick the examples that have the best results, and those
    are the basis for the next generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crossover**: Two of these selected examples are then combined to create a
    child that is a product of both, just like in biology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random genetic mutations are introduced**: There could be some good traits
    that the old ones didn''t have, or that got thrown out because those traits were
    overwhelmed by other traits. This means you don''t miss out on some potentially
    great traits just because they weren''t in the original population.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've seen, AI is a huge topic, and we've only touched on the basics here.
    We've gone over the basics of pathfinding (with the NavMesh), Behavior Trees,
    environment query systems, Flocking, machine learning and neural networks, and
    Genetic algorithms. There are entire books out there if you want to learn more,
    as well as numerous websites, such as [http://aigamedev.com/](http://aigamedev.com/),
    and articles on [https://www.gamasutra.com](https://www.gamasutra.com).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn to cast spells to defend your player from
    the monsters.
  prefs: []
  type: TYPE_NORMAL
