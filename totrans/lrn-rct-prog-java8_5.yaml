- en: Chapter 5. Combinators, Conditionals, and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the programs that we write handle data from different sources. These
    sources can be both external (files, databases, servers, and many others) and
    internal (different collections or branches of the same external source). There
    are many cases in which we'll want to have these sources depend on each other
    in one way or another. Defining these dependencies is a necessary step in building
    our programs. The idea of this chapter is to introduce the `Observable` operators
    capable of that.
  prefs: []
  type: TYPE_NORMAL
- en: We saw an example of combined `Observable` instances in the first and second
    chapters. Our "Reactive Sum" program had one external data source—the user input
    but it branched it into two internal data sources, depending on the custom format.
    We saw how we can use the `filter()` operator instead of procedural `if-else`
    constructions. Later, we combined these data flows into one, with the help of
    a combinator.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to react to errors from inside the `Observable` instance chain.
    Remember, being able to react to failures makes our programs resilient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Combining the `Observable` instances using operators such as `combineLatest()`,
    `merge()`, `concat()`, and `zip()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dependencies between the `Observable` instances using conditional operators
    such as `takeUntil()`, `skipUntil()`, and `amb()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling using operators such as `retry()`, `onErrorResumeNext()`, and
    `onErrorReturn()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the Observable instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll first look at the `zip(Observable, Observable, <Observable>..., Func)`
    operator, which can *combine* two or more `Observable` instances using a *combining*
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The zip operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function passed to the `zip` operator has as many parameters as the number
    of the `Observable` instances passed to the `zip()` method. When all of these
    `Observable` instances emit at least one item, the function is called with the
    parameter values first emitted by each of the `Observable` instances. Its result
    will be the first emitted item by the `Observable` instance created via the `zip()`
    method. The second item emitted by this `Observable` instance will be a combination
    (computed using the function parameter of the `zip()` method) of the second items
    of the source `Observable` instances. Even if one of the source `Observable` instances
    has emitted three or more items, its second emitted item is used. The resulting
    `Observable` instance always emits the same number of items as the source `Observable`
    instance, which emits the fewest items and then completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior can be better seen in this marble diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The zip operator](img/4305_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a very simple example of using the `zip()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The example is similar to the marble diagram and outputs the same result. The
    first item emitted by the `Observable` instance created by the `zip()` method
    is emitted by the time all of the sources have emitted at least one item. This
    means that even if one of the sources emits all of its items, the result will
    be emitted only when all of the other sources emit items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you remember the `interval()` operator from [Chapter 3](ch03.html "Chapter 3. Creating
    and Connecting Observables, Observers, and Subjects"), *Creating and Connecting
    Observables, Observers, and Subjects*, it is able to create an `Observable` instance
    emitting sequential numbers every `<n>` milliseconds. What if you want to emit
    a sequence of, say, arbitrary objects instead? This is possible by combining the
    `interval()` and `from()` or `just()` methods using the `zip()` method. Let''s
    look at an example of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will output `Z` after 300 milliseconds, `I` after another 300 milliseconds,
    `P` after the same interval , and another `P` after `300` more milliseconds. After
    that, the `timedZip` `Observable` instance will complete. That's because the source
    `Observable` instance, created via the `interval()` method emits, its element
    every `300` milliseconds, and it determines the speed of the `timedZip` parameter
    emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `zip()` method has an instance method version too. The operator is called
    `zipWith()`. Here is an analogous example to the preceding one but using the `zipWith()`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll get to know the *combinator* we first saw in [Chapter 1](ch01.html
    "Chapter 1. An Introduction to Reactive Programming"), *An Introduction to Reactive
    Programming*, while implementing *'The Reactive Sum'*.
  prefs: []
  type: TYPE_NORMAL
- en: The combineLatest operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `combineLatest()` operator has the same parameters and overloads as the
    `zip()` operator but behaves a bit differently. The `Observable` instance it creates
    emits the first item as soon as there is at least one of each source, taking the
    last of each. After that, the `Observable` instance it creates emits an item whenever
    any of the source `Observable` instances emits an item. The number of items emitted
    by the `combineLatest()` operator depends entirely on the order of items emitted,
    since multiple items could be emitted from a single source before there is one
    of each source. Its marble diagram looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The combineLatest operator](img/4305_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the color of the items emitted by the combining `Observable`
    instance are the same as the colors of those items triggering their emission.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, will be using three source `Observable` instances,
    created by the `interval()` and `zipWith()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the function used for zipping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the same method of inserting delays between emissions as seen in the
    section about the `zip()` method. These three `Observable` instances can be used
    to compare the different combining methods. The `Observable` instance containing
    greetings emits every second, the one containing names emits every second and
    a half, and the one with punctuation signs every 1.1 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `combineLatest()` operator, we can combine them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will combine the different source items in sentences. The first sentence
    will be emitted after a second and a half because all the sources have to emit
    something in order for the combined `Observable` instance to start its emissions.
    This sentence will be `'Hello Meddle.'`. The next sentence will be emitted the
    moment any of the sources emits something. This will happen two seconds after
    subscribing, because the greetings `Observable` instance emits every second; it
    will emit `'Hi'`, and this will make the combined `Observable` instance emit `'Hi
    Meddle.'`. When 2.2 seconds pass, the punctuation `Observable` instance will emit
    `'?'`, so we'll have another sentence—`'Hi Meddle?'`. This will continue until
    all of the sources are completed.
  prefs: []
  type: TYPE_NORMAL
- en: The `combineLatest()` operator is very useful when we need computation or notification
    when any of the data sources we depend on changes. The next method is simpler;
    it just merges the emissions of its sources, *interleaving* them in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The merge operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we want to get feeds from multiple sources as one stream, we can use the
    `merge()` operator. For example, we can have many `Observable` instances emitting
    data from different `log` files. We don't care which `log` file is the source
    of the current emission, we just want to see all the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram of the `merge()` operator is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The merge operator](img/4305_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every item is emitted at its original emission time, and the source doesn''t
    matter. An example using the three `Observable` instances introduced in the previous
    section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It just emits different words/punctuation signs. The first word emitted will
    come from the greetings `Observable` instance, one second after the subscription
    (because greetings emits every second) `'Hello'`; then `'.'` will be emitted after
    100 milliseconds because the punctuation `Observable` instance emits its items
    every 1.1 seconds. After 400 milliseconds, one second and a half after the subscription,
    `'Meddle'` will be emitted. Next is the greeting `'Hi'`. Emissions will continue
    to take place until the source `Observable` instance, which takes the most time,
    completes.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that if any of the sources emits an `OnError` notification,
    the `merge Observable` instance emits the *error* too and completes with it. There
    is a form of `merge()` operator that delays emitting errors until all the error-free
    source `Observable` instances are completed. It is called `mergeDelayError()`.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to combine our sources in such a way that their items don't interleave
    in time and the emissions of the first passed source take precedence over the
    next one, we will be using the last combinator that this chapter introduces—the
    `concat()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The concat operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the chapters in this book are in different files. We want to concatenate
    the content of all of these files into one big file, representing the whole book.
    We can create an `Observable` instance for each chapter-file with the `from(Path)`
    method that we created earlier, and we can use the `concat()` operator with these
    `Observable` instances as sources to concatenate them in the right order in one
    `Observable` instance. If we subscribe to this `Observable` instance with a method
    that writes everything in a file, we'll have our book-file in the end.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `conact()` operator won't work well with infinite `Observable`
    instances. It will emit the notifications of the first one, but it will block
    the others. The main difference between the `merge()` and `concat()` operators
    is that `merge()`subscribes to all source `Observable` instances at the same time,
    whereas `concat()`has exactly one subscription at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The marble diagram of the `concat()` operator looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The concat operator](img/4305_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of concatenating the three `Observable` instances from the
    previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will output all of the greetings, one by one, every second, then the names
    every second and a half, and finally the punctuation signs every 1.1 seconds.
    Between the greetings and the names there will be a second and a half.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one operator, similar to the `concat()` operator, called `startWith()`.
    It prepends items to an `Observable` instance and has overloads that take one,
    two, three, and so on, up to nine values, with an `Iterable` instance or another
    `Observable` instance. Using the overload taking another `Observable` instance
    as a parameter, we can simulate the `concat()` operator. Here is the preceding
    example implemented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The greetings `Observable` instance is prepended to the names one, and the result
    of this is prepended to the punctuation of the `Observable` instance, creating
    the same `Observable` instance of concatenated sources as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding and all the previous examples in this chapter
    can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/CombiningObservables.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'Good use of the `startWith()` operator is when it is used with the `combineLatest()`
    operator. If you remember the initial implementation of our *''Reactive Sum''*
    example, you had to enter both the `a` and `b` values in order to calculate the
    initial sum. But suppose we modify the construction of the sum like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will have an initial sum of `0.0` even before the user has entered anything
    and the situation in which the user has entered `a` for the first time and not
    yet gave value to `b` in which case we don't see the sum won't occur.
  prefs: []
  type: TYPE_NORMAL
- en: Again, like with the `merge()` operator, the `concat()` operator has an instance
    form—the `concatWith()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, we saw how we can combine different `Observable`
    instances. But combining is not the only interaction between the `Observable`
    instances. They can depend on each other or manage each other. There is a way
    of getting one or more `Observable` instances to create conditions changing the
    behavior of other `Observable` instances. It's achieved through conditional operator/operators.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to make it so that one `Observable` instance won't begin its
    emissions until another emits, or so that it would emit only if another doesn't
    emit anything. These `Observable` instances are able to emit items under given
    conditions, and these conditions are applied to them using *conditional* operators.
    In this section, we'll take a look at some of the *conditional* operators provided
    by RxJava.
  prefs: []
  type: TYPE_NORMAL
- en: The amb operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `amb()` operator has overloads that take from two up to nine source `Observable`
    instances or an `Iterable` instance of the `Observable` instances. It emits the
    items of the source `Observable` instance that starts emitting first. It doesn''t
    matter what this is, whether `OnError`, `OnCompleted` notification, or data. Its
    diagram looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The amb operator](img/4305_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This operator has an instance form too. It is called `ambWith()` and can be
    called on one `Observable` instance in argument with another `Observable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This *conditional* operator is good for reading from multiple sources of similar
    data. The subscriber won''t care about the origin of the data. It can be used
    to implement simple caching, for example. Here is a little example of how it may
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first `amb()` operator will emit the items of the *words* `Observable` instance,
    because the *interval* `Observable` instance will have to wait for half a second
    before emitting, and the *words* will begin emitting immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The emission of the second `amb Observable` instance will be decided at random.
    If the first source `Observable` instance emits its data before the second, its
    emission will be mirrored by the `amb Observable` instance, but if the second
    source emits first, the `amb Observable` instance will emit its data.
  prefs: []
  type: TYPE_NORMAL
- en: The takeUntil(), takeWhile(), skipUntil(), and skipWhile() conditional operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw operators similar to these in the previous chapter. The `take(int)`
    operator filtered only the first *n* items. These operators also filter items,
    but *based on conditions*. The `takeUntil()` operator takes another `Observable`
    instance, and until this other `Observable` instance emits, the source''s items
    are emitted; after that, the `Observable` instance created by the `takeUntil()`
    operator completes. Let''s look at an example of using these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: For these examples, we'll use the *words* and *interval* `Observable` instances.
    The *words* `Observable` instance emits a word every 200 milliseconds, and the
    *interval* `Observable` emits every half a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned previously, this overload of the `takeUntil()` operator will emit
    words until the `interval Observable` emits. So, the words `one` and `way` will
    be emitted because the next word, `or`, should be emitted 600 milliseconds after
    the subscription, and the `interval Observable` emits on the 500th millisecond.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, the `takeWhile()` operator puts a condition on the `words Observable`.
    It will emit only while there are words that contain more than two letters. Because
    ''`or''` has two letters, it won''t be emitted and all the words after it will
    be skipped too. The `takeUntil()` operator has a similar overload, but it emits
    only words containing fewer than three letters. There is no `takeWhile(Observable)`
    operator overload as it would be `zip()` operator essentially: emit only if the
    other emits too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `skip*` operators are analogous to the `take*` ones. The difference is that
    they don't emit until/while a condition is satisfied. In this example, the words
    `one` and `way` are skipped because they are emitted before the 500th millisecond
    of subscribing and the `interval Observable` begins emitting at the 500th millisecond.
    The word `'or'` and all the words coming after it are emitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These *conditional* operators can be used, for example, for displaying loading
    animation in GUI applications. The code can be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On every emission of the `loadingAnimationObservable` variable, some short-lived
    animation will be displayed to the user. When the request is returned, the animation
    will no longer be displayed. This is another way of branching the logic of a program.
  prefs: []
  type: TYPE_NORMAL
- en: The defaultIfEmpty( ) operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of the `defaultlfEmpty()` operator is to return something useful if
    an unknown source turns out to be empty. For example, we'll use locally stored
    information, if a remote source has nothing new.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this will output `5` and will complete.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the `amb()`, `take*`, `skip*`, and `defaultIfEmpty()` operator
    examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/Conditionals.java).
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have transformed, filtered, and combined data. But what about
    the *errors*? Our applications can enter into error state at any time. Yes, we
    can subscribe for *errors* emitted by the `Observable` instances, but this will
    terminate our logic. In the `subscribe` method, we are outside of the `Observable`
    chain of operators. What if we want to react to an *error* from within the `Observable`
    instances chain and to try to prevent the termination? There are some operators
    that help us do that, and we'll be examining them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with *errors* in RxJava, you should be aware that they terminate
    the `Observable` chain of actions. Much like with your normal procedural code,
    once you are in the catch block, you can't go back to the code that has thrown
    the exception. You can execute some backup logic though and use it instead of
    failing the program. The `return*`, `retry*`, and `resume*` operators do something
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: The return and resume operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `onErrorReturn` operator can be used in order to prevent the `Subscriber`
    instance''s `onError` from being called. Instead, it will emit one last item and
    complete. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Integer::parseInt` method will succeed in converting the strings `1` and
    `2` to `Integer` values, but it will fail on `three` with a `NumberFormatException`
    exception. This exception will be passed to the `onErrorReturn()` method, which
    will return the number -`1`. The `numbers Observable` instance will emit the number
    -`1` and complete. So the output will be `1`, `2`, `-1`, `OnCompleted` notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fine, but sometimes we''ll want to switch to another Observable chain
    of operations on exception. For that, we can use the `onExceptionResumeNext()`
    operator, which returns a backup `Observable` instance that will replace the source
    one when an `Exception` occurs. Here is the code modified to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now this will output `1`, `2`, `5`, `4`, `3`, `2`, `1`, `OnCompleted` notification
    because, after the `Exception` raised on `'three'`, the `defaultOnError Observable`
    instance passed to `onExceptionResumeNext()` method will begin emitting, replacing
    the source `Observable` instance for all the `Subscriber` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There is one other `resuming()` operator very similar to `onExceptionResumeNext()`.
    It is called `onErrorResumeNext()`. It can replace the `onExceptionResumeNext()`
    operator in the preceding example, and the result will be the same. There are
    two differences between these two operators though.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `onErrorResumeNext()` operator has an additional overload that takes
    a lambda expression, returning the `Observable` instance (similar to the `onErrorReturn()`
    method). Second, it will react to every kind of error. The `onExceptionResumeNext()`
    method reacts only to instances of the `Exception` class and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the result will be the same as in the preceding one `(1, 2,
    5, 4, 3, 2, 1, OnCompleted notification b)`; it doesn't matter that there is an
    *assertion error*. But if we've used an `onExceptionResumeNext()` operator, the
    error would have reached the `subscribePrint` method as an `OnError` *notification*.
  prefs: []
  type: TYPE_NORMAL
- en: The `doOnNext()` operator used in this example is a *side effect generator*.
    It doesn't change the items emitted by the `Observable` instance it is called
    upon. It can be used for logging, caching, asserting, or adding additional logic.
    There are `doOnError()` and `doOnCompleted()` operators too. In addition, there
    is a `finallyDo()` operator, which executes the function passed to it when there
    is an error or when the `Observable` instance has completed.
  prefs: []
  type: TYPE_NORMAL
- en: The retrying technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrying is an important technique. When an `Observable` instance is emitting
    data from an uncertain source (for example, a remote server), one network problem
    could terminate the whole application. Retrying on *errors* saves us in situations
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting the `retry()` operator into the `Observable` action chain means that
    if an *error* occurs, the subscribers will resubscribe to the source `Observable`
    instance and try everything from the beginning of the chain. If there is an *error*
    again, everything is restarted once more. The `retry()` operator without parameters
    retries infinitely. There is an overload `retry(int)` method, which takes the
    number of the maximum allowed retry attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate the `retry()` method, we will use the following special
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: An `ErrorEmitter` instance can be passed to the `Observable.create()` method.
    If the `throwAnErrorCounter` field is a number greater than four, a `FooException`
    exception is sent; if it's greater than zero, a `BooException` exception is sent,
    and if it's less than or equal to zero, it sends some events and completes normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at this example of using the `retry()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the initial value of the `throwAnErrorCounter` field is five, it will
    retry `five` times, and when the counter becomes zero, the `Observable` instance
    will *complete*. The result will be `1`, `2`, `1`, `2`, `1`, `2`, `1`, `2`, `1`,
    `2`, `1`, `2`, `3`, `4`, `OnCompleted` notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `retry()` operator can be used to retry a set number of times (or indefinitely).
    It even has an overload, taking a function with two arguments—the number of the
    retries until now and cause `Throwable` instance. If this function returns `True`,
    the `Observable` instance is resubscribed to. This is a way of writing custom
    retry logic. But what about delayed retries? For example, retrying every second?
    There is one special operator capable of very complex *retrying logic*, the `retryWhen()`
    operator. Let''s look at an example of using it and the previously mentioned `retry(predicate)`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the `retryWhen()` operator returns an `Observable` instance, emitting the
    `OnError()` or `OnCompleted()` notifications, the notification is propagated,
    and if there is no other *retry/resume*, the `onError()` or `onCompleted()` methods
    of the subscribers are called. Otherwise, the subscribers will be resubscribed
    to the source observable.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if the `Exception` is `FooException`, the `retryWhen()` operator
    returns an `Observable` instance emitting after a second. That's how we implement
    retrying with a delay. If the `Exception` is not `FooException`, it is propagated
    to the next `retry(predicate)` operator. It can check the type of the *error*
    and the number of attempts and decide if it should propagate the error or retry
    the source.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll get one delayed retry, three retries from the `retry(predicate)`
    method, and on the fifth try, the subscribers will receive an `OnError` notification,
    with a `BooException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the `retry`/`resume`/`return` examples can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HandlingErrors.java).
  prefs: []
  type: TYPE_NORMAL
- en: The last section of this chapter is saved for a more complex example. We'll
    use our knowledge so far to create a request to remote HTTP API and handle the
    result, outputting it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP client example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use RxJava to retrieve information about the GitHub repositories of
    a user by *username*. We will use our `subscribePrint()` function used previously
    to output the information to the system output. The idea of the program is to
    display all of the public repositories of the user that are not forks. The main
    part of the program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This program uses my user (it can be easily reworked to use a *username* passed
    as a parameter) to retrieve information its public repositories. It prints the
    name of each repository and the main programming language used in it. The repositories
    are represented by `Map` instances generated from the incoming JSON file, so we
    can read repository properties from them.
  prefs: []
  type: TYPE_NORMAL
- en: These JSON `Map` instances are emitted by an `Observable` instance, created
    by the `githubUserInfoRequest(client, username)` method. The client parameter
    is an instance of Apache's `HttpAsyncClient` class. The client is capable of performing
    asynchronous HTTP requests, and there is an additional RxJava module, called `RxApacheHttp`,
    that gives us bindings between RxJava and Apache HTTP. We'll be using it for our
    HTTP request implementation; you can find it at [https://github.com/ReactiveX/RxApacheHttp](https://github.com/ReactiveX/RxApacheHttp).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many additional RxJava projects, placed at [https://github.com/ReactiveX](https://github.com/ReactiveX).
    Some of them are very useful. For example, most of the `from(Stream/Reader/File)`
    methods that we have implemented in this book have better implementations in the
    `RxJavaString` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to implement the `githubUserInfoRequest(HttpAsyncClient, String)`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This method is fairly simple too.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to have a GitHub *username* in order to execute our request, so
    we do some checking for it. It should not be `null`. If it's `null`, we'll return
    an *error-emitting* `Observable` instance, emitting an `OnError` notification
    with a `NullPointerException` exception. Our printing subscriber function will
    display it to the users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to do the actual HTTP request, we'll use another method with the signature
    `requestJson(HttpAsyncClient, String)`. It is the one returning the `Observable`
    instance, emitting JSON represented by the Map instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user is not a real GitHub user, or if we've exceeded the GitHub API limit,
    GitHub will send us a JSON message. That's why we need to check whether the JSON
    we've got contains repository data or something else. The JSON representing a
    repository has a `git_url` key. We use this to filter only JSONs that represent
    GitHub repositories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need only the non-fork repositories; that's why we filter them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is again quite simple to understand. Up until now, we''ve used only the
    `map()` and `filter()` operators in our logic, nothing special. Let''s look at
    the actual HTTP request implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ObservableHttp` class comes from the `RxApacheHttp` module. It does the
    asynchronous HTTP request for us, using the Apache `HttpClient` instance. The
    `createGet(url, client)` method returns an instance that can be converted into
    an actual `Observable` instance with the `toObservable()` method. We do exactly
    that here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `Observable` instance, when it receives the HTTP response, will emit it
    as an `ObservableHttpResponse` instance. This instance has a `getContent()` method,
    which returns an `Observable<byte[]>` object, representing the response as a *sequence
    of bytes*. We turn these *byte arrays* into `String` objects with a simple `map()`
    operator. Now we have a JSON response represented by a `String` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is some problem connecting to GitHub, we *retry* five times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cast to `String` is necessary because of Java's type system. Additionally,
    we remove any trailing/leading white spaces from the response, using the `trim()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We clear the cached information for this URL. We use a simple in-memory Map
    instance from URL to JSON data cache implementation in order to not repeat the
    same request multiple times. How do we fill up this cache? We''ll see soon in
    the following piece of code. Let''s take a look at it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The response can be either a JSON array or a JSON object; we branch our logic
    using the `filter()` operator here. The JSON object is turned to a JSON array
    in order to use common logic later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `ambWith()` operator, we'll use the one emitting data from the two
    `Observable` instances and treat the result as a JSON array. We will have either
    array or object JSON, and in the end, the result is just an `Observable` instance
    emitting a JSON array as a `String` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We turn this `String` object into actual List of Map instances, using Google's
    JSON library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `flatMapIterable()` operator flattens the `Observable` instance emitting
    a `List` instance to one that emits its contents—multiple Map instances representing
    JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these Map instances are cached by adding them to the in-memory cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `amb()` operator, we implement the fallback-to-cache mechanism. If
    the cache contains data, it will emit first, and this data will be used instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have a real example of HTTP data retrieval, implemented using `Observable`
    instances! The output of this request look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for the preceding example can be found at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter05/HttpRequestsExample.java).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've learned how to combine `Observable` instances, how to
    create dependencies between them, and how to react to errors. As we've seen in
    the final example, we are now capable of creating quite complex logic using just
    `Observable` instances and their operators. Adding to that the RxJava modules
    available on the Internet, we can turn almost every data source into an `Observable`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to master Schedulers. They will provide us with the power to
    handle multi-threading while coding using this reactive style of programming.
    Java is famous for its concurrency; it is time to add these capabilities of the
    language to our `Observable` chains, doing multiple HTTP requests in parallel
    (for example). Another new thing we'll learn is how to **buffer**, **throttle**,
    and **debounce** our data, techniques that come hand-in-hand with real-time data
    streams.
  prefs: []
  type: TYPE_NORMAL
