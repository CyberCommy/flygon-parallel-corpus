- en: Introduction to Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce readers to the formal definition of asynchronous
    programming. We will be discussing the basic idea behind asynchronous processing,
    the differences between asynchronous programming and other programming models
    that we have seen, and the reason why asynchronous programming is such a major
    factor in concurrency.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The concept of asynchronous programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key differences between asynchronous programming and other programming models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: You must have Python 3 installed on your computer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository from [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During this chapter, we will be working with the subfolder titled `Chapter09`,
    so make sure that you have it at the ready
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2DF700L](http://bit.ly/2DF700L)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick analogy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is a model of programming that focuses on coordinating
    different tasks in an application. Its goal is to ensure that the application
    finishes executing those tasks in the smallest amount of time possible. From this
    perspective, asynchronous programming is about switching from one task to another
    when it is appropriate to create overlapping between waiting and processing time,
    and from there, shorten the total time taken to finish the whole program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the underlying idea of asynchronous programming, let''s consider
    a quick, real-life analogy. Imagine a scenario in which you are cooking a three-course
    meal that contains the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: An appetizer that will take 2 minutes of preparation and 3 minutes of cooking/waiting
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A main course that will take 5 minutes of preparation and 10 minutes of cooking/waiting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dessert that will take 3 minutes of preparation and 5 minutes of cooking/waiting
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, considering the order in which the courses finish cooking, your goal is
    to determine a way to produce the three courses that will take the least amount
    of time. For example, if we are cooking the courses in a sequential way, we will
    finish the appetizer first, which will take 5 minutes, then we will move on to
    the main course, which will take 15 minutes, and then finally the dessert, which
    will take 8 minutes, respectively. In total, the whole meal will take 28 minutes
    to finish.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to finding a quicker way to go about this is to **overlap** the cooking/waiting
    time of one course with the preparation time of another. Since you will not be
    occupied while waiting for the food that has already been prepared for cooking,
    this time could be saved by preparing the food for another dish. For example,
    improvements could be achieved through the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Preparing the appetizer: 2 minutes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preparing the main course while waiting for the appetizer to cook: 5 minutes.
    The appetizer will have finished during this step.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preparing and cooking the dessert while waiting for the main course to cook:
    8 minutes. The dessert will have finished during this step, and the main course
    will have 2 minutes of cooking remaining.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Waiting for the main course to finish cooking: 2 minutes. The main course will
    have cooking finished during this step.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By overlapping the time, we have saved a significant amount of time cooking
    the three meals, which now takes only 17 minutes in total, compared to 28 minutes
    if we had done this in the sequential way. However, there is obviously more than
    one way to decide which dish we should start first, and which dish should be cooked
    second and last. Another variation of the cooking order could be as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Preparing the main course: 5 minutes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preparing the appetizer while waiting for the main course to cook: 2 minutes.
    The main course will have 8 minutes of cooking left.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Preparing the dessert while waiting for the appetizer and the main course to
    cook: 3 minutes. The appetizer will have finished during this step, and the main
    course will have 5 minutes of cooking left.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Waiting for the main course and the dessert to finish cooking: 5 minutes. Both
    the main course and the dessert will have finished during this step.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This time, it only takes 15 minutes in total to produce the whole meal. As
    we can see, different variations of the cooking order might result in a different
    total cooking time. Finding the best order to execute and switch between tasks
    in a program is the main idea behind asynchronous programming: instead of executing
    all of the instructions of that program in a sequential way, we coordinate those
    instructions so that we can create overlapped waiting and processing times and
    finally achieve a better execution time.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus other programming models
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is one of the major concepts in concurrency specifically,
    and in programming in general. However, it is quite a complex concept that can
    be considerably challenging for us to sometimes differentiate it from other programming
    models. In this section, we will be comparing asynchronous programming with synchronous
    programming and other concurrent programming models that we have seen (that is,
    threading and multiprocessing).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus synchronous programming
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, asynchronous programming is fundamentally different from synchronous
    programming because of its task-switching nature. In synchronous programming,
    the instructions of a program are executed sequentially: a task has to have finished
    executing before the next task in the program starts processing. With asynchronous
    programming, if the current task takes significant time to finish, you have the
    option to specify a time during the task at which the execution is switched to
    another task. As we have observed, doing this would result in potential improvements
    in the execution time of the whole program.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: One common example of asynchronous programming is the interaction between a
    server and a client during an HTTP request. If HTTP requests were synchronous,
    clients would have to wait after making a request until receiving the response
    from the server. Imagine a scenario in which your browser would hang every time
    you go to a new link or start playing a video until the actual data returns from
    the server. This would be extremely inconvenient and inefficient for HTTP communication.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is asynchronous communication, where the client is free to
    continue working, and when data from the requests made returns from the server
    is when the client will be notified and proceed to process that data. Asynchronous
    programming is so common in web development that a whole programming model called
    **AJAX** (short for **Asynchronous JavaScript and XML**) is now used in almost
    every website. Additionally, if you have used common libraries in JavaScript such
    as jQuery or Node.js, chances are you have worked with, or at least heard the
    term **callback**, which simply means a function that can be passed to another
    function to execute later in the future. Switching back and forth between the
    execution of functions is the main idea of asynchronous programming, and we will
    actually analyze an advanced example of callback usage in [Chapter 18](2198114d-2ca1-464f-93df-a29b05807928.xhtml),* Building
    a Server from Scratch*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram further illustrates the difference between synchronous
    and asynchronous client-server communication:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2ba8b96a-5449-47e6-9f20-5680fb42a540.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Differences between synchronous and asynchronous HTTP requests
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming is, of course, not limited to HTTP requests. Tasks
    that involve general network communication, software data processing, interaction
    with databases, and so on all take advantage of asynchronous programming. Contrary
    to synchronous programming, asynchronous programming provides responsiveness for
    users by preventing the program from hanging while waiting for data. Therefore,
    it is a great tool to implement in programs that deal with a large amount of data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus threading and multiprocessing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While providing somewhat similar benefits to those that threading and multiprocessing
    provide, asynchronous programming is fundamentally different from these two programming
    models, especially in the Python programming language.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, in multiprocessing, multiple copies of our main program—together
    with its instructions and variables—are created and executed independently across
    different cores. Threads, which are also known as lightweight processes, operate
    on the same basis: although the code is not executed in separate cores, independent
    portions of the code that are executed in separate threads do not interact with
    one another either.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming, on the other hand, keeps all of the instructions of
    a program in the same thread and process. The main idea behind asynchronous programming
    is to have a single executor to switch from one task to another if it is more
    efficient (in terms of execution time) to simply wait for the first task while
    processing the second. This means that asynchronous programming will not take
    advantage of the multiple cores that a system might have.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: An example in Python
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will go into more depth regarding how asynchronous programming can
    be implemented in Python and the main tools we will be using, including the `asyncio`
    module, let's consider how asynchronous programming can improve the execution
    time of our Python programs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `Chapter09/example1.py` file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have our familiar prime-checking `is_prime()` function, which takes
    in an integer and prints out a message indicating whether that input is a prime
    number or not. In our main program, we call `is_prime()` on three different numbers.
    We are also keeping track of how much time it takes for our program to process
    all three numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you execute the script, your output should be similar to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have probably noticed that the program took quite some time to process the
    first input. Because of the way the `is_prime()` function is implemented, if the
    input of the prime number is large, then it takes `is_prime()` longer to process
    it. So, since we have a large prime number as the first input, our Python program
    will hang for a significant amount of time before printing out the output. This
    typically creates a non-responsive feel for our program, which is not desirable
    in both software engineering and web development.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve the responsiveness of the program, we will take advantage of the
    `asyncio` module, which has been implemented in the `Chapter09/example2.py` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will go into the details of this code in the next chapter. For now, simply
    run the script, and you will see an improvement in responsiveness in the printed
    output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Specifically, while `9637529763296797` (our largest input) was being processed,
    the program decided to switch to the next inputs. Therefore, the results for `427920331`
    and `157` were returned before it, hence improving the responsiveness of the program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is a programming model that is based on task coordination
    through task switching. It is different from traditional sequential (or synchronous)
    programming since it creates an overlap between processing and waiting time, which
    provides potential improvements in speed. Asynchronous programming is also different
    from threading and multiprocessing, as it only takes place within one single thread
    in one single process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming is mostly used to improve the responsiveness of a program.
    When a large input takes a significant amount of time to process, the sequential
    version of a program will appear to be hanging, while the asynchronous program
    will move to other less heavy tasks. This allows small inputs to finish executing
    first and help the program to be more responsive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程主要用于改善程序的响应性。当一个大输入需要花费大量时间来处理时，顺序版本的程序会出现挂起的情况，而异步程序会转移到其他较轻的任务。这允许小输入先完成执行，并帮助程序更具响应性。
- en: In the next chapter, we will learn about the main structure of an asynchronous
    program and look into the `asyncio` module and its functionalities in more detail.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习异步程序的主要结构，并更详细地了解`asyncio`模块及其功能。
- en: Questions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the idea behind asynchronous programming?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程背后的理念是什么？
- en: How is asynchronous programming different from synchronous programming?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程与同步编程有何不同？
- en: How is asynchronous programming different from threading and multiprocessing?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程与线程和多进程有何不同？
- en: Further reading
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，您可以参考以下链接：
- en: '*Parallel Programming with Python*, by Jan Palach, Packt Publishing Ltd, 2014'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用Python进行并行编程》，作者Jan Palach，Packt Publishing Ltd，2014
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd, 2015'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python并行编程食谱》，作者Giancarlo Zaccone，Packt Publishing Ltd，2015
- en: '*RabbitMQ Cookbook*, by Sigismondo Boschi and Gabriele Santomaggio, Packt Publishing
    Ltd, 2013'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《RabbitMQ Cookbook》，作者Sigismondo Boschi和Gabriele Santomaggio，Packt Publishing
    Ltd，2013
