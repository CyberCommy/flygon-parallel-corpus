- en: The Enemies of Clean Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, we should have a pretty clear picture of what we mean when we say *clean
    code*. In the previous chapter, we explored the tenets of reliability, efficiency,
    maintainability, and usability. Together, these guide us toward cleaner code,
    but if we aren''t careful, we can still get caught out. In this chapter, we''ll
    explore the *enemies* of clean code: things that may prevent us from writing code
    that is reliable, efficient, maintainable, or usable.'
  prefs: []
  type: TYPE_NORMAL
- en: None of these enemies should be considered *your* enemies; instead, they should
    be thought of as agitators of clean code. We need to take a holistic view of these
    potentially harmful factors and keep an eye out for them in our code bases, teams,
    and workplaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the enemies we''ll be covering in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enemy #1 – JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enemy #2 – Management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enemy #3 – Self'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enemy #4 – The cargo cult'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enemy #1 – JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worst JavaScript feature is also arguably its best. It is a remarkably ubiquitous
    language that has had to grow and adapt at a very fast rate. The language itself
    and its position within browser have precipitated this ubiquity.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is an incredibly expressive and diverse language, with functional
    inspiration from Lisp and Scheme, prototypical inheritance from Self, and a C-like
    syntax that mirrors Java. It is a language of many paradigms. Whether you want
    to program in a classically object-oriented way, a prototypical way, or an entirely
    functional way, JavaScript has you covered. JavaScript''s flexibility and its
    position in the broader web stack also make it incredibly accommodating to beginners.
    You can be immediately productive with it, and this was very much Brendan Eich''s
    original intention. It was intended to be easy to pick up by designers and programmers
    alike, providing them with the power to script what was once a single-purpose
    platform: the browser. The once humble browser, however, has since grown into
    an incredibly broad and complex set of complementary abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: The growth of JavaScript itself and its broad set of applications on both the
    client and server-side (and beyond!) has meant that the language has been pushed
    and pulled in a thousand different directions. An overwhelming number of frameworks,
    libraries, spin-off languages (for example, CoffeeScript), language extensions
    (for example, JSX), compilers, build tools, and other abstractions have erupted
    and have sought to leverage JavaScript in new and unique ways. Together, these
    tools form the JavaScript landscape, and it is an incredibly rich and diverse
    one. There are countless ways to do the same thing and, as a result, we can barely
    hope to do anything correctly. That is why I say that JavaScript's ubiquity is
    both its own worst enemy and its own greatest asset.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we'll explore foundational concepts that'll teach us to think
    critically about the nature of clean code and will allow us to write clean code
    within a language and landscape that don't always cater well code cleanness. JavaScript,
    if wielded well, will surprise you with its efficacy and expressiveness, and given
    time and effort, it can be the equal of any other language in terms of its reliability
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enemy #2 – management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean code is as much about the processes and principles that foster it as it
    is about syntax. No matter how perfect and beautiful our code is in isolation,
    it is usually written as part of a project, alongside a team, and managed by fallible
    people and fallible processes. And only by seeing and understanding these fallibilities
    can we hope to prevent or avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: We are all taking on more challenging work nowadays. The days of JavaScript
    being limited to humble brochure websites with snazzy navigation rollovers are
    long gone. The creators of the web have been tasked with building ever more ambitious
    projects. As the technological tower of abstraction grows to new heights, the
    complexity of these projects will only increase. Due to this, if we are to truly
    write clean code, we must think broadly about this complexity. We must go beyond
    our code bases and consider the context of the team and the organization that
    we work in.
  prefs: []
  type: TYPE_NORMAL
- en: Casting management as an enemy may appear to suggest that managers themselves
    are blameworthy, but this is not the case. What we'll discover in this section
    is that it is individual cultural practices that make it challenging to ship clean
    code. Among these is the pressure to ship, bad metrics, and a lack of ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Pressure to ship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pressure to ship code, usually because of a deadline or other managerial
    dictates, is an ever-present and nasty force in the world of software. To the
    outside stakeholder or manager, a deadline is a great thing; it seems to provide
    certainty and accountability, but to the people working on the project, it might
    only be seen as enforcing unwelcome compromises. Sometimes, the first compromise
    that's made is that of code quality. This does not happen intentionally but is
    just a natural result of prioritizing completion over quality.
  prefs: []
  type: TYPE_NORMAL
- en: A **stakeholder**, in this context, is any individual or organization that relies
    on the output of your work. Usual stakeholders include project managers, other
    teams within the same organization, outside clients, and users.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there are pressures to ship, there are a few ways in which code quality
    can slowly atrophy. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documentation**: Developers, when rushed, will not be able to take the necessary
    time to ensure their code and its APIs are correctly documented. Existing documentation
    will atrophy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Architecture**: Developers will begin to focus on the most necessary changes
    they need to make, ignoring the larger architectural structure of the code and
    how it all inter-relates. Dependencies will become confused and architectures
    will splinter over time, eventually creating spaghetti code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Both architecturally and in terms of syntax, consistency will
    begin to suffer. Multiple different developers, possibly siloed away from each
    other, are rushed to build things in the fastest possible way. Without intending
    to, they may neglect communication and the establishment of standards, leading
    to less consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Writing tests often takes time, as does refactoring tests to suit
    new requirements. Existing tests are liable to be disabled or deleted. New tests
    won''t be written because there simply isn''t time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Best practices**: When their time is stretched, developers will begin to
    take shortcuts in their code, not taking the care and attention that''s required
    to make sure their software is suited for its purpose. They''ll skirt best practices
    and instead opt for speedy and hacked-together solutions. On the web, this can
    often result in a less accessible and usable UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding items are the first to go when deadlines begin to loom. If we''re
    not careful, we can end up with the following second-order effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bugginess**: With testing and documentation absent, and the code''s architectural
    foundations under threat, flaky and buggy code will begin to become the norm.
    Many of these bugs may be caught in the Q&A process, but many others will surface
    to users. The fragility of the code and its APIs and UIs will increase, putting
    an increased burden on users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unhappy users**: Due to the increase in the number of bugs that surface to
    users and the software''s decreased level of usability, their level of productivity
    and happiness will decrease. They may begin to avoid or abandon the platform in
    search of a higher-quality alternative.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burned-out developers**: Tired developers, having had to forgo their best
    principles continually, will begin to become burned out. They may become depressed
    at the prospect of continuing their work on the team. With their mental health
    and general fulfillment under threat, they will start to leave.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these effects, when they last long enough, can coalesce and result in
    the failure of a project. Therefore, it is of vital importance to address the
    underlying pressure that is forcing such recklessly high speed. The pressure to
    ship code quickly is a pressure that's usually instigated by forces that do not
    have a strong working knowledge of the slow degeneration that can occur in software
    projects. This lack of knowledge may, in part, be due to them being insulated
    from the long-term effects of their decisions. They may assume that, when something
    is shipped and meets the stakeholders' approval, that's the end of it. But as
    we know, just because quickly shipped code meets immediate demands doesn't mean
    it abides by good levels of quality. Bad-quality code can have many adverse knock-on
    effects that are only realized in full many weeks or months after implementation.
    Months later, stakeholders may find themselves annoyed at the slowdown and degradation
    in quality, not realizing that it was the pressure they originally applied that
    led to it.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this mess lies in a crucial compromise between t*ime to ship* and
    t*echnical debt*. Technical debt accrues over time. It describes deficits that
    need to be addressed to keep the code base healthy and in good working order.
    This may include fixing bugs, writing tests, refactoring old modules, or integrating
    tools to improve code quality. Fundamentally, technical debt is all work that,
    ideally, would be part of the natural development cycle but, because of time constraints,
    it is pushed aside until later. There are other factors that dictate the proliferation
    of technical debt, but time is the biggest one. Not paying off our technical debt
    is a sure way to ensure code atrophy and eventual failure of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are countless pieces of advice and processes that you can utilize when
    it comes to project management. I won''t be going into them here, but I will share
    some heuristics that you can use to ensure a healthy code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do not ship a feature or fix without tests**. Without tests, a regression
    could occur at any time. Tests are a defensive technique to ensure the correctness
    of our code on a continued basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pay off technical debt** frequently. Possibly once a week, or twice a month,
    try to have everyone work on technical debt, that is, any work that''s believed
    to increase the health of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communicate regularly** with stakeholders to express constraints and costs
    related to code and project health. Do not over-promise shipment or under-sell
    problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We, as developers, are not always in control of the way that projects are managed.
    Nonetheless, we should always feel comfortable broaching concerns and advocating
    for processes that foster clean code. [Chapter 18](6b197059-b00f-48fb-bc6b-c46ad73fa2b8.xhtml),
    *Communication and Advocacy*, goes into more detail on how we can go about this.
  prefs: []
  type: TYPE_NORMAL
- en: Bad metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are seemingly no industries in the world that can escape metrics. The
    crazed obsession with measuring things is as much a cult-like obsession as it
    is a genuine need that produces necessary introspection and change. In the world
    of software engineering, we are not strangers to this need. As programmers, we
    are very interested in metrics that provide us with insights into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: How many bugs are there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long does this code take to run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much test coverage do I have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managers and other stakeholders, however, will usually harbor their own interests
    and metrics. The more infamous among these are the metrics that attempt to measure
    a developer''s output or productivity:'
  prefs: []
  type: TYPE_NORMAL
- en: How many lines of code or commits are there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many features did we ship?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many lines of documentation did we write?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are good questions if they're asked for the right reasons. For example,
    lines of code can be a useful metric if we're using them as a proxy for complexity
    when discussing whether to refactor specific classes/utilities. But many metrics
    are entirely divorced from the thing they are attempting to measure.
  prefs: []
  type: TYPE_NORMAL
- en: A non-technical manager or stakeholder may assume that writing a certain amount
    of code should always take the same amount of time. They may be confused when
    a developer who once wrote 200 lines of code in a single day has recently taken
    10 days to commit only 10 lines of code. Their confusion, of course, demonstrates
    a gross misunderstanding of the programming process and its chaotic complexity.
    But these misunderstandings are rife, so we need to be wary of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The clear solution to bad metrics is to push for and create better metrics.
    And to create good metrics, it is essential to know what underlying question we''re
    trying to answer and then brainstorm ways of answering that question. Let''s take
    a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The question** | **The bad metric** | **Example of why it''s bad** | **A
    better metric or approach** |'
  prefs: []
  type: TYPE_TB
- en: '| Are we being productive? | Lines of code/commits | A programmer could reasonably
    take many days to solve a crucial bug that only requires a one-line change. |
    Ask developers and explore what is dragging their productivity down; have team
    retrospectives to discover areas of improvement. |'
  prefs: []
  type: TYPE_TB
- en: '| Are we delivering value to users? | Number of features shipped | Users may
    receive more benefit from fewer features that are of high quality.  | Build metrics
    or A/B experiments to judge which features are being used and enjoyed. Focus on
    the quality of each feature. |'
  prefs: []
  type: TYPE_TB
- en: '| Are we writing useful documentation? | Lines of documentation | Developers
    may only end up documenting the things they know well, not the areas of the code
    base that are most in need of documentation. | Create a metric that tracks the
    usage of documentation. Discern what areas of code are under-documented by asking
    developers. |'
  prefs: []
  type: TYPE_TB
- en: '| Do we have a well-tested code base? | Test coverage | If it only measures
    whether certain lines of code are called, then it could be fooled with only a
    handful of very broad integration tests. | Use traditional test coverage in combination
    with other metrics. Keep track of areas of regression where bugs often occur. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| Do we have a buggy code base? | Number of bugs | A code base may have many
    bugs in an area of the app that is virtually unused. Bugs in certain areas may
    be unreported. | Don''t count bugs; instead, focus on and measure user happiness
    and developer happiness. Prioritize bugs based on how they are affecting your
    users. |'
  prefs: []
  type: TYPE_TB
- en: Fixation on bad metrics within an organization or team can lead to the wrong
    things being optimized. Developers who are more concerned with writing more lines
    of code will be less interested in the underlying quality of their code. Developers
    who are pushed to release more features will compromise on best practices and
    clean code, optimizing for speed and shipment.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to ensure that any metrics we track are tempered by reality
    and that we do not judge success based purely on those metrics. Be especially
    wary when you see metrics running in opposition to our principles of clean code.
    Over time, as well, if a metric is chased too ambitiously, it may end up corrupting
    the very thing it was trying to measure. This is done via an effect known as **Goodhart''s
    law**:'
  prefs: []
  type: TYPE_NORMAL
- en: '"When a measure becomes a target, it ceases to be a good measure."'
  prefs: []
  type: TYPE_NORMAL
- en: – Marilyn Strathern
  prefs: []
  type: TYPE_NORMAL
- en: Lack of ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ownership is a key tenet of a healthy code base and relies on individuals having
    a stake in the health of their code. Ownership here doesn't mean that a piece
    of code belongs to an individual and nobody else can work on it. Instead, it means
    that a piece of code is fostered by an individual or a group of people, with its
    ongoing health and reliability a key priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lack of ownership can lead to the key tenets of clean code suffering in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: The code''s correctness and stability can atrophy over time
    as new changes are made that unknowingly create fragility. The code''s ongoing
    stability is not monitored or cared for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: The code is not measured or observed directly by anyone, with
    an underlying assumption that it just works. Over time, its efficiency may wane.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Having many non-owners making swift and ill-considered
    changes can result in a non-cohesive architecture that makes ongoing maintenance
    more difficult in the long run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: The documentation and general usability of the code will not
    be thought about or monitored by anyone, leading to its atrophy and, eventually,
    a piece of software that is complicated and burdensome to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properly applied ownership can fundamentally change the otherwise burgeoning
    atrophy of the preceding tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: The code''s correctness and ongoing stability will be cared
    for and monitored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: The code will be measured and assessed for efficiency on an
    ongoing basis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: The code will retain a singular vision for its architecture
    and syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Documentation will be constantly updated and the code''s usability
    will be an ongoing concern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentally, ownership is about an individual or a team that has a level of
    **ongo****ing** **concern** for the code. For this to occur, a level of ego or
    pride is necessary. An individual or team must have some kind of stake in the
    ongoing health of the code. It is often the organizational or managerial culture
    that leads to a healthy or unhealthy level of ownership, and so, again, it is
    vital to properly communicate and advocate processes and dynamics that will allow
    us, the programmers, to ensure our code's cleanliness and health.
  prefs: []
  type: TYPE_NORMAL
- en: There are also more severe and unimagined results of a lack of ownership. Due
    to the lack of pride and feeling of guardianship over our work, burnout becomes
    more likely as programmers aren't able to actualize their need to feel a sense
    of pride and self-worth regarding their work. Due to no ownership, team members
    may not be able to foster a high level of understanding in any one area, meaning
    that the general knowledge of the team or organization suffers, with everyone
    only understanding the code base in a very shallow or cursory way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beware of too much ego in ownership**! Ego is a delicate trait. There is
    always the risk of *too much ownership*, which can result in a stubborn and defensive
    culture where *insiders* don''t let *outsiders* make changes, and where strong
    and self-centered opinions run rife. Beware of this. Remember the key tenets of
    usability and maintainability. These will guide you toward kindness and openness
    toward those who would wish to use your code or make changes to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enemy #3 – Self'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers, as creators, are forever impressing their version of how something
    should be upon the world, so it's almost impossible to not, at times, feel a sense
    of pride over our work. If not kept in check, this can easily spiral into a place
    where we are writing code to impress people, and to boost feelings of our own
    superiority, without considering whether the code we're writing is maintainable
    or usable. But if our natural ego is not allowed to flourish, then we will have
    no pride in our work and no inclination to foster excellence in what we do. As
    such, in programming, as in other areas of life, the key is a balance of ego where
    we retain its good parts without letting its bad parts affect things too much.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ego**, in this context, is our selfhood; the ways in which we identify with
    ourselves and how we express ourselves in the world. All programmers have an ego
    and its effects on the code they write are numerous.'
  prefs: []
  type: TYPE_NORMAL
- en: Showing off with syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a younger programmer, I found my ego getting the better of me quite often.
    I don't presume to say this is a general truth. This is only my experience. Whenever
    I discovered a new JavaScript idiosyncrasy, I would try to exploit and make use
    of it in my next piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of this is the use of bitwise operators for their flooring effects.
    Traditionally, to floor numbers—to round a number down to its nearest whole number—you''d
    use the native method provided by the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, at the time, I preferred using bitwise operators to achieve the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here? Bitwise operators (including `~`, `&`, `|`, and so on)
    are used to mutate bits on operands, but as a side-effect, they will first convert
    their operands into 32-bit integers. This means they'll throw away the decimal
    fraction. To harness this implicit conversion into an integer without changing
    the value of the integer, we can perform, for example, a double bitwise inversion
    using the double tilde (`~~`). This essentially inverts all the bits of the operand
    and then inverts them again. We could also perform a bitwise OR with a zero (`0|...`),
    which will always return the bits of the non-zero operand, thus producing the
    same effect by harnessing the side-effect (the integer conversion) without changing
    the underlying value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Crucially, it''s important to note that this side-effect does not functionally
    match the flooring behavior of `Math.floor` for negative numbers. Note how the
    following two expressions differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to see what''s alluring about these cryptic techniques. Their usage
    seems to suggest a high level of language understanding, and that very much appeals
    to the ego. It''s similar to using needlessly long or complex words to convey
    simple ideas: fun to say but alienating to the listener.'
  prefs: []
  type: TYPE_NORMAL
- en: Techniques like this usually result in code that is less maintainable. The maintainers
    of our code should not be expected to understand the inner workings of rarely
    used operators and should be able to trust that we would not be recklessly employing
    side-effects of language internals to achieve results that can clearly be achieved
    via more familiar and obvious approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex or rare syntax is often a vehicle for egotistic code. Another example
    of this lies in the misuse of logical operators to specify control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be more conventionally, and clearly, expressed as an
    *IF* statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is far clearer, more familiar, and more readable to a larger group of people.
  prefs: []
  type: TYPE_NORMAL
- en: Some people argue that we should be able to freely use the entire language to
    its full capability, harnessing all its idiosyncrasies and side-effects to write
    code that is terser and more efficient. This is a fine attitude to take if our
    only goal is to write code that works. But writing *clean *code is about taking
    a considered approach, using techniques that allow us to provide more readability
    and avoiding techniques that do the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: It also helps to remember that, fundamentally, code is about communicating intent.
    Communication is as much about the listener as it is about the speaker. Egotistic
    code tends to fall short in this way; it limits the familiarity of your code to
    an elite few who have been blessed with the same knowledge that you have. This
    is not ideal. We should always try to take into account the diverse knowledge
    and capabilities of the people who will have to read, use, and maintain our code.
    This concern should take precedence over our ego.
  prefs: []
  type: TYPE_NORMAL
- en: Stubborn opinions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code is rarely written in isolation; we often work with people to bring projects
    to life. Clean code, therefore, depends on both your approach and the approach
    of the entire team. A team that owns a code base continuously decides the tools,
    conventions, and abstractions that they'll use to achieve their goals. As such,
    members of the team must be able to communicate well and share perspectives, molding
    these perspectives into a clear outcome. Sometimes, compromise is necessary. And
    compromise can often hit the ego.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript and its tools are susceptible to strong opinions. Over time, we each
    gain experience in working with different approaches and, often through toil and
    pain, end up having a set of beliefs about which approaches we think are best.
    These beliefs may not always match those of our colleagues, though. When there
    is disagreement, the path to resolution is unclear. Without resolution, the team
    and the code base can splinter, causing more damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine the following scenario between Adam and Susan:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adam: We should use the Foo testing framework; it''s more reliable and simply
    better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Susan: No, we should definitely use Baz; it''s far superior and has a proven
    track record.'
  prefs: []
  type: TYPE_NORMAL
- en: There are likely many different ways this disagreement could be resolved. We
    could suggest, for example, that both individuals build their case and continue
    to debate the various merits of each testing framework. That may resolve the issue.
    But equally, it may not. The argument may persist, drawing a wedge between the
    individuals and leaving the code base in a state of flux without a firmly chosen
    testing framework. The paths to resolution are not always clear in cases like
    this, but what is clear is that resolution is less likely if uncompromising egos
    are involved. If both Adam and Susan can start to see each other's perspectives,
    broadening their view and un-entrenching themselves from their own opinions, then
    the path to resolution becomes much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Imposter syndrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ego, as a delicate trait, is also responsible for our level of faith and belief
    in our own capabilities and opinions. It is no wonder that having a level of belief
    in ourselves is vital to the act of creation and problem-solving in programming.
    In the technology industry especially, **imposter syndrome** seems to be a widespread
    occurrence. Imposter syndrome is characterized by a feeling of being an *imposter—*that
    you are somehow not suitable or sufficiently capable for the role you have, while
    you feel as though others around you are far more capable.
  prefs: []
  type: TYPE_NORMAL
- en: It can be argued that its prevalence in the software industry is due to the
    inherent complexity and wealth of specialties. We can, at best, hope for a high
    level of proficiency in a relatively narrow area but will never be expertly knowledgeable
    in all areas. We are, as we move about in our day-to-day work, ever aware of all
    the things we don't know, and this can understandably create a level of anxiety
    and lack of confidence in our own humble abilities. Such a feeling can sometimes
    cause stress, alienation, and a lack of confidence in our own abilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may yield the following negative outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of decisiveness**: A lack of belief in our own capabilities can result
    in low levels of confidence when making a decision about our code''s architecture;
    not knowing which route to take can often mean the default route is taken, which
    is especially liable to the cargo cults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of boldness**: A lack of assertiveness may result in less risk-taking
    and fewer bold decisions being made, but sometimes such decisions need to be made
    to move a project or code base forward. For example, picking a more reliable UI
    or testing framework can be a large and bold risk given the cost of refactoring,
    but can lead to overall improvements in code health.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of communication**: Lacking confidence in our own opinions and skills
    can result in less vital communication occurring, for example, between a programmer
    and the stakeholders of a project. Communication here does not mean being outgoing
    or talkative, but rather identifying key concerns and being sufficiently confident
    in them to advocate change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The act of programming is an act of communicating our intent, that is, of impressing
    upon the world, maybe in a small way, the way we believe a thing should work.
    It is itself a bold action and a skill that we should not take for granted. If
    you are reading this and are concerned that you may lack specific traits or capabilities,
    I offer the following advice: nobody on the planet is fully capable. Everyone
    has their strengths and weaknesses. It is the diversity of everyone and their
    varying capabilities that will define the success of a project and code base.
    Even if you feel a sense of imposter syndrome, acknowledge that it is natural
    to feel this way and that, in spite of it, you offer more than you might think.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enemy #4 – The cargo cult'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 20^(th) century, it was observed that some Melanesian cultures
    would carry out rituals that would emulate Western technologies and behaviors,
    such as building runways and control towers out of wood and clay. They were doing
    this in the hope that material wealth, such as food, would be delivered to them.
    These odd rituals arose because they had previously observed cargo being delivered
    via Western planes and falsely concluded that it was the runway itself that summoned
    the cargo.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, within programming, we use the terms *cargo cult* or *cargo culting* to
    broadly describe copying patterns and behaviors without fully understanding their
    true purpose and functionality. When programmers search for a solution online
    and copy and paste the first piece of code they find without consideration as
    to its reliability or safety, they are partaking in act of cargo culting, seeking
    to accomplish some task by utilizing code that appears to be responsible for it
    in some other context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cargo culting typically entails the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: The person is embedded in a slightly unfamiliar technical context
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The person sees the effect they wish to emulate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The person copies code that appears to produce the desired effect
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This act can occur both organizationally and technically. Programmers, sometimes
    tasked with tying together disparate technical dependencies that they have little
    expertise in, will often be left with no other option than to cargo cult. And
    organizations, often without time to consider all the fundamentals, will often
    end up cargo culting popular behaviors and processes from other organizations.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo culting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the act of cargo culting, let''s imagine that a programmer is
    tasked with adding a new HTTP GET route to their Node.js server. They need to
    add the `/about_us` route. They open up the `routes.js` file and, among its many
    lines, find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code happens to be using a Node.js framework:  **Express**. Unfortunately,
    however, the programmer is not well versed in the Express API. They see the preceding
    code and seek to emulate it for their own ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as you may be able to tell, this programmer has committed the
    act of cargo culting. They've copied code that's used to route traffic toward
    the admin section and have assumed that they should use similar code to route
    traffic toward the about page.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things they''ve missed in doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: The admin route is, in fact, middleware, which is used to block unauthorized
    users from accessing `/admin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `app.use()` method should only be used for middleware, not for a direct
    GET route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `next()` is something only middleware should be interested in doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the programmer had taken the time to read the Express documentation, they
    would have discovered that the correct way is more akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a very brief example. Often, the act of cargo culting is more complex.
    It may not involve the direct copying of code, but maybe only the subtle copying
    of patterns or syntax. We may shake our head at the preceding example, sure of
    the knowledge that we would never do such a thing, but we likely already do, in
    less obvious ways.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers that are engaged in a project will often rightfully inherit the
    naming, syntax, and whitespace conventions from the existing code base. They may
    do this without thought, naturally reflecting and conforming to the existing paradigms
    without applying their critical skills at every step. This isn't necessarily negative: it
    is the sensible upholding of conventions and presentational consistency. These
    are important qualities. But equally, the mindless copying of such things can
    often result in the pointless proliferation of redundant code, or worse, negative
    effects due to misunderstood code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you''re a first-time programmer and you wanted to add a `hobby` field
    to the following slightly bizarre object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to imagine that you might be inclined to copy the existing syntax
    when you add your new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is an entirely reasonable thing for a first-timer to have done. They were
    embedded in an unfamiliar context, saw an effect they wished to emulate, and so
    they adopted the pattern that produced the effect. It is even an understandable
    act by someone experienced, who wants to make the minimal necessary changes to
    the code surgically and without disturbing its surroundings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is nothing egregiously wrong in this code. It''s functional. However,
    if we are to write code that is maximally maintainable and efficient, then we
    should adopt conventions and syntax that are more widely accepted and conventional.
    So, in this light, there are two specific problems with the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping every key name in double quotes (unnecessary!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping every value in parentheses (unnecessary!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The non-cargo culted version of the file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, this file and object will likely live on for months and maybe years
    to come. Nobody will ever question or challenge its syntax as they'll assume it
    must be like that for a reason. There is comfort and ease in conforming to an
    established way of doing something. It is often easier not to challenge it. This
    form of cargo culting is the more insidious type and introduces a lot of inertia
    to projects and teams. We mindlessly adopt practices without questioning their
    continuing validity and suitability.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo culting tools and libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as code can be mindlessly copied, so can tools. As JavaScript programmers,
    we are exposed to a quickly shifting landscape of tools and libraries. Every month,
    a new utility or tool seems to be released. The excitement and hyperbole that
    surrounds some of these tools creates fertile ground for cargo cults to erupt.
    Programmers may start to use these new tools, convinced of their merit, without
    building a full understanding of them or properly considering their suitability
    for the project at hand. Tools may be prescribed by companies or managers, with
    non-programmers and programmers alike weighing in based purely on a tool's popularity
    or novelty, without considering how it actually works or how it differs from the
    current approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *cult* in cargo cults tends to be a very persuasive force, telling us that
    if we just use this approach or tool, all our problems will be solved. Naturally,
    this rarely comes to pass. We may only end up exchanging our current set of problems
    for a new set of problems. So, when deciding upon a tool, whether it is a framework,
    library, or any third-party abstraction or service, we should always use a considered
    approach where we ask ourselves the following key questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suitability**: Is it the most suitable tool for the problem at hand?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Does it work reliably and will it continue to do so?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability**: Is it simple to use and is it well documented?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**: Does it integrate well with the existing codebase?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptability**: Is it adaptable to our changing needs?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid cargo culting, we should try to abstain from anecdotes and hearsay,
    instead preferring detailed comparative analyses in which we compare and contrast
    various possibilities to find the most suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an appreciation of some of the most prevalent *enemies* of
    clean code. We discussed how JavaScript itself is a language that, when wielded
    incorrectly, can invite unclean code. We also explored the pitfalls of both teams
    and the individual. We learned that clean code is not merely a characteristic
    of code but a culture that must be fostered both throughout an organization and
    within our own minds.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore some well-known and some less well-known
    principles of clean code and integrate what we've learned so far into some concrete
    JavaScript abstractions.
  prefs: []
  type: TYPE_NORMAL
