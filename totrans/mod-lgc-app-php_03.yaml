- en: Chapter 3. Implement an Autoloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this step, we will set up automatic class loading. After this, when we need
    a class file, we will not need an `include` or `require` statement to load it
    for us. You should review the PHP documentation on autoloaders before continuing
    – [http://www.php.net/manual/en/language.oop5.autoload.php](http://www.php.net/manual/en/language.oop5.autoload.php).
  prefs: []
  type: TYPE_NORMAL
- en: PSR-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different autoloader recommendations in PHP land. The one we
    will be using to modernize our legacy application is based on something called
    `PSR-0`.
  prefs: []
  type: TYPE_NORMAL
- en: PSR-0 is a PHP Framework Interoperability Group recommendation for structuring
    your class files. The recommendation rises out of a long history of projects using
    the "class-to-file" naming convention from the days of PHP 4\. Originating with
    Horde and PEAR, the convention was adopted by early PHP 5 projects such as Solar
    and Zend Framework, and later by projects such as Symfony2.
  prefs: []
  type: TYPE_NORMAL
- en: We use PSR-0 instead of the newer PSR-4 recommendation because we are dealing
    with legacy code, code that was probably developed before PHP 5.3 namespaces came
    into being. Code written before PHP 5.3 did not have access to namespace separators,
    so authors following the class-to-file naming convention would typically use underscores
    in class names as a pseudo-namespace separator. PSR-0 makes an allowance for older
    non-PHP-5.3 pseudo-namespaces, making it more suitable for our legacy needs, whereas
    PSR-4 does not.
  prefs: []
  type: TYPE_NORMAL
- en: Under PSR-0, the class name maps directly to a file system sub-path. Given a
    fully-qualified class name, any PHP 5.3 namespace separators are converted to
    directory separators, and underscores in the class portion of the name are also
    converted to directory separators. (Underscores in the namespace portion proper
    are *not* converted to directory separators.) The result is prefixed with a base
    directory location, and suffixed with `.php`, to create a file path where the
    class file may be found. For example, the fully-qualified class name `\Foo\Bar\Baz_Dib`
    would be found in a sub-path named `Foo/Bar/Baz/Dib.php` on a UNIX-style file
    system.
  prefs: []
  type: TYPE_NORMAL
- en: A Single Location for Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we implement a PSR-0 autoloader, we need to pick a directory location
    in the codebase to hold every class that will ever be used in the codebase. Some
    projects already have such a location; it may be called `includes`, `classes`,
    `src`, `lib` or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: If a location like that already exists, examine it carefully. Does it have *only*
    class files in it, or is it a combination of class files and other kinds of files?
    If it has anything besides class files in it, or if no such location exists, create
    a new directory location and call it classes (or some other properly descriptive
    name).
  prefs: []
  type: TYPE_NORMAL
- en: This directory will be the central location for all classes used throughout
    the project. Later, we will begin moving classes from their scattered locations
    in the project to this central location.
  prefs: []
  type: TYPE_NORMAL
- en: Add Autoloader Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a central directory location for our class files, we need to set
    up an autoloader to look in that location for classes. We can create the autoloader
    as a static method, an instance method, an anonymous function, or a regular global
    function. (Which one we use is not as important as actually doing the autoloading.)
    Then we will register it with `spl_autoload_register()` early in our bootstrap
    or setup code, before any classes are called.
  prefs: []
  type: TYPE_NORMAL
- en: As a Global Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most straightforward way to implement our new autoloader code is
    as a global function. Below, we find the autoloader code to use; the function
    name is prefixed with `mlaphp_` to make sure it does not conflict with any existing
    function names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `$dir` variable represents an absolute directory as the base
    path for our central class directory. As an alternative on PHP 5.3 and later,
    it is perfectly acceptable to use the `__DIR__` constant in that variable so the
    absolute path is no longer hard-coded, but is instead relative to the file where
    the function is located. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are stuck on PHP 5.2 for some reason, the `__DIR__` constant is not available.
    You can replace `dirname(__DIR__)` with `dirname(dirname(__FILE__))` in that case.
  prefs: []
  type: TYPE_NORMAL
- en: As a Closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we are using PHP 5.3, we can create the autoloader code as a closure and
    register it with SPL in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As a Static or Instance method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is my preferred way of setting up an autoloader. Instead of using a function,
    we create the autoloader code in a class as an instance method or a static method.
    I recommend instance methods over static ones, but your situation will dictate
    which is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create our autoloader class file in our central class directory location.
    If we are using PHP 5.3 or later, we should use a proper namespace; otherwise,
    we use underscores as pseudo-namespace separators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a PHP 5.3 example. Under versions earlier than PHP 5.3, we
    would omit the `namespace` declaration and name the class `Mlaphp_Autoloader`.
    Either way, the file should be in the sub-path `Mlaphp/Autoloader.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the setup or bootstrap file, `require_once` the class file, instantiate
    it if needed, and register the method with SPL. Note that we use the array-callable
    format here, where the first array element is either a class name or an object
    instance, and the second element is the method to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please pick either an instance method or a static method, not both. The one
    is not a fallback for the other.
  prefs: []
  type: TYPE_NORMAL
- en: Using The __autoload() Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we are stuck on PHP 5.0 for some reason, we can use the `__autoload()` function
    in place of the SPL autoloader registry. There are drawbacks to doing things this
    way, but under PHP 5.0 it is our only alternative. We do not need to register
    it with SPL (in fact, we cannot, since SPL was not introduced until PHP 5.1).
    We will not be able to mix-and-match other autoloaders in this implementation;
    only one `__autoload()` function is allowed. If an `__autoload()` function is
    already defined, we will need to merge this code with any code already existing
    in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I strongly recommend against using this kind of implementation in PHP 5.1 and
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Autoloader Priority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of how we implement our autoloader code, we need it to be available
    *before* any classes get called in the codebase. It cannot hurt to register the
    autoloader as one of the very first bits of logic in our codebase, probably in
    a setup or bootstrap script.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What If I Already Have An Autoloader?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some legacy applications may already have a custom autoloader in place. If
    this is our situation, we have some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the existing autoloader as-is**: This is our best option if there is
    already a central directory location for the application class files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Modify the existing autoloader to add PSR-0 behavior**: This is a good option
    if the autoloader does not conform to PSR-0 recommendations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the PSR-0 autoloader described in this chapter with SPL in addition
    to the existing autoloader. This is another good option when the existing autoloader
    does not conform to PSR-0 recommendations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Other legacy codebases may have a third-party autoloader in place, such as
    Composer. If Composer is present, we can obtain its autoloader instance and add
    our central class directory location for autoloading like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, we can co-opt Composer for our own purposes, making our own autoloader
    code unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: What are the Performance Implications Of Autoloading?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is some reason to think that using autoloaders may cause a slight performance
    drag compared to using `include`, but the evidence is mixed and situation-dependent.
    If it is true that autoloading is comparatively slower, how big of a performance
    hit can be expected?
  prefs: []
  type: TYPE_NORMAL
- en: I assert that, when modernizing a legacy application, it is probably not an
    important consideration. Any performance drag incurred from autoloading is minuscule
    compared to the other possible performance issues in your legacy application,
    such as the database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In most legacy applications, or even in most modern ones, attempting to optimize
    performance on autoloading is a case of attempting to optimize on the wrong resource.
    There are other resources that are likely to be worse offenders, just ones that
    we don't see or don't think of.
  prefs: []
  type: TYPE_NORMAL
- en: If autoloading is the single worst performance bottleneck in your legacy application,
    then you are in fantastic shape. (In that case, you should return this book for
    a refund, and then tell me if you are hiring, because I want to work for you.)
  prefs: []
  type: TYPE_NORMAL
- en: How Do Class Names Map To File Names?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PSR-0 rules can be confusing. Here are some class-to-file mapping examples
    to illustrate its expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is some unexpected behavior in the last three examples.
    This is born of the transitional nature of PSR-0: `Foo\Bar\Baz, Foo\Bar_Baz`,
    and `Foo_Bar_Baz` all map to the same file. Why is this?'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that pre-PHP-5.3 codebases did not have namespaces, and so used underscores
    as a pseudo-namespace separator. PHP 5.3 introduced a real namespace separator.
    The PSR-0 standard had to accommodate both cases simultaneously, so it honors
    underscores in the relative class name (i.e., the final part of the fully-qualified
    name) as directory separators, but underscores in the namespace part are left
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that if you are on PHP 5.3, you should never use underscores
    in your relative class names (although underscores in the namespace are fine).
    If you are on a version before PHP 5.3, you have no choice but to use only underscores,
    as there is only the class name and no actual namespace portion; interpret underscores
    as namespace separators in that case.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have not modified our legacy application very much. We have
    added and registered some autoloader code, but it is not actually being called
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: No matter. Having an autoloader is critical to the next step in modernizing
    our legacy application. Using an autoloader will allow us to start removing `include`
    statements that only load classes and functions. The remaining `include` statements
    will be logical-flow includes, showing us which parts of the system are logic
    and which are definition-only. This is the beginning of our transition from an
    include-oriented architecture toward a class-oriented architecture.
  prefs: []
  type: TYPE_NORMAL
