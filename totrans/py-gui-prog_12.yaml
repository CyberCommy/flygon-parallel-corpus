- en: Visualizing Data Using the Canvas Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With months of experimental data logged in the database, it's time to begin
    the process of visualizing and interpreting it. Rather than exporting data into
    a spreadsheet to create charts and graphs, your fellow analysts have asked whether
    the program itself can create graphical data visualizations. To implement this
    feature, you're going to need to learn about Tkinter's `Canvas` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Canvas` widget for drawing and animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple line graph using `Canvas`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporating more advanced graphs and charts using Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and animation with Tkinter's Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Canvas` widget is undoubtedly the most powerful widget available in Tkinter.
    It can be used to build anything from custom widgets and views to complete user
    interfaces. As the name implies, `Canvas` is a blank area on which figures and
    images can be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Canvas` object can be created like any other widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Canvas` accepts the usual widget configuration arguments, as well as `width`
    and `height` for setting its size. Once created, we can start adding items to
    `canvas` using its many `create_()` methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a rectangle with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first four arguments are the coordinates of the upper-left and lower-right
    corners, in pixels from the upper-left corner of the canvas. Each `create_()`
    method begins like this, with coordinates defining the shape. The `fill` option
    specifies the color of the inside of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coordinates can also be specified as tuple pairs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Although this is more characters, it improves readability considerably. Also
    note that, just like colors elsewhere in Tkinter, we can use names or hex codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create ovals, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An oval, like a rectangle, takes the coordinates of the upper-left and lower-right
    corners of its **bounding box**. A bounding box is the smallest rectangle that
    will contain an item, so in the case of this oval, you can imagine a circle inside
    a square with corners at `(350, 250)` and `(450, 350)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create lines using `create_line()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lines can consist of any number of points, between which Tkinter will connect
    the dots. We've specified the width of the line as well as its color (using the
    `fill` argument). Additional arguments can control the shape of corners and ends,
    the presence and style of arrows at each end of the line, whether and how the
    line is dashed, and whether the line is straight or curved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion, we can create polygons, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is just like creating a line, except that Tkinter connects the last dot
    back to the first and fills in the interior. Setting `smooth` to `True` causes
    the corners to be rounded using Bezier curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to simple shapes, we can also place text or images on the `canvas`
    object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The return value of any `create_()` method is a string that uniquely identifies
    the item in the context of the `Canvas` object. We can use that identification
    string to do things to the item after creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can bind events like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `tag_bind` method to bind a left-mouse click on our image
    object to the canvas's `delete()` method, which (when given an item identifier)
    deletes the item.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Canvas objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter's `Canvas` widget doesn't have a built-in animation framework, but we
    can still create simple animations by combining its `move()` method with our understanding
    of the event queue.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we'll create a bug race simulator, in which two bugs (represented
    by colored circles) will race haphazardly toward a finish line on the other side
    of the screen. Like real bugs, they won't have any notion that they're in a race
    and will move randomly, the winner being whichever bug incidentally hits the finish
    line first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, open a new Python file and start with a basic boilerplate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating our objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the objects to be used in our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.__init__()`, we''ll simply create our `canvas` object and add it using
    `pack()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a `setup()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, `setup()` begins by calculating some relative
    locations on the `canvas` object and saving them as instance properties, which
    will simplify the placement of objects on the `canvas` object. The finish line,
    which is a rectangle across the right edge of the window, uses the `stipple` argument
    to specify a bitmap that will overlay the solid color to give it some texture;
    in this case, `gray50` is a built-in bitmap that alternates black and transparent
    pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to `setup()` at the end of `__init__()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because `setup()` relies on the `width` and `height` values of the `canvas` object,
    we need to make sure it isn't called until the operating system's window manager
    has drawn and sized the window. The simplest way of doing this is to delay the
    call by a few hundred milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create our players. Let''s create a class to represent them
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Racer` class will be created with a reference to `canvas` and a `color`
    string, from which its color and name will be derived. We'll draw the racer initially
    at the middle-left of the screen and make it `50` pixels in size. Finally, we
    save a reference to its item ID string in `self.id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in `App.setup()`, we''ll create two racers by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, all the objects in our game are set up. Run the program and you
    should see a yellow-stippled finish line on the right and a green circle on the
    left (the red circle will be hidden under the green).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animating the racers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To animate our racers, we're going to use the `Canvas.move()` method. `move()`
    takes an item ID, a number of `x` pixels, and a number of `y` pixels, and moves
    the item by that amount. By using `random.randint()` and some simple logic, we
    can generate a series of moves that will send each racer on a meandering path
    towards the finish line.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple implementation may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This isn't really what we want, though; the problem is that `move()` happens
    instantaneously, causing the bug to jump across the screen; we want our moves
    to take place smoothly over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we''re going to take the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate a series of linear moves, each with a random delta `x`, delta `y`,
    and `time`, that will reach the finish line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break each move into a number of steps determined by dividing the time into
    a regular interval
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add each step of each movement to a queue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At our regular interval, pull the next step from the queue and pass it to `move()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by defining our frame interval and creating our animation queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`FRAME_RES` (short for frame resolution) defines the number of milliseconds
    between each `Canvas.move()` call. `50` milliseconds gives us 20 frames per second
    and should be sufficient for smooth movements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a method to plot the course to the finish line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method plots a course from the left-center of `canvas` to the right-side
    by generating random `x` and `y` movements until the total `x` is greater than
    the width of the `canvas` object. The change in `x` will always be positive, keeping
    our bugs moving towards the finish line, but the change in `y` can be positive
    or negative. To keep our bugs on the screen, we constrain the total `y` movements
    by negating any change in `y` that would put the player outside the top or bottom
    bound of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to `dx` and `dy`, we generate a random amount of `time` for the
    move to take, between half a second and two seconds, and send the generated values
    to a `queue_move()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `queue_move()` command will need to break the large move into individual
    frames that describe how much movement should happen in one `FRAME_RES` interval.
    To do this, we need a **partition function**: a mathematical function that will
    break an integer `n` into `k` approximately equal integers. For example, if we
    wanted to break -10 into four parts, our function should return a list like [-3,
    -3, -2, -2].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `partition()` as a static method on `Racer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with the easy case: when `n` is `0`, return a list of `k` zeros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a list of length `k` that is made up of `base_step`, that is,
    the integer portion of `n` divided by `k`. We use a cast of `int()` here rather
    than floor division because it behaves more appropriately with negative numbers.
    Next, we need to distribute the remainder among the list as evenly as we can.
    To accomplish this, we add `1` or `-1` (depending on the sign of the remainder)
    to the first `n % k` items in the parts list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the math here using our example of `n = -10` and `k = 4`:'
  prefs: []
  type: TYPE_NORMAL
- en: -10 / 4 = -2.5, truncated to -2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we have a list: [-2, -2, -2, -2].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -10 % 4 = 2, so we add -1 (that is, -10 / 10) to the first two items in the
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We arrive at an answer of [-3, -3, -2, -2]. Perfect!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can write `queue_move()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We first determine the number of steps in this move by dividing the time by `FRAME_RES`
    using floor division. We create a list of `x` moves and a list of `y` moves by
    passing `dx` and `dy` each to our `partition()` method. Those two lists are combined
    with `zip` to form a single list of `(dx, dy)` pairs, which then gets added to
    the animation queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the animation actually happen, we''ll write an `animate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `animate()` method checks the queue for a move. If there is one, `canvas.move()`
    is called with the racer's ID and the moves that need to be made. Finally, the
    `animate()` method is scheduled to run again in `FRAME_RES` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The last step in animating the racers is to call `self.plot_course()` and `self.animate()`
    at the end of `__init__()`. If you run the game now, your two dots should wander
    the screen from left to right. But nobody's winning just yet!
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and handling a win condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To detect a win condition, we're going to periodically check whether a racer
    is overlapping with the finish line item. When one of them is, we'll declare it
    the winner and offer the option to play again.
  prefs: []
  type: TYPE_NORMAL
- en: Collision detection between items is slightly awkward with the Tkinter `Canvas` widget.
    We have to pass a set of bounding box coordinates to `find_overlapping()`, which
    returns a tuple of item identifiers that overlap with the bounding box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `overlapping()` method for our `Racer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method retrieves the bounding box of the `Racer` item using the canvas's
    `bbox()` method. It then fetches a tuple of items overlapping this bounding box
    using `find_overlapping()`. Next, we'll filter this tuple to remove the `Racer`
    item's ID, effectively returning a list of items overlapping with the `Racer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `App()` method, we''ll create a `check_for_winner()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method iterates our list of racers and checks whether the `finish_line`
    ID is in the list returned by the racer's `overlapping()` method. If it is, `racer`
    has hit the finish line and will be declared the winner.
  prefs: []
  type: TYPE_NORMAL
- en: If no player was declared the winner, we'll schedule the check to run again
    after `Racer.FRAME_RES` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We handle a win condition in the `declare_winner()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we've just created a `text` item declaring `racer.name` as the
    winner in the center of `canvas`. The `activefill` argument causes the color to
    appear violet when the mouse is hovered over it, indicating to the user that this
    text is clickable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When that text is clicked, it calls the `reset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `reset()` method needs to clear off the canvas, so it retrieves a list of
    all item identifiers using the `find_all()` method, then calls `delete()` on each
    one. Finally, we call `setup()` to reset the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game is now complete, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5199652b-2987-472d-b74e-4d00c79ddc46.png)'
  prefs: []
  type: TYPE_IMG
- en: While not exactly simple, animation in Tkinter can provide smooth and satisfactory
    results with some careful planning and a bit of math.
  prefs: []
  type: TYPE_NORMAL
- en: Enough games, though; let's get back to the lab and figure out how to use the
    Tkinter `Canvas` widget to visualize data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple graphs on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first graph we want to produce is a simple line graph that shows the growth
    of our plants over time. Each lab has varying climate conditions, and we want
    to see how those conditions are affecting the growth of all plants, so the chart
    will have one line per lab showing the average of the median height measurements
    for all plots in the lab over the days of the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by creating a model method to return the raw data, then create a
    `Canvas`-based line-chart view, and finally create an application callback to
    pull the data and send it to the chart view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we have a SQL query that determines the day number of a plot check by
    subtracting its date from the oldest date in the `plot_checks` table, then pulls
    `lab_id` and the average of `median_height` for all plants in the given lab on
    the given day.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll run this query in a new `SQLModel` method called `get_growth_by_lab()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get back a table of data that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Day** | **Lab ID** | **Average height** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | A | 7.4198750000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | B | 7.3320000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | C | 7.5377500000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | D | 8.4633750000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | E | 7.8530000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | A | 6.7266250000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | B | 6.8503750000000000 |'
  prefs: []
  type: TYPE_TB
- en: We'll use this data to build our chart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the graph view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Head over to `views.py`, where we''ll create the `LineChartView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`LineChartView` is a subclass of `Canvas`, so we''ll be able to draw items
    directly on it. We''ll accept a parent widget, height, and width for the chart
    portion, labels for the `x` and `y` axes as arguments, and the maximum values
    for `x` and `y` to display. We''ll save the chart dimensions and maximum values
    for later use, and set a class property of 20 pixels for the margin width.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start setting up this `Canvas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We calculate the `width` and `height` values of view by adding the margin to
    both sides, then call the superclass `__init__()` with them, also setting the
    background to `lightgrey`. We'll also save the chart `width` and `height` as instance
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s draw the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Our chart's origin will be `self.margin` pixels from the bottom-left corner,
    and we'll draw the `x` and `y` axes as simple black lines moving left and up from
    it to the edge of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll label the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re creating the `text` items set to the labels for the `x` and `y`
    axes. There are a few new arguments in use here: `anchor` sets which side of the
    text''s bounding box is attached to the coordinates provided, and `angle` rotates
    the text object by the given number of degrees. Note that `angle` is a Tkinter
    8.6 feature, so it could be a problem for macOS users. Also, note that we''ve
    used south as `anchor` for the rotated text; even though it''s rotated, the cardinal
    directions refer to the non-rotated sides, so south will always be the bottom
    of the text as it''s normally printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last of all, we need to create a second `Canvas` that will contain the actual
    chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While we could place widgets on `canvas` using a geometry manager like `pack()`
    or `grid()`, the `create_window()` method places a widget on `Canvas` as a `Canvas`
    item using coordinates. We're anchoring the lower-left corner of the chart to
    the origin point on our graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the pieces in place, we''ll now create a method to draw data on the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In `plot_line()`, we first have to convert the raw data into coordinates that
    can be drawn. We'll need to scale our `data` points so that they range from `0`
    to the height and width of the chart object. Our method calculates the scale of
    `x` and `y` (that is, how many pixels per unit `x` or `y`) by dividing the chart
    dimensions by the maximum values of `x` and `y`. We can then transform our data
    by using a list comprehension that multiplies each data point by the scale value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, data is usually graphed with the origin in the bottom-left, but coordinates
    measure from the top-left, so we'll need to flip the `y` coordinates; this is
    done in our list comprehension as well by subtracting the new `y` value from the
    chart height. These coordinates can now be passed to `create_line()` along with
    a reasonable `width` and the `color` argument passed in by the caller.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing we need is a **legend**, to tell the user what each color on
    the chart represents. Without legend, this chart would be meaningless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `draw_legend()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our method takes a dictionary that maps labels to colors, which will be provided
    by the application. For each one, we simply draw a text item containing the `label`
    text with the associated `fill` color. Since we know our labels will be short
    (only a single character), we can get away with just putting this in the margin.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Application` class, create a new method for showing our chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first order of business is to fetch data from our `get_growth_by_lab()`
    method and calculate the maximum values for the `x` and `y` axes. We've done this
    by using list comprehensions to extract values into lists and calling the built-in
    `max()` function on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll build a widget to hold our `LineChartView` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `Toplevel` widget in this case, which creates a new window outside
    our main application window. We've then created `LineChartView` that is `600`
    by `300` pixels with the *x*-axis and *y*-axis labels and added it to `Toplevel`
    using `pack()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll assign colors to each lab and draw `legend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is to draw the actual lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our data contains values for all the labs together, so we're iterating
    through the labs in `legend` and using a list comprehension to extract only the
    data for that lab. Then our `plot_line()` method does the rest.
  prefs: []
  type: TYPE_NORMAL
- en: With this method complete, add it to the `callbacks` dictionary and add a menu
    item to the tools menu for each platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call your function, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db64ecf3-2169-4ea1-ac5c-954a960ba237.png)The graph won''t look like
    much without some sample data. Unless you just like doing data entry, there is
    a script for loading sample data in the `sql` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced graphs using Matplotlib and Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our line graph is pretty, but it still needs considerable work to be fully
    functional: it lacks a scale, grid lines, and other features that would make it
    a completely useful chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could spend a lot of time making it more complete, but there''s a faster
    way to get much more satisfactory graphs and charts in our Tkinter application:
    **Matplotlib**.'
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is a third-party library for generating professional-quality, interactive
    graphs of all types. It's a vast library with many add-ons, and we won't cover
    much of its actual usage, but we should look at how to integrate Matplotlib into
    a Tkinter application. To do this, we'll create a bubble chart showing the yield
    of each plot as it relates to `humidity` and `temperature`.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to install `matplotlib` using `pip` with the command `pip
    install --user matplotlib`.  For complete instructions on installing, please see
    [https://matplotlib.org/users/installing.html.](https://matplotlib.org/users/installing.html)
  prefs: []
  type: TYPE_NORMAL
- en: Data model method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can make a chart, we''ll need a `SQLModel` method to extract the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this chart is to find the sweet spot of `temperature` and `humidity`
    for each seed sample. Therefore, we need one row per `plot` that includes the
    maximum `fruit` measurement, average humidity and temperature at the `plot` column,
    and `seed_sample`. Since we don't want any bad data, we'll filter out rows that
    have `Equipment` `Fault`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the bubble chart view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate MatplotLib into a Tkinter application, there are several imports
    we need to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is `matplotlib` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It may seem odd to run code in the `import` section, and your editor may even
    complain about it. But before we import anything else from `matplotlib` we need
    to tell it which backend it should use. In this case, we want the `TkAgg` backend,
    which is made to integrate into Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can make a few more imports from `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Figure` class represents the basic drawing area on which `matplotlib` charts
    can be drawn. The `FigureCanvasTkAgg` class is an interface between the `Figure`
    and the Tkinter `Canvas`, and `NavigationToolbar2TkAgg` allows us to place a pre-made
    toolbar for `Figure` on our graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how these fit together, let''s start our `YieldChartView` class in `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After calling `super().__init__()` to create the `Frame` object, we create a
    `Figure` object to hold our chart. Instead of a size in pixels, the `Figure` object
    takes a size in **inches** and a **dots per inch** (**dpi**) setting (in this
    case, resulting in a 600 by 400 pixel `Figure`). Next, we create a `FigureCanvasTkAgg`
    object to connect our `Figure` object with a Tkinter `Canvas`. The `FigureCanvasTkAgg` object
    is not itself a `Canvas` object or subclass, but it has a `Canvas` object we can
    place in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add the toolbar and `pack()` to our `FigureCanvasTkAgg` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our toolbar is passed our `FigureCanvasTkAgg` object and the root window (`self`
    in this case),  attaching it to our figure and it's canvas. To place  the `FigureCanvasTkAgg`
    object on our `Frame` object, we need to call `get_tk_widget()` to retrieve its
    Tkinter `Canvas` widget, which we can then pack or grid as desired using `pack()`
    and `grid()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set up the axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In Matplotlib, an `axes` object represents a single set of `x` and `y` axes
    on which data can be graphed, and is created using the `add_subplot()` method.
    The three integers passed to `add_subplot()` establish that this is the first
    set of `axes` out of one row of one column of subplots. Our figure could conceivably
    contain multiple subplots arranged in a table-like format, but we only need one.
    After it's created, we set the labels on the `axes` object.
  prefs: []
  type: TYPE_NORMAL
- en: To create a bubble chart, we're going to use the **scatter plot** feature of
    Matplotlib, but use the size of each dot to indicate the fruit yield. We'll also
    color code the dots to indicate the seed sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a method to draw our scatter plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The data passed in should contain three columns per record, and we're breaking
    those out into three separate lists containing the `x`, `y`, and `size` values.
    Next, we're going amplify the differences between size values to make them more
    apparent by squaring each value then dividing it by half. This isn't strictly
    necessary, but it helps make the chart more readable when differences are relatively
    small.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we draw the data onto the `axes` object by calling `scatter()`, also
    passing along the  `color` and `label` values for the dots, and making them semi-transparent
    with the `alpha` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`zip(*data)` is a Python idiom for breaking a list of n-length tuples into
    n lists of values, essentially the reverse of `zip(x, y, s)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw legend for our `axes` object, we need two things: a list of our `scatter`
    objects and list of their labels. To get these, we''ll have to create a couple
    of blank lists in `__init__()` and append them whenever `draw_scatter()` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `__init__()`, add some empty lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the end of `draw_scatter()`, append the lists and update the `legend()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can call `legend()` repeatedly and it will simply destroy and redraw the
    legend each time.
  prefs: []
  type: TYPE_NORMAL
- en: Application method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in `Application`, let's create the method to show our yield data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `Toplevel` method and adding our chart view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s set up the data for our scatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've retrieved the yield `data` from the data model and created a dictionary
    that will hold the colors we want to use for each seed sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to iterate through the seed samples and draw the scatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're formatting and filtering down our data using a list comprehension,
    providing average humidity for `x`, average temperature for `y`, and yield for
    `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the method to the `callbacks` dictionary and create a menu item for it just
    under the growth chart option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your bubble chart should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/335e2505-6f35-4708-aaa0-5a5e1948112e.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a moment to play with this chart using the navigation toolbar. Notice how
    you can zoom and pan, adjust the size of the chart, and save the image. These
    are powerful tools that Matplotlib provides automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Tkinter's graphical capabilities. You learned
    how to draw and animate figures on the Tkinter `Canvas` widget, and how to use
    these capabilities to visualize data. You also learned how to integrate Matplotlib
    figures into your application, and we implemented two charts in our application
    by connecting SQL queries to our chart views.
  prefs: []
  type: TYPE_NORMAL
