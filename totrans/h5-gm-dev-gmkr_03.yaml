- en: 'Chapter 3. Shoot ''em Up: Creating a Side-scrolling Shooter'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a very simple side-scrolling shooter that will
    introduce us to the basics of making a complete game utilizing GML code. We will
    have a player character that can move around the play area and fire weapons. If
    they collide into an enemy or enemy bullet, they will be destroyed and can respawn
    if they have any remaining lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create three different types of enemies that fly across the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FloatBot**: It has no weapons but is hard to hit, because it floats up and
    down as it moves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpaceMine**: It is the slowest enemy and will fire a ring of bullets if the
    player gets too close.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strafer**: It is the fastest enemy that flies in a straight line and fires
    bullets directly at the player''s location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will polish the game by displaying the score and player lives, scroll the
    background to create the illusion of movement, play music, and add explosions.
    Finally, we will restart the game by implementing a win/lose condition. The game
    will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shoot ''em Up: Creating a Side-scrolling Shooter](img/4100OT_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Coding conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write effective code, regardless of programming language, it is
    important to follow the recommended coding conventions. This will help ensure
    that other people can read and understand what the code is attempting to do and
    debug it. There is no universal standard for programming practices, though many
    languages follow similar guidelines. The **GameMaker Language** (**GML**) does
    not have an official recommended set of conventions, partially due to the fact
    that it was developed to be a learning tool and is very forgiving as a result.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will define our own conventions based on common practices
    and ease of learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'All assets, except Rooms, will start with a simple type signifier and an underscore.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sprites**: `spr_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: `obj_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripts**: `scr_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though it is possible to use the Execute Code DnD to write code directly
    on an event, all code will be placed into Scripts and the naming convention will
    indicate the Object it is attached to and the Event it is applied to. This will
    make it easier to find later for debugging purposes. For example, code placed
    onto the player object's **Create** event would have a Script named `scr_Player_Create`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a Script is intended to be used by multiple objects, the name should use
    a clear description of what it is doing. For example: for removing an object after
    it goes offscreen, the Script would be named `scr_OffScreenRemoval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables will be written using CamelCase wherever multiple words are used;
    the first word starts with a lowercase letter, and each following word starts
    with an uppercase letter, for example: `variableWithManyWords`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean variables should be posed as a question, for example: `canShoot`, `isPlaying`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants are written using all uppercase letters and underscores to separate
    words, for example: `LEFT`, `MAX_GRAVITY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expressions in `if` statements are always enclosed in parentheses. GameMaker
    does not require this, but it does make it easier to read the code; for example:
    `if (x > 320)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by building our player object. We have briefly described
    the design already, but we have not broken the design down into something that
    we can start creating. First, we should bullet point each feature and what it
    entails to ensure we have all the **Variables** and **Events** we will need.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow keys will move the player around the play area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must remain in play area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spacebar will fire weapon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single bullet fired with each button press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliding with bullets or enemies causes damage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be different values based on type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the player sprite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the player sprite and prepare it for the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and call it `Chapter_03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Load Sprite** and load `Chapter 3/Sprites/Player.gif`, with **Remove
    Background** checked. This `.art` file has a spaceship with transparency and several
    frames of animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we want to adjust the collision area of the spaceship. The default collision
    is a rectangle covering the entire area of the Sprite that has pixel data. This
    means that the ship will take damage even though it has not visually come into
    contact with anything. What we want is to have a really small collision area.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Modify Mask**. This will open the **Mask Properties** editor as shown
    in the following screenshot:![Setting up the player sprite](img/4100OT_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Mask Properties** editor, we are able to control the size, shape, and
    placement of the collision mask, the area of a sprite where collision detection
    will occur. Some games require pixel perfect collision, where collision is determined
    on an individual pixel basis. This is the most precise collision possible, but
    it is also computationally expensive. The majority of games, however, can get
    away with a much simpler shape, such as a rectangle. This method is much more
    efficient, but limits the visual accuracy of the collision. The choice of which
    one to choose is dependent on the game's design and how much control is necessary
    to achieve the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: We want full control of the collision area, so set the **Bounding Box** to **Manual**
    and leave **Shape** as **Rectangle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two ways to adjust the parameters of the **Bounding Box**. We can
    either enter exact positions for the corners of the box, or we can draw the box
    directly on the image of the Sprite. Left mouse drag a small box roughly in the
    center of the spaceship as shown in the previous screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now back in the **Sprite Properties** editor and we can see that **Collision
    Checking** now states that it has been **Modified**. The last thing we will do
    to this Sprite is to move the origin to the tip of the spaceship's gun. By doing
    this we won't have to worry about offsetting the bullets upon creation through
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the player sprite](img/4100OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Set **Origin** to **X**: `28`, **Y**: `24`, and then click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Controlling the player object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the player object and get it moving around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `spr_Player` as its Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to initialize a variable for the speed we want the player to move at.
    This will make it easier to change the value later and have all scripts in `obj_Player`
    refer to it. Create a new Script and name it `scr_Player_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In `obj_Player`, add a **Create** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the `scr_Player_Create` to the script option. Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Player_Key_Left`. This script will have
    the code for the left arrow key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While we want the player to be able to move left, we also want to prevent the
    player from going offscreen. Write the following code into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start with a conditional `if` statement that queries whether the player's
    current `x` position is greater than or equal to the width of the sprite. In this
    case, it would mean that the origin of the player is greater than the image's
    width of 48 pixels. If it is greater, we place the object eight pixels to the
    left of the current position.
  prefs: []
  type: TYPE_NORMAL
- en: The method of movement we are using here is not movement in the traditional
    sense. There is no velocity being applied to the object, but rather we are teleporting
    the object from one position to the next. The benefit of using this method is
    that if the key isn't being pressed, the Object won't move. This is necessary
    in this game, because we cannot use a **No Key** event due to having to shoot
    weapons.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player`, add a **Left** event under **Keyboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the scr`_Player_Key_Left` to the **Script** option. Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we move on to all the other keys and their scripts, it is always good
    to check to see if the Object works as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **settings** tab, change the name to `TheGame` and **Width** to `800`.
    Making the Room wider will give the player more area to maneuver around and recognize
    enemies easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **objects** tab, select `obj_Player` and place a single instance near
    the center of the room as seen in the following screenshot:![Controlling the player
    object](img/4100OT_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is set up properly, the player should move to the left only when
    the left arrow is pressed down and should remain in the play area. We can now
    move onto the other controls.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Player_Key_Right`. This will be for the
    right arrow key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script will be similar to the left, except we need to also take into consideration
    the width of the room. Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are testing whether the player's current `x` position is less than the
    width of the room minus the width of the sprite. If it is less than that, we add
    `mySpeed` to the current location. This will ensure the player stays on-screen
    when moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player`, add a **Right** event under **Keyboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply `scr_Player_Key_Right`. Click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have our horizontal controls and need to add the vertical movement. We
    will go over the code for the up key and down key scripts, but by now you should
    be able to implement them into the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the up arrow key, create a new Script and name it `scr_Player_Key_Up`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is similar to the horizontal code except now we are looking at the `y` position
    and the height of the Sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the down arrow key, create a new Script and name it `scr_Player_Key_Down`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, here we are looking at the height of the room minus the height of the
    sprite as being the furthest point we can move downwards. The movement controls
    are now complete and the Object properties should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the player object](img/4100OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player should be able to move around the entire screen, but never off of
    it. The only remaining control we have left is the button for firing the gun.
    However, before we can implement that we need a bullet!
  prefs: []
  type: TYPE_NORMAL
- en: Building the bullet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bullets are easy to make, as they generally just move along in a straight line
    once they have been fired.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Bullet_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Load Sprite** and load `Chapter 3/Sprites /Bullet_Player.gif`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we currently have the origin of the player object set to the tip of the
    gun, we will want **Origin** of the bullet to be at the front. This will help
    make the bullet appear to come out of the gun without having to code it directly.
    Set the values to **X**: `17`, **Y**: `4`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can leave everything else as it is, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bullets should also make a sound when they are fired so let's bring in a sound.
    The first thing we need to do is to switch back to the Legacy Sound engine, so
    that we ensure the audio is heard in all browsers. Navigate to **Resources** |
    **Change Global Game Settings** and under the **General** tab, uncheck the box
    for **Use New Audio Engine**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sound and name it `snd_Bullet_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Load Sound** and load `Chapter 3/Sounds/Bullet_Player.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure **Kind** is set to **Normal Sound**. Then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it is time to make the bullet move on its own. Create a new Script and name
    it `scr_Bullet_Player_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want the bullet to move horizontally to the right. This is easy to do with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Hspeed** is a property representing the horizontal velocity of an object
    in GameMaker: Studio. We need to apply this code the moment the bullet is instantiated
    in the world. We also play the sound of the bullet a single time.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Bullet_Player`, and set the Sprite to `spr_Bullet_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create** event. The **Create** event is only ever executed once, upon
    creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the `scr_Bullet_Player_Create` and click on **OK**.![Building the bullet](img/4100OT_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, the bullet is now complete and ready to
    be fired. Let's go back to the spaceship!
  prefs: []
  type: TYPE_NORMAL
- en: Firing the bullet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bullet is only dangerous to enemies if it has been fired. The player ship
    will handle this code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Player_KeyPress_Space`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we are simply creating an instance of a bullet where the current
    position of the player ship is, or more specifically, where the origin of the
    player ship Sprite is. This will make the bullet appear to be shot from the ship's
    gun.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Player`, add a **Space** event from **Key Press** and apply `scr_Player_KeyPress_Space`.
    The **Key Press** event checks if the indicated key has been pushed down. This
    will run once and requires the key to be released before being able to run again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is working properly, we should be able to move around the screen
    and fire bullets as fast as we can hit the spacebar, as shown in the following
    screenshot. We are almost ready to start adding in gameplay, but before we do,
    we have a little bit of cleanup to do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Firing the bullet](img/4100OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If everything appears to be correct, but you are still unable to see the intended
    result, try refreshing your browser. Occasionally, browsers will keep the game
    in memory and won't load the updated version immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Removing bullets from the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time we create an instance of an object, it needs to be placed into the
    memory and the computer will need to keep a track of it. We have all these bullets
    that are going offscreen never to be seen again, but the computer sees them. This
    means that over time the computer could be trying to watch millions of wasted
    bullets, which in turn means that the game will start to slow down. As we don't
    want that to happen, we need to get rid of all these offscreen bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_OffScreenRemoval`. This Script can be applied
    to any object in the game that goes offscreen and that we want to get rid of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remove an instance from the world, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In `obj_Bullet_Player`, add an **Outside Room** event from **Other** and apply
    the script. The **Outside Room** event is a special event that checks if the entire
    sprite of an instanced object is completely outside the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There we go! We now have a spaceship that moves around the screen, shoots bullets,
    and we keep the memory usage low. Let's make some enemies!
  prefs: []
  type: TYPE_NORMAL
- en: Constructing three little enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this game we are going to have three unique types of enemies for the player
    to fight against: the FloatBot, the SpaceMine, and the Strafer. Each of these
    enemies will move differently and have a distinct attack. However, there are some
    common elements that they share, such as they will all have collision with bullets
    and the player, but not with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: It is always useful to think about the commonalities of the various objects
    as there may be ways to simplify and reduce the amount of work needed. In this
    case, as we are dealing with collision, we can use a **parent** object.
  prefs: []
  type: TYPE_NORMAL
- en: Making the enemy parent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parenting object is an incredibly useful ability in GameMaker: Studio. It allows
    for one object, the **parent**, to pass its attributes down to other objects called
    **child** objects in what is generally known as **inheritance** . The best way
    to think of this relationship is that parents are a group and children are individuals.
    This means we can tell a group to do something and every individual will do it.'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a parent object and use it for all the common collision events.
    This way we don't have to apply a new collision event for each different enemy.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Enemy_Parent`. We do not need a Sprite
    for this Object, as it will never be seen in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Enemy_Collision_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using a `with` statement which allows us to apply code to another
    object. In this case, we are also able to use a special variable called `other`
    which is only available in collision events. This is because there are always
    two instances involved and only one collision between the two. Whoever has the
    code is identified as `self` and then there is the other. When there is a collision
    between `obj_Enemy_Parent` or any child of it with `obj_Player`, we will remove
    the player, and then remove the instance it collided with.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Enemy_Parent`, add an `obj_Player` event from **Collision** and apply
    this collision script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Player collision now works, but currently nothing happens when bullets collide.
    We could use the same script if all the instances were going to be removed. In
    this case, we want to do something different if an enemy is hit by the player
    bullet. We want to award points.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating a new script, let's just duplicate the collision Script
    we just created. In the Resource tree, hold right-click on `scr_Enemy_Collision_Player`
    and select **Duplicate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name this script `scr_Enemy_Collision_Bullet`, and add the following line of
    code at the top of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add 20 points to the total score of the game. Just to make sure everything
    is set up correctly, the entire code for this script should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Back in `obj_Enemy_Parent`, add an `obj_Bullet` event from **Collision** and
    apply `scr_Enemy_Collision_Bullet`. Enemies will now be destroyed and points will
    be awarded when they collide with bullets!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final event we need the parent object to watch over is to remove enemies
    if they go offscreen. We can't use the same script as our bullet cleanup script,
    because we will be spawning enemies offscreen to the right. Therefore, we need
    to make sure they are only removed when they go off the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Enemy_Removal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we check to see if the `x` position of the instance is less than `0`,
    or offscreen to the left. If it is, we remove it from the game.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Enemy_Parent`, add an **Outside Room** event from **Other** and apply
    this script. We are done with the parent object and it should look like the following
    screenshot:![Making the enemy parent](img/4100OT_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a parent object that will deal with the bullet collision and remove
    the enemies when they go offscreen. Let's test it out by making some children.
  prefs: []
  type: TYPE_NORMAL
- en: Building the FloatBot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FloatBot is the most basic enemy in the game. It will not fire a weapon,
    which makes it more of an obstacle to be avoided. The FloatBot will move across
    the screen to the left, bobbing up and down as it goes.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_FloatBot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the Sprite `Chapter 3/Sprites/FloatBot.gif` with **Remove Background**
    checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is an animated Sprite whose shape changes on each frame. Therefore, we
    want to make sure the collision changes accordingly. In **Collision Checking**,
    check the box for **Precise Collision Checking**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want the origin to be in the center of this Sprite, so that it moves correctly
    when we add the bobbing motion. Set **Origin** to **X**: `16`, **Y**: `16`. Click
    on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need two scripts to make the FloatBot fly the way we intend. On creation
    we will apply the horizontal movement, and then at every step after that we will
    adjust the vertical bobbing motion.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_FloatBot_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The negative value of the horizontal speed means that it will move to the left.
    `angle` is a variable we will be using in the next script for the bobbing motion.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_FloatBot_Step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get the vertical motion we desire, we are going to use some simple trigonometry.
    Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we are changing the vertical speed based on the sine value of the variable
    angle in radians, multiplied by a base speed of `8`. We also increase the value
    of `angle` every step, which is necessary to have it follow the sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object, name it `obj_FloatBot`, and set `spr_FloatBot` as the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to make this object a child, so in the **Parent** drop-down box, select
    `obj_Enemy Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create** event and apply the `scr_FloatBot_Create` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Step** event and apply the `scr_FloatBot_Step` script. The FloatBot
    is now ready for testing and should look like the following screenshot:![Building
    the FloatBot](img/4100OT_03_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen the room `TheGame` and place an instance of `obj_FloatBot` somewhere
    on the right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is working correctly the FloatBot should move across the screen
    to the left and have a bob up and down around 240 pixels in height in a similar
    pattern as shown in the next screenshot. If we hit the FloatBot with a bullet,
    both the bullet and the FloatBot will disappear. We have also successfully created
    a parent-child relationship. Let's create another!
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the FloatBot](img/4100OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the SpaceMine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SpaceMine is going to be a slow moving object that will shoot a ring of
    bullets if the player gets too close. As this is going to require two objects,
    we should always start with the simplest one, the bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Bullet_SpaceMine`. Load `Chapter 3/Sprites/Bullet_SpaceMine.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin. We don't need to change **Collision Checking**, as a square
    will work fine for this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, name it `obj_Bullet_SpaceMine`, and set the Sprite to `spr_Bullet_SpaceMine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Bullet_SpaceMine_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This time we want to use the instance properties of `speed` and `direction`,
    as we will require the direction to be set later. Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In `obj_Bullet_SpaceMine`, add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add collision to the bullet and to do this quickly, we can reuse
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with the bullet for now, as can be seen in the
    following screenshot:![Creating the SpaceMine](img/4100OT_03_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time to build the SpaceMine itself. Create a new Sprite, name it `spr_SpaceMine`,
    and load `Chapter 3/Sprites/SpaceMine.gif` with **Remove Background** checked.
    As you can see, the SpaceMine has animated blinking lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin and check **Precise Collision Checking**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a shooting sound when the SpaceMine fires, so create a new Sound, `snd_Bullet_SpaceMine`
    and load `Chapter 3/Sounds/Bullet_SpaceMine.wav`. We won't be attaching this to
    the bullets themselves as we will be creating eight bullets, but we only need
    the sound to be played once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**. Create
    a new Object and name it `obj_SpaceMine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Sprite** to `spr_SpaceMine` and **Parent** to `obj_Enemy_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_SpaceMine_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need the SpaceMine to do a few things. It is going to fire bullets, so we
    will need a variable to control when it shoots. It needs to move across the screen,
    so we need to apply velocity. Finally, we will want to slow down the animation
    so that it doesn't blink too fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we are setting the horizontal speed to move slowly to the left. `canFire`
    is a Boolean variable that will determine if it is to shoot or not. Finally, `image_speed`
    sets the speed of the animation. At a speed of `0.2`, it animates at 20 percent
    of normal, or in other words, each frame of animation will be held for five steps.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_SpaceMine`, add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another new script and name it `scr_SpaceMine_Step`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each step we will want to see whether the player is within proximity of the
    SpaceMine. If the player is too close, the SpaceMine will start firing rings of
    bullets. We don't want a stream of bullets, so we are going to need to add a delay
    between each firing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking two statements; the distance between the SpaceMine and
    `obj_Player`, and whether we are able to shoot. The distance we have chosen is
    `200` pixels, which should be enough space for the player to avoid triggering
    it occasionally. If the player is in range and we can shoot, we set `alarm` for
    `60` steps (2 seconds) and play the bullet sound once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alarm is an event that, when triggered, will execute code a single time.
  prefs: []
  type: TYPE_NORMAL
- en: To create the ring of bullets we will use a `for` loop. When we create an instance
    of an object it returns the unique ID of that instance. We need to capture this
    in a variable, so that we can talk to the object and affect it. Here we are using
    a variable called `bullet` which is an instance of `obj_Bullet_SpaceMine`. We
    can then change the properties of the bullet such as direction. In this case,
    each bullet will be offset by 45 degrees. We also apply some additional `hspeed`
    to the bullets, so that they move along with the SpaceMine. Finally, we set the
    `canFire` variable to `true` to indicate that we have fired our bullets.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_SpaceMine`, add a **Step** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are almost done with the SpaceMine, we just need to add some code to an alarm
    that we can trigger, so that it can shoot more than once. Create a new Script
    and name it `scr_SpaceMine_Alarm0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `canFire` variable back to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In `obj_SpaceMine`, add an **Alarm 0** event and apply this script. We are now
    done with the SpaceMine and it should look like the following screenshot:![Creating
    the SpaceMine](img/4100OT_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `TheGame`, add an instance of `obj_SpaceMine` on the right-hand side of
    the screen, and then run the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is set up properly, the SpaceMine will slowly move across the
    screen to the left and blink. When the player approaches the SpaceMine, eight
    bullets should blast out from it as seen in the next screenshot. Every two seconds,
    another ring will be fired from this instance, so long as the player is still
    within range. If the SpaceMine is hit by one of the player bullets, it will be
    destroyed. Finally, if the player collides with the enemy's bullet the player
    disappears. Let's move on to our final enemy!
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the SpaceMine](img/4100OT_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making the Strafer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strafer is the most dangerous enemy in the game. It moves very quickly in
    a straight line and will target the player no matter where they are. Once again,
    there are two objects needed, so let's start with the bullet.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Bullet_Strafer`. Load `Chapter 3/Sprites/Bullet_Strafer.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Bullet_Strafer` and set the Sprite to `spr_Bullet_Strafer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a unique shooting sound, so create a new Sound, `snd_Bullet_Strafer`,
    and load `Chapter 3/Sounds/Bullet_Strafer.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Bullet_Strafer_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This script will be similar to `scr_Bullet_SpaceMine_Create`, except that this
    bullet is faster and playing the bullet sound. Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In `obj_Bullet_Strafer`, add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with the other enemy bullet, let's add collision to the bullet by reusing
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with this bullet, so let's build the enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Strafer`, and load `Chapter 3/Sprites/Strafer.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want the bullet to come from the front of the ship, so we need to manually
    move the origin to the proper location. Set **Origin** to **X**: `0`, **Y**: `19`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Strafer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Sprite** to `spr_Strafer` and **Parent** to `obj_Enemy_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Script and name it `scr_Strafer_Create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Strafer is going to move quickly across the screen and fire bullets at
    the player constantly. Write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Much like the SpaceMine, we have set `hspeed` to move left, and are also setting
    an alarm so that the Strafer will start shooting immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Strafer`, add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We only need one more script and that is for the alarm. Create a new Script
    and name it `scr_Strafer_Alarm0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the alarm goes off, we need to create a bullet, launch it at the player,
    and then reset the alarm so that it can fire again. To do this write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We start here by creating an instance of `obj_Bullet_Strafer`. When an instance
    is created, the function returns the unique ID of that instance; we then capture
    it in a variable, such as `bullet`. Next, we query whether the player exists or
    not. This is a very important step, as without this check if the player is dead
    and the Strafer tries to target it, the game will error out and crash.
  prefs: []
  type: TYPE_NORMAL
- en: If the player does exist, we set the bullet direction at the player. This is
    done through the `point_direction` function that takes any two points in space
    (x1, y1) and (x2, y2) and returns the angle in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reset the alarm. In this case, to make things more interesting we
    have added a bit of randomness to it. The `irandom` function will return a whole
    number between zero and the number you pass to it. The code we have here will
    give us a random value between `0` and `30` and we will add `15` to it. This means
    a new bullet will be created between every half second to a second and a half.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Strafer`, add an **Alarm 0** event and apply this script.![Making the
    Strafer](img/4100OT_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Strafer is now complete, so let's test it out and place one in `TheGame`
    on the left-hand side.![Making the Strafer](img/4100OT_03_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is working correctly, the Strafer will quickly move across the
    screen and fire bullets directly at the position of the player. Make sure you
    move the player around the room to make sure it fires in all directions! The player
    should be able to shoot and destroy the Strafer. If hit by the Strafer's bullet,
    the player should disappear.
  prefs: []
  type: TYPE_NORMAL
- en: The enemies for the game are all complete; now we just need a way to populate
    the game world. Let's bring in an Overlord!
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the game with the Overlord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this game, we will be using the Overlord, the master controller of the game,
    to control the spawning of enemies, monitor the player's lives, and deal with
    the win/lose condition. The win condition will simply be to survive for two minutes
    against waves of enemies. The lose condition will be that the player runs out
    of lives.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning waves of enemies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to start by creating the wave of enemies, so that the game is playable.
    For this, we will utilize a looping timeline to spawn the various enemies. We
    are going to have three different waves, each one spawning a different enemy every
    two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create three new scripts, and name them: `scr_Wave_Strafer`, `scr_Wave_SpaceMine`,
    and `scr_Wave_FloatBot`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start with the wave of Strafer, as it will be the simplest wave. Write
    the following code in `scr_Wave_Strafer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we spawn two instances of the Strafer located `64` pixels off the right-hand
    side of the screen. This will ensure that we don't see them pop into existence.
    We have also offset them by `64` pixels from the vertical center of the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the SpaceMine, we will want them vertically placed in random positions
    to keep things interesting. Write the following code in `scr_Wave_SpaceMine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating a variable called `placeY` to hold a value for the vertical
    position. GameMaker: Studio has a special function, `irandom_range`, which will
    return a whole number between any two numbers passed to it. The numbers we used
    will ensure that the SpaceMine will remain at least 64 pixels away from the top
    and bottom of the screen. We then use the `placeY` variable when we create the
    instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The FloatBot is going to use a similar setup for placement on the vertical
    axis, but we will want three instances flying in a "V" formation. Write the following
    code in `scr_Wave_FloatBot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the `placeY` variable again, but the range of numbers is narrower.
    We need some extra padding, so that all three planes stay onscreen. The first
    instance created is the front unit of the formation. The next two instances spawn
    32 pixels behind and offset 32 pixels above and below the first.
  prefs: []
  type: TYPE_NORMAL
- en: All the waves are scripted, so we can now implement them in a Time Line. When
    first implementing a Time Line, it is useful to keep the numbers simple, such
    as two seconds apart. Properly balancing the timing comes during the polish phase
    of a game's development, and spending too much time trying to get this right before
    all content is in is most likely wasted time. Create a new Time Line and name
    it `tm_Wave_Spawning`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**, set **Indicate the Moment** as `60`, and apply the `scr_Wave_FloatBot`
    script. This will spawn the first enemy into the game for two seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to add the SpaceMines two seconds later. Click on **Add**, set
    **Indicate the Moment** as `120`, and apply the `scr_Wave_SpaceMine` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we bring in the Strafer after six seconds. Click on **Add**, set **Indicate
    the Moment** as `180`, and apply the `scr_Wave_Strafer` script. The Time Line
    is now ready to be used and should look like the following screenshot:![Spawning
    waves of enemies](img/4100OT_03_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the Overlord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to start building the Overlord and apply our spawning system.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Overlord`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no Sprite needed, so set **Sprite** to **no sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start the Time Line immediately upon creation of the Overlord. Create
    a new Script, name it `scr_Overlord_Create`, and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code defines what Time Line we want to run, in our case we
    only have one: `tm_Wave_Spawning`. Next, we start the Time Line and then tell
    it to loop. These last two are Boolean variables, which means that they can only
    be turned on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Overlord, add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **TheGame** and place a single instance of the Overlord anywhere in the
    room. The location does not matter, but the upper-left corner is a common place
    to put it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any instances of the enemies that remain in the room. There should be
    only one instance of the Player and one of the Overlord as can be seen in the
    following screenshot:![Building the Overlord](img/4100OT_03_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.![Building the Overlord](img/4100OT_03_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The game now has enemies! It will take a couple of seconds for the first enemy,
    the FloatBots, to appear, but after that the enemies will continue to spawn forever.
    At this point we have most of the core gameplay implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can move the player around the screen, but not out of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can shoot and destroy enemies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies can shoot and destroy the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies will spawn continuously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only element remaining is very obvious when playing the game at this stage;
    the player can die, but the game doesn't stop. We need to implement the win/lose
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the life and death of the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this is a game about survival, we will want the win/lose condition to be
    fairly simple. For the win condition, we will make the player survive for a set
    amount of time. The lose condition will be the player dying, but we don't want
    to come across as too hard to play, so we will give the player three lives. This
    means that we are going to need to respawn the player. Finally, to get this to
    work properly, we will need to give the Overlord some more duties.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the win condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The win condition for this game is to survive for a set amount of time. We can
    achieve this through the use of an alarm and a variable to signal to the Overlord
    that the player has survived.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set up some variables for the lives, win, and lose conditions.
    Reopen `scr_Overlord_Create` and add the following code at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'GameMaker: Studio has a few built-in global variables including `lives`. This
    variable is accessible by every instance in the game and never goes away. Here
    we have set it to `3` and will use that as our starting point. We also create
    two other variables, `isVictory` and `isDefeat`, which we have set to `false`.
    The reason we are using two variables to represent winning and losing the game
    instead of one is that we will want to check these during gameplay when they have
    neither won nor lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set our win condition in this script by setting an alarm for 90
    seconds. To do this add the following line of code after the code in step 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scr_Overlord_Create` script should now look like the following in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to set up a script for the alarm event for the victory condition.
    Create a new Script, name it `scr_Overlord_Victory`, and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The very first thing we do is stop the Time Line, as we don't want any more
    enemies to spawn. The next step is to remove all enemies still alive in the game.
    We do this by using a `with` statement that is going to execute code to all instances
    of `obj_Enemy_Parent`. As all the enemies are children of this object, they too
    will be destroyed. We will eventually want to restart the game, so we set another
    alarm for three seconds. Finally, we set the `isVictory` variable to true.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Overlord`, add an **Alarm 0** event and apply the victory script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wrap this up by creating the restart script. Create a new Script, name
    it `scr_Overlord_GameRestart` and write this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Add an **Alarm 1** event and apply this restart script. The win condition is
    now working, so feel free to try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respawning with a Ghost object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now move on to the losing condition and respawning. When the player dies,
    we don't want to have the player respawn immediately, but instead have a smaller
    buffer of invulnerability. To do this, we will want to create a Ghost object that
    will temporarily stand in for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, name it `spr_Ghost`, and load `Chapter 3/Sprites/Ghost.gif`
    with **Remove Background** checked. It looks just like the plane, but is slightly
    transparent and flickers when animated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to set the origin to be exactly the same as the origin of `spr_Player`.
    Set **Origin** to **X**: `43`, **Y**: `22`, and then click on **OK**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, name it `obj_Ghost`, and apply `spr_Ghost` as the Sprite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the player dies, we are going to have the Ghost appear offscreen to the
    left and then move into the gameplay area. Create a new Script, name it `scr_Ghost_Create`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting the `x` coordinate to be offscreen by `64` pixels. We then
    center the Ghost vertically by setting the `y` coordinate to half of the room
    height. Finally, we are applying a positive velocity to the Ghost, so that it
    starts moving on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Create** event to `obj_Ghost` and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Ghost is going to move on the screen, and we will need to change it into
    the player at some point. In our case, we will make the switch once the Ghost
    has passed quarter way into the gameplay area. Create a new script, name it `scr_Ghost_Step`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we check to see if the Ghost''s `x` coordinate has crossed `200` pixels
    or not. If it has, we stop the forward velocity and then we transform into the
    player. The `instance_change` function asks for two arguments: what object to
    transform into and whether we want to run the **Create** event of this new object.'
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Step** event to `obj_Ghost` and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One issue we will encounter with this setup is that the player has no control
    of the Ghost, and could end up in a dangerous position near an enemy when they
    transform. We don't want that, so let's give the player some limited controls.
    We can reuse the existing `scr_Player_Key_Up` and `scr_Player_Key_Down` scripts,
    so that the player has vertical movement. Add the appropriate Keyboard events
    and attach these scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ghost Object's properties should look like the following screenshot and
    is now ready to become a part of the game. We just need to change what happens
    when the player is hit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Respawning with a Ghost object](img/4100OT_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reopen `scr_Enemy_Collision_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Currently, we are destroying both the bullet and the player. We need to change
    the `with` statement to allow for respawning. Remove line **3**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We only want to become a Ghost if we have lives available, so we start by checking
    that. If we do have at least one life, we transform the Player into a Ghost. Otherwise,
    we just destroy the Player and the Player will be permanently dead. Finally, we
    subtract a life every time, whether we have lives or not. The final code should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we can play the game. Notice that when the player dies:'
  prefs: []
  type: TYPE_NORMAL
- en: The player disappears
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Ghost is created and moves into the play area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ghost can move up and down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ghost turns back into the Player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This of course happens three times and then the player disappears forever. The
    rest of the game, however, is continuing on as if nothing happened. We need to
    add in the defeat condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Overlord_Step`, and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Every step in this code will check to see if the player has any lives left.
    If the player has no lives left and the variable `isDefeat` is still `false`,
    it will set the *Restart Game* alarm for three seconds. Lastly, we set the `isDefeat`
    variable to `true`, so that we don't run this code again.
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Overlord`, add a **Step** event and apply this script. The game will
    now restart after the player dies three times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The core mechanics of the game are now complete, but it's not very clear to
    the player as to what is going on. The player can die and respawn a few times,
    but there is no indication of how many lives are left. Nor is there any information
    being displayed on whether the player has won or lost the game. Let's fix this!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important elements in creating a great game is ensuring that
    the player has all the information they need to play the game. Much of this is
    usually presented in the **heads-up display**, otherwise known as the **HUD**.
    Every game has different components that can be a part of the HUD including things
    we need such as scoreboards and life counters.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we are going to need a font for the text we intend to display.
    We have supplied a font called **Retroheavyfuture** for use in this game that
    will need to be installed on your computer. To install this font on a Windows
    7 computer, right-click on `Chapter 3/Fonts/RETRRG__.ttf` and click on **Install**.
    Then follow the directions when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back into GameMaker: Studio, create a new font and name it `fnt_Scoreboard`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Retroheavyfuture** as **Font**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Size** under **Style** to `16`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a decent sized font to display the score and lives during the game.
    It should look like the following screenshot, so click on **OK**:![Drawing the
    user interface](img/4100OT_03_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need a second version of the font when we display the win/lose condition.
    Create a new font and name it `fnt_WinLose`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, select **Retroheavyfuture** as **Font**, but this time set **Size**
    to `32`. We now have all the in-game fonts we need, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move on to the new Script, `scr_Overlord_Draw`. We will start by setting
    the color and the font for the scoreboard text with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of code sets the color with one of GameMaker: Studio''s premade
    colors, `c_white`. The next line then sets the scoreboard as the font.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting colors are globally applied to the `draw` events. That means if you
    don't set a color, it will use the color last set, regardless of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the font set we can start applying the HUD. We will start with the player
    lives. Add this code to the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure the text is properly formatted, we set the horizontal alignment of
    the text to be aligned left. The text itself needs to be a string, which can be
    done in two ways. First, anything in quotation marks is considered a string, such
    as `"Lives: "`. If we want to pass a number, such as the amount of lives we have,
    we need to convert it by passing through the string function. As seen here, if
    we have lives remaining we can concatenate the two things to create a single sentence
    *Lives: 3* and draw it in the upper-left corner of the screen. If we are out of
    life, we draw the text without the concatenated value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other HUD element we want is the score, which we will place on the opposite
    side of the screen in the upper-right corner. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the previous text, we are setting the horizontal alignment, this
    time to the right. We then place the text in the proper position using the same
    concatenation method for the score.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this out now by adding a **Draw GUI** event to `obj_Overlord` and
    apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. As seen in the next screenshot, the game should now display the
    lives in the upper-left corner and update each time the player dies. It should
    also display the score in the upper right-hand corner and increase with every
    enemy killed.![Drawing the user interface](img/4100OT_03_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to add the display for when the player wins or loses. Add the following
    code at the end of `scr_Overlord_Draw`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We change the font to `fnt_WinLose` and set the horizontal alignment to be in
    the center. We don't want the text to be displayed all the time, instead we should
    only show either **VICTORY** or **DEFEAT** when it is appropriate. We have already
    implemented the code in the Overlord for the game condition, so we just check
    every step whether `isVictory` is `true` or `isDefeat` is `true`. As soon as the
    game is either won or lost, we draw the appropriate text in the center of the
    room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `scr_Overlord_Draw` script should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Adding the finishing details to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game is now functionally complete, but it doesn't have any polish or the
    finishing details we would expect of a full game. There is no music, no background
    art, and no explosions! Let's fix that right now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the game music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want the music to start at the beginning and play for the duration of the
    game. When the win/lose condition occurs, we want the music to fade out to let
    the player know that the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sound and name it `snd_Music`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 3/Sounds/Music.mp3`. **Kind** should be set to **Background Music**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reopen `scr_Overlord_Create`. Since the Overlord controls the overall game,
    we will use it to control the music as well. After the last line of code, add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We start by playing the music and set it to loop. We then create a variable,
    `volume`, that we will use for controlling the sound level and the fade out. We
    have set the sound level to `1`, which is full volume. Finally, we set the global
    sound level, or master gain level, to the variable `volume`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `scr_Overlord_Step`. To fade the music out we will need to lower the
    global volume over several steps, but only if the game has ended. After the last
    line of code, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here we check to see if either the win or lose condition has been set to `true`.
    If it has been, we decrease the volume variable by `0.02` and apply it to the
    master gain level. It will take 50 steps for the sound level to go from full volume
    to silent, which is about half the duration before the game restart kicks in.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. You should now hear the background music playing. If the player
    dies quickly three times and the defeat condition is triggered, you should hear
    the sound fade out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the background move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This game takes place in outer space, so we will need to add in a space backdrop.
    In order for the game universe to feel as though the player is moving, we need
    to make the background shift constantly to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Background and name it `bg_Starscape`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 3/Backgrounds/Starscape.gif` with **Remove Background** unchecked.
    This is all we need to do for this, so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `TheGame` and select the **backgrounds** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `bg_Starscape` as **background image**. It should happen automatically,
    but ensure that **Background 0** is highlighted and that **Visible when room starts**
    is checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The starscape is only going to move horizontally, therefore we only need **Tile
    Hor.** checked so that the image wraps around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To move the background, set **Hor. Speed:** to `-2`. This will make it move
    to the left, which will make the player appear to move to the right. The settings
    should look like the following screenshot:![Making the background move](img/4100OT_03_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should now see a moving starscape! Check out the following
    screenshot:![Making the background move](img/4100OT_03_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the explosions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having enemies just blink out of existence not only looks bad, it is not very
    rewarding to the player. Let's make this more exciting by adding in some explosions!
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Explosion`, and load `Chapter 3/Sprites/Explosion.gif`
    with **Remove Background** checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the origin to the center and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sound, `snd_Explosion`, and load `Chapter 3/Sounds/Explosion.wav`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Explosion`, and set the sprite to `spr_Explosion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the explosion to make a sound, play its animation, and then remove itself
    from the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Explosion_Create`, and write the following code to
    play the explosion sound a single time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Add a **Create** event and apply this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get the explosion to remove itself is best done when the animation is finished.
    Luckily for us, GameMaker: Studio has an event for that. Add an **Animation End**
    event from **Other**, and then create a new Script to apply to it named `scr_Explosion_AnimEnd`
    with the following code to remove the instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The explosion is now prepared and all we have to do is spawn it when we destroy
    an enemy. Open `scr_Enemy_Collision_Bullet` and add the following line of code
    at the very top of the script on line **1**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will create an explosion right where the enemy is located. This needs to
    happen before we remove the enemy from the game.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this code addition with `scr_Enemy_Collision_Player`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should now see explosions whenever something is destroyed
    as shown in the following screenshot:![Creating the explosions](img/4100OT_03_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You have just finished creating your first side-scrolling
    shooter. We covered quite a lot in this chapter. We have applied all three methods
    of movement: manually adjusting the X and Y coordinates, using `hspeed` and `vspeed`,
    and setting the `speed` and `direction` variables. We are now able to add and
    remove instances from the game world dynamically. With the bullets, we learned
    to transfer information from one instance to another, such as the direction to
    move, by capturing the ID of the instance and accessing it through the dot operator.'
  prefs: []
  type: TYPE_NORMAL
- en: We discovered the wonderful `with` statement that gave us the ability to affect
    a single instance, all instances of an object, or even the `other` instance involved
    in a collision. We took a look at global variables, such as `lives` and `score`,
    and used the **Draw** event to display it. Waves of enemies were spawned using
    Time Lines. The illusion of movement was created by scrolling the background image.
    Sound was applied and the volume adjusted to create a fade out effect. We even
    used a bit of trigonometry!
  prefs: []
  type: TYPE_NORMAL
- en: With the skills and knowledge developed in this chapter it is now your turn
    to take this game and extend it even further. Try adding your own enemies, collectible
    items, and weapon power-ups. Have some fun with it!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn more about collision and player controls
    by making a spooky adventure game. We will also take a look at artificial intelligence
    and using paths to make the enemies appear to think and act on their own.
  prefs: []
  type: TYPE_NORMAL
