- en: 'Chapter 3. Shoot ''em Up: Creating a Side-scrolling Shooter'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a very simple side-scrolling shooter that will
    introduce us to the basics of making a complete game utilizing GML code. We will
    have a player character that can move around the play area and fire weapons. If
    they collide into an enemy or enemy bullet, they will be destroyed and can respawn
    if they have any remaining lives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create three different types of enemies that fly across the screen:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**FloatBot**: It has no weapons but is hard to hit, because it floats up and
    down as it moves.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SpaceMine**: It is the slowest enemy and will fire a ring of bullets if the
    player gets too close.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strafer**: It is the fastest enemy that flies in a straight line and fires
    bullets directly at the player''s location.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will polish the game by displaying the score and player lives, scroll the
    background to create the illusion of movement, play music, and add explosions.
    Finally, we will restart the game by implementing a win/lose condition. The game
    will look as shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![Shoot ''em Up: Creating a Side-scrolling Shooter](img/4100OT_03_22.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Coding conventions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write effective code, regardless of programming language, it is
    important to follow the recommended coding conventions. This will help ensure
    that other people can read and understand what the code is attempting to do and
    debug it. There is no universal standard for programming practices, though many
    languages follow similar guidelines. The **GameMaker Language** (**GML**) does
    not have an official recommended set of conventions, partially due to the fact
    that it was developed to be a learning tool and is very forgiving as a result.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we will define our own conventions based on common practices
    and ease of learning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'All assets, except Rooms, will start with a simple type signifier and an underscore.
    For example:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sprites**: `spr_`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: `obj_`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripts**: `scr_`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though it is possible to use the Execute Code DnD to write code directly
    on an event, all code will be placed into Scripts and the naming convention will
    indicate the Object it is attached to and the Event it is applied to. This will
    make it easier to find later for debugging purposes. For example, code placed
    onto the player object's **Create** event would have a Script named `scr_Player_Create`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a Script is intended to be used by multiple objects, the name should use
    a clear description of what it is doing. For example: for removing an object after
    it goes offscreen, the Script would be named `scr_OffScreenRemoval`.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables will be written using CamelCase wherever multiple words are used;
    the first word starts with a lowercase letter, and each following word starts
    with an uppercase letter, for example: `variableWithManyWords`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boolean variables should be posed as a question, for example: `canShoot`, `isPlaying`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constants are written using all uppercase letters and underscores to separate
    words, for example: `LEFT`, `MAX_GRAVITY`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expressions in `if` statements are always enclosed in parentheses. GameMaker
    does not require this, but it does make it easier to read the code; for example:
    `if (x > 320)`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the player
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by building our player object. We have briefly described
    the design already, but we have not broken the design down into something that
    we can start creating. First, we should bullet point each feature and what it
    entails to ensure we have all the **Variables** and **Events** we will need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Arrow keys will move the player around the play area
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must remain in play area
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spacebar will fire weapon
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single bullet fired with each button press
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colliding with bullets or enemies causes damage
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should be different values based on type
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the player sprite
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the player sprite and prepare it for the game:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project and call it `Chapter_03`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Player`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Load Sprite** and load `Chapter 3/Sprites/Player.gif`, with **Remove
    Background** checked. This `.art` file has a spaceship with transparency and several
    frames of animation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载精灵**，加载`Chapter 3/Sprites/Player.gif`，勾选**移除背景**。这个`.art`文件有一个带有透明度和几帧动画的太空飞船。
- en: Next, we want to adjust the collision area of the spaceship. The default collision
    is a rectangle covering the entire area of the Sprite that has pixel data. This
    means that the ship will take damage even though it has not visually come into
    contact with anything. What we want is to have a really small collision area.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要调整太空飞船的碰撞区域。默认的碰撞是一个覆盖具有像素数据的精灵整个区域的矩形。这意味着即使外观上没有接触任何东西，飞船也会受到伤害。我们希望的是有一个非常小的碰撞区域。
- en: Click on **Modify Mask**. This will open the **Mask Properties** editor as shown
    in the following screenshot:![Setting up the player sprite](img/4100OT_03_01.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**修改遮罩**。这将打开**遮罩属性**编辑器，如下截图所示：![设置玩家精灵](img/4100OT_03_01.jpg)
- en: In the **Mask Properties** editor, we are able to control the size, shape, and
    placement of the collision mask, the area of a sprite where collision detection
    will occur. Some games require pixel perfect collision, where collision is determined
    on an individual pixel basis. This is the most precise collision possible, but
    it is also computationally expensive. The majority of games, however, can get
    away with a much simpler shape, such as a rectangle. This method is much more
    efficient, but limits the visual accuracy of the collision. The choice of which
    one to choose is dependent on the game's design and how much control is necessary
    to achieve the desired results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在**遮罩属性**编辑器中，我们可以控制碰撞遮罩的大小、形状和位置，即精灵中进行碰撞检测的区域。一些游戏需要像素级的碰撞检测，即根据单个像素确定碰撞。这是最精确的碰撞检测，但也需要大量计算。然而，大多数游戏可以使用简单得多的形状，比如矩形。这种方法更有效，但限制了碰撞的视觉准确性。选择哪种方法取决于游戏的设计以及为实现期望的结果需要多少控制。
- en: We want full control of the collision area, so set the **Bounding Box** to **Manual**
    and leave **Shape** as **Rectangle**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望完全控制碰撞区域，所以将**边界框**设置为**手动**，并将**形状**保留为**矩形**。
- en: There are two ways to adjust the parameters of the **Bounding Box**. We can
    either enter exact positions for the corners of the box, or we can draw the box
    directly on the image of the Sprite. Left mouse drag a small box roughly in the
    center of the spaceship as shown in the previous screenshot.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**边界框**参数有两种方法。我们可以输入框的角落的确切位置，或者直接在精灵图像上绘制框。用鼠标左键拖动一个小框，大致位于太空飞船的中心，如前一个截图所示。
- en: Click on **OK**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。
- en: We are now back in the **Sprite Properties** editor and we can see that **Collision
    Checking** now states that it has been **Modified**. The last thing we will do
    to this Sprite is to move the origin to the tip of the spaceship's gun. By doing
    this we won't have to worry about offsetting the bullets upon creation through
    code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到**精灵属性**编辑器，可以看到**碰撞检测**现在显示为**已修改**。我们要做的最后一件事是将原点移动到太空飞船枪的尖端。这样做，我们就不必担心通过代码在创建时偏移子弹。
- en: '![Setting up the player sprite](img/4100OT_03_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![设置玩家精灵](img/4100OT_03_02.jpg)'
- en: 'Set **Origin** to **X**: `28`, **Y**: `24`, and then click on **OK**.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**原点**设置为**X**:`28`，**Y**:`24`，然后点击**确定**。
- en: Controlling the player object
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制玩家对象
- en: Let's create the player object and get it moving around the world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建玩家对象，并让它在世界中移动。
- en: Create a new Object and name it `obj_Player`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Player`。
- en: Assign `spr_Player` as its Sprite.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`spr_Player`指定为其精灵。
- en: We need to initialize a variable for the speed we want the player to move at.
    This will make it easier to change the value later and have all scripts in `obj_Player`
    refer to it. Create a new Script and name it `scr_Player_Create`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要初始化一个变量，用于控制玩家移动的速度。这样以后更改数值会更容易，并且`obj_Player`中的所有脚本都可以引用它。创建一个新的脚本，命名为`scr_Player_Create`。
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In `obj_Player`, add a **Create** event.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**创建**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the `scr_Player_Create` to the script option. Click on **OK**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并将`scr_Player_Create`应用到脚本选项。点击**确定**。
- en: Create a new Script and name it `scr_Player_Key_Left`. This script will have
    the code for the left arrow key.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_Player_Key_Left`。这个脚本将包含左箭头键的代码。
- en: 'While we want the player to be able to move left, we also want to prevent the
    player from going offscreen. Write the following code into the script:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们希望玩家能向左移动，但我们也希望防止玩家离开屏幕。将以下代码写入脚本：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start with a conditional `if` statement that queries whether the player's
    current `x` position is greater than or equal to the width of the sprite. In this
    case, it would mean that the origin of the player is greater than the image's
    width of 48 pixels. If it is greater, we place the object eight pixels to the
    left of the current position.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用条件`if`语句查询玩家当前的`x`位置是否大于或等于精灵的宽度。在这种情况下，这意味着玩家的原点大于48像素的图像宽度。如果大于，我们将对象放在当前位置的左侧八个像素处。
- en: The method of movement we are using here is not movement in the traditional
    sense. There is no velocity being applied to the object, but rather we are teleporting
    the object from one position to the next. The benefit of using this method is
    that if the key isn't being pressed, the Object won't move. This is necessary
    in this game, because we cannot use a **No Key** event due to having to shoot
    weapons.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的移动方法不是传统意义上的移动。对象没有施加速度，而是我们将对象从一个位置瞬间传送到另一个位置。使用这种方法的好处是，如果没有按键，对象就不会移动。这在这个游戏中是必要的，因为我们不能使用**无按键**事件来射击武器。
- en: In `obj_Player`, add a **Left** event under **Keyboard**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，在**键盘**下添加一个**左**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply the scr`_Player_Key_Left` to the **Script** option. Click on **OK**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并将scr`_Player_Key_Left`应用到**脚本**选项中。点击**确定**。
- en: Before we move on to all the other keys and their scripts, it is always good
    to check to see if the Object works as intended.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理所有其他键及其脚本之前，最好检查对象是否按预期工作。
- en: Create a new Room.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的房间。
- en: In the **settings** tab, change the name to `TheGame` and **Width** to `800`.
    Making the Room wider will give the player more area to maneuver around and recognize
    enemies easier.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设置**选项卡中，将名称更改为`TheGame`，**宽度**更改为`800`。使房间变宽将为玩家提供更多的操纵空间，并更容易识别敌人。
- en: In the **objects** tab, select `obj_Player` and place a single instance near
    the center of the room as seen in the following screenshot:![Controlling the player
    object](img/4100OT_03_03.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象**选项卡中，选择`obj_Player`并在房间中心附近放置一个单个实例，如下截屏所示：![控制玩家对象](img/4100OT_03_03.jpg)
- en: Run the game.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is set up properly, the player should move to the left only when
    the left arrow is pressed down and should remain in the play area. We can now
    move onto the other controls.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，玩家应该只在按下左箭头时向左移动，并且应该保持在游戏区域内。现在我们可以继续处理其他控制。
- en: Create a new Script and name it `scr_Player_Key_Right`. This will be for the
    right arrow key.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Player_Key_Right`。这将用于右箭头键。
- en: 'The script will be similar to the left, except we need to also take into consideration
    the width of the room. Write the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本将类似于左侧，只是我们还需要考虑房间的宽度。编写以下代码：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are testing whether the player's current `x` position is less than the
    width of the room minus the width of the sprite. If it is less than that, we add
    `mySpeed` to the current location. This will ensure the player stays on-screen
    when moving to the right.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在测试玩家当前的`x`位置是否小于房间宽度减去精灵的宽度。如果小于这个值，我们将`mySpeed`添加到当前位置。这将确保玩家在向右移动时保持在屏幕上。
- en: In `obj_Player`, add a **Right** event under **Keyboard**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，在**键盘**下添加一个**右**事件。
- en: Drag an Execute Script icon from **Control** into the **Actions:** area, and
    apply `scr_Player_Key_Right`. Click on **OK**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**控制**中拖动一个执行脚本图标到**操作：**区域，并应用`scr_Player_Key_Right`。点击**确定**。
- en: We now have our horizontal controls and need to add the vertical movement. We
    will go over the code for the up key and down key scripts, but by now you should
    be able to implement them into the object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了水平控制，并且需要添加垂直移动。我们将介绍上键和下键脚本的代码，但现在您应该能够将它们实现到对象中。
- en: 'For the up arrow key, create a new Script and name it `scr_Player_Key_Up`,
    and write the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于上箭头键，创建一个新的脚本，并将其命名为`scr_Player_Key_Up`，并编写以下代码：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is similar to the horizontal code except now we are looking at the `y` position
    and the height of the Sprite.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这与水平代码类似，只是现在我们要考虑`y`位置和精灵的高度。
- en: 'For the down arrow key, create a new Script and name it `scr_Player_Key_Down`,
    and write the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下箭头键，创建一个新的脚本，并将其命名为`scr_Player_Key_Down`，并编写以下代码：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, here we are looking at the height of the room minus the height of the
    sprite as being the furthest point we can move downwards. The movement controls
    are now complete and the Object properties should look like the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这里，我们要考虑的是房间的高度减去精灵的高度作为我们可以向下移动的最远点。移动控制现在已经完成，对象属性应该如下截屏所示：
- en: '![Controlling the player object](img/4100OT_03_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![控制玩家对象](img/4100OT_03_04.jpg)'
- en: Run the game.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: The player should be able to move around the entire screen, but never off of
    it. The only remaining control we have left is the button for firing the gun.
    However, before we can implement that we need a bullet!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该能够在整个屏幕上移动，但永远不会离开屏幕。我们剩下的唯一控制是开枪的按钮。然而，在实现这一点之前，我们需要一颗子弹！
- en: Building the bullet
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建子弹
- en: Bullets are easy to make, as they generally just move along in a straight line
    once they have been fired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 制作子弹很容易，因为它们通常一旦被发射就沿着直线移动。
- en: Create a new Sprite and name it `spr_Bullet_Player`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，并将其命名为`spr_Bullet_Player`。
- en: Click on **Load Sprite** and load `Chapter 3/Sprites /Bullet_Player.gif`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载精灵**，加载`Chapter 3/Sprites /Bullet_Player.gif`。
- en: 'As we currently have the origin of the player object set to the tip of the
    gun, we will want **Origin** of the bullet to be at the front. This will help
    make the bullet appear to come out of the gun without having to code it directly.
    Set the values to **X**: `17`, **Y**: `4`.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们当前将玩家对象的原点设置为枪口，我们希望子弹的**原点**在前面。这将有助于使子弹看起来是从枪口射出，而无需直接编码。将值设置为**X**：`17`，**Y**：`4`。
- en: We can leave everything else as it is, so click on **OK**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他所有内容保持不变，然后点击**确定**。
- en: Bullets should also make a sound when they are fired so let's bring in a sound.
    The first thing we need to do is to switch back to the Legacy Sound engine, so
    that we ensure the audio is heard in all browsers. Navigate to **Resources** |
    **Change Global Game Settings** and under the **General** tab, uncheck the box
    for **Use New Audio Engine**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子弹发射时也应该发出声音，所以让我们加入一个声音。我们需要切换回传统声音引擎，以确保在所有浏览器中都能听到音频。导航到**资源** | **更改全局游戏设置**，在**常规**选项卡下，取消**使用新音频引擎**的复选框。
- en: Create a new Sound and name it `snd_Bullet_Player`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的声音，并将其命名为`snd_Bullet_Player`。
- en: Click on **Load Sound** and load `Chapter 3/Sounds/Bullet_Player.wav`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**加载声音**，加载`Chapter 3/Sounds/Bullet_Player.wav`。
- en: Make sure **Kind** is set to **Normal Sound**. Then click on **OK**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**类型**设置为**普通声音**。然后点击**确定**。
- en: Now it is time to make the bullet move on its own. Create a new Script and name
    it `scr_Bullet_Player_Create`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候让子弹自行移动了。创建一个新的脚本，并将其命名为`scr_Bullet_Player_Create`。
- en: 'We want the bullet to move horizontally to the right. This is easy to do with
    the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹向右水平移动。使用以下代码很容易实现：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Hspeed** is a property representing the horizontal velocity of an object
    in GameMaker: Studio. We need to apply this code the moment the bullet is instantiated
    in the world. We also play the sound of the bullet a single time.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hspeed**是GameMaker: Studio中表示对象水平速度的属性。我们需要在子弹实例化到世界中的那一刻应用这段代码。我们还会播放子弹的声音一次。'
- en: Create a new Object and name it `obj_Bullet_Player`, and set the Sprite to `spr_Bullet_Player`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Bullet_Player`，并将精灵设置为`spr_Bullet_Player`。
- en: Add a **Create** event. The **Create** event is only ever executed once, upon
    creation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**Create**事件。**Create**事件只在创建时执行一次。
- en: Apply the `scr_Bullet_Player_Create` and click on **OK**.![Building the bullet](img/4100OT_03_05.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`scr_Bullet_Player_Create`并点击**OK**。![构建子弹](img/4100OT_03_05.jpg)
- en: As shown in the preceding screenshot, the bullet is now complete and ready to
    be fired. Let's go back to the spaceship!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，子弹现在已经完成，准备好发射。让我们回到太空船！
- en: Firing the bullet
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射子弹
- en: A bullet is only dangerous to enemies if it has been fired. The player ship
    will handle this code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹只有在被发射后才对敌人构成威胁。玩家飞船将处理这段代码。
- en: Create a new Script and name it `scr_Player_KeyPress_Space`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_Player_KeyPress_Space`。
- en: 'Write the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this code, we are simply creating an instance of a bullet where the current
    position of the player ship is, or more specifically, where the origin of the
    player ship Sprite is. This will make the bullet appear to be shot from the ship's
    gun.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们只是在玩家飞船当前位置，或者更具体地说，玩家飞船精灵的原点处创建一个子弹实例。这将使子弹看起来是从飞船的枪中射出的。
- en: In `obj_Player`, add a **Space** event from **Key Press** and apply `scr_Player_KeyPress_Space`.
    The **Key Press** event checks if the indicated key has been pushed down. This
    will run once and requires the key to be released before being able to run again.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Player`中，添加一个**Space**事件从**Key Press**并应用`scr_Player_KeyPress_Space`。**Key
    Press**事件检查指定的键是否被按下。这将运行一次，并需要释放键才能再次运行。
- en: Run the game.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is working properly, we should be able to move around the screen
    and fire bullets as fast as we can hit the spacebar, as shown in the following
    screenshot. We are almost ready to start adding in gameplay, but before we do,
    we have a little bit of cleanup to do.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们应该能够在屏幕上四处移动并尽可能快地射击子弹，如下图所示。我们几乎可以开始添加游戏玩法了，但在这之前，我们还有一点清理工作要做。
- en: '![Firing the bullet](img/4100OT_03_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![发射子弹](img/4100OT_03_06.jpg)'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If everything appears to be correct, but you are still unable to see the intended
    result, try refreshing your browser. Occasionally, browsers will keep the game
    in memory and won't load the updated version immediately.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切看起来正确，但仍然无法看到预期的结果，请尝试刷新您的浏览器。偶尔，浏览器会将游戏保存在内存中，并不会立即加载更新的版本。
- en: Removing bullets from the world
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从世界中移除子弹
- en: Every time we create an instance of an object, it needs to be placed into the
    memory and the computer will need to keep a track of it. We have all these bullets
    that are going offscreen never to be seen again, but the computer sees them. This
    means that over time the computer could be trying to watch millions of wasted
    bullets, which in turn means that the game will start to slow down. As we don't
    want that to happen, we need to get rid of all these offscreen bullets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个对象实例，都需要将其放入内存，并且计算机需要跟踪它。我们有所有这些子弹离开屏幕再也看不到了，但计算机看到了。这意味着随着时间的推移，计算机可能会试图观察数百万个浪费的子弹，这反过来意味着游戏会开始变慢。由于我们不希望发生这种情况，我们需要摆脱所有这些离开屏幕的子弹。
- en: Create a new Script and name it `scr_OffScreenRemoval`. This Script can be applied
    to any object in the game that goes offscreen and that we want to get rid of.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`scr_OffScreenRemoval`。这个脚本可以应用于游戏中任何离开屏幕并且我们想要摆脱的对象。
- en: 'To remove an instance from the world, write the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从世界中移除一个实例，写下以下代码：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `obj_Bullet_Player`, add an **Outside Room** event from **Other** and apply
    the script. The **Outside Room** event is a special event that checks if the entire
    sprite of an instanced object is completely outside the room.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_Player`中，添加一个**Outside Room**事件从**Other**并应用脚本。**Outside Room**事件是一个特殊事件，检查实例化对象的整个精灵是否完全在房间外。
- en: There we go! We now have a spaceship that moves around the screen, shoots bullets,
    and we keep the memory usage low. Let's make some enemies!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在我们有一个在屏幕上移动、射击子弹并且内存使用率低的太空船。让我们制作一些敌人！
- en: Constructing three little enemies
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建三个小敌人
- en: 'In this game we are going to have three unique types of enemies for the player
    to fight against: the FloatBot, the SpaceMine, and the Strafer. Each of these
    enemies will move differently and have a distinct attack. However, there are some
    common elements that they share, such as they will all have collision with bullets
    and the player, but not with each other.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将有三种独特类型的敌人供玩家对抗：FloatBot，SpaceMine和Strafer。这些敌人每个都会以不同的方式移动并具有独特的攻击。然而，它们也有一些共同的元素，比如它们都会与子弹和玩家发生碰撞，但彼此之间不会发生碰撞。
- en: It is always useful to think about the commonalities of the various objects
    as there may be ways to simplify and reduce the amount of work needed. In this
    case, as we are dealing with collision, we can use a **parent** object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑各种对象的共同点总是有用的，因为可能有简化和减少所需工作量的方法。在这种情况下，由于我们正在处理碰撞，我们可以使用一个**父**对象。
- en: Making the enemy parent
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作敌人父对象
- en: 'Parenting object is an incredibly useful ability in GameMaker: Studio. It allows
    for one object, the **parent**, to pass its attributes down to other objects called
    **child** objects in what is generally known as **inheritance** . The best way
    to think of this relationship is that parents are a group and children are individuals.
    This means we can tell a group to do something and every individual will do it.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '父对象是GameMaker: Studio中非常有用的功能。它允许一个对象，**父对象**，将其属性传递给其他对象，称为**子对象**，通常被称为**继承**。最好的理解这种关系的方式是，父对象是一个群体，子对象是个体。这意味着我们可以告诉一个群体做某事，每个个体都会去做。'
- en: We will create a parent object and use it for all the common collision events.
    This way we don't have to apply a new collision event for each different enemy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个父对象，并将其用于所有常见的碰撞事件。这样我们就不必为每个不同的敌人应用新的碰撞事件。
- en: Create a new Object and name it `obj_Enemy_Parent`. We do not need a Sprite
    for this Object, as it will never be seen in the game.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Enemy_Parent`。我们不需要为这个对象添加精灵，因为它在游戏中永远不会被看到。
- en: Create a new Script and name it `scr_Enemy_Collision_Player`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，命名为`scr_Enemy_Collision_Player`。
- en: 'Write the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are using a `with` statement which allows us to apply code to another
    object. In this case, we are also able to use a special variable called `other`
    which is only available in collision events. This is because there are always
    two instances involved and only one collision between the two. Whoever has the
    code is identified as `self` and then there is the other. When there is a collision
    between `obj_Enemy_Parent` or any child of it with `obj_Player`, we will remove
    the player, and then remove the instance it collided with.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个`with`语句，它允许我们对另一个对象应用代码。在这种情况下，我们还可以使用一个特殊的变量叫做`other`，它只在碰撞事件中可用。这是因为总是涉及两个实例，两者之间只有一个碰撞。谁拥有代码被标识为`self`，然后是另一个。当`obj_Enemy_Parent`或其任何子对象与`obj_Player`发生碰撞时，我们将移除玩家，然后移除它碰撞的实例。
- en: In `obj_Enemy_Parent`, add an `obj_Player` event from **Collision** and apply
    this collision script.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**碰撞**中添加一个`obj_Player`事件，并应用此碰撞脚本。
- en: Player collision now works, but currently nothing happens when bullets collide.
    We could use the same script if all the instances were going to be removed. In
    this case, we want to do something different if an enemy is hit by the player
    bullet. We want to award points.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家碰撞现在可以工作了，但是当子弹碰撞时目前什么也不会发生。如果所有实例都将被移除，我们可以使用相同的脚本。在这种情况下，如果敌人被玩家子弹击中，我们希望做一些不同的事情。我们想要奖励分数。
- en: Rather than creating a new script, let's just duplicate the collision Script
    we just created. In the Resource tree, hold right-click on `scr_Enemy_Collision_Player`
    and select **Duplicate**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其创建一个新脚本，不如直接复制我们刚刚创建的碰撞脚本。在资源树中，右键单击`scr_Enemy_Collision_Player`，然后选择**复制**。
- en: 'Name this script `scr_Enemy_Collision_Bullet`, and add the following line of
    code at the top of the script:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此脚本命名为`scr_Enemy_Collision_Bullet`，并在脚本顶部添加以下代码行：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will add 20 points to the total score of the game. Just to make sure everything
    is set up correctly, the entire code for this script should look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为游戏的总分数增加20分。为了确保一切设置正确，此脚本的整个代码应该如下所示：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Back in `obj_Enemy_Parent`, add an `obj_Bullet` event from **Collision** and
    apply `scr_Enemy_Collision_Bullet`. Enemies will now be destroyed and points will
    be awarded when they collide with bullets!
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**碰撞**中添加一个`obj_Bullet`事件，并应用`scr_Enemy_Collision_Bullet`。当敌人与子弹碰撞时，敌人现在将被摧毁并奖励分数！
- en: The final event we need the parent object to watch over is to remove enemies
    if they go offscreen. We can't use the same script as our bullet cleanup script,
    because we will be spawning enemies offscreen to the right. Therefore, we need
    to make sure they are only removed when they go off the left-hand side.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要父对象监视的最后一个事件是，如果敌人离开屏幕，将其移除。我们不能使用与我们的子弹清理脚本相同的脚本，因为我们将在屏幕右侧生成敌人。因此，我们需要确保它们只在离开左侧时被移除。
- en: Create a new Script and name it `scr_Enemy_Removal`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，命名为`scr_Enemy_Removal`。
- en: 'Write the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we check to see if the `x` position of the instance is less than `0`,
    or offscreen to the left. If it is, we remove it from the game.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查实例的`x`位置是否小于`0`，或者在屏幕左侧。如果是，我们将其从游戏中移除。
- en: In `obj_Enemy_Parent`, add an **Outside Room** event from **Other** and apply
    this script. We are done with the parent object and it should look like the following
    screenshot:![Making the enemy parent](img/4100OT_03_07.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Enemy_Parent`中，从**其他**中添加一个**外部房间**事件，并应用此脚本。我们已经完成了父对象，它应该看起来像下面的截图：![制作敌人父对象](img/4100OT_03_07.jpg)
- en: We now have a parent object that will deal with the bullet collision and remove
    the enemies when they go offscreen. Let's test it out by making some children.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个父对象，它将处理子弹碰撞并在敌人离开屏幕时移除它们。让我们通过创建一些子对象来测试它。
- en: Building the FloatBot
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建FloatBot
- en: The FloatBot is the most basic enemy in the game. It will not fire a weapon,
    which makes it more of an obstacle to be avoided. The FloatBot will move across
    the screen to the left, bobbing up and down as it goes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: FloatBot是游戏中最基本的敌人。它不会发射武器，这使它更像是要避开的障碍物。FloatBot将横穿屏幕向左移动，同时上下浮动。
- en: Create a new Sprite and name it `spr_FloatBot`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，命名为`spr_FloatBot`。
- en: Load the Sprite `Chapter 3/Sprites/FloatBot.gif` with **Remove Background**
    checked.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载精灵`Chapter 3/Sprites/FloatBot.gif`，勾选**删除背景**。
- en: This is an animated Sprite whose shape changes on each frame. Therefore, we
    want to make sure the collision changes accordingly. In **Collision Checking**,
    check the box for **Precise Collision Checking**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个动画精灵，每一帧形状都会改变。因此，我们希望确保碰撞相应地改变。在**碰撞检查**中，勾选**精确碰撞检查**。
- en: 'We want the origin to be in the center of this Sprite, so that it moves correctly
    when we add the bobbing motion. Set **Origin** to **X**: `16`, **Y**: `16`. Click
    on **OK**.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将原点设置在此精灵的中心，这样当我们添加摆动运动时，它就会正确移动。将**原点**设置为**X**:`16`，**Y**:`16`。然后单击**确定**。
- en: We need two scripts to make the FloatBot fly the way we intend. On creation
    we will apply the horizontal movement, and then at every step after that we will
    adjust the vertical bobbing motion.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个脚本来使FloatBot以我们想要的方式飞行。在创建时，我们将应用水平移动，然后在每一步之后我们将调整垂直摆动运动。
- en: Create a new Script and name it `scr_FloatBot_Create`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_FloatBot_Create`。
- en: 'Write the following code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The negative value of the horizontal speed means that it will move to the left.
    `angle` is a variable we will be using in the next script for the bobbing motion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 水平速度的负值意味着它将向左移动。`angle`是我们将在下一个脚本中使用的变量，用于摆动运动。
- en: Create a new Script and name it `scr_FloatBot_Step`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_FloatBot_Step`。
- en: 'To get the vertical motion we desire, we are going to use some simple trigonometry.
    Write the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获得我们想要的垂直运动，我们将使用一些简单的三角学。编写以下代码：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we are changing the vertical speed based on the sine value of the variable
    angle in radians, multiplied by a base speed of `8`. We also increase the value
    of `angle` every step, which is necessary to have it follow the sine wave.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据变量角的正弦值（以弧度为单位）乘以基本速度`8`来改变垂直速度。我们还每一步增加`angle`的值，这是必要的，以便它遵循正弦波。
- en: Create a new Object, name it `obj_FloatBot`, and set `spr_FloatBot` as the Sprite.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_FloatBot`，并将`spr_FloatBot`设置为精灵。
- en: We want to make this object a child, so in the **Parent** drop-down box, select
    `obj_Enemy Parent`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将此对象设置为子对象，因此在**父对象**下拉框中，选择`obj_Enemy Parent`。
- en: Add a **Create** event and apply the `scr_FloatBot_Create` script.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**创建**事件并应用`scr_FloatBot_Create`脚本。
- en: Add a **Step** event and apply the `scr_FloatBot_Step` script. The FloatBot
    is now ready for testing and should look like the following screenshot:![Building
    the FloatBot](img/4100OT_03_08.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**步骤**事件并应用`scr_FloatBot_Step`脚本。FloatBot现在已经准备好测试，应该看起来像下面的截图：![构建FloatBot](img/4100OT_03_08.jpg)
- en: Reopen the room `TheGame` and place an instance of `obj_FloatBot` somewhere
    on the right-hand side of the screen.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开房间`TheGame`，并在屏幕右侧的某个地方放置一个`obj_FloatBot`的实例。
- en: Run the game.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。
- en: If everything is working correctly the FloatBot should move across the screen
    to the left and have a bob up and down around 240 pixels in height in a similar
    pattern as shown in the next screenshot. If we hit the FloatBot with a bullet,
    both the bullet and the FloatBot will disappear. We have also successfully created
    a parent-child relationship. Let's create another!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，FloatBot应该沿着屏幕向左移动，并在大约240像素的高度上上下摆动，模式与下一个截图中显示的类似。如果我们用子弹击中FloatBot，子弹和FloatBot都将消失。我们还成功创建了父子关系。让我们再创建一个！
- en: '![Building the FloatBot](img/4100OT_03_09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![构建FloatBot](img/4100OT_03_09.jpg)'
- en: Creating the SpaceMine
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SpaceMine
- en: The SpaceMine is going to be a slow moving object that will shoot a ring of
    bullets if the player gets too close. As this is going to require two objects,
    we should always start with the simplest one, the bullet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: SpaceMine将是一个缓慢移动的对象，如果玩家靠近，它将发射一圈子弹。由于这将需要两个对象，我们应该始终从最简单的对象开始，即子弹。
- en: Create a new Sprite and name it `spr_Bullet_SpaceMine`. Load `Chapter 3/Sprites/Bullet_SpaceMine.gif`
    with **Remove Background** checked.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新精灵，命名为`spr_Bullet_SpaceMine`。加载`Chapter 3/Sprites/Bullet_SpaceMine.gif`，勾选**删除背景**。
- en: Center the origin. We don't need to change **Collision Checking**, as a square
    will work fine for this object.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中。我们不需要改变**碰撞检查**，因为正方形对于这个对象来说效果很好。
- en: Create a new Object, name it `obj_Bullet_SpaceMine`, and set the Sprite to `spr_Bullet_SpaceMine`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新对象，命名为`obj_Bullet_SpaceMine`，并将精灵设置为`spr_Bullet_SpaceMine`。
- en: Create a new Script and name it `scr_Bullet_SpaceMine_Create`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_Bullet_SpaceMine_Create`。
- en: 'This time we want to use the instance properties of `speed` and `direction`,
    as we will require the direction to be set later. Write the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们希望使用`speed`和`direction`的实例属性，因为我们稍后需要设置方向。编写以下代码：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `obj_Bullet_SpaceMine`, add a **Create** event and apply this script.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_SpaceMine`中，添加一个**创建**事件并应用此脚本。
- en: We need to add collision to the bullet and to do this quickly, we can reuse
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with the bullet for now, as can be seen in the
    following screenshot:![Creating the SpaceMine](img/4100OT_03_10.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为子弹添加碰撞，为了快速完成这个过程，我们可以重用`scr_Enemy_Collision_Player`脚本。从**碰撞**中添加一个`obj_Player`事件并应用脚本。目前我们已经完成了子弹，如下截图所示：![创建SpaceMine](img/4100OT_03_10.jpg)
- en: Time to build the SpaceMine itself. Create a new Sprite, name it `spr_SpaceMine`,
    and load `Chapter 3/Sprites/SpaceMine.gif` with **Remove Background** checked.
    As you can see, the SpaceMine has animated blinking lights.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候建立SpaceMine本身了。创建一个新精灵，命名为`spr_SpaceMine`，并加载`Chapter 3/Sprites/SpaceMine.gif`，勾选**删除背景**。正如你所看到的，SpaceMine有动画闪烁的灯光。
- en: Center the origin and check **Precise Collision Checking**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原点居中并检查**精确碰撞检查**。
- en: We want a shooting sound when the SpaceMine fires, so create a new Sound, `snd_Bullet_SpaceMine`
    and load `Chapter 3/Sounds/Bullet_SpaceMine.wav`. We won't be attaching this to
    the bullets themselves as we will be creating eight bullets, but we only need
    the sound to be played once.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当SpaceMine发射时，我们希望有射击声音，因此创建一个新声音，`snd_Bullet_SpaceMine`，并加载`Chapter 3/Sounds/Bullet_SpaceMine.wav`。我们不会将其附加到子弹本身，因为我们将创建八颗子弹，但我们只需要播放一次声音。
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**. Create
    a new Object and name it `obj_SpaceMine`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未设置，将**类型**设置为**普通声音**，然后单击**确定**。创建一个新对象，命名为`obj_SpaceMine`。
- en: Set **Sprite** to `spr_SpaceMine` and **Parent** to `obj_Enemy_Parent`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵**设置为`spr_SpaceMine`，**父对象**设置为`obj_Enemy_Parent`。
- en: Create a new Script and name it `scr_SpaceMine_Create`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新脚本，并将其命名为`scr_SpaceMine_Create`。
- en: We need the SpaceMine to do a few things. It is going to fire bullets, so we
    will need a variable to control when it shoots. It needs to move across the screen,
    so we need to apply velocity. Finally, we will want to slow down the animation
    so that it doesn't blink too fast.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we are setting the horizontal speed to move slowly to the left. `canFire`
    is a Boolean variable that will determine if it is to shoot or not. Finally, `image_speed`
    sets the speed of the animation. At a speed of `0.2`, it animates at 20 percent
    of normal, or in other words, each frame of animation will be held for five steps.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_SpaceMine`, add a **Create** event and apply this script.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another new script and name it `scr_SpaceMine_Step`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each step we will want to see whether the player is within proximity of the
    SpaceMine. If the player is too close, the SpaceMine will start firing rings of
    bullets. We don't want a stream of bullets, so we are going to need to add a delay
    between each firing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by checking two statements; the distance between the SpaceMine and
    `obj_Player`, and whether we are able to shoot. The distance we have chosen is
    `200` pixels, which should be enough space for the player to avoid triggering
    it occasionally. If the player is in range and we can shoot, we set `alarm` for
    `60` steps (2 seconds) and play the bullet sound once.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alarm is an event that, when triggered, will execute code a single time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To create the ring of bullets we will use a `for` loop. When we create an instance
    of an object it returns the unique ID of that instance. We need to capture this
    in a variable, so that we can talk to the object and affect it. Here we are using
    a variable called `bullet` which is an instance of `obj_Bullet_SpaceMine`. We
    can then change the properties of the bullet such as direction. In this case,
    each bullet will be offset by 45 degrees. We also apply some additional `hspeed`
    to the bullets, so that they move along with the SpaceMine. Finally, we set the
    `canFire` variable to `true` to indicate that we have fired our bullets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_SpaceMine`, add a **Step** event and apply this script.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are almost done with the SpaceMine, we just need to add some code to an alarm
    that we can trigger, so that it can shoot more than once. Create a new Script
    and name it `scr_SpaceMine_Alarm0`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `canFire` variable back to `false`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `obj_SpaceMine`, add an **Alarm 0** event and apply this script. We are now
    done with the SpaceMine and it should look like the following screenshot:![Creating
    the SpaceMine](img/4100OT_03_11.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `TheGame`, add an instance of `obj_SpaceMine` on the right-hand side of
    the screen, and then run the game.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything is set up properly, the SpaceMine will slowly move across the
    screen to the left and blink. When the player approaches the SpaceMine, eight
    bullets should blast out from it as seen in the next screenshot. Every two seconds,
    another ring will be fired from this instance, so long as the player is still
    within range. If the SpaceMine is hit by one of the player bullets, it will be
    destroyed. Finally, if the player collides with the enemy's bullet the player
    disappears. Let's move on to our final enemy!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the SpaceMine](img/4100OT_03_12.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Making the Strafer
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Strafer is the most dangerous enemy in the game. It moves very quickly in
    a straight line and will target the player no matter where they are. Once again,
    there are two objects needed, so let's start with the bullet.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite and name it `spr_Bullet_Strafer`. Load `Chapter 3/Sprites/Bullet_Strafer.gif`
    with **Remove Background** checked.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center the origin.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Bullet_Strafer` and set the Sprite to `spr_Bullet_Strafer`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a unique shooting sound, so create a new Sound, `snd_Bullet_Strafer`,
    and load `Chapter 3/Sounds/Bullet_Strafer.wav`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未将**种类**设置为**普通声音**，请点击**确定**。
- en: Create a new Script and name it `scr_Bullet_Strafer_Create`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Bullet_Strafer_Create`。
- en: 'This script will be similar to `scr_Bullet_SpaceMine_Create`, except that this
    bullet is faster and playing the bullet sound. Write the following code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本与`scr_Bullet_SpaceMine_Create`类似，只是这颗子弹速度更快，并播放子弹声音。编写以下代码：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `obj_Bullet_Strafer`, add a **Create** event and apply this script.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Bullet_Strafer`中，添加一个**创建**事件，并应用此脚本。
- en: As with the other enemy bullet, let's add collision to the bullet by reusing
    the `scr_Enemy_Collision_Player` script. Add an `obj_Player` event from **Collision**
    and apply the script. We are done with this bullet, so let's build the enemy.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他敌人子弹一样，让我们通过重用`scr_Enemy_Collision_Player`脚本为子弹添加碰撞。从**碰撞**中添加一个`obj_Player`事件，并应用该脚本。子弹部分完成后，让我们构建敌人。
- en: Create a new Sprite and name it `spr_Strafer`, and load `Chapter 3/Sprites/Strafer.gif`
    with **Remove Background** checked.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的精灵，并将其命名为`spr_Strafer`，并加载`Chapter 3/Sprites/Strafer.gif`，勾选**删除背景**。
- en: 'We want the bullet to come from the front of the ship, so we need to manually
    move the origin to the proper location. Set **Origin** to **X**: `0`, **Y**: `19`.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望子弹从飞船的前方发射，因此我们需要手动将原点移动到正确的位置。将**原点**设置为**X**：`0`，**Y**：`19`。
- en: Create a new Object and name it `obj_Strafer`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的对象，并将其命名为`obj_Strafer`。
- en: Set **Sprite** to `spr_Strafer` and **Parent** to `obj_Enemy_Parent`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵**设置为`spr_Strafer`，**父对象**设置为`obj_Enemy_Parent`。
- en: Create a new Script and name it `scr_Strafer_Create`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`scr_Strafer_Create`。
- en: 'The Strafer is going to move quickly across the screen and fire bullets at
    the player constantly. Write the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Strafer将快速在屏幕上移动并不断向玩家发射子弹。编写以下代码：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Much like the SpaceMine, we have set `hspeed` to move left, and are also setting
    an alarm so that the Strafer will start shooting immediately.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与SpaceMine类似，我们将`hspeed`设置为向左移动，并设置一个警报，以便Strafer立即开始射击。
- en: In `obj_Strafer`, add a **Create** event and apply this script.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Strafer`中，添加一个**创建**事件，并应用此脚本。
- en: We only need one more script and that is for the alarm. Create a new Script
    and name it `scr_Strafer_Alarm0`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要再创建一个脚本，那就是用于警报的脚本。创建一个新的脚本，并将其命名为`scr_Strafer_Alarm0`。
- en: 'When the alarm goes off, we need to create a bullet, launch it at the player,
    and then reset the alarm so that it can fire again. To do this write the following
    code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当警报响起时，我们需要创建一个子弹，将其发射到玩家，并重置警报，以便它可以再次发射。编写以下代码：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start here by creating an instance of `obj_Bullet_Strafer`. When an instance
    is created, the function returns the unique ID of that instance; we then capture
    it in a variable, such as `bullet`. Next, we query whether the player exists or
    not. This is a very important step, as without this check if the player is dead
    and the Strafer tries to target it, the game will error out and crash.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`obj_Bullet_Strafer`的一个实例。当创建一个实例时，该函数会返回该实例的唯一ID；然后我们将其捕获在一个变量中，比如`bullet`。接下来，我们查询玩家是否存在。这是一个非常重要的步骤，因为如果没有这个检查，如果玩家死亡并且Strafer试图瞄准它，游戏将出错并崩溃。
- en: If the player does exist, we set the bullet direction at the player. This is
    done through the `point_direction` function that takes any two points in space
    (x1, y1) and (x2, y2) and returns the angle in degrees.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家存在，我们将设置子弹的方向指向玩家。这是通过`point_direction`函数完成的，该函数接受空间中的任意两点（x1，y1）和（x2，y2），并返回角度（以度为单位）。
- en: Finally, we reset the alarm. In this case, to make things more interesting we
    have added a bit of randomness to it. The `irandom` function will return a whole
    number between zero and the number you pass to it. The code we have here will
    give us a random value between `0` and `30` and we will add `15` to it. This means
    a new bullet will be created between every half second to a second and a half.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重置警报。在这种情况下，为了增加趣味性，我们添加了一些随机性。`irandom`函数将返回一个介于零和传递给它的数字之间的整数。我们这里的代码将给我们一个介于`0`和`30`之间的随机值，然后我们将其加上`15`。这意味着每隔半秒到一秒半之间将创建一个新的子弹。
- en: In `obj_Strafer`, add an **Alarm 0** event and apply this script.![Making the
    Strafer](img/4100OT_03_13.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`obj_Strafer`中，添加一个**Alarm 0**事件，并应用此脚本。![制作Strafer](img/4100OT_03_13.jpg)
- en: The Strafer is now complete, so let's test it out and place one in `TheGame`
    on the left-hand side.![Making the Strafer](img/4100OT_03_14.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Strafer现在已经完成，让我们测试一下，并将其放置在`TheGame`的左侧。![制作Strafer](img/4100OT_03_14.jpg)
- en: If everything is working correctly, the Strafer will quickly move across the
    screen and fire bullets directly at the position of the player. Make sure you
    move the player around the room to make sure it fires in all directions! The player
    should be able to shoot and destroy the Strafer. If hit by the Strafer's bullet,
    the player should disappear.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，Strafer将快速横穿屏幕，并直接朝向玩家位置发射子弹。确保您将玩家移动到房间的各个方向，以确保它可以朝各个方向射击！玩家应该能够射击并摧毁Strafer。如果被Strafer的子弹击中，玩家应该消失。
- en: The enemies for the game are all complete; now we just need a way to populate
    the game world. Let's bring in an Overlord!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的敌人都已经完成；现在我们只需要一种方法来填充游戏世界。让我们引入一个Overlord！
- en: Controlling the game with the Overlord
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Overlord控制游戏
- en: In this game, we will be using the Overlord, the master controller of the game,
    to control the spawning of enemies, monitor the player's lives, and deal with
    the win/lose condition. The win condition will simply be to survive for two minutes
    against waves of enemies. The lose condition will be that the player runs out
    of lives.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们将使用Overlord，游戏的主控制器，来控制敌人的生成，监视玩家的生命，并处理胜利/失败条件。胜利条件很简单，就是在两分钟内生存下来，抵御敌人的波浪。失败条件是玩家耗尽生命。
- en: Spawning waves of enemies
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人的波浪
- en: We need to start by creating the wave of enemies, so that the game is playable.
    For this, we will utilize a looping timeline to spawn the various enemies. We
    are going to have three different waves, each one spawning a different enemy every
    two seconds.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Create three new scripts, and name them: `scr_Wave_Strafer`, `scr_Wave_SpaceMine`,
    and `scr_Wave_FloatBot`.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start with the wave of Strafer, as it will be the simplest wave. Write
    the following code in `scr_Wave_Strafer`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we spawn two instances of the Strafer located `64` pixels off the right-hand
    side of the screen. This will ensure that we don't see them pop into existence.
    We have also offset them by `64` pixels from the vertical center of the room.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'For the SpaceMine, we will want them vertically placed in random positions
    to keep things interesting. Write the following code in `scr_Wave_SpaceMine`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are creating a variable called `placeY` to hold a value for the vertical
    position. GameMaker: Studio has a special function, `irandom_range`, which will
    return a whole number between any two numbers passed to it. The numbers we used
    will ensure that the SpaceMine will remain at least 64 pixels away from the top
    and bottom of the screen. We then use the `placeY` variable when we create the
    instance.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The FloatBot is going to use a similar setup for placement on the vertical
    axis, but we will want three instances flying in a "V" formation. Write the following
    code in `scr_Wave_FloatBot`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we are using the `placeY` variable again, but the range of numbers is narrower.
    We need some extra padding, so that all three planes stay onscreen. The first
    instance created is the front unit of the formation. The next two instances spawn
    32 pixels behind and offset 32 pixels above and below the first.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: All the waves are scripted, so we can now implement them in a Time Line. When
    first implementing a Time Line, it is useful to keep the numbers simple, such
    as two seconds apart. Properly balancing the timing comes during the polish phase
    of a game's development, and spending too much time trying to get this right before
    all content is in is most likely wasted time. Create a new Time Line and name
    it `tm_Wave_Spawning`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Add**, set **Indicate the Moment** as `60`, and apply the `scr_Wave_FloatBot`
    script. This will spawn the first enemy into the game for two seconds.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to add the SpaceMines two seconds later. Click on **Add**, set
    **Indicate the Moment** as `120`, and apply the `scr_Wave_SpaceMine` script.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we bring in the Strafer after six seconds. Click on **Add**, set **Indicate
    the Moment** as `180`, and apply the `scr_Wave_Strafer` script. The Time Line
    is now ready to be used and should look like the following screenshot:![Spawning
    waves of enemies](img/4100OT_03_15.jpg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the Overlord
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to start building the Overlord and apply our spawning system.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Object and name it `obj_Overlord`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no Sprite needed, so set **Sprite** to **no sprite**.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start the Time Line immediately upon creation of the Overlord. Create
    a new Script, name it `scr_Overlord_Create`, and write the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first line of code defines what Time Line we want to run, in our case we
    only have one: `tm_Wave_Spawning`. Next, we start the Time Line and then tell
    it to loop. These last two are Boolean variables, which means that they can only
    be turned on and off.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the Overlord, add a **Create** event and apply this script.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **TheGame** and place a single instance of the Overlord anywhere in the
    room. The location does not matter, but the upper-left corner is a common place
    to put it.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any instances of the enemies that remain in the room. There should be
    only one instance of the Player and one of the Overlord as can be seen in the
    following screenshot:![Building the Overlord](img/4100OT_03_16.jpg)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game.![Building the Overlord](img/4100OT_03_17.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The game now has enemies! It will take a couple of seconds for the first enemy,
    the FloatBots, to appear, but after that the enemies will continue to spawn forever.
    At this point we have most of the core gameplay implemented as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We can move the player around the screen, but not out of it
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can shoot and destroy enemies
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies can shoot and destroy the player
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemies will spawn continuously
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only element remaining is very obvious when playing the game at this stage;
    the player can die, but the game doesn't stop. We need to implement the win/lose
    condition.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the life and death of the player
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this is a game about survival, we will want the win/lose condition to be
    fairly simple. For the win condition, we will make the player survive for a set
    amount of time. The lose condition will be the player dying, but we don't want
    to come across as too hard to play, so we will give the player three lives. This
    means that we are going to need to respawn the player. Finally, to get this to
    work properly, we will need to give the Overlord some more duties.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the win condition
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The win condition for this game is to survive for a set amount of time. We can
    achieve this through the use of an alarm and a variable to signal to the Overlord
    that the player has survived.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to set up some variables for the lives, win, and lose conditions.
    Reopen `scr_Overlord_Create` and add the following code at the bottom:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'GameMaker: Studio has a few built-in global variables including `lives`. This
    variable is accessible by every instance in the game and never goes away. Here
    we have set it to `3` and will use that as our starting point. We also create
    two other variables, `isVictory` and `isDefeat`, which we have set to `false`.
    The reason we are using two variables to represent winning and losing the game
    instead of one is that we will want to check these during gameplay when they have
    neither won nor lost.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set our win condition in this script by setting an alarm for 90
    seconds. To do this add the following line of code after the code in step 1:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `scr_Overlord_Create` script should now look like the following in total:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we have to set up a script for the alarm event for the victory condition.
    Create a new Script, name it `scr_Overlord_Victory`, and write the following code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The very first thing we do is stop the Time Line, as we don't want any more
    enemies to spawn. The next step is to remove all enemies still alive in the game.
    We do this by using a `with` statement that is going to execute code to all instances
    of `obj_Enemy_Parent`. As all the enemies are children of this object, they too
    will be destroyed. We will eventually want to restart the game, so we set another
    alarm for three seconds. Finally, we set the `isVictory` variable to true.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Overlord`, add an **Alarm 0** event and apply the victory script.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s wrap this up by creating the restart script. Create a new Script, name
    it `scr_Overlord_GameRestart` and write this code:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add an **Alarm 1** event and apply this restart script. The win condition is
    now working, so feel free to try it out.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Respawning with a Ghost object
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now move on to the losing condition and respawning. When the player dies,
    we don't want to have the player respawn immediately, but instead have a smaller
    buffer of invulnerability. To do this, we will want to create a Ghost object that
    will temporarily stand in for the player.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, name it `spr_Ghost`, and load `Chapter 3/Sprites/Ghost.gif`
    with **Remove Background** checked. It looks just like the plane, but is slightly
    transparent and flickers when animated.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to set the origin to be exactly the same as the origin of `spr_Player`.
    Set **Origin** to **X**: `43`, **Y**: `22`, and then click on **OK**.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, name it `obj_Ghost`, and apply `spr_Ghost` as the Sprite.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the player dies, we are going to have the Ghost appear offscreen to the
    left and then move into the gameplay area. Create a new Script, name it `scr_Ghost_Create`,
    and write the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We start by setting the `x` coordinate to be offscreen by `64` pixels. We then
    center the Ghost vertically by setting the `y` coordinate to half of the room
    height. Finally, we are applying a positive velocity to the Ghost, so that it
    starts moving on its own.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Create** event to `obj_Ghost` and apply this script.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Ghost is going to move on the screen, and we will need to change it into
    the player at some point. In our case, we will make the switch once the Ghost
    has passed quarter way into the gameplay area. Create a new script, name it `scr_Ghost_Step`,
    and write the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here we check to see if the Ghost''s `x` coordinate has crossed `200` pixels
    or not. If it has, we stop the forward velocity and then we transform into the
    player. The `instance_change` function asks for two arguments: what object to
    transform into and whether we want to run the **Create** event of this new object.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Add a **Step** event to `obj_Ghost` and apply this script.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One issue we will encounter with this setup is that the player has no control
    of the Ghost, and could end up in a dangerous position near an enemy when they
    transform. We don't want that, so let's give the player some limited controls.
    We can reuse the existing `scr_Player_Key_Up` and `scr_Player_Key_Down` scripts,
    so that the player has vertical movement. Add the appropriate Keyboard events
    and attach these scripts.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Ghost Object's properties should look like the following screenshot and
    is now ready to become a part of the game. We just need to change what happens
    when the player is hit.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Respawning with a Ghost object](img/4100OT_03_18.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: Reopen `scr_Enemy_Collision_Player`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Currently, we are destroying both the bullet and the player. We need to change
    the `with` statement to allow for respawning. Remove line **3**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And replace it with:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We only want to become a Ghost if we have lives available, so we start by checking
    that. If we do have at least one life, we transform the Player into a Ghost. Otherwise,
    we just destroy the Player and the Player will be permanently dead. Finally, we
    subtract a life every time, whether we have lives or not. The final code should
    look like the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At this point we can play the game. Notice that when the player dies:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The player disappears
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Ghost is created and moves into the play area
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ghost can move up and down
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ghost turns back into the Player
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This of course happens three times and then the player disappears forever. The
    rest of the game, however, is continuing on as if nothing happened. We need to
    add in the defeat condition.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Overlord_Step`, and write the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Every step in this code will check to see if the player has any lives left.
    If the player has no lives left and the variable `isDefeat` is still `false`,
    it will set the *Restart Game* alarm for three seconds. Lastly, we set the `isDefeat`
    variable to `true`, so that we don't run this code again.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In `obj_Overlord`, add a **Step** event and apply this script. The game will
    now restart after the player dies three times.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The core mechanics of the game are now complete, but it's not very clear to
    the player as to what is going on. The player can die and respawn a few times,
    but there is no indication of how many lives are left. Nor is there any information
    being displayed on whether the player has won or lost the game. Let's fix this!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the user interface
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important elements in creating a great game is ensuring that
    the player has all the information they need to play the game. Much of this is
    usually presented in the **heads-up display**, otherwise known as the **HUD**.
    Every game has different components that can be a part of the HUD including things
    we need such as scoreboards and life counters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we are going to need a font for the text we intend to display.
    We have supplied a font called **Retroheavyfuture** for use in this game that
    will need to be installed on your computer. To install this font on a Windows
    7 computer, right-click on `Chapter 3/Fonts/RETRRG__.ttf` and click on **Install**.
    Then follow the directions when prompted.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back into GameMaker: Studio, create a new font and name it `fnt_Scoreboard`.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Retroheavyfuture** as **Font**.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Size** under **Style** to `16`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want a decent sized font to display the score and lives during the game.
    It should look like the following screenshot, so click on **OK**:![Drawing the
    user interface](img/4100OT_03_19.jpg)
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need a second version of the font when we display the win/lose condition.
    Create a new font and name it `fnt_WinLose`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, select **Retroheavyfuture** as **Font**, but this time set **Size**
    to `32`. We now have all the in-game fonts we need, so click on **OK**.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s move on to the new Script, `scr_Overlord_Draw`. We will start by setting
    the color and the font for the scoreboard text with this code:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The first line of code sets the color with one of GameMaker: Studio''s premade
    colors, `c_white`. The next line then sets the scoreboard as the font.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting colors are globally applied to the `draw` events. That means if you
    don't set a color, it will use the color last set, regardless of the object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'With the font set we can start applying the HUD. We will start with the player
    lives. Add this code to the script:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To ensure the text is properly formatted, we set the horizontal alignment of
    the text to be aligned left. The text itself needs to be a string, which can be
    done in two ways. First, anything in quotation marks is considered a string, such
    as `"Lives: "`. If we want to pass a number, such as the amount of lives we have,
    we need to convert it by passing through the string function. As seen here, if
    we have lives remaining we can concatenate the two things to create a single sentence
    *Lives: 3* and draw it in the upper-left corner of the screen. If we are out of
    life, we draw the text without the concatenated value.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'The other HUD element we want is the score, which we will place on the opposite
    side of the screen in the upper-right corner. Add the following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we did with the previous text, we are setting the horizontal alignment, this
    time to the right. We then place the text in the proper position using the same
    concatenation method for the score.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this out now by adding a **Draw GUI** event to `obj_Overlord` and
    apply this script.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. As seen in the next screenshot, the game should now display the
    lives in the upper-left corner and update each time the player dies. It should
    also display the score in the upper right-hand corner and increase with every
    enemy killed.![Drawing the user interface](img/4100OT_03_20.jpg)
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to add the display for when the player wins or loses. Add the following
    code at the end of `scr_Overlord_Draw`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We change the font to `fnt_WinLose` and set the horizontal alignment to be in
    the center. We don't want the text to be displayed all the time, instead we should
    only show either **VICTORY** or **DEFEAT** when it is appropriate. We have already
    implemented the code in the Overlord for the game condition, so we just check
    every step whether `isVictory` is `true` or `isDefeat` is `true`. As soon as the
    game is either won or lost, we draw the appropriate text in the center of the
    room.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `scr_Overlord_Draw` script should look like the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Adding the finishing details to the game
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The game is now functionally complete, but it doesn't have any polish or the
    finishing details we would expect of a full game. There is no music, no background
    art, and no explosions! Let's fix that right now.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Adding the game music
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want the music to start at the beginning and play for the duration of the
    game. When the win/lose condition occurs, we want the music to fade out to let
    the player know that the game is over.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sound and name it `snd_Music`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 3/Sounds/Music.mp3`. **Kind** should be set to **Background Music**.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reopen `scr_Overlord_Create`. Since the Overlord controls the overall game,
    we will use it to control the music as well. After the last line of code, add
    the following:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We start by playing the music and set it to loop. We then create a variable,
    `volume`, that we will use for controlling the sound level and the fade out. We
    have set the sound level to `1`, which is full volume. Finally, we set the global
    sound level, or master gain level, to the variable `volume`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `scr_Overlord_Step`. To fade the music out we will need to lower the
    global volume over several steps, but only if the game has ended. After the last
    line of code, add the following:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we check to see if either the win or lose condition has been set to `true`.
    If it has been, we decrease the volume variable by `0.02` and apply it to the
    master gain level. It will take 50 steps for the sound level to go from full volume
    to silent, which is about half the duration before the game restart kicks in.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Run the game. You should now hear the background music playing. If the player
    dies quickly three times and the defeat condition is triggered, you should hear
    the sound fade out.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making the background move
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This game takes place in outer space, so we will need to add in a space backdrop.
    In order for the game universe to feel as though the player is moving, we need
    to make the background shift constantly to the left.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Background and name it `bg_Starscape`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load `Chapter 3/Backgrounds/Starscape.gif` with **Remove Background** unchecked.
    This is all we need to do for this, so click on **OK**.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `TheGame` and select the **backgrounds** tab.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `bg_Starscape` as **background image**. It should happen automatically,
    but ensure that **Background 0** is highlighted and that **Visible when room starts**
    is checked.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The starscape is only going to move horizontally, therefore we only need **Tile
    Hor.** checked so that the image wraps around.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To move the background, set **Hor. Speed:** to `-2`. This will make it move
    to the left, which will make the player appear to move to the right. The settings
    should look like the following screenshot:![Making the background move](img/4100OT_03_21.jpg)
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should now see a moving starscape! Check out the following
    screenshot:![Making the background move](img/4100OT_03_22.jpg)
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the explosions
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having enemies just blink out of existence not only looks bad, it is not very
    rewarding to the player. Let's make this more exciting by adding in some explosions!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Sprite, `spr_Explosion`, and load `Chapter 3/Sprites/Explosion.gif`
    with **Remove Background** checked.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the origin to the center and click on **OK**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Sound, `snd_Explosion`, and load `Chapter 3/Sounds/Explosion.wav`.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Kind** to **Normal Sound** if it isn't already, and click on **OK**.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Explosion`, and set the sprite to `spr_Explosion`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the explosion to make a sound, play its animation, and then remove itself
    from the game.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Explosion_Create`, and write the following code to
    play the explosion sound a single time:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Add a **Create** event and apply this script.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get the explosion to remove itself is best done when the animation is finished.
    Luckily for us, GameMaker: Studio has an event for that. Add an **Animation End**
    event from **Other**, and then create a new Script to apply to it named `scr_Explosion_AnimEnd`
    with the following code to remove the instance:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The explosion is now prepared and all we have to do is spawn it when we destroy
    an enemy. Open `scr_Enemy_Collision_Bullet` and add the following line of code
    at the very top of the script on line **1**:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will create an explosion right where the enemy is located. This needs to
    happen before we remove the enemy from the game.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this code addition with `scr_Enemy_Collision_Player`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You should now see explosions whenever something is destroyed
    as shown in the following screenshot:![Creating the explosions](img/4100OT_03_23.jpg)
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! You have just finished creating your first side-scrolling
    shooter. We covered quite a lot in this chapter. We have applied all three methods
    of movement: manually adjusting the X and Y coordinates, using `hspeed` and `vspeed`,
    and setting the `speed` and `direction` variables. We are now able to add and
    remove instances from the game world dynamically. With the bullets, we learned
    to transfer information from one instance to another, such as the direction to
    move, by capturing the ID of the instance and accessing it through the dot operator.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: We discovered the wonderful `with` statement that gave us the ability to affect
    a single instance, all instances of an object, or even the `other` instance involved
    in a collision. We took a look at global variables, such as `lives` and `score`,
    and used the **Draw** event to display it. Waves of enemies were spawned using
    Time Lines. The illusion of movement was created by scrolling the background image.
    Sound was applied and the volume adjusted to create a fade out effect. We even
    used a bit of trigonometry!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: With the skills and knowledge developed in this chapter it is now your turn
    to take this game and extend it even further. Try adding your own enemies, collectible
    items, and weapon power-ups. Have some fun with it!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn more about collision and player controls
    by making a spooky adventure game. We will also take a look at artificial intelligence
    and using paths to make the enemies appear to think and act on their own.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
