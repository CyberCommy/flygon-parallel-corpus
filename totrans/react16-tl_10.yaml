- en: Building and Deploying Static React Sites with Gatsby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gatsby is a static website generation tool for React developers. In essence,
    this tool lets you build React components and captures their rendered output to
    use as the static site content. However, Gatsby takes static site generation to
    the next level. In particular, it provides mechanisms for sourcing your website
    data and transforming it into GraphQL that's more easily consumed by React components.
    Gatsby can handle anything from a single page brochure site to a site that spans
    hundreds of pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you''ll learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why you would want to build a static site using React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building simple Gatsby sites using starters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data from your local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using remote data from Hacker News
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why static React sites?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you get started with building static websites using Gatsby, let's set
    the context with a brief discussion on why you would want to do this. There are
    three key factors at play here —we'll go over each of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Types of React apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React has connotations with apps that are very interactive and with lively data
    that changes a lot. This might be true of some apps, perhaps even most apps, but
    there are still cases where the user is looking at static data—information that
    doesn't change or changes very infrequently.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a blog. The typical flow is for an author to publish some content and
    then that content is served to anyone who visits the site, who can then view the
    content. The common case is that once the content is published, it stays the same,
    or, it stays static. The uncommon case is that the author makes updates to their
    post, but even then, this is an infrequent action. Now, think about your typical
    blog publishing platform. Every time a reader visits a page on your blog, database
    queries are executed, content has to be assembled, and so on. Ask yourself, is
    there really any point in issuing all of these queries if the results are going
    to be the same every time?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example. You have an enterprise-style app—a large app
    with lots of data and lots of features. One part of the app is focused on user
    interactivity—adding/changing data and interacting with near real-time data. Another
    part of the app generates reporting—reports based on database queries and charts
    based on historical snapshots of data. The latter part of this enterprise application
    doesn''t appear to interact with data that changes frequently, or at all. Perhaps,
    the app could benefit by being split into two apps: one that handles user interactions
    with lively data, and another one that generates static content that doesn''t
    change frequently, or at all.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be building an app or part of a larger app where you have mostly static
    data. If so, you could probably use a tool like Gatsby to generate statically
    rendered content. But why do this? What's the benefit?
  prefs: []
  type: TYPE_NORMAL
- en: Better user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most compelling reason for building a static version of your React components
    is to provide a better experience for your users. The key metric here is the overall
    performance improvements. Instead of having to touch various API endpoints and
    handle all of the asynchronous aspects of providing data to your React components,
    everything is loaded upfront.
  prefs: []
  type: TYPE_NORMAL
- en: Another less obvious user experience improvement with statically built React
    content is that since there are fewer moving parts, there's less chance of the
    site breaking, leading to user frustration. For example, if your React components
    don't have to reach out over the network to fetch data, this failure vector is
    removed entirely from your site.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient resource usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Components that are statically compiled by Gatsby know how to make efficient
    use of the GraphQL resources that they consume. One of the great things about
    GraphQL is that it''s easy for tools to parse and generate efficient code at compile
    time. If you want a more in-depth introduction to GraphQL before continuing with
    Gatsby, a good one can be found here: [http://graphql.org/learn/](http://graphql.org/learn/).'
  prefs: []
  type: TYPE_NORMAL
- en: Another place that static Gatsby React apps help reduce resource consumption
    is in the backend. These apps aren't constantly hitting API endpoints that return
    the same response every single time. This is time that the same API and database
    could be spent servicing requests that actually need dynamic data or are generating
    new data.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first Gatsby site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to using Gatsby is to install the command-line tool globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run the command-line tool to generate your Gatsby project, not
    unlike how `create-react-app` works. The `gatsby` command takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL of the Gatsby starter repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The project name is basically the name of the folder that''s created to hold
    all of your project files. A Gatsby starter is kind of like a template that makes
    it easier for you to get rolling, especially if you''re learning. If you don''t
    pass a starter, the default starter is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above command would be the same as running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the starter repository is cloned into the `your-first-gatsby-site`
    directory and then dependencies are installed for you. If all goes well, you should
    see the console output that looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can change into the `your-first-gatsby-site` directory and start the
    development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts the Gatsby development server within your project. Once again,
    this is similar to how `create-react-app` works—there''s zero configuration to
    deal with and Webpack is setup to just work. After starting the development server,
    you should see output on the console that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can now view `gatsby-starter-default` in the browser by navigating to `http://localhost:8000/`.
  prefs: []
  type: TYPE_NORMAL
- en: View GraphiQL, an in-browser IDE, to explore your site's data and schema
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8000/___graphql`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the development build is not optimized. To create a production build,
    use `gatsby build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you visit `http://localhost:8000/` in your web browser, you should see the
    default content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a34620ae-1efb-49f9-9605-c9f83645e039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The default starter creates multiple pages so that you can see how to link
    your pages together. If you click on the Go to page 2 link, you''ll be taken to
    the next page of the site, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9871976b-c9f3-4fb0-b4ee-1f74e97ce782.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what the structure of your default Gatsby starter project looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For basic site design and editing, you''ll mostly be concerned with files and
    directories under `src`. Let''s take a look at what you have to work with here,
    starting with the `Header` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This component defines the purple header section. The title is static for now,
    it links to the home page, and defines some inline styles. Next, let''s look at
    the `layouts/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This module exports a `TemplateWrapper` component. The job of this component
    is to define the layout for the site. Like other container components that you
    might have implemented, this one is rendered on every page of the site. It's similar
    to what you would do with `react-router`, except with Gatsby, the routing is handled
    for you. For example, the route that handles the link that points to `page-2`
    is created automatically by Gatsby. Likewise, Gatsby automatically handles this
    layout module for you by making sure that it's rendered by every page on the site.
    All you have to do is make sure that it looks the way you want it to and that
    the `children()` function is rendered. For now, you can just leave it as is.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice, too, that the layout module also imports a stylesheet that contains
    styles pertinent to the layout of the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the page components now, starting with `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like plain HTML sites have an `index.html` file, it''s important that
    static Gatsby sites have an `index.js` page that exports the content to render
    on the home page. The `IndexPage` component that''s defined here renders some
    basic HTML, including a link to `page-2`. Let''s look at `page-2.js` next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This page looks very similar to the home page. The link that's rendered here
    takes the user back to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: This was just a basic introduction to get you rolling with Gatsby. You didn't
    use any data sources to generate content; you'll do just that in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding local filesystem data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you saw how to get a basic Gatsby website up and running.
    This website wasn't very interesting because there was no data to drive it. For
    example, the data that drives a blog is the blog entry content stored in a database—the
    blog framework that renders the post lists and posts themselves use this data
    to render markup.
  prefs: []
  type: TYPE_NORMAL
- en: You can do the same thing with Gatsby but in a more sophisticated way. First,
    the markup (or in this case, React components) is statically built and bundled
    once. These builds are then served to users without having to query a database
    or API. Second, the plugin architecture used by Gatsby means that you're not restricted
    to only one source of data and that different sources are often combined. Lastly,
    GraphQL is the querying abstraction that sits on top of all of these things and
    delivers data to your React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, you need a data source to drive the content of your website.
    We''ll keep things simple for now and use a local JSON file as the source. To
    do so, you need to install the `gatsby-source-filesystem` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this package is installed, you can add it to your project by editing your
    `gatsby-config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `name` option tells the GraphQL backend how to organize the query result.
    In this case, everything will be under a `data` property. The path option restricts
    which files are readable. The path used in this example is `src/data`—feel free
    to throw a file into that directory so that it's queryable.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can go ahead and start up the Gatsby development server.
    The GraphiQL utility is accessible at `http://localhost:8000/___graphql`. When
    developing Gatsby websites, you will utilize this tool often as it allows you
    to create ad hoc GraphQL queries and execute them on the fly. When you first load
    this interface, you''ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/516c3d4c-3c8f-4744-92e8-76ce159e7435.png)'
  prefs: []
  type: TYPE_IMG
- en: The left panel is where you write your GraphQL queries, clicking on the Play
    button above executes the query, and the panel to the right displays the query
    results. The docs link in the top-right is a useful way to explore the available
    GraphQL types that Gatsby creates for you. Additionally, the query editor pane
    to the right will autocomplete as you type to help make building queries easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute your first query that lists information about files on the filesystem.
    Remember that you need at least one file in `src/data` in order to have your query
    return any results. Here is how to query the name, extension, and the size of
    files in your data directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0262adc8-b93d-4f2b-a674-c6e5727dcb0d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, specific node fields are specified in the query. The result
    in the right panel shows that you get the exact fields that you ask for. Part
    of GraphQLs appeal is that you can create arbitrarily nested and complex queries
    that span multiple backend data sources. However, delving into the specifics of
    GraphQL go way beyond the scope of this book. The Gatsby home page ([https://www.gatsbyjs.org/](https://www.gatsbyjs.org/))
    has some great resources on GraphQL, including links to other GraphQL tutorials
    and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway here is that the `gatsby-source-filesystem` data source plugin
    did all of the heavy GraphQL lifting for you. It generates the entire schema for
    you, which means that once you have the plugin installed, you can start the development
    server and experiment with autocomplete and documentation right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward with the example, you probably don''t have any need to render
    local file data in your UI. So let''s create a `articles.json` file that has some
    JSON content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This JSON structure is an array of article objects with `topic` and `title`
    properties. This is the data that you want to query with GraphQL. To do so, you
    need to install another Gatsby plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gatsby-transformer-json` plugin is from another category of Gatsby plugins—transformers.
    Source plugins are responsible from feeding data into Gatsby, while transformers
    are responsible for making the data queryable via GraphQL. Just like any plugin
    you want to use, you need to add it to your project config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a file with JSON content in your data directory and the `gatsby-transformer-json`
    plugin installed and enabled, you can go back to GraphiQL and query for JSON content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/96aa1a5a-f9cf-44a1-9add-87cbfe07901f.png)'
  prefs: []
  type: TYPE_IMG
- en: The `gatsby-transformer-json` plugin makes the `allArticlesJson` query possible
    because it defines the GraphQL schema for you, based on the JSON data found in
    the data source. Under `node`, you can ask for specific properties, as you would
    with any other GraphQL query. In the results, you get all of the JSON data that
    your query asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s assume that you want three separate pages for listing
    articles, organized by topic. You need a way to filter the nodes that are returned
    by the query. You can add filters directly into your GraphQL syntax. For example,
    to find only global articles, you do execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a8799f8a-f4bf-419d-82d3-bc5cf1987d2b.png)'
  prefs: []
  type: TYPE_IMG
- en: This time a filter argument is passed to the `allArticlesJson` query. Here,
    the query is asking for nodes with a topic value of global. Sure enough, the articles
    with a global topic are returned in the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphiQL utility allows you to design a GraphQL query that can then be
    used by your React component. Once you have a query that''s returning the correct
    results, you can simply copy it into your component. This last query returns global
    articles, so you can use it with the component used for the `pages/global.js`
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are two things to pay attention to in this module. First, look at the
    argument passed to the component and notice how it matches the result data that
    you saw in GraphiQL. This data is then used to render the list of global article
    titles. Next, notice the `query` export string. During build time, Gatsby will
    find this string and execute the appropriate GraphQL query so that your component
    has a static snapshot of the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that you now know how to filter for global articles, you can now update
    the filter for the `pages/local.js` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s what the `pages/sports.js` page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed that these three components look very similar. This
    is because they''re all working with the same data. The only unique thing about
    them is their title. To reduce some of this redundancy, you could create a higher-order
    component that takes a `name` argument and returns the same underlying component
    used on each page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you could use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to view all of these pages, you need an index page that links to each
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the home page looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4ca67551-6019-4000-9dc4-754b8898244d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you were to click on one of the topic links, like Global for example, you''re
    taken to an article list page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1e75e46a-857c-4c0c-977a-7499101c790b.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching remote data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gatsby has a rich ecosystem of data source plugins—we don't have time go through
    all of them. It's common for a Gatsby source plugin to reach out to another system
    and fetch data over the network at build time. The `gatsby-source-hacker-news`
    plugin is a great plugin to start with, so that you can see how this fetching
    process works with Gatsby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of building your own Hacker News website using Gatsby, we''ll use the
    demo created by [https://github.com/ajayns](https://github.com/ajayns). To get
    started, you can clone into his repo as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can install dependencies, including the `gatsby-source-hacker-news`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t need to edit the project configuration to enable anything, because
    this is already a Gatsby project. Simply start the development server as you''ve
    done throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to other websites you''ve worked on this chapter, this time around
    the build takes longer to complete. This is due to the fact that that Gatsby has
    to fetch data over the network. There are also more resources to fetch. If you
    look at the console output from the development server, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This indicates that the build will take longer due to the work that needs to
    happen in order to load the Hacker News data. Once this process completes, you
    can load the site in your browser. You should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/46022adb-b2be-4880-b79b-b9570374076e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the GraphQL query that loaded the data used to render
    this content. In the `index.js` page, you''ll find the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of individual node fields being specified, there''s `...Story`. This
    is called a **fragment** and it''s defined in the `StoryItem` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StoryItem` component defines this GraphQL fragment because it uses this
    data. Now, let''s shift over to GraphiQL and put this query together and execute
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f78af049-2082-4b7d-8bbd-87acf0b5fb1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how the home page of the site loads data fetched from the Hack News
    API. Here''s what the home page component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The edges of the returned data are mapped to `StoryItem` components, passing
    in the data node. Here''s what the `StoryItem` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see how this component uses the data defined by the GraphQL fragment
    that was passed to the larger query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s click on the comments link of a story, which will take you to the
    details page of a story. The new URL should look something like `http://localhost:8000/item/16691203`
    and the page should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7848af2c-c83d-4e35-9e58-91967c4017e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''re probably wondering where this page comes from, given that it has a
    URL parameter (the ID of the story). When using Gatsby to build static pages that
    have a dynamic URL component to them, you have to write some code whose job is
    to tell Gatsby how to create pages based on GraphQL query results. This code goes
    into the `gatsby-node.js` module. Here''s how the pages in this Hacker News website
    are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This module exports a `createPages()` function that Gatsby will use to create
    the static Hacker News article pages at build time. It starts by using the `grapghql()`
    function to execute a query to find all of the article nodes that you need to
    create pages for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `createPage()` function is called for each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties that are passed to `createPage()` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: This is the URL that when accessed, will render the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: This is the filesystem path to the React component that renders
    the page content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: This is data that''s passed to the React component. In this case,
    it''s important that the component knows the article ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the general approach that you would take with Gatsby any time you have
    lots of pages to generate based on dynamic data, but the same React component
    can be used to render the content. In other words, you would probably rather write
    this code and a React component rather than separate components for every article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the component that''s used to render the article details
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the component relies on Gatsby executing the GraphQL query found
    in the `pageQuery` constant. The context is passed to `createPage()` in `gatsby-node.js`.
    This is how you're able to feed the `$id` argument into the query so that you
    can query for the specific story data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Gatsby, a tool for generating static websites
    based on React components. We started the chapter off with a discussion on why
    you might want to consider building static sites, and why React is a good fit
    for this job. Static sites lead to an overall better user experience because they
    don't utilize the same types of resources as regular React apps would.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you built your first Gatsby website. You learned the basic layout of files
    that are created by Gatsby starter templates and how to link pages together. Then,
    you learned that Gatsby data is driven by a plugin architecture. Gatsby is able
    to support various data sources via plugins. You got started with local filesystem
    data. Next, you learned about transformer plugins. These types of Gatsby plugins
    enable specific types of data sources to be queried via GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you looked at a Hacker News example built using Gatsby. This exposed
    you to fetching remote API data as the data source and generating pages dynamically
    based on GraphQL query results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, you'll learn about tooling to containerize and
    deploy your React applications alongside the services that they consume.
  prefs: []
  type: TYPE_NORMAL
