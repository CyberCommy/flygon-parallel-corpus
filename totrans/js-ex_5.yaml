- en: Developing a Weather Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey! Good work with the Video Call app. Hope you made some calls to your friends.
    In the previous chapter, we built a Video Call app using the SimpleWebRTC framework.
    Isn't it great to know that you can build all these cool applications with JavaScript?
    You have the power to access the user's device hardware straight from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have been building entire applications by yourself, so you had complete
    knowledge of the app's structure, such as the classes and IDs used in HTML and
    CSS and the classes, functions, and services used in JavaScript. But in the real
    world, you seldom work alone. If anything, you work in teams of sizes ranging
    from a few members to hundreds of developers working across the globe. In this
    case, you will not have knowledge about the entire web application. For this chapter,
    you are part of a huge web application project. You are in your first week of
    work and then your manager walks in and hands you your task for the week.
  prefs: []
  type: TYPE_NORMAL
- en: Can you build a Weather Widget?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, your project has around 40 developers working in different parts of the
    web application and a new requirement just popped up. They need to show a Weather
    Widget in some areas of the website. The Weather Widget needs to be responsive
    so that it can squeeze into any available space in any section of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: We can surely build a Weather Widget but there is a problem. We have no idea
    about the rest of the web application! For example, what are the class and ID
    used in its HTML, since the styles created by CSS are always global? If we were
    to accidentally use a class that is already being used in some other part of the
    HTML in the web application, our widget will inherit the style of that DOM element,
    which we really need to avoid!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem is will be that we would have created `<div>`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Along with a CSS file and some JS files, we have all the logic needed to make
    our widget work. But how are we going to deliver it to the rest of the team (given
    we didn't hopefully reuse any other used class names or IDs from the web app in
    the widget)?
  prefs: []
  type: TYPE_NORMAL
- en: If it were a simple JavaScript module, we simply build an ES6 module, which
    the team can import and use, since the scope of variables in the ES6 modules do
    not leak out (you should only use `let` and `const`; you really don't want to
    accidentally create a global variable with `var`). But it's a different story
    for HTML and CSS. Their scope is always global and they always need to be handled
    with care (you don't want some one else in the team to accidentally tamper with
    your widget)!
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started! We are going to think of some really random (and cool!)
    class names and IDs for the DOM elements, which no one else in your team can think
    of and then write a 10 page `readme` file to document the working of the Weather
    Widget with all the dos and don'ts and then later spend our time working on carefully
    updating the `readme` file whenever we do some enhancements and bug fixes to the
    widget. Also, be sure to memorize all the class names and the IDs!
  prefs: []
  type: TYPE_NORMAL
- en: 'About the last paragraph, Nope! We are definitely not going to do that! I''m
    already getting goosebumps thinking about it! Instead, we are going to learn about web
    components and we are going to write a simple ES6 module, which should be imported
    by the rest of your team members and then they should simply add the following
    DOM element in their HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You need to build a DOM element (such as the `<input>`, `<p>`, and
    `<div>` elements), which will show a Weather Widget. `x-weather` is a new HTML5
    *custom element*, which we are going to build in this chapter. It is going to
    overcome all the problems we might face in the previous approach.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web components are a set of four different technologies that can be used together
    or separately to build reusable user interface widgets. Just as we can create
    reusable modules using JavaScript, we can create reusable DOM elements with web
    component technologies. The four technologies that form the web components are:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web components were created to provide developers simple APIs to build highly
    reusable DOM elements. There are many JavaScript libraries and frameworks that
    focus on providing reusability by organizing the entire web application into simpler
    components, such as React, Angular, Vue, Polymer, and so on. In the next chapter,
    we are going to build an entire web application by putting together multiple independent
    React components. However, despite all the frameworks and libraries available,
    web components hold a big advantage, since they are supported natively by the
    browser, which means no additional libraries to increase the size of your widget.
  prefs: []
  type: TYPE_NORMAL
- en: For our widget, we are going to use custom elements and shadow DOM. Before we
    start building our widget, let's take a quick look into the other two, which we
    will not use in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Web components are a new standard and they are actively being implemented by
    all the browser vendors. However, at the time of writing this book, *only Chrome
    supports all the features of the web components*. If you want to check whether
    your browser supports web components, visit: [http://jonrimmer.github.io/are-we-componentized-yet/](http://jonrimmer.github.io/are-we-componentized-yet/).
  prefs: []
  type: TYPE_NORMAL
- en: You should only use Chrome for the project in this chapter, since other browsers
    do not yet have proper support for web components. At the end of this chapter,
    we'll discuss how to add polyfills to make web components work in all the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTML template is a simple `<template>` tag, which we can add in our DOM.
    However, even if we add it in our HTML, the contents of the `<template>` element
    will not get rendered. If it contains any external resources, such as images,
    CSS, and JS files, they will also not get loaded into our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the template element only holds some HTML content, which can be used
    later by JavaScript. For example, say you have the following template element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This element holds `div` that will not be rendered by the browser. However,
    we can create a reference of that `div` using JavaScript, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can make any changes to this reference and add it to our DOM. Even better,
    we can make a deep copy of this element so that we can use it in multiple places.
    A deep copy is a copy of the object in which changes to the copy will not be reflected
    in the original. By default, JavaScript always makes a shallow copy of the object
    when we do an assignment using the `=` operator. `$template` is a shallow copy
    of the DOM element, which we call as a reference to the DOM element. Hence, any
    change to `$template` is reflected in the DOM. But if we make a deep copy of `$template`,
    then the changes to that deep copy will not be reflected in the DOM, since it
    won't affect `$template`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a deep clone of a DOM element, we can use the `document.importNode()`
    method. It accepts two parameters: the first one is the DOM element it needs to
    clone and the second one is a boolean for whether it needs to be a deep copy.
    If the second argument is true, it will make a deep copy of the element. See the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, I made a deep copy of the contents of the template element (`$template.content`)
    in the `$javascript` object and added `$javascript` to the DOM element. Any modifications
    to `$javascript` will not affect `$template`.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed example, I have set up a JSFiddle at: [https://jsfiddle.net/tgf5Lc0v/](https://jsfiddle.net/tgf5Lc0v/).
    Do check it out to see the working of the template elements in action.
  prefs: []
  type: TYPE_NORMAL
- en: HTML imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTML imports are simple. They let you import an HTML document inside another
    HTML document in the same way as you include CSS and JS files. The import statement
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: HTML imports have a lot of benefits when we work in an environment that *does
    not* use a build tool such as Webpack; for example delivering the web components
    for use across the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information regarding using the HTML imports feature, refer to the
    html5rocks tutorial at: [https://www.html5rocks.com/en/tutorials/webcomponents/imports/](https://www.html5rocks.com/en/tutorials/webcomponents/imports/).'
  prefs: []
  type: TYPE_NORMAL
- en: The main reason why we are not going to use HTML templates and HTML imports
    in our Weather Widget is that they are more focused on usage with HTML files.
    Our build system that we are going to use in this chapter (Webpack) works better
    with JavaScript files. So, we'll continue with the rest of the chapter, learning
    about custom elements and shadow DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Weather Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we need a server to fetch weather information for a given
    location. In the browser, we can use navigator object to retrieve the exact geolocation
    (`latitude` and `longitude`) of the user. Then, using these coordinates, we need
    to find the name of the region and its weather information. For this purpose,
    we need to use third-party weather providers and the Google Maps API, which we
    used in [Chapter 3](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7)*, Event
    Registration App*. The weather provider we are going to use in this project is
    **Dark Sky**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up the server for the Weather Widget. Open up the `Chapter05\Server`
    directory in the book code. Inside the server directory, first run `npm install`
    to install all the dependencies. You need to get the API keys for both Dark Sky
    and Google Maps. You might already have the Google Map API key, since we used
    it recently. To generate your API keys for both the services, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dark Sky**: Sign up for a free account at: [https://darksky.net/dev/](https://darksky.net/dev/),
    and then you will get a secret key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Maps**: Follow the steps provided at: [https://developers.google.com/maps/documentation/javascript/get-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you get both the keys, create a `.env` file inside the `Server` root directory
    and add the keys inside it in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added the keys, run `npm start` in the terminal from the `Server`
    root directory to start the server. The server will be running at the `http://localhost:3000/`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the server ready. Let''s set up the starter files for the project.
    Open up the `Chapter05\Starter` files and then run `npm install` inside that directory
    to install all the dependencies. Create a `.env` file in the project root directory
    and add the following lines inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in the previous chapter, we should set `NODE_ENV=production`
    for generating production builds. `SERVER_URL` will contain the URL of the project's
    server that we just set up. Both `NODE_ENV` and `SERVER_URL` will be available
    as global variables for the JavaScript code in our app (I have used the Webpack
    defined plugin in `webpack.config.js`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, execute `npm run watch` in the Terminal to start the Webpack dev server.
    You will have your project running in `http://localhost:8080/` (the project URL
    will be printed in the Terminal). Currently, the web app will display three texts:
    large, medium, and small. It has three containers of different sizes, which will
    hold the Weather Widget. At the end of the project, the Weather Widget will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Working of the Weather Widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s strategize the working of our Weather Widget. Since our Weather Widget
    is an HTML custom element, it should work just like other native HTML elements.
    For example, consider the `<input>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render a normal text input. However, we can use the same `<input>`
    element with a different attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It will render a password field instead of the text field with all the input
    text content hidden. Likewise, for our Weather Widget, we need to display the
    current weather condition for a given location. The best way to pinpoint the user's
    location is to use the HTML5 geolocation, which will get the user's current latitude
    and longitude information directly from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we should make our widget customizable for the rest of the developers.
    They might want to manually set a location for our Weather Widget. So, we''ll
    leave the logic to retrieve the location to other developers. Instead, we can
    manually accept `latitude` and `longitude` as attributes for our Weather Widget.
    Our weather element will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can read `latitude` and `longitude` from the respective attributes and
    set the weather information in our widget, and other developers can easily customize
    the location by simply changing the values of the `latitude` and `longitude` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start building the widget, let''s take a look at the steps to retrieve
    the user''s geolocation. In your `src/js/home.js` file, you should see an import
    statement, which will import the CSS into the web application. Below that import
    statement, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will call the `getLocation()` function when the page completes loading.
    Inside this function, we must first check whether the `navigator.geolocation`
    method is available in the browser. If it is available, we can use the `navigator.geolocation.getCurrentPosition()`
    method to retrieve the user's geolocation. This method accepts two functions as
    parameters. The first function will be called when the location is retrieved successfully
    and the second function is called if the location cannot be retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `home.js` file, add the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Open the app in Chrome. The page should ask you for permission to access your
    location, just as it did for accessing the camera and microphone in the previous
    chapter. If you click Allow, you should see your current `latitude` and `longitude`
    printed in Chrome's console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the `getLocation()` function will use the `navigator.getlocation.getCurrentPosition(showPosition,
    errorPosition)` method to get the location of the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click Allow when the page asks for permission, then it will call the `showPosition`
    function with the `position` object as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you click Block, then it will call the `errorPosition` function with the
    `error` object as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position` object contains the latitude and longitude of the user in the
    `position.coords` property. This function will print the latitude and longitude
    in the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding the usage of the geolocation, refer to the MDN
    page: [https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/Using_geolocation).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the weather custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have the geolocation. So, let''s start creating the custom element. Currently,
    your folder structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We want to keep our custom element to be independent of other JavaScript modules.
    Inside the `src/js` directory, create a file under the path `CustomElements/Weather/Weather.js`.
    Do note that I have used capital letters for the first letters in the folder and
    filenames (PascalCase). You can use PascalCase for files and folders, which will
    export an entire class. This is only for easily identifying classes in your project
    folder and need not be a strictly followed rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your folder structure will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Weather.js` file in VSCode. All the native HTML elements are implemented
    using the `HTMLElement` class (interface) either directly or through an interface
    that inherits it. For our custom weather element, we need to create a class that
    extends `HTMLElement`. By extending a class, we can inherit the properties and
    methods of the parent class. In your `Weather.js` file, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As per the custom elements v1 spec, a custom element should be extended from
    `HTMLElement` directly only using a class. However, we are using `babel-loader`
    with the `env` preset, which converts all the classes into functions. This will
    cause a problem with the custom elements, which need to be classes. But there
    is a plugin that can be used to overcome this issue: *transform-custom-element-classes*.
    I have already added this plugin in your `webpack.config.js` file so that you
    wouldn't face any problems in this chapter. You can find it in the `.js` rules
    section of your Webpack configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the initial class variables in our `Weather` class''s constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the constructor's first line, I have made a call to the `super()`
    method. This will call the constructor of the parent class `HTMLElement`. Whenever
    your class extends another class, always add `super()` inside your class's constructor.
    This way, the parent class will also get initialized before your class methods
    start working.
  prefs: []
  type: TYPE_NORMAL
- en: The two class variables (properties), `this.latitude` and `this.longitude`,
    will get the value of the attributes `lat` and `long` from the custom weather
    element using the `this.getAttribute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add HTML to our custom element. Since the `Weather` class is
    similar to the reference of a DOM element we used before, `this.innerHTML` can
    be used to add HTML for the weather element. Inside the constructor, add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, `this.innerHTML` is an empty template string. I have already created the
    HTML and CSS needed for the custom element. You can find it in the `Chapter 05\WeatherTemplate`
    directory of the book code. Copy the contents of the `weather-template.html` file
    and paste it inside the template string.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our custom element now contains the HTML needed for displaying the contents.
    Let''s test it. At the end of your `Weather.js` file, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will export the entire `Weather` class and make it available to be used
    inside other modules. We need to import this into our `home.js` file. Inside your
    `home.js` file, add the following code at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to define the custom element, that is, associate the custom element
    with a tag name. Ideally, we would like to call our element `<weather>`. It would
    be nice! But according to the custom element spec, we should name the element
    so that it has a dash `-` in its name. So, for simplicity, we call our element
    `<x-weather>`. This way, whenever we see an element prefixed with `x-`, we will
    immediately know it is a custom element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `customElements.define()` method is used for defining custom elements.
    `customElements` is available on the global `window` object. It accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is a string that should contain the custom element name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter should contain the class that implements the custom element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add `customElements.define(''x-weather'', Weather)` to your callback function
    of the window load event listener, which we previously added in `home.js` to get
    the geolocation. `window.addEventListener` will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the custom element to our `index.html` file. In your `index.html`
    file, add the following line inside the `div.large-container` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it is a change in the HTML file, you have to manually reload the page
    in Chrome. Now, you should get a Weather Widget showing a loading message, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you inspect the element using Chrome DevTools, it should be structured as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, your HTML is now attached inside the custom element along with
    the styles. However, we are facing one serious problem here. The scopes of styles
    are always *global*. This means that, if anyone were to add style for the `.title`
    class, say `color: red;` in the page''s CSS, it will affect our Weather Widget
    too! Or, if we add styles to any class that is used in the page, say `.large-container`,
    inside our widget, it will affect the entire page! We really don''t want this
    to happen. To overcome this problem, let''s learn the last remaining topic of
    the web components.'
  prefs: []
  type: TYPE_NORMAL
- en: Attaching a shadow DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A shadow DOM provides encapsulation between DOM and CSS. A shadow DOM can be
    attached to any element and the element to which the shadow DOM is attached is
    called the shadow root. A shadow DOM is considered separate from the rest of the
    DOM tree; hence, the styles from outside the shadow root will not affect the shadow
    DOM and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach a shadow DOM to an element, we simply need to use the `attachShadow()`
    method on that element. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, firstly, I attached a shadow DOM named `$shadowDom` to `$element`. After
    this, I added some HTML to `$shadowDom`. Note that I used the parameter `{mode:
    ''open''}` to the `attachShadow()` method. If `{mode: ''closed''}` were to be
    used, access to the shadow DOM from the shadow root using JavaScript is closed
    and other developers will not be able to manipulate our element from the DOM using
    JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: We need the developers to manipulate our element using JavaScript so that they
    can set the geolocation for the Weather Widget. Generally, the open mode is widely
    used. The closed mode is used only when you want to completely prevent others
    from making changes to your element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the shadow DOM to our custom weather element, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach a shadow DOM to our custom element. This can be done by adding the following
    line to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `this.innerHTML` with `this.$shadowRoot.innerHTML` and your code should
    now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page in Chrome. You should see the same Weather Widget; however, if
    you inspect the element using Chrome DevTools, your DOM tree will be structured
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the contents of the `<x-weather>` element will be separated
    from the rest of the DOM by specifying `x-weather` as a shadow root. Also, the
    styles defined inside the weather element will not leak out to the rest of the
    DOM and the styles outside the shadow DOM will not affect our weather element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, to access the shadow DOM of an element, you can use the `shadowRoot`
    property of that element. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will print the entire shadow DOM attached to a shadow root in the console.
    However, if your shadow root is *closed*, then it will simply print `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have the UI ready for our Weather Widget. Our next step is to retrieve
    the data from the server and display it in the Weather Widget. Generally, widgets,
    such as our Weather Widget, will not be present in the HTML directly. Like with
    the tasks in our Chapter 1, *Building a ToDo List*, developers often create the
    element from JavaScript, attach attributes, and append it to the DOM. Also, if
    they need to make any changes, such as changing the geolocation, they will use
    a reference to the element in JavaScript to modify its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: This is very common and we have been modifying a lot of DOM elements this way
    in all our projects. Now, the same will be expected from our custom weather element.
    The `HTMLElement` interface from which we extended our `Weather` class provides
    special methods called lifecycle callbacks to our `Weather` class. Lifecycle callbacks
    are methods that get called when a certain event happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a custom element, four lifecycle callback methods are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connectedCallback()`: This is called when the element is inserted into a DOM
    or a shadow DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeChangedCallback(attributeName, oldValue, newValue, namespace)`: This
    is called when an observed attribute of the element is modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnectedCallback()`: This is called when the element is removed from the
    DOM or shadow DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adoptedCallback(oldDocument, newDocument)`: This is called when an element
    is adopted into a new DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our custom element, we are going to use the first three callback methods.
    *Remove* the `<x-weather />` element inside your `index.html` file. We are going
    to add it from our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `home.js` file, inside the `showPosition()` function, create a new
    function name: `createWeatherElement()`. This function should accept a class name
    (the HTML class attribute) as a parameter and create a weather element with that
    class name. We already have the geolocation in the `latitude` and `longitude`
    constants. The code for the `showPosition()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will return a weather element with three attributes, which will
    look like the following snippet in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the Weather Widget inside all the large, medium, and small containers,
    add the following code after the preceding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see Weather Widgets attached to all the three different sized containers.
    Our final widget should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Weather Widget contains the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: City name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weather icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time (*hours***:***minutes***:***seconds*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary of the weather status (*Overcast*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding dependency modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Weather Widget needs to make an HTTP request to the server. For this, we
    can reuse the APICall module we built previously in [Chapter 3](part0075.html#27GQ60-f852807d0cb141b58fff8f992d32cbb7),
    *Event Registration App*. Also, since we will be using the Dark Sky service for
    displaying weather information, we can use their icon library, Skycons, for displaying
    the weather icon. Currently, Skycons is not available in npm. You can get both
    the files from the book code `Chapter05\weatherdependencies` directory or from
    the completed code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, your JS folder will be structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should add the `apiCall.js` file under the `CustomElements/Weather/services/api/apiCall.js`
    path and the `skycons.js` file under the `CustomElements/Weather/lib/skycons.js`
    path. Your JS folder should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving and displaying weather information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In your `weather.js` file, add the following import statements at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The Skycons library will add a global variable, `Skycons`, to the window object.
    It is used to show an animated **Scalable Vector Graphics** (**SVG**) icon in
    the canvas element. Currently, all the class variables, such as `latitude` and
    `longitude`, are created in the constructor. But instead, it is better to create
    them only when the Weather Widget is added to the DOM. Let''s move the variables
    to the `connectedCallback()` method so that the variables are created only when
    the widget is added to the DOM. Your `Weather` class will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, just as we created the reference for elements in the DOM in the previous
    chapters, let''s create references to the elements in the shadow DOM of the Weather
    Widget. Inside the `connectedCallback()` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server included with this chapter and let it run in the `http://localhost:3000/`
    URL. For retrieving the weather information, the API endpoint is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `lat` and `long` are latitude and longitude values. If your (`lat`, `long`)
    values are (`13.1358854`, `80.286841`), then your request URL will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The response format of the API endpoint is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the weather information in the Weather Widget, create a new method inside
    the `Weather` class `setWeather()` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, call the preceding method by adding `this.setWeather()` at the end of
    the `connectedCallback()` method. Open the page in Chrome and you should see the
    Weather Widget working as expected! You will be able to see the city name, weather
    information, and the weather icon. The working of the `setWeather()` method is
    straightforward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it will check whether both the latitude and longitude are available.
    Otherwise, it will be impossible to make the HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `apiCall` module, a GET request is made and the `response` is available
    in the `Promise.then()` chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the `response` of the HTTP request, the required data, such as city name,
    temperature, and summary, are included in the respective DOM elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the weather icon, the global `Skycons` variable is a constructor that creates
    an object with all the icons in a specific color. In our case, black. The instance
    of the constructor is stored in the `skycons` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For adding the animated icon, we use the `add` method with the canvas element
    (`this.$icon`) as the first parameter and the icon name as the second parameter
    in the required format. For example, if the value of the icon from the API is
    `cloudy-day`, the equivalent icon is `Skycons['CLOUDY_DAY']`. For this purpose,
    we first convert the entire string to uppercase and replace `-` with `_` by using
    a replace method with regular expression `.replace(/-/g, "_")`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the current time to the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are still missing time in our widget. Unlike other values, time does not
    depend on the HTTP request but it needs to be updated every second automatically.
    In your weather class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayTime()` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A date object is created using the `new Date()` constructor. The `new Date()`
    constructor creates a `date` object with all the details regarding the date and
    time passed as parameters. If no parameters are passed, it will create an object
    containing all the information regarding the current date and time (up to milliseconds).
    In our case, since we didn't pass any parameters, it contains all the details
    of the date and time in the moment it was initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get the hours, minutes, and seconds from the date object. By using template
    strings, we simply constructed the time in the required format easily and stored
    it in the `displayTime` constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it sets the time as the text content of the *p#time* (`$time`) element
    in the shadow DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the date object is an important concept and is part of everyday software development
    in JavaScript. To learn more about date objects, refer to the w3schools page at: [https://www.w3schools.com/js/js_dates.asp](https://www.w3schools.com/js/js_dates.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is used to set the time once but we need to execute this method
    every second so that users can see the exact time in the widget. JavaScript has
    a method called `setInterval()`. It is used to execute a function repeatedly in
    a specific time interval. The `setInterval()` method accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the function that needs to be executed in a specific time interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one is the time interval in milliseconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, `setInterval()` executes the function repeatedly even if the DOM element
    is removed from the DOM for some reason. To overcome this, you should store `setInterval()`
    in a variable and then use the `disconnectedCallback()` method to execute `clearInterval(intervalVariable)`,
    which clears the interval function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Open up the Weather Widget in Chrome and you should see the current time in
    the widget updated for every second, which looks normal to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to changes in element attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a full working Weather Widget but the weather information gets loaded
    only when the widget gets added to the DOM for the first time. If you try to change
    the value of the attributes `latitude` and `longitude` either from Chrome DevTools
    or from JavaScript, the value changes but the Weather Widget will not get updated.
    To make the weather element respond to the changes in `latitude` and `longitude`,
    we need to declare them as observed attributes. To do so, inside your `Weather`
    class, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will create a static getter `observedAttributes()` that will return an
    array of all the attribute names, for which the Weather Widget should listen for
    changes. Static methods are special methods of `Class` that can be accessed without
    creating a class instance object. For all the other methods, we need to create
    a new instance (object) of the class; otherwise, we won't be able to access them.
    Since static methods do not need an instance, the `this` object will be *undefined*
    inside these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods are used to hold common (class variables and methods independent)
    functions associated with the class that can be used in other places outside the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we marked `latitude` and `longitude` as observed attributes, whenever
    they get modified using any method, it will trigger `attributeChangedCallback()`
    with the modified attribute''s name, and the old value of that attribute and the
    new value of that attribute as parameters. So, let''s add `attributeChangedCallback()`
    inside our `Weather` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This method is simple. Whenever the value of the `latitude` or `longitude` attribute
    changes, it updates the respective class variable and calls `this.setWeather()`
    to update the weather to the new geolocation. You can test this by editing the
    attribute of the Weather Widget directly in the DOM tree of Chrome DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: Using setters and getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use `setters` and `getters` all the time when we create a reference to the
    DOM element. If we have a reference to the weather custom element, we would simply
    want to set or get `latitude` or `longitude` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we need the widget to update if we set a new `latitude` or `longitude`.
    To do that, add the following setters and getters to your `Weather` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To test if the setters and getters are working properly, let''s remove (or
    comment) the line where the Weather Widget gets appended to `$smallContainer`.
    Instead of that, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You should see that after 10 seconds, the weather in the small container automatically
    changes to London. The old and new geolocation will also get printed in the Chrome
    DevTools console.
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully completed the Weather Widget! Before you use it in your
    project, you need to add polyfills, because at the time of writing this book,
    only Chrome supports all the features of the web components.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing browser compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To improve the browser compatibility of our Weather Widget, we need the set
    of polyfills provided by the `webcomponents.js` library in the: [https://github.com/webcomponents/webcomponentsjs](https://github.com/webcomponents/webcomponentsjs)
    repository. These polyfills make our widget work with most of all the modern browsers.
    To add these polyfills to our project, first run the following command in the
    Terminal from the project root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install and add `webcomponents.js` to our project dependency. After
    that, import it in your `home.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, we are initializing the project after listening to the window load event.
    `Webcomponents.js` loads the polyfills asynchronously and, once it is ready, it
    will fire a `''WebComponentsReady''` event. So, instead of the load event, we
    should now listen for this new event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, for the last part, you need to document how to use the weather custom element
    and the web components polyfill in a `readme` file so that the rest of the team
    will know how to add it to the project. But this time, the `readme` document will
    be less than a single page and should be simple to maintain! I'll leave the `readme`
    part to you. Bet you are celebrating the completion of the fifth chapter already.
  prefs: []
  type: TYPE_NORMAL
- en: Essential things to know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are a few things to know that will come in handy when working with custom
    elements. Just as we extended the general `HTMLElement` interface, we can also
    extend inbuilt elements, such as the paragraph element `<p>`, the button element
    `<button>`, and so on. This way, we can inherit all the properties and methods
    available in the parent element. For example, to extend the button element, do
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are extending the `HTMLButtonElement` interface instead of the `HTMLElement`
    interface. Also, just as inbuilt elements can be extended, custom elements can
    also be extended, which means we can create another type of widget by extending
    our Weather Widget class.
  prefs: []
  type: TYPE_NORMAL
- en: Even though JavaScript now supports classes and extend classes, it does not
    yet support private or protected class variables and methods like other object-oriented
    languages. Currently, all the class variables and methods are public. Some developers
    add the underscore '_' prefix to variables and methods that need to be private
    so that they don't accidentally use them in the extended class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested in working more with web components, you should probably
    check out the following libraries, which are created to improve the usability
    and workflow of using web components along with inbuilt polyfills:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymer: [https://www.polymer-project.org/](https://www.polymer-project.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X-Tag: [https://x-tag.github.io/](https://x-tag.github.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about extending native inbuilt HTML elements, refer to the following
    tutorial on the Google Developers page: [https://developers.google.com/web/fundamentals/getting-started/primers/customelements](https://developers.google.com/web/fundamentals/getting-started/primers/customelements).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you built a Weather Widget for your team while learning about
    the web components. You created a reusable HTML custom element, which uses shadow
    DOM to abstract CSS from the rest of the document, making the widget easily pluggable
    into the rest of the project. You also learned about some methods, such as geolocation
    and set intervals. But the most important thing you learned in this chapter is
    the advantage of creating independent components in a team environment. By creating
    a reusable weather component, you made the work easier for yourself and for the
    rest of the team.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been working on pure JavaScript. However, there are a lot of
    modern frameworks and libraries today, which makes programming with JavaScript
    more easier, efficient, and scalable to a large extent. Most of the frameworks
    concentrate on organizing your entire application into smaller, independent, and
    reusable components, which we experienced with the web components in this chapter.
    In the next chapter, we are going to build an entire application using the awesome
    UI library created by Facebook-**React.js**.
  prefs: []
  type: TYPE_NORMAL
