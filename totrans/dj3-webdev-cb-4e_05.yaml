- en: Custom Template Filters and Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Following conventions for your own template filters and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to show how many days have passed since a post was
    published
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to extract the first media object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to humanize URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to include a template, if it exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to load a QuerySet in a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to parse content as a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating template tags to modify request query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has an extensive template system with features such as template inheritance,
    filters to change the representation of values, and tags for presentational logic.
    Moreover, Django allows you to add your own template filters and tags to your
    apps. Custom filters or tags should be located in a template-tag library file
    under the `templatetags` Python package in your app. Your template-tag library
    can then be loaded in any template with the `{% load %}` template tag. In this
    chapter, we will create several useful filters and tags that will give more control
    to template editors.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For working with the code of this chapter, you will need the latest stable version
    of Python 3, the MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all the code for this chapter at the `ch05` directory of the GitHub
    repository: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: Following conventions for your own template filters and tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Custom template filters and tags can be confusing and inconsistent if you don''t
    have guidelines to follow. It is essential to have both handy and flexible template
    filters and tags that should serve template editors as much as possible. In this
    recipe, we will take a look at some conventions that you should use when enhancing
    the functionality of the Django template system:'
  prefs: []
  type: TYPE_NORMAL
- en: Don't create or use custom template filters or tags when the logic for the page
    fits better in the view, context processors, or model methods. When your content
    is context-specific, such as a list of objects or an object-detail view, load
    the object in the view. If you need to show some content on nearly every page,
    create a context processor. Use custom methods of the model instead of template
    filters when you need to get some properties of an object that are not related
    to the context of the template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the template-tag library with the `_tags` suffix. When your template-tag
    library is named differently than your app, you can avoid ambiguous package-importing
    problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the newly created library, separate the filters from the tags—for example,
    using comments, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating advanced custom template tags, make sure that their syntax is
    easy to remember by including the following constructs that can follow the tag name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for [app_name.model_name]`: Include this construct to use a specific model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using [template_name]`: Include this construct to use a template for the output
    of the template tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit [count]`: Include this construct to limit the results to a specific
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as [context_variable]`: Include this construct to store the results in a context
    variable that can be reused multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to avoid multiple values that are defined positionally in the template tags,
    unless they are self-explanatory. Otherwise, this will likely confuse template
    developers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make as many resolvable arguments as possible. Strings without quotes should
    be treated as context variables that need to be resolved, or as short words that
    remind you of the structure of the template-tag components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a template filter to show how many days have passed since a post was
    published
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about creation or modification dates, it is convenient to read
    a more human-readable time difference—for example, the blog entry was posted 3
    days ago, the news article was published today, and the user last logged in yesterday.
    In this recipe, we will create a template filter named `date_since`, which converts
    dates to humanized time differences based on days, weeks, months, or years.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create the `core` app, and put it under `INSTALLED_APPS` in the settings, if
    you haven't done so already. Then, create a `templatetags` Python package in this
    app (Python packages are directories with an empty `__init__.py` file).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `utility_tags.py` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This filter used in a template, as shown in the following code, will render
    something similar to yesterday, last week, or 5 months ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can apply this filter to values of the `date` and `datetime` types.
  prefs: []
  type: TYPE_NORMAL
- en: Each template-tag library has a register of `template.Library` type where filters
    and tags are collected. Django filters are functions registered by the `@register.filter`
    decorator. In this case, we pass the `is_safe=True` parameter to indicate that
    our filter will not introduce any unsafe HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the filter in the template system will be named the same as the
    function or another callable object. If you want, you can set a different name
    for the filter by passing the name to the decorator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The filter itself is fairly self-explanatory. At first, the current date is
    read. If the given value of the filter is of the `datetime` type, its `date` is
    extracted. Then, the difference between today and the extracted value is calculated
    based on the `DAYS_PER_YEAR`, `DAYS_PER_MONTH`, `DAYS_PER_WEEK`, or days intervals.
    Depending on the count, different string results are returned, falling back to
    displaying a formatted date if the value is in the future.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If required, we could cover other stretches of time too, as in 20 minutes ago,
    5 hours ago, or even 1 decade ago. To do so, we would add more intervals to the
    existing `diff_map` set, and to show the difference in time, we would need to
    operate on `datetime` values instead of `date` values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a template filter to extract the first media object* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to humanize URLs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to extract the first media object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are developing a blog overview page, and, for each post, you
    want to show images, music, or videos on that page, taken from the content. In
    such a case, you need to extract the `<figure>`, `<img>`, `<object>`, `<embed>`,
    `<video>`, `<audio>`, and `<iframe>` tags from the HTML content of the post, as
    stored on a field of the post model. In this recipe, we will see how to perform
    this using regular expressions in the `first_media` filter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the `core` app that should be set in `INSTALLED_APPS` in
    the settings and should contain the `templatetags` package in this app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `utility_tags.py` file, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the HTML content in the database is valid, and you put the following code
    in the template, it will retrieve the media tags from the content field of the
    object; otherwise, an empty string will be returned if no media is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions are a powerful feature to search or replace patterns of
    text. At first, we define lists of all the supported media tag names, splitting
    them into groups for those that have both opening and closing tags (`MEDIA_CLOSED_TAGS`),
    and those that are self-closed (`MEDIA_SINGLE_TAGS`). From these lists, we generate
    the compiled regular expression as `MEDIA_TAGS_REGEX`. In this case, we search
    for all the possible media tags, allowing them to occur across multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this regular expression works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Alternating patterns are separated by the pipe (`|`) symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two groups within the patterns—first of all, those with both opening
    and closing normal tags (`<figure>`, `<object>`, `<video>`, `<audio>`, `<iframe>`,
    and `<picture>`), and then one final pattern for what are called self-closing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or void tags (`<img>` and `<embed>`).
  prefs: []
  type: TYPE_NORMAL
- en: For the possibly multiline normal tags, we will use the `[\S\s]+?` pattern that
    matches any symbol at least once; however, we do this as few times as possible
    until we find the string that goes after it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, `<figure[\S\s]+?</figure>` searches for the start of the `<figure>`
    tag and everything after it, until it finds the closing `</figure>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, with the `[^>]+` pattern for self-closing tags, we search for any
    symbol except the right-angle bracket (possibly better known as a greater-than
    symbol—that is to say, `>`) at least once and as many times as possible, until
    we encounter such a bracket indicating the closure of the tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `re.MULTILINE` flag ensures that matches can be found, even if they span
    multiple lines in the content. Then, in the filter, we perform a search using
    this regular-expression pattern. By default, in Django, the result of any filter
    will show the `<`, `>`, and `&` symbols escaped as the `&lt;`, `&gt;`, and `&amp;`
    entities, respectively. In this case, however, we use the `mark_safe()` function
    to indicate that the result is safe and HTML-ready, so that any content will be
    rendered without escaping. Because the originating content is user input, we do
    this instead of passing `is_safe=True` when registering the filter, as we need
    to explicitly certify that the markup is safe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in regular expressions, you can learn more about them
    in the official Python documentation at [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to humanize URLs* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template filter to humanize URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web users commonly recognize URLs without the protocol (`http://`) or trailing
    slash (`/`), and, similarly, they will enter URLs in this fashion in address fields.
    In this recipe, we will create a `humanize_url` filter that is used to present
    URLs to the user in a shorter format, truncating very long addresses, similar
    to what Twitter does with the links in tweets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous recipes, we will start with the `core` app that should
    be set in `INSTALLED_APPS` in the settings, which contains the `templatetags`
    package in the app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `FILTERS` section of the `utility_tags.py` template library in the `core`
    app, let''s add the `humanize_url` filter and register it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `humanize_url` filter in any template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The filter uses regular expressions to remove the leading protocol and trailing
    slash, shortens the URL to the given amount of letters (40, by default), and adds
    an ellipsis to the end after truncating it if the full URL doesn't fit the specified
    letter count. For example, for the  `https://docs.djangoproject.com/en/3.0/howto/custom-template-tags/` URL,
    the 40-character humanized version would be `docs.djangoproject.com/en/3.0/howto/cus…`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template filter to extract the first media object* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template, if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to include a template, if it exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django provides the `{% include %}` template tag that allows one template to
    render and include another template. However, this template tag raises an error
    if you try to include a template that doesn't exist in the filesystem. In this
    recipe, we will create a `{% try_to_include %}` template tag that includes another
    template, if it exists, and fails silently by rendering as an empty string otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start again with the `core` app that is installed and ready for custom
    template tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create the `{% try_to_include %}` template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a custom `IncludeNode` class in the same file, extending from
    the base `template.Node`. Let''s insert it just before the `try_to_include()`
    function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Advanced custom template tags consist of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that parses the arguments of the template tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Node` class that is responsible for the logic of the template tag as well
    as the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{% try_to_include %}` template tag expects one argument— that is, `template_name`.
    Therefore, in the `try_to_include()` function, we try to assign the split contents
    of the token only to the `tag_name` variable (which is `try_to_include`) and the
    `template_name` variable. If this doesn't work, a `TemplateSyntaxError` is raised.
    The function returns the `IncludeNode` object, which gets the `template_name`
    field and stores it in a template `Variable` object for later use.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render()` method of `IncludeNode`, we resolve the `template_name` variable.
    If a context variable was passed to the template tag, its value will be used here
    for `template_name`. If a quoted string was passed to the template tag, then the
    content within the quotes will be used for `included_template`, whereas a string
    corresponding to a context variable will be resolved into its string equivalent
    for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will try to load the template, using the resolved `included_template`
    string, and render it with the current template context. If that doesn't work,
    an empty string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two situations where we could use this template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When including a template whose path is defined in a model, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When including a template whose path is defined with the `{% with %}` template
    tag somewhere high in the template context variable''s scope. This is especially
    useful when you need to create custom layouts for plugins in the placeholder of
    a template in Django CMS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, the placeholder can be filled with the `editorial_content` plugins,
    and the `editorial_content_template_path` context variable is then read and the
    template can be safely included, if available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `{% try_to_include %}` tag in any combination with the default
    `{% include %}` tag to include the templates that extend other templates. This
    is beneficial for large-scale web platforms, where you have different kinds of
    lists in which complex items share the same structure as widgets but have a different
    source of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the artist list template, you can include the `artist_item`
    template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This template will extend from the item base, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The item base defines the markup for any item and also includes a `Like` widget,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating template tags to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to load a QuerySet in a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, the content that should be shown on a web page will be defined in
    the context by views. If the content is to be shown on every page, it is logical
    to create a context processor to make it available globally. Another situation
    is when you need to show additional content, such as the latest news or a random
    quote, on some pages—for example, the starting page or the details page of an
    object. In this case, you can load the necessary content with a custom `{% load_objects
    %}` template tag, which we will implement in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we will start with the `core` app, which should be installed and
    ready for custom template tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, to illustrate the concept, let''s create a `news` app with an
    `Article` model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There, the interesting part is the `custom_manager` for the `Article` model.
    The manager can be used to list out random published articles.
  prefs: []
  type: TYPE_NORMAL
- en: Using the examples of the previous chapter, you can complete the app with URL
    configurations, views, templates, and administration setup. Then, add some articles
    to the database using the administration form.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag, and the `Node` class that renders the output of the
    tag or modifies the template context. Perform the following steps to create the
    `{% load_objects %}` template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function that handles the parsing of the template-tag
    arguments, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the custom `ObjectsNode` class in the same file, extending
    from the `template.Node` base. Let''s insert it just before the `load_objects()`
    function, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `{% load_objects %}` template tag loads a QuerySet defined by the method
    of the manager from a specified app and model, limits the result to the specified
    count, and saves the result to the given context variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a simple example of how to use the template tag that
    we have just created. It will load all news articles in any template, using the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is using the `all()` method of the default `objects` manager of the `Article`
    model, and it will sort the articles by the `ordering` attribute defined in the
    `Meta` class of the model.
  prefs: []
  type: TYPE_NORMAL
- en: Next is an example that uses a custom manager with a custom method to query
    the objects from the database. A manager is an interface that provides the database
    query operations to models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each model has at least one manager called `objects`, by default. For our `Article`
    model, we added an extra manager called `custom_manager` with a method, `random_published()`.
    Here is how we can use it with our `{% load_objects %}` template tag to load one
    random published article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the code of the `{% load_objects %}` template tag. In the parsing
    function, there are two allowed forms for the tag—with or without a `limit`. The
    string is parsed, and if the format is recognized, the components of the template
    tag are passed to the `ObjectsNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the `render()` method of the `Node` class, we check the manager's name and
    its method's name. If no manager is specified, `_default_manager` will be used.
    This is an automatic property of any model injected by Django and points to the
    first available `models.Manager()` instance. In most cases, `_default_manager`
    will be the `objects` manager. After that, we will call the method of the manager
    and fall back to an empty QuerySet if the method doesn't exist. If a `limit` is
    defined, we resolve the value of it and limit the QuerySet accordingly. Lastly,
    we will store the resulting QuerySet in the context variable, as given by `var_name`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a model mixin with URL-related methods* recipe in [Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)
    [2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template, if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating template tags to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a template tag to parse content as a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create the `{% parse %}` template tag that will allow
    you to put template snippets in the database. This is valuable when you want to
    provide different content for authenticated and unauthenticated users, when you
    want to include a personalized salutation, or when you don't want to hardcode
    the media paths in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we will start with the `core` app that should be installed and ready
    for custom template tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag, and a `Node` class that renders the output of the
    tag or modifies the template context. Perform the following steps to create the `{%
    parse %}` template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the function parsing the arguments of the template tag,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the custom `ParseNode` class in the same file, extending
    from the base `template.Node`, as shown in the following code (place it just before
    the `parse()` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `{% parse %}` template tag allows you to parse a value as a template and
    render it immediately or store it in a context variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have an object with a description field, which can contain template variables
    or logic, we can parse and render it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to define a value to parse using a quoted string, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the code of the `{% parse %}` template tag. The parsing
    function checks the arguments of the template tag bit by bit. At first, we expect
    the parse name and the template value. If there are still more bits in the token,
    we expect the combination of an optional `as` word followed by the context variable
    name. The template value and the optional variable name are passed to the `ParseNode`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `render()` method of that class first resolves the value of the template
    variable and creates a template object out of it. The `context_vars` are copied
    and a request context is generated, which the template renders. If the variable
    name is defined, the result is stored in it and an empty string is rendered; otherwise,
    the rendered template is shown immediately.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template, if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating template tags to modify request query parameters* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating template tags to modify request query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a convenient and flexible system to create canonical and clean URLs
    just by adding regular-expression rules to the URL configuration files. However,
    there is a lack of built-in techniques to manage query parameters. Views such
    as search or filterable object lists need to accept query parameters to drill
    down through the filtered results using another parameter or to go to another
    page. In this recipe, we will create `{% modify_query %}`, `{% add_to_query %}`,
    and `{% remove_from_query %}` template tags, which let you add, change, or remove
    the parameters of the current query.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, we start with the `core` app that should be set in `INSTALLED_APPS` which contains
    the `templatetags` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, make sure that you have the `request` context processor added to the
    `context_processors` list in the `TEMPLATES` settings under `OPTIONS`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For these template tags, we will be using the `@simple_tag` decorator that
    parses the components and requires you to just define the rendering function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a helper method for putting together the query strings that
    each of our tags will output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the `{% modify_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create the `{% add_to_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s create the `{% remove_from_query %}` template tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All three created template tags behave similarly. At first, they read the current
    query parameters from the `request.GET` dictionary-like `QueryDict` object to
    a new list of (key, value) `query_params` tuples. Then, the values are updated
    depending on the positional arguments and keyword arguments. Lastly, the new query
    string is formed via the helper method defined first. In this process, all spaces
    and special characters are URL-encoded, and the ampersands connecting the query
    parameters are escaped. This new query string is returned to the template.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about the `QueryDict` objects, refer to the official Django documentation
  prefs: []
  type: TYPE_NORMAL
- en: at [https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of how the `{% modify_query %}` template tag
    can be used. Positional arguments in the template tag define which query parameters
    are to be removed, and the keyword arguments define which query parameters are
    to be updated in the current query. If the current URL is `http://127.0.0.1:8000/artists/?category=fine-art&page=5`,
    we can use the following template tag to render a link that goes to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet is the output rendered using the preceding template tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following example to render a link that resets pagination
    and goes to another category, `sculpture`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the output rendered using the preceding template tag would be as shown
    in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `{% add_to_query %}` template tag, you can add, step by step, the
    parameters with the same name. For example, if the current URL is `http://127.0.0.1:8000/artists/?category=fine-art`,
    you can add another category, `Sculpture`, with the help of the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be rendered in the template, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, with the help of the `{% remove_from_query %}` template tag, you can
    remove, step by step, the parameters with the same name. For example, if the current
    URL is `http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`,
    you can remove the `Sculpture` category, with the help of the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be rendered in the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Filtering object lists* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to include a template, if it exists* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a template tag to parse content as a template* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
