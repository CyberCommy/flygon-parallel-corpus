- en: Understanding Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding how libraries work is extremely important to mastering C++ game
    development. Gaining knowledge of how libraries work in C++ will allow you to
    build more robust games and tools. Often the most fundamental ingredients to create
    the core of game engines can be found in easy-to-use, *Redistributable* libraries.
    In this chapter, we will explore the key differences between library types and
    how you can create, build, and consume them. For this chapter, I am going to assume
    you have read through [Chapter 1](89c6ce5a-45ed-4161-aa86-1bc309f69102.xhtml),
    *C++ for Game Development*, and you have a general understanding of the compiling
    and linking process. This chapter consists of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Library build types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a custom shareable library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we use libraries?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries are a key concept in C++ and they are the mechanism that allows the
    language to build modular designs and portable code. By using libraries, we are
    able to create reusable code that we can easily share among multiple programs,
    and with other developers. It allows developers to save time by not having to
    constantly rewrite a particular code chunk over and over again. It also saves
    the developers time by allowing the use of other developers solutions for commonly
    occurring problems. The **Standard Template Library** (**STL**) is a great example
    of this. STL has solutions for a large amount of problems commonly found in C++.
    These solutions include the implementation of data types such as string, containers
    such as vector, and algorithms such as sort. These standard implementations come
    from years of refinement and development. As such they tend to be incredibly performant
    and highly optimized, I would suggest defaulting to using an STD implementation
    over a handwritten implementation where applicable as a general rule. There are
    literally thousands and thousands of libraries available for C++ development.
  prefs: []
  type: TYPE_NORMAL
- en: Library build types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways to create library files. You can use the different
    tools such as an **Integrated Development Environment** (**IDE**). Development
    environment tools such as Visual Studio and XCode, often have templates or starter
    projects included to create library files for various platforms and situations.
    Another somewhat simpler way and the way we will use here is via the command line.
    More specifically the Developer Command Prompt that comes with Visual Studio 2015
    and the terminal program that comes with macOS X. You can obtain a copy of Visual
    Studio 2015 Community edition, a free version for teams of five or fewer developers,
    at the Visual Studio website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the Developer Command Prompt on Windows 8 or higher, hit the windows
    key and start typing `developer command prompt`, and select Developer Command
    Prompt for VS2105 when it appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6814c5c2-614a-4c50-b03c-5462303e892f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To open the Terminal on OS X, open the application launcher and type `Terminal`
    in the search bar at the top of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41b115fc-0c1a-4e85-a412-07398b30ca62.png)'
  prefs: []
  type: TYPE_IMG
- en: To start with, let's create a basic library that we will then be able to consume
    from other programs. In this example, we will just write a simple function that
    will print out the time-honored line `Hello World`. It wouldn't be a book on programming
    without at least one hello world program. Here is the file we will use, I saved
    mine as `hello.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Statically linked libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A static library is a library that is compiled as part of the application itself.
    What this means is that all the code relating to the library is contained in a
    single file, `.lib` on Windows and `.a` on Linux/OS X systems, and it is directly
    linked into the program. A program that incorporates a static library creates
    copies of the code that it requires from the library and places that copy in the
    program where the library implementation was called. It does this for every call
    to the library. This leads to one of the larger drawbacks of using a static library,
    it increases the overall size of the executable. On the other hand, the advantage
    of using a static library is that there are no external dependencies that the
    user requires to run the program. This helps to avoid the issue of the libraries
    on the user's system being the wrong version or having to distribute it with the
    program, which can create a whole pile of problems. You will often hear this common
    issue referred to *Dll Hell*. Another advantage to static libraries are since
    they are linked as part of the build process, this will allow compilers and build
    tools more opportunities to optimize the implementations. A good rule of thumb
    to follow is, for common or standard libraries, ones that most users will have
    (OpenGL or DirectX) use dynamic or shared libraries. For less common libraries
    (GLFW or SDL) you are more likely to use a static library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn our `hello.cpp` file into a static library from the Developer Command
    Prompt, we follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, you need to type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`cl` is the command to compile and link. The `/c` tells the compiler we only
    want to compile and not link our file. Finally, we pass in the file we want to
    compile. This will create an object file, `hello.obj`, that we can then use to
    create our static library file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our object file created, we can use a library building tool
    to create our static library. We use the following command to generate a `.lib`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`lib` is the command to launch the build tool. The `/out:MyLib.lib` tells the
    compiler to name the library build `MyLib.lib`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we list the contents of the directory, you will see we now have our static
    library `MyLib.lib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f897d059-c8f4-44d0-a468-0b6cb07d8f84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now consume our newly created library in other projects. Let''s create
    a very simple program that will use our library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I saved the file as `main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: This program will call the `Hello` function which the compiler we then look
    for an implementation in our linked libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile this program and link our static library, we can use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the compile has finished, we will now have a `main.exe` on Windows in
    our directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/55a06c90-9d02-48d8-88c0-d59f56b3f557.png)'
  prefs: []
  type: TYPE_IMG
- en: On macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS X, you need to type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`g++` is the open source compiler we are using. The flag `-c` tells `g++` to
    output an object file. After the flag, we state which cpp file to use when building
    the object file. This command will produce the file `hello.o`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the macOS X platform, we use the following command to generate an `.a` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`ar`, short for archiver, is the library building tool that we use to create
    our static library. First we set a few flags, `rvs`, which tell the `ar` tool
    how to set up the library archive. We then tell the tool the name of the library
    we are creating, followed by the object file(s) that make up the library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we list the contents of the directory, you will see we now have our static
    library `Mylib.a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eae70479-600b-483e-8dd3-14d18cd1b56a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now consume our newly created library in other projects. Let''s create
    a very simple program that will use our library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I saved the file as `main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: This program will call the `Hello` function which the compiler we then look
    for an implementation in our linked libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compile the program and link our static library with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once the compile has finished, we will now have a `main.exe` on Windows, or
    a main executable file on macOS X, in our directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42e2d0c3-520e-4c5b-8ab2-100dc2587ece.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the size of this executable file for Windows and macOS X. Again, since
    we are statically linking our library, we actually include the necessary parts
    of the library in the executable itself. This eliminates the need to package the
    library with the program separately, which stops the library mismatches. In fact,
    now that the library, `.lib` file, has been compiled into the executable we no
    longer need it and can delete it. Our program will still run, but if we want to
    make any changes to the library, we would have to repeat the preceding steps to
    recompile the library, link it, and add it to our program's build.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically linked libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic or shared libraries are libraries that have their code implementations
    linked at runtime. What this means is that a dynamic library, `.dll` on Windows,
    `.so` on Linux, and `.dylib` on OS X, are the libraries that can be referenced
    in the source code of a program. When a compiler sees these references it looks
    for links in the library implementation. The referenced code is included through
    these created links when the program is launched. When a program uses a dynamic
    library, it only creates references to the code, not any copies of the code. This
    is one of the biggest advantages of using dynamic libraries, since they are only
    referenced hence they do not add to the overall size of the executable like a
    static library does. Another big advantage of using a dynamic library is maintainable
    or modification. Since the library is included at runtime, you can make updates
    or modifications without having to recompile the whole program. This is great
    for *patch* style updates and for allowing the modifications by the user themselves.
    The biggest disadvantage, is the one I mentioned earlier. Using dynamic libraries
    usually requires you to include the library with the program in some sort of package
    or installer. This of course could lead to mismatches and the dreaded Dll Hell.
  prefs: []
  type: TYPE_NORMAL
- en: For dynamic or shared libraries, we have to make a few modifications and follow
    slightly different steps for compilation and linking. To begin with, we will have
    to change our library file to let the compiler know that we would like to share
    certain parts with other programs. We do this, on the Microsoft platform, with
    `__declspec` or declaration specification. Passing the `dllexport` parameter to
    `__declspec` lets the compiler know that this function or even classes should
    be exported as part of the dynamic linked library. On the OS X platform, we also
    use a type of declaration to let the compiler know that the classes or functions
    are to be exported. Here we use `__attribute__((visibility("default")))` in place
    of `__declspec`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and linking dynamic libraries on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the step for compiling and linking dynamic libraries on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hello.cpp` file would now look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the function specified for export, we can compile the file
    into a dynamically shared library.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, we can create a `.dll` from the developer console prompt with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again `cl` is the command to launch the compiler and linker. The `/LD` tells
    the compiler that we want to create a dynamically linked library. The `/FeMyDynamicLib.dll`
    sets the name of the library `/Fe` being the compiler option and `MyDynamicLib.dll`
    being the name. Finally, again, we pass in the file(s) we want to use to create
    the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler is finished, and we list the directory, we will now have
    both `MyDynamicLib.lib` and `MyDynamicLib.dll`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce4c0d05-71c5-48e9-97ba-0eef07fb6301.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing you may have noticed is that this version of the `.lib` file
    is much smaller than in the previous static library example. This is because the
    implementation is not stored in this file. Instead, it acts as a pointer to the
    actual implementation in the `.dll` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can link and build our program with our newly created library exactly
    like the previous example with the following commands (on Windows):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So now if we run the program and will see the line `Hello World Dynamically!`
    displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e5c8886-ccfd-4b55-8826-5927d003cda7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we do a listing of the directory now, we will notice that the new main executable,
    like the `.lib` file from this example, is much smaller than the previous version
    that used the static library. This, again, is because we do not include the needed
    parts from the library at build time. Instead, we are loading them as needed at
    runtime, dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e50cd47-2b0c-4d89-b481-e475d34959d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the bonuses I mentioned earlier is the fact that when you make changes
    to a dynamically linked library, you do not have to recompile the entire program;
    we only have to recompile the library. To see this in action, let''s make a small
    change to the `hello.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can recompile our library with the same command as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add our new changes, and we can see them take effect without recompiling
    `main.exe`, and simply running it instead. The output will now be the two lines:
    `Hello World Dynamically!` and `Version 2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f57f7e6-bf83-4448-94b4-8978166b2bb4.png)'
  prefs: []
  type: TYPE_IMG
- en: This makes upgrading very easy, but can also quickly lead Dll mismatching on
    machines without the updated library, often referred to as Dll Hell.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and linking dynamic libraries On macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hello.cpp` file would now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a `.dylib` from the terminal shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use the `g++` compiler and set a flag to create a dynamic library file,
    `-dynamiclib`. The next flag `-o MyDynamicLib.dylib`, tells the compiler what
    to name the outputted file. Finally, we specify the file(s) to use when creating
    the library. If you list the directory now, you will see the newly created `MyDynamicLib.dylib`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1018c29-10de-473a-ada8-8ca306a3afea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can link and build our program with our newly created library exactly
    like the previous example with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So now if we run the program and will see the line `Hello World Dynamically!`
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb956f82-2de2-49f2-8bad-f813baa73d30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we do a listing of the directory now, you will notice that the new main
    executable, like the `.lib` file from this example, is much smaller than the previous
    version that used the static library. This, again, is because we do not include
    the needed parts from the library at build time. Instead, we are loading them
    as needed at runtime, dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41fa7209-5a9f-4fc2-8560-4b2f1d32b8be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the bonuses I mentioned earlier is the fact that when you make changes
    to a dynamically linked library, you do not have to recompile the entire program;
    we only have to recompile the library. To see this in action, let''s make a small
    change to the `hello.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can recompile our library with the same command as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Output from the preceding command will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43abc55f-b279-4085-bf3b-8067abe90703.png)'
  prefs: []
  type: TYPE_IMG
- en: This makes upgrading very easy, but can also quickly lead Dll mismatching on
    machines without the updated library, often referred to as Dll Hell.
  prefs: []
  type: TYPE_NORMAL
- en: Header only or source libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last way to share libraries that I want to mention, and that is
    simply sharing the source or header implementation. This is an entirely legitimate
    way to share libraries and is very common among open source and smaller projects.
    It has the clear bonus of providing the source for modification and can easily
    allow the consuming developer to pick and choose which parts they would like to
    implement in their project. This can also be seen as a drawback, though, as now
    your source code is available publicly. By offering your code openly and freely,
    you give up a lot of control over its use and depending on the licensing could
    have little or no proprietary claims to the solution it implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change our little example to a header only implementation, we would simply
    change the `hello.cpp` file into a header file, `hello.h`, and do all the function''s
    implementation inside. Our new `hello.h` file will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then to consume the header library, we will include it in the `main.cpp` file
    just like any other header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using the header only implementation, we don't have the worry of
    linking the library during the build process. We can compile the program from
    the developer console prompt with the following command.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, you can run the main executable and see similar a hello world
    message, `Hello World Header!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea937f03-5695-4bb1-8c9b-99b53d29a764.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On macOS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, you can run the main executable and see similar a hello world
    message, `Hello World Header!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f6cfc05-c84b-42f4-aacf-35f27b59af36.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a custom shareable library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to create your own custom library is an extremely valuable
    skill. Building a strong understanding of the steps needed to create, build, and
    consume libraries will allow you to create more capable systems and solutions.
    In the next section, we dive a little deeper and take a look at how you can create
    then build and consume a shareable library project in a managed development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, I am going to stick with using Visual Studio for Windows,
    and XCode for macOS X. While some of the exact details will be different in each
    development environment, it should not be too difficult to extrapolate the steps.
    You can find the full source for this example in the `Chapter02` folder of the
    code repository.
  prefs: []
  type: TYPE_NORMAL
- en: To start we will create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Windows, we can do this by going to File|New|Project, then expanding the
    Visual C++ drop down and finally selecting Win32 Console Application. I named
    my new project `MemoryMgr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cfc23a9-839d-4a3f-a4ee-33bf3e4c5572.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you select OK, the Win32 Application Wizard dialog will pop up. Click
    on Next to move the dialog to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88990b87-f00e-4255-a007-ff58e426161e.png)'
  prefs: []
  type: TYPE_IMG
- en: On this dialog page, we are presented a few different application settings.
    For our Application type, we are going to select DLL. This will create a `.dll`
    and accompanying `.lib` file that we can then share and consume. The reason we
    are picking a dynamic or shared library as opposed to a static library is because
    I can demonstrate how to build and compile a shareable library. This is a simplistic
    memory manager library that in most cases would be included in a suite of other
    utility libraries. We could easily modify this library to be static, see the previous
    section for an explanation on how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the option for Empty project, this will give us a completely blank project
    from which we can build our library. This will also gray out most of the other
    options, such as the Precompiled header in the Additional options. This is a commonly
    used option to help speed up the compilation of large projects by calling all
    or most needed header files in a single header file, which you then add as a single
    header to other implementation files. You can leave Security Development Lifecycle
    (SDL) checks selected as it will not cause any issues. Click on Finish to exit
    the dialog and open the new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2024de63-431e-4619-b6b7-4229a5f99c87.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the project is loaded, we are greeted with a blank editor window and empty
    solution explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project on macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create a new project by going to File|New|Project, then selecting OS X from
    the platform list, and then Library from the template choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0dad365-da6e-4ee8-a462-52a233b808d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on Next, a dialog with project setting options will appear.
    These options include the Product Name, which I chose `MemoryMgr` for, Organization
    Name and Organization Identifier, which I left as the default choices. In a production
    setting, you would want to adjust these to match your project. The last two options
    are Framework and Type. For the Framework, select STL (C++ Library) this is the
    template used when working with a library that will include access to the STL.
    For Type select Dynamic, there is also the option for a static library project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d982505a-7bde-41da-a7e1-b3ae121f3cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Our next step is to create the source files that we will need for the library.
    In this example, we will only be creating one class consisting of a single header,
    `.h`, and implementation file, `.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating source files on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can add this class quickly in Visual Studio using the Add | Class... dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the MemoryMgr project in the Solution Explorer; navigate to
    Add|Class from the menu list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9af827e-b124-4e51-9211-9244e4078f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: A new screen will pop up with a few options for creating new classes; we are
    just going to use the default generic C++ Class option.
  prefs: []
  type: TYPE_NORMAL
- en: Select Add to advance to the next dialog screen. We are now on the Generic C++
    Class Wizard screen. In the Class name section, add the name of the new class
    you are creating, in my case I called it `MemoryMgr`. When you enter the class
    name, the wizard will auto populate the .h file and .cpp file for you. Since this
    is not a class that is inheriting, we can leave the Base class section empty.
    We will leave Access at the default setting of public, and finally we will leave
    the Virtual destructor and Inline options unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Finish to add the class to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61f33ca0-b7bd-4717-ac25-ba639fb1815c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, this would be the exact same as if we simply typed out the full
    export specifier like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Creating source files on macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This step is already done for us by default. The project creation wizard automatically
    includes an implementation file, `.cpp` and a Header File, but in this case the
    header file''s extension is `.hpp`. The automatically created files also have
    a bunch of stubbed code to help get things started. In our example case, to make
    things more coherent, we are going to delete this stubbed code and remove both
    `.hpp` files. Instead we are going to create a new `.h` file and insert our own
    code. To create a new `.h` file is quite simple, navigate to File|New|File. In
    the new file dialog, select OS X from the platform list on the left and Header
    File from the type selection window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e433128c-2c31-4a14-8277-9ab9bab8eaec.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the Next button will bring up the file save dialog. Save the file
    as `MemoryMgr.h`, notice I specified `.h` as the extension. If you do not specify
    the extension, the wizard will default to `.hpp`. Also of note, make sure the
    target project is selected at the bottom of the dialog, this will make sure it
    is counted as part of the XCode project solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f48dc14e-33c7-458b-a7ef-a0aa29452e86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You project layout should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3ee73e6-8992-42f3-bec3-939aaf32eb7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it''s time for the code. We will start with the `MemoryMgr` header file,
    `MemoryMgr.h`. In this file, we will declare all the functions and variables we
    will be using along with the definitions that will provide access to our dynamic
    library. Here is `MemoryMgr.h` with the comments removed for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The full file contents are available in the code repository in the `Chapter02` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The first step we take when creating the new dynamic library is a helpful shortcut
    that allows us to save a few keystrokes and simply the creation of exported classes,
    functions, or variables. Using `ifdef` directives, we can first create an identifier
    for our memory manager, `MEMORYMGR_EXPORTS`, then for the target platforms, `_WIN32`
    for Windows and `__APPLE__` for macOS X. Inside the `ifdef` directives for each
    platform, we can then add defines for the macro `EXPORT`, on Windows these are
    for `dllexport` and `dllimport`. This is a standard way of using macros to make
    the process of exporting and importing easier. With these macros in place, any
    project that includes this file will see the exposed functions as being imported
    whereas the dynamic library will see anything defined with this macro as being
    exported. This means we can now simply use `EXPORT` in place of `_declspec(dllexport)`
    or `__attribute__((visibility("default")))` when specifying what should be made
    available to others in the dynamic library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step for creating our memory manager is to create a couple of `struct`
    for our `Block` and `Heap` objects. A block is a slice or block of memory where
    we will store individual objects. The `Heap` is a collection of these `Block`
    contained in a contiguous container of the memory. The `Block` struct simply holds
    a pointer to the next `Block` pointer; this creates a single linked list for the
    `Block` objects in each `Heap`. The `Heap` struct also holds a pointer to the
    next `Heap` in memory, which again creates a single linked list for the `Heap`
    objects. The `Heap` struct also contains a little helper function that returns
    the next block in the `Heap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `Heap` and `Block` structs in place, we can move on to
    defining the actual memory manager class, `CMemoryMgr`. This is where the define
    we created earlier comes in handy. In this case, we use `EXPORT` to specify that
    we want the entire class to be exported in our dynamic library. When we export
    the class this way, the class access is exactly like any other class. That means
    that all the `private`, `protected`, and `public` objects continue to have the
    same access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'While in our simple example, it makes sense to export the entire class, that
    might not always be the case. If we want to export just a function or variable,
    we could do that with our created `EXPORT` macro like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this would be the exact same as if we simply typed out the full
    export specifier like so (on macOS X):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'More about the `MemoryMgr` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to export class, functions, and variables, let's continue
    on with a quick look at the rest of the `MemoryMgr` header file. To begin with,
    we define our public methods that will be available when calling our library.
    These include the constructor, which takes three parameters; `dataSize`, the size
    of the objects for each block, `heapSize`, the size of each memory heap, and `memoryAlignmentSize`,
    this is the variable we use to shift the objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting the objects in memory means that we will always use a set amount memory
    to hold an object no matter the size. We do this so that the objects are aligned
    in such a way that we can reduce the amount of calls to the actual memory hardware
    which of course will increase performance. This is often the main reason developers
    will use a custom memory manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the destructor which takes no parameters, followed by the `Allocate`,
    `Deallocate`, and `DeallocateAll`, which do exactly what their names imply. The
    only function that takes a parameter is the `Deallocate` function, which takes
    a pointer to the memory that you wish to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These functions are the only ones exposed through our library, and, in this
    simple example, can be considered a basic implementation interface for this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the public declarations come, of course, the private declarations are
    needed for our library. They begin with three static constants that hold simple
    hexadecimal patterns we will use. This will help us identify each memory segment
    while debugging and provide a simple mechanism to check that we are working on
    the right segment at the right time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the `private` methods we use to do the heavy lifting in our library.
    The helper function `GetNextBlock` will return the next linked `block` in the
    `Heap`. The `OverWriteHeap` function takes a pointer to heap that will write to
    that specific `Heap`. An `OverWriteBlock` takes a pointer to a block to write
    to, and an `OverWriteAllocated` again takes a `Block` pointer that is allocated
    to write over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `private` methods, we have the member variables that will store the
    various types of data needed for our memory manager library. The first two are
    lists of pointers that we use to hold the heaps we have created and the free blocks
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a group of unsigned integers that hold various pieces of data.
    Since the names of the variables are pretty self-explanatory, I won''t go through
    each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our implementation file (`MemoryMgr.cpp`), since in this example we
    are exporting the entire class we do not have to include anything special, all
    of the publicly access contents will be available to any projects using our library.
    If we instead decided to export only selected functions and variables, instead
    of the whole class, we would have to use the `EXPORT` macro we created to specify
    that they should be exported in our library. To do that, you would simply add
    `EXPORT` in front of the implementation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To save time and space here, I am not going to go through each line of the `MemoryMgr.cpp`
    implementation. The file is well documented and should explain the simple mechanics
    of the memory manager well enough. Although it is simple, this library is a great
    starting point for building a more robust memory manager system to suit any project's
    particular needs.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you or anyone else can use your custom library, you need to build it.
    There are a few different ways we can accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example from the preceding section, we used Visual Studio 2015, and
    in this case building the library is quite simple. For example, to build the `MemoryMgr`
    library, you can right-click on the Solution ''MemoryMgr'' in Solution Explorer
    and select Build Solution, or use the keyboard shortcut *Ctrl *+ *Shift *+ *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c180a9a9-4847-445b-a612-389e9621c9a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create the needed `MemoryMgr.dll` and `MemoryMgr.lib` files in the
    project''s output folder under either Debug or Release, depending on the build
    setting selected. Another way we can build our library is with the developer command-line
    tools that we discussed in the first part of this chapter. In this case, we could
    simply change directories to the project file and run the `cl` command with the
    library name and input files included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Again this will create the `MemoryMgr.dll` and `MemoryMgr.lib` files that are
    needed to use our library in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build an XCode library project is quite easy. You can simply select Product
    from the toolbar and the click on Build or use the keyboard shortcut Command +
    *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c237e7-bf12-4a29-a504-48ee49020189.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create the `MemoryMgr.dylib` file that we will need when including
    the library in other projects. Another way we can build the library is with the
    terminal shell the we looked at earlier in the chapter. In this case, we could
    simply change directories to the project file and run `g++` with the library name
    and input files included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Building dynamic library on Windows using .def file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore the options of building the dynamic library using either only
    `.def` file or by using linker options as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using only .def file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one more way that I want to mention that we can use to build our dynamic
    library, and that is with the use of a `.def` file. A module-definition or `.def`
    file is a text file that contains module statements that describe the exported
    attributes of the dynamic library. With a `.def` file, you do not need to create
    any macros or use the `__declspec(dllexport)` specifier to export the DLL''s functions.
    For our `MemoryMgr` example, we can create a `.def` file by opening a text editor
    and adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell the compiler that we wish to export these three functions: `Allocate`,
    `Deallocate`, and `DeallocateAll`. Save the file as a `.def` file; I called mine
    `MemoryMgr.def`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can recompile the library using the module definition file, we have
    to make a few changes to the source code of `MemoryMgr`. First, we can remove
    the macros we created and remove the `EXPORT` before the `CMemoryMgr` class definition.
    Instead of needing the macro or `_declspec(dllexport)` specifier, the `.def` file
    we created earlier will handle telling the compiler what should be exported.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a dynamic library using a module definition file on the Windows
    platform, we have a couple of options. We could compile the library using the
    developer console, much like we did earlier, but with an extra option to specify
    the `.def` file. The command to compile the `MemoryMgr` library from the console
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `/DEF:filename` is the flag that tells the compiler to use the specified
    module definition file to build the library. This command will produce a dynamic
    library called `MemoryMgr2.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting linker options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second option we have to build the dynamic library using a `.def` file is
    by setting linker options in the Visual Studio development environment. It's fairly
    straightforward to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we open the Property Pages dialog box by right-clicking on the project''s
    name in Solution Explorer or by using the keyboard shortcut *Alt* + *Enter* with
    the project highlighted. With the Property Pages dialog open, select Linker, click
    on the Input property page, and finally, enter the name of the `.def` file in
    the Module Definition File property. The end result should look something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b7448bd-48ac-4dd6-baef-0e3faa530d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now when you build your dynamic library project, the compiler will use the `MemoryMgr.def`
    file to determine which attributes should be exported.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how we can consume this and other libraries when working
    with Visual Studio and XCode projects.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing and consuming libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our custom library built, we can start to use it in other
    projects. As we saw earlier in the chapter, we can link the dynamic and static
    libraries using the command-line compiler tools. This is OK if you have just a
    few libraries or have maybe created a custom build script, but in most cases when
    working with an IDE like Visual Studio, there are simpler ways to manage. In fact,
    adding libraries to a project in Visual Studio can be quite easy. To add the library
    first, we open the Property Pages dialog again, right-click and go to Properties
    or *Alt* + *Enter* with the project selected in the Solution Explorer. Next, expand
    Linker and select Input. At the top of the dialog on the Additional Dependencies
    property, click on the drop down and select Edit. This will bring up a dialog
    like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3702c26-2d32-464b-be0f-974942428511.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this dialog''s property window, we can specify the libraries we wish to
    include at compile time. We include the `.lib` file regardless of whether it is
    a dynamic library or a static library. If you have set up your library directories
    in the VC++ Directories folder under Configuration Properties, you can simply
    use the library name like this: `MemoryMgr.lib`. You can also include the libraries
    by specifying the path to the library such as `C:\project\lib\MemoryMgr.lib`.
    This property also accepts macros, which are important to use since moving the
    project to another directory would break the include otherwise. Some of the macros
    you can use are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$(SolutionDir)`: This is the top solution directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$(SourceDir)`: This is the directory of the source for the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$(Platform)`: This is the platform that is selected (Win32, x64, or ARM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$(Configuration)`: This is the configuration that is selected (Debug or Release)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means if I have a few libraries for each platform and configuration in
    a folder called `lib` located in the solution directory, I can save myself a bunch
    of work by using a macro like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now if I switch platforms or configurations, I don't have to go back into the
    property pages and make changes each time.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of linking the library, but there is one more piece needed when
    consuming or sharing a library. In the first set of examples of this chapter,
    you must have noticed that when creating the little console program to demonstrate
    the use of the library, I used a forward declaration to specify the implementation
    of the `Hello` function from the library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While this works in small examples like this one, if you are using libraries
    with multiple attributes, forward declarations will become quite tedious. In order
    to make use of libraries in your project, you will often have to include the definition
    files, the headers. This is why when you see libraries shared they will usually
    have an `Include` folder that has all the header files needed to work with that
    library. In the case of our `MemoryMgr` library, that would mean if I wanted to
    use it in a new project or share it with another developer I would include three
    files. The `MemoryMgr.dll` library, is actually a dynamic library. The `MemoryMgr.lib`
    library, is the library file used for linking. Lastly, I would also need to include
    the `MemoryMgr.h` file, the file that includes all the attribute definitions for
    my library.
  prefs: []
  type: TYPE_NORMAL
- en: Since most libraries you will work with have more than one header file, simply
    copying them into your project can get messy. The good news is, like most IDEs,
    Visual Studio has configuration settings that allow you to specify which folders
    house the files you wish to include in your project. Setting these configuration
    options is again quite simple. First, open the Property Page dialog, *Alt *+ *Enter*
    with the project highlighted in the Solution Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on the C/C++ folder to expand it. Then select the General section.
    In this property window at the top, you will see Additional Include Directories,
    select the drop down from this property and click on Edit. This will bring up
    a dialog like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5f043fa-4637-46db-8bed-5141be2c15d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this dialog window, we can add a new line by clicking on the add folder
    icon, or by using the keyboard shortcut *Ctrl* + *Insert*. You can use the folder
    explorer dialog to find and select the folders you need to include, but this property
    also supports macros, so a much better way to specify the needed include folders
    would be by using macros. If we had a folder in the main solution directory called
    Include that had a folder inside it called `MemoryMgr`, we could include that
    folder using the following macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you select OK and Apply to close the Property Pages dialog, you can include
    the header files just like any other header file in your project. In the case
    of our `MemoryMgr` folder we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the filesystem hierarchy is respected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the advanced topic of shareable libraries. We looked
    at the different types of libraries available. We walked through the various ways
    you can create your own sharable libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to use this advanced library knowledge to
    build an asset management pipeline.
  prefs: []
  type: TYPE_NORMAL
