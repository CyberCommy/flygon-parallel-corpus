- en: Caching the Current Folder Structure Using Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to introduce an official Vue plugin called Vuex.
    Vuex is a state management pattern and library that allows you to have a centralized
    store for all your Vue components, irrelevant of whether they are child components
    or a Vue instance. It gives us a centralized, simple way of keeping our data in
    sync across the whole app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is going to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data from the Vuex store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Vuex with our Dropbox app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching the current Dropbox folder contents and loading data from the store
    if required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of requiring custom events and the `$emit` functions on every component,
    and trying to keep components and child components up to date, every part of your
    Vue app can update the central store, and others can react and update their data
    and state based on that information. It also gives us a common place to store
    data so, rather than trying to decide whether it is more semantic to place the
    data object on the component, a parent component, or the Vue instance, we can
    use the Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex is also integrated into the Vue dev tools—something that is covered in Chapter
    12, *Using Vue Dev Tools and Testing Your SPA*. With the integration of the library,
    it makes debugging and viewing the current and past states of the store easy.
    The dev tools reflect state changes, or data updates, and allow you to inspect
    each part of the store.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, Vuex is a state management pattern, which is the source of truth
    for your Vue app. For example, keeping track of a shopping basket or logged in
    user is vital for some apps and could wreak havoc if this data got out of sync
    between components. It is also impossible to pass data between child components
    without using the parent to handle the exchange. Vuex removes this complication
    by handling the storage, mutation, and actions on the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02e6fa58-a9f3-4654-88d4-7747265331a2.png)'
  prefs: []
  type: TYPE_IMG
- en: When initially using Vuex, it may seem quite verbose and like overkill for what
    is required; however, this is a great example of getting to grips with the library.
    More information about Vuex can be found in their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: For our Dropbox app, the Vuex store can be utilized to store the folder structure,
    file list, and download links. This means if a user visits the same folder more
    than once, the API will not need to be queried as all the information is stored
    already. This will speed up the navigation of the folders.
  prefs: []
  type: TYPE_NORMAL
- en: Including and initializing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vuex library is included the same way as Vue itself. You can either use
    a hosted version by using the previously mentioned unpkg service ([https://unpkg.com/vuex](https://unpkg.com/vuex))
    or you can download the JavaScript library from their [https://github.com/vuejs/vuex](https://github.com/vuejs/vuex).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new `<script>` block to the bottom of your HTML file. Ensure the Vuex
    library is included after your `vue.js` library but before your application JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are deploying an app with several JavaScript files, it is worth investigating
    whether it is more efficient to combine and compress them into one file or configure
    your server to use HTTP/2 push.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the library included, we can initialize and include the store within our
    app. Create a new variable called a `store` and initialize the `Vuex.Store` class,
    assigning it to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the Vuex store initialized, we can now utilize its functionality with the
    `store` variable. Using `store`, we can access the data within and alter that
    data with mutations. With an independent `store`, many Vue instances could update
    the same `store`; this may be desired in some instances, but, it could be an undesirable
    side effect in others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To circumvent this, we can associate a store with a specific Vue instance.
    This is done by passing the `store` variable to our Vue class. Doing this also
    injects the `store` instance into all our child components. Although not strictly
    required for our app, it''s good practice to get into the habit of associating
    the store with the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the `store` variable added, we can now access the `store` in our components
    using the `this.$store` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help us get to grips with how to use the store, let''s move the `path` variable
    that is currently stored on the parent Vue instance. Before we start writing and
    moving code, there are a few phrases and words that are different when using the
    Vuex store and we should familiarize ourselves with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state`: This is the store''s equivalent of the data object; the raw data is
    stored within this object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getters`: These are the Vuex equivalent of computed values; the function of
    the `store` that may process the raw state value before returning it for use in
    a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutations`: Vuex doesn''t allow modification of the state object directly
    outside of the `store` and this must be done via a mutation handler; these are
    functions on the `store` that then allow the state to be updated. They always
    take `state` as the first parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These objects belong directly in the `store`. Updating the `store`, however,
    is not as simple as calling `store.mutationName()`. Instead, we must call the
    method by using a new `commit()` function. This function accepts two parameters:
    the name of the mutation and the data being passed to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although initially difficult to understand, the verbose nature of the Vuex
    store allows for powerful capabilities. An example of the store in action, adapting
    the original example from Chapter 1, *Getting Started with Vue.js*, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `store` example includes the `state` object, which is our raw
    data store; a `getters` object, which includes our processing of the state; and
    finally, a `mutations` object, which allows us to update the message. Notice how
    both the `message` getter and the `updateMessage` mutation have the store's state
    as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this `store`, you could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `{{ message }}` computed function, we have retrieved the raw, unprocessed
    message from the state object and used the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is literally accessing the `store`, then the state object, followed by
    the message object key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar vein, the `{{ formatted }}` computed value uses the getter from
    the `store`, which lowercases the string. This is retrieved by accessing the `getters`
    object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Updating the message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the message, you need to call the `commit` function. This accepts
    the method name as the first parameter with the payload, or data, being the second.
    The payload can be either a simple variable, an array, or an object if several
    variables need to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `updateMessage` mutation in the `store` accepts a single parameter and
    sets the message to equal that, so to update our message the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This can be run anywhere in the app and will automatically update the previous
    values used, as they all rely on the same `store`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning our message getter now would return VUEX Store, as we've updated the
    state. With that in mind, let's update our app to use a path variable in the `store`,
    rather than the Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Vuex store for the folder path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in using the Vue store for our global Dropbox path variable
    is to move the data object from the Vue instance to the `Store`, and rename it
    to `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create a mutation to allow the path to be updated from the
    hash of the URL. Add a `mutations` object to the store and move the `updateHash`
    function from the Vue instance—don''t forget to update the function to accept
    the store as the first parameter. Also, change the method so it updates `state.path`
    rather than `this.path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By moving the path variable and mutation to the store, it makes the Vue instance
    significantly smaller, with both the `methods` and `data` objects being removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We now need to update our app to use the path variable from the `store`, instead
    of on the Vue instance. We also need to ensure we call the `store` `mutation`
    function to update the path variable instead of the method on the Vue instance.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the path methods to use store commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start with the Vue instance, changing `this.Updatehash` to `store.commit('updateHash')`
    instead. Don't forget to also update the method in the `onhashchange` function.
    The second function should reference the `store` object on our Vue instance, rather
    than the `store` directly. This is done by accessing the Vue instance variable,
    `app`, and then referencing the Vuex store in this instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When referring to the Vuex store on a Vue instance, it is saved under the variable
    as `$store`, regardless of the variable name it was initially declared against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the path variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to update the components to use the path from the `store`, rather
    than one passed down through components. Both `breadcrumb` and `dropbox-viewer`
    need to be updated to accept this new variable. We can also remove unnecessary
    props from the components.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the breadcrumb component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the HTML, remove the `:p` prop, leaving a simple breadcrumb HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the `props` object from the component in the JavaScript file.
    The `parts` variable will also need to be updated to use `this.$store.state.path`,
    instead of `this.p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Updating the dropbox-viewer component to work with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the `breadcrumb` component, the first step is to remove the HTML prop
    from the view. This should simplify the view of your app even more and you should
    be left with a handful of HTML tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to clean up the JavaScript, removing any unnecessary function
    parameters. Remove the `props` object from the `dropbox-viewer` component. Next,
    update the `filesListFolder` Dropbox method located inside `getFolderStructure` to
    use the store path, instead of using the path variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As this method is now using the `store`, instead of a function parameter, we
    can remove the variable from the method declaration itself, along with removing
    it from the `updateStructure` method and from whenever these two functions get
    called. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We do, however, still need to store the path as a variable on this component.
    This is due to our `watch` method, which calls the `updateStructure` function.
    To do this, we need to store our path as a computed value, rather than a fixed
    variable. This is so it can dynamically update when the `store` updates, rather
    than a fixed value when the component gets initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a computed object on the `dropbox-viewer` component with a method called
    `path`—this should just return the `store` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have it as a local variable, so the Dropbox `filesListFolder` method
    can be updated to once again use `this.path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly-updated `dropbox-viewer` component should look like the following.
    Viewing the app in your browser, it should appear as though nothing has changed—however,
    the inner workings of the app are now reliant on the new Vuex store, rather than
    a variable stored on the Vue instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Caching the folder contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have Vuex in our app and are utilizing it for the path, we can begin
    to look at storing the contents of the currently-displayed folder so that if the
    user returns to the same place, the API does not need to be queried to retrieve
    the results. We are going to do this by storing the object returned by the API
    the Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: When the folder gets requested, the app will check whether the data exists in
    the store. If it does, the API call will be omitted and the data loaded from the
    storage. If it doesn't exist, the API will be queried and the results saved in
    the Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to separate out the data processing into its own method. This
    is because the files and folders are going to need to be split regardless of whether
    the data comes from the store or API.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new method in the `dropbox-viewer` component titled `createFolderStructure()` and
    move the code from inside the `then()` function, following the Dropbox `filesListFolder` method.
    Call the new method inside this function instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your two methods should now look like the following, and your app should still
    be working as it was before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using promises, we can use `createFolderStructure` as the action for the API
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to store the data we are processing. To do this, we are going
    to take advantage of the ability to pass an object to the `commit` function of
    the `store` and use the path as the key in the storage object. Rather than nest
    the file structures, we are going to store the information in a flat structure.
    For example, after we''ve navigated through a few folders, our store would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There will be several transformations made to the path to make it object key-friendly.
    It will be lowercased and any punctuation will be removed. We will also replace
    all spaces and slashes with hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create an empty object in the Vuex store state object titled `structure`;
    this is where we are going to store the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create a new `mutation`, to allow us to store the data as we
    load it. Create a new function inside the `mutations` object. Call it `structure`; it
    needs to accept the `state` as a parameter, plus a `payload` variable which will
    be an object passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The path object will consist of a `path` variable, plus the `data` returned
    from the API. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this object being passed in, we can use the path as the key and the data
    as the value. Store the data with a key of the path inside the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now commit this data at the end of our new `createFolderStructure` method
    in our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will now store each folder's data when navigating through the app. This
    can be verified by adding a `console.log(state.structure)` inside the structure
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Although this works as is, it would be good practice to sanitize the path when
    using it as the key in an object. To do this, we are going to remove any punctuation,
    replace any spaces and slashes with hyphens, and change the path to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new computed function called `slug` on the `dropbox-viewer` component.
    The term slug is often used for sanitized URLs and originates from newspapers
    and how editors used to reference stories. This function will run several JavaScript
    `replace` methods to create a safe object key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The slug function carries out the following operations. An example path of
    `/images/iPhone/mom''s Birthday - 40th` would be affected in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the string to lowercase: `/images/iphone/mom's birthday - 40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any slashes at the beginning and end of the path: `images/iphone/mom
    birthday - 40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any spaces with hyphens: `images/iphone/mom-birthday---40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any slashes with hyphens: `images-iphone-mom-birthday---40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace any multiple hyphens with just a singular hyphen: `images-iphone-mom-birthday-40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, remove any punctuation: `images-iphone-moms-birthday-40th`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the slug now created, we can use this as the key when storing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With our folder contents now being cached in the Vuex store, we can add a check
    to see whether the data exists in the store and if it does, load it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data from the store if it exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loading our data from the store requires a couple of changes to our code. The
    first step is to check whether the structure exists in the `store` and if it does,
    load it. The second step is to only commit the data to storage if it is new data—calling
    the existing `createFolderStructure` method will update the structure but also
    re-commit the data to storage. Although not detrimental to the user as it currently
    stands, unnecessarily writing data to the `store` could cause issues when your
    app grows. This will also help us when we come to precaching the folders and files.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the data from the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a `store` is a JavaScript object and our `slug` variable is a consistent
    computed value on our component, we can check whether the object key exists with
    an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the flexibility to load the data from the `store` if it exists,
    using the `createFolderStructure` method and, if not, trigger the Dropbox API
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `getFolderStructure` method to include the `if` statement and add
    the method call if the data exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The path to the data is quite long and can make our code unreadable. To make
    it easier to understand, assign the data to a variable, which allows us to check
    whether it exists and returns the data with cleaner, smaller, and less repeatable
    code. It also means we only have to update one line if the path to our data changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Only storing new data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the current `createFolderStructure` method both displays
    the structure and caches the response in the `store`, thus re-saving the structure
    even when the data is loaded from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method that the Dropbox API will fire once the data has loaded.
    Call it `createStructureAndSave`. This should accept the response variable as
    its only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move the `store` `commit` function from the `createFolderStructure`
    method into this new one, along with a call to fire the existing method with the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, update the Dropbox API function to call this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Open your app in the browser and navigate through the folders. When you navigate
    back up using the breadcrumb, the response should be a lot quicker—as it is now
    loading from the cache you've created instead of querying the API every time.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 7, *Pre-Caching Other Folders and Files for Faster Navigation*, we
    will be looking at precaching the folders to try and preempt where the user is
    heading next. We will also look at caching the download links for the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our full app JavaScript should now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this chapter, your app should now be integrated with Vuex and be caching
    the contents of the Dropbox folders. The Dropbox folder path should also be utilizing
    the `store` to make the app more efficient. We are also querying the API only
    when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](https://cdp.packtpub.com/vue_js_by_example/wp-admin/post.php?post=71&action=edit#post_82), *Pre-Caching
    Other Folders and Files for Faster Navigation*, we will look at precaching the
    folders—actively querying the API in advance to speed up the app navigation and
    usability.
  prefs: []
  type: TYPE_NORMAL
