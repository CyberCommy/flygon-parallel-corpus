- en: '*Chapter 5*: Updating and Deleting Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to deploy an application and its service
    and how to scale deployment replicas up. Let's now learn about some more advanced
    ways to update your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn how to update applications to new versions
    and, if the release was a bad one, how to roll it back. We will see how to assign
    an application to a particular node, running applications in high-availability
    mode, how to make applications available over the internet, and in cases where
    there is a need, how to delete an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Releasing a new application version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling back an application release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning an application to a specific node (node affinity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling application replicas to different nodes (pod affinity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing an application to the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a new application version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we deployed an application using the `nginx v1.18.0`
    Docker image. In this section, let''s update it to `nginx v1.19.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the `nginx` Docker image tag, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$ kubectl rollout status deployment nginx` command will show the rollout
    status as a success, failed, or waiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a handy way to check the deployment's rollout status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ensure that the deployment is updated to `nginx` v1.19.0 by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Output for describe deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Output for describe deployment
  prefs: []
  type: TYPE_NORMAL
- en: Yup, it was updated to v1.19.0, as we can see in the `Pod Template` part. Now,
    let's update the Docker image using the `deployment.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `deployment.yaml` file with the new Docker `image` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `$ kubectl apply -f deployment.yaml` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Running the `$ kubectl get pods` command shows that the pods haven't changed
    as we applied the same Docker image tag as before, so Kubernetes is clever enough
    not to make any unnecessary changes to the `nginx` deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back an application release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are always cases (such as bugs in the code, the wrong Docker tag supplied
    for the latest release, and more) when you need to roll back an application release
    to a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the `$ kubectl rollout undo deployment nginx` command
    followed by the `get` and `describe` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Deployment release rollback'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Deployment release rollback
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output shows the version as `Image: nginx:1.18.0`, so the rollback
    was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the deployment rollout history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also roll back to a specific revision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Nice, we have learned how to roll back a deployment's release.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning an application to a specific node (node affinity)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some use cases where Kubernetes clusters have different node pools
    with different specs, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateful applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s reschedule the `nginx` deployment to a dedicated node pool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the nodes list, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Node pools list'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Node pools list
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s check a node under the `gke-kubectl-lab-we-app-pool` name. Run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Node labels'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Node labels
  prefs: []
  type: TYPE_NORMAL
- en: There, we have a `node-pool=web-app` label, which is the same for all nodes
    of the `gke-kubectl-lab-we-app-pool` pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s update the `deployment.yaml` file with the `nodeAffinity` rule, so the
    `nginx` application only gets scheduled to `gke-kubectl-lab-we-app-pool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To deploy the changes, run the `$ kubectl apply -f deployment.yaml` command
    followed by the `get` command as shown in the following screenshot:![Figure 5.5
    – Node affinity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16411_05_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Node affinity
  prefs: []
  type: TYPE_NORMAL
- en: Nice, the pods were scheduled onto `gke-kubectl-lab-we-app-pool`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `–o wide` flag, which allows us to show more information about
    a pod, such as its IP and the node it's scheduled on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delete one pod to verify that it gets scheduled onto `gke-kubectl-lab-we-app-pool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get the pods list again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Pods list with nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Pods list with nodes
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the pods list with the nodes the pods were scheduled
    on. Good, the new pod was scheduled onto the right node pool.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling application replicas to different nodes (pod affinity)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `nodeAffinity` does not ensure that pods will next time be scheduled onto
    separate nodes, and for real application high availability, the best practice
    is to ensure that application pods are scheduled onto separate nodes. If one of
    the nodes is down/rebooted/replaced, having all the pods running on that node
    will cause the application to go down and its services to be unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `deployment.yaml` file with the `podAntiAffinity` rule so
    that the `nginx` application is only scheduled to `gke-kubectl-lab-we-app-pool`
    and onto separate nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy the new changes, run the `$ kubectl apply -f deployment.yaml` command
    followed by the `get` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Node affinity'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Node affinity
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the pods are rescheduled again as we added the `podAntiAffinity`
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Node affinity pods are rescheduled'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Node affinity pods are rescheduled
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the pods are running on separate nodes, and the `podAntiAffinity`
    rule will ensure that pods will not be scheduled onto the same node.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing an application to the internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Awesome job so far, so to finish this chapter, let's make our application available
    over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to update `service.yaml` with `type: LoadBalancer`, which will create
    a LoadBalancer with an external IP.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The LoadBalancer capability is dependent on the vendor integration because an
    external LoadBalancer is created by the vendor. So, if you run locally with Minikube
    or Kind, you will never really get an external IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `service.yaml` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy the new changes, run the `$ kubectl apply -f service.yaml` command
    followed by the `get` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 5.9 – Service with pending LoadBalancer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – Service with pending LoadBalancer
  prefs: []
  type: TYPE_NORMAL
- en: 'We are seeing `pending` as the status depends on the cloud provider, and it
    can take up to 5 minutes for the LoadBalancer to be provisioned. Running the `get`
    command again after some time, you can see that the IP is assigned, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – The service with LoadBalancer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – The service with LoadBalancer
  prefs: []
  type: TYPE_NORMAL
- en: 'To be sure that the application is working, let''s open IP `104.197.177.53`
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Application in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16411_05_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Application in the browser
  prefs: []
  type: TYPE_NORMAL
- en: Voila! Our application is accessible from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example showing how to expose the application to the internet
    is not secure, as it is using HTTP. To keep the example simple, we used HTTP,
    but real-world applications should use HTTPS only.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to delete an application, so let's go over a few options
    for how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we deployed the deployment and service. Let's refresh
    our memory on what we deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check the deployments, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the active services, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have a deployment called `nginx` and a service called `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s delete the `nginx` service using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding screenshot, the `nginx` service was deleted,
    and the application is not exposed to the internet anymore and is safe to be deleted
    as well. To delete the `nginx` deployment, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is so easy to delete an application's deployed resources with a few commands.
  prefs: []
  type: TYPE_NORMAL
- en: But if you have an image where you have more than just two resources installed,
    would you run a deletion command for each resource? Of course not, there is an
    easier way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: As we have deleted the deployment and service, let's deploy them again so that
    we have something to delete again. You need to put `deployment.yaml` and `service.yaml`
    into some folder – for example, `code`.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow you to manage multiple resources together as multiple files
    in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also have multiple YAML entries in a single YAML file (with the `---`
    divider).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the deployment and service with the same command, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the deployment and service, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time, we used one command to install the application, and in the same way,
    you can apply changes to the application as well, as Kubernetes is clever enough
    that it will only update the resource that was changed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also use one command to show a service and deployment:`kubectl get deployment`/`service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the same approach to delete the application. To delete the
    deployment and service with one command, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used just one command to clean up all of the application's
    installed resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to release a new application version, roll back
    an application version, assign an application to a particular node, schedule application
    replicas between different nodes, and expose an application to the internet. We
    also learned how to delete an application in a few different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to debug an application, which
    is really important to know as it is not always the case that an application's
    releases go well.
  prefs: []
  type: TYPE_NORMAL
