- en: Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a mobile and web application platform first developed by Firebase
    Inc. in 2011 and bought by Google in 2014\. Since then, it has gone from a reactive
    database in the cloud to a whole suite of products. We will, however, focus on
    the database side of things, as that is the interesting part for an Angular developer.
    So, the best way to think of Firebase is as a backend as a service. That means
    that with Firebase, there is no reason to build your own REST services; you only
    need to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth pointing out that it is ultimately a product with paid plans, but
    it is definitely possible to create toy projects with it without having to pay
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so backend as a service, got it. That''s not all, however; its real selling
    point is the fact that it is reactive. It is reactive in the sense that if you
    subscribe to a collection on the database and a client somewhere makes a change
    to that collection, you will be notified and can act accordingly. Does that sounds
    familiar? Yes, you are thinking right: it sounds like RxJS and Observables, which
    is why the Firebase API has been wrapped in RXJS called AngularFire2, an Angular
    module that you can easily install from `npm` and add to your project.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the business case for using Firebase in the first place is when you want
    to create collaboration applications. I'm going to be so bold as to say that it
    is like web sockets, but in the cloud and with an underlying database, so with
    not only the communication part, but data as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What Firebase is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To leverage AngularFire2 in your Angular app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to listen for and act on changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use CRUD operations to manipulate your Firebase data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why it is important to deal with authentication and authorization and how to
    set them up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three-way binding versus two-way binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have different kinds of bindings. AngularJS made the two-way binding famous.
    This entails being able to change data from two different directions:'
  prefs: []
  type: TYPE_NORMAL
- en: A change in the view changes data on the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change on the controller is reflected in the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As for three-way binding, what do we mean? Let''s illustrate this with an app;
    it''s best described through an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae528e84-5583-436c-bb3e-6d28cf69bdd5.png)'
  prefs: []
  type: TYPE_IMG
- en: What you need to imagine here is that we developed an application that uses
    Firebase. We are launching said application in two different browser windows.
    In the first window, we make a change that is being reflected in the second browser
    window, for example, adding an item to a list. So, what steps take place?
  prefs: []
  type: TYPE_NORMAL
- en: 'What we see here is best read from right to left:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance one: user changes a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instance one: change propagates to the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This triggers synchronisation with the Firebase database instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second instance is listening to the synchronisation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model for the second instance is being updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view for the second instance is being updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There you have it: change in one place, and see the results in two or more
    instances depending on how many instances you have spawned.'
  prefs: []
  type: TYPE_NORMAL
- en: Some words on storage - the problem with a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before venturing deeper into Firebase, let''s first explain why we are talking
    about lists in the first place. In a relational database, we would be using SQL,
    tables, and normal forms to define our database. This is not the case with a Firebase
    database, as it is made of a JSON structure, looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the orders collection in a relational database would be an `orders`
    table with a lot of rows. Here, it seems to be an object; why is that?
  prefs: []
  type: TYPE_NORMAL
- en: Objects in a list - solving the deletion problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list normally has an index associated to every item in the list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: item1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: item2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: item3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's nothing wrong with that, until you start to think about what happens
    when many simultaneous users start to access the same data. As long as we do reads,
    we don't have a problem. But what happens if we attempt something else, such as
    deletion?
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally when you delete things, the index gets reassigned. If we delete the
    preceding `item2`, we have a new situation that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: item1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: item3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine we do deletions based on the index and your data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: item1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: item2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: item3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: item4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, two different users can access this data and one wants to delete index
    1 and the other wants to delete index 3\. We would probably employ a locking algorithm,
    so one user deletes index 1 a few milliseconds before user two deletes index 3\.
    The intention of the first user was to delete `item2` and the intention of the
    second user was to delete `item4`. The first user succeeds in what they set out
    to do, but the second one deletes an index that is out of bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that deleting things on the index is just crazy in a multiuser database,
    but in the case of Firebase, it means that lists are not lists when they are stored;
    they are objects, looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This circumvents the deletion problem and is, therefore, the reason that lists
    are represented the way they are.
  prefs: []
  type: TYPE_NORMAL
- en: AngularFire2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AngularFire2 is the name of the library where the Firebase API is wrapped in
    Observables. That means we can somewhat anticipate what it might look like when
    we want to listen for changes and so on. We will come back to the change scenario
    in a later section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official repository can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/angular/angularfire2](https://github.com/angular/angularfire2)'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent documentation on how to do CRUD and work with authentication can be
    found at the bottom of the page the preceding link leads to.
  prefs: []
  type: TYPE_NORMAL
- en: The core classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is some basic information that is good to know before venturing deeper
    into AngularFire2; it''s about core objects and what their responsibilities are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AngularFireAuth`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirebaseObjectObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirebaseListObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AngularFireAuth` deals with authentication. `FirebaseObjectObservable`is the
    core object you want to talk to when you know that the database property you deal
    with is of the type object. Lastly, `FirebaseListObservable`is the object that
    acts like a list. From before, we know that Firebase lists aren''t really lists,
    but that doesn''t stop this object from having methods on it that a list would
    normally have.'
  prefs: []
  type: TYPE_NORMAL
- en: The admin tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The admin tools can be found at [https://firebase.google.com/](https://firebase.google.com/).
    Once there, in the top-right corner, click on the GO TO CONSOLE link. You should
    have a Gmail account. If you do, then you have a Firebase account as well, and
    you only need to set up the database. Then, you should choose to create a project;
    give it a title of your choice and your location.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](assets/bfbbe7cb-04fd-45ea-bbb5-72b08f85f070.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve done this, you will be taken to the admin page, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9944befd-010f-4912-89dc-7317796d1d9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot displays the left menu, and then to the right, you
    would have a content pane. What content is displayed on the right varies based
    on what you choose on the left. As you can see, you can control a lot of things.
    Your most important options when starting to craft your database are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Here, you set up what kind of authentication you want: no
    authentication, username/password, social logins, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Here, you design what the database should look like. There are
    also some tabs in here that let us control authorization for the database collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other options are interesting, but for the purposes of this section, this
    is something beyond our scope.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We go to the Database menu option on our left. In the following screenshot,
    I have already added a node to the root node, the book node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0641a4ff-fc3c-4407-aac8-27d93f3f468b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hovering over our root element, we are presented with a + character that allows
    us to add a child to the root. Of course, we can also create more complex objects
    by clicking on a specific element and adding child nodes to them that look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f94c123-e0cf-4866-8707-0d6e6b84be19.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we can quite easily build out our database and it has a JSON-like
    appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding AngularFire2 to your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The time has come to add Firebase support to our Angular application. To do
    that, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the `npm` library for AngularFire2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import said library into our Angular application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up our Firebase configuration so Firebase lets us retrieve the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the proper Firebase service so we can access the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Present the data in a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The link [https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md](https://github.com/angular/angularfire2/blob/master/docs/install-and-setup.md)
    is the official link to set up Firebase in your Angular application. This might
    change over time, so it can be worth checking this page if the instructions of
    the book no longer seem to work after an update of the AngularFire2 library. Let's
    go through the steps though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Downloading the AngularFire2 library is as simple as typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to grab the configuration data from the Firebase admin page
    and save that to a configuration object. Go back to the admin page. You go to
    the correct page for the configuration by pressing:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add Firebase to your web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, you have a configuration in the form of an object with the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding values differ depending on your project. I can only urge you to
    copy the configuration from the admin page for your next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to scaffold an Angular application using `@angular-cli` and
    look up the `app.module.ts` file. In it, we will assign our config to the following
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to instruct the module to import the modules we need. Essentially,
    there are three modules that we can import:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AngularFireModule`: This is used to initialize the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AngularFireDatabaseModule`: This is used to access the database; this is necessary
    to import'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AngularFireAuthModule`: This is used to work with authentication; it''s not
    necessary at first, but will definitely become so as the app grows - security
    anyone?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s import the first two, so we can work with Firebase and pull some data
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are done configuring the Angular module and can move on to
    `AppComponent`, which is where we will inject a Firebase service so we can finally
    pull some data from Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And there you have it: a complete Firebase setup, from downloading AngularFire2
    to displaying your first data.'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Protecting our app is vital. It''s not an if, it is a must, unless you are
    building a toy application. There are currently three ways to do this in Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication: This is where we verify that the user enters the correct credentials
    to be logged on to the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authorization: This is where we set up what resources in the application the
    user has a right to access/modify'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Validation: This is where we ensure that only valid data is persisted in the
    database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication - allowing access to the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Authentication means that we identify you when you attempt to log on. If your
    credentials match a user in the database, then the app should let you in; otherwise,
    you are shown the door. Firebase has different ways of authenticating you. Currently,
    the following authentication methods are possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Email/password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is pretty much what you would expect in 2017: everything from simple authentication
    with email/password to OAuth.'
  prefs: []
  type: TYPE_NORMAL
- en: Authorization - deciding who gets to access what data, and how
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As for authorization, it is possible to set rules:'
  prefs: []
  type: TYPE_NORMAL
- en: On the whole database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Per collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also important to know that the rules are enforced in these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomically**: Applies to a specific element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cascading**: Applies to a specific element and all its children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The permission level is either:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read**: This will make it possible to read the contents of the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: This will give you the ability to modify the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deny**: This will stop any write or read actions from being possible on the
    targeted resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This calls for an example. Imagine you have the following database structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Atomic authorization means that we need to be explicit; if we are not explicit,
    the default is to deny access. Let''s try to enforce some rules on the preceding
    structure. We navigate to the rules section under the Database menu option. A
    rule is defined as a JSON object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we have set an explicit atomic rule for `bar` and that rule
    is inherited by its child elements, that is, it acts in a cascading way`foo`,
    on the other hand, has no rule to it. This would have the following consequence
    if trying to access the collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This explains the types of rules that are in place. I urge you to look into
    this topic deeper by studying the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing your data in general: [https://firebase.google.com/docs/database/security/securing-data](https://firebase.google.com/docs/database/security/securing-data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing data per user, that is, setting different permission levels for different
    types of users: [https://firebase.google.com/docs/database/security/user-security](https://firebase.google.com/docs/database/security/user-security)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is quite an interesting topic. What is meant here is that we can control
    what data is allowed to enter our collections by setting up rules about the shape
    of the data. You essentially specify a set of requirements that the data must
    have for an insertion or update to be considered okay to perform. Just like the
    read/write authorization rules, we specify a rules object. Let''s describe two
    different versions of validation so you get the hang of it:'
  prefs: []
  type: TYPE_NORMAL
- en: Incoming data must include these fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incoming data must have a value within this range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first case we can describe like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a code snippet showing the impact when the preceding rules are in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second case, we can set up the rules like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding specified rule states that any incoming data must be of type number,
    must be larger than or equal to `0`, and smaller than or equal to `100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet showing the impact with this rule in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this makes it very easy to protect our data from unwanted input
    and thereby keeps the database nice and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data - CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have come to the exciting part: how to work with the data, read our
    data, add more data, and so on. In short, the term **Create, Read, Update, Delete** (**CRUD**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when we work with CRUD, we need to know a little something about the structure
    that we are operating on. We need to know whether it is of type object or list.
    In terms of code, this means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding states that we can treat the data we look at, from the database,
    as either an object or list. Depending on our choice, this has an impact on what
    methods will be available to us, but also what the data looks like coming back.
    This is especially obvious if we have a list-like structure in the database and
    choose to treat it as an object. Assume we have the following stored structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we choose to treat this as a list, we get the following response back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This means we can use methods such as `push()` to add things to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to treat the data as an object, then it comes back as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This may or may not be what you want. So remember, if it is a list, treat it
    as one. Firebase won't punish you with an exception if you choose `.object()`
    over `.list()`, but it might make the data harder to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the read case. The following code will read the data from a
    property in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is a stream, this means that we can get the data in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the async pipe, which displays the observable as is, in the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grabbing the data from the `subscribe()` method and assigning it to a property
    on your class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we do the first scenario, it will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth highlighting how we ask for the path in the database and transform
    the result with the `.map()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, we use the async pipe and an expression to show the title
    of our `Book` entity when it has been resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do the second scenario, it will look something like this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will take away a little of the typing, but you now must remember to unsubscribe
    to your stream; this has not been added in the previous example. When possible,
    use the async pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Changing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of data changes that can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destructive update**: We override what is there'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-destructive update**: We merge the incoming data with what is already
    there'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method used for the destructive update is called `set()` and is used in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that our previous data was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It has now become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we mean by a destructive update: we get the `title` property
    overridden, but we also lose the `description` property as the entire object is
    being replaced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the destruction of the data was not what you had in mind, then there is
    a softer update you can use, which is the `update()` method. Using it is as easy
    as writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the data looked like the following before the `update()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember to select the appropriate update operation depending on your intention
    as it makes a difference.
  prefs: []
  type: TYPE_NORMAL
- en: Removing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing data is simple. We need to split this up into two different parts,
    as they differ a bit, to remove for an object and to remove an item in a list.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways of subscribing to data in Firebase. You can either
    subscribe to changes, using a method called `valueChanges()`. This will give you
    the data you want to display. As long as you want to display data, then you are
    fine using this method. However, when you start to want to change specific data
    like removing an item in a list or in short, when you need to know the exact key
    value of the resource you are trying to manipulate, then you need a new function.
    This function is called `snapshotChanges()`. Using said function gives you a more
    raw version of the resource you want. In this case, you need to dig out the value
    that you want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the first case, that of removing an object.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at two different `remove()` scenarios. In the first scenario, we
    want to remove what our path is pointing to. Imagine we are looking at the path/book.
    Then, our remove code for this is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Removing an item in a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list in Firebase looks something like this when looking at the database from
    the Firebase console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, there is an internal representation of each item that points to
    a key with a hash value. We have the following scenario; we want to delete the
    first item in the list. We write some code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now that we discover that we don''t know what the key is for the item
    we want to remove. This is where we start using the method `snapshotChanges()`
    and try to find this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The list parameter is a list, but the list items is a complicated object that
    contains the key we need as well as the value that we mean to display in the UI.
    We realise that this is the way to go and decide on using a `map()` function on
    our stream to transform the it into a list of books.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we amend our `book.model.ts` file to contain a key property, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we needed to change how we access data; our data was to be
    found under the `payload.val()` and our `key` was easy to retrieve. With this
    knowledge, we can now build a list :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we loop all the books in the list and create
    a remove button for each book in the list. We also wire up each remove button
    to point to the `book.key`, that is, our `key`, which is what we need when communicating
    a remove action to Firebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Responding to change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase's cloud database is not just a database that looks like JSON, it also
    pushes out the data when it changes. You can listen for when that happens. This
    gives you not only cloud storage, but also the opportunity to build applications
    in a more collaborative and real-time manner. A lot of systems out there work
    like this already, such as most ticketing systems, chat applications, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a system built with Firebase that, for example, books movie tickets.
    You would be able to see when a person books a ticket, or an incoming message
    in a chat system, without polling logic or refreshing the app; it would be almost
    child's play to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'AngularFire2, the Angular framework on top of Firebase, uses Observables. Observables
    convey changes when they happen. From before, we know that we can listen to such
    changes by giving a subscribe method a callback, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What you can do as a developer is intercept when such a change happens, by signing
    up to the `subscribe()` method, and for example, show a CSS animation to draw
    the user's attention to the change, so they can respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can''t really build an application and call it ready for release unless
    we at least have some proper authentication. Essentially, we can''t trust just
    anyone with our data, only authenticated users. In Firebase, you can set authentication
    on the highest level for your database. Click on the Database menu option tab
    in your admin tool and then select the tab rules. That should showcase the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s highlight the following row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, this sets up the read permission for your entire database and
    we give it the value `auth != null`. This means that you need to be authenticated
    to have any kind of read access to the database. You can see in the following
    row we have the same value, but this time for a rule called `.write`, which governs
    the writing access.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good default permission to have. Of course, when testing the database
    out, you might want to have the value `auth == null`to shut off authentication,
    but remember to set the value back to `auth != null`, or you will leave your database
    wide open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up any kind of authentication means we need to perform some steps,
    namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the rules are on, that is, `auth != null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling a security method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a user or token (if it is OAuth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `AuthService` in the application to programmatically log on the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple authentication with email/password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up a simple user/password authentication. Click on the Authentication
    menu option and select the Sign-in method tab. Then, enable the email/password
    option. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f37a176b-c3f9-4d8b-8671-b164de447bd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we need to add a user, a user that is allowed to access our
    data. So, let''s set up the user. We go to the Users tab instead and clickADD
    USER button. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d5db160-fb7e-45ef-8e44-5a6eca202001.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, so now we have a user with an email `a@b.com` and password `abc123`. We
    still need to log in such a user for the database to show us the data. If we don't
    log in, our application will look very empty and devoid of any data. We will also
    get a lot of errors on the console log saying that we lack permission to look
    at the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous setup of Firebase, we had only set up the database itself,
    not the authentication part. As Firebase is an Angular module, there are some
    rules we need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the module and add it to the `import` keyword of the `@NgModule`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the `AngularFireAuth` service in the `providers` keyword in `@NgModule`,
    so a component is able to inject it into its constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a programmatic login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The module side of things looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to inject the service into the component and perform the
    login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do two interesting things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we assign the `authState` of the  `authService`to a user. This is
    an Observable that, once logged in, will contain your user. We have now learned
    that we can show Observables with the async pipe. However, we are interested in
    getting two things from this user, `uid` and `email`, so we can see we are logged
    in as the correct user. It is tempting to write template code that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This creates the variable user for us that we can refer to instead. As expected,
    this prints out the user for us once logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to the second piece of our preceding code, the login call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we talk to the `auth` property on the `authService` and we call the `signInWithEmailAndPassword(email,
    password)` method.We pass it the credentials. The method returns a promise and,
    on resolving that promise, we set our properties' book and books. If we don't
    do it this way and first authenticate, we will get a lot of `access not allowed
    errors`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a ton more `signInWith...` methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7c8330f4-25e4-4674-9468-6a269cf26186.png)'
  prefs: []
  type: TYPE_IMG
- en: We urge you to try them out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for ways of authenticating, we have just scratched the surface. The following
    is the full range of login methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/769e6c33-b4a4-436f-bc47-1de55aa58552.png)'
  prefs: []
  type: TYPE_IMG
- en: Try them out and see what works for you and your app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a powerful technology that is essentially a backend in the cloud;
    it has a reactive API. AngularFire2 is the name of the library wrapping Firebase.
    The library is especially made for use with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to listen for changes from Firebase. AngularFire2 communicates
    those changes through RxJS and Observables, which makes it very easy for us to
    involve Firebase in our apps once we grow the basics of Observables with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this has been an educational chapter which has further motivated
    you to use RxJS in Angular as your choice for anything async.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has been about the standalone product Firebase. The point was to
    show that there is a very powerful piece of technology at your fingertips that
    expands on your newfound knowledge of RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover a very important aspect of building Angular
    applications, namely routing. Routing is a central concept that allows us to divide
    our application into several logical pages. We talk about logical pages instead
    of actual pages as we are building an SPA, which is a single page application.
    What is the difference, you ask? The routing component, which you will read more
    about in the next chapter, will help you to define components that can be routed
    to, as well as helping you to define viewports in your application that can be
    switched out. Think of your application as a passepartout or a frame. Inside the
    frame of your application, you can define things such as a top menu or left menu,
    but the painting in the middle is the part of your application that can be switched
    out.  We call that replaceable part a page.
  prefs: []
  type: TYPE_NORMAL
