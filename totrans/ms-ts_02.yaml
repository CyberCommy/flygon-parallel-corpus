- en: Chapter 2. Types, Variables and Function Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript introduces strong typing to JavaScript through a simple syntax, referred
    to by Anders Hejlsberg as "syntactic sugar".
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is an introduction to the syntax used in the TypeScript language
    to apply strong typing to JavaScript. It is intended for readers that have not
    used TypeScript before, and covers the transition from standard JavaScript to
    TypeScript. If you already have experience with TypeScript, and have a good understanding
    of the topics listed below, then by all means have a quick read through, or skip
    to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic types and type syntax: strings, numbers, and booleans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inferred typing and duck-typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The any type and explicit casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional and default function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function callbacks and function signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function scoping rules and overloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript variables can hold a number of data types, including numbers, strings,
    arrays, objects, functions, and more. The type of an object in JavaScript is determined
    by its assignment – so if a variable has been assigned a string value, then it
    will be of type string. This can, however, introduce a number of problems in our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is not strongly typed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 1](ch01.html "Chapter 1. TypeScript – Tools and Framework
    Options"), *TypeScript – Tools and Framework Options*, JavaScript objects and
    variables can be changed or reassigned on the fly. As an example of this, consider
    the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining three variables, named `myString`, `myNumber` and `myBoolean`.
    The `myString` variable is set to a string value of `"test"`, and as such will
    be of type `string`. Similarly, `myNumber` is set to the value of `1`, and is
    therefore of type `number`, and `myBoolean` is set to `true`, making it of type
    `boolean`. Now let''s start assigning these variables to each other, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We start by setting the value of `myString` to the value of `myNumber` (which
    is the numeric value of `1`). We then set the value of `myBoolean` to the value
    of `myString`, (which would now be the numeric value of `1`). Finally, we set
    the value of `myNumber` to the value of `myBoolean`. What is happening here, is
    that even though we started out with three different types of variables—a string,
    a number, and a boolean—we are able to reassign any of these variables to one
    of the other types. We can assign a number to a string, a string to boolean, or
    a boolean to a number.
  prefs: []
  type: TYPE_NORMAL
- en: While this type of assignment in JavaScript is legal, it shows that the JavaScript
    language is not strongly typed. This can lead to unwanted behaviour in our code.
    Parts of our code may be relying on the fact that a particular variable is holding
    a string, and if we inadvertently assign a number to this variable, our code may
    start to break in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is strongly typed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript, on the other hand, is a strongly typed language. Once you have declared
    a variable to be of type `string`, you can only assign `string` values to it.
    All further code that uses this variable must treat it as though it has a type
    of `string`. This helps to ensure that code that we write will behave as expected.
    While strong typing may not seem to be of any use with simple strings and numbers—it
    certainly does become important when we apply the same rules to objects, groups
    of objects, function definitions and classes. If you have written a function that
    expects a `string` as the first parameter and a `number` as the second, you cannot
    be blamed, if someone calls your function with a `boolean` as the first parameter
    and something else as the second.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript programmers have always relied heavily on documentation to understand
    how to call functions, and the order and type of the correct function parameters.
    But what if we could take all of this documentation and include it within the
    IDE? Then, as we write our code, our compiler could point out to us—automatically—that
    we were using objects and functions in the wrong way. Surely this would make us
    more efficient, more productive programmers, allowing us to generating code with
    fewer errors?
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript does exactly that. It introduces a very simple syntax to define the
    type of a variable or a function parameter to ensure that we are using these objects,
    variables, and functions in the correct manner. If we break any of these rules,
    the TypeScript compiler will automatically generate errors, pointing us to the
    lines of code that are in error.
  prefs: []
  type: TYPE_NORMAL
- en: This is how TypeScript got its name. It is JavaScript with strong typing - hence
    TypeScript. Let's take a look at this very simple language syntax that enables
    the "Type" in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Type syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TypeScript syntax for declaring the type of a variable is to include a
    colon (`:`), after the variable name, and then indicate its type. Consider the
    following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet is the TypeScript equivalent of our preceding JavaScript
    code, and shows an example of the TypeScript syntax for declaring a type for the
    `myString` variable. By including a colon and then the keyword `string` (`: string`),
    we are telling the compiler that the `myString` variable is of type `string`.
    Similarly, the `myNumber` variable is of type `number`, and the `myBoolean` variable
    is of type `boolean`. TypeScript has introduced the `string`, `number` and `boolean`
    keywords for each of these basic JavaScript types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we attempt to assign a value to a variable that is not of the same type,
    the TypeScript compiler will generate a compile-time error. Given the variables
    declared in the preceding code, the following TypeScript code will generate some
    compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Type syntax](img/9665OS_02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: TypeScript build errors when assigning incorrect types
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler is generating compile errors, because we are attempting
    to mix these basic types. The first error is generated by the compiler because
    we cannot assign a `number` value to a variable of type `string`. Similarly, the
    second compile error indicates that we cannot assign a `string` value to a variable
    of type `boolean`. Again, the third error is generated because we cannot assign
    a `boolean` value to a variable of type `number`.
  prefs: []
  type: TYPE_NORMAL
- en: The strong typing syntax that the TypeScript language introduces, means that
    we need to ensure that the types on the left-hand side of an assignment operator
    (`=`) are the same as the types on the right-hand side of the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the preceding TypeScript code, and remove the compile errors, we would
    need to do something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our first line of code has been changed to call the `.toString()` function on
    the `myNumber` variable (which is of type `number`), in order to return a value
    that is of type `string`. This line of code, then, does not generate a compile
    error because both sides of the equal sign are of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Our second line of code has also been changed so that the right hand side of
    the assignment operator returns the result of a comparison, `myString === "test"`,
    which will return a value of type `boolean`. The compiler will therefore allow
    this code, because both sides of the assignment resolve to a value of type `boolean`.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of our code snippet has been changed to only assign the value
    `1` (which is of type `number`) to the `myNumber` variable, if the value of the
    `myBoolean` variable is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Anders Hejlsberg describes this feature as "syntactic sugar". With a little
    sugar on top of comparable JavaScript code, TypeScript has enabled our code to
    conform to strong typing rules. Whenever you break these strong typing rules,
    the compiler will generate errors for your offending code.
  prefs: []
  type: TYPE_NORMAL
- en: Inferred typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript also uses a technique called inferred typing, in cases where you
    do not explicitly specify the type of your variable. In other words, TypeScript
    will find the first usage of a variable within your code, figure out what type
    the variable is first initialized to, and then assume the same type for this variable
    in the rest of your code block. As an example of this, consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by declaring a variable named `myString`, and assign a string value
    to it. TypeScript identifies that this variable has been assigned a value of type
    `string`, and will, therefore, infer any further usages of this variable to be
    of type `string`. Our second variable, named `myNumber` has a number assigned
    to it. Again, TypeScript is inferring the type of this variable to be of type
    `number`. If we then attempt to assign the `myString` variable (of type `string`)
    to the `myNumber` variable (of type `number`) in the last line of code, TypeScript
    will generate a familiar error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This error is generated because of TypeScript's inferred typing rules.
  prefs: []
  type: TYPE_NORMAL
- en: Duck-typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript also uses a method called duck-typing for more complex variable
    types. Duck-typing means that if it looks like a duck, and quacks like a duck,
    then it probably is a duck. Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We start with a variable named `complexType` that has been assigned a simple
    JavaScript object with a `name` and `id` property. On our second line of code,
    we can see that we are re-assigning the value of this `complexType` variable to
    another object that also has an `id` and a `name` property. The compiler will
    use duck-typing in this instance to figure out whether this assignment is valid.
    In other words, if an object has the same set of properties as another object,
    then they are considered to be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate this point, let''s see how the compiler reacts if we
    attempt to assign an object to our `complexType` variable that does not conform
    to this duck-typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of this code snippet defines our `complexType` variable, and
    assigns to it an object that contains both an `id` and `name` property. From this
    point, TypeScript will use this inferred type on any value we attempt to assign
    to the `complexType` variable. On our second line of code, we are attempting to
    assign a value that has an `id` property but not the `name` property. On the third
    line of code, we again attempt to assign a value that has a `name` property, but
    does not have an `id` property. On the last line of our code snippet, we have
    completely missed the mark. Compiling this code will generate the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the error messages, TypeScript is using duck-typing to ensure
    type safety. In each message, the compiler gives us clues as to what is wrong
    with the offending code – by explicitly stating what it is expecting. The `complexType`
    variable has both an `id` and a `name` property. To assign a value to the `complexType`
    variable, then, this value will need to have both an `id` and a `name` property.
    Working through each of these errors, TypeScript is explicitly stating what is
    wrong with each line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the following code will not generate any error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, our first line of code defines the `complexType` variable, as we have
    seen previously, with an `id` and a `name` property. Now, look at the second line
    of this example. The object we are using actually has three properties: `name`,
    `id`, and `address`. Even though we have added a new `address` property, the compiler
    will only check to see if our new object has both an `id` and a `name`. Because
    our new object has these properties, and will therefore match the original type
    of the variable, TypeScript will allow this assignment through duck-typing.'
  prefs: []
  type: TYPE_NORMAL
- en: Inferred typing and duck-typing are powerful features of the TypeScript language
    – bringing strong typing to our code, without the need to use explicit typing,
    that is, a colon `:` and then the type specifier syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the base JavaScript types of string, number, and boolean, TypeScript
    has two other data types: Arrays and enums. Let''s look at the syntax for defining
    arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An array is simply marked with the `[]` notation, similar to JavaScript, and
    each array can be strongly typed to hold a specific type as seen in the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On the first line of this code snippet, we are defining an array named `arrayOfNumbers`,
    and further specify that each element of this array must be of type `number`.
    The second line then reassigns this array to hold some different numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of this snippet, however, will generate the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This error message is warning us that the variable `arrayOfNumbers` is strongly
    typed to only accept values of type `number`. Our code tries to assign an array
    of strings to this array of numbers, and is therefore, generating a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: The any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this type checking is well and good, but JavaScript is flexible enough
    to allow variables to be mixed and matched. The following code snippet is actually
    valid JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first line of code assigns an object with an `id` property and a `name`
    property to the variable `item1`. The second line then re-assigns this variable
    to an object that has an `id` property but not a `name` property. Unfortunately,
    as we have seen previously, TypeScript will generate a compile time error for
    the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript introduces the `any` type for such occasions. Specifying that an
    object has a type of `any` in essence relaxes the compiler''s strict type checking.
    The following code shows how to use the `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how our first line of code has changed. We specify the type of the variable
    `item1` to be of type `: any` so that our code will compile without errors. Without
    the type specifier of `: any`, the second line of code, would normally generate
    an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any strongly typed language, there comes a time where you need to explicitly
    specify the type of an object. This concept will be expanded upon more thoroughly
    in the next chapter, but it is worthwhile to make a quick note of explicit casting
    here. An object can be cast to the type of another by using the `< >` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not a cast in the strictest sense of the word; it is more of an assertion
    that is used at runtime by the TypeScript compiler. Any explicit casting that
    you use will be compiled away in the resultant JavaScript and will not affect
    the code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our previous code snippet to use explicit casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that on the first line of this snippet, we have now replaced the `: any`
    type specifier on the left hand side of the assignment, with an explicit cast
    of `<any>` on the right hand side. This snippet of code is telling the compiler
    to explicitly cast, or to explicitly treat the `{ id: 1, name: "item 1" }` object
    on the right-hand side as a type of `any`. So the `item1` variable, therefore,
    also has the type of `any` (due to TypeScript''s inferred typing rules). This
    then allows us to assign an object with only the `{ id: 2 }` property to the variable
    `item1` on the second line of code. This technique of using the `< >` syntax on
    the right hand side of an assignment, is called explicit casting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `any` type is a necessary feature of the TypeScript language – its
    usage should really be limited as much as possible. It is a language shortcut
    that is necessary to ensure compatibility with JavaScript, but over-use of the
    `any` type will quickly lead to coding errors that will be difficult to find.
    Rather than using the type `any`, try to figure out the correct type of the object
    you are using, and then use this type instead. We use an acronym within our programming
    teams: **S.F.I.A.T.** (pronounced sviat or sveat). **Simply Find an Interface
    for the Any Type**. While this may sound silly – it brings home the point that
    the `any` type should always be replaced with an interface – so simply find it.
    An interface is a way of defining custom types in TypeScript, and we will cover
    interfaces in the next chapter. Just remember that by actively trying to define
    what an object''s type should be, we are building strongly typed code, and therefore
    protecting ourselves from future coding errors and bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enums are a special type that has been borrowed from other languages such as
    C#, and provide a solution to the problem of special numbers. An enum associates
    a human-readable name for a specific number. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have defined an `enum` called `DoorState` to represent
    the state of a door. Valid values for this door state are `Open`, `Closed`, or
    `Ajar`. Under the hood (in the generated JavaScript), TypeScript will assign a
    numeric value to each of these human-readable enum values. In this example, the
    `DoorState.Open` enum value will equate to a numeric value of `0`. Likewise, the
    enum value `DoorState.Closed` will be equate to the numeric value of `1`, and
    the `DoorState.Ajar` enum value will equate to `2`. Let''s have a quick look at
    how we would use these enum values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line within the `window.onload` function creates a variable named
    `myDoor`, and sets its value to `DoorState.Open`. The second line simply logs
    the value of `myDoor` to the console. The output of this `console.log` function
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This clearly shows that the TypeScript compiler has substituted the enum value
    of `DoorState.Open` with the numeric value `0`. Now let''s use this enum in a
    slightly different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet uses a string value of "Closed" to lookup the `enum` type,
    and assign the resulting enum value to the `openDoor` variable. The output of
    this code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample clearly shows that the enum value of `DoorState.Closed` is the
    same as the enum value of `DoorState["Closed"]`, because both variants resolve
    to the numeric value of `1`. Finally, let''s have a look at what happens when
    we reference an enum using an array type syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assign the variable `openDoor` to an enum value based on the 2nd index
    value of the `DoorState` enum. The output of this code, though, is surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have been expecting the output to be simply `2`, but here we are getting
    the string `"Ajar"` – which is a string representation of our original enum name.
    This is actually a neat little trick – allowing us to access a string representation
    of our enum value. The reason that this is possible is down to the JavaScript
    that has been generated by the TypeScript compiler. Let''s have a look, then,
    at the closure that the TypeScript compiler has generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This strange looking syntax is building an object that has a specific internal
    structure. It is this internal structure that allows us to use this enum in the
    various ways that we have just explored. If we interrogate this structure while
    debugging our JavaScript, we will see the internal structure of the `DoorState`
    object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `DoorState` object has a property called `"0"`, which has a string value
    of `"Open"`. Unfortunately, in JavaScript the number `0` is not a valid property
    name, so we cannot access this property by simply using `DoorState.0`. Instead,
    we must access this property using either `DoorState[0]` or `DoorState["0"]`.
    The `DoorState` object also has a property named `Open`, which is set to the numeric
    value `0`. The word `Open` IS a valid property name in JavaScript, so we can access
    this property using `DoorState["Open"]`, or simply `DoorState.Open`, which equate
    to the same property in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: While the underlying JavaScript can be a little confusing, all we need to remember
    about enums is that they are a handy way of defining an easily remembered, human-readable
    name to a special number. Using human-readable enums, instead of just scattering
    various special numbers around in our code, also makes the intent of the code
    clearer. Using an application wide value named `DoorState.Open` or `DoorState.Closed`
    is far simpler than remembering to set a value to `0` for `Open`, `1` for `Closed`,
    and `3` for `ajar`. As well as making our code more readable, and more maintainable,
    using enums also protects our code base whenever these special numeric values
    change – because they are all defined in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last note on enums – we can set the numeric value manually, if needs be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have overridden the default values of the enum to set `DoorState.Open`
    to `3`, `DoorState.Closed` to `7`, and `DoorState.Ajar` to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Const enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the release of TypeScript 1.4, we are also able to define `const` enums
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These types of enums have been introduced largely for performance reasons,
    and the resultant JavaScript will not contain the full closure definition for
    the `DoorStateConst` enum as we saw previously. Let''s have a quick look at the
    JavaScript that is generated from this `DoorStateConst` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note how we do not have a full JavaScript closure for the `DoorStateConstenum`
    at all. The compiler has simply resolved the `DoorStateConst.Open` enum to its
    internal value of `0`, and removed the `const enum` definition entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'With const enums, we therefore cannot reference the internal string value of
    an enum, as we did in our previous code sample. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `console.log` statement will now generate a compile time error –
    as we do not have the full closure available with the property of `[0]` for our
    const enum. The second usage of this `const` enum is valid, however, and will
    generate the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When using const enums, just keep in mind that the compiler will strip away
    all enum definitions and simply substitute the numeric value of the enum directly
    into our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript defines functions using the `function` keyword, a set of braces,
    and then a set of curly braces. A typical JavaScript function would be written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet is fairly self-explanatory; we have defined a function named
    `addNumbers` that takes two variables and returns their sum. We then invoke this
    function, passing in the values of `1` and `2`. The value of the variable `result`
    would then be `1` + `2`, which is `3`. Now have a look at the last line of code.
    Here, we are invoking the `addNumbers` function, passing in two strings as arguments,
    instead of numbers. The value of the variable `result2` would then be a string,
    `"12"`. This string value seems like it may not be the desired result, as the
    name of the function is `addNumbers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copying the preceding code into a TypeScript file would not generate any errors,
    but let''s insert some type rules to the preceding JavaScript to make it more
    robust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this TypeScript code, we have added a `:number` type to both of the parameters
    of the `addNumbers` function (`a` and `b`), and we have also added a `:number`
    type just after the `( )` braces. Placing a type descriptor here means that the
    return type of the function itself is strongly typed to return a value of type
    `number`. In TypeScript, the last line of code, however, will cause a compilation
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This error message is generated because we have explicitly stated that the function
    should accept only numbers for both of the arguments `a` and `b`, but in our offending
    code, we are passing two strings. The TypeScript compiler, therefore, cannot match
    the signature of a function named `addNumbers` that accepts two arguments of type
    `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript language also has the concept of anonymous functions. These
    are functions that are defined on the fly and don''t specify a function name.
    Consider the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet defines a function that has no name and adds two values. Because
    the function does not have a name, it is known as an anonymous function. This
    anonymous function is then assigned to a variable named `addVar`. The `addVar`
    variable, then, can then be invoked as a function with two parameters, and the
    return value will be the result of executing the anonymous function. In this case,
    the variable `result` will have a value of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now rewrite the preceding JavaScript function in TypeScript, and add
    some type syntax, in order to ensure that the function only accepts two arguments
    of type `number`, and returns a value of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have created an anonymous function that accepts only
    arguments of type `number` for the parameters `a` and `b`, and also returns a
    value of type `number`. The types for both the `a` and `b` parameters, as well
    as the return type of the function, are now using the `:number` syntax. This is
    another example of the simple "syntactic sugar" that TypeScript injects into the
    language. If we compile this code, TypeScript will reject the code on the last
    line, where we try to call our anonymous function with two string parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we call a JavaScript function that has is expecting parameters, and we
    do not supply these parameters, then the value of the parameter within the function
    will be `undefined`. As an example of this, consider the following JavaScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a function called `concatStrings` that takes three parameters,
    `a`, `b`, and `c`, and simply returns the sum of these values. If we call this
    function with all three parameters, as seen in the second last line of this snipped,
    we will end up with the string `"abc"` logged to the console. If, however, we
    only supply two parameters, as seen in the last line of this snippet, the string
    `"abundefined"` will be logged to the console. Again, if we call a function and
    do not supply a parameter, then this parameter, `c` in our case, will be simply
    `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript introduces the question mark `?` syntax to indicate optional parameters.
    Consider the following TypeScript function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a strongly typed version of the original `concatStrings` JavaScript
    function that we were using previously. Note the addition of the `?` character
    in the syntax for the third parameter: `c?: string`. This indicates that the third
    parameter is optional, and therefore, all of the preceding code will compile cleanly,
    except for the last line. The last line will generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This error is generated because we are attempting to call the `concatStrings`
    function with only a single parameter. Our function definition, though, requires
    at least two parameters, with only the third parameter being optional.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optional parameters must be the last parameters in the function definition.
    You can have as many optional parameters as you want, as long as non-optional
    parameters precede the optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subtle variant on the optional parameter function definition, allows us to
    specify the default value of a parameter if it is not passed in as an argument
    from the calling code. Let''s modify our preceding function definition to use
    an optional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This function definition has now dropped the `?` optional parameter syntax,
    but instead has assigned a value of `"c"` to the last parameter: `c:string = "c"`.
    By using default parameters, if we do not supply a value for the final parameter
    named `c`, the `concatStrings` function will substitute the default value of `"c"`
    instead. The argument `c`, therefore, will not be `undefined`. The output of the
    last two lines of code will both be `"abc"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that using the default parameter syntax will automatically make the parameter
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JavaScript language allows a function to be called with a variable number
    of arguments. Every JavaScript function has access to a special variable, named
    `arguments`, that can be used to retrieve all arguments that have been passed
    into the function. As an example of this, consider the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have defined a function name `testParams` that does
    not have any named parameters. Note, though, that we can use the special variable,
    named `arguments`, to test whether the function was called with any arguments.
    In our sample, we can simply loop through the `arguments` array, and log the value
    of each argument to the console, by using an array indexer : `arguments[i]`. The
    output of the console.log calls are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, how do we express a variable number of function parameters in TypeScript?
    The answer is to use what are called rest parameters, or the three dots (`…`)
    syntax. Here is the equivalent `testParams` function, expressed in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the `…argArray: number[]` syntax for our `testParams` function.
    This syntax is telling the TypeScript compiler that the function can accept any
    number of arguments. This means that our usages of this function, i.e. calling
    the function with either `testParams(1)` or `testParams(1,2,3,4)`, will both compile
    correctly. In this version of the `testParams` function, we have added two `console.log`
    lines, just to show that the `arguments` array can be accessed by either the named
    rest parameter, `argArray[i]`, or through the normal JavaScript array, `arguments[i]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The last line in this sample will, however, generate a compile error, as we
    have defined the rest parameter to only accept numbers, and we are attempting
    to call the function with strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The the subtle difference between using `argArray` and `arguments` is the inferred
    type of the argument. Since we have explicitly specified that `argArray` is of
    type `number`, TypeScript will treat any item of the `argArray` array as a number.
    However, the internal `arguments` array does not have an inferred type, and so
    will be treated as the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also combine normal parameters along with rest parameters in a function
    definition, as long as the rest parameters are the last to be defined in the parameter
    list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two normal parameters named `arg1` and `arg2` and then an `argArray`
    rest parameter. Mistakenly placing the rest parameter at the beginning of the
    parameter list will generate a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: Function callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most powerful features of JavaScript–and in fact the technology
    that Node was built on–is the concept of callback functions. A callback function
    is a function that is passed into another function. Remember that JavaScript is
    not strongly typed, so a variable can also be a function. This is best illustrated
    by having a look at some JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a function named `myCallBack` that takes a parameter and logs
    its value to the console. We then define a function named `callingFunction` that
    takes two parameters: `initialText` and `callback`. The first line of this funciton
    simply logs `"inside CallingFunction"` to the console. The second line of the
    `callingFunction` is the interesting bit. It assumes that the `callback` argument
    is in fact a function, and invokes it. It also passes the `initialText` variable
    to the `callback` function. If we run this code, we will get two messages logged
    to the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens if we do not pass a function as a callback? There is nothing
    in the preceding code that signals to us that the second parameter of `callingFunction`
    must be a function. If we inadvertently called the `callingFunction` function
    with a string, instead of a function as the second parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get a JavaScript runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Defensive minded programmers, however, would first check whether the `callback`
    parameter was in fact a function before invoking it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note the third line of this code snippet, where we check the type of the `callback`
    variable before invoking it. If it is not a function, we then log a message to
    the console. On the last line of this snippet, we are executing the `callingFunction`,
    but this time passing a string as the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the code snippet would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When using function callbacks, then, JavaScript programmers need to do two things;
    firstly, understand which parameters are in fact callbacks and secondly, code
    around the invalid use of callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function signatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TypeScript "syntactic sugar" that enforces strong typing, is not only intended
    for variables and types, but for function signatures as well. What if we could
    document our JavaScript callback functions in code, and then warn users of our
    code when they are passing the wrong type of parameter to our functions ?
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript does this through function signatures. A function signature introduces
    a fat arrow syntax, `() =>`, to define what the function should look like. Let''s
    re-write the preceding JavaScript sample in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first function definition, `myCallBack` now strongly types the `text` parameter
    to be of type `string`. Our `callingFunction` function has two parameters; `initialText`,
    which is of type `string`, and `callback`, which now has the new function signature
    syntax. Let''s look at this function signature more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What this function definition is saying, is that the `callback` argument is
    typed (by the `:` syntax) to be a function, using the fat arrow syntax `() =>`.
    Additionally, this function takes a parameter named `text` that is of type `string`.
    To the right of the fat arrow syntax, we can see a new TypeScript basic type,
    called `void`. Void is a keyword to denote that a function does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `callingFunction` function will only accept, as its second argument,
    a function that takes a single string parameter and returns nothing. Compiling
    the preceding code will correctly highlight an error in the last line of the code
    snippet, where we passing a string as the second parameter, instead of a callback
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the preceding function signature for the callback function, the following
    code would also generate compile time errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a function named `myCallBackNumber`, that takes a number
    as its only parameter. When we attempt to compile this code, we will get an error
    message indicating that the `callback` parameter, which is our `myCallBackNumber`
    function, also does not have the correct function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The function signature of `myCallBackNumber` would actually be `(arg1:number)
    => void`, instead of the required `(text: string) => void`, hence the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In function signatures, the parameter name (`arg1` or `text`) does not need
    to be the same. Only the number of parameters, their types, and the return type
    of the function need to be the same.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful feature of TypeScript — defining in code what the signatures
    of functions should be, and warning users when they do not call a function with
    the correct parameters. As we saw in our introduction to TypeScript, this is most
    significant when we are working with third-party libraries. Before we are able
    to use third-party functions, classes, or objects in TypeScript, we need to define
    what their function signatures are. These function definitions are put into a
    special type of TypeScript file, called a declaration file, and saved with a `.d.ts`
    extension. We will take an in-depth look at declaration files in [Chapter 4](ch04.html
    "Chapter 4. Writing and Using Declaration Files"), *Writing and Using Declaration
    Files*.
  prefs: []
  type: TYPE_NORMAL
- en: Function callbacks and scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript uses lexical scoping rules to define the valid scope of a variable.
    This means that the value of a variable is defined by its location within the
    source code. Nested functions have access to variables that are defined in their
    parent scope. As an example of this, consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet defines a function named `testScope`. The variable `testVariable`
    is defined within this function. The `print` function is a child function of `testScope`,
    so it has access to the `testVariable` variable. The last line of the code, however,
    will generate a compile error, because it is attempting to use the variable `testVariable`,
    which is lexically scoped to be valid only inside the body of the `testScope`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Simple, right? A nested function has access to variables depending on its location
    within the source code. This is all well and good, but in large JavaScript projects,
    there are many different files and many areas of the code are designed to be re-usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how these scoping rules can become a problem. For this
    sample, we will use a typical callback scenario—using jQuery to execute an asynchronous
    call to fetch some data. Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we are defining a variable named `testVariable` and setting
    its value. We then define a function called `getData`. The `getData` function
    sets another variable called `testVariable_2`, and then calls the jQuery `$.ajax`
    function. The `$.ajax` function is configured with three properties: `url`, `success`,
    and `error`. The `url` property is a simple string that points to a `sample_json.json`
    file in our project directory. The `success` property is an anonymous function
    callback, that simply logs the values of `testVariable` and `testVariable_2` to
    the console. Finally, the `error` property is also an anonymous function callback,
    that simply pops up an alert.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code runs as expected, and the success function will log the following
    results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. Now, let''s assume that we are trying to refactor the preceding
    code, as we are doing quite a few similar `$.ajax` calls, and want to reuse the
    `success` callback function elsewhere. We can easily switch out this anonymous
    function, and create a named function for our `success` callback, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this sample, we have created a new function named `successCallback` with
    the same parameters as our previous anonymous function. We have also modified
    the `$.ajax` call to simply pass this function in, as a callback function for
    the `success` property: `success: successCallback`. If we were to compile this
    code now, TypeScript would generate an error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Since we have changed the lexical scope of our code, by creating a named function,
    the new `successCallback` function no longer has access the variable `testVariable_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is fairly easy to spot this sort of error in a trivial example, but in larger
    projects, and when using third-party libraries, these sorts of errors become more
    difficult to track down. It is, therefore, worth mentioning that when using callback
    functions, we need to understand this lexical scope. If your code expects a property
    to have a value, and it does not have one after a callback, then remember to have
    a look at the context of the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As JavaScript is a dynamic language, we can often call the same function with
    different argument types. Consider the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a simple `add` function that returns the sum of its two
    parameters, `x` and `y`. The last three lines of this code snippet simply log
    the result of the `add` function with different types: two numbers, two strings,
    and two boolean values. If we run this code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript introduces a specific syntax to indicate multiple function signatures
    for the same function. If we were to replicate the preceding code in TypeScript,
    we would need to use the function overload syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this code snippet specifies a function overload signature
    for the `add` function that accepts two strings and returns a `string`. The second
    line specifies another function overload that uses numbers, and the third line
    uses booleans. The fourth line contains the actual body of the function and uses
    the type specifier of `any`. The last three lines of this snippet show how we
    would use these function signatures, and are similar to the JavaScript code that
    we have been using previously.
  prefs: []
  type: TYPE_NORMAL
- en: There are three points of interest in the preceding code snippet. Firstly, none
    of the function signatures on the first three lines of the snippet actually have
    a function body. Secondly, the final function definition uses the type specifier
    of `any` and eventually includes the function body. The function overload syntax
    must follow this structure, and the final function signature, that includes the
    body of the function must use the `any` type specifier, as anything else will
    generate compile-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third point to note, is that we are limiting the `add` function, by using
    these function overload signatures, to only accept two parameters that are of
    the same type. If we were to try and mix our types; for example, if we call the
    function with a `boolean` and a `string`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript would generate compile errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to contradict our final function definition though. In the original
    TypeScript sample, we had a function signature that accepted `(arg1: any, arg2:
    any)`; so, in theory, this should be called when we try to add a `boolean` and
    a `number`. The TypeScript syntax for function overloads, however, does not allow
    this. Remember that the function overload syntax must include the use of the `any`
    type for the function body, as all overloads eventually call this function body.
    However, the inclusion of the function overloads above the function body indicates
    to the compiler that these are the only signatures that should be available to
    the calling code.'
  prefs: []
  type: TYPE_NORMAL
- en: Union types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the release of TypeScript 1.4, we now have the ability to combine one
    or two types using the pipe symbol (`|`) to denote a Union Type. We can, therefore,
    rewrite our `add` function overrides in the previous code snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This function, named `addWithUnion` has two arguments, `arg1` and `arg2`. These
    arguments are are now using the union type syntax to specify that these arguments
    can be either `string,` `number`, or `boolean`. Notice too that our return type
    for the function is again using union types, meaning that the function will return
    one of these types as well.
  prefs: []
  type: TYPE_NORMAL
- en: Type guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within the body of the `addWithUnion` function in the preceding code snippet,
    we check whether the type of the `arg1` argument is a string, with the statement
    `typeof arg1 === "string"`. This is known as a type guard and means that the type
    of `arg1` will be treated as a `string` within the `if` statement block. Within
    the body of the next `if` statement, the type of `arg1` will be treated as a number,
    allowing us to add `10` to its value, and in the body of the last if statement,
    the type will be treated as a `boolean` by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are also able to define an alias for a type, a union type, or a function
    definition. Type aliases are denoted by using the `type` keyword. We can, therefore,
    write our preceding `add` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a type alias named `StringNumberOrBoolean` that is a type
    union of the `string`, `number`, and `boolean` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type aliases can also be used for function signatures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a type alias named `CallbackWithString` that is a function
    that takes a single `string` parameter and returns a `void`. Our `usingCallback`
    function accepts this type alias within the function signature as the type for
    the `callback` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed TypeScript's basic types, variables, and
    function techniques. We saw how TypeScript introduces "syntactic sugar" on top
    of normal JavaScript code, to ensure strongly typed variables and function signatures.
    We also saw how TypeScript uses duck-typing and explicit casting, and finished
    up with a discussion on TypeScript functions, function signatures, and overloading.
    In the next chapter, we will build on this knowledge and see how TypeScript extends
    these strongly typed rules into interfaces, classes and generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
