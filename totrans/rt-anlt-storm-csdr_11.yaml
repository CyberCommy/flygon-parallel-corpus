- en: Chapter 11. Distributed Cache and CEP with Storm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the need for distributed caching in conjunction
    with Storm and the integration of widely used options with Storm. We will also
    touch upon the **Complex Event Processing** (**CEP**) engines in collaboration
    with Storm.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for distributed caches in the Storm framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to memcache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a topology with caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to CEP and Esper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you should be able to apply CEP and cache in conjunction
    with Storm to solve real-time use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The need for distributed caching in Storm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have explored Storm enough to understand all its strengths, let''s
    touch on one of its biggest weaknesses: the lack of a shared cache, a common store
    in memory that all tasks running across the workers on various nodes in the Storm
    cluster can access and write to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates a three node Storm cluster where we have two
    workers running on each of the supervisor nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The need for distributed caching in Storm](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As depicted in the preceding figure, each worker has its own JVM where the
    data can be stored and cached. However, what we are missing here is a layer of
    cache that shares components within the workers on a supervisor as well as across
    the supervisors. The following figure depicts the need for what we are referring
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The need for distributed caching in Storm](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure depicts the need for a shared caching layer where common
    data can be placed, which is referable from all nodes. These are very valid use
    cases because in production, we encounter scenarios such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a lot of read-only reference dimensional data, which we would want in
    one place instead of having it replicated and updated at each supervisor level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we have transactional data in certain use cases, which are to be
    read and updated by all the workers; for example, when counting certain events,
    the count has to be kept in a common location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is where the layer of common shared cache that is accessible across all
    supervisor nodes comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to memcached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcached is a very simple in-memory key value store; we can assume it to be
    an in-memory store for a hash map. This can be used in conjunction with Storm
    supervisors to serve as a common memory storage, which can be accessed for read/write
    operations by all the Storm workers on various nodes in the Storm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memcached has the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: The memcached server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memcache client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hashing algorithm (client-based implementation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server algorithm for data retention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcached uses **Least Recently Used** (**LRU**) to discard the elements from
    the cache. This means that the items that have not been referred since the longest
    time are the first ones to be removed from the cache. These items are said to
    be expired from the cache, and if they are referred after expiry, they are reloaded
    from a stable storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the flow of how entries are loaded and retrieved from or through
    a cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to memcached](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure depicts the scenarios of cache hit and cache miss, where
    certain items expire as per the LRU algorithm. The scenarios in the preceding
    figure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the cache app location starts, it's loaded with the data from the stable
    storage, in our case, from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two scenarios that can happen in a situation where we request the
    data from the cache:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache hit**: This is where the data we request exists on the cache server
    and in this case, the request is served from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache miss**: This is where the data requested doesn''t exist in the cache
    server, and in this case, the data is fetched from the database into the cache
    and then the request is serviced from the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we understand how the cache functions and what the need for it in the context
    of solutions for Storm is.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up memcache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps that need to be executed and will be required for
    the installation of memcache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code snippet to connect to the memcache client and functions.
    It retrieves the data from the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you encode the preceding snippet, you will have built the mechanism to
    create the cache client, load data into the cache, and retrieve values from it.
    So any Storm bolt that needs access to the cache can use the common layer created
    by memcache through interactions with the client.
  prefs: []
  type: TYPE_NORMAL
- en: Building a topology with a cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to the complex event processing engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two terms that are generally used in conjunction; they are **Complex
    Event Processing** (**CEP**) and **Event Stream Processing** (**ESP**).
  prefs: []
  type: TYPE_NORMAL
- en: Well, in theory, these are part of a technical paradigm that allow us to build
    applications with dramatic, real-time analytics over streaming data. They let
    us process incoming events at a very fast rate and execute SQL-like queries on
    top of the stream of events to generate real-time histograms. We can assume that
    CEP is an inversion of traditional databases. In the case of traditional DBMS
    and RDBMS, we have data stored, and then we run SQL queries over them to arrive
    at results, while in the case of CEPs, we have the queries predefined or stored
    and we run the data through them. We can envision this with an example; let's
    say I am running a department store and I would like to know the highest selling
    item in the last one hour. So if you look here, the query we are about to execute
    is pretty fixed in nature but the input data isn't constant—it changes at each
    sale transaction. Similarly, let's say I run a stock holding company and would
    like to know the top 10 performers over the last 2 minutes every 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to the complex event processing engine](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding figure depicts the stock ticker use case where we have a sliding
    window of 2 minutes and the stock ticker is sliding every 5 seconds. We have many
    practical use cases for this nowadays, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Fraud detection patterns against **Point Of Sales** (**POS**) transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top *N* in any segment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application of deep learning patterns to stream data from any source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, having understood CEP and its need at a high level, let''s touch upon
    its high-level components:'
  prefs: []
  type: TYPE_NORMAL
- en: The operand in every CEP is `Data` of `Event`; it's essentially an event-driven
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event processing language**: This is the tool that facilitates the framing
    of queries to be executed on the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listeners**: These are the components that actually execute the query and
    perform the action on the arrival of the event into the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Esper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Esper is one of the leading CEP engines that are available under open source—GPL
    and Enterprise License. The package can be downloaded from [http://www.espertech.com/download/](http://www.espertech.com/download/),
    and if you are attempting to execute a Maven-based Esper project, the dependency
    can be built as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next obvious question could be why we want to use Esper-CEP in conjunction
    with Storm. Well, Esper has some unique capabilities that work well with Storm
    and let the EQL facility leverage the results drawn over Storm. The following
    are complementing features that lead to this choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Throughput**: Complementing the capability of Storm, Esper also has a very
    high throughput and can process from 1K to 100K messages per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency**: Esper has the ability to perform EQLs and actions based on results
    of Esper at a very low latency rate; in most cases, this is the order of milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computations**: These refer to the ability to perform functions such as pattern
    detection, complex queries based on aggregates, and correlation over time. These
    slice windows of streaming data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Esper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the value object in place, the next step is to instantiate the
    Esper engine and listener and wire in all the pieces together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: CEPListener is the implementation of `updateListener` (which listens for the
    arrival of the event), `newData` has the stream of one or more new arriving events,
    and `oldData` has the previous state of the stream, that is, before the arrival
    of the current trigger to the listener.
  prefs: []
  type: TYPE_NORMAL
- en: In the main method, we can load the Esper configuration or, as shown in our
    preceding case, create a default configuration. Then, we create an Esper runtime
    engine instance and bind the EQL query to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the `cepStatement.addListener(new CEPListener())` statement in
    the preceding code, you will see that we are also binding the listener to the
    statement, thus wiring all the pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Esper with Storm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following figure depicts how we plan to use Esper in conjunction with one
    of the topologies we created earlier in [Chapter 6](part0045_split_000.html#page
    "Chapter 6. Adding NoSQL Persistence to Storm"), *Adding NoSQL Persistence to
    Storm*. The integration of Storm with Esper gives the developer the power to execute
    SQL-like queries on top of the stream of events being processed by Storm.
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Esper with Storm](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to conjugate the Esper bolt into the topology. This can be
    easily downloaded as a bundle from [https://github.com/tomdz/storm-esper](https://github.com/tomdz/storm-esper),
    and it can be quickly bundled into the topology using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the output would be like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating Esper with Storm](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Esper query in the preceding figure executes on a stream of incoming data;
    here is its breakdown and explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are selecting the following fields from the incoming tuples, such as `Call_Id`,
    `Call_type`, and `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The named window out of which we are operating is `CDR.WIN`. The batch size
    is 5 minutes, which means that with the arrival of every event or tuple, we are
    looking back into time for 5 minutes and executing the query over data that has
    arrived in the last 5 minutes. The results are grouped by the event type and are
    sorted in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Q.1\. State whether the following statements are true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: Cache is a read-only memory space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data once added in cache remains there forever.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CEP lets SQL-like queries be implemented over streaming data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Esper is based on event-driven architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Q.2\. Fill in the blanks:'
  prefs: []
  type: TYPE_NORMAL
- en: _______________ is the algorithm for memcache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When data is not present in the cache, it's called ______________.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: _______________ is the component of Esper that triggers the **Endeca Query Language**
    (**EQL**) execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: _______________ is generally used for the time series windowing function data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q.3\. Create an end-to-end topology using Esper to display the top 10 speeding
    devices on a said freeway using Storm and Esper in conjunction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the concept of cache in conjunction with Storm and
    the utility and application of the solutions developer with cache. We learned
    about memcache as a caching system.
  prefs: []
  type: TYPE_NORMAL
- en: In the later part of the chapter, we explored Esper as a complex event processing
    system and understood its integration with Storm topologies.
  prefs: []
  type: TYPE_NORMAL
