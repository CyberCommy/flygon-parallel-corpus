- en: Appendix A. Tools to Make Life Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered many things in this book, starting with new features in PHP 7 and
    ending with the best techniques in programming. In each chapter, we used and talked
    about some tools, but due to the finite length of chapters and the book, we did
    not go too much in detail for these tools. In this appendix, we will discuss three
    of these tools in much more detail. The tools we will to discuss are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grunt watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start.
  prefs: []
  type: TYPE_NORMAL
- en: Composer – A dependency manager for PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composer is a dependency management tool for PHP that enables us to define dependencies
    for a PHP application, and Composer installs/updates them. Composer is completely
    written in PHP and is an application in the PHP Archive (PHAR) format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composer downloads dependencies from [https://packagist.org/](https://packagist.org/).
    Any dependency for an application can be installed through Composer as long as
    it is available on Packagist. Also, complete applications can be installed through
    Composer if they are available at Packagist.
  prefs: []
  type: TYPE_NORMAL
- en: Composer installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composer is a command line tool and can be installed globally in the operating
    system, or the `composer.phar` file can be placed in the root of the application
    and then executed from the command line. For Windows, an executable setup file
    is provided, which can be used to install Composer globally. For this book, we
    will follow the instructions for Debian/Ubuntu globally. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following command to download the Composer installer. The file name
    is `installer` and can only be executed with PHP once installed via the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Issue the following command to install it globally on Debian or Ubuntu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will download Composer and will install it in the `/usr/local/bin`
    directory with the file name `composer`. Now, we will be able to run Composer
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the Composer installation by issuing the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the Composer version is displayed, then Composer is successfully installed
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Composer is installed locally to an application, then we will have a `composer.phar`
    file. The commands are the same, but all the commands should be executed with
    PHP. For example, `php composer.phar --version` will display the Composer version.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Composer is installed successfully and is working; it's time to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Composer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Composer in our project, we will need a `composer.json` file. This file
    contains all the dependencies required for the project and some other metadata.
    Composer uses this file to install and update different libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that our application needs to log different information in different
    ways. For this, we can use the `monolog` library. First, we will create a `composer.json`
    file in the root of our application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, execute the following command to install the dependencies
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will download the dependencies and place them in the `vendor`
    directory, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Composer](graphics/B05225_appendix_a_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding screenshot, monolog version 1.0.2 is downloaded,
    and a `vendor` directory is created. The `monolog` library is placed in this directory.
    Also, if a package has to autoload information, then Composer places the library
    in the Composer autoloader, which is also placed in the `vendor` directory. So,
    any new libraries or dependencies will be autoloaded automatically during the
    application's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Also a new file can be seen, which is `composer.lock`. When Composer downloads
    and installs any dependencies, the exact version and other information is written
    to this file to lock the application to this specific version of dependencies.
    This ensures that all the team members or whoever wants to set up the application
    will use the exact same version of the dependencies, and thus, it will reduce
    the chances of using different versions of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, Composer is widely used for package management. Big open source projects
    such as Magento, Zend Framework, Laravel, Yii, and many others are easily available
    for installation through Composer. We will install some of these in the next appendix
    using Composer.
  prefs: []
  type: TYPE_NORMAL
- en: Git – A version control system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is the most widely used version control system. According to the Git official
    website, it is a distributed version control system capable of handling everything
    from small- to large-sized projects with speed and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Git installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git is available for all major operating systems. For Windows, an executable
    setup file is provided that can be used to install Git and use it in the command
    line. On OS X, Git comes already installed, but if it is not found, it can be
    downloaded from their official website. To install Git on Debian/Ubuntu, just
    issue the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation, issue the following command to check whether it is properly
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will see the current installed version of Git.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a better understanding of Git, we will start with a test project. Our test
    project name is `packt-git`. For this project, we also created a GitHub repository
    named `packt-git`, where will push our project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will initialize Git in our project by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will initialize an empty Git repository in our project
    root directory, and the head will be kept on the master branch, which is the default
    branch for every Git repository. It will create a hidden `.git` directory that
    will contain all the information about the repository. Next, we will add a remote
    repository that we will create on GitHub. I created a test repository at GitHub
    that has the URL [https://github.com/altafhussain10/packt-git.git](https://github.com/altafhussain10/packt-git.git).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, issue the following command to add the GitHub repository to our empty
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a `README.md` file at your project root and add some content to
    it. The `README.md` file is used to display the repository information and other
    details about the repository at Git. This file is also used to display instructions
    regarding how to use the repository and/or the project for which this repository
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, issue the following command to see the status of our Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will display the status of the repository, as can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Git](graphics/B05225_appendix_a_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen in the preceding screenshot, we have an untracked file in our
    repository that is not committed yet. First, we will add the files to be tracked
    by issuing the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git add` command updates the index using the current contents found in
    the working tree. This command adds all the changes made to the path. There are
    some options that can be used to add some specific changes. The previous command
    we used will only add the `README.md` file to the track in the repository. So,
    if we want to track all the files, then we will use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start tracking all the files in the current working directory or
    at the root of the current branch. Now, if we want to track some specific files,
    such as all files with the `.php` extension, then we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will add all the files with the `.php` extension to track.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will commit changes or additions to our repository using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `git commit` command commits all the changes to the local repository. The
    `-m` flag specifies any log message to `commit`. Remember that the changes are
    only committed to the local repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will push the changes to our remote repository using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will push all the changes from the local repository to
    the remote repository or origin. The `-u` flag is used to set the upstream, and
    it links our local repo to our remote central repo. As we pushed our changes for
    the first time, we have to use the `-u` option. After this, we can just use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will push all the changes to the main repository of the current branch
    at which we are.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new branches and merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New branches are always required during development. If any kind of changes
    are required, it is good to create a new branch for these changes. Then, make
    all the changes on this branch and finally commit, merge, and push them to the
    remote origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this, let''s suppose we want to fix an issue in the login
    page. The issue is about validation errors. We will name our new branch `login_validation_errors_fix`.
    It is good practice to give a more understandable name to branches. Also, we would
    like to create this new branch from the master branch head. This means that we
    want the new branch to inherit all the data from the master branch. So, if we
    are not at the master branch, we have to use the following command to switch to
    the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will switch us to the master branch no matter which branch
    we are at. To create the branch, issue the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our new branch is created from the master branch head, so all the changes
    should be made to this new branch. After all the changes and fixes are done, we
    have to commit the changes to the local and remote repositories. Note that we
    did not create the new branch in our remote repository. Now, let''s commit the
    changes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we did not use `git add` to add the changes or new additions. To
    automatically commit our changes, we used the `-a` option in `commit`, which will
    add all the files automatically. If `git add` is used, then there is no need to
    use the `-a` option in `commit`. Now, our changes are committed to the local repository.
    We will need to push the changes to the remote origin. Issue the following command
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a new branch at the remote repository, set
    the tracking of the same local branch to the remote branch, and push all the changes
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to merge the changes with our master branch. First, we need to
    switch to our master branch using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will issue the following commands to merge our new branch `login_validation_errors_fix`
    with the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is important to switch to the branch to which we want to merge our new branch.
    After this, we need to use the `git merge branch_to_merge` syntax to merge this
    branch with the current branch. Finally, we can just push to the remote origin.
    Now, if we take a look at our remote repository, we will see the new branch and
    also the changes in our master branch.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we need to work on a project that is hosted on a repository. For
    this, we will first clone this repository, which will download the complete repository
    to our local system, and then create a local repository for this remote repository.
    The rest of the working is the same as we discussed before. To clone a repository,
    we should first know the remote repository web address. Let''s say that we want
    to clone the `PHPUnit` repository. If we go to the GitHub repository for PHPUnit,
    we will see the web address of the repository at the upper right-hand side, as
    shown in the screenshot that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning a repository](graphics/B05225_appendix_a_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL just after the **HTTPS** button is the web address for this repository.
    Copy this URL and use the following command to clone this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will start downloading the repository. After it is completed, we will have
    a `PHPUnit` folder that will have the repository and all its files. Now, all the
    operations mentioned in the preceding topics can be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most powerful features of Git is webhooks. Webhooks are events that
    are fired when a specific action occurs on the repository. If an event or hook
    for the `Push` request is made, then this hook will be fired every time a push
    is made to this repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a webhook to a repository, click on the **Settings** link for the repository
    in the upper right-hand side. In the new page, on the left-hand side, we will
    have a **Webhooks and Services** link. Click on it, and we will see a page similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Webhooks](graphics/B05225_appendix_a_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding screenshot, we have to enter a payload URL,
    which will be called every time our selected event is fired. In **Content type**,
    we will select the data format in which the payload will be sent to our URL. In
    the events section, we can select whether we want only push events or all the
    events; we can select multiple events for which we want this hook to be fired.
    After saving this hook, it will be fired every time the selected event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks are mostly used for deployment. When the changes are pushed and if
    there is a webhook for the push event, the specific URL is called. Then, this
    URL executes some command to download the changes and processes them on the local
    server and places them at the appropriate place. Also, webhooks are used for continues
    integration and to deploy to cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop tools to manage repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several tools that can be used to manage Git repositories. GitHub
    provides its own tool called GitHub Desktop that can be used to manage GitHub
    repositories. This can be used to create new repositories, see the history, and
    push, pull, and clone repositories. It provides every feature that we can use
    in the command line. The screenshot that follows shows our test `packt-git` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desktop tools to manage repositories](graphics/B05225_appendix_a_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Desktop can be downloaded from [https://desktop.github.com/](https://desktop.github.com/)
    and is available for Mac and Windows only. Also, GitHub Desktop can be only used
    with GitHub unless some hacks are used to make it work with other repositories,
    such as GitLab or Bitbucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another powerful tool is SourceTree. SourceTree can be used with GitHub, GitLab,
    and Bitbucket easily. It provides complete features to manage repositories, pull,
    push, commit, merge, and other actions. SourceTree provides a very powerful and
    beautiful graph tool for the branches and commits. The following is a screenshot
    for SourceTree that is used to connect with our `packt-git` test repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Desktop tools to manage repositories](graphics/B05225_appendix_a_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Besides the previous two nice tools, every development IDE provides version
    control systems with full support and also provides features such as different
    colors for modified and newly added files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git is a powerful tool; it can't be covered in this appendix. There are several
    books available, but Git Book is a very good place to start. This can be downloaded
    in different formats from [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)
    or can be read online.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt watch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We studied Grunt in [Chapter 3,](ch03.html "Chapter 3. Improving PHP 7 Application
    Performance") *Improving PHP 7 Application Performance*. We only used it to merge
    CSS and JavaScript files and minify them. However, Grunt is not used only for
    this purpose. It is a JavaScript task runner, which can run tasks either by watching
    specific files for changes or by manually running tasks. We studied how we can
    run tasks manually, so now we will study how to use grunt watch to run specific
    tasks when some changes are made.
  prefs: []
  type: TYPE_NORMAL
- en: Grunt watch is useful and saves a lot of time because it runs the specific tasks
    automatically instead of running the tasks manually every time we change something.
  prefs: []
  type: TYPE_NORMAL
- en: Let's recall our examples from [Chapter 3](ch03.html "Chapter 3. Improving PHP
    7 Application Performance"), *Improving PHP 7 Application Performance*. We used
    Grunt to combine and compress CSS and JavaScript files. For this purpose, we created
    four tasks. One task was combining all CSS files, the second task was combining
    all JavaScript files, the third task was compressing the CSS files, and the fourth
    task was compressing all JavaScript files. It will be very time consuming if we
    run all these tasks manually every time we make some changes. Grunt provides a
    feature called watch that watches different destinations for file changes, and
    if any change occurs, it executes the tasks that are defined in the watch.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check whether the `grunt watch` module is installed or not. Check the
    `node_modules` directory and see whether there is another directory with the name
    `grunt-contrib-watch`. If this directory is there, then watch is already installed.
    If the directory is not there, then just issue the following command in the terminal
    at the project root directory where `GruntFile.js` is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install Grunt watch and the `grunt-contrib-watch`
    directory will be available with the `watch` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will modify this `GruntFile.js` file to add the `watch` module, which
    will monitor all the files in our defined directories, and if any changes occur,
    it will run these tasks automatically. This will save a lot of time in manually
    executing these tasks again and again. Look at the following code; the highlighted
    code is the modified section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In preceding highlighted code, we added a `watch` block. The `mywatch` title
    can be any name. The `files` block is required, and it takes an array of the source
    paths. The Grunt watch watches for changes in these destinations and executes
    the tasks that are defined in the tasks block. Also, the tasks that are mentioned
    in the `tasks` block are already created in `GruntFile.js`. Also, we have to load
    the `watch` module using `grunt.loadNpmTasks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the terminal at the root of the project where `GruntFile.js` is located
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Grunt will start watching the source files for changes. Now, modify any file
    in the paths defined in the `files` block in `GruntFile.js` and save the file.
    As soon as the file is saved, the tasks will be executed and the output for the
    tasks will be displayed in the terminal. A sample output can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grunt watch](graphics/B05225_appendix_a_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is possible to watch as many tasks as required in the `watch` block, but
    these tasks should be present in `GruntFile.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we discussed Composer and how to use it to install and update
    packages. Also, we discussed Git in detail, including pushing, pulling, committing,
    creating branches, and merging different branches. Also, we discussed Git hooks.
    Lastly, we discussed Grunt watch and created a watch that executed four tasks
    whenever any changes occurred in the files paths defined in `GruntFile.js`.
  prefs: []
  type: TYPE_NORMAL
