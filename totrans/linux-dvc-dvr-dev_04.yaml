- en: Character Device Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Character devices transfer data to or from a user application by means of characters,
    in a stream manner (one character after another), like a serial port does. A character
    device driver exposes the properties and functionalities of a device by means
    of a special file in the `/dev` directory, which one can use to exchange data
    between the device and user application, and also allows you to control the real
    physical device. This is the basic concept of Linux that says *everything is a
    file* . A character device driver represents the most basic device driver in the
    kernel source. Character devices are represented in the kernel as instances of
    `struct cdev` , defined in `include/linux/cdev.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This chapter will walk through the specificities of character device drivers,
    explain how they create, identify, and register the devices with the system, and
    also give a better overview of the device file methods, which are methods by which
    the kernel exposes the device capabilities to user space, accessible by using
    file related system calls (`read` , `write` , `select` , `open` , `close` and
    so on), described in `struct file_operations` structures, which you have certainly
    heard of before.
  prefs: []
  type: TYPE_NORMAL
- en: The concept behind major and minor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Character devices are populated in the `/dev` directory. Do note that, they
    are not only files present in that directory. A character device file is recognizable
    to its type, which we can display thanks to the command `ls -l` . Major and minor
    identify and tie the devices with the drivers. Let us see how it works, by listing
    the content of the `*/dev*` directory (`ls -l /dev` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the preceding excerpt, the first character of the first column identifies
    the file type. Possible values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`c` : This is for character device files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b` : This is for block device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` : This is for symbolic link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` : This is for directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` : This is for socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` : This is for named pipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `b` and `c` file types, the fifth and sixth columns right before the date
    respect the <`X, Y` > pattern. `X` represents the major, and `Y` is the minor.
    For example, the third line is <`1, 2` > and the last one is <`7, 3` >. That is
    one of the classical methods for identifying a character device file from user
    space, as well as its major and minor.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel holds the numbers that identify a device in `dev_t` type variables,
    which are simply `u32` (32-bit unsigned long). The major is represented with only
    12 bits, whereas the minor is coded on the 20 remaining bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'As one can see in `include/linux/kdev_t.h` , given a `dev_t` type variable,
    one may need to extract the minor or the major. The kernel provides a macro for
    these purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you may have a minor and a major, and need to build a `dev_t`
    . The macro you should use is `MKDEV(int major, int minor);` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The device is registered with a major number that identifies the device, and
    a minor, which one may use as an array index to a local list of devices, since
    one instance of the same driver may handle several devices while different drivers
    may handle different devices of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Device number allocation and freeing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Device numbers identify device files across the system. That means, there are
    two ways to allocate these device numbers (actually major and minor):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Statically** : Guessing a major not yet used by another driver using the
    `register_chrdev_region()` function. One should avoid using this as much as possible.
    Its prototype looks this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method returns `0` on success, or a negative error code on failure. `first`
    is made of the major number that we need along with the first minor of the desired
    range. One should use `MKDEV(ma,mi)` . `count` is the number of consecutive device
    numbers required, and `name` should be the name of the associated device or driver.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamically** : Letting the kernel do the job for us, using the `alloc_chrdev_region()`
    function. This is the recommended way to obtain a valid device number. Its prototype
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This method returns `0` on success, or a negative error code on failure. `dev`
    is the ony output parameter. It represents the first number the kernel assigned.
    `firstminor` is the first of the requested range of minor numbers, `count` the
    number of minors one requires, and `name` should be the name of the associated
    device or driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the two is that with the former, one should know in
    advance what number we need. This is registration: one tells the kernel what device
    numbers we want. This may be used for pedagogic purposes, and works as long as
    the only user of the driver is you. When it comes to loading the driver on another
    machine, there is no guarantee the chosen number is free on that machine, and
    this will lead to conflicts and trouble. The second method is cleaner and much
    safer, since the kernel is responsible for guessing the right numbers for us.
    We do not even have to care about what the behavior would be on loading the module
    on to another machine, since the kernel will adapt accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, the preceding functions are generally not called directly from the driver,
    but masked by the framework on which the driver relies (IIO framework, input framework,
    RTC, and so on), by means of dedicated API. These frameworks are all discussed
    in further chapters in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to device file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Operations that one can perform on files depend on the drivers that manage
    those files. Such operations are defined in the kernel as instances of `struct
    file_operations` . `struct file_operations` exposes a set of callbacks that will
    handle any user-space system call on a file. For example, if one wants users to
    be able to perform a `write` on the file representing our device, one must implement
    the callback corresponding to that `write` function and add it into the `struct
    file_operations` that will be tied to your device. Let''s fill in a file operations
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding excerpt only lists important methods of the structure, especially
    the ones that are relevant for the needs of this book. One can find the full description
    in `include/linux/fs.h` in kernel sources. Each of these callbacks is linked with
    a system call, and none of them is mandatory. When a user code calls a files-related
    system call on a given file, the kernel looks for the driver responsible for that
    file (especially the one that created the file), locates its `struct file_operations`
    structure, and checks whether the method that matches the system call is defined
    or not. If yes, it simply runs it. If not, it returns an error code that varies
    depending on the system call. For example, an undefined `(*mmap)` method will
    return `-ENODEV` to user, whereas an undefined `(*write)` method will return `-EINVAL`
    .
  prefs: []
  type: TYPE_NORMAL
- en: File representation in the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel describes files as instances of struct inode (not struct file) structure,
    defined in `include/linux/fs.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `struct inode` is a filesystem data structure holding information, which
    is only relevant to the OS, about a file (whatever its type, character, block,
    pipe, and so on) or directory (yes!! from a kernel point of view, a directory
    is a file that on entry points to other files) on disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `struct file` structure (also defined in `include/linux/fs.h` ) is actually
    a higher level of file description that represents an open file in the kernel
    and which relies on the lower `struct inode` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between `struct inode` and `struct file` is that an inode doesn''t
    track the current position within the file or the current mode. It only contains
    stuff that helps the OS find the contents of the underlying file structure (pipe,
    directory, regular disk file, block/character device file, and so on). On the
    other hand, the `struct file` is used as a generic structure (it actually holds
    a pointer to a `struct inode` structure) that represents and open file and provides
    a set of functions related to methods one can perform on the underlying file structure.
    Such methods are: `open` , `write` , `seek` , `read` , `select` , and so on. All
    this reinforces the philosophy of UNIX systems that says *everything is file*
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a `struct inode` represents a file in the kernel, and a `struct
    file` describes it when it is actually open. There may be different file descriptors
    that represent the same file opened several times, but these will point to the
    same inode.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and registering a character device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Character devices are represented in the kernel as instances of `struct cdev`
    . When writing a character device driver, your goal is to finally create and register
    an instance of that structure associated with a `struct file_operations` , exposing
    a set of operations (functions) the user-space can perform on the device. To reach
    that goal, there are some steps we must go through, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserve a major and a range of minors with `alloc_chrdev_region()` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class for your devices with `class_create(),` visible in `/sys/class/`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a `struct file_operation` (to be given to `cdev_init` ), and for each
    device one needs to create, call `cdev_init()` and `cdev_add()` to register the
    device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then `create a device_create()` for each device, with a proper name. It will
    result in your device being created in the `/dev` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Writing file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing the preceding file operations, it is time to implement them
    in order to enhance the driver capabilities and expose the device's methods to
    the user space (by means of system calls or course). Each of these methods has
    its particularities, which we will highlight in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging data between kernel space and user space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section does not describe any driver file operation but instead, introduces
    some kernel facilities that one may use to write these driver methods. The driver's
    `write()` method consists of reading data from user space to kernel space, and
    then processing that data from the kernel. Such processing could be something
    like *pushing* the data to the device, for example. On the other hand, the driver's
    `read()` method consists of copying data from the kernel to the user space. Both
    of these methods introduces new elements we need to discuss prior to jumping to
    their respective steps. The first one is `__user` . `__user` is a cookie used
    by sparse (a semantic checker used by the kernel to find possible coding faults)
    to let the developer know he is actually about to use an untrusted pointer (or
    a pointer that may be invalid in the current virtual address mapping) improperly
    and that he should not dereference but instead, use dedicated kernel functions
    to access the memory to which this pointer points.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to introduce different kernel functions needed to access such
    memory, either to read or write. These are `copy_from_user()` and `copy_from_user()`
    respectively to copy a buffer from user space to kernel space, and vice versa,
    to copy a buffer from kernel to user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, pointers prefixed with `__user` point to user space (untrusted)
    memory. `n` represents the number of bytes to copy. `from` represents the source
    address, and `to` is the destination address. Each of these returns the number
    of bytes that could not be copied. On success, the return value should be `0`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Please do note that with `copy_to_user()` , if some data could not be copied,
    the function will pad the copied data to the requested size using zero bytes.
  prefs: []
  type: TYPE_NORMAL
- en: A single value copy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to copying single and simple variables like `char` and `int`
    but not larger data types like structures nor arrays, the kernel offers dedicated
    macros in order to quickly perform the desired operation. These macros are `put_user(x,
    ptr)` and `get_used(x, ptr)` , which are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`put_user(x, ptr);` : This macro copies a variable from kernel space to user
    space. `x` represents value to copy to user space, and `ptr` is the destination
    address in user space. The macro returns `0` on success, or `-EFAULT` on error.
    `x` must be assignable to the result of dereferencing `ptr` . In other words,
    they must have (or point to) the same type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_user(x, ptr);` : This macro copies a variable from user space to kernel
    space, and returns `0` on success or `-EFAULT` on error. Please do note that `x`
    is set to `0` on error. `x` represents the kernel variable to store the result,
    and `ptr` is the source address in user space. The result of dereferencing `ptr`
    must be assignable to `x` without a cast. Guess what it means.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The open method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`open` is the method called every time someone opens your device''s file. Device
    opening will always success in case where this method is not defined. One usually
    uses this method to perform device and data structure initialization, and return
    a negative error code if something goes wrong, or `0` .The prototype of `open`
    method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Per-device data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each `open` performed on your character device, the callback function will
    be given a `struct inode` as parameter, which is the kernel lower-level representation
    of the file. That `struct inode` structure has a field named `i_cdev` that points
    to the `cdev` we have allocated in the `init` function. By embedding the `struct
    cdev` in our device-specific data as in `struct pcf2127` in the following example,
    we will be able to get a pointer on that specific data using the `container_of`
    macro. Here is an `open` method sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this data structure, the `open` method would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The release method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `release` method is called when the device gets closed, the reverse of
    the `open` method. You must then undo everything you have done in the open task.
    What you have to do is roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: Free any private memory allocated during the `open()` step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shut down the device (if supported) and discard every buffer on the last closing
    (if the device supports multi opening, or if the driver can handle more than one
    device at a time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is an excerpt of a `release` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The write method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `write()` method is used to send data to the device; whenever a user app
    calls the `write` function on the device''s file, the kernel implementation is
    called. Its prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The return value is the number of bytes (size) written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*buf` represents the data buffer coming from the user space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` is the size of the requested transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*pos` indicates the start position from which data should be written in the
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to write
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following steps do not describe any standard nor universal method to implement
    the driver's `write()` method. They are just an overview of what kind of operations
    one can perform in this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for bad or invalid requests coming from the user space. This step is
    relevant only if the device exposes its memory (eeprom, I/O memory, and so on),
    which may have size limitations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust `count` for the remaining bytes in order to not go beyond the file size.
    This step is not mandatory neither, and is relevant in the same condition as step
    1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the location from which you will start to write. This step is relevant
    only if the device has a memory in which the `write()` method is supposed to write
    given data. As steps 2 and 3, this step is not mandatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy data from the user space and write it into the appropriate kernel space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Write to the physical device and return an error on failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Increase the current position of the cursor in the file, according to the number
    of bytes written. Finally, return the number of bytes copied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the `write` method. Once again, this is aimed
    to give an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The read method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prototype of the `read()` method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is the size read. The rest of the method''s elements are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*buf` is the buffer we receive from the user space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` is the size of the requested transfer (size of the user buffer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*pos` indicates the start position from which data should be read in the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prevent from reading beyond the file size, and return end-of-file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of bytes read can''t go beyond the file size. Adjust `count` appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the location from which you will start the read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the data into the user-space buffer and return an error on failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Advance the file''s current position according to the number of bytes read,
    and return the number of bytes copied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a driver `read()` file operation, which is intended
    to give an overview of what can be done there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The llseek method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `llseek` function is called when one moves the cursor position within a
    file. The entry point of this method in user space is `lseek()` . One can refer
    to the man-page in order to print the full description of either method from user
    space: `man llseek` and `man lseek` . Its prototype looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The return value is the new position in the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loff_t` is an offset, relative to the current file position, which defines
    how much it will be changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whence` defines where to seek from. Possible values are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_SET` : This puts the cursor into a position relative to the beginning
    of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_CUR` : This puts the cursor into a position relative to the current file
    position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_END` : This adjusts the cursor to a position relative to end-of-file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps to llseek
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `switch` statement to check every possible `whence` case, since they
    are limited, and adjust `newpos` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether `newpos` is valid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `f_pos` with the new position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the new file-pointer position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a user program that successively reads and seeks
    into a file. The underlying driver will then execute the `llseek()` file operation
    entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The poll method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If one needs to implement a passive wait (not wasting CPU cycles while sensing
    the character device), one must implement the `poll()` function, which will be
    called whenever a user-space program performs a `select()` or `poll()` system
    calls on the file associated with the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel function at the heart of this method is `poll_wait()` , defined
    in `<linux/poll.h>` , which is the header one should include in driver code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`poll_wait()` adds the device associated with a `struct file` structure (given
    as first parameter) to a list of those that can wake up processes (which have
    been put to sleep in the `struct wait_queue_head_t` structure given as second
    parameter), according to events registered into the `struct poll_table` structure
    given as third parameter. A user process can run `poll()` , `select()` , or `epoll()`
    system calls to add a set of files to a list on which it needs to wait, in order
    to be aware of the associated (if any) devices readiness. The kernel will then
    call the `poll` entry of the driver associated with each device file. The `poll`
    method of each driver should then call `poll_wait()` in order to register events
    for which the process needs to be notified with the kernel, put that process to
    sleep until one of these events occurs, and register the driver as one of those
    that can wake the process up. The usual way is to use a wait queue per event type
    (one for readability, another one for writability, and eventually one for exception
    if needed), according to events supported by the `select()` (or `poll()` ) system
    call.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the `(*poll)` file operation must have `POLLIN | POLLRDNORM`
    set if there is data to read (at the moment, select or poll is called), `POLLOUT
    | POLLWRNORM` if the device is writable (at the moment, select or poll is called
    here as well), and `0` if there is no new data and the device is not yet writable.
    In the following example, we assume the device supports both blocking read and
    write. Of course one may implement only one of these. If the driver does not define
    this method, the device will be considered as always readable and writable, so
    that `poll()` or `select()` system calls return immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to poll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When one implements the `poll` function, either the `read` or `write` method
    may change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a wait queue for each event type (read, write, exception) one needs
    to implement passive wait, to put tasks in when there is no data to read, or when
    the device is not writable yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `poll` function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notify the wait queue when there is new data or when the device is writable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: One can notify readable events either from within the driver's `write()` method,
    meaning that the written data can be read back, or from within an IRQ handler,
    meaning that an external device sent some data which can be read back. On the
    other hand, one can notify writable events either from within the driver's `read()`
    method, meaning that the buffer is empty and can be filled again, or from within
    an IRQ handler, meaning that the device has completed a data-send operation, and
    is ready to accept data again.
  prefs: []
  type: TYPE_NORMAL
- en: When using a sleepy input/output operation (blocked I/O), either the `read`
    or `write` method may change. The wait queue used in the poll must be used in
    read too. When the user needs to read, if there is data, that data will be sent
    immediately to the process and you must update the wait queue condition (set to
    `false` ); if there is no data, the process is put to sleep in the wait queue.
  prefs: []
  type: TYPE_NORMAL
- en: If the `write` method is supposed to feed data, then in the `write` callback,
    you must fill the data buffer and update the wait queue condition (set to `true`
    ), and wake up the reader (see the section *wait queue* ). If it is an IRQ instead,
    these operations must be performed in their handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of a code that `select()` on a given char device
    in order to sense data availability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The ioctl method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical Linux system contains around 350 system calls (syscalls), but only
    a few of them are linked with file operations. Sometimes devices may need to implement
    specific commands that are not provided by system calls, and especially the ones
    associated with files and thus device files. In this case, the solution is to
    use **input/output control** (**ioctl** ), which is a method by which one extends
    a list of syscalls (actually commands) associated with a device.. One can use
    it to send special commands to devices (`reset` , `shutdown` , `configure` , and
    so on). If the driver does not define this method, the kernel will return `-ENOTTY`
    error to any `ioctl()` system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be valid and safe, an `ioctl` command needs to be identified by
    a number which should be unique to the system. The unicity of ioctl numbers across
    the system will prevent it from sending the right command to the wrong device,
    or passing the wrong argument to the right command (given a duplicated ioctl number).
    Linux provides four helper macros to create an `ioctl` identifier, depending on
    whether there is data transfer or not and on the direction of the transfer. Their
    respective prototypes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Their descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_IO` : The `ioctl` does not need data transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOW` : The `ioctl` needs write parameters (`copy_from_user` or `get_user`
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOR` : The `ioctl` needs read parameters (`copy_to_user` or `put_user` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOWR` : The `ioctl` needs both write and read parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What their parameters mean (in the order they are passed) is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: A number coded on 8 bits (0 to 255), called magic number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sequence number or command ID, also on 8 bits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A data type, if any, that will inform the kernel about the size to be copied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is well documented in *Documentation/ioctl/ioctl-decoding.txt* in the kernel
    source, and existing `ioctl` are listed in *Documentation/ioctl/ioctl-number.txt*
    , a good place to start when you need to create an `ioctl` command.
  prefs: []
  type: TYPE_NORMAL
- en: Generating ioctl numbers (command)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One should generate their own ioctl number in a dedicated header file. It is
    not mandatory, but it is recommended, since this header should be available in
    user space too. In other words, one should duplicate the ioctl header file so
    that there is one in the kernel and one in the user space, which one can include
    in user apps. Let''s now generate ioctl numbers in a real example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eep_ioctl.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Steps for ioctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let us have a look at its prototype. It look likes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one step: use a `switch ... case` statement and return an `-ENOTTY`
    error when an undefined `ioctl` command is called. One can find more information
    at [http://man7.org/linux/man-pages/man2/ioctl.2.html](http://man7.org/linux/man-pages/man2/ioctl.2.html)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you think your `ioctl` command will need more than one argument, you should
    gather those arguments in a structure and just pass a pointer from the structure
    to `ioctl` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the user space, you must use the same `ioctl` header as in the driver''s
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_main.c`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Filling the file_operations structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing kernel modules, it is better to use designated initializers when
    it comes to statically initialize structures with their parameters. It consists
    of naming the member one needs to assign a value to. The form is `.member-name`
    to designate what member should be initialized. This allows, among other things,
    initializing the members in an undefined order, or leaving unchanged the fields
    that we do not want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined our functions, we just have to fill the structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Let us remember, the structure is given as a parameter to `cdev_init` in the
    `init` method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have demystified character devices and we have seen how
    to let users interact with our driver through device files. We learned how to
    expose file operations to the user space and control their behavior from within
    the kernel. We went so far that you are even able to implement multi-device support.
    The next chapter is a bit hardware oriented since it deals with platform drivers
    which expose hardware device capabilities to the user space. The power of character
    drivers combined with platform drivers is just amazing. See you in the next chapter.
  prefs: []
  type: TYPE_NORMAL
