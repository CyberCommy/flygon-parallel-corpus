- en: Learning About Character Animation, Collision, and Movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Animation is an art*. This raises questions about how we can create a virtual
    world that imitates the physical behavior of a person or objects by adding a texture
    or skin to each character or by maintaining an impeccable graphical user interface.
    While creating animation, we do not require knowledge of how controllers or physical
    devices work, yet animation is a medium between the physical devices and the characters
    of the games. Animation instructs players by guiding them with proper shading
    and movements in a pictorial view, and thus it is an art. We, as programmers,
    are accountable for where and why game characters move in certain directions,
    while animators are accountable for how they look and move.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Python `pygame` module, we can create animation and collision using
    sprites—a two-dimensional image that is part of the larger graphical scene. Maybe
    we can make one for ourselves or download one from the internet. After loading
    such sprites with pygame, we are going to learn about two fundamental blocks for
    building games: handling user events and building animation logic. Animation logic
    is a simple yet powerful logic that makes sprites or images move in a particular
    direction that is governed by user events.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with the concepts of the game
    controller and ways of using it to create animations for game characters. Along
    with this, you will also learn about collision principles and ways of dealing
    with them using the pygame masking method. Not only that, but you will also learn
    about ways to handle movements for game characters, such as jumping, tapping,
    and scrolling while making games such as flappy bird.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of game animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrolling background and character animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random object generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting collisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoring and end screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the following list of requirements to be able to complete this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame editor (IDLE) version 3.5 or higher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pycharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets and sprites for the Flappy Bird game are available in this book's
    GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oKQQxC](http://bit.ly/2oKQQxC)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding game animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like just about everything you see in computer games, animation mimics the real
    world or tries to create one in which players can feel that they are interacting
    with it. Drawing a game with two-dimensional sprites is fairly simple, as we saw
    in the previous chapter while making the snake character for our Snake game. Even
    with the 2D characters, we can create three-dimensional movements with proper
    shading and motion. Animating single objects is easier with the `pygame` module;
    we saw a bit of this in action in the previous chapter when we created a simple
    animation for the Snake game. In this section, we are going to animate a number
    of objects using the `pygame` module. We will make a simple program that will
    create a snowfall animation. To begin, we will use some shapes to fill in the
    snowflakes (in this program, we are using a circular geometrical shape, but you
    can choose any shape) and then create some animation logic that will make the
    snowflake move within a milieu.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write the code, make sure you brainstorm a little bit. Since we coded
    some advanced logic in the previous chapter too, this section might be easier
    for you, but make sure you learn about what we do here too as it is extremely
    useful for the next section, in which we will start making a clone of the Flappy
    Bird game.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the snowflakes animation requires a location (*x*, *y*) to render
    snow on it. This location can be chosen arbitrarily, and so you can use a random
    module to choose such locations. The following code shows how any shape can be
    drawn in a random location using the `pygame` module. Since a `for` loop is used
    for iteration, we will be using it to create a range for an iteration of at 50
    calls at the most (the value of `eachSnow` ranging from 0 to 49). Recall the previous
    chapter, where you learned how to use pygame''s `draw` module to draw any shape
    into the screen. Considering this, let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we made animation using the preceding code which will, in turn,
    draw circular snowflakes. After running this, you will observe something odd in
    the output. You may have guessed this already, but let me shed some light on this.
    The preceding code makes a circle—in some random position—and the previously made
    circle vanishes as soon as the new circle is created. Instead of that, we want
    our code to generate numbers of snow and must make sure that the previously made
    circle is on the right-hand position instead of vanishing. Did you discover that
    the preceding code was kind of buggy? Now that you know what causes that error,
    take your time and think about how to solve this error. One ubiquitous idea that
    might occur to you is solving this using a data structure. I prefer to use lists.
    Let''s make some modifications to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `snowArray` list, we have added the position of the randomly created
    snow at position *x* and *y*. For multiple `x_pos` and `y_pos` values of snow,
    a nested list will be formed. For instance, a list might look something like `[[20,40],[40,30],[30,33]]` for
    three randomly made circular pieces of snow.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of piece of snow made by using the preceding `for` loop, you have
    to render it using another loop. Getting the length of the `snow_list` variable
    might be helpful as this will give us an idea about how much snow should be drawn.
    For the number of positions indicated by `snow_list`, we can use the `pygame.draw`
    module to draw any shape, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you see how easy it is to make drawings with the `pygame` module? Even
    though it is not alienating stuff for you, this concept will come handy in a little
    while. Next, we will look at how to make the snow fall downward. Follow these
    steps to create a downward movement for the circular snow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you have to make the snow move downward with unit pixels. You only
    have to make changes to the `y_pos` coordinates of the `snowArray` elements, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, you have to make sure that, whenever snow falls out of sight, it
    is created continuously. In *Step 1*, we have created a downfall for the circular
    snow. At some point, it is going to strike with a lower horizontal boundary. If
    it hits this, you have to reset it to render it from the top. By adding the following
    code, the circular snow will be rendered at the top of the screen using a random
    library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code for this animation is as follows (code that''s written with comments
    is self-explanatory):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, the preceding code that we wrote needs to be redefined and refactored
    so that the code looks good. Let''s start by initializing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add your `for` loop, right below the initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we will end the logic by creating the main loop, which *loops* until
    the user clicks the Close button explicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, check if snow is within the boundary or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the screen with whatever has been drawn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code consists of many fragments of code: the initialization of
    game variables, followed by creating game models. In *Step 3*, we created some
    simple logic that governs the animation of the game. We built two models of code
    in *Step 3*, which make our game interactive for the user (handling user events)
    and make a game object (circular snowfall) that it renders with a `for` loop.
    Although we are going to create more intricate animations in upcoming chapters,
    this is a good animation program to start with. You can clearly see that, under
    the hood, the creation of animations requires the use of looping, conditionals,
    and game objects. We use Python programming paradigms such as if-else statements,
    looping, arithmetic, and vectored manipulation to create game-object animations.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from animating geometrical shapes, you can even animate sprites or images.
    To do this, you have to make your own sprites or download some from the internet.
    In the next section, we are going to animate sprites using the `pygame` module.
  prefs: []
  type: TYPE_NORMAL
- en: Animating sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating sprites is no different from animating geometrical shapes, but they
    are considered complex because you have to write extra bits of code to `blit`
    such images using animation logic. This animation logic, however, won't be the
    same for every image you load; it differs from game to game. Thus, you must analyze
    what type of animation is suitable for your sprites beforehand so that you can
    code it accordingly. In this section, we aren't going to create any custom images;
    instead, we will be downloading some (thanks to the internet!). We are going to
    embed animation logic into those sprites so that our program will facilitate adequate
    shading and movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to give you a flavor of how easy it is to animate static images or sprites,
    we are going to create a simple program that will load about 15 images of a character
    (moving left and right). We will `blit` (render) them whenever the user presses
    the LEFT or RIGHT key on their keyboard. Perform the following steps to learn
    how to create an animated sprite program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you should start by creating a base template for the `pygame` program.
    You must import some important modules, create a surface for the animation console,
    and declare the *idle* friendly `quit()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, you must load all the sprites and images listed in the *images* directory.
    This directory contains several sprites. You must download it and save it in the
    directory where your Python file is stored (the sprites/images file can be found
    on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to declare some essential variables, such as the initial position
    of the character and its velocity, that is, the distance traveled per unit keystroke
    by the game sprites. In the following code, I have declared the velocity as five
    units, which suggests that the game character will move a fixed 5 pixels from
    the current position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to declare a few more variables in order to track the movement of
    sprites based on what the user is pressing on the keyboard. If the LEFT arrow
    key is pressed, the `left` variable will be `True`, while if the RIGHT arrow key
    is pressed, the `right` variable will be `False`. The `walkCount` variable will
    track the number of times the key is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have completed the basic layout for any pygame program—importing appropriate
    modules, declaring variables to track movements, loading sprites, and so on. The
    two remaining parts of the program are the most important ones, so make sure you
    understand them. We will start by creating a main loop, as usual. This main loop
    will handle user events, that is, what to do when a user presses the LEFT or RIGHT
    key. Secondly, you have to create some animation logic, which will determine what
    image to `blit` at what point of time based on user events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by handling user events. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you must declare a main loop, which much be an infinite loop. We
    will provide **FPS** for the game using the `tick` method. As you may recall,
    this method should be called once per frame. It will compute how many milliseconds
    have passed since the previous call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, start by handling critical user events. In simple sprite animations,
    you can start by handling two basic movements: LEFT and RIGHT. In upcoming sections,
    we will make games by handling the JUMPING/TAPPING action. This code should be
    written inside a while loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the last line of the preceding code—the call to the `Animation_Logic()`
    function is complete. However, this method hasn''t been declared yet. This method
    is a central block for any game that''s made out of sprites or images. Code written
    inside the animation logic will perform two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Blit or render images from the list of images defined while loading the sprites.
    In our case, these are `walkRight`, `walkLeft`, `bg`, and `char`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redraw the game window based on the logic, which will check which image to select
    from the pool of images. Note that `walkLeft` contains nine different images.
    This logic will make a selection from these images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have handled user events, let's learn how to make animation logic
    for our previously loaded sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Animation logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sprites are static images that contain characters and have a transparent background.
    Extra alpha information for these sprites is essential because, in 2D games, we
    want the user to only see the characters and not their background. Imagine a game
    that has a character blit with a bland background. It would leave the players
    with a bad impression of the game. For instance, the following sprites are Mario
    characters. Let''s say you are making a Mario game and you crop a character from
    the following sprites and forget to remove its blue background. The character,
    along with its blue background, will be rendered in the game, making the game
    awful. Thus, we have to manually remove (if any) the character background using
    online tools or offline tools such as GIMP. An example of a sprite sheet is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e5970c4-966c-4bd4-92fa-1e9e2452d573.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s continue with our sprite animation. Up until now, we have declared
    a template for handling events using `pygame`; now, let''s write our animation
    logic. As we previously affirmed, *Animation logic is simple logic that will make
    a selection between the images and blit it accordingly.* Let''s make that logic
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you will see is the `global` variable. The `walkCount` variable
    was initially declared inside the main loop and counts the number of times the
    user has pressed any keys. However, if you remove the `global walkCount` statement,
    you won''t be able to change the value of `walkCount` inside the `Animation_Logic`
    function. If you only want to access or print the value of `walkCount` inside
    the function, you don''t need to define it as global. However, if you want to
    manipulate its value inside a function, you must declare it as a global variable.
    The `blit` command is going to take two arguments: one is the sprite that needs
    to be rendered while the other is the position at which the sprite must be rendered
    onto the screen. In the preceding code, the code that''s written after `#check_1`
    is to qualify the character whenever it reaches extreme positions. It is a check
    for which we have to render a *char* image, which is a still image of a character.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the sprites begins with our checking whether the left movement is
    active or not. If `True`, `blit` the images at the (*x*, *y*) position. The value
    of (*x*, *y*) is manipulated by the event handler. Whenever the user presses the
    LEFT arrow key, the *x* value will be decreased by five units from its previous
    value and the image will be rendered to it. Since this animation allows the character
    to move only in a horizontal direction on either the positive *X*-axis or negative
    *X*-axis, there is no change in the y-coordinates. Similarly, for the right movement,
    we are going to render images from the pool of `walkRight` at the position specified
    by (*x*, *y*). In the else part of the code, we `blit` a char image, which is
    an idle image of the character with no movements. Thus, `walkCount` is equal to
    zero. After we `blit` everything, we have to update it to reflect the changes.
    We do this by calling the `display.update` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the animation and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d090b846-6b24-4c12-9ce4-197a81fc49fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the console, if you press the LEFT arrow key, the character will begin moving
    to the left, and if you press the RIGHT arrow key the character will move to the
    right. Since there is no change in y coordinates and we are not handling any events
    in the main loop to facilitate vertical movements, the character is restricted
    to moving in a horizontal direction. I strongly urge you to experiment with these
    sprites and try handling vertical movements by changing y-coordinates. Although
    I have provided you with a list of resources containing a list of images, if you
    want to use any other sprites for your game, you can go over to the following
    site and download any of the sprites from there: [https://www.spriters-resource.com/](https://www.spriters-resource.com/).
    This website is a paradise for any pygame developer, so make sure you visit it
    and download any game sprites you want so that you can experiment with this (Mario
    would be better to experiment with).'
  prefs: []
  type: TYPE_NORMAL
- en: From the next section onward, we will start making a clone of the Flappy Bird
    game. We will learn about techniques such as a scrolling background and character
    animation, random object generation, collision, and scoring.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling background and character animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know enough about pygame sprites and animation, you are capable of
    making a game that contains intricate sprite animations that contain multiple
    objects. In this section, we are going to learn about scrolling backgrounds and
    character animation by making a Flappy Bird game. This game contains multiple
    objects, with Bird being the main character for the game and a pipe pair for the
    obstacles in the game. If you haven't played this game before, give it a go by
    visiting its official website: [https://flappybird.io/](https://flappybird.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the game, it isn't that hard to make, but by taking care of multiple
    aspects of game programming it can be an arduous task for beginners. Having said
    that, we aren't going to make any sprites ourselves—they are freely available
    on the internet. This makes our task even easier. Since the designs of the game
    characters are open source, we can directly focus on the coding part of the game.
    But if you want to design your game characters from scratch, start making them
    using any simple Paint application. For this Flappy Bird game, I am going to use
    sprites that are freely available.
  prefs: []
  type: TYPE_NORMAL
- en: I have added resources in the GitHub links. If you open the images folder and
    then open the background image file, you will see that it contains background
    images of a specific height and width. But in the Flappy Bird game, you can observe
    that background images are rendered continuously. Thus, using pygame, we can make
    a scrolling background so that we can `blit` the background image continuously.
    Thus, instead of using thousands of copies of the same images for the background,
    we can use one image and `blit` it continuously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by making a character animation, along with a scrolling background.
    The following steps show us how to use object-oriented programming to make a class
    for each game character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you must start declaring modules such as math, os (for loading images
    with a specified filename), random, collections, and pygame. You must also declare
    some variables representing the frames-per-second setting, animation speed, and
    the game console''s height and width:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's load all the images from the image folder into the Python project.
    I will also make two more methods that will perform the conversion between frames
    to milliseconds and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see how the `loading_Images` function works by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we defined the `loading_Image` function, which loads/extracts
    all the images from a certain directory and returns them as a dictionary containing
    name as key and image as value. Let''s analyze how the keys and values will be
    stored in such a dictionary via the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background.png`: The background image for the flappy bird game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img:bird-wingup.png`: This image of the flappy bird has one wing pointing
    upward and is rendered when the screen is tapped in the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img:bird-wingdown.png`: This part of the image is used when the flappy bird
    has free fall, that is, when a user is not tapping the screen. This image has
    the flappy bird''s wing pointing downward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img:bodyPipe.png`: This contains the discrete body parts that can be used
    to create a single pipe. For instance, in the Flappy Bird game, there should be
    two discrete slices of the pipe rendered from the top and bottom, leaving a gap
    between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img:endPipe.png`: This part of the image is the base of the pipe pair. There
    are two types of such images: the small pipe-end for the small pipe pair and the
    big pipe-end image for the larger pipe pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we have a nested `loading_Image` function that creates a filename
    for each sprite that's being loaded. It loads images from `/images/ folder`. After
    loading each image successively, they are called with the `convert()` method to
    speed up the blitting (rendering) process. The argument that's passed to the `loading_Image`
    function is the filename of the image. `image_name` is the filename that's given
    (along with its extension; `.png` is preferred) to load it via the `os.path.join`
    method, along with the `convert()` method to speed up the blitting (rendering)
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the images, we need to make two functions that perform conversions
    of frame rates (please go to [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml), *Upgrading
    the Snake Game with Turtle* to find out more about frame rates). These sets of
    functions primarily perform conversion from frames to milliseconds at the specified
    frame rates and vice versa. This conversion of frames to milliseconds is important
    because we have to use milliseconds for the movement of the `Bird` character,
    that is, the number of milliseconds left to climb, where a complete climb lasts
    `Bird.CLIMB_DURATION` milliseconds. Use this if you want the bird to make a (small)
    climb at the very beginning of the game. Let''s make such two sets of functions
    (an exhaustive description of the code is also available on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12))
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, declare a class for the bird character. Recall [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming* where we learned that each entity should be represented by a single
    class. In the Flappy Bird game, the entity or model representing the `PipePair`
    (obstacles) is different from another entity, let's say, Bird. Thus, we have to
    make a new class to represent another entity. This class will represent the bird
    that will be controlled by the player. Since the bird is the "hero" of our game,
    any movements that are defined for the Bird character are only allowed by the
    user who's playing the game. The player can make the bird climb (ascend quickly)
    by tapping the screen; otherwise, it will sink (descend slowly). The bird must
    pass through the space in-between the pipe-pair, and for every pipe that's passed,
    one point will be rewarded. Similarly, if the bird crashes into a pipe, the game
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start coding our main character. Do you remember how to do this?
    This is one of the most important characteristics of any good game programmer—they
    brainstorm too much and write small but optimized code. So, let''s brainstorm
    and predict how we want to build the bird character beforehand so that we can
    code flawlessly afterward. The following are some essentials attributes and constants
    that must be defined as Bird class members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes of the class:** `x` is the bird''s *X* coordinates, `y` is the
    bird''s *Y* coordinates, and `msec_to_climb` represents the number of milliseconds
    left to climb, where a complete climb lasts `Bird.CLIMB_DURATION` milliseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WIDTH`: The width, in pixels, of the bird''s image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEIGHT`: The height, in pixels, of the bird''s image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SINK_SPEED`: The speed at which, in pixels per millisecond, the bird descends
    in one second while not climbing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLIMB_SPEED`: The speed at which, in pixels per millisecond, the bird ascends
    in one second while climbing, on average. See the `Bird.update` doc-string for
    more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CLIMB_DURATION`: The number of milliseconds it takes the bird to execute a
    complete climb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have enough information about the Bird character in our game, we
    can start writing the code for it. The following line of code represents the Bird
    class, which has members defined as class attributes and constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk about the constructor, or initializer, that''s defined inside the
    Bird class. It contains many arguments that might overwhelm you, but they are
    rather easy to grasp. In the constructor, we normally define the attributes of
    the class, in this case, variables such as the x and y coordinates that represent
    the bird''s position, as well as other arguments. Let''s go over these now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`: The bird''s initial *X* coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: The bird''s initial *Y* coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msec_to_climb`: The number of milliseconds left to climb, where a complete
    climb lasts `Bird.CLIMB_DURATION` milliseconds. Use this if you want the bird
    to make a (small) climb at the very beginning of the game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: A tuple containing the images used by this bird. It must contain
    the following images, in the following order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bird wing when flying up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bird wing when falling down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, three important properties should be declared. These properties are `image`,
    `mask`, and `rect`. Imagine properties are what the bird is essentially doing
    in the game. It can fly up and down, which is defined inside the image property.
    However, the other two properties of the bird class are quite different. The `rect`
    property will get the bird''s position, height, and width as a `Pygame.Rect` (in
    the form of a rectangle). Remember that `pygame` can track every game character
    with the `rect` property, and something like an invisible rectangle will be drawn
    around the sprites. The mask property gets a bit-mask that can be used in collision
    detection with obstacles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Since we are already familiar with the concepts of the `rect` and `mask` properties,
    I won't bother repeating myself here, so let's learn about the image property
    in detail. The image property gets the surface that points to the current image
    of a bird. This will decide whether to return an image where the bird's visible
    wing is pointing upward or where it is pointing downward based on `pygame.time.get_ticks()`.
    This will animate the Flappy Bird, even though pygame doesn't support *animated
    GIFs.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The time has come to wrap up the Bird class, but before that, you have to declare
    one more method, which will update the bird''s position. Ensure that you read
    the description that I''ve added inside the triple quote as a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The mathematical `cosine(angle)` function is used to make a smooth climb for
    the bird. Cosine is an even function, which means it is an even climb and a fall
    movement is given to the bird: when the bird is in the middle of the screen, a
    high jump can be performed, but when the bird is near the top/bottom boundary,
    only a slight jump can be made (this is a basic principle for the Flappy Bird''s
    movement).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the game to check how the bird has been rendered. However, we haven''t created
    any logic to enable the player yo play the game (we will do this soon). For now,
    let''s run our game and observe what the interface looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/be35d72a-846f-4d44-b17f-72a7b29304f2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the light of the preceding code, you must be able to make a complete `Bird`
    class that has properties for masking, updating, and getting the position, that
    is, the height and width, using `rect`. The bird character in our Flappy Bird
    game is only associated with motion—moving either up or down, vertically. The
    next character in our game is Pipes (obstacles for the bird), which is quite complex
    to deal with. We have to `blit` pipe pairs randomly and continuously. Let's see
    how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding random object generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already covered the `Bird` character's animation in the previous sections.
    It consists of a list of properties and attributes that deal with the vertical
    motion of the bird. Since the `Bird` class is restricted to performing movements
    for the bird character only, we can't add any other character attributes to it.
    For instance, if you want to add attributes for obstacles (pipes) in the game,
    they can't be added to the `Bird` class. You have to create another class to define
    the next object. This concept is called encapsulation (we learned about this back
    in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented Programming*)
    in which code and data are wrapped together within a single unit so that no other
    entity can harm it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a new class to spawn obstacles for the game. You must start by
    defining a class, along with some constants. I have added comments along with
    the code so that you can understand the primary use of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we actually write this `PipePair` class, let me give you some pithy
    information about this class so that you can grasp each of the following concepts.
    We will use different attributes and constants, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PipePair` **class**:A pipe pair (a combination of two pipes) is inserted to
    form two pipes, and only a small gap is provided between them so that the Flappy
    Bird can pass through them. Whenever the bird touches or collides with any of
    pipe-pairs, the game will be over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes****:** `x` is the *X*-position for `pipePair`. This value is a
    float to make movement smoother. There is no *Y*-position for `pipePair` as it
    doesn''t change in the *y*-direction; it always remains 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: This is the surface provided by the `pygame` module and is used to
    `blit` the `pipePair`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mask`: There is a bitmask that excludes all the pixels in `self.image` with
    a transparency greater than 127\. This can be used for collision detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top_pieces`: A combination of top-pipes along with an end-piece, which is
    the base for the top pieces of the pipe (this is a one-pair consisting of the
    top-pieces of the pipe).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom_pieces`: A combination of down-pipes (tunnel pointing upward) with
    an end-piece, which is the base for the bottom pipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constants**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WIDTH`: The width, in pixels, of a pipe piece.  Because a pipe is only one-piece
    wide, this is also the width of a `PipePair` image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PIECE_HEIGHT`: The height, in pixels, of a pipe piece.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_INTERVAL`: The interval, in milliseconds, between adding new pipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we already know, the first thing that we need to do for any class is the
    initialization of a class or constructor. This method will initialize the new
    random pipe pair. The following screenshot shows how the pipe pair should be rendered.
    There are two parts of the pipe, that is, the top and the bottom, and a small
    space is inserted between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/66b04e30-29e3-4eaf-b559-771accc219a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make an initializer for the `PipePair` class that will `blit` the bottom
    and top parts of the pipe, as well as mask it. Let''s learn about the arguments
    that need to be initialized in this constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`end_image_pipe`: Image representing the base of the pipe (end-piece)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body_image_pipe`:Image representing the vertical piece of the pipe (one-slice
    of pipe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipe pair only has an x-attribute and the y-attribute is 0\. Therefore,
    the value of the `x` attribute is assigned as `WIN_WIDTH`, that is, `float(WIN_WIDTH
    - 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps represent the code that needs to be added to the constructor
    to create a random pipe pair in the game''s interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s initialize a new random pipe pair for `PipePair`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define two types of pipe pair—the bottom pipe and the top
    pipe. The code that adds the pipe pair blits the pipe image and only cares about
    the *y*-position for the pipe pair. No horizontal coordinates are required for
    pipe pairs (they should be rendered vertically):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although the comments that were provided alongside the code are helpful when
    it comes to understanding the code, we need to learn about the logic in a more
    pithy way. The `total_pipe_body_piece` variable stores the height for the number
    of pipe pieces that can be added in one frame. For example, it infers the number
    of bottom pipes and top pipes that can be inserted into the current instance.
    We typecast it to the integer since pipe pairs will be always integers. The `bottom_pipe_piece` class
    attribute represents the height of the bottom pipe. It may range anywhere from
    1 to the maximum width supported by `total_pipe_piece`. Similarly, the height
    of the top pipe piece depends on the total pipe piece. For example, if the total
    height of the canvas is 10 and the height of the bottom pipe is 1, then by leaving
    a gap between the two pipe pairs (let's say, 3), the remaining height should be
    that of the top pipe (that is, its height is 10 - (3+1) = 6) which means that,
    except from the gap between the pipe pair, no other gap must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Everything that is written in the preceding code is self-explanatory. Although
    the code is simple, I want you to focus on the last line of code, which we used
    to detect a collision. This process of detection is significant because, in the
    Flappy Bird game, we have to check if the bird is colliding with the pipe pair
    or not. This is usually done by adding a mask using the `pygame.mask` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to a add few properties to the `PipePair` class. We will add
    four properties: `visible`, `rect`, `height_topPipe_px`, and `height_bottomPipe_px`.
    The `rect` property works similarly to the `Bird` class'' `rect` call—it returns
    the rectangle that contains the `PipePair`. The `visible` property of the class
    checks if the pipe pair is visible in the screen or not. The two other properties
    return the top and bottom pipe''s height in pixels. The following is the code
    for the preceding four properties of the `PipePair` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to add two more methods to the `PipePair` class before wrapping
    it. The first method, `collides_with`, is going to check whether the bird collides
    with a pipe in the pipe pair or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method, `update`, will update the pipe pair''s positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how every method works, let''s see the code in action. You
    won''t understand any flaws in your game until you run it. Take the time to run
    your game and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3876e226-50d8-48e1-9258-9fc566b22a87.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, so the game is appealing enough to play. The tapping events are working
    perfectly, and the background image is rendered along with the bird images and
    the physics for climbing and sinking actions. However, one strange thing you might
    have observed (if not, take a look at the preceding screenshot), is that, after
    colliding with the pipe pair, our bird was able to move forward. This is a big
    flaw in our game, and we don't want it. Instead, we want to close the game when
    this happens. Thus, to overcome such an error, we have to use concepts of collision
    (a technique that handles the event when multiple game objects collide with each
    other).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have completed the two game character classes, that is, `Bird`
    and `PipePair`, let''s move toward making the physical part of the game: initializing
    the display and handling collisions.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of *handling collisions* is done by figuring out what actions must
    be performed when two independent objects touch each other. In the preceding section,
    we added a mask for each object to check whether two objects collide or not. The
    `pygame` module makes checking the process of collisions extremely easy; we can
    simply use `sprite.collide_mask` to check if two objects are touching or not.
    However, the argument that this method takes is the masking object. In the previous
    section, we added the `collides_with` method to check if the bird collides with
    one of the pipes in the pipe pairs or not. Now, let's use that method to check
    for collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with detecting collisions, we will make a physical layout/template for
    the game. I am not emphasizing the basic pygame layout in this section because
    it should be self-explanatory for you since we have been doing this for a long
    time now. The following steps depict the layout for making a model that detects
    game characters collisions (`Bird` with `pipePairs`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the main function, which will be externally called afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create some logic that will make the bird appear at the center of the
    screen. If you have played the Flappy Bird game, you will know that the bird is
    placed at the center of the canvas and that it can move either vertically upward
    or downward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add pipe pair images to the `pipes` variable since a pipe is
    formed by concatenating `pipe-body` with `pipe-end`. This concatenation is done
    inside the `PipePair` class, so that, after creating the instances, we can append
    the pipe pair to the pipes list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, handle the user''s actions. Since the Flappy Bird game is a tapped game,
    we will handle mouse events (refer to the *Mouse control* section we covered in
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s what you''ve been waiting for: how to build a collision interface
    with the help of Python''s `pygame` module. The highlighted part of the following
    code will be discussed in detail after we''ve completed the rest of these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, end the program with some superfluous steps, such as rendering the
    game with an update function, giving an extraneous message to the user, and so
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted parts in the preceding code are important, so ensure that you
    understand them. Here, the `any()` function returns a Boolean by checking whether
    the bird collides with the pipe pair or not. Based on that check, if it is `True`,
    we exit the game. We will also check whether the bird is touching the lowest horizontal
    or upper horizontal boundary or not and exit from the game if it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the game and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4296ca36-a86e-479b-9b3b-7178b05417fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The game is playable enough, so let's add one more feature to the game that
    tells the player how well they're scoring.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring and end screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a score to the Flappy Bird game is quite simple. The player''s score
    will be the number of pipes or obstacles a player has passed through. If the player
    passes through 20 pipes—their score will be 20\. Let''s add a score screen to
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the game looks more appealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70199436-5df8-4e03-acf8-bef436d2120a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll look at how we can test everything out and even try
    to apply some modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although there are fewer areas where Flappy Bird can be modified, you can always
    test the game by modifying some game character attributes in order to change the
    difficulty of the game. In the previous section, we ran our game and saw that
    there was a huge space between a pipe pair. This will make the game extremely
    easy for many users to play, and so we need to increase the difficulty by narrowing
    down the space between the two pipe pairs. For instance, inside the `Bird` class,
    we have declared four attributes. Change them to different values to observe the
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You can also vary the values of game attributes to give your game a unique look.
    Some of the different game attributes that are used in Flappy Bird are *frames
    per second* and *animation speed*. You can alter these values to implement the
    necessary changes. Although you can change the value of the animation speed, a
    value of 60 for FPS is adequate for the Flappy Bird game.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of debugging and searching for possible modifications manually, you
    can simply run your program in debug mode to test it faster. Assuming that you
    have coded the Flappy Bird game in Pycharm's IDE ( I recommend this), you can
    run your program in debug mode by pressing *Shift* + *F9* or simply clicking on
    the Run tab and running it in debug mode from there. After you run it, try to
    play the game and try to make it fit every possible situation that the user might
    encounter. Any errors will be located in the Terminal of the program, from which
    you can jump to a location in the program that has multiple errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concepts of sprite animations and collision
    more deeply. We looked at how to make a simple animation for geometrical shapes
    and create complex sprite animations, and learned which works best in certain
    scenarios. We combined pygame's event handling method with animation logic, which
    renders the images based on the current game state. Essentially, animation logic
    maintains a queue in which user events will be stored. Fetching one action at
    a time renders the image to a position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Game prototypes that are made by using pygame have three central blocks: loading
    ant sprites (the original sprites or those downloaded from the internet), handling
    user events, and animation logic, which governs the movement of game characters.
    Sometimes, instead of having independent sprite images, you might have sprite
    sheets—sheets containing images of characters. You can crop them by using online
    tools or even pygame''s `rect` method. After getting the proper images or sprites
    for the game, we handled user events and created animation logic to make the game
    sprites move. We also looked at pygame''s masking properties, which can be used
    to detect collisions between objects.'
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you now understand game controllers and animation,
    have learned about the collision principle (including pygame's masking property),
    have learned about sprite animations (creating a running animation of a character),
    and have learned about adding an interactive score screen to make the game more
    user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: The wide range of areas where you can apply the knowledge you have gained in
    this chapter is *pure* *gold* to most Python pygame developers. Handling sprites
    is important for almost all pygame-based games. Although simple yet powerful concepts,
    character animation, collision, and movements are three primary aspects of Python
    games that make them appealing and interactive. Now, experiment by creating a
    simple **role-playing game** (**RPG**) game such as Junction Jam (if you haven't
    heard of it, Google it) and try to embed the concepts of collision and sprite
    movement in it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about pygame's primitive graphics
    programming by creating game grids and shapes. We will learn about multi-dimensional
    list processing and valid space determination by coding a Tetris game.
  prefs: []
  type: TYPE_NORMAL
