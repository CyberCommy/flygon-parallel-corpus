- en: Node.js versus Python
  prefs: []
  type: TYPE_NORMAL
- en: Why would a developer choose Node.js over Python? Can they work together? What
    do our programs look like? These questions and more are at the heart of some of
    the differences between Python and Node.js, and it's important to understand when
    and where to use a particular language. For example, there are tasks for which
    a certain language is more suited than others, and it is the technologist's duty
    to advocate for the proper language. Let's investigate the use cases and different
    considerations when choosing Node.js versus Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Philosophical differences between Node.js and Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance implications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be prepared to work with the code provided in the `Chapter-12` directory of
    the repository at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-12](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-12).
    As we'll be working with command-line tools, also have your Terminal or command-line
    shell available. We'll need a modern browser and a local code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Philosophical differences between Node.js and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common to have a main language that you know, work with, and are comfortable
    with. However, it's important to realize that not all programming languages are
    created for the same purpose. That is why it's very important to use the right
    tool for the job at hand. Just as you wouldn't attempt to build a house with a
    pocketknife, you probably wouldn't use a table saw to whittle a stick into a point
    for a campfire for s'mores.
  prefs: []
  type: TYPE_NORMAL
- en: If you've been in the industry for a while, you have probably heard the term
    **stack**. In technology, a stack is the architectural combination of technologies
    used to create a program or multiple programs in an ecosystem. In the past, applications
    tended to be large-scale **monoliths**, built in a "one application to rule them
    all" mindset. In today's world, the use of monoliths is decreasing in favor of
    multiple, smaller applications and **microservices**. In this manner, different
    parts of a workflow can be distributed to completely independent processes, greatly
    increasing the stability of an overall system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use Office software as an example. You certainly wouldn't try to write
    your next bestselling novel in Microsoft Excel, and you probably wouldn't want
    to do your taxes in Microsoft Word. There is a *separation of concerns* between
    these programs. They function very well together and form a unified whole, but
    each has its own part to play in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the different pieces of technology in a web application have their
    own uses and concerns. One of the more traditional stacks used for web applications
    is called **LAMP** (**Linux, Apache, MySQL, and PHP**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db3645d2-d9b2-4f38-a070-9ccdccd29948.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – LAMP stack
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when discussing web applications in specifics, we take the
    web browser and the client stack as a given and unknown, not listed in the abbreviation
    LAMP. In this case, LAMP is only the server-side components.
  prefs: []
  type: TYPE_NORMAL
- en: As the web evolved, so did the underlying technologies supporting it and their
    stacks. Two of the more common stacks you may hear of now are **MEAN** (**MongoDB,
    Express, Angular, and Node.js**) and **MERN** (**MongoDB, Express, React, and
    Node.js**). It's no coincidence that the only difference in technology is Angular
    versus React. They fulfill essentially the same role in an otherwise stable system.
    We'll explore Express, the ubiquitous web server framework for Node.js, in [Chapter
    13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml), *Using Express*, and MongoDB
    in [Chapter 18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml), *Node.js and MongoDB*.
    For now, let's focus on the question of *why Node.js?*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing a language for a project, there are many factors to consider.
    Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Type of project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Budget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-to-market
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These may sound like very basic factors, but I've certainly seen instances where
    the chosen technology was not a good fit for the type of project.
  prefs: []
  type: TYPE_NORMAL
- en: For those immersed in the web side of software, the choice between using JavaScript
    on the backend versus another language seems like a no-brainer. JavaScript is
    foundational to the use of the modern web, so it sounds like, by corollary, it
    should be used on both the client side and server side.
  prefs: []
  type: TYPE_NORMAL
- en: However, Python's been around longer and has definitely had a cemented foothold
    in the development community, especially with the explosion of interest in data
    science and machine learning, where Python reigns supreme. Flask and Django are
    excellent web frameworks that are robust and powerful. So why would we want to
    use Node.js instead?
  prefs: []
  type: TYPE_NORMAL
- en: The first part of deciding what tech stack to use is understanding the *type
    of project*. For the scope of our discussion today, let's limit our type of project
    to reasonable use cases. We won't open the can of worms to the Internet of Things/connected
    devices, as these are mostly written in Java. Let's also rule out machine learning
    and data science as possible use cases, as it's been established in the field
    that Python is better suited for these use cases. However, there actually is an
    argument for desktop and mobile applications being developed in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s think about if our project is a web application. In most
    cases, Node.js would be a logical fit over Python for many of the reasons that
    we''ve already explored: its asynchronous nature, less context switching, performance,
    and so forth. I''m hard-pressed to think of an adequate use case for using a Pythonic
    backend for a web app that would be superior to Node.js. I''m sure some exist,
    but in general, even when dealing with larger, more complex systems, the preference
    today is not to have a monolithic backend application, but rather to have a combination
    of *microservices* interacting with each other with data handoff.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a possible **high-level architecture **(**HLA**) diagram.
    If you''re dealing with complex applications, understanding the HLA of a system
    is extremely useful. Even if you''re only actively working on one part of the
    application, understanding the needs and structure of other systems is invaluable.
    In this example, we have a possible architecture of an e-commerce site that also
    has a mobile app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/20a02158-e417-4e03-9ba7-4030c0f1aa2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – High-level architecture
  prefs: []
  type: TYPE_NORMAL
- en: We can see that there can be multiple microservices, including some that are
    *not* Node.js or JavaScript at all. Python would be better suited as a microservice
    to provide the overarching application with recommendations, as that requires
    data analysis, which Python and R are better at doing than Node.js. Additionally,
    you can see that in the application, there can be multiple different data sources,
    from third-parties to different database types.
  prefs: []
  type: TYPE_NORMAL
- en: So, what about our project? Are we building this large ecosystem or a specific
    piece of it? In this example, the web app, payment service, account service, and
    inventory service are Node.js, as it makes sense to use technology designed for
    asynchronous communication. The recommendation engine, however, can be a *completely
    separate stack* without any problems, since it's contained within an overall ecosystem
    of microservices. As long as the parts of the application are appropriately communicating
    with each other, each service can be nearly independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this important? Simply stated, it''s a good way to enable smaller, nimbler
    teams to work in parallel to create software that is delivered faster and with
    greater stability than a monolithic application. Let''s look at an example: you
    hit a major retailer''s website to make a purchase, but instead of seeing the
    home page, you see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9d914e1-caa8-4471-afec-3467eff199d1.png)Figure 12.3 – 500! Error,
    error, danger, danger!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bane of any web application developer''s life: a full-blown outage caused
    by a code problem. Instead, wouldn''t it be much nicer if the site functioned
    for the majority of it, but, perhaps when it came time to check out, it said "Sorry,
    our payment processing system is currently offline. We''ve saved your cart for
    later." Or let''s say the Pythonic piece of the recommendation engine crashed—we
    could instead serve in a static collection of items. To creatively construct an
    authentic user experience for a large ecosystem of microservices, it''s important
    to consider the end user''s standpoint *as well as* the business goals. In the
    case of our e-commerce store, we don''t want the whole application to crash from
    a small error. Rather, we can intelligently downgrade the experience if problems
    were to occur. This is one example of a principle often known as fault-tolerant
    computing and, when designing large applications, it''s powerful to separate a
    monolith into microservices in order to be more fault-tolerant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to show you a quick example of some of the power of JavaScript existing
    in the desktop arena before we discuss the consideration of the budget. Let''s
    run a piece of example code provided for you in the GitHub repository at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-12/electron](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-12/electron):'
  prefs: []
  type: TYPE_NORMAL
- en: Install the dependencies with `npm install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application with `npm start`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a *native application* start—with our Pokémon game that we created
    in [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml), *Events, Event-Driven
    Design, and APIs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2c52b4b3-7ea6-409b-ba79-1ac55c544328.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – It's a desktop app!
  prefs: []
  type: TYPE_NORMAL
- en: 'How did this happen? We leveraged a great tool: Electron. You can read more
    about Electron at [https://electronjs.org/](https://electronjs.org/), but the
    gist is that it''s a container tool to present HTML, CSS, and JavaScript as a
    desktop application. You may have already used Electron without realizing it:
    Spotify, Slack, and other popular desktop applications are built with Electron.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we compare this to our PokéAPI project from [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml), *Events,
    Event-Driven Design, and APIs*, ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-7/pokeapi/solution-code)),
    we'll see that there are a lot of similarities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Wait.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not just similarities…this is *identical* to the code we used for our browser!
    `main.js` has been renamed to `poke.js` to avoid a naming conflict, but that''s
    a small detail. Yes: you''ve just successfully created a desktop app with existing
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to budget: what if you need a web app *and* a desktop app? You should
    be getting the idea by now that with JavaScript, you can have the best of both
    worlds and have a modern web application *and* a desktop application with minimal
    changes. The nuances are a bit more than we''ve done here, but the power of Electron
    should be evident. Write once, use multiple times—isn''t that the mantra of DRY
    coding?'
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a flip side to this argument. Since Python has been mature
    longer than Node.js, there is a probability that Python developers will be more
    cost-effective in their hourly rate than Node.js developers. However, I would
    consider this a secondary concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, as a secondary concern, *time-to-market* is indeed a question that
    arises when choosing a technology. Unfortunately, the numbers here are inconclusive.
    Because Node.js is JavaScript, in theory, it can be developed quickly and iteratively.
    However, Python''s explicit and simple syntax makes writing it faster at times.
    It''s a very difficult problem to solve, so it''s best to consider another part
    of the timing aspect: technical debt. Tech debt is the bane of engineering teams,
    and it simply means that, at the expense of the optimal solution, a faster solution
    was implemented. Additionally, the attrition of technology can lead to tech debt.
    Do you remember Y2K? When it was discovered that many major applications in the
    world were dependent on a two-digit year, it was feared that the change from the
    year 1999 to 2000 would wreak havoc on computer systems. Thankfully, only minor
    glitches occurred, but the problem of tech debt arose: many of those systems were
    coded in languages that had since become obscure. Finding programmers to develop
    these fixes was difficult and costly. Likewise, if you choose a technology because
    it''s faster, you may find yourself paying twice or thrice the initial investment
    in terms of budget and time to refactor the application to meet ongoing needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's turn our attention to performance. There is a lot to consider here, so
    let's continue to the next section and discuss why performance is always a consideration
    when discussing Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Performance implications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Node.js was first gaining popularity, there were concerns about its single-threaded
    nature. Single thread means one CPU, and one CPU can be overwhelmed by large traffic
    influxes. However, for the most part, all of these thread concerns have been assuaged
    by advances in server technology, hosting, and DevOps tools. With that being said,
    the single-threaded nature also shouldn''t be a deterrent in and of itself: we''ll
    discuss in just a little bit why the *Node event loop* plays an important role
    in any discussion around Node.js''s performance.'
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, to really differentiate on performance, we should focus on *perceived*
    performance. Python is an easy-to-understand, robust, object-oriented programming
    language; there are no disputes about that. However, one of the things it does
    not, cannot, and will not do is run in the browser. That spot is taken by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is this important and how does it relate to performance? In a nutshell:
    *Python can''t react to changes in the browser.* It''s possible to perform an
    Ajax request every time the UI of a page changes, but that would be incredibly
    expensive computationally both for the browser and the server. Additionally, you''d
    have to make the browser wait for a response from the server at each change, causing
    a very laggy experience. So, therefore, the more we can do client-side in the
    browser, the better. Using JavaScript in a browser to handle logic before needing
    to communicate with a server is the goal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit in the discussion around using Node.js is a thought you probably have
    from the previous section: *Node.js doesn''t run in the browser either!* That''s
    true! However, there''s the fact that Node.js is based on the Chrome interpreter
    and, as such, implicit in its design is the idea of asynchronicity. The event
    loop of Node.js is designed for, well, events—and inherent in the concept of events
    is that they''re asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following diagram from [Chapter 7](72ec1a13-fd17-4319-8693-8afa18746a72.xhtml),
    *Events, Event-Driven Design, and APIs*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e38f207f-a227-44ba-8593-d7d5f6b0d508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – The event life cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, this diagram represents the three phases of a browser event:
    capturing, targeting, and bubbling. The DOM events specifically relate to actions,
    interactions, or triggers that are caused in the browser either by the user or
    the program itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the event loop of Node.js has a life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e96702ef-0b7d-41c1-9ed5-2b200396ed79.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 - The Node.js event loop
  prefs: []
  type: TYPE_NORMAL
- en: Let's decipher this. The single-thread event loop runs during the life cycle
    of a Node application and accepts inbound requests, either from a browser, another
    API, or other sources, and executes its work. If it's a simple request or specified
    as synchronous, it can be returned immediately. For more intensive operations,
    Node will register a *callback*. Remember that this is a term for a function that
    is passed to another function in order to be executed when the function it's passed
    to finishes its work. We've used these extensively as *event handlers* in JavaScript
    so far. The Node.js event loop provides an efficient means to access and serve
    data to our application.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not too familiar with the concepts of threads and processes, that's
    OK because we won't really dive in deep here. However, it's important to point
    out some facts about Node's use of processes and threads. It's stated by some
    computer scientists that the single-threaded nature of Node is inherently unscalable
    and that it can't stand up to the volume of traffic that a mature web app would
    need. However, as I mentioned previously, our applications don't live in a silo.
    No application that needs to be designed for scale is just going to hang out on
    a server alone. With the advent of cloud technologies such as Amazon AWS, it's
    easy to incorporate multiple virtual machines, load balancers, and other virtual
    tools to appropriately distribute the load for an application. Yes, Python may
    be better suited as a single-box application to receive thousands upon thousands
    of incoming requests, but this benchmark for performance is outdated and belies
    the state of technology today.
  prefs: []
  type: TYPE_NORMAL
- en: Caveat emptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're in love with Node, let's return to the idea of the right tool
    for the task at hand. Node isn't a panacea for all the world's computing problems.
    In fact, it's specifically *not* designed to be a Swiss Army knife. It has its
    use and its place, but it doesn't try to be everything to everyone. The "do everything"
    nature of Java might be considered one of its weaknesses, in that while you can
    write Java code once and compile it for practically any architecture, there are
    limitations, considerations, and trade-offs that have been made to accommodate
    this. Node.js and JavaScript, in essence, try to stay in their own lanes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what''s the catch? We know that JavaScript is fast, powerful, effective,
    and understandable. Like any technology, there are always nuances, and one nuance
    of JavaScript and Node is this mantra that is in some Linux systems when you first
    log in as a superuser: "With great power comes great responsibility." While the
    provenance of the quote is nebulous, it''s important to think of when executing
    anything that has influence over others. (Don''t use hypnotism for evil!)'
  prefs: []
  type: TYPE_NORMAL
- en: 'All joking aside, there are very real problems that can occur with an asynchronous
    environment. We know that we can easily crash a user''s browser with our own client-side
    JavaScript code by throwing it into an infinite loop. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. If you were to run this in a browser, the *best* that could happen
    is that the browser would recognize an infinite loop and prompt a warning for
    you to exit the script because the page is unresponsive. A second outcome would
    be that the browser crashes, and in the worst-case scenario, the user's entire
    machine may crash with an out-of-memory exception. With great power...
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can severely impact the user''s experience in Node by improperly
    handling state and events. What if, for example, your frontend code was dependent
    upon a Node process and that process never returned? Luckily, there are Ajax safeguards
    built in to prevent this in most cases, in that HTTP requests will, by default,
    close after a certain period of time and error out if necessary. With that being
    said, there are a whole host of ways to force a connection to stay open, causing
    absolute chaos to a user''s browser. There are perfectly valid reasons for doing
    this, such as long polling for live data, so that''s why they exist. On the flip
    side, it''s also possible to accidentally cause major issues for a user. Fail
    safes such as timing out requests exist for  you protection, but any good engineer
    will tell you: don''t rely on fail safes—avoid errors in the design process.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is great. Node is great. Both are great. So why are we having this conversation?
    While both technologies are strong and mature, each has a role to play in the
    technology ecosystem. Not all languages are created equal, and not all languages
    handle problems in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is asynchronous and works well with event-based thoughts, such as JavaScript
    in a browser reacting to page events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has established itself as a leader in data analysis and machine learning,
    as it's able to process large datasets quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For web work, the technologies may be interchangeable, but a complex architecture
    may involve both (and more!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we'll begin working with Express, a foundational web server
    for Node.js. We'll create our own websites and work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a little more reading on some of these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: stateofjs: [https://2019.stateofjs.com/](https://2019.stateofjs.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NodeJs versus Python: [https://www.similartech.com/compare/nodejs-vs-python](https://www.similartech.com/compare/nodejs-vs-python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern — microservice architecture: [https://microservices.io/patterns/microservices.html](https://microservices.io/patterns/microservices.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon API Gateway: [https://aws.amazon.com/api-gateway/](https://aws.amazon.com/api-gateway/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electron: [https://electronjs.org/](https://electronjs.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y2K bug: [https://www.britannica.com/technology/Y2K-bug](https://www.britannica.com/technology/Y2K-bug)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js multithreading: [https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
