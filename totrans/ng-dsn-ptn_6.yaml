- en: Performance Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we investigated stability patterns. Stability patterns
    are here for your application so that it can survive bugs. It is ludicrous to
    expect applications to be shipped without any bugs, and trying to achieve this
    will wear your team out. Instead, we learned how to live with it and made sure
    that our application is resilient enough to live through bugs. In this chapter,
    we will focus on performance patterns and anti-patterns. These patterns define
    architectures and practices that significantly affect the performance of your
    application in a positive or negative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In detail, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: AJAX overkill
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbound result sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters and Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype and the reusable pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX overkill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application is a bit more than a throwaway prototype or a glorified
    one-pager, you are likely dealing with remote APIs. These remotes APIs, in turn,
    are communicating with a backend layer (for example, PHP, Ruby, or Golang) and
    databases (for example, MySQL, MS SQL, or Oracle).
  prefs: []
  type: TYPE_NORMAL
- en: While this book focuses on *Angular* application, we cannot ignore the fact
    that they do not usually exist by themselves. Indeed, any meaningful application
    will need to pull and push data from/to somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's imagine that your application is some sort of frontend
    for an online e-commerce site such as Amazon. This made-up application would certainly
    have a profile page where your users can see their past and ongoing commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s further specify our application by imagining that your APIs, endpoints
    are specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This returns the orders of logged-in users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a JSON return call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of clarity and brevity, we will assume that our users are magically
    authenticated and that their authorization to access given API endpoints is magical
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each command, you have access to a `GET` /`command_details` API where,
    for a given ID, you can retrieve the details of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The Angular side of things could be a simple expansion panel that''s implemented
    using the expansion panel of the Google Material Design components suite as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f2d0dda-baa9-4314-8de2-0c40b3e25fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: We could also add a `GET` /`items_details` that returns the details of an item,
    but let's stop here for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's assume that every API call takes 100 ms to complete and another 10
    ms for transforming the JSON into TypeScript objects. An experienced developer
    would certainly first fetch all the commands of the given user and pre-fetch the
    details of each command so that the user will not have to wait when a given panel
    is expanded. If our APIs can handle 100 requests per second, which is respectable,
    then we could only serve nine clients per second, assuming that they each have
    ten commands. Nine clients per second don't sound impressive...
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, 10 clients hitting the *order resume*page at once will cost us 1/10 of
    our capacity and provoke an additional 100 calls (10 clients × 10 commands). Consequently,
    the 10^(th) client will not be served during the first second. It may not sound
    that alarming, however, we are only talking about 10 users.
  prefs: []
  type: TYPE_NORMAL
- en: This effect is known as the AJAX overkill performance anti-pattern. As a frontend
    developer, I have access to APIs that fulfill my every need, and I use them to
    make my clients happy. However, pre loading every detail of every command, and
    potentially every detail of every item, is a terrible idea. You put unnecessary
    stress on your backend architecture on the off chance that your customer wants
    to access the details of the last commands immediately.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of your backend infrastructure, it might be worth it to only request
    the details of the commands when the user actually wants to see them.
  prefs: []
  type: TYPE_NORMAL
- en: This goes hand in hand with unbound APIs. Once again, the backend architecture
    is not within the scope of this book, however, if we were to talk about the performance
    of Angular applications, we would have to mention it. If you have control over
    the APIs you consume, then make sure that they expose some sort of pagination
    and that you use it properly.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing our investigation into unbounded APIs and AJAX overkill, in the previous
    recipe, we established that both should be avoided, but the solution to this was
    to make APIs change in case the APIs were not paginated. This assumes that you
    have access to these APIs or to someone who has. While this is a reasonable assumption
    to make, it will not hold true in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do, besides not making requests (obviously), to preserve those poorly
    designed and out-of-control APIs? Well, an elegant way to resolve this problem
    would be to use the proxy pattern. The proxy pattern is used to control access
    to an object. You surely know that the web proxy can control access to web pages
    given a user's credentials. In this recipe, we will not talk about the web proxy,
    but the objected-oriented proxy. In the object-oriented proxy, we do not control
    so much the access to the object regarding security, but regarding features.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, an image manipulation software is to list and display high-resolution
    photo objects that are in a folder, but users will not always visualize all the
    images in the given folder. Consequently, some images will have been loaded for
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does that relate to our API problem, though? Using the proxy pattern, we
    can control at which time we actually want to perform our API request, while keeping
    our collection of commands neat and tidy. First, let''s have a look at the proxy
    UML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2f6547fa-c386-4fdf-b702-83c66c3bf60a.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we have the `Subject` interface that defines the `doOperation()` method.
    This interface is implemented by the `Proxy` and `RealSubject` classes. The `Proxy`
    class contains a reference to a `realSubject` class, which will be populated at
    the right time. What could it look like for our purposes?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have a simple interface named `OnlineCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this interface, the only method is defined: `fetchItems()`. This method
    returns the items contained in the command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, our component has an array of commands that represent the commands of
    our customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this short component, we only have the commands of our customer in addition
    to what makes an Angular component a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the HTML part, we simply iterate over the collection of commands and, on
    click, call the `fetchItems` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the `RealCommand` class that implements the `OnlineCommand` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of the puzzle, albeit the most important one, is the proxyfied
    version of the online command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As discussed previously, the proxyfied version of the online command contains
    a reference to a real command that, for all intents and purposes, is our actual
    command. The point here is that the costly operation is the feature we only want
    to access when we really need to. On the HTML side, everything is elegantly hidden
    behind the encapsulation. On the TypeScript side, we only perform the call when
    the user requests the details and not before.
  prefs: []
  type: TYPE_NORMAL
- en: Loop count
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications of any kind are often filled with loops. It could be a loop
    on products for *Amazon.com*, a loop on your transactions for your bank website,
    a loop on your phone calls for your phone carrier website, and so on. Worst of
    all, you can have many loops on a page. When these loops iterate over static collections,
    it sure takes time to process when the page is being generated, unless there is
    nothing you can do about it. You can still apply the patterns we saw earlier in
    this chapter to reduce your collection depth and to save on heavy calls made on
    a per-item basis. Where real performance problem arise, however, is when these
    loops are bound to a collection that evolves asynchronously. Indeed, Angular,
    and all frameworks allowing these kinds of bindings for that matter, repaint the
    collection every time it changes. Indeed, it can now show which items inside the
    collection have been modified and how to select them within the DOM. Consequently,
    if you have 1,000 elements in a collection, if one of the elements is modified,
    then the whole collection has to be repainted. In practice, this is quite transparent
    to both the user and the developer. Nevertheless, selecting and updating 1,000
    DOM elements regarding the value of the JavaScript collection is computationally
    expansive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s simulate a collection of books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Book` class is straightforward. It only contains two properties: `id`
    and `title`. In the default app component, we add a list of books and a few methods.
    In the constructor, we populate the books. We also have a refresh method that
    will randomly select a book and update its title. Finally, the `makeid` method
    generates a random string ID that we can use to populate the book title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of our experiment is the HTML template below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our book class, the app component, and the `html` template, when put together,
    create the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b3862bcb-3535-49a5-a703-69654d994d70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have our 10 books and our Refresh button, which is linked to the `refresh`
    function. When pressed, one book will be randomly selected and updated. Now, by
    default, the entire list would have to be recomputed. Of course, the *refresh*
    mechanism is manual here but, in a more realistic scenario, the refresh will be
    asynchronous from a remote API update, for example. To help Angular figure out
    which element has been changed and needs to be refreshed, we can use the `trackBy`
    option of `ngFor` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function helps Angular know how to track our elements in the book collection.
    Now, when the Refresh button is pressed, only the modified element will be recomputed
    and repainted. In other words, only one DOM element will be manipulated. Once
    again, for 10 elements, the difference will not be noticeable. For a few dozen,
    however, one may start to feel the page become a bit sluggish, depending on one''s
    hardware. We can assert that the `trackByFn` function operates as intend by using
    the Chrome development tools. While inspecting the DOM, if you click the Refresh
    button, then only one of the `<li>` markups should light up. DOM elements are
    lighting up when modified. In the following screenshot, you can see that only
    the element at index 6 is being recomputed rather than all the elements of the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/649968bd-d2da-4677-915e-743005b4079d.png)'
  prefs: []
  type: TYPE_IMG
- en: Change detection and immutable states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem we ealluded to in our previous recipe is inherent to any framework
    that maps some sort of view and model. It isn't an Angular particularity. That
    being said, this problem, while exacerbated within loops, also exists in other
    places. To be precise, it exists everywhere we bind everything between our models
    and out the view. In other words, every time we have `{{ myValue }}` somewhere
    in our HTML model, it is a performance hit for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is the solution? Stop using binding altogether? Well, that would not
    be very practical, as we would give up on what makes JavaScript attractive in
    the first place. No, the real solution is to make our objects immutable. However,
    to understand why, we need to take a look at how change detection is achieved
    in Angular. Change detection is, as its name suggests, the process that Angular
    performs to detect if anything has changed. If so, the objects are reprocessed
    and repainted to the DOM. The way Angular does this by default is by attaching
    a *watcher* to our models. Watchers watch the model and, for each value bound
    to the view, keeps a few things. It keeps the reference of the bound object, the
    old value of each property of the object, and the new value of each property of
    the object. The old and new values are used when the object is changing state.
    In the book example from the previous section, the watcher for our model would
    have, for each book, its reference, old and new ID, and old and new title. At
    each detection cycle, Angular will check if the old and new properties of the
    object match, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, taken individually, these actions do not weigh much. However, when
    having hundreds of objects with dozens of mapped properties within your page,
    well, you will feel the performance hit. As I said before, the answer to this
    is immutability. Immutability of objects means that our objects cannot change
    their properties. If we want to change the values displayed in our view, then
    we must change the object altogether. If you follow the principle of immutability,
    then the control flow from before would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This saves us a lot of ifs and buts everywhere in our application, but it also
    means that the modification to bound variables in our models such as `book.title
    = "qwerty"` will not be reflected in the view. What we will have to do to make
    this modification visible is feed the view with a new book object. Let''s experiment
    a bit with this new concept. Here''s our HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The book class stays as presented in the previous section. Now, on serving
    this application, you''ll be greeted with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42b05852-662d-4166-a3d8-f64162fe9034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And pressing the CHANGE button will change the displayed title, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae34d832-bc9b-4fd6-b953-4e84b67fa122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we tell Angular that we would prefer to only check if the references have
    changed rather than checking for the values of every property by using the `ChangeDetection.OnPush`
    method, then the button will not have any effect on the view anymore. Indeed,
    the value of the model will have been changed, but the change will not have been
    caught by the change detection algorithm as the reference of the book is still
    the same, as we explained earlier. Consequently, if you do want to propagate your
    changes to the view, you have to change the reference. Here''s what our component
    looks like with all this in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We added `changeDetection: ChangeDetectionStrategy.OnPush` to our component
    and changed the `changeMe` method so that it creates a new book rather than updating
    the old one. Of course, creating a new object is more expensive than updating
    an existing object. However, this technique brings better performance to Angular
    applications because there are infinitely more cycles where nothing changes, but
    the properties of each object are still compared to their old values, than cycles
    where something is actually changed.'
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, we significantly improve the performance of our applications
    to the cost of having to think when we want an update to an object to be propagated
    to the view. Note that this also applies to filter and pipe. If your application
    only has a bound value from the model to the view, you might think that it does
    not matter and you could go mutable all the way. You would be right if your application
    indeed only had one bonded value, and this value was never piped or filtered using
    the `{{ myValue | myPipe }}` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, each pipe is treated asynchronously by our application. In fact, if
    you have 100 calls to `myPipe`, you are effectively creating the equivalent of
    100 watchers that watch the value of `myValue` and will apply your pipe to it.
    It makes sense because your pipe cannot know what's coming its way and cannot
    anticipate that the results of its computation will be identical for the 100 calls.
    Consequently, it watches and executes as many times as needed. If you find yourself
    with a template filled with a pipe invocation that returns all the same values,
    you are better off creating a dummy component with that value as input or storing
    the transformed value in your model altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype and the reusable pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented developers look at ways to reduce the cost of creating objects
    – especially when those objects are expensive to create because they require,
    for example, a database pull or complex mathematical operations. Another reason
    to invest in reducing the creation cost of a particular object is when you create
    a lot of them. Nowadays, backend developers tend to disregard this aspect of optimization
    as on-demand CPU/memory have become cheap and easy to adjust. It'll literally
    cost you a few bucks more a month to have an additional core or 256 MB of RAM
    on your backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'This used to be a big deal for desktop application developers too. On a client
    desktop, there is no way to add CPU/RAM on demand, but fairly cadenced quad cores
    and a ridiculous amount of RAM for a consumer PC made the issue less problematic.
    Nowadays, only games and intensive analytics solutions developers seem to care.
    So, why should you care about the creation time of your object after all? Well,
    you are building something that is likely to be accessed from old devices (I still
    use an iPad 1 for casual browsing in the kitchen or on the couch). While desktop
    application developers can publish minimum and recommended configurations – and
    enforce them by refusing to install them themselves – we, as web developers, don''t
    have this luxury. Now, if your website doesn''t behave properly, users won''t
    question their machines, but your skills... Ultimately, they won''t use your products,
    even when on a capable machine. Let''s see how to use the `Prototype` design pattern.
    First, we''ll need a `Prototype` interface like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Prototype` interface only defines the`clone` method that returns a `Prototype`-compliant
    object. You''ve guessed it, the optimized way of creating objects is to clone
    them when needed! So, let''s say you have an object called `Movie` that, for some
    reasons, takes time to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the way we override functions in TypeScript is different from
    most languages. Here, the two signatures of the constructor are on top of each
    other and share the same implementation. And that''s it for the `Prototype` pattern.
    One another pattern that often goes with the `Prototype` pattern is the object
    pool pattern. While working with expensive-to-create objects, cloning them sure
    makes a difference. A bigger difference would be to not do anything at all: no
    creation, no cloning. To achieve this, we can use the pool pattern. In this pattern,
    we have a pool of objects ready to be shared by any clients or components in the
    case of an Angular 2 application. The pool implementation is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'First and foremost, the pool is also a singleton. Indeed, it wouldn''t make
    much sense to have this costly object reusable design if anyone can create pools
    at will. Consequently, we have the static `instance:MoviePool` and the private
    constructor to ensure that only one pool can be created. Then, we have the following
    attribute: `private static movies:[{movie:Movie, used:boolean}] = [];`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `movies` attribute stores a collection of movies and a boolean that determines
    if anyone is currently using any given movie. As the movie objects are hypothetically
    taxing to create or maintain in memory, it makes sense to have a hard limit on
    how many such objects we can have in our pool. This limit is managed by the private
    static `nbMaxMovie = 10;` attribute. To obtain movies, components would have to
    call the `getMovie():Movie` method. This method does a hard create on the first
    movie and then leverages the `Prototype` pattern to create any subsequent movie.
    Every time a movie is checked out of the pool, the `getMovie` method changes the
    `used` boolean to true. Note that, in the case where the pool is full and we don't
    have any free movies to give away, an error is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, components need a way to check their movies back to the pool so that
    others can use them. This is achieved by the `releaseMovie` method. This method
    receives a hypothetically checked-out movie, and iterates over the movies of the
    pool to set them, according to the boolean, to false. Hence, the movie becomes
    usable for other components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to avoid major performance pitfalls in our *Angular*
    application by limiting our AJAX call, and with the proxy design pattern. We also
    learned how to control the undesirable effects of our loops performance-wise.
    We then took a dive into the change detection process of Angular to make it work
    nicely with immutable objects for the times where our object count gets too high.
    Finally, we also learned about the prototype and reusable pool pattern, which
    can help in reducing the footprint of our application regarding required resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about operations patterns for our Angular
    application. Operations patterns are patterns that help in monitoring and diagnosing
    live applications.
  prefs: []
  type: TYPE_NORMAL
