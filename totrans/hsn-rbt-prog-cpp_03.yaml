- en: Implementing Blink with wiringPi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up the Raspberry Pi, it's now time to connect different electronics
    components to it and program it using the C++ programming language. To use C++,
    we will first have to download and install a library called **wiringPi**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the `wiringPi` library inside the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an LED blink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart Light—working with a digital sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulse Width Modulation using softPwm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hardware requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 LED (any color)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 **LDR** (**Light Dependent Resistor**) sensor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 3B+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-6 female to female connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the wiringPi library in the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'wiringPi is a pin-based GPIO access library that is written in C. Using this
    library, you can control the Raspberry Pi using C/C++ programming. The `wiringPi`
    library is easy to set up. Once installed, the Raspberry Pi GPIO pins will have
    wiringPi pin numbering. Let''s take a look at how to download and install wiringPi:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the Terminal window by clicking on its icon from the taskbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccf56d38-8928-47cc-be0c-ead4119c57fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before installing the `wiringPi` library, we first need to verify that our
    Raspberry Pi is up to date by checking for updates. If your Raspberry Pi is not
    updated, you may face errors while installing the `wiringPi` library. To update
    your Raspberry Pi, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/177fcaa3-a9d0-4bda-8218-6d0564a55064.png)'
  prefs: []
  type: TYPE_IMG
- en: Depending on your internet speed, it will take around 10-15 minutes for the
    updates to download and install. Make sure that you place your Raspberry Pi near
    your Wi-Fi router.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the update, type in the following command to upgrade the Raspberry Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While upgrading, you may get a message asking you to download a particular
    component. Type `Y` and then press *Enter*. It will take around 30-40 minutes
    for the upgrade to complete. Once the upgrade is done, you will see the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e293e669-4a8c-47e0-bccf-b65446f782d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After updating your Raspberry Pi, you will need to download and `install git-core`
    inside your Raspberry Pi. To install Git, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e96c7786-8561-4382-aaf7-8739fa6bf47b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, to download the `wiringPi` library from `git`, type in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e10ba477-59d4-4a5b-9a9f-d2e4dca0d243.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you click on the File Manager option and click on the `pi` folder,
    you should see the `wiringPi` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc5142f9-d5d1-49dd-b68e-420c27a6db79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, change the directory to `wiringPi`, so that the wiringPi files are downloaded
    and installed inside this particular folder. The command for changing the directory
    is `cd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9df6e314-f099-4b15-86f9-98a351c609a6.png)'
  prefs: []
  type: TYPE_IMG
- en: You should now see the directory pointing toward the `wiringPi` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to fetch the Git files from their `origin` directory, type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/fc06f480-b074-47f2-9e8b-d2a95b47d84d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, for building the files, type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e722c4f6-128b-43e4-868e-cf22a2718159.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once everything is done, you will see an `All done` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c66fbdf-02e9-4d2f-87bb-8c148679e580.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have installed the wiringPi library, we can move on and understand
    wiringPi pin configurations on the RPi.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Raspberry Pi GPIO pins via wiringPi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have installed wiringPi, we can now look at the wiringPi pin numbering,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf066e9-8e3b-4f0d-ab08-90c43e25de71.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Physical` column represents the Raspberry Pi numbering from `1-40`. On
    both sides of the `Physical` column, you will see the wiringPi (`wPi`) columns.
    The arrows pointing from the `Physical` column to `wPi` represent the wiringPi
    pin numbering for a particular physical pin of a Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical pin number 3 has a wiringPi pin number of 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin number 5 has a wiringPi pin number of 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin number 8 has a wiringPi pin number of 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin number 11 has a wiringPi pin number of 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin number 40 has a wiringPi pin number of 29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By consulting this table, you can figure out which of the remaining physical
    pins correspond to which wiringPi pins.
  prefs: []
  type: TYPE_NORMAL
- en: wiringPi pin numbers from **17-20** do not exist. After **wPi pin 16**, we skip
    straight to **wPi pin 21**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the relationship between the wiringPi pins and the physical
    pins, you can refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97c2efb3-a563-478b-9e1c-441935552691.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The wiringPi pin numbering is what you will need to remember while programming.
    We can use a total of **28** wiringPi pins for programming. As well as these,
    we have the following pins, which can be used for providing power and can be used
    as ground pins:'
  prefs: []
  type: TYPE_NORMAL
- en: Physical pin numbers **6**, **9**, **14**, **20**, **25**, **30**, **34**, and
    **39** are ground pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin numbers **2** and **4** provide a +5V supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin numbers **1** and **17** provide a +3.3V supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on to writing our first C++ program for Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Making an LED blink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very first project that we are going to create is making an LED blink.
    For this project, we require the following hardware components:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two female-to-female wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connecting the LED to the Raspberry Pi is straightforward. Before doing this,
    however, let''s take a closer look at the pins of the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8e06d09-ca03-4a3b-812f-6d932b5ef25a.png)'
  prefs: []
  type: TYPE_IMG
- en: The LED contains one positive pin and one negative pin. The long pin is the
    positive pin, which you can connect to any data pin of the Raspberry Pi. The short
    pin is the negative pin, which can be connected to the ground pin of the Raspberry
    Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect it up. First, connect the negative pin of the LED to the ground
    pin (physical pin number **6**) of the Raspberry Pi. Next, connect the positive
    pin of the LED to wiringPi pin number **15**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/0f6a2e67-aebb-4272-8974-1d153da87637.png) **'
  prefs: []
  type: TYPE_NORMAL
- en: Now the we've connected the LED to the Raspberry Pi, let's write a program to
    make the LED blink.
  prefs: []
  type: TYPE_NORMAL
- en: The blinking program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write our first C++ program, we are going to use Geany Programmer''s Editor.
    To open Geany, click on the **Raspberry icon**, go to Programming, and then select **Geany
    Programmer''s Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a90522b4-7b0a-4787-864c-b73596641d0a.png)'
  prefs: []
  type: TYPE_IMG
- en: After opening Geany, you will see an unsaved file called `Untitled`. The first
    thing that we need to do is save the file. Click on File | Save as and give this
    file the name `Blink.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this file, write the following code to make the LED blink. You can download
    the `Blink.cpp` program from the `Chapter02` folder of GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have done Arduino programming before, you are likely to have understood
    around 90% of this code. This is because wiringPi allows us to write C++ programs
    in Arduino format:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we first import the `iostream` and the `wiringPi` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we have the main function, called `int main`***.*** Since this function
    does not have any arguments, we write a `void` statement inside the round brackets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, the `wiringPisetup()` function initializes `wiringPi`. It assumes
    that this program will use the wiringPi numbering scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the `pinMode(15, OUTPUT)` command, we are setting the wiringPi pin
    number `15` as the `OUTPUT` pin. This is the pin we have connected to the positive
    pin of the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we have an infinite `for` loop. The code written inside it will
    run infinitely, unless we stop it manually from the coding editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `digitalWrite(15,HIGH)` command, we write a `HIGH` signal on the LED,
    which means the LED will turn on. Instead of `HIGH`, we could also put the number
    `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, with the `delay(1000)` command, we ensure that the LED is only **on**
    for one second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, with the `digitalWrite(15,LOW)` command, we write a `LOW` signal on the
    LED. This means that the LED will turn **off** for one second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this code is inside a for loop, the LED will keep turning **on** and **off**
    until we instruct it otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading the code to the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are using wiringPi numbering conventions, we will add the `-lwiringPi` command inside
    the Build command so that our C++ program with the `wiringPi` library is compiled
    and built successfully. To open the Build command, click on Build | Set Build
    Commands. Inside the command boxes next to the Compile and Build buttons, add `-lwiringPi` at
    the end and then click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e30cbd86-64fc-45f5-b473-f0a539dea459.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, to compile the code, click on the **compilation button** (the brown icon).
    Finally, to upload the code to the Raspberry Pi, press the **build button** (the
    airplane icon):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95a1fd04-a578-4b78-933d-6ad76438007c.png)'
  prefs: []
  type: TYPE_IMG
- en: The compilation icon will check for errors in the code. If there aren't any,
    click the build icon to test the blinking output. After building the code, the
    build icon will turn into a red circle. Click on the red circle to stop the program.
  prefs: []
  type: TYPE_NORMAL
- en: Smart light – working with digital sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After writing our first C/C++ program for Raspberry Pi, we can now write a
    program that will take input from an LDR sensor and turn the LED on or off. For
    this project, you will need the following hardware components:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 LDR sensor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 female-to-female connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's explore how the LDR sensor works.
  prefs: []
  type: TYPE_NORMAL
- en: The LDR sensor and the way it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An LDR sensor is an analog input sensor that consists of a variable resistor
    whose resistance varies depending on the amount of light falling on its surface.
    When there is no light in the room, the resistance of the LDR sensor is HIGH (up
    to 1 M ohm) and in the presence of light, the resistance of the LDR sensor is
    LOW. The LDR sensor consists of two pins. These pins do not have positive and
    negative polarity. We can use any pin as a data or ground pin and because of this,
    the LDR sensor is sometimes referred to as a special type resistor. The image
    of the LDR sensor is shown in the following photo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64d208de-ef4f-4fef-8c6f-952cfc431afe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since LDR is an analog sensor, we cannot connect it directly to the RPi as
    this does not contain an **analog to digital converter** (**ADC**) circuit. Because
    of this, RPi cannot read incoming analog data from an LDR sensor. So, instead
    of an LDR sensor, we will use an LDR digital sensor module, which will provide
    digital data to the RPi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9d1de05-fc00-46b5-a57d-f16da16039a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An LDR sensor module will read the incoming analog data from the LDR sensor
    and provide digital data in the form of HIGH or LOW as output. The LDR sensor
    module consists of 3 pins: **D0** (**data output**), ground, and Vcc. D0 will
    provide digital data as output, which is further provided as input to RPi pins.
    The D0 pin will be HIGH in low light and will be LOW in the presence of light.
    The sensor module also consists of a potentiometer sensor, which can be used to
    vary the resistance of the LDR sensor.'
  prefs: []
  type: TYPE_NORMAL
- en: Practical uses of the LDR sensor module is seen in street lamps, which automatically
    turn off during day time and turn on during night time. The smart light program
    that we are going to write is somewhat similar to this application, but instead
    of a street lamp, we are going to use an LED to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've gained an understanding of the basic way in which an LDR sensor
    works, next let's connect the LDR sensor module to Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a wiring connection, we can connect the LDR sensor module and a LED to
    the RPi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72d9bc67-5467-4d05-a5a0-af7d7bc7fbff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The wiring connections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: wiringPi pin 8 of the RPi is connected to the D0 pin of the LDR sensor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin 2 of the RPi is connected to the Vcc pin of the LDR sensor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin 6 of the RPi is connected to the Gnd pin of the LDR sensor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: wiringPi pin 0 is connected to the positive pin of the LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical pin 14 is connected to the negative pin of the LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have connected the LDR sensor module and LED to the RPi, let's write
    the program to turn the LED on/off by taking inputs from the LDR sensor.
  prefs: []
  type: TYPE_NORMAL
- en: Smart light program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this smart light program, we will first read input from the LDR sensor and,
    based on the input value, we will turn the LED on or off. The program for smart
    light is described as follows. You can download the `SmartLight.cpp` program from
    the `Chapter02` folder of this book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we have set wiringPi pin 8 as the input pin and
    wiringPi pin 0 as the output pin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, in the `for` loop, using the `digitalRead(8)` function, we are reading
    the incoming digital data from the digital pin(D0) of the LDR sensor and storing
    it inside the `ldrstate` variable. From the LDR sensor, we will receive HIGH(1)
    data or LOW(0) data. The `ldrstate` variable will be HIGH when there is no light
    and it will be LOW when there is light.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will check whether the data inside the `ldrstate` variable is HIGH
    or LOW using an `if...else` condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `if(ldrstate == HIGH)`, we are comparing whether the data inside the `ldrstate`
    variable is HIGH. If it is HIGH, we are turning the LED on using `digitalWrite(0,HIGH)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ldrstate` is LOW, then the `else` condition will execute and by using
    `digitalWrite(0,LOW)`, we are turning the LED off. Next, you can click on the
    Compile button to compile the code and then test it by clicking the Build button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the SmartLight program, we will explore the concept of
    **Pulse Width Modulation** (**PWM**) and use a library called softPWM to change
    the brightness of an LED.
  prefs: []
  type: TYPE_NORMAL
- en: Pulse Width Modulation using softPWM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PWM is a powerful technique that can use to control the power that's delivered
    to an electronic component like LEDs and motors. Using PWM, we can perform operations
    like controlling the brightness of an LED or reducing the speed of a motor. In
    this section, we will first understand the way in which a PWM works and then we
    will write a simple PWM program to increase the brightness of an LED, step by
    step.
  prefs: []
  type: TYPE_NORMAL
- en: How PWM works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous `Blink.cpp` program, we applied a digital signal from the RPi
    to the LED. Digital signals either have a HIGH state or a LOW state. In, HIGH,
    state the Raspberry Pi pins produces a voltage of 3.3V and in a LOW state, the
    pins produce a voltage of 0V. Consequently, at 3.3V, the LED is on with full brightness
    and at 0V, the LED is turned off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6afde46d-da33-4d13-9f5b-5bb3dfaa1799.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To reduce the brightness of the LED, we need to reduce the voltage. To reduce
    the voltage, we use PWM. In PWM, a single wave with one full repetition is called
    a cycle and the time taken for a cycle to complete itself is called a period.
    In the following diagram, the red lines represent one complete cycle. The time
    taken to complete that cycle is called a period:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab19827a-aa9f-4400-afc5-4c4ae26df015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The time duration for which a signal remains HIGH is called a duty cycle, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abbf8698-365d-473e-9aff-ac95c0e6e752.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The duty cycle is represented in percentage format, and the formula for calculating
    the duty cycle is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Duty cycle = (time duration for HIGH signal / total time) X 100 *'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the signal remains HIGH for 7 milliseconds, and the
    total time period for a single cycle is 10 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7584af2b-571e-46c8-9570-c94b1466b4d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Duty cycle =  70% or 0.7
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, the duty cycle is 0.7 or 70%. Next, to find the new voltage value,
    we need to multiply the duty cycle with the maximum voltage value, which is 3.3V:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vout = Duty cycle X Vmax*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vout = 0.7 X 3.3*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Vout = 2.31V*'
  prefs: []
  type: TYPE_NORMAL
- en: At a duty cycle of 70%, the voltage that's provided to the LED will be 2.31V
    and the brightness of the LED will reduce slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we reduce the duty cycle to 40%, then the voltage that''s provided
    to the LED will be 1.32V, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c676d13-34c8-465f-8948-eba0df3491dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have understand how PWM is used to reduce the voltage at RPi data
    pins, let's take a look at the softPWM library, using which data pins can be used
    as PWM pins.
  prefs: []
  type: TYPE_NORMAL
- en: The softPWM library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'wiringPi consists of a softPWM library, using which we can get PWM signal output
    from any data pin of the RPi. The softPWM library contains two main functions:
    `softPwmCreate` and `softPwmWrite`. Both of these functions work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `softPwmCreate` function is used to create a PWM pin. It consists of three
    main parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pin number`: Pin number represents the wiringPi pin that we want to set as
    a PWM pin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initial duty cycle value`: In initial duty cycle value we have to provide
    as the minimum value of the duty cycle. The initial duty cycle value is ideally
    set to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max duty cycle value`: In the max duty cycle value, we have to provide the
    maximum value of the duty cycle. This value must be set to `100`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `softPwmWrite` function is used to write PWM data on the output device
    (for example, LED). It consists of two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pin number`: Pin number represents the wiringPi pin on which we have to write
    the PWM data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duty cycle value`: In this parameter, we have to provide the duty cycle value.
    The duty cycle value must be between the initial duty cycle value and max duty
    cycle value, that is, in the range of 0 to 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand the two functions inside the softPWM library, we will
    write a simple C++ program to make an LED blink at different intensities.
  prefs: []
  type: TYPE_NORMAL
- en: Making an LED blink with the softPWM library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the blinking LED program using softPWM, you will need one led. In my case,
    I have connected the negative pin of the LED to physical pin 6 (ground pin) of
    the RPi, and the positive pin of the LED is connected to wiringPi pin 15\. The
    wiring connection is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c4edb3d-6fda-4910-8058-9b013f70b0fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After connecting the led to the RPi, it''s time to write the program. The program
    for blinking the led using the softPWM library is as follows. This program is
    called `Soft_PWM_Blink.cpp`, and you can download this program from the `Chapter02`
    folder of this book''s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we first import the `wiringPi` and `iostream` libraries, along
    with the `softPwm` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, in the `main` function, using the `softPwmCreate` function, we are setting
    wiringPi pin 15 as the PWM pin. The initial duty cycle value is set to `0` and
    the max duty cycle value is set to `100`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, inside the `for` loop, we have six `softPwmWrite` functions, and
    by using these functions, we turn on the LED at different brightness levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `softPwmWrite(15,25)` function code, the LED will be HIGH with 25%
    brightness. Since the delay is set to 1,000, the LED will be HIGH for 1 second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, since the duty cycle value is set to `0`, the led will be LOW for
    1 second in the `softPwmWrite(15 , 0)` function code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, with the `softPwmWrite(15,50)` command, the LED will be HIGH with 50%
    brightness for 1 second. After this, we are again turning the LED LOW for 1 second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, with the `softPwmWrite(15 , 100)` function code, the LED will be HIGH
    with 100% brightness for 1 second. Next, we again turn the led OFF for 1 second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After writing the code, you can click on the compile button to compile the code
    and after that, hit the build button to test the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how we control the brightness of an LED using the softPWM library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations—you have successfully written your first C++ program and run
    it on your Raspberry Pi! In this chapter, we first installed the `wiringPi` library
    and understood the wiringPi pin connections for the Raspberry Pi. Next, we wrote
    a simple C++ program to blink an led. After that, we understood the working of
    the LDR sensor module and turned the LED on/off depending on the input from the
    LDR sensor module. After this, we understood PWM and used the softPWM library
    to write a program to vary the brightness of the led.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the different parts that are required to
    create a car robot. Next, we will understand the workings of DC motors and motor
    drivers, and learn how to create a car robot. After this, we will write a C++
    program to move the robot in different directions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many ground pins are there on the Raspberry Pi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a dark environment, is the resistance of the LDR sensor HIGH or LOW?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command is used for reading values from a sensor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the for loop command to make the LED blink six times?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will be the output voltage at a duty cycle at 20%, assuming the maximum
    voltage is 5V?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
