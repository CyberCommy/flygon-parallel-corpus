- en: Going Serverless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **serverless** term is probably among the hottest terms in the software
    industry lately. It may be described as the architecture style that partially
    or fully abstracts the infrastructure needed to run our software. This abstraction
    is usually provided by various third-party service providers.
  prefs: []
  type: TYPE_NORMAL
- en: To put it in the context of web application development, let's think about **Single
    Page Application** (**SPA**). Nowadays, we can easily develop an entire SPA on
    top of a fully managed infrastructure, such as AWS. Such a SPA may be written
    in Angular, having client components served from the S3 bucket, managing users
    through the Amazon Cognito service, whilst using DynamoDB as an application data
    store. The managed infrastructure abstracts away any hosting or server dealings
    from us, allowing us to focus our efforts on the application alone. What we end
    up with is one form of serverless application, depending on how narrow our definition
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Like any architectural style, serverless is far from being **<<the solution>>**.
    While some types of application can benefit from it, others might find it a total
    mismatch. The long-running applications for example, can easily turn out to  be
    expensive solution for serverless frameworks, rather than running a workload on
    a dedicated server. The trick is to find the right balance.
  prefs: []
  type: TYPE_NORMAL
- en: A more rigid and narrow definition of serverless is pure code/function hosting,
    often referred to as **Function as a Service** (**FaaS**). Such infrastructures
    provide highly concurrent, scalable, yet affordable solutions, given that they
    are mostly priced by *pay-per-execution* model. AWS Lambda and Iron.io are two
    platforms that perfectly depict this notion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a closer look at how we can utilize both the
    AWS Lambda and the Iron.io platforms to deploy chunks of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the serverless framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Iron.io IronWorker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the serverless framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AWS Lambda is a compute service provided by **Amazon Web Services** (**AWS**).
    What makes it specific is that it lets us run code without provisioning or managing
    any servers whatsoever. The auto-scaling features enable it to withstand thousands
    of requests per second. With an added benefit of pay-per-execution pricing, this
    service caught some traction among developers. Over time, the serverless framework
    was developed to make the use of the AWS Lambda service easy.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless framework is available at [https://serverless.com](https://serverless.com).
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have an AWS account created, and a clean installation of the Ubuntu
    server at hand, let's go ahead and outline the steps needed to set up and utilize
    the serverless framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can deploy applications on the AWS Lambda, we need to make sure we
    have a user with the right set of permissions. AWS permissions are quite robust,
    in that we can tune them per resource. The serverless framework uses several other
    AWS resources aside from AWS Lambda itself, such as S3, API Gateway, and a few
    others. To make our demonstration simple, we will first create an IAM User with
    Administrator access:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by logging into the AWS console at [https://aws.amazon.com/console/](https://aws.amazon.com/console/).
    Once logged in, we need to proceed under the My Security Credentials | Users screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/26e8dfc0-bee9-4725-9426-068b56ebcace.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a new user, we click on the Add user button. This triggers a four-step
    process, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2b71f9fd-594c-4e29-a045-f80cebfa993c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We provide two pieces of information here, User name and Access type. The Programmatic
    access type is what we need for our serverless integration. Clicking on the Next:
    Permissions button gets us to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/afed7936-66d3-43d5-b95c-200800c9b0ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few ways we can attach permissions to the user here. To keep things
    simple, we click on the Attach existing policies directly box, and type in AdministratorAccess
    in the Policy type field filter. We then simply check the AdministratorAccess
    policy and click on the Next: Review button, which gets us to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e4ce7578-bcdc-45a8-9e40-d3c2c4cf9a61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we merely review the current progress, and finally click on the Create
    user button, which gets us to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f8227089-6927-46fa-a6a4-195feb1ce937.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have Access key ID and Secret access key, the two pieces of information
    required by the serverless framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating users with full administrative permissions is generally considered
    a bad security practice. Normally, we would create users with a bare minimum of
    needed permissions.
  prefs: []
  type: TYPE_NORMAL
- en: With these steps out of the way, we can move forward with setting up the serverless
    framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The serverless framework runs on top of Node.js. Assuming we have an instance
    of a clean Ubuntu server, we can set it up by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Node.js with the following console commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Node.js is installed, the `npm` console tool becomes available. The serverless
    framework itself is available as an `npm` package at [https://www.npmjs.com/package/serverless](https://www.npmjs.com/package/serverless).
    Running the following console commands should get it installed on our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/3ff41a29-4d16-41cf-bff0-4bf06d7490e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the serverless framework now installed, we need to set the console environment
    variables: `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`. These get used by
    serverless during deploy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now address the bits and pieces related to PHP. The official serverless
    framework example uses an AWS lambda that runs a PHP function, which can be found
    at [https://github.com/ZeroSharp/serverless-php](https://github.com/ZeroSharp/serverless-php).
    We can install it via the following console command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an output much like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ecebec78-dabf-4a68-b734-acdfb7542473.png)'
  prefs: []
  type: TYPE_IMG
- en: The serverless install command merely pulls the content of the Git repository
    into a local directory. Within the newly created `serverless-php` directory, there
    is an `index.php` file within which our PHP application code resides. Strangely
    enough, there are bits and pieces here that, at first, look like they have nothing
    to do with PHP, such as `handler.js`. A quick look into the `handler.js` reveals
    something interesting, which is that the AWS Lambda service does not actually
    run the PHP code directly. The way it works is that `handler.js`, which is a Node.js
    app, spawns a process with an included `php` binary file. In a nutshell,  `index.php`
    is our application file, the rest is a necessary boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick sanity check, let''s trigger the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These should give us the following output, indicating that serverless is able
    to see and execute our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/43fdf30e-4b1c-4deb-a925-3602a44b81e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we are ready to deploy our PHP application to the AWS Lambda service. We
    do this by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/95344457-6c57-4980-b8b5-1142d0972798.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple command puts in motion a series of events that result in several
    different AWS services being utilized within the AWS console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the link listed under endpoints shows that our application is publicly
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9ce30662-5947-40ef-ab1f-c83d254b707e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This was made possible by the automatically created API entry under the Amazon
    API Gateway service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e369c9b8-3397-46dd-b7c2-5981dca8800f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The API Gateway bridges the `GET /hello` URL action with the AWS Lambda `serverless-php-dev-hello`
    application. A look under the AWS Lambda screen that reveals this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7f7e212a-3c65-41bd-bc8b-fd69a845e979.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The CloudFormation stack has also been created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b167b8cc-6d54-4f29-8577-ba77cdb709ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The S3 bucket has also been created, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7f0a9b21-a5be-4b4f-b51d-9775fb452b9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The CloudWatch log group has also been created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e52db856-4769-46ea-aa17-0b1c01f8e784.png)'
  prefs: []
  type: TYPE_IMG
- en: In a nutshell, `serverless deploy` kicked off quite a few services for us, thus
    giving us time to focus more on actual application development. Although AWS Lambda
    only charges a fee when a code is run, some of the other services in the mix might
    be different. This is why it is important to keep an eye on everything that gets
    automatically triggered for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, serverless also provides a cleanup command, which is written
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8a1807f7-94d9-4e90-bcab-e513dec0fa22.png)'
  prefs: []
  type: TYPE_IMG
- en: This command does an overall cleanup by removing all of the services and resources
    it previously created.
  prefs: []
  type: TYPE_NORMAL
- en: Using Iron.io IronWorker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iron.io is a serverless job processing platform designed for high performance
    and concurrency. Built around Docker containers, the platform itself is language-agnostic.
    We can use it to run pretty much any programming language, including PHP. There
    are three main features of the Iron.io platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IronWorker**: This is an elastic task/queue-like worker service that scales
    out processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IronMQ**: This is a message queueing service designed for distributed systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IronCache**: This is an elastic and durable key/value store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we cannot run real-time PHP within the Iron.io platform, we could utilize
    its IronWorker feature for task/queue-like type of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have an Iron.io account opened and the Ubuntu server with Docker
    installed, we'll be able to follow the next steps outlining the IronWorker workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by clicking the New Project button under the Iron.io dashboard. This
    opens up a simple screen, where all we need is to punch in the project name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3893fc43-cfa5-4ed0-b4ba-048ea945b652.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the project is created, we can click on the project settings link. This
    opens up a screen with several pieces of information, including the Authentication/Configuration
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/271ab3b9-79d2-4e1b-817a-c2bfd145e822.png)'
  prefs: []
  type: TYPE_IMG
- en: We will need these parameters as we will configure the `iron.json` file later
    on. With these pieces of information at hand, we are ready to proceed with the
    application bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application-wise, we start of by installing the `iron` console tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, the `iron` command should be available via the console, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/456cb0f0-3aea-4c2d-afc4-61428794c65a.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to kick off our first Iron app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have a clean directory where we want to put our application files,
    we start by adding `composer.json` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are just telling Composer what libraries to pull in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iron_worker`: This is the client library for IronWorker ([https://packagist.org/packages/iron-io/iron_worker](https://packagist.org/packages/iron-io/iron_worker))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iron_mq`: This is the client binding for IronMQ ([https://packagist.org/packages/iron-io/iron_mq](https://packagist.org/packages/iron-io/iron_mq))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php-cli-tools`: These are the console utilities for PHP ([https://packagist.org/packages/wp-cli/php-cli-tools](https://packagist.org/packages/wp-cli/php-cli-tools))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create `Dockerfile` with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These `Dockerfile` instructions help Docker to automatically build the necessary
    image for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `greet.payload.json` file with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is not really a necessary part of the process, but we are using it to simulate the
    payload our application receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the `greet.php` file with its content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `greet.php` file is our actual application. The job that gets created on
    the IronWorker service will be queueing and executing this application. The application
    itself is simple; it merely grabs the value of a payload variable named `name`,
    and echoes it out. This should suffice for our IronWorker demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the `iron.json` file with a similar content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We ensure that we paste `project_id` and `token` obtained from the Project settings
    screen within the Iron.io dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: With these files in place, we have defined our application, and are now ready
    to kick off Docker related tasks. The overall idea is that we will first create
    a local Docker image for testing purposes. Once we are done with the testing,
    we will push the Docker image to the Docker repository, and then configure the
    Iron.io platform to use the image from the Docker repository to power its IronWorker
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now install our worker dependencies into Docker, as set by the `composer.json`
    file. We will do so by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should show the Composer installing dependencies, as you can see
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/54528b74-a093-4227-9bfe-d67ebba7aa26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once Composer is done installing dependencies, we should test to see if our
    application is executing. We can do this via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output of the preceding command should be a Welcome John string,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/773c3783-468f-4602-a540-ec2c766777bf.png)'
  prefs: []
  type: TYPE_IMG
- en: This confirms that our Docker image is working correctly, and we are now ready
    to build and deploy it to [https://hub.docker.com](https://hub.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub, available at [https://hub.docker.com](https://hub.docker.com), is
    a cloud-based service that provides a centralized solution for container image
    management. While it is a commercial service, there is a free *one-repository*
    plan available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have opened a Docker Hub account, executing the following command
    via the console would flag us as logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Where `ajzele` is the username which should be replaced with our own:![](assets/4443de04-07d7-4d4c-961e-ed0ed8e90bd3.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now and package our Docker image by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard build command that will create an `ajzele/greet` image, flagged
    with version `0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/249c6260-3677-4b42-ab8a-c29131084018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the image now created, we should test it first before pushing it to the
    Docker Hub. Executing the following command confirms that our newly created `ajzele/greet`
    image is working fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/27fcdeea-f539-4b2d-81d6-48e901398b95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The resulting Welcome John output confirms that our image is now ready to be
    deployed to Docker Hub, which can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/0e266f2c-0cb6-44f1-9a97-7b6870f8e86c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the push process is done, we should be able to see our image under the
    Docker Hub dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/962b5d25-bf1d-45e3-a699-78234cf300d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Quite a few steps up until now, but we are nearly there. Now that our application
    is available as a Docker image within the Docker Hub repository, we can turn our
    focus back onto the Iron.io platform. The `iron` console tool that we installed
    early on in the process is able to register the Docker Hub image as a new worker
    under the Iron.io dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa2d7445-b1b8-4ee6-9c08-382268bd66e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we should see the `ajzele/greet` worker under the Iron.io dashboard''s TASKS tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/12bdfd6d-417a-4f1a-933e-43f3ef7edd37.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the worker is registered, it is not executed at this point. The Iron.io
    platform allows us to execute the worker either as a scheduled or queued task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduled task, as shown in the following screenshot, allows us to choose the registered
    Docker image along with the time of execution and a few other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/afdb4665-59f0-4bb3-8d05-d22a9fafeec3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The queued task, as shown in the following screenshot, also allows us to choose
    the registered Docker image, but this time without any specific timing configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/195b6831-ff13-400e-a34a-6c9e1a1a0812.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the `iron` console tool, we can create both, the schedule and queue tasks
    based on the `ajzele/greet` worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates a scheduled task based on the `ajzele/greet`
    worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `start-at` parameter defines a time in the RFC3339 format.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the RFC3339 format, check out [https://tools.ietf.org/html/rfc3339](https://tools.ietf.org/html/rfc3339).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62b5908c-ed94-43e7-8f1c-5040177b6f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Iron.io dashboard should now show this as a new entry under the SCHEDULED
    TASKS section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46ff3923-9a05-4496-a2fa-8a5c4a2d698b.png)'
  prefs: []
  type: TYPE_IMG
- en: When the scheduled time comes, the Iron.io platform will execute this scheduled
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates a queued task based on the `ajzele/greet` worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14d527b1-f84d-4879-9f90-b6e337065ab5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Iron.io dashboard registers every executed task by increasing the Complete
    counter (currently showing *3* in the following screenshot) under the TASKS section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cc021bf-9195-40a4-95a2-0588d956d8bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Going into the `ajzele/greet` worker reveals details behind each job, both
    scheduled and queued:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6ec8a8ac-57dd-4ce4-a397-37237b31fc67.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, you have learned how to create a PHP application Docker image, push
    it to the Docker Hub, register it with the Iron.io platform, and start scheduling
    and queueing tasks. The part about scheduling and queueing tasks may be a bit
    tricky as we were doing it from the console and not the PHP code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, the `composer.json` file references all of the libraries we need,
    to be able to schedule and queue tasks from the PHP code. Let''s assume, for a
    moment, that we grabbed the `iron.json` and `composer.json` files and moved onto
    a completely different server, maybe even our local development machine. All we
    need to do there is to run `composer install` on the console, and create the `index.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once this code gets executed, it will create one scheduled and one queued task,
    just as the `iron` console tool does.
  prefs: []
  type: TYPE_NORMAL
- en: While we might not host an entire PHP application with it, the Iron.io platform
    makes it easy and hassle-free to create and run various isolated jobs, giving
    developers a worthwhile serverless experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took a hands-on approach with two popular serverless
    platforms--AWS and Iron.io. Using the serverless framework, we were able to quickly
    deploy our code to the AWS Lambda service. The actual deployment involved a few
    AWS services, exposing our little chunk of code as a REST API endpoint hitting
    AWS Lambda in the background. With all of the services being managed by AWS, we
    were left with a true serverless experience. Quite a powerful concept, if we think
    about it. Aside from AWS, Iron.io is another interesting serverless platform. Unlike
    real-time code execution on AWS Lamda, the code on Iron.io executes as scheduled/queued
    tasks (not to say that AWS does not have its own queued solution as well). While
    AWS Lambda natively supports Node.js, Java, Python, and .NET Core runtimes, Iron.io
    abstracts the language away by using Docker containers. Still, we were able to
    run PHP, even on AWS Lambda, by wrapping the PHP binary through Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: The serverless approach certainly has its appeal. While it might not be the
    complete solution for some of our applications, it can certainly take on the resource-intense
    bits. The effortless use and pay-per-execution model can be a game changer for
    some.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a look at what PHP has to offer when it comes to
    the trending reactive programming paradigm.
  prefs: []
  type: TYPE_NORMAL
