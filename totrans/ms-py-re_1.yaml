- en: Chapter 1. Introducing Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions are text patterns that define the form a text string should
    have. Using them, among other usages, it will be possible to do the following
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if an input honors a given pattern; for example, we can check whether
    a value entered in a HTML formulary is a valid e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for a pattern appearance in a piece of text; for example, check if either
    the word "color" or the word "colour" appears in a document with just one scan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract specific portions of a text; for example, extract the postal code of
    an address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace portions of text; for example, change any appearance of "color" or "colour"
    with "red"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split a larger text into smaller pieces, for example, splitting a text by any
    appearance of the dot, comma, or newline characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn the basics of regular expressions from
    a language-agnostic point of view. At the end of the chapter, we will understand
    how regular expressions work, but we won't yet be able to execute a regular expression
    in Python. This is going to be covered in the next chapter. Because of this reason,
    the examples in this chapter will be approached from a theoretical point of view
    rather than being executed in Python.
  prefs: []
  type: TYPE_NORMAL
- en: History, relevance, and purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are pervasive. They can be found in the newest offimatic
    suite or JavaScript framework to those UNIX tools dating back to the 70s. No modern
    programming language can be called complete until it supports regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Although they are prevalent in languages and frameworks, regular expressions
    are not yet pervasive in the modern coder's toolkit. One of the reasons often
    used to explain this is the tough learning curve that they have. Regular expressions
    can be difficult to master and very complex to read if they are not written with
    care.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this complexity, it is not difficult to find in Internet forums
    the old chestnut:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"Some people, when confronted with a problem, think "I know, I''ll use
    regular expressions." Now they have two problems."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Jamie Zawinski, 1997* |'
  prefs: []
  type: TYPE_TB
- en: You'll find it at [https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ](https://groups.google.com/forum/?hl=en#!msg/alt.religion.emacs/DR057Srw5-c/Co-2L2BKn7UJ).
  prefs: []
  type: TYPE_NORMAL
- en: Going through this book, we'll learn how to leverage the best practices when
    writing regular expressions to greatly simplify the reading process.
  prefs: []
  type: TYPE_NORMAL
- en: Even though regular expressions can be found in the latest and greatest programming
    languages nowadays and will, probably, for many years on, their history goes back
    to 1943 when the neurophysiologists Warren McCulloch and Walter Pitts published
    *A logical calculus of the ideas immanent in nervous activity*. This paper not
    only represented the beginning of the regular expressions, but also proposed the
    first mathematical model of a neural network.
  prefs: []
  type: TYPE_NORMAL
- en: The next step was taken in 1956, this time by a mathematician. Stephen Kleene
    wrote the paper *Representation of events in nerve nets and finite automata*,
    where he coined the terms **regular sets** and **regular expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve years later, in 1968, a legendary pioneer of computer science took Kleene's
    work and extended it, publishing his studies in the paper *Regular Expression
    Search Algorithm*. This engineer was Ken Thompson, known for the design and implementation
    of Unix, the B programming language, the UTF-8 encoding, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ken Thompson''s work didn''t end in just writing a paper. He included support
    for these regular expressions in his version of QED. To search with a regular
    expression in QED, the following had to be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, `g` means global search and `p` means print.
    If, instead of writing `regular expression`, we write the short form `re`, we
    get `g/re/p`, and therefore, the beginnings of the venerable UNIX command-line
    tool `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: The next outstanding milestones were the release of the first non-proprietary
    library of **regex** by Henry Spence, and later, the creation of the scripting
    language **Perl** by Larry Wall. Perl pushed the regular expressions to the mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation in Perl went forward and added many modifications to the
    original regular expression syntax, creating the so-called **Perl flavor**. Many
    of the later implementations in the rest of the languages or tools are based on
    the Perl flavor of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The IEEE thought their POSIX standard has tried to standardize and give better
    Unicode support to the regular expression syntax and behaviors. This is called
    the POSIX flavor of the regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the standard Python module for regular expressions—`re`—supports only
    Perl-style regular expressions. There is an effort to write a new regex module
    with better POSIX style support at [https://pypi.python.org/pypi/regex](https://pypi.python.org/pypi/regex).
    This new module is intended to replace Python's `re` module implementation eventually.
    In this book, we will learn how to leverage only the standard `re` module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Regular expressions, regex, regexp, or regexen?**'
  prefs: []
  type: TYPE_NORMAL
- en: Henry Spencer referred indistinctly to his famous library as "regex" or "regexp".
    Wikipedia proposed *regex* or *regexp* to be used as abbreviations. The famous
    Jargon File lists them as *regexp*, regex, and reg-ex.
  prefs: []
  type: TYPE_NORMAL
- en: However, even though there does not seem to be a very strict approach to naming
    regular expressions, they are based in the field of mathematics called **formal
    languages**, where being exact is everything. Most modern implementations support
    features that cannot be expressed in formal languages, and therefore, they are
    not real regular expressions. Larry Wall, creator of the Perl language, used the
    term **regexes** or **regexen** for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will indistinctly use all the aforementioned terms as if they
    were perfect synonyms.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any experienced developer has undoubtedly used some kind of regular expression.
    For instance, in the operating system console, it's not uncommon to find the usage
    of the asterisk (`*`) or the question mark (`?`) to find files.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark will match a single character with any value on a filename.
    For example, a pattern such as `file?.xml` will match `file1.xml`, `file2.xml`,
    and `file3.xml`, but it won't match `file99.xml` as the pattern expresses that
    anything that starts with `file`, followed by just one character of any value,
    and ends with `.xml`, will be matched.
  prefs: []
  type: TYPE_NORMAL
- en: A similar meaning is defined for asterisk (`*)`. When asterisk is used, any
    number of characters with any value is accepted. In the case of `file*.xml`, anything
    that starts with `file`, followed by any number of characters of any value, and
    finishes with `.xml`, will be matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this expression, we can find two kind of components: **literals** (`file`
    and `.xml`) and **metacharacters** (`?` or `*`). The regular expressions we will
    learn in this book are much more powerful than the simple patterns we can typically
    find on the operating system command line, but both can share one single definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression is a pattern of text that consists of ordinary characters
    (for example, letters *a* through *z* or numbers *0* through *9*) and special
    characters known as metacharacters. This pattern describes the strings that would
    match when applied to a text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see our very first regular expression that will match any word starting
    with ![The regular expression syntax](graphics/inlinemedia.jpg)`a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The regular expression syntax](graphics/3156OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regex using literals and metacharacters
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Representation of regular expressions in this book**'
  prefs: []
  type: TYPE_NORMAL
- en: In the following figures of this book, regular expressions are going to be represented
    bounded by the `/` symbol. This is the QED demarcation that is followed in most
    of the text books. The code examples, however, won't use this notation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, even with monospaced font faces, the white spaces of a regular
    expression are difficult to count. In order to simplify the reading, every single
    whitespace in the figures will appear as ![The regular expression syntax](graphics/inlinemedia.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The previous regular expression is again using literals and metacharacters.
    The literals here are ![The regular expression syntax](graphics/inlinemedia.jpg)
    and `a`, and the metacharacters are `\` and `w` that match any alphanumeric character
    including underscore, and `*`, that will allow any number of repetitions of the
    previous character, and therefore, any number of repetitions of any word character,
    including underscore.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the metacharacters later in this chapter, but let's start by understanding
    the literals.
  prefs: []
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Literals are the simplest form of pattern matching in regular expressions. They
    will simply succeed whenever that literal is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply the regular expression `/fox/` to search the phrase `The quick
    brown fox jumps over the lazy dog`, we will find one match:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Literals](graphics/3156OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Searching using a regular expression
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can also obtain several results instead of just one, if we apply
    the regular expression `/be/` to the following phrase `To be, or not to be`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Literals](graphics/3156OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple results searching with regex
  prefs: []
  type: TYPE_NORMAL
- en: We have just learned in the previous section that metacharacters can coexist
    with literals in the same expression. Because of this coexistence, we can find
    that some expressions do not mean what we intended. For example, if we apply the
    expression `/(this is inside)/` to search the text `this is outside (this is inside)`,
    we will find that the parentheses are not included in the result. This happens
    because parentheses are metacharacters and they have a special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '![Literals](graphics/3156OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Incorrectly unescaped metacharacters
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use metacharacters as if they were literals. There are three mechanisms
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Escape the metacharacters by preceding them with a backslash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In python, use the `re.escape` method to escape non-alphanumeric characters
    that may appear in the expression. We will cover this in [Chapter 2](ch02.html
    "Chapter 2. Regular Expressions with Python"), *Regular Expressions with Python*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quoting with \Q and \E**: There is a third mechanism to quote in regular
    expressions, the quoting with `\Q` and `\E`. In the flavors that support them,
    it''s as simple as enclosing the parts that have to be quoted with \Q (which starts
    a quote) and \E (which ends it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, this is not supported in Python at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the backslash method, we can convert the previous expression to `/\(this
    is inside\)/` and apply it again to the same text to have the parentheses included
    in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Literals](graphics/3156OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Escaped metacharacters in regex
  prefs: []
  type: TYPE_NORMAL
- en: 'In regular expressions, there are twelve metacharacters that should be escaped
    if they are to be used with their literal meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: Backslash `\`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caret `^`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dollar sign `$`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dot `.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe symbol `|`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Question mark `?`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asterisk `*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plus sign `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening parenthesis `(`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing parenthesis `)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening square bracket `[`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The opening curly brace `{`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, the regular expression engines will do their best to understand
    if they should have a literal meaning even if they are not escaped; for example,
    the opening curly brace `{` will only be treated as a metacharacter if it's followed
    by a number to indicate a repetition, as we will learn later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Character classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use a metacharacter for the first time to learn how to leverage
    the character classes. The character classes (also known as character sets) allow
    us to define a character that will match if any of the defined characters on the
    set is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a character class, we should use the opening square bracket metacharacter
    `[`, then any accepted characters, and finally close with a closing square bracket
    `]`. For instance, let''s define a regular expression that can match the word
    "license" in British and American English written form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Character classes](graphics/3156OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Searching using a character class
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to also use the range of a character. This is done by leveraging
    the hyphen symbol (`-`) between two related characters; for example, to match
    any lowercase letter we can use `[a-z]`. Likewise, to match any single digit we
    can define the character set `[0-9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The character classes'' ranges can be combined to be able to match a character
    against many ranges by just putting one range after the other—no special separation
    is required. For instance, if we want to match any lowercase or uppercase alphanumeric
    character, we can use `[0-9a-zA-Z]` (see next table for a more detailed explanation).
    This can be alternatively written using the union mechanism: `[0-9[a-z[A-Z]]]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **[** | Matches the following set of characters |'
  prefs: []
  type: TYPE_TB
- en: '| **0-9** | Matches anything between `0` and `9` (`0`, `1`, `2`, `3`, `4`,
    `5`, `6`, `7`, `8`, `9`). |'
  prefs: []
  type: TYPE_TB
- en: '|   | Or |'
  prefs: []
  type: TYPE_TB
- en: '| **a-z** | Matches anything between `a` and `z` (`a`, `b`, `c`, `d`, ...,
    `z`) |'
  prefs: []
  type: TYPE_TB
- en: '|   | Or |'
  prefs: []
  type: TYPE_TB
- en: '| **A-Z** | Matches anything between `A` and `Z` (`A`, `B`, `C`, `D`, ...,
    `Z`) |'
  prefs: []
  type: TYPE_TB
- en: '| **]** | End of character set |'
  prefs: []
  type: TYPE_TB
- en: There is another possibility—the negation of ranges. We can invert the meaning
    of a character set by placing a caret (`^`) symbol right after the opening square
    bracket metacharacter (`[`). If we have a character class such as `[0-9]` meaning
    any digit, the negated character class `[^0-9]` will match anything that is not
    a digit. However, it is important to notice that there has to be a character that
    is not a digit; for example, `/hello[^0-9]/` won't match the string `hello` because
    after the ![Character classes](graphics/inlinemedia.jpg) there has to be a non-digit
    character. There is a mechanism to do this—called **negative lookahead**—and it
    will be covered in [Chapter 4](ch04.html "Chapter 4. Look Around"), *Look Around*.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined character classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After using character classes for some time, it becomes clear that some of them
    are very useful and probably worthy of a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily enough, there are a number of predefined character classes that can
    be re-used and will be already known by other developers, making the expressions
    using them more readable.
  prefs: []
  type: TYPE_NORMAL
- en: These characters are not only useful as well-known shortcuts for typical character
    sets, but also have different meanings in different contexts. The character class
    `\w`, which matches any alphanumeric character, will match a different set of
    characters depending on the configured locale and the support of Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the character classes supported at this moment in
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Description (for regex with default flags) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| This element matches any character except newline `\n` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any decimal digit; this is equivalent to the class `[0-9]` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any non-digit character; this is equivalent to the class `[^0-9]`
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any whitespace character; this is equivalent to the class `[![Predefined
    character classes](graphics/inlinemedia.jpg)\t\n\r\f\v]` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any non-whitespace character; this is equivalent to the class
    `[^ \t\n\r\f\v]` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any alphanumeric character; this is equivalent to the class
    `[a-zA-Z0-9_]` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| This matches any non-alphanumeric character; this is equivalent to the class
    `[^a-zA-Z0-9_]` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**POSIX character classes in Python**'
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX standard provides a number of character classes' denominations, for
    example, `[:alnum:]` for alphanumeric characters, `[:alpha:]` for alphabetic characters,
    or `[:space:]` for all whitespace characters, including line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: All the POSIX character classes follow the same `[:name:]` notation, rendering
    them easily identifiable. However, they are not supported in Python at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: If you come across one of them, you can implement the same functionality by
    leveraging the character classes' functionalities we just studied in this section.
    As an example, for an ASCII equivalent of `[:alnum:]` with an English locale,
    we can write `[a-zA-Z0-9]`.
  prefs: []
  type: TYPE_NORMAL
- en: The first one from the previous table—the dot—requires special attention. The
    dot is probably one of the oldest and also one of the most used metacharacters.
    The dot can match any character except a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: The reason to not match the newline is probably UNIX. In UNIX, the command-line
    tools usually worked line by line, and the regular expressions available at the
    moment were applied separately to those lines. Therefore, there were no newline
    characters to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the dot in practice by creating a regular expression that matches
    three characters of any value except newline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| . | Matches any character |'
  prefs: []
  type: TYPE_TB
- en: '| . | Matches any character followed by the previous one |'
  prefs: []
  type: TYPE_TB
- en: '| . | Matches any character followed by the previous one |'
  prefs: []
  type: TYPE_TB
- en: The dot is a very powerful metacharacter that can create problems if it is not
    used moderately. In most of the cases where the dot is used, it could be considered
    overkill (or just a symptom of laziness when writing regular expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better define what is expected to be matched and to express more concisely
    to any ulterior reader what a regular expression is intended to do, the usage
    of character classes is much recommended. For instance, when working with Windows
    and UNIX file paths, to match any character except the slash or the backslash,
    you can use a negated character set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches a set of characters |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| Not matching this symbol''s following characters |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches a `/` character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches a `\` character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| End of the set |'
  prefs: []
  type: TYPE_TB
- en: This character set is explicitly telling you that we intend to match anything
    but a Windows or UNIX file path separator.
  prefs: []
  type: TYPE_NORMAL
- en: Alternation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just learned how to match a single character from a set of characters.
    Now, we are going to learn a broader approach: how to match against a set of regular
    expressions. This is accomplished using the pipe symbol `|`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by saying that we want to match either if we find the word "yes"
    or the word "no". Using alternation, it will be as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | Matches either of the following character sets |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| The characters `y`, `e`, and `s`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Or |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| The characters `n` and `o`. |'
  prefs: []
  type: TYPE_TB
- en: 'On the other hand, if we want to accept more than two values, we can continue
    adding values to the alternation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | Matches either of the following character sets |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| The literal "yes" |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| Or |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| The literal "no" |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Or |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| The literal "maybe" |'
  prefs: []
  type: TYPE_TB
- en: 'When using in bigger regular expressions, we will probably need to wrap our
    alternation inside parentheses to express that only that part is alternated and
    not the whole expression. For instance, if we make the mistake of not using the
    parentheses, as in the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|   | Matches either of the following character sets |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| The characters `L`, `i`, `c`, `e`, `n`, `c`, `e`, `:`, ![Alternation](graphics/inlinemedia.jpg),
    `y`, `e`, and `s` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| Or |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| The characters `n` and `o`. |'
  prefs: []
  type: TYPE_TB
- en: 'We may think we are accepting either `Licence: yes` or `Licence: no`, but we
    are actually accepting either `Licence: yes` or `no` as the alternation has been
    applied to the whole regular expression instead of just the `yes|no` part. A correct
    approach for this will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Alternation](graphics/3156OS_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expression using alternation
  prefs: []
  type: TYPE_NORMAL
- en: Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have learned how to define a single character in a variety of fashions.
    At this point, we will leverage the quantifiers—the mechanisms to define how a
    character, metacharacter, or character set can be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we define that a `\d` can be repeated many times, we can easily
    create a form validator for the `number of items` field of a shopping cart (remember
    that `\d` matches any decimal digit). But let''s start from the beginning, the
    three basic quantifiers: the question mark `?`, the plus sign `+`, and the asterisk
    `*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Symbol | Name | Quantification of previous character |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Question mark | Optional (0 or 1 repetitions) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| Asterisk | Zero or more times |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| Plus sign | One or more times |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| Curly braces | Between *n* and *m* times |'
  prefs: []
  type: TYPE_TB
- en: 'In the preceding table, we can find the three basic quantifiers, each with
    a specific utility. The question mark can be used to match the word `car` and
    its plural form `cars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the characters `c`, `a`, `r` and `s` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| Optionally matches the character `s` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous example, the question mark is only applied to the character
    `s` and not to the whole word. The quantifiers are always applied only to the
    previous token.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting example of the usage of the question mark quantifier will
    be to match a telephone number that can be in the format `555-555-555`, `555 555
    555`, or `555555555`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to leverage character sets to accept different characters,
    but is it possible to apply a quantifier to a character set? Yes, quantifiers
    can be applied to characters, character sets, and even to groups (a feature we
    will cover in [Chapter 3](ch03.html "Chapter 3. Grouping"), *Grouping*). We can
    construct a regular expression like this to validate the telephone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next table, we can find a detailed explanation of the preceding regular
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Element | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| Predefined character set | Any decimal character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| Quantifier | - that is repeated one or more times |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '| Character set | A hyphen or whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| Quantifier | - that may or may not appear |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '| Predefined character set | Any decimal character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| Quantifier | - that is repeated one or more times |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '| Character set | A hyphen or whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| Predefined character set | Any decimal character |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '| Quantifier | - that is repeated one or more times |'
  prefs: []
  type: TYPE_TB
- en: At the beginning of this section, one more kind of quantifier using the curly
    braces had been mentioned. Using this syntax, we can define that the previous
    character must appear exactly three times by appending it with `{3}`, that is,
    the expression `\w{8}` specifies exactly eight alphanumeric digits.
  prefs: []
  type: TYPE_NORMAL
- en: We can also define a certain range of repetitions by providing a minimum and
    maximum number of repetitions, that is, between three and eight times can be defined
    with the syntax `{4,7}`. Either the minimum or the maximum value can be omitted
    defaulting to `0` and infinite respectively. To designate a repetition of up to
    three times, we can use `{,3}`, we can also establish a repetition at least three
    times with `{3,}`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Readability Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using `{,1}`, you can use the question mark. The same applies to
    `{0,}` for the asterisk `*` and `{1,}` for the plus sign `+`.
  prefs: []
  type: TYPE_NORMAL
- en: Other developers will expect you to do so. If you don't follow this practice,
    anyone reading your expressions will lose some time trying to figure out what
    kind of fancy stuff you tried to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: 'These four different combinations are shown in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Syntax | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| The previous character is repeated exactly *n* times. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '| The previous character is repeated at least *n* times. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '| The previous character is repeated at most *n* times. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '| The previous character is repeated between *n* and *m* times (both inclusive).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Earlier in this chapter, we created a regular expression to validate telephone
    numbers that can be in the format `555-555-555`, `555 555 555`, or `555555555`.
    We defined a regular expression to validate it using the metacharacter plus sign:
    `/\d+[-\s]?\d+[-\s]?\d+/`. It will require the digits (`\d`) to be repeated one
    or more times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fine-tune the regular expression by defining that the leftmost digit
    group can contain up to three characters, while the rest of the digit groups should
    contain exactly three digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quantifiers](graphics/3156OS_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Greedy and reluctant quantifiers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We still haven''t defined what would match if we apply a quantifier such as
    this `/".+"/` to a text such as the following: `English "Hello", Spanish "Hola"`.
    We may expect that it matches `"Hello" and "Hola"` but it will actually match
    `"Hello", Spanish "Hola"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This behavior is called greedy and is one of the two possible behaviors of
    the quantifiers in Python: **greedy** and **non-greedy** (also known as **reluctant**).'
  prefs: []
  type: TYPE_NORMAL
- en: The greedy behavior of the quantifiers is applied by default in the quantifiers.
    A greedy quantifier will try to match as much as possible to have the biggest
    match result possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-greedy behavior can be requested by adding an extra question mark to
    the quantifier; for example, `??`, `*?` or `+?`. A quantifier marked as reluctant
    will behave like the exact opposite of the greedy ones. They will try to have
    the smallest match possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Possessive quantifiers**'
  prefs: []
  type: TYPE_NORMAL
- en: There is a third behavior of the quantifiers, the possessive behavior. This
    behavior is only supported by the Java and .NET flavors of the regular expressions
    at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: They are represented with an extra plus symbol to the quantifier; for example,
    `?+`, `*+`, or `++`. Possessive quantifiers won't have further coverage in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can understand better how this quantifier works by looking at the next figure.
    We will apply almost the same regular expression (with the exception of leaving
    the quantifier as greedy or marking it as reluctant) to the same text, having
    two very different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Greedy and reluctant quantifiers](graphics/3156OS_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Greedy and reluctant quantifiers
  prefs: []
  type: TYPE_NORMAL
- en: Boundary Matchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until this point, we have just tried to find out regular expressions within
    a text. Sometimes, when it is required to match a whole line, we may also need
    to match at the beginning of a line or even at the end. This can be done thanks
    to the **boundary matchers**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boundary matchers are a number of identifiers that will correspond to a
    particular position inside of the input. The following table shows the boundary
    matchers available in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Matcher | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches at the beginning of a line |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches at the end of a line |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the opposite of `\b`. Anything that is not a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the beginning of the input |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the end of the input |'
  prefs: []
  type: TYPE_TB
- en: These boundary matchers will behave differently in different contexts. For instance,
    the word boundaries (`\b`) will depend directly on the configured locale as different
    languages may have different word boundaries, and the beginning and end of line
    boundaries will behave differently based on certain flags that we will study in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start working with boundary matchers by writing a regular expression
    that will match lines that start with "Name:". If you take a look at the previous
    table, you may notice the existence of the metacharacter `^` that expresses the
    beginning of a line. Using it, we can write the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the beginning of the line |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `N` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `a` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `m` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `e` |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by symbol colon |'
  prefs: []
  type: TYPE_TB
- en: If we want to take one step further and continue using the caret and the dollar
    sign in combination to match the end of the line, we should take into consideration
    that from now on we are going to be matching against the whole line, and not just
    trying to find a pattern within a line.
  prefs: []
  type: TYPE_NORMAL
- en: Following the previous example, let's say that we want to make sure that after
    the name, there are only alphabetic characters or spaces until the end of the
    line. We will do this by matching the whole line until the end by setting a character
    set with the accepted characters and allowing their repetition any number of times
    until the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the beginning of the line. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `N`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `a`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `m`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `e`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by colon symbol. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '| Then matches the followed by whitespace, or any alphabetic lowercase or uppercase
    character. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '| The character can be repeated one or more times. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '| Until the end of the line. |'
  prefs: []
  type: TYPE_TB
- en: 'Another outstanding boundary matcher is the word boundary `\b`. It will match
    any character that is not a word character (in the configured locale), and therefore,
    any potential word boundary. This is very useful when we want to work with isolated
    words and we don''t want to create character sets with every single character
    that may divide our words (spaces, commas, colons, hyphens, and so on). We can,
    for instance, make sure that the word `hello` appears in a text by using the following
    regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '| Element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches a word boundary. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `h`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `e`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `l`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `l`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '| Matches the followed by character `o`. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '| Then matches another followed by word boundary. |'
  prefs: []
  type: TYPE_TB
- en: As an exercise, we could think why the preceding expression is better than `/hello/`.
    The reason is that this expression will match an isolated word instead of a word
    containing "hello", that is, `/hello/` will easily match `hello`, `helloed`, or
    `Othello`; while `/\bhello\b/` will only match `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first chapter, we have learned the importance of the regular expressions
    and how they became such a relevant tool for the programmers.
  prefs: []
  type: TYPE_NORMAL
- en: We also studied from a yet non-practical point of view, the basic regular expression
    syntax and some of the key features, such as character classes and quantifiers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to jump over to Python to start practicing
    with the `re` module.
  prefs: []
  type: TYPE_NORMAL
