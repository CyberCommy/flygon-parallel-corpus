- en: Exploitation of Embedded Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with web app security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OWASP ZAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting command injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications and web services are used to execute remote access features
    as well as to manage devices. A great deal of power can be given to web applications
    of IoT devices that would enable remotely executable control over to an attacker.
    Certain products such as connected vehicles or smart door locks with remotely
    executable vulnerabilities can cause harm and personal safety risks to its users.
    When testing products in the before mentioned categories of IoT, locating vulnerabilities
    with the highest risk and impact to users are the first to target. In this chapter,
    we will show how to select a web application testing methodology, setup your web
    testing toolkit, as well as discuss how to discover and exploit some of the most
    commonly found embedded web application vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with web app security testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the modern web is running on applications that are behind hundreds of
    web, application, and database servers as their backend systems. The web has progressed
    from static HTML pages to sophisticated asynchronous applications that require
    more resources to compute. Although the web has changed, some of the most common
    security issues have not. Vulnerabilities first discovered in the 1990s are still
    relevant and actively being exploited. In IoT products, some of these common vulnerabilities
    are often command injection, **Cross-site scripting** (**XSS**), directory traversal,
    authentication bypass, session hijacking, **XML External Entity** (**XXE**), **cross-site
    request forgery** (**CSRF**), and other business logic flaws. In this recipe,
    we will establish a web application testing methodology to be used for finding
    and exploiting IoT web application and web services vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start assessing web applications, it is important to establish a methodology
    and sometimes even a checklist once you get the hang of things. Understanding
    your approach and contextual applications risks are key to the success of compromising
    security controls. After we establish methodologies relevant to our target application,
    we will start configuring our web testing environment and toolkit to start with
    web application security testing.
  prefs: []
  type: TYPE_NORMAL
- en: Web penetration testing methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of pen testing methodologies other than web pen testing
    methodologies. There is no right or wrong methodology per se; however, establishing
    your approach to testing an application is crucial to your success in finding
    software flaws. The most common methodologies are **Penetration Testing Execution
    Standard** (**PTES**) and OWASP''s Web Application Penetration Testing Methodology.
    **Open Web Application Security Project** (**OWASP**) is a not-for-profit charitable
    organization providing tools and documents, and advocates software security internationally.
    If you have ever tested an application or had to remediate software vulnerabilities,
    you might be familiar with OWASP already. If you have ever performed a penetration
    test, you might have run into PTES as well. PTES is meant to provide a baseline
    to follow for penetration tests. PTES defines penetration testing as seven phases
    that consist of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-engagement interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Intelligence gathering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Threat modeling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vulnerability analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploitation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Post-exploitation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reporting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Although PTES is relevant to all silos of information security testing, it
    is most used and applied for network-oriented penetration tests. There are small
    sections pertaining to web security but not enough to perform a successful assessment
    at this time. PTES does provide detailed hands-on examples for each phase of the
    methodology and also includes tool usage examples. On the other hand, OWASP''s
    Web Application Penetration Testing Methodology is geared purely towards web application
    penetration testing. OWASP''s Web Application Penetration Testing Methodology
    consists of the following 12 categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction and objectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration and deployment management testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity management testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input validation testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to PTES, OWASP's testing methodology provides a number of examples for
    each phase with screenshots as well as tool references and usage. Having examples
    relevant to your testing target application is helpful when experience is low
    in some areas. One of the great things about the OWASP testing methodology is
    the context to specific testing methods to try for use cases and testing perspectives,
    such as black box or grey box. OWASP is considered the de facto organization for
    application security guidance and testing. When in doubt, have a look at the OWASP
    testing guide or their various cheat sheet series for a helping hand.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of tools available for testing web applications. The first
    step in assembling your tool box for assessing web applications will be selecting
    a browser and customizing its configuration for testing. A common browser to test
    with is Firefox due to its many testing add-ons available. Other browsers can
    also be used and may be required for some applications, such as those that utilize
    ActiveX or Silverlight, which need an Internet Explorer browser to function. Some
    add-ons make life much easier and more efficient for testing. Common useful add-ons
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FoxyProxy**: A tool to manage browser proxy settings for Chrome and Firefox.
    Sometimes you may have multiple proxy tools running concurrently and may need
    to switch between the two. FoxyProxy helps with changing proxy settings without
    clicking through a number of browser setting menus. FoxyProxy can be downloaded
    at [https://addons.mozilla.org/en-us/firefox/addon/foxyproxy-standard/](https://addons.mozilla.org/en-us/firefox/addon/foxyproxy-standard/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie Manager+**: A cookie manager is useful for editing cookie values and
    viewing their attributes. There are many cookie manager add-ons available for
    Firefox and Chrome. A common cookie manager for Firefox is Cookie Manager+. Cookie
    Manager+ can be downloaded at https://addons.mozilla.org/en-US/firefox/addon/cookies-manager-plus/.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wappalyzer**: For a better understanding of the target application, it helps
    to know what components are being utilized. Wappalyzer is an add-on that assists
    with uncovering the technology being used, which includes the web server, frameworks,
    and JavaScript libraries. Wappalyzer can be downloaded for Firefox and Chrome
    at https://wappalyzer.com/download.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a browser is selected, proxy settings must be configured in order to view
    the application's request and responses in a web application proxy tool. In the
    following recipes, we will walk through configuring proxy settings and web application
    proxy tools.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite is one of the most popular web proxy tools used for assessing web
    applications. Burp is a cross-platform tool based on Java. With Burp Suite, HTTP
    requests, and responses can be man-in-the-middled in order to tamper with as well
    as monitor application behavior. Additionally, applications can be spidered, actively
    scanned for vulnerabilities, passively scanned, and fuzzed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite is preinstalled in the virtual machine prepared for the cookbook;
    however, it can also be downloaded at [https://portswigger.net/burp/](https://portswigger.net/burp/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two versions of Burp: free edition and professional edition. The
    professional edition is available for a modest price ($349.00 USD) given Burp''s
    feature set. There is a 2-week professional edition trial available as well. The
    free edition allows proxying of HTTP requests and responses as well as downloading
    some of the extender add-ons available in the BApp store. The professional version
    allows usage of more advanced features and professional extender add-ons.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will walk through basic usage of Burp Suite to start testing embedded web
    applications. The following examples will be using the Burp Suite professional
    edition; however, the same setup steps can also be applied to the free edition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up Burp proxy listener settings to `127.0.0.1` with port `8080`, as seen
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ab04475-9738-48f9-8a02-ca5f7d2f8aea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set up browser proxy settings with FoxyProxy to our Burp Suite listener address
    we set in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c75e385-9c69-413c-874b-2d40f9c6f692.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the configured proxy to route all traffic to our Burp proxy listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16663d82-4c91-462f-9392-9b3cb8c7f417.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to download and install Burp''s CA certificate by navigating
    to `http://burp/cert`, save the certificate in a folder, and import the certificate
    into the browser''s certificate manager. Importing Burp''s CA certificate allows
    for the proxying of HTTPS connections, which may come in handy in the future:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d394bec0-e6a7-407c-8484-4109e37db384.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to `about:preferences#advanced` in Firefox and select Certificates
    then Authorities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f38711f7-1d8b-42db-95b0-d2cdc78ab708.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Import... button and select the Burp Suite certificate that was
    saved locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0468ca2b-36b5-455f-996e-3c5ec8af99a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can view HTTP /HTTPS request and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have basic proxy settings configured for our browser and Burp Suite,
    navigate to a target web application. Add our target application to scope by right-clicking
    its address and select Add to scope, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/053deda8-7603-4721-a3c8-4070db6fc438.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the scope is selected, requests can be scanned via Burp''s scanning engine
    by right-clicking a request and selecting Do an active scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32fb5ab3-dcb5-4fa2-aaea-03be79890bf6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'View the scan results by navigating to Scan queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c01b5144-1b24-4680-b86e-d91a1303f322.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes we may want to replay requests using a Repeater for observing application
    responses or for tweaking payloads. This can be done by right-clicking the target
    request and sending it to the Repeater. The following screenshot shows the `alias`
    parameter being tweaked with a payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5faec337-291f-4c7c-b1b9-ced6e1550d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While on the subject of tweaking payloads, we may need to encode or decode
    certain characters to ensure our payload executes using Burp Suite''s decoder
    facility. The following screenshot shows a decoded value (top) being URL encoded
    (bottom):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/02b7e4ff-8973-45ff-b9ad-319f891921b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A more manual approach for fuzzing parameters with specific targeted payloads
    can be accomplished using Burp Suite''s Intruder. First, a target parameter needs
    to be specified. In this case, we use the `alias` parameter as the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c9d6df39-b119-4c59-b10d-316a208dee36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the attack payloads to be used (Fuzzing - XSS in this case) and
    click Start attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/be2b63cd-033d-4fee-90d1-14cfaffacd59.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A separate window will pop up, where attack results will be viewable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbd3005f-0a49-4206-b819-f8c10c75bd27.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During our setup steps, we configured Burp proxy settings and browser settings,
    and learned the basics of Burp Suite that will be used for testing. We configured
    browser proxy settings using FoxyProxy, installed Burp's CA certificate, scanned
    a request, and showed how to use additional Burp tools that may be helpful in
    more target attacks, such as the Repeater, decoder, and Intruder.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, we can now start accessing embedded web applications for
    vulnerabilities on target devices using Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite has a strong community behind it. The community has created a number
    of add-on extensions when new attack techniques are discovered. The same goes
    for Burp Suite itself. PortSwigger does a great job of staying ahead of the curve
    by constantly updating Burp. Have a look at the various release notes and you
    might learn a thing or two ([http://releases.portswigger.net/](http://releases.portswigger.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Useful intruder payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Intruder, it's a good idea to have a set of targeted payloads for
    fuzzing parameters. The SecList project has a number of wordlists as well as fuzzing
    payloads to be used in more targeted attacks. The project is regularly being updated
    with community contributions that assist with testing. The SecList repository
    can be found via the URL [https://github.com/danielmiessler/SecLists/](https://github.com/danielmiessler/SecLists/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ever find yourself needing to create macros or an add-on for a customized
    purpose, have a look at Burp's extensibility API found at [https://portswigger.net/burp/extender/](https://portswigger.net/burp/extender/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OWASP ZAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OWASP **Zed Attack Proxy** (**ZAP**) is a free cross-platform web proxy
    testing tool used for finding vulnerabilities in web applications. ZAP is a close
    runner-up to Burp Suite in the web application proxy testing tool space and is
    a definite go-to when your budget may be low for licensing commercial products.
    ZAP is designed to be used by people with a wide range of security experience
    and as such is ideal for developers as well as functional testers who are new
    to penetration testing. With ZAP's API, scans can be automated and used within
    a developer's workflow to scan builds prior to production. ZAP has a number of
    different useful add-ons with a strong scanning engine that includes other proven
    testing tools within its engine, such as Dirbuster and SQLmap. In addition, ZAP
    has a graphical scripting language known as ZEST that records and replays requests
    similar to a type of macro. This recipe will introduce the basic ZAP features
    for web app security testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite is preinstalled in the virtual machine prepared for the cookbook;
    however, it can also be downloaded via [https://github.com/zaproxy/zaproxy/wiki/Downloads](https://github.com/zaproxy/zaproxy/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: The ZAP download page contains additional Docker images as well as ZAP weekly
    versions that utilize new features not introduced in the official releases. The
    weekly releases are highly stable and I would recommend giving them a go if you
    would like more extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will introduce the setup and basic usage of ZAP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the ZAP proxy listener settings by clicking Tools and then Options.
    Input the IP and port information for ZAP to listen on, as seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb263bcd-8773-464d-92c6-1b7bc38bd6d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Generate and install ZAP''s CA certificate via the Dynamic SSL Certificate
    option and install the certificate in the browser, similar to how you did in the
    Burp Suite recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71c9b102-a12e-4392-9a2d-9390a01c450a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the certificate in a known directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6e52f310-3823-4d8b-9587-4b93a9612454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are required add-on installations that will assist in active and passive
    web pen testing. These add-ons are Advanced SQLInjection Scanner, Active scanner
    rules (alpha), DOM XSS Active scanner rule, Passive scanner rules (alpha), and
    Technology detection using Wappalyzer. ZAP has levels of maturity for its add-ons
    but it does not hurt using an alpha-level add-on. The following screenshot illustrates
    the necessary add-ons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfd962bc-aedd-46c3-8dbf-047275b0e390.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have the required add-ons installed, scan policies can now be configured
    via the Analyse and Scan Policy Manager options. These policies can also be exported
    and imported. The following screenshot shows an example scan policy to be used
    for XSS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d08cc6f-ac66-405b-9e02-ef621a203ac1.png)'
  prefs: []
  type: TYPE_IMG
- en: ZAP's scan policies contain a threshold and strength. The threshold pertains
    to the alert confidence and how likely ZAP is to report potential vulnerabilities.
    The strength pertains to the amount of attacks ZAP will perform. This information
    can be found via ZAP's user guide located in the tool itself or online at [https://github.com/zaproxy/zap-core-help/wiki](https://github.com/zaproxy/zap-core-help/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: 'With our scanning configurations configured, we need to add the target site
    to be in context by right-clicking the target, as seen in the following screenshot.
    This is similar to Burp''s Add to Scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/88e0ab44-58cc-483d-b55c-8192fc0e7488.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The target is now included in context for scanning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63ac437e-c29e-4d52-bb9a-fbf1f55d6fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scanning a request is done by right-clicking the target request, selecting
    your scan policy, and starting the scan, as seen in the following screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/335ee3fc-f922-4ea2-bd9b-7fe33af67715.png)'
  prefs: []
  type: TYPE_IMG
- en: The XSS scan policy is chosen and now the scan will begin with the output of
    the scan shown in the "Active Scan" tab in ZAP.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bf5c0a4-3580-4a5a-a47c-7184e178c0d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a more targeted approach to active scanning, utilize ZAP''s fuzzing feature,
    which is similar to Burp''s Intruder. To fuzz, right click the request and select
    fuzz locations and payloads, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f7d9c14-7016-4d24-856e-fd6e7ff3f692.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Decoding and encoding characters are crucial to code executing. ZAP''s Encoder/Decoder,
    accessible via the Tool menu, works similar to Burps Decoder, as seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f46f40f5-8bc5-42bc-abf8-a8a7fdf353b1.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ZAP is very customizable and extendable; our last recipe only covered the basic
    usage of ZAP to assist with web app security testing. To learn more about using
    and customizing ZAP, visit ZAP's blog as well as their wiki via the links [https://github.com/zaproxy/zaproxy/wiki](https://github.com/zaproxy/zaproxy/wiki)
    and [https://zaproxy.blogspot.com/](https://zaproxy.blogspot.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you would like to hone your web application testing skills
    with ZAP or Burp Suite, have a look at OWASP's Vulnerable Web Application Directory
    Project found at [https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project](https://www.owasp.org/index.php/OWASP_Vulnerable_Web_Applications_Directory_Project).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting command injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In embedded systems, OS command injection is a vulnerability most commonly via
    a web interface or debug page left from development firmware builds in order to
    execute arbitrary operating system commands. The user supplies operating system
    commands within a web service parameter through a web interface in order to execute
    OS commands. A parameter that is dynamic and not properly sanitized is subject
    to this vulnerability being exploited. With the ability to execute OS commands,
    an attacker can upload malicious firmware, change configuration settings, gain
    persistent access to the device, obtain passwords, attacker other devices in a
    network, or even lock out legitimate users from the device. In this recipe, we
    will demonstrate how to exploit command injection to gain shell access to a device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use tcpdump, Burp Suite, and a vulnerable IHOMECAM
    ICAM-608 IP camera. Tcpdump is included in most *Nix operating systems but Wireshark
    can also be used to observe packets.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of finding command injectable pages within an embedded web application
    is rather trivial. The first places within an application we want to examine are
    diagnostic pages that make use of system commands, such as `ping` or `traceroute`,
    but also configuration setting pages for daemons, such as SMB, PPTP, or FTP. If
    we have acquired firmware or gained access to a target device''s console, it''s
    always best to statically analyze vulnerable scripts and functions that the device
    executes and validate potential findings discovered via dynamic analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at our target IP camera''s configuration menu settings to
    pinpoint a potentially vulnerable page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9675cb0f-af21-474c-8094-1b0c3c4f8d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are not many pages to choose from, but we do see mail service and FTP
    service setting pages. These pages may feed system commands into the operating
    system for execution. Let''s first examine the FTP service setting page and attempt
    to manipulate parameter values with system commands via Burp Suite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e6c1d0f6-2898-4872-9721-cd5ed3b1054c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There appears to be a stripping of characters from the application when trying
    to send the payload `$(ping%20192.168.1.184)` in the `pwd` parameter, as seen
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/81a56e3b-bea5-4e4d-b597-4c9d9b98a8b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using a basic command such as `ping` for a payload to our host computer gives
    us an indication that our command has successfully executed. In order to observe
    whether the ping has been executed, set up `tcpdump` to listen for ICMP packets
    coming from our target IP camera using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Burp Suite''s Repeater, we can change the values and bypass client-side
    checks the IP camera is performing. Using the following request, we can see that
    the application accepts our changes and needs to refresh the `ftp.htm` page based
    on the HTTP response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon refreshing to the `ftp.htm` page, we observe ICMP packets being sent to
    our host computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know the `pwd` parameter is vulnerable to command injection, our
    next goal is to obtain shell access to the target device. We know the IP camera
    contains legacy daemons based on the usage of FTP, and chances are Telnet is also
    used. Next, we will invoke Telnet to start on port `25` and drop us into a shell
    without a username or password using the following payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also know the application requires a refresh to the `ftp.htm` page for the
    settings to save but, viewing the source of the page, it calls to a CGI called
    `ftptest.cgi` that executes our payload. The following is the snippet of code
    that executes our payload from the `ftp.htm` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can call the `ftptest.cgi` directly to save our settings using the
    following `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Telnet is now running on port `25` and gives us a root shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a variety of techniques that can be used for post-exploitation on
    the device''s LAN after the shell has been granted. Post-exploitation techniques
    will not be covered in this recipe; however, we can easily script our command
    injection payloads to ensure access using the following bash script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we walked through discovering and exploiting command injection
    on an IHOMECAM ICAM-608 IP camera. We were able to gain shell access and create
    a script to automate the exploitation of command injection.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more on finding and preventing command injection, refer to OWASP's
    command injection wiki page ([https://www.owasp.org/index.php/Command_Injection](https://www.owasp.org/index.php/Command_Injection))
    as well as OWASP's Embedded Application Security project ([https://www.owasp.org/index.php/OWASP_Embedded_Application_Security](https://www.owasp.org/index.php/OWASP_Embedded_Application_Security)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'XSS is a type of attack that executes and injects arbitrary JavaScript from
    an untrusted source in the context of a trusted website. XSS attacks occur when
    an attacker discovers a vulnerable parameter within a web application that executes
    dynamic content without validating or output encoding characters before rendering
    content back to the user. XSS attacks utilize the browser''s to transport attack
    payloads since the browser believes the code is trusted. There are three types
    of XSS vulnerabilities: reflective (most common), stored, and DOM-based. Reflective
    XSS vulnerabilities arise when parameter data is copied and echoed back into the
    application''s response without sanitizing its content. Stored XSS vulnerabilities
    arise when an application allows parameter input data to be stored in the application''s
    database for later use. **Document Object Model** (**DOM**) XSS vulnerabilities
    occur when data from a parameter is fed into a DOM element via a JavaScript function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An attacker who successfully exploits an XSS would be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Key log data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack the victim's **local area networks** (**LANs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy all web traffic through the victim known as **man-in-the-browser** (**MITB**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steal or modify the application cookie(s) for session hijacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the appearance of the victim's application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypass CSRF security controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to successfully attack a victim, an attacker would need to perform
    a type of social engineering technique to get the user to execute the malicious
    request. Common methods of social engineering for an XSS attack are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fake website with malicious JavaScript and linking to its page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending emails embedding the malicious web URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking the URL with a URL shortener
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of the scenarios, the initial URL will link to the trusted victim's
    site, and will execute malicious JavaScript code asynchronously without user knowledge.
    In this recipe, we will walk through discovering and exploiting a reflective XSS
    vulnerability that will gain full control over the victim's browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will make use of OWASP ZAP, **Browser Exploitation Framework**
    (**BeEF**), and a vulnerable RT-N12 ASUS router. BeEF can be installed via [http://beefproject.com](http://beefproject.com)
    or used within a Kali Linux virtual machine where BeEF is installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When attempting to find a reflective XSS vulnerability, we start by observing
    parameter input behavior to see whether the data is reflected back to the user.
    Web proxys such as OWASP ZAP and Burp Suite can help automate the discovery process
    with their scanning engines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate through the application to find potential reflected values. Usually
    places to probe are diagnostic pages, troubleshooting, or configuration pages
    that change services or daemons running on the embedded device. The following
    screenshot shows a potential starting point for discovering a web vulnerability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8c989d0-42ca-4330-a072-d11264aaf784.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Proxy the HTTP request in ZAP and make a change to the configuration on this
    page. You should see the POST body parameters as seen in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7633b956-938c-4db3-94b1-b10db94b9ad5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Reviewing the `start_apply.htm` source reveals some possible dynamic variables
    that can be manipulated via concatenating JavaScript code. These variables appear
    to be the parameters sent as the `POST` body of the request but can also be sent
    via a `GET` request as well. The following are snippets of possible injectable
    parameter values for `next_page` within `start_apply.htm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using fuzz parameters with XSS payloads, we can manually inject XSS payloads
    and observe the responses but we can also utilize known XSS payloads with wordlists
    such as SecLists that will help speed up the discovery process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the fuzz results in ZAP, we see a number of reflected parameters in
    the HTTP response, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23539223-f5c8-4c98-9e52-1b719528c184.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the `next_page` parameter reflects our exact fuzzing input
    value (`<script>(document.head.childNodes[3].text)</script>`) as seen in the following
    snippet of the HTTP response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba67e021-85c2-4b02-bfb1-129fbfaa864d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s manually input this reflected parameter in the browser to observe its
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c82cc2b-d804-4f6d-aa3c-7e240e775c8b.png)'
  prefs: []
  type: TYPE_IMG
- en: It appears we are breaking some of the JavaScript code based on the response.
    It may have to do with the encoding or possible length of the payload. We will
    need to adjust encoding characters and review the JavaScript code to make sure
    our code starts or ends a function that may be in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using basic alert XSS payloads for discovery, remember in the `start_apply.html`
    source, the parameter values were in the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use ZAPs Encoder/Decoder tool to adjust our basic XSS payloads, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f2e101c9-017b-42b6-87b1-7653dc17fec7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Plug in the URL encoded value into the vulnerable parameter via the web interface
    and now our alert code executes successfully. It''s always best to try an integer
    within the alert box to see whether our code executes first before digging into
    more complex XSS payloads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4fa7004-3f96-47af-97b7-4c17d1fb1c83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s take it a step further and dump any cookies within the alert box
    with the following payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the cookie value `IoTCookbook=1234567890` rendered in our browser
    using the basic payload of `alert(document.cookie)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5917c0dd-44e6-4ceb-98bc-7d0962aa5415.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We now know that we can do some basic XSS payloads at this point. Luckily
    for us, we have yet to hit any character limitations or any type of filtering.
    Let's see if we can do more damage and insert a BeEF hook payload into the vulnerable
    parameter. After all, what risk does an alert box pose?
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to using BeEF XSS payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BeEF is a tool that exploits web browsers and client-side attack vectors within
    a victim's environment via vulnerable application parameters as well social engineering
    techniques. BeEF will hook one or more web browsers when a victim has executed
    its payload where a number of command modules are available for further exploitation.
    This next section will expand on our discovered XSS vulnerability to have it execute
    a BeEF hook and then touch on some of the basic uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'BeEF is powerful and demonstrates the impact of what an XSS is capable of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have demonstrated how basic XSS payloads execute, we are going
    to kick it up a notch and try a BeEF payload with similar formatting as the last
    two with the following `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this `GET` request, we can see the browser respond with a broken page
    as seen in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f20f997-5804-4dfb-8490-e2bd459956a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we are breaking some piece of JavaScript code, preventing the browser
    from executing our JavaScript code hosted externally on the BeEF server. Chances
    are we need to terminate the intended JavaScript code and start our own `<script>`
    tags to have our external JavaScript BeEF be requested. We can try adding a parameter
    with open and close script tag brackets, add quotation marks, and then try to
    call our BeEF hook payload using the following `GET` request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we send the `GET` request and have a look at the browser response, it
    appears to output the same broken JavaScript; however, if we have a look at ZAP,
    we can see the browser sending requests to our BeEF server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e4d47ed-73f8-4246-99b6-18f7b14c7bd3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Following are the BeEF hook requests shown in ZAP''s History tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/874c69c1-28ec-4c5c-af61-0a06d6c75255.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the BeEF server, we have successfully hooked our browser with our payload,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84dc7381-1e28-4346-9c3b-8513ab31358e.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic usage of BeEF when hooking a victim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the basic usage of BeFF while hooking a victim:'
  prefs: []
  type: TYPE_NORMAL
- en: Once a victim is hooked, BeEF quickly enumerates information running on the
    victim's computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates what BeEF captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e372f36-35c1-4f4f-a1ac-6c5f376f7f63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Along with host details, BeEF uses a number of exploitation modules to be used
    on the victim, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/95723930-53b5-44b3-afb0-5afec8d5fbdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One module in the network category can scan the victim''s ports for post-exploitation
    assistance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e7308456-d9aa-4794-a8d9-28e5bafa6e1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Proxying traffic through a victim's browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of my favorite features of BeEF is the ability to use the victim as a proxy
    to send forged requests on behalf of the user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s as simple as right-clicking the hooked victim to use as a proxy, navigating
    to the Rider tab, and using the Forge Request option, as seen in the following
    screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22b6a1a5-8afd-4e62-824b-a593a1dfbc9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy a known `HTTP` request to forge through the victim''s browser, such as
    creating or changing an admin user''s password, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75c54380-421e-4c78-a096-3434c0eb51c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'View the forged response in the History tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/85c6f421-d3d9-405d-9bc9-fa9d95d49a18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the forged request is double-clicked, another tab will open with the path
    of the forged request and the `HTTP` response will be shown, as illustrated in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/535439ce-c485-47cc-9bb0-5458a79d1cf0.png)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we demonstrated how to discover vulnerable XSS parameters, reviewed
    encoding considerations, dissected JavaScript code, discussed usage of basic XSS
    payloads, and exploited a cross-site scripting vulnerability with a BeEF hook.
    When BeEF is hooking a victim, there are a number of possibilities and exploitation
    techniques to be used.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For details on BeEF modules and advanced features, visit BeEF's GitHub wiki
    page at [https://github.com/beefproject/beef/wiki](https://github.com/beefproject/beef/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many caveats when trying to exploit XSS beyond a basic alert box.
    Quite often, encoding will need to be adjusted for evading filters or to minimize
    a payload due to character limitations. For assistance with evading filters and
    XSS in general, have a look at OWASP's XSS wiki page found via [https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)).
    The XSS wiki page also links to several XSS testing guidance documents, such as
    evading filters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting CSRF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF is an attack that tricks a victim into submitting a malicious request with
    the identity and privileges of the victim to perform an undesired function on
    the victim's behalf. For most applications, browsers will automatically include
    any associated session information such as the user's session cookie, token, IP
    address, and sometimes Windows domain credential NTLM hashes. If the victim user
    is currently authenticated to the site, the site will have no way to distinguish
    between the forged request sent by the victim and a legitimate request sent by
    the victim.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF attacks target application functionality that causes a state change on
    the server, such as changing the victim's email address, password, or various
    other application configuration settings. The adversary does not receive a response
    if the attack was successful, only the victim does. As such, CSRF attacks target
    state-changing configuration requests that are performed in an automated fashion.
    Embedded IoT devices are known to be susceptible to CSRF attacks due to hardware
    computational complexities of keeping the state of anti-CSRF tokens. Although
    there are preventative design patterns that do not require a server-side state
    but instead the app validates HTTP referrers and origin headers, these are not
    effective solutions.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF attacks have been used in a number malware that target IoT devices and
    SOHO routers to reroute the victim's traffic to DNS servers controlled by attackers
    for control over internet traffic as well as DDoS attacks. A couple of these malware
    strands are known as SOHO Pharming ([https://www.team-cymru.com/ReadingRoom/Whitepapers/2013/TeamCymruSOHOPharming.pdf](https://www.team-cymru.com/ReadingRoom/Whitepapers/2013/TeamCymruSOHOPharming.pdf))
    and DNSChanger ([https://www.proofpoint.com/us/threat-insight/post/home-routers-under-attack-malvertising-windows-android-devices](https://www.proofpoint.com/us/threat-insight/post/home-routers-under-attack-malvertising-windows-android-devices)).
    In this recipe, we will demonstrate how to exploit CSRF on a target device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To exploit CSRF, we will use Burp Suite and a vulnerable IHOMECAM ICAM-608 IP
    camera.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first step in discovering whether an application is vulnerable to CSRF
    is observing the request parameter and HTML form values that change the application
    state. If there is not a randomized token sent with each parameter or a hardcoded
    token in the HTML form chances are the application is vulnerable to CSRF. We want
    to look at either changing sensitive configurations that will benefit us as attackers
    or a form of persistence to the device, such as adding users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the target IP camera''s user settings configuration page
    and its source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3984ef0-4e53-46a7-942a-412868599cce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The source of the user settings page looks like it doesn''t contain anti-CSRF
    tokens and blindly inputs parameters into the URL of the page without any validations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1395fc52-c7e4-445a-8165-f89f2ea70382.png)'
  prefs: []
  type: TYPE_IMG
- en: We can now create a **proof of concept** (**PoC**) CSRF HTML page that creates
    three users on behalf of the victim.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to right click the vulnerable HTTP request and select Generate
    CSRF PoC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/601612c0-ec5c-44db-9a52-01dff3d5937d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Burp Suite creates a PoC HTML page we can weaponize and tailor to our needs.
    Our next step is to change the admin user settings and add two new users by hardcoding
    input values. In the following screenshot, we have added `IoTCookbookUserAdmin`,
    `IoTCookbookUser1`, and `IoTCookbookUser2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e9caa619-1b80-42e5-85c0-2db77dcf97da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Test in browser, which pops up the following box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e3770d3b-7f60-4550-8c1a-60eeadb1f90c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Copy the link into your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a59cd1cc-5f91-49d1-80aa-7a366df75908.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the link is run in your browser, observe the request sent to Burp Suite''s
    proxy HTTP history that contains the hardcoded input values we used in our PoC
    HTML page adding the users to the IP camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fdd8e5e9-480f-483f-8757-e04d1457bcb8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Refresh the user settings page of the IP camera to see the changes made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d4a50a84-d353-451f-a126-1c72ff833d81.png)'
  prefs: []
  type: TYPE_IMG
- en: Similar tactics and techniques based upon the aforementioned malware can be
    utilized when sending the CSRF PoC page victims. Administrator and user accounts
    will be created in an automated manner, allowing attackers to make unauthorized
    changed on behalf of the victim user.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For additional guidance on reviewing code for CSRF vulnerabilities as well as
    finding and preventing CSRF, refer to the OWASP's CSRF wiki page [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
