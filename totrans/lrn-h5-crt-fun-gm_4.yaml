- en: Chapter 4. Using HTML5 to Catch a Snake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the first part of a two-part series, where we'll build the first
    version of a game, and then spice it up with more HTML5 APIs in the next chapter.
    Both versions will be complete and playable, but since covering all of the APIs
    in the same game within one chapter would make for a very large chapter, we'll
    break things up into smaller chunks, and write two separate games.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of the game will cover five new concepts, namely, **HTML5's
    2D canvas API**, **offline application cache**, **web workers**, **typed arrays**,
    and **requestAnimationFrame**. The canvas element allows us to draw 2D as well
    as 3D graphics, and manipulate image data at a very low level, gaining access
    to individual pixel information. Offline application cache, also known as app
    cache, allows us to cache specific assets from a server into the user's browser,
    so that the application can work even when no internet access is available. Web
    workers is a thread-like mechanism that allows us to execute JavaScript code in
    a separate thread from the main UI thread. This way, the user interface is never
    blocked, and users don't see a **page not responsive** warning. `Typed arrays`
    is a new native JavaScript data type similar to arrays, but much more efficient,
    and specifically designed to handle binary data. Finally, requestAnimationFrame
    is an API offered by the browser to help us perform time-based animation. Instead
    of using a JavaScript timer (`setTimeout` or `setInterval`) multiple times a second
    in order to perform animations, we can let the browser do the heavy lifting, optimizing
    the animation beyond what we could achieve in JavaScript alone.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve certainly seen or played this game before. You control a snake in a
    2D grid only moving up, down, left, or right. When you change the direction in
    which the snake''s head is moving, each part of the snake''s body gradually changes
    direction as well, following the head. If you run into a wall, or into the snake''s
    own body, you lose. If you guide the snake''s head over a fruit, the snake''s
    body gets larger. The larger the snake gets, the more challenging the game becomes.
    Additionally, the speed at which the snake moves can be increased for an extra
    challenge. In order to stay true to the old school nature of this classic game,
    we opted for old school graphics and typefaces, as shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The game](img/6029OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image shows the look and feel of the game. When the game first starts, the
    snake has a total body length of zero—only the head is present. At first, the
    snake is randomly placed somewhere within the game grid, and is not given a starting
    direction to move towards. The player can control the snake with the arrow keys,
    and once the snake starts moving in a particular direction, the snake cannot be
    stopped. For example, if the snake is moving to the right, the player can move
    it up or down (but not backwards). If the player wishes to move the snake to the
    left (once it is currently moving to the right), the only possible ways are to
    first move the snake up, then to the left, or down, then left.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there are no fruits on the game grid, one is randomly added to the
    grid. That fruit stays there until the player eats it, at which point, a new fruit
    is added to the grid. For added difficulty, we could make a fruit disappear, if
    the snake can't get to it within so many seconds.
  prefs: []
  type: TYPE_NORMAL
- en: API usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A general description and demonstration of each of the APIs used in the game
    are given as follows. For an explanation of how each of the functionality was
    incorporated into the final game, look at the following code section. For the
    complete source code for this game, check out the book's page at the Packt Publishing
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Before `requestAnimationFrame` was introduced, the main method developers used
    to create animations in JavaScript was by using a timer to repeatedly call a function
    that gradually updated attributes of the element(s) being animated. While this
    is a straightforward method, what the browser provides through `requestAnimationFrame`
    has a couple of added benefits. First of all, the browser uses a single animation
    cycle to handle the rendering of a page, so any rendering we do using that same
    cycle will result in a smoother animation, since the browser can optimize the
    animation for us. Also, since the rendering would be done by the browser's internal
    rendering mechanism, our animation would not run when the browser tab running
    our animation is not shown. This way we don't waste battery life animating something
    that is not even visible.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `requestAnimationFrame` is very simple, and similar to `setTimeout`. We
    call the `requestAnimationFrame` function on the global window object, passing
    a callback function that is executed whenever the browser is ready to run another
    animation cycle. When the callback is invoked, it is passed in a timestamp, which
    is normally used inside the animation function we register with `requestAnimationFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways in which `requestAnimationFrame` is used, both of
    which achieve the same result. In the first method, you define your animation
    function with no references to `requestAnimationFrame`. Then, a second function
    calls that animation function, followed by a call to `requestAnimationFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second pattern that is commonly used is very similar, except that it only
    includes the main animation function. That function itself takes care of calling
    `requestAnimationFrame` when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The reason that the time argument is useful is, because most of the time, you
    want the animation to run more or less at the same rate on different computers.
    `requestAnimationFrame` attempts to run as close to 60 times per second as possible.
    However, based on the code you execute inside it, that rate may drop significantly.
    Obviously, faster hardware would be able to execute your code much faster, and
    thus, display it to the screen more often than some slower hardware would. In
    order to make up for this possibility, we can use actual time to control how often
    the animation code runs. This way, we can specify a cap refresh rate, which, if
    a particular computer is able to run faster than this rate, can simply slowdown
    that computer, and all users experience about the same animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible implementation of this technique is shown in the following steps.
    Although it may seem like a lot of steps, the concept is really quite simple.
    The gist of it is this: we set two variables, one that keeps track of the cap
    speed that the animation will run (measured in **frames per second** (**fps**)),
    and the other keeps track of when the last time was, that a frame was rendered.
    Then, whenever the animation function executes, we take the current time, subtract
    the last time that a frame was rendered, and check if their difference is greater
    than, or equal to the ideal fps we have chosen. If it is less than our desired
    fps, we don''t animate anything, but still register `requestAnimationFrame` to
    call us back in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: This we do until enough time has elapsed so that our frames per second rate
    can be achieved (in other words, so that the fastest frame rate we can possibly
    run would be our fps). If the system is running slower than that, there's nothing
    we can do about it. What this technique does is control the maximum speed.
  prefs: []
  type: TYPE_NORMAL
- en: Once `requestAnimationFrame` has called our animation function, and enough time
    has passed since the last time a frame was rendered, we update all the data we
    need to, for the animation, render the animation to the screen (or let the browser
    do it, if it can), and update the variable that keeps track of when a frame was
    last updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This simple code snippet creates a **Document Object Model** (**DOM**) element,
    sets some text to it, and registers an onclick handler to it. When the click handler
    is called, we reset some styling properties of the element (namely, placing the
    element on the far left side of the screen), and get the animation routine started.
    The animation routine moves the element to the right a little bit every frame,
    until the element has reached the right side of the screen. If the element has
    not yet reached the right side of the screen, or in other words, if the animation
    is not yet completed, we perform the animation (move the element a few pixels),
    then register itself with `requestAnimationFrame`, thus continuing the cycle.
    Once the animation is complete, we simply stop calling `requestAnimationFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: A key point to remember is that, one of the major optimizations that the browser
    does with `requestAnimationFrame` is to only call it when there is anything to
    render (in other words, when the tab holding the page is active relative to other
    tabs). Thus, if the user switches tabs while the animation is in progress, the
    animation will be paused until the tab is selected again.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, what we ought to do is have `requestAnimationFrame` call the
    code that handles the rendering of the game, but not the code that updates the
    game state. This way, even if the browser is not rendering, the values related
    to the animation still get animated, but we don't waste CPU and GPU power, rendering
    something not visible. But as soon as the browser tab becomes active again, the
    latest data state will be rendered, as if it had been rendering the whole time.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is especially useful for games, as we may not want the entire
    game to pause when a user switches browser tabs. Then again, we can always benefit
    from saving the user's battery, which we can achieve by not rendering data to
    the screen when we don't need to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that `requestAnimationFrame` will, by definition, cap the frame
    rate of your animation loop to the refreshing rate of the monitor. Thus, `requestAnimationFrame`
    is not intended to replace native timer implementations, particularly in cases
    when we'd like the callback function to be invoked at a rate independent from,
    and possibly higher than a monitor's refresh rate.
  prefs: []
  type: TYPE_NORMAL
- en: Typed arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, JavaScript engines have become amazingly faster. However, simply
    being able to process data faster doesn't necessarily equate to being able to
    do more powerful things. Take WebGL, for example. Just because the browser now
    has the ability to understand OpenGL ES, it doesn't necessarily mean that it has
    all the tools we developers need to take advantage of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that the JavaScript language has also made some progress in
    order to satisfy this, and other needs that have come about. One such addition
    to JavaScript in recent years is a new data type: typed arrays. In general, typed
    arrays offer a structure similar to the array type already in JavaScript. However,
    these new arrays are much more efficient, and were designed with binary data in
    mind.'
  prefs: []
  type: TYPE_NORMAL
- en: Why and how are typed arrays more efficient than regular arrays, you ask? Well,
    let's look at a trivial example, where all we do is traverse an array of integers
    the old way. Although most JavaScript engines don't particularly struggle to get
    this task done fairly fast, let us not overlook all the work the engine needs
    to do in order to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since JavaScript is not strongly typed, the array `nums` is not restricted to
    holding data of any particular type. Furthermore, the `nums` array can store a
    different data type for each element in it. While this can sometimes be convenient
    for a programmer, the JavaScript engine needs to figure out where each element
    is stored, and what data type is being stored at said location. Contrary to what
    you may think, those five elements in the `nums` array may not be stored in a
    contiguous piece of memory, because, well, that's how JavaScript does it.
  prefs: []
  type: TYPE_NORMAL
- en: With typed arrays, on the other hand, each element in the array can only be
    an `integer` or a `float`. Based on the type of array we choose, we can have a
    different type of `integer` or `float` (`signed`, `unsigned`, 8, 16, or 32 bits),
    but every element in the array is always the same data type we decide to use (integer
    or float). This way, the browser knows precisely and instantly, where in memory
    element `nums[3]` is found which is at memory address `nums + 3`. This can be
    done because typed arrays are stored in a continuous chunk of memory, much like
    it does in array structures in C and C++ (which, by the way, is the language used
    to implement most, if not all JavaScript engines).
  prefs: []
  type: TYPE_NORMAL
- en: The major use case for typed arrays is, as hinted earlier, WebGL (which we'll
    cover in [Chapter 6](ch06.html "Chapter 6. Adding Features to Your Game"), *Adding
    Features to Your Game*). In WebGL, where we can perform 3D rendering right from
    JavaScript, we may need to process `integer` buffers, over a million elements
    long. These buffers can be used to represent a 3D model that we wish to draw to
    the screen. Now, imagine how long it would take for the browser to iterate through
    one such array. For each and every element, it would have to follow a memory location,
    check the value at that location, make sure the value is a number, attempt to
    convert the value into a number, and then finally use that value. Sounds like
    a lot of work? Well, that's because it is. With typed arrays, it can just run
    through that array as fast as it can, knowing that each element is indeed a number,
    and knowing exactly how much memory each element takes, so that jumping to the
    next memory address is a consistent and predictable process.
  prefs: []
  type: TYPE_NORMAL
- en: Typed arrays are also used in the 2D canvas context. As we'll see in the canvas
    API section later in the chapter, there is a way that we can get the pixel data
    from whatever is drawn into a canvas. All that this pixel data is, is a long array
    of 8bits clamped `unsigned integers`. What that means is that each element in
    this array can only be an `integer` value between 0 and 255, which is precisely
    what the acceptable values are for a pixel.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using typed arrays is really simple. It may be easier to understand how they
    work if you have at least some experience with C or C++. The easiest way to create
    a typed array is to declare our array variable, and assign it an instance of a
    particular typed array type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we have created an instance of an `integer` array, where each
    element can be either positive or negative (`signed`). Each element will be stored
    as a 32 bits number. The `integer` argument that we pass in, indicates the size
    of the array. Once this array is created, its size cannot be changed. Any values
    assigned to it outside its bounds are silently ignored by the browser, as well
    as any illegal values.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the restrictions on what can be stored in this special array, it
    all may seem just as an ordinary JavaScript array to the untrained eye. But if
    we look a bit deeper into it, we'll notice a couple more distinctions between
    an array and a typed array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we notice is that the array is indeed an `Int32Array`, and
    not an Array. Next, we''re happy to know that the length property is still there.
    So far so good. Then, things start to separate, as simple methods associated with
    regular arrays are no longer present. Not only that, but there''s also a new attribute
    in the typed array object named `buffer`. This buffer object is of type `ArrayBuffer`,
    which has a `byteLength` property. In this case, we can see that the buffer''s
    length is `40`. It''s easy to see where this `40` came from: `buffer` holds 10
    elements (`typedArr.length`), and each element is 32 bits long (4 bytes), for
    a total of `40` bytes in the `ArrayBuffer` (hence the property name of `byteLength`).'
  prefs: []
  type: TYPE_NORMAL
- en: Since typed arrays don't come with helper functions such as regular JavaScript
    arrays do, we read and write data to them using the old array notation, where
    we index into the array in order to read or write a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, just to reinforce the fact that no helper functions or shortcuts related
    to ordinary JavaScript arrays work with typed arrays, notice that an attempt to
    access an element without providing an index will provide an exception being thrown
    by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: ArrayBuffer and ArrayBufferView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although, all the previous examples used a specific kind of typed array directly,
    the way that typed arrays work is slightly more involved than that. The implementation
    is broken down into two separate parts, namely, an array buffer and a view (or
    more specifically, an array buffer view). The array buffer is simply a chunk of
    memory that is allocated, so we can store our data there. The thing about this
    buffer is that it has no type associated with it, so we can't access that memory
    to store data to, or read data from it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to be able to use the memory space allocated by the array buffer, we
    need a view. Although the base type for this view is `ArrayBufferView`, we actually
    need a subclass of `ArrayBufferView`, which defines a specific type to the data
    stored in the array buffer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here's where things can get a bit confusing. The array buffer works in terms
    of bytes. As a refresher, a byte is made up of 8 bits. A bit is a single binary
    digit, which can have a value of either zero or one. This is how data is represented
    at its most basic format in computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if a buffer works in terms of bytes, when we created our buffer in the
    example, we created a block of `32` bytes. The view that we create to hold and
    use the buffer can be one of nine possible types, each of which specifies a different
    data size (in terms of bits, not bytes). Thus, a view of type `Int32` represents
    a buffer where each element is an `integer`, 32 bits long. In other words, a 32
    bits view can hold exactly 8 bytes (1 byte = 8 bits; 32 bits = 8 bytes), as illustrated
    in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ArrayBuffer and ArrayBufferView](img/6029OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Array buffers work in terms of bytes. In the image, there are 4 bytes, although
    view types work in terms of bits. Thus, if we use a 32 bits view, it will result
    in an array that has a length of exactly one element. If the view uses a 16 bits
    data type, then the array will have 2 elements (4 bytes divided by 16 bits). Finally,
    if the view uses an 8 bits data type, the array stored in the 4 bytes buffer will
    have 4 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important thing to always remember is that when you create an array buffer,
    the length you choose to make the buffer must divide perfectly into however large
    you make the array buffer view. If there is not enough room in the buffer to fit
    entire bytes, the JavaScript will throw an error of type `RangeError`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following image, the buffer is only big enough for 8 bits, all of which
    must be occupied by whole bytes. Thus, a view is an 8 bits number which would
    fit exactly one whole element, which would be fine. A 16 bits element would only
    fit half of an element, which is not possible. A 32 bits element would likewise
    only fit a portion of it, which is also not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '![ArrayBuffer and ArrayBufferView](img/6029OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, as long as the array buffer has a bit length that is a multiple
    of the bit size of the data type used in the view, things work out fine. If the
    view is 8 bits long, then an array buffer of 8, 16, 24, 32, or 40, would work
    out fine. If the view is 32 bits long, then the buffer must be at least 4 bytes
    long (32 bits), 8 bytes (64 bits), 24 bytes (96 bits), and so on. Then, by dividing
    the amount of bytes in the buffer by the amount of bytes in the data type represented
    by the view, we can calculate the total number of elements that we can fit in
    said array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Typed array view types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a summary, a plain old array buffer has no actual size. Although it wouldn't
    make sense to create an array buffer of a byte length of say 5 bytes, we are more
    than welcome to do so. Only after the array buffer is created can we create a
    view to hold the buffer. Based on the byte size of the buffer, we can determine
    how many elements the array buffer view can access by selecting an appropriate
    data type. Currently, there are nine data types that we can choose from for the
    array buffer view.
  prefs: []
  type: TYPE_NORMAL
- en: '**Int8Array**: It is a `signed integer`, 8 bits long, ranging from 32,768 to
    32,767'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint8Array**: It is an `unsigned integer`, 8 bits long, ranging from 0 to
    65,535'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint8ClampedArray**: It is an `unsigned integer`, 8 bits long, ranging from
    0 to 255'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int16Array**: It is a `signed integer`, 16 bits long, ranging from 2,147,483,648
    to 2,147,483,647'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint16Array**: It is an `unsigned integer`, 16 bits long, ranging from 0
    to 4,294,967,295'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int32Array**: It is a `signed integer`, 32 bits long, ranging from 9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint32Array**: It is an `unsigned integer`, 32 bits long, ranging from 0
    to 18,446,744,073,709,551,615'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float32Array**: It is a `signed float`, 32 bits long, with a range of 3.4E
    +/- 38 (7 digits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float64Array**: It is a `signed float`, 64 bits long, with a range of 1.7E
    +/- 308 (15 digits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It goes without saying that the larger the view type, the larger the buffer
    will need to be to hold the data. Obviously, it follows that the larger the buffer
    you create, the more memory the browser will need to set aside for you, whether
    or not you end up using that memory. Thus, we should always pay attention to how
    much memory we might actually need, and try to allocate no more than that. It
    would be an awesome waste of resources to allocate an array of 10,000 elements,
    each of which are 64 bits long, just to represent a snake in a game, such as the
    one that we're building in the chapter, where the maximum snake size might be
    no larger than 50 or so elements, and where each element needs not hold a value
    larger than say 10.
  prefs: []
  type: TYPE_NORMAL
- en: Given such constraints, we could calculate a rough, yet optimistic array size
    of 50, where each element only needs 8 bits (since we'll only need around 10 unique
    values). Thus, 50 elements times one byte each, gives us a total buffer size of
    50 bytes. This should be more than enough for our purposes, while the memory consumption
    for this buffer alone should stay around 0.05 KB. Not bad.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may have noticed, the first part of this section demonstrated typed
    array creation without using the `ArrayBuffer` construct explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: While the two typed arrays above, refer to two separate and unique memory locations,
    they are identical at run time, and cannot be told apart (unless the actual arrays
    hold different values, of course); the point here being that an array buffer view
    constructor can take an `ArrayBuffer`, or simply an `integer`. If you use an `ArrayBuffer`,
    all of the restrictions just mentioned apply, and must be handled with care. If
    you only supply an `integer`, the browser will create an array buffer of the appropriate
    size for you automatically. In practice, there are rare occasions and reasons,
    where you'd want to manually create an array buffer separately. It is noteworthy,
    however, that it is totally legal to create multiple array buffer views for the
    same array buffer, even if each view is of a different data type. Remember that,
    since the buffer refers to a single memory location, so all views bound to the
    same buffer are sharing that memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps no other HTML5 feature is as powerful as the canvas API with regards
    to game development for the web platform. Although we may have every other feature
    currently in the specification, as well as any forthcoming feature that the browser
    can possibly support, it would be nearly impossible to produce a high quality,
    engaging, fun game using HTML and JavaScript. The canvas API allows us to create
    2D, as well as 3D graphics right on the browser. It also lets us manipulate the
    graphical data stored in the canvas context, down to the individual pixel level.
  prefs: []
  type: TYPE_NORMAL
- en: One major difference between a canvas graphic and an SVG graphic, apart from
    the fact that SVG graphics are vector-based, and canvas graphics are always raster
    graphics, is that the canvas is a single HTML element, and everything drawn in
    it is, for all practical purposes, non-existent to the browser. Thus, any event
    handling on individual entities drawn on a canvas must be handled at the application
    level. There are generic events on the canvas that we can observe and respond
    to, such as clicks, move events, and keyboard events. Beyond that, we are free
    to do as we please.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the shape-based drawing that we can do on an HTML5 canvas, there are
    three major use cases for the API. We can create 2D, sprite-based games, full-blown
    3D games (using WebGL with the help of the canvas), and manipulating photographs.
    The last use case mentioned: photo manipulation, is especially interesting. The
    API has a very handy function that allows us to not only export the data in the
    canvas as a PNG or JPG image, but it also supports various types of compression.
    That means, we can draw on a canvas, load graphics on it (for example photographs),
    manipulate that data at a pixel level (for example apply Photoshop-like filters
    to it), rotate, stretch, scale, and otherwise, play with the data. Then, the API
    allows us to export that data as a compressed file that can be saved to the file
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we'll focus on the aspects of the canvas API
    that we can best use for game development. Although WebGL is a very exciting aspect
    of the canvas element, but we will cover a very basic introduction to it in [Chapter
    6](ch06.html "Chapter 6. Adding Features to Your Game"), *Adding Features to Your
    Game*. For other capabilities available on the canvas API, we will cover them
    briefly with a few examples in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to understand about the canvas element is that there
    are two parts to it. One is the physical canvas element, and the other is the
    rendering context through which we can draw to the canvas. As of this writing,
    there are two rendering contexts that we can use in modern browsers, namely, `CanvasRenderingContext2D`
    and `WebGLRenderingContext`.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a reference to the rendering context of a canvas, we call a `factory`
    method on the canvas element itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the use of a fallback context is aimed at the prefixed `experimentalwebgl`
    context. As of this writing, most browsers that support WebGL will do so through
    the experimental tag.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the section will relate exclusively to the `CanvasRenderingContext2D`
    API. While it is technically possible to do everything that the 2D canvas context
    can, using the 3D canvas context of WebGL, the only thing that these two APIs
    have in common is their link to the HTML5 canvas element. WebGL is an entire programming
    language in and of itself, and a single chapter dedicated to it would not be enough
    to even scratch the surface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, a very important aspect of the 2D rendering context is its coordinate space.
    Similar to most coordinate system in computers, the origin is located at the top
    left corner of the canvas. The horizontal axis increases to the right, while the
    vertical axis increases downwards. The size of the grid held in memory to represent
    the canvas is determined by the physical size of the canvas that generates the
    rendering context, and not the styled size of the canvas. This is a key principle
    that can't be emphasized enough. By default, a canvas is 300 x 150 pixels. Even
    if we resize the canvas through **Cascading Style Sheets** (**CSS**), the rendering
    context that it generates will be that size (unless we physically resize the canvas,
    of course). Once the rendering context has been created, it cannot be resized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![How to use it](img/6029OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The border was added in order to make the canvas somewhat visible to us, as
    by default, the canvas is transparent.
  prefs: []
  type: TYPE_NORMAL
- en: You will observe that the CSS rule is indeed applied to the canvas element,
    even though the canvas' real size is still the default 300 x 150 pixels. If we
    were to draw a circle in the middle of that canvas, the circle would seem distorted,
    because the actual coordinate space where the circle is actually drawn, would
    be stretched by the styling applied to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: clearRect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first drawing function we'll look at is `clearRect`. All that this function
    does is, clear a rectangular area of the canvas. This function is called on the
    context object, as do all drawing calls that we'll be making on the 2D canvas.
    The four parameters it takes, represent, in order, the x and y offset from the
    canvas' origin, plus a width and a height distance to clear. Keep in mind that
    unlike other popular drawing APIs in other programming languages, the last two
    parameters are not measured from the origin—they are displacement distances from
    the point specified by the first two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Normally, when rendering many frames every second, we'd be calling this function
    to clear out the entire canvas before drawing the next frame. Luckily, in most
    JavaScript engines, this function performs fairly well; so that we don't need
    to worry too much about optimizing the precise area to clear out on a regular
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: Fill and stroke
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When drawing native objects such as lines, paths, text, and other shapes, we'll
    deal with the concept of strokes and fills; just as in SVG, a stroke refers to
    the outline of a primitive (such as a border or sorts), and the fill is the content
    that covers the inside of the shape.
  prefs: []
  type: TYPE_NORMAL
- en: The way we can change the color that is used to fill a shape, or the color used
    to stroke the shape, is by assigning any color to the `fillStyle` or `strokeStyle`
    properties. The color can be any string valid for a CSS color.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Fill and stroke](img/6029OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any valid CSS color string can be assigned to color properties in the 2D rendering
    context, including colors with opacity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pay special attention to the fact that the rendering context acts much like
    a state machine. Once you set a fill or stroke style, as well as any other property,
    that property will maintain that value until you change it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that each subsequent drawing call that you issue, draws on top of
    whatever is already on the canvas. Thus, we can layer shapes and images by carefully
    arranging the drawing calls in just the right order.
  prefs: []
  type: TYPE_NORMAL
- en: Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing lines is as easy as calling the function `lineTo`, which only takes
    two parameters, indicating the point where the line is going to. Subsequent calls
    to `lineTo` will draw a line to the point specified by the function call, starting
    the line at the last point where the line was. More specifically, the line starts
    where the current drawing pointer is.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the pointer is not defined anywhere, so drawing a line to some other
    point makes little sense. To help with that, we can make use of the function `moveTo`,
    which moves the drawing pointer without drawing anything.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, any calls to `lineTo` only set the points in memory. In order to eventually
    draw the line, we need to make a quick call to the stroke function. Once this
    call is made, whatever attributes are currently set (such as line width and stroke
    style), will be drawn. Thus, changing line properties before actually stroking
    the line does little good, and can negatively influence performance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Lines](img/6029OT_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shapes are only drawn after the call to stroke(), at which point the current
    style attributes are used.
  prefs: []
  type: TYPE_NORMAL
- en: Shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a couple of different shapes we can draw very effortlessly. These
    are rectangles and circles. While, there is no circle function as there is a `rect`
    function for drawing rectangles. There is, however, an `arc` function, from which
    we can draw circles.
  prefs: []
  type: TYPE_NORMAL
- en: The `rect` function takes four parameters, exactly as `fillRect`. `arc` takes
    an x and a y coordinate, followed by a radius, a starting angle (in radians, not
    degrees), an ending angle, and a Boolean, specifying, if the arc is to be drawn
    clockwise. To draw a circle, we can just draw an arc that goes from 0 to PI times
    2, which is the same as 360 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Shapes](img/6029OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Arcs (including circles) are drawn from their center and not from some point
    on their outline.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Drawing text on an HTML5 canvas is also pretty straightforward. The function
    `fillText` takes a string (the text to be drawn), and an x and y coordinate, where
    the text begins to draw. Additionally, we can style the text the same way that
    text can be styled through CSS. This can be done by setting the text style property
    string to the font attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Transformations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The canvas API also defines a few transformation functions that allow us to
    translate, scale, and rotate the context's coordinate system. After transforming
    the coordinate system, we can draw onto the canvas just as we normally would,
    and the transformations would apply.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Rotation and scaling also works the same way. The `scale` function takes a value
    to scale the coordinate system by, on each axis. The `rotation` function takes
    a single parameter, which is the angle (in radian) to rotate the coordinate system
    by.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Transformations](img/6029OT_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With transformations, order is very important.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most exciting and useful feature of the 2D canvas API from a game
    development perspective, is its ability to draw images onto it. Thankfully, for
    us, there are several ways to draw a regular JPG, GIF, or PNG image right on the
    canvas, including functions that handle scaling images from source to destination.
  prefs: []
  type: TYPE_NORMAL
- en: One other note that we need to make about the canvas element is that it follows
    the same origin policy. That means, in order for us to be able to draw an image
    onto a canvas context, the script attempting to draw the image must be served
    from the same domain (along with the same protocol and port number) as the image.
    Any attempt to load an image from a different domain into the canvas context and
    the browser will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest call to draw an image only takes five parameters. The first is
    a reference to an image. The next two parameters are the x and y position where
    that image will be drawn onto the canvas, and the last two parameters are the
    width and height to paint the image onto the canvas. If the last two parameters
    don''t maintain the aspect ratio of the original image, the result will be distortion,
    rather than clipping. Also, note that, if the original image is larger than the
    canvas, or if the image is drawn from an offset such that part of the image runs
    off the canvas, that extra data will simply not be drawn (obviously), and the
    canvas will just ignore those pixels outside the viewable area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing images](img/6029OT_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The HTML5 logo drawn inside a canvas rendering context.
  prefs: []
  type: TYPE_NORMAL
- en: A very important observation is that if the browser has not yet finished downloading
    the image resource from the server by the time the call is made to `drawImage`,
    the canvas will simply not draw anything, since the image passed to be drawn onto
    it has not loaded yet. In the case where we draw the same image onto the canvas
    multiple times per second using a game loop of some sort, this is not really a
    problem, because whenever the image finally loads, the next pass through the game
    loop will successfully draw the image. However, in cases where the call to draw
    the image is only done once (as in the example above), we only get one chance
    to draw the image. Thus, it is very important that we don't make that call until
    the image is in fact loaded into memory, and ready to be drawn into the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In order to ensure that the call to draw the image into the canvas only happens
    after the image has been fully downloaded from the server, we can simply register
    a callback function on the load event of the image. This way, as soon as the image
    is done downloading, the browser can fire that callback, and the call can finally
    be made to draw the image. This way, we can be sure that the image will indeed
    be ready by the time we want to have it rendered in the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another version of the same function, which takes into account,
    scaling from source to destination. In the case above, the source image is larger
    than the canvas. Instead of resizing the image using a photo editing software
    program, we can instead tell the canvas to draw the whole image into a smaller
    area of the canvas. The scaling is done by the canvas automatically. We could
    also draw the image into a larger area than the image itself, but doing so will
    result in pixilation depending on how much we scale the image.
  prefs: []
  type: TYPE_NORMAL
- en: The parameters for this function are the source image, the source x and y coordinates
    (in other words, where to start sampling the source image relative to the image
    itself), the source width and height (in other words, how much to sample the source
    image), and the destination x and y, followed by width and height.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Drawing images](img/6029OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Part of the HTML5 logo drawn inside a canvas rendering context, with some intentional
    stretching.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating pixels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to draw images into a canvas, let's take things to the
    next step, and work with the individual pixels drawn in the canvas. There are
    two functions that we can use in order to accomplish this. One function allows
    us to retrieve the pixel data from the canvas context, and the other lets us put
    a pixel buffer back into the canvas context. Additionally, there is a function
    that allows us to retrieve the pixel data as a data URL, meaning, that we can
    save the image data from the canvas right to the user's file system, just as we
    can with a regular image from an `<img />` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To get the pixel data representing whatever is currently drawn in the canvas,
    we can use the function `getImageData`. The four parameters are the x and y offset
    on the source image, along with the width and height to be extracted. Note that
    the output from this function is an object of type `ImageData`, which has three
    attributes, namely, width, height, and a typed array with the actual pixel information.
    As mentioned earlier in the chapter, this typed array is of type `Uint8ClampedArray`,
    where each element can only be an `integer` with a value between 0 and 255 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: The pixel data is a buffer of length (`canvas.width x canvas.height x 4`). That
    is, each four elements represent one pixel, representing the red, green, blue,
    and alpha channels of the pixel in this order. Thus, in order to manipulate an
    image through this canvas API, we perform various calculations on this pixel buffer,
    which we can then put back in the canvas using the `putImageData` function.
  prefs: []
  type: TYPE_NORMAL
- en: The three parameters of `putImageData` are the `ImageData` object, along with
    the x and y offset on the destination canvas. From there, the canvas will render
    the image data as far as it can, clipping any extra data that would otherwise
    be drawn outside the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of what we can do with an image, we'll take the HTML5 logo that
    we drew into the canvas, and apply a gray scale function to the pixel data representing
    it. If this sounds like a complex task, fear not. While there are several different
    formulas to turn a color image into gray scale, the easiest way to do this is
    to simply average the red, green, and blue values of each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Manipulating pixels](img/6029OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating an image is no more complex than performing various calculations
    on each pixel of the pixel buffer that represents an image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the way we can export the image from a canvas is as simple as calling
    the `toDataURL` function. Make a special note that this function is called on
    the canvas object, and not on the rendering context object. The `toDataURL` function
    of the canvas object takes two optional parameters, namely, a string representing
    the MIME type of the output image, and a `float` between `0.0` and `1.0`, representing
    the quality of the output image. If the output image type is anything other than
    `"image/jpeg"`, the quality parameter is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web workers bring the ability to execute code outside the main UI thread. This
    thread-like behavior allows us to perform long lasting tasks without blocking
    the user interface. When a JavaScript task takes too long to complete, the browser
    displays an alert to the user, letting the user know that the page is not responsive.
    Using web workers, we can solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few restrictions with web workers that we need to keep in mind.
    First, workers run outside the DOM, so any functionality related to that is not
    available inside worker threads. Also, there is no concept of shared memory with
    workers—any data that is passed to and from a worker is copied into its own memory
    space. Finally, any objects passed to and from a worker can contain any data types,
    except for functions. If you attempt to pass a function to or from a worker (or
    an object holding a reference to a function), the browser will throw a **DataCloneError**
    (DOM Exception 25).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, workers are completely capable of firing XHR requests (Ajax
    calls), starting other workers, and stopping other workers, including themselves.
    Once a worker is terminated, it can no longer be started, similar to other threading
    constructs available in other languages such as Java.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll create a sample mini application that generates prime
    numbers in a worker thread. The user can input a number into the application,
    and the application will return a list of primes up to that number. Those prime
    numbers will then be passed back to the main application, which will then list
    the prime numbers back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with web workers, we must first create a separate JavaScript
    file that will be run in the worker thread. The way this script will communicate
    with its parent thread is through messages. In order to receive messages from
    a parent thread, the worker needs to register a callback function that is called
    whenever a message is passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function is called when a message is received, both in the worker thread
    and in its parent thread, and a `MessageEvent` object is passed to the function.
    This object contains many attributes, including a timestamp, and most importantly,
    a data attribute, which contains any data passed into the worker.
  prefs: []
  type: TYPE_NORMAL
- en: To post a message to a worker or back to its parent, we simply call the function
    `postMessage` on the appropriate object (either the worker object, or on the self-object,
    if inside a worker), passing the data along with the function call. This data
    can be a single value, an array, or an object of any type, as long as no functions
    are included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to create a `worker` object, we simply create an instance of the class
    `Worker`, passing the path to the worker script as a constructor parameter. This
    `worker` object will need to register callback functions for whatever events it
    wants to observe: `onMessage` or `onError`. To kill the worker thread, we can
    either call the `terminate` function directly on the worker object, or the `close`
    function on the worker script.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above snippet, we set up two things: a worker and an input field. We
    then set up a `keydown` listener on the input field, which we use so the user
    can input a number to send to the worker. To send this number to the worker, the
    user must press the **Enter** key. When that happens, the number in the input
    field will be the highest possible prime number generated by the worker. If the
    user inputs the number `-1`, the worker is terminated, and the input field is
    removed from the DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the worker thread will use the **Sieve of Eratosthenes** to
    find the primes. Keep in mind that this exercise is only a proof of concept to
    illustrate how web workers work, and not a lesson on advanced mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![How to use it](img/6029OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The worker can be invoked an infinite amount of times, as long as it is not
    terminated. Once terminated, the worker can be deleted, as it serves no useful
    purpose from that point on.
  prefs: []
  type: TYPE_NORMAL
- en: Offline application cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Offline application cache is a way to store assets on the browser for use when
    the user is not connected to the internet. This API further breaks down any barriers
    between a native application and a web application, since it does away with the
    major characteristic that sets a web application apart from a native one—the need
    for a connection to the World Wide Web. Although the user will obviously still
    need to be connected to the network at some point, so the application can be downloaded
    initially; after that, the application can run completely from the user's cache.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the main use case for offline application cache is when the user's
    connection is not stable, consistent, or simply not on every time the application
    is used. This is especially true with games, as the user may choose to play a
    certain online game some of the time, but offline later on. Similarly, if the
    game needs to connect to a backend server, in order to perform whatever task (such
    as to retrieve new game data), this can be done whenever the user is connected,
    the resources can be again cached locally, and the new data can be used again,
    if and when the user's connectivity becomes unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The backbone of the offline application cache API is the manifest file, which
    specifies to the browser which resources should be cached for offline use, which
    resources must never be cached, and what the browser should do when an attempt
    is made to connect to the server, but no connection is found.
  prefs: []
  type: TYPE_NORMAL
- en: The manifest file is served with the HTML file that the user requests, when
    loading your application. More specifically, the host HTML file specifies the
    path to the manifest file, which the browser then fetches and processes in parallel,
    with the download and processing of the main application. This is done with the
    `manifest` attribute in the root `html` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the above snippet specifies a manifest file named `manifest.appcache`,
    located in the same directory as the HTML file specifying the manifest. The name
    of the file, along with its extension, is completely arbitrary. By convention,
    many developers named the manifest simply `manifest.appcache`, `manifest` (without
    an extension), or `appcache.manifest`. However, this file could very well be named
    `manifest.php?id=2642`, `my-manifest-file.txt`, or `the_file.json`.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to remember is that the manifest file be served with the
    proper MIME type. If the browser attempts to fetch whatever file is listed in
    the `manifest` attribute of the root HTML tag, and the MIME type is not `text/cache-manifest`,
    then the browser will reject the manifest, and no offline application cache will
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to set the MIME type to a file, but generally this is a
    server setting. If using an Apache server, such as the one we are using with WAMP,
    MAMP, or LAMP (see the online chapter, *Setting Up the Environment*), we can easily
    do this with a `.htaccess` file. For example, in the root directory of our project,
    we can create a file named `.htaccess` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This would tell the server to add the right MIME type to any file with an extension
    of `.appcache`. Of course, if you decide to tweak the `htaccess` file to serve
    the `cache-manifest` MIME type to other file extensions, you could possibly run
    into issues if the extension you choose is already associated with other MIME
    types (such as `.json`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of the manifest file must be the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If this line isn''t present again, the entire API will take no effect. If there
    is as much as an extra white space before the string listed above, the browser
    will throw the following error, indicating that the file manifest is invalid,
    and nothing will be cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using offline application cache on your games, make sure to keep an open
    eye on your browser's JavaScript console. If anything goes wrong at all, such
    as finding the manifest file, parsing the manifest, or loading any of the resources
    described in the manifest, the browser will let you know that something went wrong
    by raising an exception, but it will go on. Unlike most fatal JavaScript exceptions,
    a fatal offline application cache exception doesn't stop or influence the execution
    of the script that initiated the caching process. Thus, you may be getting app
    cache exceptions and not know it, so get acquainted with whatever developer tools
    your browser supports, and make good of it.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the manifest can be divided into three main categories, namely,
    assets to be cached, assets to never be cached, and the fallback asset. Comments
    can be placed anywhere within the file, and are denoted by a pound sign. The entire
    line following a pound sign is ignored by the manifest parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By using the wild card under the network section, we indicate that any resource
    not specified under cache, qualified under the network section, meaning that those
    resources are not to be cached. Any attempt to load those resources when network
    access is not available will result in the fallback file being loaded instead.
    This is a good option to let the user know that network access is needed without
    needing to special case any extra code.
  prefs: []
  type: TYPE_NORMAL
- en: Once the manifest is parsed and all the resources are cached, all of the resources
    will remain cached, until the user deletes the offline application cache data
    (or all of the data cached by the browser), or the manifest is changed. Even if
    only a single character changes in the manifest file, the browser will consider
    it to be an update, thus, all of the resources are cached anew. Because of this,
    many developers write a comment line right at the top of the manifest file that,
    among other optional things, they include some sort of version number that identifies
    a unique version of the manifest. This way, if one or more assets changes, we
    can force the browser to re-cache those assets by simply changing the version
    number listed in the manifest file. Remember, the browser will only check the
    text in the manifest file in order to determine if it needs to download new assets.
    If assets change (say, you update JavaScript code listed in the manifest, or some
    graphics, or any other resource), but the manifest text doesn't, those resources
    will not be pulled from the server, and the user will continue to use an outdated
    asset in his or her application, since the assets are loaded only from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way this game was laid out is actually quite simple. The HTML has only
    three widgets: the title of the game, a score board for the player''s current
    score, and a score board for the overall high score across multiple games. This
    last score board is not used in this version of the game, and we''ll get more
    into it in the next game (see [Chapter 5](ch05.html "Chapter 5. Improving the
    Snake Game"), *Improving the Snake Game*).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In order to separate the various responsibilities from all the different components
    in the game, we abstracted out all the rendering for the entire game into a single
    `Renderer` class. This class is in charge of drawing data to a `canvas` reference
    that is given to it. The data that it draws, be it a snake or any other objects,
    is passed in to it as a typed array, representing the coordinates where the entity
    is to be drawn, along with the image resource that is drawn at the location specified
    by the typed array. The `Renderer` class also includes a few helper functions
    to help us easily clear the canvas, and convert an `x` and `y` point into an index
    used to traverse the flat array representing a 2D one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a `Snake` class that encapsulates all of the data and behavior
    associated with the snake. The data that this class stores is the current position
    of the snake's head, the current length of the snake's body, the image that is
    to be drawn representing the snake, and whether the snake is alive or not. The
    behavior that it handles includes the moving of the snake and the handling of
    user input (which is included in this class for simplicity and brevity). There
    are a few helper functions that allow us to delegate other behaviors to the client.
    For example, through the API exposed, the client can check at each frame whether
    the snake has gone outside the world grid, if it has eaten a fruit, or if the
    snake ran into its own body. The client can also use the API provided, to take
    action on the snake, such as setting its life attribute (dead or alive), as well
    as reset the image used to draw the snake, or any other attribute of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `snake` class, we also create a class to encapsulate the fruit
    that the snake will eat. The only difference between the `snake` class and the
    `fruit` class is that the `fruit` class will not do anything other than show up
    in the map. For all practical purposes, the `fruit` class shares a common entity
    interface with the `snake` class, which allows them to be reset to a default state,
    set their position, and check for collision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the main code, we perform the following setup task:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a canvas element and attach it to the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate the `renderer`, `snake`, and `fruit` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a game loop that places a fruit on the grid when one is not present,
    update the snake's position, check where the snake is, and render the game state
    to the canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also use the game loop to hook into the score board widgets, to add to the
    user experience. The complete source code for the game available at the book's
    page on the website of Packt Publishing also includes extra menus, but these have
    been left out of the code snippets shown here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing we take advantage of in this game loop is the `requestAnimationFrame`
    API. In order to assure that different CPUs and GPUs, all render the game at the
    same pace, we added a simple frame rate controller inside the game loop. The frame
    rate is controlled by a variable that specified how many fps the game should attempt
    to run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapter we got started with 2D rendering using the long-awaited canvas
    API. We looked at the various drawing functions available to us through the canvas
    rendering context, which includes drawing simple lines and shapes, drawing images
    from an external image source, pixel manipulation, and image extraction, which
    allows us to save the image from the canvas back to the user's file system.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the new threading system available to us through the web worker
    interface. This allows us to free up the user interface thread, while we perform
    long lasting tasks that would otherwise lock up the interface, and cause the browser
    to display a non-responsive page alert. Unfortunately, there are a few limitations
    to web workers, since there is no shared memory between workers, and no DOM associated
    with, or allowed in a worker thread. Still, much can be done with this magnificent
    new feature of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: The other HTML5 specific API that we covered in the chapter was the offline
    application cache. Through this mechanism, we can save specific assets from a
    web server, storing it as a fast, highly available cache, powered by the user's
    browser. The specific assets that are saved by the browser are specified by a
    manifest file, while it is a simple text-based file, and must be served by the
    server with the `text/cache-manifest` MIME type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at two new additions to the JavaScript language that make
    game development more efficient and exciting. The first of these two features
    is `requestAnimationFrame`, which allows us to render all of our content in a
    single, synchronized call, managed by the browser itself. This is often the best
    way possible to render all of our graphics, since the browser can highly optimize
    the rendering process. The second feature is the typed array data type, which
    allows for much efficient data storage and access. This is especially attractive
    to game development because of the extra boost in performance we can get, just
    by using this new data type, even though it looks and behaves almost 100% the
    same as regular arrays. Thus, writing new code using typed arrays should include
    no learning curve whatsoever, as porting existing code that uses arrays is a real
    treat.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we continue working on the Snake game, making it more robust
    and feature rich. We'll learn about four more HTML5 APIs, namely sessionStorage,
    localStorage, IndexedDB, and web messaging.
  prefs: []
  type: TYPE_NORMAL
