- en: Data Persistence and BaseDataObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus exclusively on the development and testing of the `BaseDataObject`
    ABC (Abstract Base Class), which we'll need in both the `hms_artisan` (**Artisan
    Application**) and `hms_gateway` (**Artisan Gateway** service) component projects.
    It is possible that the `hms_co` (**Central Office Application**) code base will
    also need to utilize the same functionality. We'll look at that in some depth
    later, while working through the `hms_co` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At present, we''re expecting `BaseDataObject` to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5ea73312-a111-454d-8888-4ee6220ffe0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The story that drives the design and implementation of the `BaseDataObject` that
    was described earlier is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, I need a common structure for providing persistence of state
    data for business objects that are available across the entire system so that
    I can build the relevant final classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseDataObject` is not functionally related to the business object definitions
    in `hms_core`, but the functionality it provides still needs to be available to
    all of the real code bases – the ones for the applications and the **Artisan Gateway**
    service – it makes sense that it should live in the `hms_core` package, but perhaps
    not with the business object definitions from the previous iteration. In the long
    run, it will be easier to understand and maintain the `hms_core` package if its
    various members are organized into modules that group elements into common purposes
    or themes. Before the end of this iteration, the current `hms_core.__init__.py` module
    will be renamed to something more indicative of the purposes it serves, and it
    will live next to a new module that will contain all of the data objects'' classes
    and functionality: `data_object.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two additional stories that relate to the structure of `BaseDataObject` and
    capabilities, whose needs will be noted as they are met during the development
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: As any data consumer, I need to be able to create, read, update and delete individual
    data objects, so that I can perform basic data management tasks against those
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As any data consumer, I need to be able to search for specific data objects
    so that I can then work with the resulting items found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The BaseDataObject ABC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of the properties of `BaseDataObject` are Boolean values, flags that
    indicate whether an instance of the class is in a specific state. The implementations
    of those properties all follow a simple pattern that''s already been shown in
    the definition of the  `available` property of `BaseProduct` in the previous iteration.
    That structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The deleter methods behind those properties, since they are also used to set
    the default values for an instance during initialization, should yield specific
    values when the properties are deleted (calling those methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless overridden by a derived class, or by a specific object creation process,
    any instance derived from `BaseDataObject` will start with these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_active == True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_deleted == False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_dirty == False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_new == True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So a newly created instance will be active, not deleted, not dirty, and new
    , the assumption being that the process of creating a new object will usually
    be with the intention of saving a new, active object. If any state changes are
    made between the creation of the instance, those may set the `is_dirty` flag to `True` in
    the process, but the fact that `is_new` is `True` means that the object's record
    needs to be created rather than updated in the backend datastore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only significant deviation from that standard Boolean property structure
    is in the documentation of the properties themselves during their definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Two of the properties of `BaseDataObject`, `created` and `modified`, are shown
    in the class diagram as `datetime` values – objects that represent a specific
    time of day on a specific date. A `datetime` object stores the year, month, day,
    hour, minute, second, and microsecond of a date/time, and provides several conveniences
    over, say, working with an equivalent value that is managed strictly as a timestamp
    number value, or a string representation of a date/time. One of those conveniences
    is the ability to parse a value from a string, allowing the `_set_created` and `_set_modified` setter methods
    behind the property to accept a string value instead of requiring an actual `datetime`.
    Similarly, `datetime` provides the ability to create a `datetime` instance from
    a timestamp – the number of seconds elapsed from a common starting date/time. In
    order to fully support all those argument types, it''s necessary to define a common
    format string that will be used to parse the `datetime` values from strings and to
    format them into strings. That value, at least for now, feels like it''s probably
    best stored as a class attribute on `BaseDataObject` itself. That way, all classes
    that derive from it will have the same value available by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The setter methods are somewhat longer than most, since they are dealing with
    four different viable value types, though there are only two subprocesses required
    to cover all of those variations. The setter process starts by type checking the
    supplied value and confirming that it''s one of the accepted types first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling either of the numeric types that are legitimate is fairly straightforward.
    If an error is detected, we should provide more specific messaging around the
    nature of the encountered problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The subprocess for handling string values is similar, apart from its call to `datetime.strptime` instead
    of `datetime.fromtimestamp`, and its use of the `_data_time_string` class attribute
    to define what a valid date/time string looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the original value was an instance of `datetime`, then neither of the previous
    subprocesses would have executed. If either of them executed, then the original
    value argument will have been replaced with a `datetime` instance. In either case,
    that value can be stored in the underlying property attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of `BaseDataObject`, both `created` and `modified` should always have
    a value, and if one isn''t available when it''s needed – generally only when a
    data object''s state data record is being saved – one should be created then and
    there for the current value, which can be accomplished in the getter method with `datetime.now()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That, in turn, implies that the deleter method should set the property storage
    attribute''s value to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding property definitions are standard, except that the `created` property
    doesn''t allow deletion directly;  it makes no sense to allow an object to delete
    its own created date/time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last property of `BaseDataObject` is, perhaps, the most critical  `oid`,
    which is intended to uniquely identify the state data record for a given data
    object. That property is defined as a **Universally Unique Identifier** (**UUID**)
    value, which Python provides in its `uuid` library. There are at least two advantages
    to using a UUID as a unique identifier instead of some of the more traditional
    approaches, such as a serial record number:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UUIDs are not dependent on a database operation''s success to be available:**
    They can be generated in code, without having to worry about waiting for a SQL
    INSERT to complete, for example, or whatever corresponding mechanism might be
    available in a NoSQL data store. That means fewer database operations, and probably
    simpler ones as well, which makes things easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UUIDs are not easily predictable:** A UUID is a series of 32 hexadecimal
    digits (with some dashes separating them into sections that are not relevant for
    this discussion), such as `ad6e3d5c-46cb-4547-9971-5627e6b3039a`. If they are
    generated with any of several standard functions provided by the `uuid` library,
    their sequence, if not truly random, is at least random enough to make finding
    a given value very difficult for a malicious user, with 3.4 × 10^(34) possible
    values to look for (16 values per hex digit, 31 digits because one is reserved).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unpredictability of UUIDs is especially useful in applications that have
    data accessible over the internet. Identification of records by sequential numbering
    makes it *much* easier for malicious processes to hit an API of some sort and
    just retrieve each record in sequence, all else being equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some caveats, though:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all database engines will recognize UUID objects as viable field types.
    That can be managed by storing actual UUID values in the data objects, but writing
    and reading string representations of those values to and from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be very slight performance impacts on database operations that use
    UUIDs as unique identifiers as well, especially if a string representation is
    used instead of the actual value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their inherent unpredictability can make legitimate examination of data difficult
    if there aren't other identifying criteria that can be used – human-meaningful
    data values that can be queried against (against other identifying criteria).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even setting the advantages aside, `BaseDataObject` will use UUIDs for object
    identity (the `oid` property) because of a combination of requirements and expected
    implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Artisan Application** won't have a real database behind it. It'll probably
    end up being a simple, local document store so the generation of a unique identifier
    for any given data object must be something that's self-contained and not reliant
    on anything other than the application's code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same `oid` values need to propagate to and from the **Artisan Application**
    and the **Artisan Gateway** service. Trying to coordinate identities across any
    number of artisans could lead, very quickly, to identity collisions, and mitigating
    that would probably require more work (maybe a lot more) without making significant
    changes to the requirements of the system, or at least how the various installables
    in the system interact. The likelihood of collisions between any two randomly-generated
    UUIDs is extremely low (if not impossible for all practical purposes), simply
    because of the number of possible values involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementation of the `oid` property will follow a pattern similar to the one
    established for the ones based on `datetime`. The getter method will create one
    on demand, the setter method will accept `UUID` objects or string representations
    of it and create actual `UUID` objects internally, and the deleter method will
    set the current storage value to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the methods of `BaseDataObject` are abstract, including all of the
    class methods. None of them has any concrete implementations that might be reused
    in derived classes, so they are all very basic definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `to_data_dict` instance method and the `from_data_dict` class method are
    intended to provide mechanisms to represent an instance's complete state data
    as a `dict`, and create an instance from such a `dict` representation, respectively.
    The `from_data_dict` method should facilitate record retrieval and conversion
    into actual programmatic objects across most standard RDBMS-connection libraries
    in Python, especially if the field names in the database are identical to the
    property names of the class. Similar usage should be viable in NoSQL data stores
    as well. Though the `to_data_dict` method may or may not be as useful in writing
    records to a data store, it will be needed to match objects based on criteria
    (the matches method, which we'll get to shortly).
  prefs: []
  type: TYPE_NORMAL
- en: PEP-249, the current **Python Database API Specification**, defines an expectation
    that database queries in libraries that conform to the standards of the PEP will,
    at a minimum, return lists of tuples as result sets. Most mature database connector
    libraries also provide a convenience mechanism to return a list of `dict` record
    values, where each dict maps field names as keys to the values of the source records.
  prefs: []
  type: TYPE_NORMAL
- en: The `_create` and `_update` methods are simply requirements for the record creation
    and record update processes, and will eventually be called by the `save` method.
    The need for separate record creation and record update processes may not be applicable
    to all data store engines, though; some, especially in the NoSQL realm, already
    provide a single mechanism for writing a record, and simply don't care whether
    it already exists. Others may provide some sort of mechanism that will allow an
    attempt to create a new record to be made first, and if that fails (because a
    duplicate key is found, indicating that the record already exists), then update
    the existing record instead. This option is available in `MySQL` and `MariaDB`
    databases, but may exist elsewhere. In any of those cases, overriding the save
    method to use those single-point-of-contact processes may be a better option.
  prefs: []
  type: TYPE_NORMAL
- en: The `delete` class method is  self-explanatory, and `sort` probably is as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method requires some examination, even without any concrete implementation.
    As noted earlier, it is intended to be the primary mechanism for returning objects
    with state data retrieved from the database, and to accept both zero-to-many object
    IDs (the `*oids` argument list) and filtering criteria (in the `**criteria` keyword
    arguments). The expectation for how the whole `get` process will actually work is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `oids` is not empty:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform whatever low-level query or lookup is needed to find objects that match
    one of the provided `oids`, processing each record with `from_data_dict` and yielding
    a list of objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `criteria` is not empty, filter the current list down to those objects whose `matches` results
    against the criteria are `True`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the resulting list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, if `criteria` is not empty:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform whatever low-level query or lookup is needed to find objects that match one of
    the provided criteria values, processing each record with `from_data_dict` and
    yielding a list of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter the current list down to those objects whose `matches` results against
    the criteria are `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the resulting list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, perform whatever low-level query or lookup is needed to retrieve all available
    objects, again processing each record with `from_data_dict`, yielding a list of
    objects and simply returning them all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taken together, the combination of the `oids` and `criteria` values will allow
    the `get` class method to find and return objects that do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Match one or more `oids`: `get(oid[, oid, …, oid])`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match one or more `oids` and some set of `criteria`: `get(oid[, oid, …, oid],
    key=value[, key=value, …, key=value])`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Match one or more `criteria` key/value pairs, regardless of the `oids` of the
    found items: `get(key=value[, key=value, …, key=value])`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That simply exist in the backend data store: `get()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That leaves the `matches` and `save` methods, the only two concrete implementations
    in the class. The goal behind `matches` is to provide an instance-level mechanism
    for comparing the instance with criteria names/values, which is the process that
    the `criteria` in the `get` method uses and relies upon to actually find matching
    items. Its implementation is simpler than it might appear at first, but relies
    on operations against `set` objects, and on a Python built-in function that is
    often overlooked (`all`), so the process itself is heavily commented in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `all` function is a nice convenience it returns `True` if all of the items
    in the iterable it''s passed evaluate to `True` (or at least true-ish, so non-empty
    strings, lists, tuples, and dictionaries, and non-zero numbers, would all be considered `True`).
    It returns `False` if any members of the iterable aren''t `True`, and returns `True` if
    the iterable is empty. The results of `matches` will be `False` if these conditions
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Any key in the `criteria` doesn't exist in the instance's `data_dict` – a criteria
    key that cannot be matched, essentially
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any value specified in `criteria` doesn't exactly match its corresponding value
    in the instance's `data_dict`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `save` method is very simple. It just calls the instance''s `_create` or `_update` methods
    based on the current state of the instance''s `is_new` or `is_dirty` flag properties,
    respectively, and resets those flags after either executes, leaving the object
    clean and ready for whatever might come next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization of a `BaseDataObject` should allow values for all of its
    properties, but not require any of those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual initialization process follows the previously established pattern
    for optional arguments for all arguments in that case: calling the corresponding `_del_` method
    for each, then calling the corresponding `_set_` method for each if the argument
    isn''t `None`. Let''s use the `oid` argument as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This initializer method''s signature is getting pretty long, with seven arguments
    (ignoring `self`, since that will always be present, and will always be the first
    argument). Knowing that we''ll eventually define concrete classes as combinations
    of `BaseDataObject` and one of the business object classes defined, the signature
    for `__init__` on those concrete classes could get much longer, too. That, though,
    is part of the reason why the initialization signature of `BaseDataObject` makes
    all of the arguments optional. Taken in combination with one of those business
    object classes, `BaseArtisan`, for example, with an `__init__` signature of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The combined `__init__` signature for an `Artisan` that's derived from both,
    while long...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '... only requires the `contact_name`, `contact_email`, and `address` arguments
    that `BaseArtisan` requires, and allows all of the arguments to be passed as if
    they were keyword arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Allows the entire parameter set to be defined as a single dictionary and passed
    whole-cloth to the initializer using the same syntax that passing a keyword argument
    set would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That syntax for passing arguments in a dictionary using `**dictionary_name` is
    a common form of argument parameterization in Python, especially in functions
    and methods where the full collection of arguments is unreasonably long. It requires
    some thought and discipline on the design side of the development process, and
    an eye toward being very restrictive with respect to required arguments, but in
    the long run, it's more helpful and easier to use than might appear at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last structure will be critical in the implementation of the `from_data_dict` methods
    of the various classes derived from `BaseDataObject` – in most cases, it should allow
    the implementation of those methods to be little more than this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing BaseDataObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing of `BaseDataObject` is going to be… interesting, as it stands
    right now. Testing the `matches` method, a concrete method that depends on an
    abstract method (`to_data_dict`), which, in turn depends on the actual data structure
    (`properties`) of a derived class, is either not possible or meaningless in the
    context of the test case class for `BaseDataObject` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to test `matches`, we have to define a non-abstract class with a concrete
    implementation of `to_data_dict`, and some actual properties to generate that resulting `dict` from/with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That derived class, unless it also happens to be an actual class needed in the
    system, has no relevance in the final system's code, so tests there do not assure
    us that other derived classes won't have issues in `matches`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even setting the testing of the `matches` method completely aside, testing `save` is
    similarly pointless, for much the same reason  it's a concrete method that depends
    on methods that are, at the `BaseDataObject` level, abstract and undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Back when `BaseArtisan` was being implemented, we defined its `add_product` and `remove_product` methods
    as abstract, but still wrote usable concrete implementation code in both, in order
    to allow derived classes to simply call the parent''s implementation. In effect,
    we required an implementation of both in all derived classes, but provided an
    implementation that could be called from within the derived class methods. The
    same sort of approach, applied to the  `matches` and `save` methods in `BaseDataObject`,
    would essentially enforce testing requirements on each derived concrete class,
    while still permitting the use of a single implementation until or unless a need
    arose to override that implementation. It might feel a bit hacky, but there don''t
    appear to be any downsides to that approach:'
  prefs: []
  type: TYPE_NORMAL
- en: The methods processed in this fashion still have to be implemented in the derived
    classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they need to be overridden for whatever reason, testing policies will still
    require them to be tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If they are implemented as nothing more than a call to the parent class method,
    they will function and testing policy code will still recognize them as local
    to the derived class. Our testing policy says those are in need of a test method, and
    that allows test methods to execute against the specific needs and functionality
    of the derived class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing `save` doesn't have to take that approach, however. Ultimately, all
    we're really concerned with as far as that method is concerned is that we can
    prove that it calls the `_create` and `_update` abstract methods and resets the
    flags. If that proof can be tested and established in the process of testing `BaseDataObject`,
    we won't have to test it elsewhere unless the test policy code detects an override
    of the method. That would, in turn, allow us to avoid having the same test code
    scattered across all the test cases for all of the final, concrete classes later
    on, which is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the unit tests for the `data_objects` module is simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `test_data_object.py` file in the project's `test_hms_core` directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the two name replacements noted in the header comments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a reference to it in `__init__.py` in that same directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test code and go through the normal iterative test writing process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The reference to the new test module in `__init__.py` follows the structure
    that already exists in our unit test module template making a copy of the two
    lines starting with `# import child_module` in the existing code, then uncommenting
    them and changing `child_module` to the new test module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That addition adds all of the tests in the new `test_data_objects` module to
    the tests already present in the top-level `__init__.py` test module, allowing
    that top-level test suite to execute the child module tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f9359000-284f-4821-a55a-54158255a251.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tests in `test_data_objects.py` can also be executed independently, yielding
    the same failure, but without executing all of the other existing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51ea1863-b0cd-436c-8809-be5d1e9e7e1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The iterative process for writing unit tests for `data_objects.py` is no different
    than the process that was used for writing tests for the base business objects
    in the previous iteration: run the test module, find a test that''s failing, write
    or modify that test, and re-run until all tests pass. Since `BaseDataObject` is
    an abstract class, a throwaway, derived concrete class will be needed to perform
    some tests against it. With the exception of the value-oriented testing of the `oid`, `created`, and `modified` properties
    of `BaseDataObject`, we have established patterns that cover everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration over good and bad value lists that are meaningful as values for the
    member being tested:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not applicable yet) standard optional text-line values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not applicable yet) standard required text-line values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean (and numeric-equivalent) values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Not applicable yet) non-negative numeric values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying property method associations – getter methods in every case so far,
    and setter and deleter methods where they are expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying getter methods retrieve their underlying storage attribute values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying deleter methods reset their underlying storage attribute values as
    expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that setter methods enforce type checks and value checks as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying that initialization methods (`__init__`) call all of the deleter and
    setter methods as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those same three properties (`oid`, `created`, and `modified`), apart from
    not having an established test pattern already defined, share another common characteristic:
    all three of them will create a value if the property is requested and doesn''t
    already have one (that is, the underlying storage attribute''s value is `None`).
    That behavior requires some additional testing beyond the normal confirmation
    that the getter reads the storage attribute that the test methods start with (using `test_get_created` to
    illustrate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to this point, the test method is pretty typical of a getter method test
    it sets an arbitrary value (because what''s being tested is whether the getter
    retrieves the value, nothing more), and verifies that the result is what was set.
    Next, though, we force the storage attribute''s value to None, and verify that
    the result of the getter method is an object of the appropriate type a `datetime` in
    this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method for the property setter method (`_set_created` in this case)
    has to account for all of the different type variations that are legitimate for
    the property – `datetime`, `int`, `float`, and `str` values alike for `_set_created` –
    and set the expected value accordingly based on the input type before calling
    the method being tested and checking the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The deleter method test is structurally the same test process that we''ve implemented
    before, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The exact same structure, with `created` changed to `modified`, tests the underlying
    methods of the `modified` property. A very similar structure, changing names (`created` to
    `oid`) and expected types (`datetime` to `UUID`), serves as a starting point for
    the tests of the property methods for the `oid` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing `_get_oid`, then looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And testing `_set_oid` looks like this (note that the type change also has
    to account for a different expected type and value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of the data object tests complete (for now), it''s a good time to
    move the class definitions that were living in the package header file (`hms_core/__init__.py`)
    into a module file just for them: `business_objects.py`. While it''s purely a
    namespace organizational concern (since none of the classes themselves are being
    changed, just where they live in the package), it''s one that makes a lot of sense,
    in the long run. With the move completed, there is a logical grouping to the classes
    that reside in the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bfca67f7-3fc4-4445-be41-603b18e47305.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Business object definitions, and items that tie directly to those types, will
    all live in the `hms_core.business_objects` namespace, and can be imported from
    there, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All members of `hms_core.business_objects` could be imported, if needed, with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, functionality that relates to the data object structure that''s
    still in development will all live in the `hms_core.data_objects` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, again, all members of the module could be imported with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With the basic data object structure ready and tested, it's time to start implementing
    some concrete, data persisting business objects, starting with the ones living
    in the Artisan Application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The implementation of `BaseDataObject` provides mechanisms for all of the common
    data access needs we identified earlier (all the CRUD operations):'
  prefs: []
  type: TYPE_NORMAL
- en: It allows derived data objects, once they've been instantiated, to create and
    update their state data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a single mechanism that allows one or more data objects to be read
    from the data store, and as a bonus allows for some degree of object retrieval
    based on criteria other than just the `oid` of the data objects in question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a single mechanism for the deletion of object data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual implementation of those methods is the responsibility of the data
    objects themselves, which will relate directly to the storage mechanism that each
    object type uses.
  prefs: []
  type: TYPE_NORMAL
- en: The data storage for the Artisan Application, reading and writing data to local
    files on the user's machine, is, in many respects, the simpler of the two data
    storage options to implement, so we'll start with that.
  prefs: []
  type: TYPE_NORMAL
