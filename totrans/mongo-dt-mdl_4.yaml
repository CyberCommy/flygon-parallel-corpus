- en: Chapter 4. Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen with the subject of relational databases, indexes are important
    structures when we think of a performance boost. In fact, indexes are so important
    that for most database administrators, they are a critical tool in their search
    for the continuous improvement of database performance.
  prefs: []
  type: TYPE_NORMAL
- en: In NoSQL databases such as MongoDB, indexing is part of a bigger strategy that
    will allow us to achieve many gains in performance and assign important behaviors
    to our database, which will be essential to the data model's maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because we can have indexes with very special properties in MongoDB.
    For example, we can define an index of a date typed field that will control when
    a document should be removed from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special index properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of all the subjects we have been discussing in this book so far, this is
    where we will be the most at ease. The index concept is present in almost every
    relational database, so if you have any previous basic knowledge on the matter,
    you will most likely have no difficulty in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in case you feel that you are not familiar enough with the concept of indexes,
    an easy way to understand them is to draw a parallel with books. Suppose that
    we have a book with an index like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing documents](img/B04075_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this in hand, if we decide to read about the Internet, we know that on
    page **4**, we will find information on the subject. On the other hand, how would
    we be able to find information we are looking for without the page number? The
    answer is quite simple: by going through the entire book, page by page, until
    we find the word "Internet."'
  prefs: []
  type: TYPE_NORMAL
- en: As you might already know, indexes are data structures that hold part of the
    data from our main data source. In relational databases, indexes hold parts of
    a table, while in MongoDB, since indexes are on a collection level, these will
    hold part of a document. Similar to relational databases, indexes use a B-Tree
    data structure at implementation level.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on our application's requirements, we can create indexes of fields
    or fields of embedded documents. When we create an index, it will hold a sorted
    set of values of the fields we choose.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when we execute a query, if there is an index that covers the query criteria,
    MongoDB will use the index to limit the number of documents to be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `customers` collection that we used in [Chapter 3](ch03.html "Chapter 3. Querying
    Documents"), *Querying Documents*, which contains these documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create an index in the mongo shell on the `username` field, by using
    the `createIndex` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query will use the previously created index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Version 3.0.0, the `ensureIndex` method is deprecated and is an alias
    for the `createIndex` method.
  prefs: []
  type: TYPE_NORMAL
- en: We could state that this is the simplest way to create and use an index in MongoDB.
    In addition to this, we can create indexes on multikey fields or in embedded documents'
    fields, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through all these index types.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing a single field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already stated in the last section, the simplest way to create an index
    on MongoDB is to do so in a single field. The index could be created on a field
    of any type in the collection of documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `customers` collection we used before, with some modification
    to work in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command creates an ascending index in the `username` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to create an index in MongoDB, we use the `createIndex` method. In
    the preceding code, we just passed a single document as a parameter to the `createIndex`
    method. The document `{username: 1}` contains a reference to the field that the
    index should be creating and the order: 1 for ascending or -1 for descending.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create the same index, but in descending order, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following query, MongoDB will use the index created in the `username`
    field to reduce the number of documents in the `customers` collection that it
    should inspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the creation of indexes on a string or the number fields in the collection
    document, we could create an index of a field in an embedded document. Therefore,
    queries such as this will use the created index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code creates an index of the `state` field of the embedded address
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While a bit more complex, we can also create an index of the entire embedded
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following query will use the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But none of these queries will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because in order to match an embedded document, we have to match
    exactly the entire document, including the field order. The following query will
    not use the index either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although the document contains all the fields, these are in a different order.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next type of index, let's review a concept that you
    learned in [Chapter 3](ch03.html "Chapter 3. Querying Documents"), *Querying Documents*,
    the `_id` field. For every new document created in a collection, we should specify
    the `_id` field. If we do not specify it, MongoDB automatically creates one `ObjectId`
    typed for us. Furthermore, every collection automatically creates a unique ascending
    index of the `_id` field. That being said, we can state that the `_id` field is
    the document's primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing more than one field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In MongoDB, we can create an index that holds values for more than one field.
    We should call this kind of index a compound index. There is no big difference
    between a single field index and a compound index. The biggest difference is in
    the sort order. Before we move on to the particularities of compound indexes,
    let''s use the `customers` collection to create our first compound index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can imagine that an application that wants to authenticate a customer uses
    the `username` and `password` fields together in a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable better performance when executing this query, we can create an index
    of both the `username` and `password` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, for the following queries, does MongoDB use the compound index?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The answer is yes for `Query 1` and `Query 3`. As mentioned before, the order
    is very important in the creation of a compound index. The index created will
    have references to the documents sorted by the `username` field, and within each
    username entry, sorted by password entries. Thus, a query with only the `password`
    field as the criteria will not use the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume for a moment that we have the following index in the `customers`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be asking which queries will use our new compound index? Before answering
    that question, we need to understand a compound index concept in MongoDB: the
    **prefix**. The prefix in a compound index is a subset of the indexed fields.
    As its name suggests, it is the fields that take precedence over other fields
    in the index. In our example, both `{"address.state":1}` and `{"address.state":1,
    "address.zipcode": 1}` are index prefixes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A query that has any index prefix will use the compound index. Therefore, we
    can deduce that:'
  prefs: []
  type: TYPE_NORMAL
- en: Queries that include the `address.state` field will use the compound index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries that include both the `address.state` and `address.zipcode` fields will
    also use the compound index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries with `address.state`, `address.zipcode` and `address.street` will also
    use the compound index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries with both `address.state` and `address.street` will also use the compound
    index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compound index will not be used on queries that:'
  prefs: []
  type: TYPE_NORMAL
- en: Have only the `address.zipcode` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have only the `address.street` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have both the `address.zipcode` and `address.street` fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should notice that, despite a query that has both `address.state` and `address.street`
    fields using the index, we could achieve a better performance in this query if
    we have single indexes for each field. This is explained by the fact that the
    compound index will be first sorted by `address.state`, followed by a sort on
    the `address.zipcode` field, and finally a sort on the `address.street` field.
    Thus, it is much more expensive for MongoDB to inspect this index than to inspect
    the other two indexes individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be more efficient if we have this index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indexing multikey fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to create indexes in MongoDB is to create an index of an array field.
    These indexes can hold arrays of primitive values, such as strings and numbers,
    or even arrays of documents.
  prefs: []
  type: TYPE_NORMAL
- en: We must be particularly attentive while creating multikey indexes. Especially
    when we want to create a compound multikey index. It is not possible to create
    a compound index of two array fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main reason why we could not create an index of parallel arrays is because
    they will require the index to include an entry in the Cartesian product of the
    compound keys, which will result in a large index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `customers` collection with documents like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the following indexes for this collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But the following index cannot be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Indexing for text search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since its 2.4 version, MongoDB gives us the chance to create indexes that will
    help us in a text search. Although there are a wide variety of specialized tools
    for this, such Apache Solr, Sphinx, and ElasticSearch, most of the relational
    and NoSQL databases have full text searching natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to create a text index of a string or an array of string fields
    in a collection. For the following examples, we will use the `products` collection
    that we also used in [Chapter 3](ch03.html "Chapter 3. Querying Documents"), *Querying
    Documents*, but with some modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a text index just by specifying the `text` parameter in the `createIndex`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding commands could create a text index of the `products` collection.
    But, MongoDB has a limitation, in that we can only have one text index per collection.
    Thus, only one of the previous commands could be executed for the `products` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the limitation to create only one text index per collection, it is
    possible to create a compound text index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a `text` index field for the `name` and `description`
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common and useful way of creating a text index of a collection is to create
    an index for all text fields of the collection. There is a special syntax for
    creating this index, which you can see as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For a query to use a text index, we should use the `$text` operator in it. And,
    to better understand how to create an effective query, it is good to know how
    the indexes are created. As a matter of fact, the same process is used to execute
    the query using the `$text` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up the process, we can split it into three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Tokenization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of suffix and/or prefix, or stemming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of stop words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to optimize our queries, we can specify the language we are using in
    our text fields, and consequently in our text index, so that MongoDB will use
    a list of words in all three phases of the indexing process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since its 2.6 version, MongoDB supports the following languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`da` or `danish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nl` or `dutch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`en` or `english`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fi` or `finnish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fr` or `french`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`de` or `german`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hu` or `hungarian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it` or `italian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nb` or `norwegian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pt` or `portuguese`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ro` or `romanian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ru` or `russian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es` or `spanish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sv` or `swedish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tr` or `turkish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of an index creation with language could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also opt to not use any language, by just creating the index with a
    `none` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By using the `none` value option, MongoDB will simply perform tokenization and
    stemming; it will not load any stop words list.
  prefs: []
  type: TYPE_NORMAL
- en: When we decide to use a text index, we should always double our attention. Every
    single detail will have a side effect on the way we design our documents. In previous
    versions of MongoDB, before creating a text index, we should change the allocation
    method for all collections to **usePowerOf2Sizes**. This is because text indexes
    are considered larger indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Another major concern occurs at the moment we create the index. Depending on
    the size of the existing collection, the index could be very large, and to create
    a very large index we will need a lot of time. Thus, it is better to schedule
    this process to take place at a more timely opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to predict the impact that the text indexes will have on our
    write operations. This happens because, for each new record created in our collection,
    there will also be an entry created in the index referencing all the indexed value
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Creating special indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to all the indexes types we''ve created until now, whether in ascending
    or descending order, or text typed, we have three more special indexes: time to
    live, unique, and sparse.'
  prefs: []
  type: TYPE_NORMAL
- en: Time to live indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **time to live** (**TTL**) index is an index based on lifetime. This index
    is created only in fields that are from the Date type. They cannot be compound
    and they will be automatically removed from the document after a given period
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of index can be created from a date vector. The document will expire
    at the moment when the lower array value is reached. MongoDB is responsible for
    controlling the documents'' expiration through a background task at intervals
    of 60 seconds. For an example, let''s use the `customers` collection we have been
    using in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The creation command that is based on the time to live index for the `accountConfirmationExpireAt`
    field will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command indicates that every document that is older than the value in seconds
    requested in the `expireAfterSeconds` field will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way to create indexes based on lifetime, which is the
    scheduled way. The following example shows us this method of implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that the document you saw in the previous example expires
    on January 11 2015, 20:27:02.
  prefs: []
  type: TYPE_NORMAL
- en: This type of index is very useful for applications that use machine-generated
    events, logs and session information, which need to be persistent only during
    a given period of time, as you will see once again in [Chapter 8](ch08.html "Chapter 8. Logging
    and Real-time Analytics with MongoDB"), *Logging and Real-time Analytics with
    MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: Unique indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the vast majority of relational databases, MongoDB has a unique index.
    The unique index is responsible for rejecting duplicated values in the indexed
    field. The unique index can be created from a single or from a multikey field
    and as a compound index. When creating a unique compound index, there must be
    uniqueness in the values' combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for a unique field will always be null if we don''t set any
    value during the `insert` operation. As you have seen before, the index created
    for the `_id` field of a collection is unique. Considering the last example of
    the `customers` collection, it''s possible to create a unique index by executing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command will create an index of the `username` field that will not allow
    duplicated values.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sparse indexes are indexes that will be created only when the document has a
    value for the field that will be indexed. We can create sparse indexes using only
    one field from the document or using more fields. This last use is called a **compound
    index**. When we create compound indexes, it is mandatory that at least one of
    the fields has a not-null-value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example the following documents in the `customers` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following example command, we can create a `sparse` index in the
    `customers` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example query uses the created index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following example query, which requests the descending
    order by the indexed field, will not use the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how indexes are a very important tool in the maintenance
    of a data model. By including index creation during the query planning stage,
    this will bring lot of benefits—most of all in what is referred to as performance
    during query documents.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you learned how to create a single, compound, and multikey indexes. Next,
    we covered how and when to use indexes for text searching on MongoDB. We then
    met special index types such as the TTL, unique, and sparse index.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how to analyze queries and consequently create
    them in a more efficient way.
  prefs: []
  type: TYPE_NORMAL
