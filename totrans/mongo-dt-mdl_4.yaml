- en: Chapter 4. Indexing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen with the subject of relational databases, indexes are important
    structures when we think of a performance boost. In fact, indexes are so important
    that for most database administrators, they are a critical tool in their search
    for the continuous improvement of database performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In NoSQL databases such as MongoDB, indexing is part of a bigger strategy that
    will allow us to achieve many gains in performance and assign important behaviors
    to our database, which will be essential to the data model's maintenance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This happens because we can have indexes with very special properties in MongoDB.
    For example, we can define an index of a date typed field that will control when
    a document should be removed from the collection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter we will see:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Indexing documents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special index properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing documents
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of all the subjects we have been discussing in this book so far, this is
    where we will be the most at ease. The index concept is present in almost every
    relational database, so if you have any previous basic knowledge on the matter,
    you will most likely have no difficulty in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'But in case you feel that you are not familiar enough with the concept of indexes,
    an easy way to understand them is to draw a parallel with books. Suppose that
    we have a book with an index like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexing documents](img/B04075_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: 'With this in hand, if we decide to read about the Internet, we know that on
    page **4**, we will find information on the subject. On the other hand, how would
    we be able to find information we are looking for without the page number? The
    answer is quite simple: by going through the entire book, page by page, until
    we find the word "Internet."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As you might already know, indexes are data structures that hold part of the
    data from our main data source. In relational databases, indexes hold parts of
    a table, while in MongoDB, since indexes are on a collection level, these will
    hold part of a document. Similar to relational databases, indexes use a B-Tree
    data structure at implementation level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Depending on our application's requirements, we can create indexes of fields
    or fields of embedded documents. When we create an index, it will hold a sorted
    set of values of the fields we choose.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when we execute a query, if there is an index that covers the query criteria,
    MongoDB will use the index to limit the number of documents to be scanned.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `customers` collection that we used in [Chapter 3](ch03.html "Chapter 3. Querying
    Documents"), *Querying Documents*, which contains these documents:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can create an index in the mongo shell on the `username` field, by using
    the `createIndex` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following query will use the previously created index:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Version 3.0.0, the `ensureIndex` method is deprecated and is an alias
    for the `createIndex` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: We could state that this is the simplest way to create and use an index in MongoDB.
    In addition to this, we can create indexes on multikey fields or in embedded documents'
    fields, for instance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through all these index types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Indexing a single field
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already stated in the last section, the simplest way to create an index
    on MongoDB is to do so in a single field. The index could be created on a field
    of any type in the collection of documents.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `customers` collection we used before, with some modification
    to work in this section:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following command creates an ascending index in the `username` field:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to create an index in MongoDB, we use the `createIndex` method. In
    the preceding code, we just passed a single document as a parameter to the `createIndex`
    method. The document `{username: 1}` contains a reference to the field that the
    index should be creating and the order: 1 for ascending or -1 for descending.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create the same index, but in descending order, is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following query, MongoDB will use the index created in the `username`
    field to reduce the number of documents in the `customers` collection that it
    should inspect:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Besides the creation of indexes on a string or the number fields in the collection
    document, we could create an index of a field in an embedded document. Therefore,
    queries such as this will use the created index:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code creates an index of the `state` field of the embedded address
    document:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While a bit more complex, we can also create an index of the entire embedded
    document:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following query will use the index:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But none of these queries will do this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This happens because in order to match an embedded document, we have to match
    exactly the entire document, including the field order. The following query will
    not use the index either:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although the document contains all the fields, these are in a different order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next type of index, let's review a concept that you
    learned in [Chapter 3](ch03.html "Chapter 3. Querying Documents"), *Querying Documents*,
    the `_id` field. For every new document created in a collection, we should specify
    the `_id` field. If we do not specify it, MongoDB automatically creates one `ObjectId`
    typed for us. Furthermore, every collection automatically creates a unique ascending
    index of the `_id` field. That being said, we can state that the `_id` field is
    the document's primary key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Indexing more than one field
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In MongoDB, we can create an index that holds values for more than one field.
    We should call this kind of index a compound index. There is no big difference
    between a single field index and a compound index. The biggest difference is in
    the sort order. Before we move on to the particularities of compound indexes,
    let''s use the `customers` collection to create our first compound index:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can imagine that an application that wants to authenticate a customer uses
    the `username` and `password` fields together in a query like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To enable better performance when executing this query, we can create an index
    of both the `username` and `password` fields:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Nevertheless, for the following queries, does MongoDB use the compound index?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The answer is yes for `Query 1` and `Query 3`. As mentioned before, the order
    is very important in the creation of a compound index. The index created will
    have references to the documents sorted by the `username` field, and within each
    username entry, sorted by password entries. Thus, a query with only the `password`
    field as the criteria will not use the index.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume for a moment that we have the following index in the `customers`
    collection:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might be asking which queries will use our new compound index? Before answering
    that question, we need to understand a compound index concept in MongoDB: the
    **prefix**. The prefix in a compound index is a subset of the indexed fields.
    As its name suggests, it is the fields that take precedence over other fields
    in the index. In our example, both `{"address.state":1}` and `{"address.state":1,
    "address.zipcode": 1}` are index prefixes.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'A query that has any index prefix will use the compound index. Therefore, we
    can deduce that:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Queries that include the `address.state` field will use the compound index
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries that include both the `address.state` and `address.zipcode` fields will
    also use the compound index
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries with `address.state`, `address.zipcode` and `address.street` will also
    use the compound index
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries with both `address.state` and `address.street` will also use the compound
    index
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compound index will not be used on queries that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Have only the `address.zipcode` field
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have only the `address.street` field
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have both the `address.zipcode` and `address.street` fields
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should notice that, despite a query that has both `address.state` and `address.street`
    fields using the index, we could achieve a better performance in this query if
    we have single indexes for each field. This is explained by the fact that the
    compound index will be first sorted by `address.state`, followed by a sort on
    the `address.zipcode` field, and finally a sort on the `address.street` field.
    Thus, it is much more expensive for MongoDB to inspect this index than to inspect
    the other two indexes individually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this query:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It would be more efficient if we have this index:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Indexing multikey fields
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to create indexes in MongoDB is to create an index of an array field.
    These indexes can hold arrays of primitive values, such as strings and numbers,
    or even arrays of documents.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We must be particularly attentive while creating multikey indexes. Especially
    when we want to create a compound multikey index. It is not possible to create
    a compound index of two array fields.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main reason why we could not create an index of parallel arrays is because
    they will require the index to include an entry in the Cartesian product of the
    compound keys, which will result in a large index.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `customers` collection with documents like this one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can create the following indexes for this collection:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But the following index cannot be created:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Indexing for text search
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since its 2.4 version, MongoDB gives us the chance to create indexes that will
    help us in a text search. Although there are a wide variety of specialized tools
    for this, such Apache Solr, Sphinx, and ElasticSearch, most of the relational
    and NoSQL databases have full text searching natively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to create a text index of a string or an array of string fields
    in a collection. For the following examples, we will use the `products` collection
    that we also used in [Chapter 3](ch03.html "Chapter 3. Querying Documents"), *Querying
    Documents*, but with some modification:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can create a text index just by specifying the `text` parameter in the `createIndex`
    method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the preceding commands could create a text index of the `products` collection.
    But, MongoDB has a limitation, in that we can only have one text index per collection.
    Thus, only one of the previous commands could be executed for the `products` collection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the limitation to create only one text index per collection, it is
    possible to create a compound text index:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding command creates a `text` index field for the `name` and `description`
    fields.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common and useful way of creating a text index of a collection is to create
    an index for all text fields of the collection. There is a special syntax for
    creating this index, which you can see as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a query to use a text index, we should use the `$text` operator in it. And,
    to better understand how to create an effective query, it is good to know how
    the indexes are created. As a matter of fact, the same process is used to execute
    the query using the `$text` operator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up the process, we can split it into three phases:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Tokenization
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of suffix and/or prefix, or stemming
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of stop words
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to optimize our queries, we can specify the language we are using in
    our text fields, and consequently in our text index, so that MongoDB will use
    a list of words in all three phases of the indexing process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Since its 2.6 version, MongoDB supports the following languages:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`da` or `danish`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nl` or `dutch`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`en` or `english`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fi` or `finnish`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fr` or `french`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`de` or `german`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hu` or `hungarian`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it` or `italian`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nb` or `norwegian`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pt` or `portuguese`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ro` or `romanian`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ru` or `russian`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`es` or `spanish`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sv` or `swedish`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tr` or `turkish`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of an index creation with language could be:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also opt to not use any language, by just creating the index with a
    `none` value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using the `none` value option, MongoDB will simply perform tokenization and
    stemming; it will not load any stop words list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: When we decide to use a text index, we should always double our attention. Every
    single detail will have a side effect on the way we design our documents. In previous
    versions of MongoDB, before creating a text index, we should change the allocation
    method for all collections to **usePowerOf2Sizes**. This is because text indexes
    are considered larger indexes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Another major concern occurs at the moment we create the index. Depending on
    the size of the existing collection, the index could be very large, and to create
    a very large index we will need a lot of time. Thus, it is better to schedule
    this process to take place at a more timely opportunity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to predict the impact that the text indexes will have on our
    write operations. This happens because, for each new record created in our collection,
    there will also be an entry created in the index referencing all the indexed value
    fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Creating special indexes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to all the indexes types we''ve created until now, whether in ascending
    or descending order, or text typed, we have three more special indexes: time to
    live, unique, and sparse.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Time to live indexes
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **time to live** (**TTL**) index is an index based on lifetime. This index
    is created only in fields that are from the Date type. They cannot be compound
    and they will be automatically removed from the document after a given period
    of time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of index can be created from a date vector. The document will expire
    at the moment when the lower array value is reached. MongoDB is responsible for
    controlling the documents'' expiration through a background task at intervals
    of 60 seconds. For an example, let''s use the `customers` collection we have been
    using in this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The creation command that is based on the time to live index for the `accountConfirmationExpireAt`
    field will be the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command indicates that every document that is older than the value in seconds
    requested in the `expireAfterSeconds` field will be deleted.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way to create indexes based on lifetime, which is the
    scheduled way. The following example shows us this method of implementation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will make sure that the document you saw in the previous example expires
    on January 11 2015, 20:27:02.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This type of index is very useful for applications that use machine-generated
    events, logs and session information, which need to be persistent only during
    a given period of time, as you will see once again in [Chapter 8](ch08.html "Chapter 8. Logging
    and Real-time Analytics with MongoDB"), *Logging and Real-time Analytics with
    MongoDB*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Unique indexes
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the vast majority of relational databases, MongoDB has a unique index.
    The unique index is responsible for rejecting duplicated values in the indexed
    field. The unique index can be created from a single or from a multikey field
    and as a compound index. When creating a unique compound index, there must be
    uniqueness in the values' combinations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for a unique field will always be null if we don''t set any
    value during the `insert` operation. As you have seen before, the index created
    for the `_id` field of a collection is unique. Considering the last example of
    the `customers` collection, it''s possible to create a unique index by executing
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will create an index of the `username` field that will not allow
    duplicated values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Sparse indexes
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sparse indexes are indexes that will be created only when the document has a
    value for the field that will be indexed. We can create sparse indexes using only
    one field from the document or using more fields. This last use is called a **compound
    index**. When we create compound indexes, it is mandatory that at least one of
    the fields has a not-null-value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example the following documents in the `customers` collection:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the following example command, we can create a `sparse` index in the
    `customers` collection:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例命令，我们可以在`customers`集合中创建一个`sparse`索引：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following example query uses the created index:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例查询使用了创建的索引：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the other hand, the following example query, which requests the descending
    order by the indexed field, will not use the index:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，下面的示例查询，请求按索引字段的降序排列，将不使用索引：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how indexes are a very important tool in the maintenance
    of a data model. By including index creation during the query planning stage,
    this will bring lot of benefits—most of all in what is referred to as performance
    during query documents.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到索引是数据模型维护中非常重要的工具。通过在查询规划阶段包括索引创建，这将带来许多好处，尤其是在所谓的查询文档性能方面。
- en: Thus, you learned how to create a single, compound, and multikey indexes. Next,
    we covered how and when to use indexes for text searching on MongoDB. We then
    met special index types such as the TTL, unique, and sparse index.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您学会了如何创建单个、复合和多键索引。接下来，我们讨论了在MongoDB上如何以及何时使用索引进行文本搜索。然后我们介绍了特殊的索引类型，如TTL、唯一和稀疏索引。
- en: In the next chapter, you will see how to analyze queries and consequently create
    them in a more efficient way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到如何分析查询，从而以更高效的方式创建它们。
