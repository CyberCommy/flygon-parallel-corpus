- en: Scheduling and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll teach you the basics of scheduling and logging the results
    of your scripts. We'll begin by explaining how both `at` and `cron` can be used
    to schedule commands and scripts. In the second part of the chapter, we will describe
    how we can log the results of our scripts. We can use both the local mail functionality
    of Linux and redirection to achieve this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `at`, `wall`, `atq`,
    `atrm`, `sendmail`, `crontab`, and `alias`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling with `at` and `cron`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging script results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14).
    The rest of the examples and exercises should be performed on your Ubuntu virtual
    machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling with at and cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve learned about many things in the world of shell scripting so far: variables,
    conditionals, loops, redirections, and even functions. In this chapter, we''ll
    explain another important concept that is closely related to shell scripting:
    scheduling.'
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, scheduling is making sure your commands or scripts run at certain
    times, without the need for you to personally start them every time. A classic
    example can be found in cleaning up logs; often, older logs are no longer useful
    and take up too much space. For example, you could fix this with a cleanup script
    that removes logs older than 45 days. However, such a script should probably be
    run once a day. On a workday, this shouldn't pose the biggest problem, but having
    to log in during the weekend is no fun. Actually, we should not even consider
    this, since scheduling allows us to define *when* or *how often* a script should
    run!
  prefs: []
  type: TYPE_NORMAL
- en: In Linux scheduling, the most commonly used tools are `at` and `cron`. We'll
    first describe the principles of scheduling using `at`, before we continue with
    the much more powerful (and because of that, more widely used) `cron`.
  prefs: []
  type: TYPE_NORMAL
- en: at
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `at` command is used mostly for ad hoc scheduling. The syntax for `at`
    is very close to our natural language. This is easiest explained with an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In essence, you're telling the system: *at <timestamp>, do something*. When
    you enter the `at 11:51` command, you will be placed in an interactive prompt
    that will allow you to enter the commands you want executed. After that, you exit
    the prompt with *Ctrl* + *D*; if you use *Ctrl* + *C*, the job will not be saved!
    For reference, we use a simple command here, `wall`, which allows you to broadcast
    a message to everyone that is logged in to the server at that time.
  prefs: []
  type: TYPE_NORMAL
- en: Time syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use `at`, you can specify the time absolutely, like we did in the
    previous example, or relatively. An example of relative would be *in 5 minutes*
    or *after 24 hours*. This is often easier than checking the current time, adding
    your desired interval to it, and passing it to `at`. This works with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You always need to specify relative to which time you want to add the minute,
    hour, or day. Fortunately, we can use now as a keyword for the current time. Do
    note that when dealing with minutes, `at` will always round to the nearest full
    minute. Besides minutes, the following are also valid (as found in `man at`):'
  prefs: []
  type: TYPE_NORMAL
- en: Hours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weeks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can even create more complex solutions, such as *4 pm three days from now*.
    However, we feel like `cron` is better suited for these kinds of situations. With
    regards to `at`, the best use seems to be one-off jobs at a time that is *near*.
  prefs: []
  type: TYPE_NORMAL
- en: The at queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As soon as you start scheduling jobs, you''ll find yourself in a situation
    where you either messed up the time or the content for a job. For some jobs, you
    can just add a new one and let the other fail. However, there are certainly instances
    where the original job will wreak havoc on your system. In this case, it would
    be a great idea to delete the incorrect job. Luckily, the creators of `at` foresaw
    this problem (and probably experienced it too!) and created this functionality.
    The `atq` command (short for **at** **queue**), shows you the jobs currently in
    the pipeline. With `atrm` (don''t think we need to explain that one), you can
    remove jobs by number. Let''s look at an example of multiple jobs in the queue,
    and removing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve used a new flag for `at`: `-f`. This allows us to run
    commands defined in a file, instead of having to use the interactive shell. This
    file, which we ended with .txt (for clarity, no extension is needed), contains
    the commands to be executed. We use this file to schedule three jobs: after 5
    minutes, after 10 minutes, and after 4 minutes. After doing that, we use `atq`
    to see the current queue: all three jobs, numbered 12, 13, and 14\. At this point
    in time, we realize we only want the jobs to run after 4 and 5 minutes, and not
    after 10\. We can now use `atrm` to remove job number 13 by simply adding that
    number to the command. When we look at the queue again right afterward, we see
    that only jobs 12 and 14 remain. After a few minutes, the first two Hello! messages
    are printed onto our screen. If we wait the full 10 minutes, we will see... nothing,
    as we''ve successfully deleted our job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `atq` and `atrm`, `at` also has flags we can use for those
    functions. For `atq`, this is `at -l` (*list*). `atrm` even has two possible alternatives:
    `at -d` (*delete*) and `at -r` (*remove*). It does not matter whether you use
    the supporting commands or the flags; under the hood, the same thing will be executed.
    Use whatever is easiest to remember for you!'
  prefs: []
  type: TYPE_NORMAL
- en: at output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might have noticed, up until now we''ve only used commands that did
    not rely on stdout (a little sneaky, we know). However, once you think about it,
    this poses a real problem. Normally, when we deal with commands and scripts, we
    use stdout/stderr to get a feeling about the result of our actions. The same goes
    for interactive prompts: we use our keyboards to supply input via stdin. Now that
    we''re scheduling *non-interactive jobs*, things will be different. For starters,
    we cannot use interactive constructs such as `read` anymore. Scripts will simply
    fail because there is no stdin available. But, again, there is no stdout available
    either, so we do not even see the scripts fail! Or is there?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhere in the manpage of `at`, you can find the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The user will be mailed standard error and standard output from his commands,
    if any. Mail will be sent using the command /usr/sbin/sendmail. If at is executed
    from a su(1) shell, the owner of the  login  shell  will  receive  the mail."'
  prefs: []
  type: TYPE_NORMAL
- en: It would seem that the creators of `at` thought of this problem as well. However,
    if you do not have a lot of experience with Linux (yet!), you're probably confused
    about the mail portion of the preceding text. If you're thinking about the kind
    that has stamps, you're pretty far off. However, if you think *email*, you're
    a bit warmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too much detail (which is definitely outside the scope of
    this book), Linux has a local *mail spool,* which allows you to send emails within
    your local system. If you configure this with an upstream server, you can actually
    send an actual email as well, but for now, remember that an internal email on
    a Linux system is available. With this mail spool, emails are (perhaps unsurprisingly)
    files on the filesystem. These can be found at /var/spool/mail, which is actually
    a symbolic link to /var/mail. If you followed along with the installation of an
    Ubuntu 18.04 machine, these directories will be empty. This is easily explained:
    by default, `sendmail` is not installed. When it is not installed, and you schedule
    a job that has stdout, this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Yep, exactly nothing happens. Now, if we install `sendmail` and try this again,
    we should see a different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Mail, just for you! If we inspect /var/mail/, we''ll see just a single file
    that contains our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It even looks like a real email, with a Date:, a Subject:, a To:, and From:
    (and so on). If we schedule more jobs, we''ll see new mails appended to this single
    file. Linux has some simple, text-based mail clients that allow you to treat this
    single file as multiple emails, (one example of this is `mutt`); however, we do
    not need these for our purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing of note when dealing with notifications from the system, such as the
    You have new mail one, is that it does not always get pushed to your Terminal
    (while some others, such as `wall`, do). These messages are printed the next time
    your Terminal is updated; this is often done when you enter a new command, (or
    just an empty *Enter*). If you're working on these examples and waiting for the
    output, don't hesitate to press *Enter* a few times and see whether something
    comes up!
  prefs: []
  type: TYPE_NORMAL
- en: While it is sometimes great to get the output of commands we're running as jobs,
    more often than not it can be very annoying, since many processes can send you
    local mail. Often, this will result in a situation where you do not look at the
    mail, or even actively suppress output for commands, so you do not receive more
    mails. Further on in this chapter, after we introduce `cron`, we'll spend some
    time describing how we can deal with output *the right way*. As a small preview,
    this means we won't rely on inbuilt capabilities like this, but we'll use redirection
    to **write the output we need to a place where we know to find it.**
  prefs: []
  type: TYPE_NORMAL
- en: cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the basics of scheduling via `at` have been discussed, let''s take
    a look at the real powerhouse for scheduling on Linux: `cron`. Aptly named from
    the Greek word *chronos*, which translates to *time*, `cron` is a job scheduler,
    which consists of two main components: the *cron daemon* (sometimes referred to
    as *crond*), and the *crontab*. The cron daemon is the background process that
    runs the scheduled jobs. These jobs are scheduled using the crontab, which is
    simply a file on the filesystem that is most often edited with a command by the
    same name: `crontab`. We''ll start by looking at the `crontab` command and syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: crontab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every user on a Linux system can have their own crontab. There is also a system-wide
    crontab (not to be confused with the crontab that can run under the root user!),
    which is used for periodic tasks; we'll get to those later in this chapter. For
    now, we'll start by exploring the crontab syntax, and create our first crontab
    for our reader user.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax for the crontab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the syntax may initially seem confusing, it is actually not that hard
    to understand but extremely flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: <timestamp> command
  prefs: []
  type: TYPE_NORMAL
- en: 'Wow, that was easy! If this were really the case, then yes. However, what we
    described above as <timestamp> is actually composed of five different fields,
    which make up the combined period for running jobs multiple times. In reality,
    the timestamp is defined as follows (in order):'
  prefs: []
  type: TYPE_NORMAL
- en: Minute-of-the-hour
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hour-of-the-day
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Day-of-the-month
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Month
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Day-of-the-week
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In any of these values, we can substitute a number for a wildcard, which indicates
    *all values*. Look at the following table to get a feeling about how we combine
    these five fields for precise times:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ** Crontab     syntax** | ** Semantic meaning** |'
  prefs: []
  type: TYPE_TB
- en: '|  15 16 * * * |  Every day at 16:15. |'
  prefs: []
  type: TYPE_TB
- en: '|  30 * * * * |  Once every hour, at xx:30 (because every hour is valid due
    to the wildcard). |'
  prefs: []
  type: TYPE_TB
- en: '|  * 20 * * * |  60 times per day, between 20:00 and 20:59 (hour is fixed,
    minutes have a wildcard). |'
  prefs: []
  type: TYPE_TB
- en: '|  10 10 1 * * |  Once on the first of every month, at 10:10. |'
  prefs: []
  type: TYPE_TB
- en: '|  00 21 * * 1 |  Once per week, 21:00 on Monday (1-7 is Monday through Sunday,
    Sunday is also 0). |'
  prefs: []
  type: TYPE_TB
- en: '|  59 23 31 12 * |  Right before the new year, 23:59 on December 31st. |'
  prefs: []
  type: TYPE_TB
- en: '|  01 00 1 1 3 |  On 00:01 on January 1st, but only if that takes place on
    a Wednesday (which will happen in 2020). |'
  prefs: []
  type: TYPE_TB
- en: 'You might be a little confused by this syntax. Since many of us normally write
    time as 18:30, reversing the minutes and the hour seems a little counter intuitive.
    However, this is just the way it is (and trust us, you will get used to the crontab
    format soon enough). Now, there are a few advanced tricks that work with this
    syntax as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 8-16 (hyphens allows multiple values, so `00 8-16 * * *` would mean every full
    hour from 08:00 to 16:00).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/5 allows every 5 *units* (most often used in the first location, for every
    5 minutes). The value */6 for hours is useful as well, for four times a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 00,30 for two values, such as every 30 minutes on the hour or half hour (which
    could also be written as */30).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we get too bogged down in the theory, let''s create a simple first crontab
    for our user using the `crontab` command. The `crontab` command has three interesting
    flags you''ll use most often:`-l` for list, `-e` for edit, and `-r` for remove.
    Let''s create (and remove) our very first crontab using these three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we start by listing the current crontab using the `crontab
    -l` command. Since we do not have one, we see the message no crontab for reader
    (no surprises there). Next, when we use `crontab -e` to start editing the crontab,
    we''ll get a choice: which editor do we want to use? As always, do whatever works
    best for you. We have enough experience with `vim` to prefer it over `nano`. We
    only have to do that once for each user, because Linux will save our preference
    (check out the ~/.selected_editor file). Then, finally, we''re presented with
    a text editor screen, which, on our Ubuntu machine, is filled with a little tutorial
    on crontabs. Since all these lines start with a #, all are considered comments
    and do not interfere with execution. Usually, we delete everything *except the
    syntax hint*: m h dom mon dow command. You can expect to forget this syntax a
    few times, which is why that little hint helps a lot when you need to do a quick
    edit, especially if it has been a while since you''ve interacted with a crontab.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a crontab with the simplest time syntax of all: wildcards in all
    five positions. Simply said, that means the command specified after is run *every
    minute*. After we save and exit, we wait a maximum of one minute before we see
    the result of the `wall "Crontab rules!";` command a broadcast from our own user,
    visible to all users on the system. Because this construction spams up the system
    pretty badly, we remove the crontab after a single broadcast by using `crontab
    -r`. Alternatively, we could have also removed just that line or commented it
    out.'
  prefs: []
  type: TYPE_NORMAL
- en: A crontab can have many entries. Each entry has to be placed on its own line,
    with its own time syntax. This allows for a user to have many different jobs scheduled,
    at different frequencies. Because of this, `crontab -r` is not often used, and
    by itself is pretty destructive. We would advise you to always use `crontab -e`
    to ensure you do not accidentally delete your whole job schedule, but just the
    bits that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated, all crontabs are saved as files in the filesystem. You can find
    them in the /var/spool/cron/crontabs/ directory. This directory is accessible
    to the root user only; it would have some big privacy concerns if all users could
    see each other''s job schedules. If you use `sudo` to become root, however, you
    would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to open this file (`vim`, `less`, `cat`, whatever you prefer), we''d
    see the same as a `crontab -e` for the reader user would show us. As a general
    rule, though, always use the available tools to edit files like these! The primary
    added benefit of this is that these tools do not allow you to save an incorrect
    format. If we were to edit the crontab file by hand and get the time syntax wrong,
    the entire crontab will no longer work. If you do the same with `crontab -e`,
    you will see an error and the crontab will not be saved, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we entered the line `* * * * true`. As can be seen
    from the error, where cron expects a digit or wildcard, it finds the command `true`
    (which, as you might recall, is a command which simply returns an exit code of
    0). It presents the user with an error, and refuses to save the new edit, which
    means all previous scheduled jobs are safe and will continue to run, even though
    we messed it up this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time syntax for crontab allows pretty much any combination you could think
    of. However, sometimes you do not really care about an exact time, but are more
    interested in making sure something runs *hourly*, *daily*, *weekly,* or even
    *monthly*. Cron has some special time syntaxes for this: instead of the five values
    you normally insert, you can tell the crontab `@hourly`, `@daily`, `@weekly`, and
    `@monthly`.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging script results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running scripts on a schedule is a great way to automate repetitive tasks.
    There is one big consideration when doing this though: logging. Normally, when
    you run a command, the output will be visible to you directly. If something seems
    wrong, you are there behind the keyboard to investigate the issue. However, once
    we start using `cron` (and even `at`), we no longer see the direct output of the
    commands. We can only check the results once we log in, and, if we do not make
    arrangements, we can only look for the *result of the script* (for example, cleaned
    up log files). What we need is logging for our script, so we have a simple way
    to periodically verify whether our script is running successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: Crontab environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our crontab, we can define environment variables, which will be used by
    our commands and scripts. This function of the crontab is used quite frequently,
    but mostly only for three environment variables: PATH, SHELL, and MAILTO. We''ll
    look at the use case/necessity for these variables.'
  prefs: []
  type: TYPE_NORMAL
- en: PATH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, when you login to a Linux system, you are given a *login shell*.
    A login shell is a fully interactive shell that does some cool stuff for you:
    it sets the PS1 variable (which determines how your prompt looks), correctly sets
    your PATH, and so on. Now, as you might imagine, there is also something other
    than a login shell. Technically, there are two dimensions that make up four different
    kinds of shells:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ** Login** | ** Non-login** |'
  prefs: []
  type: TYPE_TB
- en: '| ** Interactive** |  Interactive login shell |  Interactive non-login shell
    |'
  prefs: []
  type: TYPE_TB
- en: '| ** Non-interactive** |  Non-interactive login shell |  Non-interactive non-login
    shell |'
  prefs: []
  type: TYPE_TB
- en: Most of the time, you'll use an *interactive login shell*, such as when you
    connect via (SSH) or directly via the Terminal console. The other often encountered
    shell is the *non-interactive non-login shell*, which is what is used when commands
    are run via `at` or `cron`. The other two are possible, but we will not be going
    into the details of when you would get those.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that you know we get a different type of shell in `at` and `cron`,
    we''re sure you''d like to know what the difference is (as in, why do you care
    about this?). There are a number of files that set your profile in Bash. Some
    of these are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/profile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/bash.bashrc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/.profile`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~/.bashrc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two, located in /etc/, are system-wide files, and are thus the same
    for all users. The latter two, which are found in your home directory, are personal;
    these can be edited to, for example, add aliases that you'd like to use. The `alias` command
    is used to create a shorthand for commands with flags. The ~/.bashrc file contains
    the line `alias ll='ls -alF'` by default on Ubuntu 18.04, which means you can
    type `ll` and have `ls -alF` executed instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without going into too much detail (and oversimplifying quite a bit), an interactive
    login shell reads and parses all these files, while a non-interactive non-login
    shell does not (for more in-depth information, see the *Further reading* section).
    As always, a picture is worth a thousand words, so let''s check out the differences
    ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, the values differ between a normal (SSH) shell and `at`
    executed commands. This goes for both PS1 and the shell itself (which we can find
    with $0). However, for `at`, the PATH is the same as for an interactive login
    session. Now, take a look at what happens if we do this in a crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting off, PS1 is equal to what `at` sees. Since PS1 controls the way the
    shell looks, this is only interesting for interactive sessions; both `at` and
    `cron` are non-interactive. If we move on to **PATH**, we see a very different
    story: when running in `cron`, we get /usr/bin:/bin instead of /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin!
    Simply put, this means for all commands that are outside of /bin/ and /usr/bin/,
    we need to use the fully qualified filename. This even manifests itself in the
    $0 difference (sh versus /bin/sh). While this is not strictly necessary (since
    /bin/ is actually part of the PATH), it is still typical to see fully qualified
    paths for anything `cron` related.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have two options to deal with this, if we want to prevent errors such
    as sudo: command not found. We can either make sure we always use fully qualified
    paths for all commands (which, in practice, will definitely fail a few times),
    or we can make sure we set a PATH for the crontab. The first option gives us a
    lot more extra work for all things we''ll ever do with `cron`. The second option
    is actually a really easy way to make sure we negate this problem. We can simply
    include a `PATH=...` at the top of the crontab, and all things executed by the
    crontab use that PATH. Give the following a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy-peasy. If you want to verify this for yourself, you could keep the default
    PATH and run something from /sbin/ (such as the `blkid` command, which shows information
    on your disks/partitions). Since this isn''t on the PATH, if you do not run it
    fully qualified, you''ll encounter the error /bin/sh: 1: blkid: not found in your
    local mail. Pick any command that you could normally run and try it!'
  prefs: []
  type: TYPE_NORMAL
- en: With this simple addition to a crontab, you can save yourself a lot of time
    and effort troubleshooting errors. As with all things in scheduling, you often
    have to wait at least a few minutes for each script attempt to run, making troubleshooting
    a time-intensive practice. Do yourself a favor and always make sure to include
    a relevant PATH as the first line of your crontab.
  prefs: []
  type: TYPE_NORMAL
- en: SHELL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be clear from looking at the outputs we saw for **PATH**, both `at`
    and `cron` by default use /bin/sh. You might get lucky and have a distribution
    where /bin/sh defaults to Bash, but this is not necessarily the case, especially
    not if you followed along with our Ubuntu 18.04 installation! In this case, if
    we check out /bin/sh, we see something different entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Dash is the ***D**ebian **A**lmquist **sh**ell*, which is the default system
    shell on recent Debian systems (Ubuntu, as you might remember, belongs to the
    Debian distribution family). While Dash is a wonderful shell with its own set
    of advantages and disadvantages, this book is written for Bash. So, for our use
    case, it is not practical to have `cron` default to using a Dash shell, since
    that would not allow us to use cool Bash 4.x functions such as advanced redirections,
    certain expansions, and so on. Fortunately, we can easily set the shell that `cron`
    should use when we run our commands: we use the SHELL environment variable. Setting
    this is really simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With just the simple addition of the SHELL environment variable, we made sure
    we do not have mind-boggling issues about why certain Bash functionality is not
    working. It is always a good idea to prevent these issues rather than hope you
    catch them quickly, especially if you're still mastering shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: MAILTO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've determined we can use environment variables in our crontab by
    checking out both PATH and SHELL, let's look at the other very important one, MAILTO.
    As you might guess from the name, this variable controls where mails will be sent.
    As you remember, mails are sent when a command has stdout (which are pretty much
    all commands). That means that for every command the crontab executes, you'll
    probably get a local email. This, as you might suspect, can become annoying very
    quickly. We could suffix a nice little `&> /dev/null` to all commands we place
    in the crontab (remember, `&>` is Bash-specific, and would not have worked for
    the default Dash shell). However, this would mean that we never have any output
    at all, mailed or otherwise. Besides that problem, we'll also need to add it to
    all our lines; not really a real practical, workable solution. In a few pages,
    we're going to discuss how we can redirect our output to somewhere we want. Before
    we get to that point, however, we need to be able to manipulate the default emails
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option would be to either not install or uninstall `sendmail`. This might
    be a good solution for some of you, but for others there is another need to have
    `sendmail` on the system, so it cannot be removed. What then? We can use the MAILTO
    variable in the same way as we use the **PATH**; we set it in the beginning of
    the crontab, and mails will be properly redirected. If we empty this variable,
    by assigning it the empty string `""`, no mail will be sent. This looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used the `tail` command a lot up until now, but it actually has a great
    little flag `--follow` (`-f`), which allows us to see if any new lines are being
    written to a file. This is normally used to *tail a logfile*, but in this case
    allows us to see whether we get mail by tailing the /var/mail/reader file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If everything went as we expected it to, this is the only thing you will see.
    Since the MAILTO variable was declared as the empty string, `""`, `cron` knows
    not to send out mails. Exit the `tail -f` with *Ctrl* + *C* (but remember the
    command), and rest easy now that you've prevented yourself from being spammed
    by your crontab!
  prefs: []
  type: TYPE_NORMAL
- en: Logging with redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the mail spam has been eliminated, now you find yourself without any
    output at all, which is definitely not a good thing either. Luckily for us, we''ve
    learned all about redirection in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts**.* Just as we can use *redirect within
    scripts* or *on the command-line*, we can use the same constructs in a crontab.
    The same rules for ordering of pipes and stdout/stderr apply, so we can chain
    whatever command we want. Before we show this, however, we''ll show one more cool
    functionality of crontab: instantiating a crontab from a file!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we create the base-crontab file, which contains our Bash SHELL, the PATH
    (which we trimmed a little), the MAILTO variable, and our syntax header. Next,
    we use the `crontab base-crontab` command. Simply put, this replaces the current
    crontab with the contents from the file. This means we can manage the crontab
    as a file now; this includes support for version control systems and other backup
    solutions. Even better, when using the `crontab <filename>` command, syntax checking
    is intact. If the file isn't proper crontab format, you'll see the error errors
    in crontab file, can't install. Should you wish to save the current crontab to
    a file, the `crontab -l > filename` command will do the trick for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that that''s out of the way, we''ll give some examples of redirection for
    commands run by the crontab. We''ll always instantiate from a file, so that you
    can easily find these materials on the GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, that was pretty easy. As long as our SHELL, PATH**,** and MAILTO are properly
    set, we have avoided a lot of issues that are normally experienced when people
    start working with scheduling via the crontab.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we have not done yet is run a script with the crontab. So far, only
    single commands have been run. However, a script will run just as great. We''ll
    use a script from the previous chapter, reverser.sh, which will show that we can
    supply arguments to scripts via the crontab as well. Furthermore, it will show
    that the redirection we just learned works for script output just as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Ouch! After all our careful preparation, we still messed up here. Fortunately,
    the output file we created (which functions as a log file, and has the .log extension
    because of it) also has stderr redirected (because of our Bash 4.x `&>>` syntax)
    and we see what the error is. A classic error, Permission denied in this case
    simply means that we are trying to execute a non-executable file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we need to fix this. We can do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the file executable with (for example) `chmod 755 reverser.sh`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the crontab from `reverser.sh` to `bash reverser.sh`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, there is not really a good or bad solution. On the one hand, it
    is always a good idea to mark files that need to be executed as executable; this
    conveys to someone seeing the system that you intended this. On the other hand,
    if the extra `bash` command in the crontab can save you from these types of issues,
    what is the harm in that?
  prefs: []
  type: TYPE_NORMAL
- en: 'In our opinion, there is slightly more merit in making the file executable
    and omitting the `bash` command in your crontab. This keeps the crontab cleaner,
    (and, from experience, crontabs can easily become a mess if mishandled, so this
    is a very big plus), and shows someone else looking at the script that it should
    be executed because of the permissions. Let''s apply this fix to our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There, much better. The full command that we run in the crontab is `/home/reader/scripts/chapter_13/reverser.sh
    'crontab' &>> /tmp/reverser.log`, which includes the word crontab as the first
    argument to the script. The output, _batnorc_, is indeed the reversed word. It
    would seem that we can correctly pass arguments via the crontab! While this example
    illustrates the point, it might not get across while this might be significant.
    However, if you imagine a generic script that is normally used multiple times
    with different arguments, it could be present with those different arguments in
    the crontab as well (on multiple lines, perhaps with different schedules). Very
    useful indeed!
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to quickly look up what the deal with the crontab was, you
    would of course check out `man crontab`. However, what we haven't told you yet
    is that some commands actually have more than one man page! By default, `man crontab`
    is shorthand for `man <first-manpage> crontab`. On that page, you'll see the sentence,
    "SEE ALSO crontab(5), cron(8)". By supplying this number with `man 5 crontab`,
    you'll see a different page where many of the concepts of this chapter (syntax,
    environment variables, and examples) are easily accessible to you.
  prefs: []
  type: TYPE_NORMAL
- en: Final logging considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might consider having your script take care of its own logging. While this
    is certainly possible, (although a little complex and not very readable), we feel
    strongly that **it is the responsibility of the caller to take care of logging**.
    If you find a script that takes care of its own logging, you might encounter some
    of the following issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple users run the same script at different intervals, to a single log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log file needs to have robust user permissions to ensure correct exposure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both ad hoc and scheduled runs will appear in the log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simply put, delegating the responsibility of logging to the script itself is
    asking for trouble. For an ad hoc command, you get the output right in your Terminal.
    If you need it for any other purpose, you can always copy and paste it somewhere,
    or redirect it. Even more probable is running the script with a pipe to `tee`,
    so output is shown to your Terminal *and* saved to a file at the same time. For
    scheduled runs from `cron`, you need to think once about redirection: when you
    create the schedule. In this case, especially if you use the Bash 4.x construct
    of `&>>`, you will always see all output (stdout and stderr) appended to the file
    you specify. In this, there is almost no risk of missing any output. Remember:
    `tee` and redirections are your friends, and when used properly they make a great
    addition to any script scheduling!'
  prefs: []
  type: TYPE_NORMAL
- en: If you want your cron logging mechanism to be *really fancy*, you can set up
    `sendmail` (or other software such as `postfix`) as an actual Mail Transfer Agent
    (very out of the scope of this book, but check the *Further reading* section!).
    If that is correctly configured, you can set the MAILTO variable in the crontab
    to an actual email address (perhaps `yourname@company.com`), and receive the reports
    from scheduled jobs in your normal email box. This is best used with important
    scripts that do not run too often; otherwise, you will just end up with an annoying
    amount of email.
  prefs: []
  type: TYPE_NORMAL
- en: A note on verbosity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to realize that, just as it is on the command-line directly,
    only output (stdout/stderr) is logged. By default, most commands that run successfully
    do not have any output; examples of these are `cp`, `rm`, `touch`, and so on.
    If you want informative logging in your scripts, it is your responsibility to
    add output where you see fit. The easiest way to accomplish this is by simply
    using an `echo` here and there. The easiest way to make a log file give confidence
    to the user is by having the final command in your scripts be `echo "Everything
    went well, exiting script."`. As long as you handle all potential errors properly
    during your script, you can safely say that once it reaches the final command
    the execution has succeeded, and you can notify the user of this. If you do not
    do this, the log file might stay empty, which can be kind of scary; is it empty
    because everything succeeded *or because the script did not even run*? This is
    not something you want to take a chance on, especially not when a simple `echo`
    can save you all that trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by showing the new `at` command and explaining how we
    can use `at` for scheduling scripts. We described the timestamp syntax for `at` and
    how it contains a queue for all scheduled jobs. We explained how `at` is mostly
    used for ad hoc scheduled commands and scripts, before we continued to the more
    powerful `cron` scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: The `cron` daemon, responsible for most scheduled tasks on a system, is a very
    powerful and flexible scheduler, which is most often used via the so-called crontab.
    This is a user-bound file, which contains instructions for `cron` on when and
    how to run commands and scripts. We presented the timestamp syntax that is used
    in a crontab.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the chapter dealt with logging our scheduled commands and
    scripts. When a command is run interactively on the command line, there is no
    need for dedicated logging, but scheduled commands are not interactive, and thus
    need additional mechanisms. Output from scheduled commands can either be mailed
    to a local file with the `sendmail` process, or redirected to a log file using
    the redirection possibilities we outlined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We ended the chapter with some final considerations on logging: how it should
    always be the responsibility of the caller to arrange logging, and how it is the
    responsibility of the script author to make sure a script is verbose enough to
    be used non-interactively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `at`, `wall`, `atq`,
    `atrm`, `sendmail`, `crontab`, and `alias`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is scheduling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do we mean by ad hoc scheduling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the output of commands run with `at` normally go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is scheduling for the `cron` daemon most often implemented?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which commands allow you to edit your personal crontab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which five fields are present in the crontab timestamp syntax?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which are the three most important environment variables for the crontab?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we inspect the output for scripts or commands we have scheduled with
    `cron`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If our scheduled scripts do not have enough output for us to effectively work
    with log files, how should we remedy this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profile and Bashrc**: [https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/](https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set up a Mail Transfer Agent with postfix**: [https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/](https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
