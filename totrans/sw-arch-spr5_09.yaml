- en: Serverless Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless architectures are becoming a popular trend in IT system building.
    As a consequence, it's quite common to hear people discussing cloud providers
    such as **Amazon Web services** (**AWS**), Google Cloud, and Microsoft Azure,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the meaning of serverless architecture and
    how this new way of building systems can help us to address business requirements
    in shorter amounts of time, thus reducing the effort required to build business
    solutions. We will also look at how this approach can be used to drastically reduce
    the time required to reach production by utilizing ready-to-use, third-party services
    and implementing custom functionalities, thereby creating stateless functions
    that can be deployed on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to serverless architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and file storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend as a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function as a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concerns about serverless architectures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor lock-in concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples and commons uses of serverless architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing applications using serverless architecture:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write functions with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using adapters for AWS Lambda and Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to serverless architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless architecture was born through the initiative of Amazon. The company
    was looking to promote an environment wherein a development team could be autonomous,
    small, and self-managed, allowing it to work on the whole software development
    cycle, from writing the code to shipping and delivering to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serverless architecture is sometimes misunderstood as the concept of software
    systems that are deployed without the need for a physical server. To understand
    this idea, you can review the definition of serverless in Martin Fowler''s blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '"It''s important to understand that a serverless architecture is the approach
    in which developers code business logic as functions, forgetting about the server''s
    provisioning and scaling concerns where the logic will be executed."'
  prefs: []
  type: TYPE_NORMAL
- en: '- [https://martinfowler.com/articles/serverless.html](https://martinfowler.com/articles/serverless.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common examples of serverless and FaaS include:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, within a serverless world, it's common to create applications
    in which third-party services are adopted as a part of the system (rather than
    creating services from scratch). These services are commonly known as **backend
    as a service** (**BaaS**) or **mobile backend as a service** (**MBaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: Following the same approach, we can code our custom business logic in the form
    of functions that can be deployed on the cloud. These services are known as **function
    as a service** (**FaaS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how third-party services and custom functions
    are created, deployed, and consumed by different software systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a9521c5-ac3c-4b18-a3aa-55abc5441088.png)'
  prefs: []
  type: TYPE_IMG
- en: Third-party services and custom functions
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure and file storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure and file storage are also considered serverless, because the
    business (or person) that owns the system does not have to purchase, rent, or
    provision servers or virtual machines to use them.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, if we take the old-fashioned approach (provisioning all of the
    infrastructure by using an on-premise environment), we have to set up all of the
    software and hardware requirements for every environment in which we want to deploy
    our software systems. This provisioning process has to be repeated for all of
    the environments, until we get into production, at which point we have to take
    care of other features, such as scaling and monitoring. In many cases, our infrastructure
    will be under-utilized, which is a waste of money, since we have purchased powerful
    servers to deploy applications that don't need many resources.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adopting a serverless architecture approach to creating applications provides
    us with many benefits, but there are also some pitfalls that we should address.
    Let''s start by reviewing the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers using a serverless architecture can focus primarily on the code,
    and can forget everything related to provisioning servers, which is a task handled
    by the cloud provider itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scaling of the code is ephemeral, meaning that it can be scaled and can
    spin up or down, based on the number of requests retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By definition, all of the functions used to code the business logic must be
    stateless, and therefore, loosely coupled. In this way, the tasks are focused
    on well-defined responsibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions can be asynchronously triggered by events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We only have to pay for the compute time consumed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions base their functionality on an event-driven model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinite scaling can be achieved for developers in a transparent way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, there are also some pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: A lack of documentation and showcases that can be used as references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latency issues that are introduced when many services have to be consumed at
    the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some features are only available from certain cloud providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor lock-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to tackle the pitfall of vendor lock-in, it is highly recommended to
    use a **polycloud** approach as a part of a serverless architecture. A polycloud
    strategy involves using more than one cloud provider. This is important because,
    with it, we can take advantage of the strengths of different vendors and different
    products. For example, Google offers awesome services for machine learning, AWS
    provides a wide variety of standard services, and Microsoft Azure has awesome
    features for functions such as remote debugging. On the other hand, cloud-agnostic strategies
    recommend that we avoid sticking to a determined cloud provider as much as possible,
    in order to have the freedom to deploy systems whenever we want to. However, this
    would be difficult to achieve, because it would mean designing systems in a more
    generic way, ignoring specific vendor features that offer additional advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Backend as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest scenario for using a BaaS approach occurs when we create **single
    page applications** (**SPA**), or mobile apps that interact with services available
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: It's common to find applications wherein the authentication process is delegated
    to third-party services, using standard protocols (such as OAuth), persisting
    information in cloud databases (such as Google Firebase), or sending notifications
    via SMS services (such as Twilio).
  prefs: []
  type: TYPE_NORMAL
- en: 'BaaS can help us with several concerns out of the box so that we can deploy
    into the production environment without having to worry about the server or virtual
    machine of the application. In addition, BaaS also provides us with a whole infrastructure
    and nodes, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database to store our data (NoSQL or RDBMS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queue servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BaaS also takes care of the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Backup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, BaaS has increased the birth of new products as services,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Firebase**: This provides us with features such as analytics, databases,
    messaging, and crash reporting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon DynamoDB**: This key-value of the store is a non-relational database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Cosmos DB**: This is a globally distributed, multi-model database service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of these changes and new tools, we have to embrace a new way of thinking
    and break the paradigms of how we build our applications. As serverless is a new
    technology, it is recommended to experiment, starting with using a small piece
    of an application. Think of three examples from your current applications that
    would be interesting to refactor using a serverless approach. Now, confer with
    your team and organize an Architectural Clash ([http://architecturalclash.org/](http://architecturalclash.org/))
    workshop to identify whether or not your ideas are feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Function as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since AWS Lambda gained popularity in 2014, the use of code implemented as functions
    has become increasingly popular. In some cases, there is even the option to build
    a whole application using a FaaS approach; in other cases, the approach is used
    to solve specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Code deployed in the form of functions is executed when an event occurs. Once
    the event happens, the code is executed, and the function is then shut down. For
    that reason, functions are stateless by nature, since there is no state or context
    to share with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A FaaS is ephemeral, meaning that when a function needs to be executed, the
    cloud provider will automatically provision an environment using the metadata
    associated with the function. This will scale depending on the processing needs,
    and, once the processing has finished, the execution environment will be destroyed,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b51d091-c38d-4713-88ff-3f1775474b06.png)'
  prefs: []
  type: TYPE_IMG
- en: Ephemeral FaaS process
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing code using a FaaS approach will provide you with the following
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You won't have to worry about host configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent scale-up on demand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic spin up/down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will only pay for what you use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns about serverless architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New technology trends sometimes create resilience and concerns, but they also
    provide the opportunity to experiment and gain benefits for applications and business.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common concerns involved in serverless architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Vendor lock-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor lock-in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With vendor lock-in, the main concern is the impossibility of embracing new
    services as part of the vendors' serverless architecture. This concern comes down
    to a fear of being locked in with a cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use as many features as you can of the cloud provider of
    your choosing. You can do so by starting a pilot and evaluating the cloud provider;
    be sure to create an assessment of pros and cons before moving more code onto
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Don't let this concern put you off of using serverless architecture. Instead,
    it is recommended to start a proof of concept and evaluate the cloud provider.
    Serverless is a new technology that will evolve with time, and there are ways
    to keep FaaS independent, such as by using Spring Cloud functionality. We will
    work on an example of this in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you should understand that moving to another vendor (from cloud-to-cloud)
    is not as difficult as it was in the past (when we were moving our application
    or legacy code to on-premises environments).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a key concern, independent of the architecture of the application,
    and serverless is no exception. Since we are creating functions as services in
    the cloud, we need to take care in our authentication, authorization of execution,
    and the OWASP. However, in this context, the cloud provider—such as AWS or Azure—provides
    us with guides and practices out of the box, in order to minimize our concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Another security concern to consider in serverless is the lack of a clearly
    shaped security perimeter. In other words, when the security perimeter of one
    of the functions ends and another starts, different cloud providers provide different ways
    to make those functions work as a whole; for example, AWS does this by using a
    service called an API Gateway. This API is used to orchestrate and compose the
    created FaaS. On the other hand, as is the case with everything that is ephemeral,
    many of these concerns may go away because the concept of ephemeral in FaaS is
    that the function will be created, run, and destroyed as many requests received
    on there are isolated each time that the FaaS is called.
  prefs: []
  type: TYPE_NORMAL
- en: To clarify any concerns, we will start to move some of our code to serverless/FaaS,
    creating an experimental development and incrementing when we feel more confident
    with the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Framework support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several frameworks working to create environments that develop serverless
    architectures without being attached to the cloud provider. In my experience,
    it is preferable to create functions as services that exploit the cloud platform
    as much as possible. As a function is a small piece of code with a clear input
    or output, it is better to use the language and technology that you feel comfortable
    with, or even to try new technologies or programming languages, in order to determine
    how good they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, serverless supports several languages for building functions.
    Currently, the most common options to deploy FaaS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lamba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One benefit for Java developers is that most cloud providers offer support for
    Java as a programming language to deploy functions. Moreover, Spring Framework
    has a project named Spring Functions that can be used to code functions; we will
    implement some functionality using this project later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of using Spring Functions is that we can develop and test our code
    in our local machine, and then wrap the code using an adaptor, in order to deploy
    it on a cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an application (or function, in this case) is deployed into production,
    one of the key aspects to consider is how to trace, find, and fix bugs. With serverless,
    this can be tricky, because we are dealing with a more segregated scenario, and
    our system has small parts that are not divided into services and microservices.
    Several functions are smaller pieces of logic and code. To deal with this concern,
    each cloud provider has tools to monitor and trace functions, dealing with one
    error in an ephemeral environment. If we compose logic for several functions,
    we will have to apply techniques like aggregate logging and use tools to collect
    information associated with the executed code. We will review some techniques
    to deal with this concept in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml), *Monitoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Examples and common use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when a serverless architecture provides us with a lot of benefits, those
    benefits cannot be applied to everything. It's quite common to find applications
    using hybrid models, when an application consumes a backend deployed on a traditional
    server (on-premise or cloud-based) and also using FaaS or third-party services
    for specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common scenarios that serverless architectures can be applied to are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks or jobs that should be scheduled or triggered under certain circumstances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data transformation, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image manipulation, compression, or conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voice data transcribed into text, such as Alexa or Cortana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A certain logic for mobile applications, based on the mobile backend as a service
    approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-page applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chatbots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, serverless architectures are not suitable for the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Long-running processes where huge amounts of resources (such as CPU and memory)
    are required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any blocking processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting serverless architectures for SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Single-page applications (SPAs)** provide one of the most suitable scenarios
    for adopting a serverless architecture approach. After all, they do not involve
    much-coded business logic, and they mainly serve and consume content provided
    by services deployed somewhere else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that we need to build an application to send the World
    Cup results to users. In this example, we will need to address the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a serverless architecture approach, these requirements can be addressed
    by the following service providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Google OAuth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data** **storage**: Google Firebase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification** **mechanisms**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS, using Twilio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email, using SparkPost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how to use the preceding services (Google
    OAuth, Firebase, Twilo, and SparkPost) as parts of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72855d45-d8aa-4459-aed9-b2b8d8f7c805.png)'
  prefs: []
  type: TYPE_IMG
- en: Integrating different third-party applications
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows some of the most well-known service providers, but
    there are a lot of other options available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of the preceding services is that all of them provide an
    SDK, or library, that can be used directly from an SPA, including common JavaScript
    libraries, such as Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FaaS with Spring Cloud Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the umbrella of Spring projects, you will find the Spring Cloud Function
    project ([https://cloud.spring.io/spring-cloud-function/](https://cloud.spring.io/spring-cloud-function/)),
    which is designed to implement applications using a serverless architecture model.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Function, we can code functions that can be launched on different
    cloud providers that support FaaS. There's no need to learn something new from
    scratch, because all of the core concepts and main features of Spring Framework,
    such as autoconfiguration, dependency injection, and built-in metrics, are applied
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Once a function has been coded, it can be deployed as a web endpoint, a stream
    processor, or simple tasks that are triggered by certain events or via a scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at an example of an SPA, we can implement an application using third-party
    services, the existing REST API, and custom functions. The following diagram illustrates
    how an application can be created by using all of the previously mentioned options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b25759bc-4d9f-4662-8f0a-5eb4b4059b00.png)'
  prefs: []
  type: TYPE_IMG
- en: Integrating FaaS in applications
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review how the components in the preceding diagram work:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is provided by a third-party service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application uses the business logic that resides in the REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom function can be used as a part of the SPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how a function works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/031689ad-d967-430b-ba3a-5fb17771f1a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Function as a service
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review each part of the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions provide a way to use an event-driven programming model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can scale infinitely, in a way that is transparent to developers. This scale
    will be handled by the platform that we use to deploy the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we only pay for the time and resources consumed by the functions during
    their execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Function brings us four main features, described in detail in
    the official documentation ([https://github.com/spring-cloud/spring-cloud-function](https://github.com/spring-cloud/spring-cloud-function)),
    that are worth mentioning here:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides the ability to wrap the `@Beans` type of function, consumer, and
    supplier. This makes it possible to expose functionalities as HTTP endpoints and
    stream messaging via listeners or publishers, with a message broker such as RabbitMQ,
    ActiveMQ, or Kafka.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides compiled strings, which will be wrapped as function bodies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can deploy a JAR file with our function, with an isolated classloader that
    will run on a single Java virtual machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It provides adaptors for different cloud providers that support serverless
    architecture, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Whisk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create a function that masks bank account numbers. Let''s start
    by creating a new Spring Boot application from scratch, using the Spring Initializr
    website ([https://start.spring.io](https://start.spring.io)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5619b314-f7dd-441d-8b7e-58b911dac1ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Initializr website
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, there''s no need to include additional dependencies as a part
    of the project. The project structure is pretty simple, and it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3436649-226c-4e1e-81d8-212a23d10aae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to write functions using Spring, we have to include the Spring Cloud
    Function project as a dependency; first, let''s add some properties to specify
    the version that we are going to use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that we will downgrade the Spring version to 1.5.11 RELEASE, because Spring
    Cloud Function is not currently ready to be used in Spring Boot 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add the dependency, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to add an entry as a part of the dependency management section,
    to allow Maven to automatically resolve all transitive dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will include some plugins that will allow us to wrap the coded
    functions, by adding the following entries as a part of the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to implement a function to mask account numbers. Let''s review
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `@FunctionScan` annotation is used to allow the Spring Function adapter
    to find the beans that will be deployed as functions in the cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function has been coded, we will register it using the `application.properties`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to execute the function locally, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the artifact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the generated artifact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72edff3a-1d89-4adc-8184-d35a64d8f2b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Console output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to execute the function using the following `CURL` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we will get a masked account number: `****7979`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review how to deploy the function using different
    cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create an account on any cloud provider, such as AWS or Azure, you
    will need a credit or debit card, even if the provider offers free tiers.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Function provides adapters for different cloud providers, in order
    to deploy the coded business logic using functions. At the moment, there are adapters
    for use with the following cloud providers:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache OpenWhisk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will cover how these adapters can be used.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Lambda adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project was designed to allow for deploying applications that use Spring
    Cloud Function to AWS Lambda ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)).
  prefs: []
  type: TYPE_NORMAL
- en: This adapter is a layer over the Spring Cloud Function application that lets
    us deploy our functions into AWS.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the sources of the project on GitHub, at the following link: [https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-aws)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using the AWS Lambda adaptor, we have to add it as a dependency of the
    project. Let''s start by defining some properties inside of the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to add the required dependencies for AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add it to the `dependency` management section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add it to the `plugin` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will write a class that will work as an adapter for AWS. This adaptor
    should extend the `SpringBootRequestHandler` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the adapter has been written, we will need to modify the previously implemented
    function as a part of the `MaskAccountsApplication.java` file. Here, we are going
    to change the name of the method to `function`, and the input and output of the
    function will be **plain old Java objects (POJOs)** with setters and getters,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to wrap the coded function, we have to create a JAR file, using the
    following Maven goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the JAR file has been created, we can use the **command-line interface
    (CLI)** provided by AWS ([https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)) to
    upload the generated JAR file, by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `[USERID]` quote is based on your AWS account and the `[ROLE]` quote. If
    you have any doubts about how to create an AWS account, go to [https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/](https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account/).
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the AWS lambda `create-function`, refer to [https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html](https://docs.aws.amazon.com/cli/latest/reference/lambda/create-function.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't set the credentials of your AWS account, you will get an error
    message that states *unable to locate credentials. *You can configure credentials
    by running the `aws configure` command.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that you will need to create an AWS user with a a role with permission
    to run AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function has been successfully deployed, you will see an output similar
    to the following in the Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57d6acad-a6b3-4bc5-b37f-4a64f0b6bfb8.png)'
  prefs: []
  type: TYPE_IMG
- en: Output processing
  prefs: []
  type: TYPE_NORMAL
- en: 'The recently deployed function will now be listed in the AWS Lambda console,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/497b329e-d515-4d71-bfa6-988174f78986.png)'
  prefs: []
  type: TYPE_IMG
- en: AWS Lambda console
  prefs: []
  type: TYPE_NORMAL
- en: If you don't see the recently deployed function in the web console, you must
    review the location where your function was created. In the example, we use the
    `us-east-1` region, which means that the function was deployed in North Virginia.
    You can check this value next to your name, at the top of the AWS Lambda console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are going to test our results in the AWS Lambda console. In the
    Test section, create some input with the value to mask, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the AWS console, you will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94c8f09d-15a3-4f65-a962-5996869afc54.png)'
  prefs: []
  type: TYPE_IMG
- en: AWS console test result for the maskAccount function
  prefs: []
  type: TYPE_NORMAL
- en: Azure adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review how to deploy the previously coded function
    to Azure, which is a cloud provider supported by Microsoft. Azure supports functions
    by using Microsoft Azure Functions ([https://azure.microsoft.com/en-us/services/functions/](https://azure.microsoft.com/en-us/services/functions/)).
  prefs: []
  type: TYPE_NORMAL
- en: The Azure adapter is a layer coded over the Spring Cloud Function project. You can
    find the source of the project on GitHub ([https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure](https://github.com/spring-cloud/spring-cloud-function/tree/master/spring-cloud-function-adapters/spring-cloud-function-adapter-azure)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the following properties as a part of the `pom.xml`
    file, in the properties section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the required dependencies for this adapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add some plugins to allow the adapter to work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create an adapter that should extend from the `AzureSpringBootRequestHandler`
    class. The extended class will provide us with the input and output types that
    enable Azure functions to inspect the class and perform any JSON conversion to
    consume/produce data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will modify the coded function that resides in the `MaskAccountsApplication.java`
    file; we will change the input and output of the function, in order to use a plain
    old Java object with setters and getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have to add a JSON configuration for Azure tooling, so we are going
    to create a JSON file named `function.json`, in a new folder behind the `src/main`
    folder, with the name of the function (`maskAccount`). This file will be used
    to let Azure know about the function that we want to deploy, by specifying the Java
    class that will be used as the entry point. The `src` folder should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d28f945-e2ae-4bfe-be18-6615a4c454bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The content of the `function.json` file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The JSON files can be created with the Maven plugin for a non-Spring function,
    but the tooling doesn't work with the current version of the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Before generating the artifact that will be deployed, we have to create an `assembly`
    file, which is required by the Azure Maven plugin that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `assembly` file should be placed in the `src/assembly` directory; the file
    will be named `azure.xml`, and will include the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the JAR file can be created by using the following Maven goals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The function can be deployed locally for testing purposes, running the JAR
    file as a regular Java application by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will then see that the application is running, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe28fac1-dd85-46d3-9921-855ee63b06f2.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of the Spring application, running locally
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out the function using the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bec9055-4f45-4f7b-aaf2-a005b7643f36.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, we can deploy our function to Azure using Azure Functions Core
    Tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, first, you have to install all of the required tools using the information
    provided at [https://github.com/azure/azure-functions-core-tools#installing](https://github.com/azure/azure-functions-core-tools#installing).
    Once the required tools have been installed, you can log in to Azure using the
    following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have entered your credentials, you will see the following output on
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/683acc84-c48f-4b65-a0c9-4ea33ab015eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Deploying the coded function to Azure is pretty simple; you only have to execute
    the following Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can try out the deployed function using the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<azure-function-url-from-the-log>` is the URL that you will get after
    running the `mvn azure-functions:deploy` command. For example, in the following
    screenshot, you can see the `https://function-mask-account-azure.azurewebsites.net/` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3e9e981-a55c-4bd2-9b70-7461ebc86e42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After executing the `curl` command, the output received will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6028e45a-7c53-484f-abf8-a551e65a7c10.png)'
  prefs: []
  type: TYPE_IMG
- en: Output processing
  prefs: []
  type: TYPE_NORMAL
- en: We can also test the same function on the Azure Functions console, just as we
    did with AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the concepts behind serverless architecture. You
    learned how functions can be implemented using Spring Cloud Functions, and we
    reviewed the adapters that can be used to deploy the functions in different cloud
    providers, such as AWS Lambda and Microsoft Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe what containers are, and how you can use
    them to containerize applications.
  prefs: []
  type: TYPE_NORMAL
