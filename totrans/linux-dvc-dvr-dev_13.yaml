- en: Linux Device Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until version 2.5, the kernel had no way to describe and manage objects, and
    the code reusability was not as enhanced as it is now. In other words, there was
    no device topology nor organization. There was no information on subsystem relationships
    nor on how the system is put together. Then came the **Linux Device Model** (**LDM**
    ), which introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of class, to group devices of the same type or devices that expose
    the same functionalities (for example, mice and keyboards are both input devices).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with the user space through a virtual filesystem called `sysfs`
    , in order to let user space manage and enumerate devices and the properties they
    expose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management of object life cycle, using reference counting (heavily used in managed
    resources).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Power management in order to handle the order in which devices should shut down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reusability of the code. Classes and frameworks expose interfaces, behaving
    like contract that any driver that registers with them must respect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDM brought an **Object Oriented** (**OO** )-like programming style in the kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will take advantage of LDM and export some properties to
    the user space through the `sysfs` filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LDM data structures (Driver, Device, Bus)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering kernel objects by type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with the kernel `sysfs` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDM data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal is to build a complete DT that will map each physical device present
    on the system, and introduce their hierarchy. One common and generic structure
    has been created to represent any object that could be a part of the device model.
    The upper level of LDM relies on the bus represented in the kernel as an instance
    of `struct bus_type` ; device driver, represented by a `struct device_driver`
    structure, and device, which is the last element represented as an instance of
    the `struct device` structure. In this section, we will design a bus driver packt
    bus, in order to get deep into LDM data structures and mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The bus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A bus is a channel link between devices and processors. The hardware entity
    that manages the bus and exports its protocol to devices is called the bus controller.
    For example, the USB controller provides USB support. The I2C controller provides
    I2C bus support. Therefore, the bus controller, being a device on its own, must
    be registered like any device. It will be the parent of devices that need to sit
    on the bus. In other words, every device sitting on the bus must have their parent
    field pointing to the bus device. A bus is represented in the kernel by the `struct
    bus_type` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of elements in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`match` : This is a callback, called whenever a new device or driver is added
    to the bus. The callback must be smart enough and should return a nonzero value
    when there is a match between a device and a driver, both given as parameters.
    The main purpose of a `match` callback is to allow a bus to determine if a particular
    device can be handled by a given driver or the other logic, if the given driver
    supports a given device. Most of the time, the verification is done by a simple
    string comparison (device and driver name, of table and DT compatible property).
    For enumerated devices (PCI, USB), the verification is done by comparing the device
    IDs supported by the driver with the device ID of the given device, without sacrificing
    bus-specific functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`probe` : This is a callback when a new device or driver is added to the bus,
    after the match has occurred. This function is responsible for allocating the
    specific bus device structure, and call the given driver''s `probe` function,
    which is supposed to manage the device (allocated earlier).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove` : This is called when a device is to removed from the bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suspend` : This is a method called when a device on the bus needs to be put
    into sleep mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume` : This is called when a device on the bus has to be brought out of
    sleep mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pm` : This is a set of power management operations of the bus, which will
    call the specific device driver''s `pm-ops` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drv_groups` : This is a pointer to a list (array) of `struct attribute_group`
    elements, each of which has a pointer to a list (array) of `struct attribute`
    elements. It represents the default attributes of the device drivers on the bus.
    Attributes passed to this field will be given to every driver registered with
    the bus. Those attributes can be found in the driver''s directory in `/sys/bus/<bus-name>/drivers/<driver-name>`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_groups` : This represents the default attributes of the devices on the
    bus. Attributes passed (through the list/array of the `struct attribute_group`
    elements) to this field will be given to every device registered with the bus.
    Those attributes can be found in the device directory in `/sys/bus/<bus-name>/devices/<device-name>.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bus_group` : This holds the set (group) of default attributes added automatically
    when the bus is registered with the core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from defining a `bus_type` , the bus controller driver must define a bus-specific
    driver structure that extends the generic `struct device_driver` , and a bus-specific
    device structure that extends the generic `struct device` structure, both part
    of the device model core. The bus drivers must also allocate a bus-specific device
    structure for each physical device discovered when probing, and is responsible
    for initializing the `bus` and `parent` fields of the device and registering the
    device with the LDM core. Those fields must point to the bus device and the `bus_type`
    structures defined in the bus driver. The LDM core uses that to build the device
    hierarchy and initialize the other fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the following are two helper macros to get the packt device
    and the packt driver, given a generic `struct device` and `struct driver` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And then comes the structure used to identify a packt device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are packt-specific devices and driver structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each bus internally manages two important lists; the list of devices added and
    sitting on it, and the list of driver registered with it. Whenever you add/register
    or remove/unregister a device/driver to/from the bus, the corresponding list is
    updated with the new entry. The bus driver must provide helper functions to register/unregister
    device drivers that can handle devices on that bus, as well as helper functions
    to register/unregister devices sitting on the bus. These helper functions always
    wrap the generic functions provided by the LDM core, which are `driver_register()`
    , `device_register()` , `driver_unregister` , and `device_unregister()` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function used to allocate packt devices is as follows. One must use this
    to create an instance of any physical device sitting on the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Bus registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bus controller is a device itself, and in 99% of cases buses are platform
    devices (even buses that offer enumeration). For example, PCI controller is a
    platform device, so is its respective driver. One must use the `bus_register(struct
    *bus_type)` function in order to register a bus with the kernel. The packt bus
    structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The bus controller is a device itself, it has to be registered with the kernel,
    and will be used as a parent of the device siting on the bus. This is done in
    the bus controller''s `probe` or `init` function. In the case of the packt bus,
    the code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When a device is registered by the bus controller driver, the parent member
    of the device must point to the bus controller device and its bus property must
    point to the bus type to build the physical DT. To register a packt device, one
    must call `packt_device_register` , given as an argument allocated with `packt_device_alloc`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Device driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A global device hierarchy allows each device in the system to be represented
    in a common way. This allows the core to easily walk the DT to create such things
    as properly ordered power management transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`struct device_driver` defines a simple set of operations for the core to perform
    these actions on each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`* name` represents the driver''s name. It can be used for matching, by comparing
    with the device name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* bus` represents the bus the driver sits on. The bus driver must fill this
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module` represents the module owning the driver. In 99% of cases, one should
    set this field to `THIS_MODULE` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_match_table` is a pointer to the array of `struct of_device_id` . The `struct
    of_device_id` structure is used to perform OF match through a special file called
    DT, passed to the kernel during the boot process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`suspend` and `resume` callbacks provide power management functionality. The
    `remove` callback is called when the device is physically removed from the system,
    or when its reference count reaches `0` . The `remove` callback is also called
    during system reboot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`probe` is the probe callback that runs when attempting to bind a driver to
    a device. The bus driver is in charge of calling the device driver''s `probe`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group` is a pointer to a list (array) of `struct attribute_group` , used as
    a default attribute for the driver. Use this method instead of creating an attribute
    separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device driver registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`driver_register()` is the low-level function used to register a device driver
    with the bus. It adds the driver to the bus''s list of drivers. When a device
    driver is registered with the bus, the core walks through the bus''s list of devices
    and calls the bus''s match callback for each device that does not have a driver
    associated with it in order to find out if there are any devices that the driver
    can handle.'
  prefs: []
  type: TYPE_NORMAL
- en: When a match occurs, the device and the device driver are bound together. The
    process of associating a device with a device driver is called binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to the registration of drivers with our packt bus, one has to use
    `packt_register_driver(struct packt_driver *driver)` , which is a wrapper around
    `driver_register()` . The `*driver` parameter must have been filled prior to registering
    the packt driver. The LDM core provides helper functions for iterating over the
    list of drivers registered with the bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This helper iterates over the bus's list of drivers, and calls the `fn` callback
    for each driver in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The struct device is the generic data structure used to describe and characterize
    each device on the system, whether it is physical or not. It contains details
    about the physical attributes of the device, and provides proper linkage information
    to build suitable device trees and reference counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`* parent` represents the device''s parent, used to build device tree hierarchy.
    When registered with a bus, the bus driver is responsible for setting this field
    with the bus device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* bus` represents the bus the device sits on. The bus driver must fill this
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* type` identifies the device''s type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kobj` is the kobject in handle reference counting and device model support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* of_node` is a pointer to the OF (DT) node associated with the device. It
    is up to the bus driver to set this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform_data` is a pointer to the platform data specific to the device. Usually
    declared in a board-specific file during device provisioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_data` is a pointer to private data for the driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class` is a pointer to the class that the device belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* group` is a pointer to a list (array) of `struct attribute_group` , used
    as the default attribute for the device. Use this method instead of creating the
    attribute separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release` is a callback called when the device reference count reaches zero.
    The bus has the responsibility of setting this field. The packt bus driver shows
    you how to do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`device_register` is the function provided by the LDM core to register a device
    with the bus. After this call, the bus list of drivers is iterated over to find
    the driver that supports this device and then this device is added to the bus''s
    list of devices. `device_register()` internally calls `device_add()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper function provided by the kernel to iterate over the bus''s list
    of devices is `bus_for_each_dev` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a device is added, the core invokes the match method of the bus driver
    (`bus_type->match` ). If the match function says there is a driver for this device,
    the core will invoke the `probe` function of the bus driver (`bus_type->probe`
    ), given both device and driver as parameters. It is then up to the bus driver
    to invoke the `probe` method of the device's driver (`driver->probe` ). For our
    packt bus driver, the function used to register a device is `packt_device_register(struct
    packt_device *packt)` , which internally calls `device_register` , and where the
    parameter is a packt device allocated with `packt_device_alloc` .
  prefs: []
  type: TYPE_NORMAL
- en: Deep inside LDM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LDM under the wood relies on three important structures, which are kobject,
    kobj_type, and kset. Let us see how each of these structures are involved in the
    device model.
  prefs: []
  type: TYPE_NORMAL
- en: kobject structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kobject is the core of the device model, running behind the scenes. It brings
    an OO-like programming style to the kernel, and is mainly used for reference counting
    and to expose devices hierarchies and relationships between them. kobjects introduce
    the concept of encapsulation of common object properties such as usage reference
    counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`name` points to the name of this kobject. One can change this using the `kobject_set_name(struct
    kobject *kobj, const char *name)` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent` is a pointer to this kobject''s parent. It is used to build a hierarchy
    to describe the relationship between objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sd` points to a `struct sysfs_dirent` structure that represents this kobject
    in sysfs inode inside this structure for sysfs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kref` provides reference counting on the kobject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ktype` describes the object, and `kset` tells us which set (group) of objects
    this object belongs to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each structure that embeds a kobject is embedded and receives the standardized
    functions that kobjects provide. The embedded kobject will enable the structure
    to become a part of an object hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `container_of` macro is used to get a pointer on the object to which the
    kobject belongs. Every kernel device directly or indirectly embeds a kobject property.
    Prior to be added to the system, the kobject must be allocated using `kobject_create()`
    function, which will return an empty kobject that one must initialize with `kobj_init()`
    , given as a parameter the allocated and non-initialized kobject pointer, along
    with its `kobj_type` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kobject_add()` function is used to add and link a kobject to the system,
    at the same time creating its directory according to its hierarchy, along with
    its default attributes. The reverse function is `kobject_del()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse function of both `kobject_create` and `kobject_add` is `kobject_put`
    . In the source provided with the book, the excerpt to tie a kobject to the system
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One could have used `kobject_create_and_add` , which internally calls `kobject_create
    and kobject_add` . The following excerpt from `drivers/base/core.c` shows how
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If a kobject has a `NULL` parent, then `kobject_add` sets parent to kset. If
    both are `NULL` , object becomes a child-member of the top-level sys directory
  prefs: []
  type: TYPE_NORMAL
- en: kobj_type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `struct kobj_type` structure describes the behavior of kobjects. A `kobj_type`
    structure describes the type of object that embeds a kobject by means of `ktype`
    field. Every structure that embeds a kobject needs a corresponding `kobj_type`
    , which will control what happens when the kobject is created and destroyed, and
    when attributes are read or written to. Every kobject has a field of the type
    `struct kobj_type` , which stands for **kernel object type** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A `struct kobj_type` structure allows kernel objects to share common operations
    (`sysfs_ops` ), whether those objects are functionally related or not. Fields
    of that structure are meaningful enough. `release` is a callback called by the
    `kobject_put()` function whenever your object needs to be freed. You must free
    memory held by your object here. One can use the `container_of` macro to get a
    pointer to the object. The `sysfs_ops` field points to sysfs operations, whereas
    `default_attrs` defines the default attributes associated with this kobject. `sysfs_ops`
    is a set of callback (sysfs operation) called when a sysfs attribute is accessed.
    `default_attrs` is a pointer to a list of `struct attribute` elements that will
    be used as default attributes for each object of this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`show` is the callback called when one reads an attribute of any kobject which
    has this `kobj_type` . The buffer size is always `PAGE_SIZE` in length, even if
    the value to show is a simple `char` . One should set the value of `buf` (using
    `scnprintf` ), and return the size (in bytes) of data actually written into the
    buffer on success or negative error on failure. `store` is called for write purposes.
    Its `buf` parameter is at most `PAGE_SIZE` but can be smaller. It returns the
    size (in bytes) of data actually read from buffer on success or negative error
    on failure (or if it receives an unwanted value). One can use `get_ktype` to get
    the `kobj_type` of a given kobject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example in the book, our `k_type` variable represents our kobject''s
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `show` and `store` callbacks are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ksets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kernel object sets** (**ksets** ) mainly group related kernel objects together.
    ksets are collection of kobjects. In other words, a kset gathers related kobjects
    into a single place, for example, all block devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`list` is a linked list of all kobjects in the kset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_lock` is a spinlock protecting linked list access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kobj` represents the base class for the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each registered (added to the system) kset corresponds to a sysfs directory.
    A kset can be created and added using the `kset_create_and_add()` function, and
    removed with the `kset_unregister()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a kobject to the set is as simple as specifying its kset field to the
    right kset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the module `exit` function, after kobject and their attributes have
    been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes are sysfs files exported to the user space by kobjects. An attribute
    represents an object property that can be readable, writable, or both, from the
    user space. That said, every data structure that embeds a struct kobject can expose
    either default attributes provided by the kobject itself (if any), or custom ones.
    In other words, attributes map kernel data to files in sysfs.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attribute definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel functions used to add/remove attributes from the filesystem are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us try to define two properties that we will export, each represented by
    an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To create each enumerated attribute separately, we have to call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A good place to start with attributes is `samples/kobject/kobject-example.c`
    in the kernel source.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how to individually add attributes and call (directly
    or indirectly through a wrapper function such as `device_create_file()` , `class_create_file()`
    , and so on) `sysfs_create_file()` on each of them. Why bother ourselves with
    multiple calls if we can do it once? Here is where the attribute group comes in.
    It relies on the `struct attribute_group` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we have removed fields that are not of interest. The `attr` s field
    is a pointer to `NULL` terminated list of attributes. Each attribute group must
    be given a pointer to a list/array of `struct attribute` elements. The group is
    just a helper wrapper that makes it easier to manage multiple attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel functions used to add/remove group attributes to the filesystem
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The two preceding defined properties can be embedded in a `struct attribute_group`
    , to make only one call to add both of them to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The one and only function to call here is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is much better than making a call for each attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Device model and sysfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Sysfs` is a non-persistent virtual filesystem that provides a global view
    of the system and exposes the kernel object''s hierarchy (topology) by means of
    their kobjects. Each kobjects shows up as a directory, and files in a directory
    representing kernel variables, exported by the related kobject. These files are
    called attributes, and can be read or written.'
  prefs: []
  type: TYPE_NORMAL
- en: If any registered kobject creates a directory in sysfs, where the directory
    is created depends on the kobject's parent (which is a kobject too). It is natural
    that directories are created as subdirectories of the kobject's parent. This highlights
    internal object hierarchies to the user space. Top-level directories in sysfs
    represent the common ancestors of object hierarchies, that is, the subsystems
    the objects belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Top-level sysfs directories can be found under the `/sys/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`block` contains a directory per-block device on the system, each of which
    contains subdirectories for partitions on the device. `bus` contains the registered
    bus on the system. `dev` contains the registered device nodes in a raw way (no
    hierarchy), each being a symlink to the real device in the `/sys/devices` directory.
    `devices` gives a view of the topology of devices in the system. `firmware` shows
    a system-specific tree of low-level subsystems, such as: ACPI, EFI, OF (DT). `fs`
    lists filesystems actually used on the system. `kernel` holds kernel configuration
    options and status info. `Modules` is a list of loaded modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these directories corresponds to a kobject, some of which are exported
    as kernel symbols. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kernel_kobj` which corresponds to `/sys/kernel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`power_kobj` for `/sys/power`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firmware_kobj` which is for `/sys/firmware` , exported in the `drivers/base/firmware.c`
    source file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hypervisor_kobj` for `/sys/hypervisor` , exported in the `drivers/base/hypervisor.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs_kobj` which corresponds to `/sys/fs` , exported in the `fs/namespace.c`
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, `class/` , `dev/` , `devices/` , are created during the boot by the
    `devices_init` function in `drivers/base/core.c` in kernel source, `block/` is
    created in `block/genhd.c` , and `bus/` is created as a kset in `drivers/base/bus.c`
    .
  prefs: []
  type: TYPE_NORMAL
- en: When a kobject directory is added to sysfs (using `kobject_add` ), where it
    is added depends on the kobject's parent location. If its parent pointer is set,
    it is added as a subdirectory inside the parent's directory. If the parent pointer
    is NULL, it is added as a subdirectory inside `kset->kobj` . If neither parent
    nor kset fields are set, it maps to the root level directory in sysfs *(`/sys`*
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'One can create/remove symbolic links on existing objects (directories), using
    `sysfs_{create|remove}_link` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will allow an object to exist in more than one place. The create function
    will create a symlink named `name` pointing to the `target` kobject sysfs entry.
    A well know example is devices appearing in both `/sys/bus` and `/sys/devices`
    . Symbolic links created will be persistent even after `target` removal. You have
    to know when the `target` is removed, and then remove the corresponding symlink.
  prefs: []
  type: TYPE_NORMAL
- en: Sysfs files and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know that the default set of files are provided via the ktype field in
    kobjects and ksets, through the `default_attrs` field of `kobj_type` . Default
    attributes will be sufficient in most of the cases. But sometimes an instance
    of a ktype may need its own attributes to provide data or functionality not shared
    by a more general ktype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a recall, the low-level functions used to add/remove new attributes (or
    group of attributes) on top of default set are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Current interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are interface layers that currently exist in sysfs. Apart from creating
    your own ktype or kobject to add your attributes, you can use ones that currently
    exist: device, driver, bus, and class attributes. Their description are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Device attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from default attributes provided by the kobject embedded in your device
    structure, you can create custom ones. The structure used for this purpose is
    `struct device_attribute` , which is nothing but a wrapping around the standard
    `struct attribute` , and a set of callbacks to show/store the value of the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Their declaration is done through the `DEVICE_ATTR` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you declare a device attribute using `DEVICE_ATTR` , the prefix `dev_attr_`
    is added to the attribute name. For example, if you declare an attribute with
    the `_name` parameter set to foo, the attribute will be accessible through the
    `dev_attr_foo` variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why, let us see how the `DEVICE_ATTR` macro is defined in `include/linux/device.h`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can add/remove those using the `device_create_file` and `device_remove_file`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sample is a demonstration of how to put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the static declarations of the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to actually create files on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For cleanup, the attribute removal is done in the remove function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wonder how and why we used to define the same set of store/show callbacks
    for all attributes of the same kobject/ktype, and now, we use a custom one for
    each attribute. The first reason is because, the device subsystem defines its
    own attribute structure, which wraps the standard one, and secondly, instead of
    showing/storing the value of the attribute, it uses the `container_of` macro to
    extract the `struct device_attribute` giving a generic `struct attribute` , and
    then executes the show/store callback depending on the user action. The following
    is the excerpt from `drivers/base/core.c` , showing `sysfs_ops` of the device
    kobject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The principle is the same for bus (in `drivers/base/bus.c` ), driver (in `drivers/base/bus.c`
    ), and class (in `drivers/base/class.c` ) attributes. They use the `container_of`
    macro to extract their specific attribute structure, and then call the show/store
    callback embedded in it.
  prefs: []
  type: TYPE_NORMAL
- en: Bus attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It relies on the `struct bus_attribute` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Bus attributes are declared using the `BUS_ATTR` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Any bus attribute declared using `BUS_ATTR` will have the prefix `bus_attr_`
    added to the attribute variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'They are created/removed using `bus_{create|remove}_file` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Device drivers attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure used is `struct driver_attribute` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration relies on the `DRIVER_ATTR` macro, which will prefix the attribute
    variable name with `driver_attr_` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro definition is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Creation/removal relies on `driver_{create|remove}_file` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `struct class_attribute` is the base structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of a class attribute relies on `CLASS_ATTR` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As the macro''s definition shows, any class attribute declared with `CLASS_ATTR`
    will have the prefix `class_attr_` added to the attribute variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, file creation and removal is done with the `class_{create|remove}_file`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `device_create_file()` , `bus_create_file()` , `driver_create_file()`
    , and `class_create_file()` all make an internal call to `sysfs_create_file()`
    . As they all are kernel objects, they have a `kobject` embedded into their structure.
    That `kobject` is then passed as a parameter to `sysfs_create_file` , as you can
    see as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Allow sysfs attribute files to be pollable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will see how not to make CPU wasting polling to sense sysfs attributes
    data availability. The idea is to use the `poll` or `select` system calls to wait
    for the attribute''s content to change. The patch to make sysfs attributes pollable
    was created by **Neil Brown** and **Greg Kroah-Hartman** . The kobject manager
    (the driver which has access to the kobject) must support notification to allow
    `poll` or `select` to return (be released) when the content changes. The magic
    function that does the trick comes from the kernel side, and is `sysfs_notify()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If the `dir` parameter is non-NULL, it is used to find a subdirectory, which
    contains the attribute (presumably created by `sysfs_create_group` ). This has
    a cost of one `int` per attribute, one `wait_queuehead` per kobject, one int per
    open file.
  prefs: []
  type: TYPE_NORMAL
- en: '`poll` will return `POLLERR|POLLPRI` , and `select` will return the fd whether
    it is waiting for read, write, or exceptions. The blocking poll is from the user''s
    side. `sysfs_notify()` should be called only after you adjust your kernel attribute
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the `poll()` (or `select()` ) code as a **subscriber** to notice a
    change in an attribute of interest, and `sysfs_notify()` as a **publisher,** notifying
    subscribers of any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of code provided with the book, which is the store
    function of an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The code from the user space must behave like this in order to sense the data
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a dummy read of all the contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call poll requesting `POLLERR|POLLPRI` (select/exceptfds works too).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `poll` (or `select` ) returns (which indicates that a value has changed),
    read the content of files whose data changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the files and go to the top of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When in doubt of a sysfs attribute being pollable, set a suitable timeout value.
    The user space example is provided with the book sample.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you are familiar with the LDM concept and with its data structures (bus,
    class, device drivers, and devices), including low-level data structures, which
    are `kobject` , `kset` , `kobj_types` , and attributes (or group of those), how
    objects are represented within the kernel (hence sysfs and devices topology) is
    not a secret anymore. You will be able to create an attribute (or group), exposing
    your device or driver feature through sysfs. If the previous topic seems clear
    to you, we will move to the next [chapter 14](text00350.html) , *Pin Control and
    GPIO Subsystem* , which heavily uses the power of `sysfs` .
  prefs: []
  type: TYPE_NORMAL
