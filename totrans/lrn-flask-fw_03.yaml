- en: Chapter 3. Templates and Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter could alternatively be titled *The Flask Chapter*, because we
    will cover two of the most recognizable components of the framework: the Jinja2
    template language, and the URL routing framework. Up to this point, we have been
    laying the foundation for the blog app, but we have barely scratched the surface
    of actual Flask development. In this chapter, we will dive into Flask and see
    our app finally start taking shape. We will turn our drab database models into
    dynamically rendered HTML pages, using templates. We will come up with a URL scheme
    that reflects the ways we wish to organize our blog entries. As we progress through
    the chapter, our blog app will start looking like a proper website.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to render HTML templates using Jinja2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use loops, control structures, and the filters provided by the
    Jinja2 template language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use template inheritance to eliminate repetitive coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a clean URL scheme for our blog app and set up the routing from URLs
    to views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render lists of blog entries using Jinja2 templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add full-text search to the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Jinja2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is a fast, flexible, and secure templating engine. It allows you to define
    your website in small blocks that are pieced together to form complete pages.
    On our blog, for instance, we will have blocks for the header, the sidebar, the
    footer, as well as templates, for rendering blog posts. This approach is **DRY**
    (**Don't Repeat Yourself**), which means that the markup contained in each block
    should not be copied or pasted elsewhere. Since the HTML for each part of the
    site exists in only one place, making changes and fixing bugs is much easier.
    Jinja2 also allows you to embed display logic in the template. For instance, we
    may wish to display a log out button to users who are logged in, but display a
    log in form to users browsing anonymously. As you will see, it is very easy to
    accomplish these types of things with a bit of template logic.
  prefs: []
  type: TYPE_NORMAL
- en: From the beginning, Flask was built with Jinja2 in mind, so working with templates
    in your Flask app is extremely easy. Since Jinja2 is a requirement of the Flask
    framework, it is already installed in our virtualenv, so we're able to get started
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder named `templates` in the blog project''s `app` directory.
    Create a single file inside the template folder named `homepage.html` and add
    the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `views.py` in the blog project''s `app` directory. We are going to
    modify our `homepage` view to render the new `homepage.html` template. To do this,
    we will use Flask''s `render_template()` function, passing in the name of our
    template as the first argument. Rendering a template is an extremely common action,
    so Flask makes this part as easy as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `manage.py` helper that we created in the previous chapter, start
    the development server and navigate to `http://127.0.0.1:5000/` to view the rendered
    template, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Introducing Jinja2](img/1709_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Basic template operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example may not seem very impressive, since we are doing little
    more than serving a plain HTML document. To make things interesting, we need to
    give our templates **context**. Let''s modify our homepage to display a simple
    greeting to illustrate the point. Open `views.py` and make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the view code, we are passing `name` into the template context. The next
    step is to do something with that `name` inside the actual template. In this example,
    we will simply print the value of `name`. Open `homepage.html` and make the following
    addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the development server and navigate to the root URL. You should see something
    like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic template operations](img/1709_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any keyword arguments passed to the `render_template` function are available
    in the template context. In the template language of Jinja2, double brackets are
    analogous to a `print` statement. We use the `{{ name }}` operation to output
    the value of `name`, which is set to `<unknown>`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The security-minded reader may have noticed that, when we viewed our template
    in the browser, the brackets were escaped. Ordinarily, brackets are treated by
    the browser as HTML markup, but, as you can see, Jinja2 has escaped the brackets
    automatically, replacing them with `&lt;` and `&gt;`.
  prefs: []
  type: TYPE_NORMAL
- en: Try navigating to a URL such as `http://127.0.0.1:5000/?name=Charlie`. Whatever
    value you specify will appear, rendered for us automatically by Jinja2, as seen
    in the following image
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic template operations](img/1709_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose someone malicious visits your site and wants to cause some trouble.
    Noticing that values from the query-string are passed directly into the template,
    this person decides to have some fun by attempting to inject a script tag. Thankfully
    for us, Jinja2 automatically escapes values before inserting them into the rendered
    page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic template operations](img/1709_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Loops, control structures, and template programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jinja2 supports a miniature programming language that can be used to perform
    operations on data within the context. If all we could do was print values to
    the context, there honestly wouldn't be too much to be excited about. Things get
    interesting when we combine contextual data with things such as loops and control
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our homepage view once more. This time we will accept a number,
    in addition to a name, from `request.args` and display all the even numbers between
    0 and that number. The neat part is that we will do almost all of this in the
    template. Make the following changes to `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now open the `hompage.html` template and add the following code. If it seems
    odd, don't worry. We will go through it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Start a runserver and experiment by passing some values in using the query-string.
    Also, take note of what happens when you pass a non-numeric value or a negative
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loops, control structures, and template programming](img/1709_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's go through our new template code line by line, starting with the `{% if
    number %}` statement. Unlike the print tags that use double curly brackets, logical
    tags use `{%` and `%}`. We are simply checking whether or not a number was passed
    into the context. If the number is `None` or an empty string, this test will fail,
    just as it would in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The next line prints the integer representation of our number and uses a new
    syntax, `|int`. The pipe symbol (`|`) is used in Jinja2 to indicate a call to
    a filter. A **filter** performs some type of operation on the value to the left
    side of the pipe symbol, and returns a new value. In this case, we are using the
    built-in `int` filter that converts a string to an integer, defaulting to `0`
    when a number cannot be determined. There are many filters built into Jinja2;
    we will discuss them later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `{% for %}` statement is used to create a *for* loop and looks remarkably
    close to Python. We are using the Jinja2 `range` helper to generate a series of
    numbers with `[0, number)`. Note that we are again piping the `number` context
    value through the `int` filter in the call to `range`. Also note that we are assigning
    a value to a new context variable `i`. Inside the loop body, we can use `i` just
    like any other context variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, just like in regular Python, we can also use an `{% else %}` statement
    on a for-loop that can be used to run some code in the eventuality that there
    is nothing for the loop to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are looping through the numbers, we need to check whether `i` is
    even, and if so, print it. Jinja2 provides several ways we could do this, but
    I have chosen to show the use of a Jinja2 feature called **tests**. Like filters
    and control structures, Jinja2 also comes with a number of useful tools for testing
    the attributes of a context value. Tests are used in conjunction with `{% if %}`
    statements and are denoted by the use of the keyword `is`. So we have `{% if i
    is divisibleby 2 %}`, which is very easy to read. If the `if` statement evaluates
    to `True` then we will print the value of `i` using double braces: `{{ i }}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jinja2 provides a number of useful tests; to learn more check the project documentation
    at [http://jinja.pocoo.org/docs/templates/#tests](http://jinja.pocoo.org/docs/templates/#tests).
  prefs: []
  type: TYPE_NORMAL
- en: Since Jinja2 is not aware of significant whitespace, we need to explicitly close
    all our logical tags. That is why you see an `{% endif %}` tag, signifying the
    closing of the `divisibleby 2` check, and an `{% endfor %},` signifying the closing
    of the `for i in range` loop. After the `for` loop, we are now in the outermost
    `if` statement, which tests whether a number was passed into the context. In the
    event no number is present, we want to print a message to the user so, before
    calling `{% endif %}`, we will use an `{% else %}` tag to display this message.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have changed the line that prints a greeting to the user to read
    `{{ name|default('<unknown>', True) }}` . In the view code, we removed the logic
    that set it to a default value of `<unknown>`. Instead, we have moved that logic
    into the template. Here we see the `default` filter (denoted by the `|` character)
    but, unlike `int`, we are passing multiple arguments. In Jinja2, a filter can
    take multiple arguments. By convention, the first argument appears to the left
    of the pipe symbol, since filters frequently operate on single values. In the
    event there are multiple arguments, these are specified in parentheses *after*
    the filter name. In the case of the `default` filter, we have specified the value
    to use in the event no name is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 built-in filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we saw how to use the `int` filter to coerce a context
    value to an integer. Along with `int`, Jinja2 provides a large array of useful
    built-in filters. For reasons of space (the list is very long), I will only include
    the most frequently-used filters from my experience, but the entire list can be
    found online at [http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters](http://jinja.pocoo.org/docs/templates/#list-of-builtin-filters).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following examples, the first argument in the argument list would appear
    to the left-hand side of the pipe symbol. So, even though I have written `abs(number)`,
    the filter used would be `number|abs`. When the filter accepts more than one parameter,
    the remaining parameters appear in parentheses after the filter name.
  prefs: []
  type: TYPE_NORMAL
- en: '| Filter and parameter(s) | Description and return value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| abs(number) | Returns the absolute value of the number. |'
  prefs: []
  type: TYPE_TB
- en: '| default(value, default_value='''', boolean=False) | In the event `value`
    is undefined (i.e., the name does not exist in the context) use the provided `default_value`
    instead. In the event you simply want to test whether `value` evaluates to a boolean
    `True` (i.e., not an empty string, the number zero, None, and so on.), then pass
    `True` as the third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| dictsort(value, case_sensitive=False, by=''key'') | Sorts a dictionary by
    key, yielding `(key, value)` pairs. You can also, however, sort by value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| int(value, default=0) | Converts `value` to an integer. In the event the
    value cannot be converted, use the specified default. |'
  prefs: []
  type: TYPE_TB
- en: '| length(object) | Returns the number of items in the collection. |'
  prefs: []
  type: TYPE_TB
- en: '| reverse(sequence) | Reverses the sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| safe(value) | Outputs the value unescaped. This filter is useful when you
    have trusted HTML that you wish to print. For instance, if `value = "<b>"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| sort(value, reverse=False, case_sensitive=False, attribute=None) | Sorts
    an iterable value. If `reverse` is specified, the items will be sorted in reverse
    order. If the `attribute` parameter is used, that attribute will be treated as
    the value to sort by. |'
  prefs: []
  type: TYPE_TB
- en: '| striptags(value) | Removes any HTML tags, useful for cleaning up and outputting
    untrusted user input. |'
  prefs: []
  type: TYPE_TB
- en: '| truncate(value, length=255, killwords=False, end=''...'') | Returns a truncated
    copy of the string. The length parameter specifies how many characters to keep.
    If `killwords` is `False`, then a word may be chopped in half; if `True` then
    Jinja2 will truncate at the previous word boundary. In the event the value exceeds
    the length and needs to be truncated, the value in `end` will be appended automatically.
    |'
  prefs: []
  type: TYPE_TB
- en: '| urlize(value, trim_url_limit=None, nofollow=False, target=None) | Converts
    URLs in plain text into clickable links. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filters can be chained together, so `{{ number|int|abs }}` would first convert
    the number variable to an integer, then return its absolute value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a base template for the blog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2's inheritance and include features make it is very easy to define a base
    template that serves as the architectural foundation for each page on your site.
    The base template contains basic structural things that should never change, such
    as the `<html>`, `<head>,` and `<body>` tags, as well as the basic structure of
    the body. It can also be used to include style sheets or scripts that will be
    served on every page. Most importantly, the base template is responsible for defining
    overrideable blocks, into which we will place page-specific content such as the
    page title and body content.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get up-and-running quickly, we will be using Twitter's Bootstrap
    library (version 3). This will allow us to focus on how templates are structured
    and have a decent-looking site with minimal extra work. You are, of course, welcome
    to use your own CSS if you prefer, but the example code will use bootstrap-specific
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `templates` directory named `base.html`, and add the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Interspersed alongside the markup is a new Jinja2 tag, `block`. The `block`
    tags are used to indicate overrideable areas of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we are serving jQuery and Bootstrap from publicly-available
    URLs. In the next chapter, we will discuss how to serve static files that are
    stored locally on disk. Now we can modify our homepage template and take advantage
    of the new base template. We can do this by extending the base template and overriding
    certain blocks. This works very similar to class inheritance that you find in
    most languages. As long as the sections of the inherited page are split up into
    blocks nicely, we can override only the bits we need to change. Let''s open `homepage.html`
    and replace some of the current contents with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By extending the original page, we have removed all the HTML boilerplate and
    a lot of complexity, focusing only on what makes this page, our homepage view,
    unique. Start up the server and navigate to `http://127.0.0.1:5000/`, you will
    see that our homepage has been transformed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a base template for the blog](img/1709_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have now learned some of the most commonly-used features
    of Jinja2\. There are many more advanced features that we have not covered in
    the interests of time, and I would recommend reading the project's documentation
    to see the full range of possibilities with Jinja2\. The documentation can be
    found at [http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/).
  prefs: []
  type: TYPE_NORMAL
- en: We still need to build templates to display our blog entries. Before continuing
    to build out templates, though, we first must create some view functions that
    will generate the lists of blog entries. We will then pass the entries into the
    context, just as we did with the homepage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a URL scheme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URLs are for people, therefore they should be easy to remember. A good URL scheme
    is easy to remember when it accurately reflects the implicit structure of the
    website. Our goal is to create a URL scheme that makes it easy for the visitors
    on our site to find blog entries on topics that interest them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring back to the spec we created in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First Flask Application"), *Creating Your First Flask Application*, we know
    that we want our blog entries to be organized by tag and by date. Entries organized
    by tag and date will necessarily be a subset of the collection of all entries,
    so that gives us a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/entries/` | This displays all of our blog entries, ordered most-recent
    first |'
  prefs: []
  type: TYPE_TB
- en: '| `/entries/tags/` | This contains all the tags used to organize our blog entries
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/entries/tags/python/` | This contains all the entries tagged with `python`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/entries/learning-the-flask-framework/` | This is a detail page showing
    the body content for a blog entry titled *Learning the Flask Framework* |'
  prefs: []
  type: TYPE_TB
- en: 'Since a single blog entry may be associated with multiple tags, how do we decide
    what to use as its canonical URL? If I wrote a blog entry titled *Learning the
    Flask framework*, I could conceivably nest it under `/entries/, /entries/tags/python/`,
    `/entries/tags/flask/`, and so on. That would violate one of the rules about good
    URLs, which is that a unique resource should have one, and only one, URL. For
    that reason, I am going to advocate putting individual blog entries at the top
    of the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/entries/learning-the-flask-framework/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'News sites and blogs with a large amount of time-sensitive content will typically
    nest individual pieces of content using the publication date. This prevents collisions
    when two articles might share the same title, but have been written at different
    times. When a lot of content is produced each day, this scheme often makes more
    sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/entries/2014/jan/18/learning-the-flask-framework/`'
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not be covering this type of URL scheme in this chapter, the
    code can be found online at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the URL routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s convert the structure described previously into some URL routes that
    Flask will understand. Create a new directory named `entries` in the blog project''s
    `app` directory. Inside the `entries` directory, create two files, `__init__.py`
    and `blueprint.py as follows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Blueprints** provide a nice API for encapsulating a group of related routes
    and templates. In smaller applications, typically everything gets registered on
    the app object (that is, `app.route`). When an application has distinct components,
    as ours does, blueprints can be used to separate the various moving parts. Since
    the `/entries/` URL is going to be devoted entirely to our blog entries, we will
    create a blueprint and then define views to handle the routes that we described
    previously. Open `blueprint.py` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These URL routes are placeholders that we will fill in shortly, but I wanted
    to show you how clean and simple it is to translate a set of URL patterns into
    a set of routes and views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to access these new views, we need to register our blueprint with
    our main Flask `app` object. We will also instruct our app that we want our entries''
    URLs to live at the prefix `/entries`. Open `main.py` and make the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to test it out, start the debug server (`python manage.py runserver`)
    and navigate to `http://127.0.0.1:5000/entries/`. You should see the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the URL routes](img/1709_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the index view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `index` view is the top-most URL in our `/entries/` hierarchy, and as such
    will contain all the entries. After a time we might have tens or even hundreds
    of blog entries, so we will want to paginate this list so as not to overwhelm
    our visitors (or our server!). Because we will frequently be displaying lists
    of objects, let''s create a helpers module that will make it easy to display paginated
    lists of objects. In the `app` directory, create a new module named `helpers.py`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will open `entries/blueprint.py` and modify the `index` view to return
    a paginated list of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are importing the `object_list` helper function and passing it the name of
    a template and the query representing the entries we wish to display. As we build
    out the rest of these views, you will see how little helper functions such as
    `object_list` make Flask development quite easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece is the `entries/index.html` template. In the `entries` directory,
    create a directory named `templates`, and a sub-directory named `entries`. Create
    `index.html` such that the full path from the `app` directory is `entries/templates/entries/index.html`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This template is very minimal, all the work will happen in `includes/list.html`.
    The `{% include %}` tag is new, and is useful for reusable template fragments.
    Create the file `includes/list.html` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `url_for` function is extremely useful. `url_for()` allows us to provide
    the name of a view function or any arguments, and then generates the URL. Since
    the URL we wish to reference is the `detail` view of the entries blueprint, the
    name of the view is `entries.detail`. The detail view accepts a single argument,
    the slug of the entry's title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before building out the detail view, re-open the base template and add a link
    to the entries in the navigation section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the updated navigation header, along with a
    list of blog entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the index view](img/1709_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the detail view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple view that will render the contents of a single blog
    entry. The slug of the entry will be passed in as a part of the URL. We will attempt
    to match that to an existing `Entry`, returning a 404 response if none matches.
    Update the following code to the `detail` view in the entries blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template in the `entries` template directory named `detail.html` and
    add the following code. We will display the title and body of the entry in the
    main content area, but in the sidebar we will display a list of tags and the date
    the entry was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It should now be possible to view entries on the index page and follow the link
    to the details view. As you probably guessed, the next thing we need to tackle
    is the tag detail page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the detail view](img/1709_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing entries matching a given tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing the entries that match a given tag will combine the logic from the
    two previous views. First we will need to look up the `Tag` using the `tag` slug
    provided in the URL, and then we will display an `object_list` of `Entry` objects
    that are tagged with the specified tag. In the `tag_detail` view, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entries` query will get all the entries associated with the tag, then
    return them ordered most-recent first. We are also passing the tag into the context
    so we can display it in the template. Create the `tag_detail.html` template and
    add the following code. Since we are going to display a list of entries, we will
    re-use our `list.html` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, I have navigated to `/entries/tags/python/`. This
    page only contains entries that have been tagged with *Python*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing entries matching a given tag](img/1709_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing all the tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final missing piece is the view that will display a list of all the tags.
    This view will be very similar to the `index` entry, except that, instead of `Entry`
    objects, we will be querying the `Tag` model. Update the following code to the
    `tag_index` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, we will display each tag as a link to the corresponding tag
    detail page. Create the file `entries/tag_index.html` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you like, you can add a link to the tag list in the base template's navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Full-text search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to allow users to find posts containing certain words or phrases,
    we will add simple full-text search to the pages that contain lists of blog entries.
    To accomplish this, we will do some refactoring. We will be adding a search form
    to the sidebar of all pages containing lists of blog entries. While we could copy
    and paste the same code into both `entries/index.html` and `entries/tag_detail.html`,
    we will, instead, create another base template that contains the search widget.
    Create a new template named `entries/base_entries.html` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we will not explicitly pass `request` into the context, Flask will
    make it accessible. You can find the list of standard context variables in the
    Flask documentation at [http://flask.pocoo.org/docs/templating/#standard-context](http://flask.pocoo.org/docs/templating/#standard-context).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will update the `entries/index.html` and `entries/tag_detail.html` to
    utilize this new base template. Since the `content` block contains the list of
    entries, we can remove that from both templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is how `entries/index.html` looks after changing the base template and
    removing the context block. Do the same to `entries/tag_detail.html`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to update our view code to actually perform the search. To do this,
    we will create a new helper function in the blueprint named `entry_list`. This
    helper will be much like the `object_list` helper, but will perform extra logic
    to filter results based on our search inquiry. Add the `entry_list` function to
    the `blueprint.py`. Note how it checks the request query-string for a parameter
    named `q`. If `q` is present, we will return only the entries that contain the
    search phrase in either the title or the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to utilize this functionality, modify the `index` and `tag_detail`
    views to call `entry_list` instead of `object_list`. The updated `index` view
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You can now navigate to the entries list and perform searches
    using the search form.
  prefs: []
  type: TYPE_NORMAL
- en: '![Full-text search](img/1709_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding pagination links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier, we would like to paginate long lists of entries so
    that users are not overwhelmed with extremely long lists. We have actually done
    all the work in the `object_list` function; the only remaining task is to add
    links allowing users to travel from one page of entries to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because pagination links are a feature we will use in several places, we will
    create the pagination `include` in our app''s template directory (as opposed to
    the entries template directory). Create a new directory in `app/templates/` named
    `includes` and create a file named `page_links.html`. Since `object_list` returns
    us a `PaginatedQuery` object, we can utilize this object to determine, in the
    template, what page we are on and how many pages there are in total. In order
    to make the pagination links look nice, we will be using CSS classes provided
    by Bootstrap. Add the following content to `page_links.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, wherever we are displaying an object list, let''s include the `page_links.html`
    template at the bottom of the page. Currently, the only templates we will need
    to update are `entries/base_entries.html` and `entries/tag_index.html`. The `content`
    block of `base_entries.html` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding pagination links](img/1709_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enhancing the blog app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before continuing on to the next chapter, I recommend spending some time experimenting
    with the views and templates we created in this chapter. Here are a few ideas
    you might consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sort the list of tags on the entry detail view (hint: use the `sort` filter
    on the tag''s `name` attribute).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the example code from the homepage template and add your own content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that we are displaying all entries regardless of their
    status. Modify the `entry_list` function and the entry `detail` view to only display
    `Entry` objects whose status is `STATUS_PUBLIC`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with different Bootstrap themes- [http://bootswatch.com](http://bootswatch.com)
    has many available for free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: allow multiple tags to be specified. For example, `/entries/tags/flask+python/`
    would only display entries that are tagged with both *flask* and *python*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of information in this chapter, and by now you should be familiar
    with the process of creating views and templates. We learned how to render Jinja2
    templates and how to pass data from the view into the template context. We also
    learned how to modify context data within the template, using Jinja2 tags and
    filters. In the second half of the chapter, we designed a URL structure for our
    site and translated it into Flask views. We added a simple full-text search feature
    to the site, and wrapped up by adding pagination links to our lists of entries
    and tags.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create and edit blog entries through
    the website using **Forms**. We will learn how to process and validate user input,
    then save the changes to the database. We will also add a photo-uploading feature
    so we can embed images in our blog entries.
  prefs: []
  type: TYPE_NORMAL
