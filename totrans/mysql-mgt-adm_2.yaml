- en: Chapter 2. Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how to set up different types of connections
    to a MySQL server from Navicat. Now that we’re ready to get connected to a server,
    it’s time to work with databases. In this chapter you’ll learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create tables and views using Navicats visual design tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create foreign key constraints and triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define stored procedures and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create scheduled events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with database queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing database objects with Navicat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we mean by database objects? Basically tables, views, functions, and
    events are what we refer to as objects. For each of them, there is a toolbar icon
    in Navicat’s main window and they also appear on the tree view list on the left-hand
    side of the navigation pane. It’s possible to hide the object hierarchy from **Tools**
    | **Options** by unchecking the **Show objects in connection tree** option, but
    this would probably be trivial, especially for novice users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolbar in Navicat’s main window has large buttons with icons for working
    with the database objects. Clicking on the **Table** button on the toolbar, for
    example, is the equivalent of selecting **Tables** in the tree view in the navigation
    pane titled **Connections**. The larger remaining portion on the right-hand side
    of the main window, under the toolbar, is called the object pane, which displays
    the objects of the selected type. The following screenshot shows the objects of
    **Tables**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing database objects with Navicat](img/7461EN_02_01_Navicat-Overview.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a database from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navicat makes it extremely easy to create databases and objects, such as tables
    and views from scratch. As we have established a connection to a MySQL server
    in the previous chapter, it’s time to get started with a blank database of our
    own. The following steps describe how to create a database from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on **localhost** (or whatever you named your server) in the **Connections**
    pane to get connected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then right-click on the server name, and select **New Database...** from the
    contextual menu that pops up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new smaller window that opens, enter the **Database Name** as `our_first_db`,
    specify the **Character set** as **utf8--UTF-8 Unicode**, and the **Collation**
    as **utf8_unicode_ci**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now **our_first_db** should appear among the other databases under **localhost**.
    By right-clicking on it, you can see what actions you can perform on our new blank
    database from the contextual pop-up menu, such as opening it, viewing, and editing
    its properties like **Character set**, **Collation**, and deleting it. There’s
    also an item named **Data Transfer...**in the same pop-up menu, which in my opinion
    is one of the most powerful features of Navicat. It allows you to transfer data
    directly to and from another database, which we will cover in [Chapter 3](ch03.html
    "Chapter 3. Data Management with Navicat"), *Data Management with Navicat*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to limitations of MySQL 5.x, it is not possible to rename a database via
    GUI tools. The best way to do this is to dump the database to an SQL file, create
    a new database with the desired name, and execute the dump file to fill it with
    the contents of the previous database. You will also find details of such tasks
    in [Chapter 3](ch03.html "Chapter 3. Data Management with Navicat"), *Data Management
    with Navicat*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a database from scratch](img/7461EN_02_02_new-database.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s create some tables for **our_first_db** by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select and open the database from the navigation pane by double-clicking on
    its name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then either click on the **New Table** button on the toolbar or right-click
    on **Tables** right under **our_first_db**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select **New Table** from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navicat’s table designer window will appear. The controls here are pretty intuitive.
    We’ll create a department table for a simple employee database and we need three
    fields for it: `id` (**int**), `name` (**varchar**), and `manager_id` (**int**).
    To create the fields, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the first field named `id`, select **Type** as **int**, leave the **Length**
    column blank as it will automatically be set to `11`, uncheck **Allow Null**,
    make it a **Primary key** either by clicking on the tiny button with a yellow
    key icon or by clicking on the empty cell next to the checkbox under **Allow Null**,
    and then finally check the **Auto Increment** option at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a new field is as easy as clicking on the **Add Field** button on the
    toolbar, or pressing the *Tab* key while in the last cell of the most recently
    created field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will create the field called `name`, select **Type** as **varchar**,
    with `31` characters of length, again uncheck the **Allow Null** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select **Type** as **int**, leave the **Length** column blank as it
    will be automatically be set to `11`, and we also want to leave **Allow Null**
    checked for this one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, save this table as `department` by clicking on one of the **Save** or **Save
    As** buttons on the toolbar. Navicat also prompts us to save our progress if we
    just try to close the window without saving anyway. Refer to the following screenshot:![Creating
    tables](img/Image443749.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to interpose a newly-created field between previously created
    ones by clicking on the existing field and clicking on the **Insert Field** button
    on the toolbar. We can also change the order of the fields by selecting a field
    and using the buttons **Move Up** and **Move Down** on the toolbar as we please.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’ll repeat the previous steps to create the employee table, but this
    time defining the fields with the following specifications. In the following table,
    false implies uncheck and true implies check:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Length** | **Decimals** | **Allow Null** | **Primary
    Key** |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | **int** |   |   | false | X (auto-incrementing) |'
  prefs: []
  type: TYPE_TB
- en: '| `first_name` | **varchar** | `50` |   | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| `last_name` | **varchar** | `40` |   | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | **varchar** | `60` |   | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | **varchar** | `35` |   | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| `salary` | **decimal** | `10` | `2` | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| `perks` | **int** |   |   | false |   |'
  prefs: []
  type: TYPE_TB
- en: '| `department_id` | **int** |   |   | true |   |'
  prefs: []
  type: TYPE_TB
- en: '| `manager_id` | **int** |   |   | true |   |'
  prefs: []
  type: TYPE_TB
- en: Next, we need to establish some relationships between the two tables by defining
    some foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Defining foreign keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, I recommend saving the table and naming it `employee` (If you
    happen to close the table designer after that, right-click on the name of the
    table and choose **Design Table** from the pop-up menu.) While back in the table
    designer, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the **Foreign Keys** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `fk_employee_4_department` as the name of the foreign key in the first
    field of the first row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **department_id** for the **Fields** in the second column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **our_first_db** as the **Reference Database** in the third column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the **department** table for the **Reference Table** in the fourth column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **id** for **Reference Fields**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, you could specify the cascading options **On Delete** and **On Update**
    depending on your programming strategy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, selecting the cascading option **On Delete** in this case means,
    when a department record is deleted, all employees in that department will also
    be deleted. Leaving **On Delete** and **On Update** blank will set them to restrict
    as default, which would mean that you can’t delete a department that has employees
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: The above definition will be enforcing a referential integrity check for every
    employee to be assigned to an existing department via the **department_id** column.
    It means you can’t set a non-existent department ID for a given employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now repeat the steps mentioned earlier to define a foreign key for the **manager_id**,
    name it `fk_employee_4_manager_id`, set the **Referenced Table** to **employee,**
    and the **Referenced Fields** to **id,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining foreign keys](img/7461EN_02_04_defining_fk.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you switch to the **SQL Preview** tab before saving your changes, you will
    be able to see a couple of automatically generated SQL commands for adding the
    designed foreign key constraint(s) to your table. In fact, every change you make
    on a table’s design has corresponding SQL commands, which Navicat performs behind
    the scenes and executes them on the database server. This can also be useful for
    learning SQL, or in the case of a server error, for analyzing what went wrong
    at the backstage. The screenshot of the **SQL Preview** tab is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining foreign keys](img/7461EN_02_05_defining_fk_sql_preview.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the same steps for defining a foreign key constraint for the **manager_id**
    in the **department** table referencing the **id** field of the **employee table**,
    and name it `fk_department_4_manager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As for the table naming convention, I encourage the use of single nouns for
    table names particularly to make life easier for developers, who use **object-relational
    mapping** (**ORM**) APIs that have reverse-engineering tools for the development
    of database-driven applications.
  prefs: []
  type: TYPE_NORMAL
- en: Navicat’s Table Designer also features a tab called **Indexes** that makes creating
    indexes as easy as creating fields and defining foreign keys using similar methods.
    In fact, creating a foreign key requires a corresponding index also to be created,
    and Navicat does that automatically for us by creating an index for every foreign
    key we define and create.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice the **Triggers** tab, where you can easily define a trigger
    for a table. Let’s define a simple trigger, which will be activated every time
    a new row is added to the employee table. For this example, we will need an auxiliary
    table that I will call **emp_log**.
  prefs: []
  type: TYPE_NORMAL
- en: Defining triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can either practice what you have learned in this section by creating the
    **emp_log** table using the table designer, by defining three basic fields: `id`
    (**Type**-**int,** check primary key auto-incrementing), `emp_id` (**Type**-**int**),
    and `date_created` (**Type**-**datetime**) or by going to the menu bar in Navicat’s
    main window, choosing **Tools** | **Console...** (alternatively press *F6* as
    a shortcut) and entering the following command in the MySQL console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the **emp_log** table is created, we’re ready to define a trigger that
    will log every employee record we created in the **employee** table. Right-click
    on the **employee** table, select **Design Table,** and then perform the following
    steps in the table designer for the employee table:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Triggers** tab and click on **Add Trigger** from the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the trigger as `ins_trig`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Fires** column, select **After**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Insert** and leave the other checkboxes alone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the **Definition** pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot of the **Triggers** tab is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining triggers](img/7461EN_02_06_trigger.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Options** tab is another useful aide, which lets you modify certain settings
    of a MySQL table. A major pitfall for MySQL database designers is that when creating
    a MySQL table, they might accidentally end up with a MyISAM table, whereas they
    actually intended to use the InnoDB engine. Navicat makes it easy to change the
    engine to InnoDB. This kind of modification is not foolproof though. Due to MySQL’s
    internal mechanism, if there’s already some data entered in the table, this might
    make the conversion difficult, and sometimes even impossible. The other options
    here include **Character set** and **Collation** modification, setting or resetting
    the **Auto Increment** value for the next record, and maintaining a live checksum
    for all rows—a feature exclusive to MyISAM tables.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced tweaks are possible on this screen, which is covered in detail
    in Navicat’s manual.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to duplicate tables by just clicking on the table’s name
    and selecting **Duplicate Table** from the pop-up menu. Another related cool feature
    of Navicat is that you can copy a table in the same way and paste it to another
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining triggers](img/7461EN_02_07_table_options.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entering data in tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built the basis for our database, we’d better enter some data
    in our tables. To open a table for data entry, simply double-click on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navicat provides two ways of data entry in tables: one of them is using the
    **Grid View**, which is predictably the most common way of entering data just
    like you would do in a spreadsheet.'
  prefs: []
  type: TYPE_NORMAL
- en: Just click on a cell to start entering the data, and when you’re done with it,
    you can press the *Tab* key to move on to the next cell or click on anywhere outside
    the active cell. Fields with foreign key constraints will contain a small square
    button for selecting data from a drop-down list, which will present data items
    from the field of the table to which it has reference(s). In our case, the **department_id**
    can be selected from the IDs of records entered in the department table as you
    can see in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished with editing the row, you can click on the tiny tick **P**
    button at the bottom of the window to save your changes, or the **O** button to
    discard them. Click on the (**+**) plus or minus (**-**) sign to delete a record
    if you need to, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entering data in tables](img/7461EN_02_08_employee_data.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you used Microsoft Access or Oracle Forms before, the form view will look
    familiar to you. Every table row or record will be displayed on a separate page
    with the fields aligned vertically in that view. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entering data in tables](img/7461EN_02_09_data_entry_form_view.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database views are usually used to hide complex details of certain tables and
    in some cases, they’re used simply as a security mechanism by limiting the data
    that a user is allowed to retrieve. In this section, I’ll show you how to create
    a view, in a moment, using Navicat’s view designer. It has a powerful visual editing
    tool called the **View Builder** and it allows you to design views visually using
    point-and-click and drag-and-drop gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a table to the view, simply click on its name on the left pane, and
    drag it to the graphical view area, or just double-click on its name in the tree
    view and click on **View Builder** tab and then follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When you get all your tables in the graphical view, you can click on the tiny
    boxes next to the field names on the left-hand side to include them in the view.
    If you click on the box on the left-hand side of the table name, all the fields
    will be included in the **SELECT** query of the view, as shown in the following
    screenshot:![Creating views](img/7461EN_02_10_employee_view.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To define the relationships, click on the name of a field of a table and drag
    it onto the field of the table it is related to. For example, in this view, we
    want to display the name of the department of every employee instead of his/her
    department ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **department_id** field in the **employee** table and drag it onto
    the **id** field of the **department** table. A connecting line will be drawn
    representing the relationship between the two tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the meantime, the SQL representation of the visual design will be updated
    accordingly in the lower-right pane, which is called the syntax view. The relationships
    will be created as **INNER JOIN** by default; however, you can change them to
    **LEFT JOIN** or **RIGHT JOIN** by clicking on its SQL syntax highlighted in blue,
    and selecting a different join type from the menu that pops up.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively you can switch to the **Definition** tab of the view designer
    to work with plain SQL. You can switch between the two any time, as it is possible
    to generate the SQL query from the visual design and vice versa. However, make
    sure you save your view definition at every step and even back up the SQL to an
    external file at every major step as it is possible that the SQL query gets mixed
    up when trying complex things in the visual editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, enter the following SQL query in the **Definition** pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To preview the results of the generated SQL, click on the **Preview** button
    on the toolbar. You will see the data retrieved by the view in a tab called **Result1**,
    if your SQL statement had no errors.
  prefs: []
  type: TYPE_NORMAL
- en: The **Explain** button on the toolbar shows the query plan of the view.
  prefs: []
  type: TYPE_NORMAL
- en: For power users, there’s also a tab titled **Advanced**, where you can set advanced
    properties for the view. One of them is the **Algorithm**, and it gives you the
    ability to force MySQL to use a specific algorithm when executing the SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The default is **Undefined**, which leaves the choice to MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the **Merge** algorithm is more efficient in most cases; it is the one MySQL
    picks whenever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alternative is the **Temptable** algorithm that retrieves the results after
    caching them in a temporary table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Security** option lets you customize access privileges by choosing between
    the user who defined the view and the one who invoked it.
  prefs: []
  type: TYPE_NORMAL
- en: More details about these settings are available in Navicat’s manual.
  prefs: []
  type: TYPE_NORMAL
- en: When you double-click on a view you saved, you will get the results in a grid
    window, which is very similar to opening tables for viewing or entering data.
    From this window, it’s possible to export the data in a variety of formats. The
    details of this functionality are covered in [Chapter 3](ch03.html "Chapter 3. Data
    Management with Navicat"), *Data Management with Navicat*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The created **View** will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating views](img/7461EN_02_11_view-execution.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with functions and procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL has brought support for functions and stored procedures as of Version
    5\. A stored procedure is a set of SQL statements that can be stored on the server,
    so that they can be invoked later by a client, a trigger, or even another stored
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a simple stored procedure that will select the employees
    with the lowest, highest, and average salaries in the company.
  prefs: []
  type: TYPE_NORMAL
- en: The default way of creating such a routine in Navicat is through the **Function
    Wizard** that is invoked by clicking on the **New function** button in the toolbar
    or by selecting the **New Function** command from the pop-up menu showing up with
    a right-click on the appropriate context.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Function Wizard** window, select **Procedure** and click on **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then enter the following parameters for the procedure before you click on **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Name** | **Type** |'
  prefs: []
  type: TYPE_TB
- en: '| **OUT** | `lowest_salary` | **decimal(10,2)** |'
  prefs: []
  type: TYPE_TB
- en: '| **OUT** | `l_emp` | **varchar** |'
  prefs: []
  type: TYPE_TB
- en: '| **OUT** | `highest_salary` | **decimal(10,2)** |'
  prefs: []
  type: TYPE_TB
- en: '| **OUT** | `h_emp` | **varchar** |'
  prefs: []
  type: TYPE_TB
- en: '| **OUT** | `average_salary` | **decimal(10,2)** |'
  prefs: []
  type: TYPE_TB
- en: 'After entering the parameters in the previous table, the screenshot will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with functions and procedures](img/7461EN_02_13_function_wizard_sp2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on **Finish**, the created **Procedure** will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with functions and procedures](img/7461EN_02_14_function_wizard_sp3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, enter the following code in the routine’s **Definition** on the next
    screen and save the procedure as `sp_salaries`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While entering the previous code, you can enjoy the code editing capabilities
    of Navicat, such as the code highlighting, word wrapping, auto-completion, and
    code-folding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to test the procedure, go to the **Queries** node, create a **New
    Query**, and then enter the following statements in the **Query Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Working with functions and procedures](img/7461EN_02_15_sp_salaires_results_qry.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see the results of the query, click on the **Run** button in the toolbar
    and there we are with the lowest and highest paid employee in the company, their
    salaries, and the average salary of all employees in the company.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, since we don’t have a single field for the full name of employees and
    instead have separate fields for first name, we will create a function that returns
    the full name of an employee by concatenating his/her first name and last name
    delimited with a single space character whose ID is taken as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we’ll follow almost the same steps from the beginning of this section,
    except that in the first screen of the **Function Wizard**, we’ll select **Function**
    instead of **Procedure**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll specify `emp_id` of type **int** as the input parameter and click
    on **Finish**. Finally, in the function’s **Definition** area, enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the function as `fn_fullname` and test it by clicking on **Run** on the
    toolbar. When prompted, enter **id** of an employee whose full name you want to
    display. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with functions and procedures](img/7461EN_02_16_fn_fullname.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Navicat’s event designer for MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Version 5.1.6, the **Event Scheduler** feature of MySQL was introduced,
    which lets you design scheduled tasks. An event in MySQL is a scheduled task consisting
    of one or more SQL statements to be executed at certain intervals, beginning,
    and ending at specific dates and time.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll show you how to create a scheduled event that will back
    up our employee table, which will recur at specific intervals. As a prerequisite,
    we need to make sure that MySQL’s global event scheduler is active (which is disabled
    by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, select **Console** from the **Tools** menu in Navicat’s main window
    to get a command-line access to the MySQL server, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Navicat’s event designer for MySQL](img/7461EN_02_17_enabling-scheduler-from-the-console.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While in the **localhost - Console** prompt, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Secondly, we will need to create a new stored procedure that will contain a
    set of commands to back up the employee table and delete any existing backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to put into practice what you have learned in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new stored procedure called `refresh_employee_bu` with no in or out
    parameters and enter the following code in its definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now were ready to create a scheduled event in Navicat; click on the **Event**
    button in the toolbar, then select **New Event**. This will bring in Navicats
    event designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While in the **Definition** tab of the event designer, set the **Definer** as
    `root@localhost` or `CURRENT_USER` if you had established the connection using
    `root`. Set **Status** to **ENABLE**, and select **PRESERVE** for **ON COMPLETION**,
    as shown in the following screenshot:![Using Navicat’s event designer for MySQL](img/7461EN_02_18_event_designer.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then enter the following code in the definition code area: `CALL refresh_employee_bu`.
    This will invoke the stored procedure you created earlier for backing up the employee
    table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, switch to the **Schedule** tab of the event designer to adjust the
    timing of the event, as shown in the following screenshot:![Using Navicat’s event
    designer for MySQL](img/7461EN_02_19_event_designer2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the backup process to run every month, so refer to the previous screenshot
    to adjust your settings so that the event will be triggered every month, **STARTS**
    at **CURRENT_TIMESTAMP** + `1` hour **INTERVAL**. Save this event as `backup_employees`
    and you’re done.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test if the scheduled event is working, you can set a much sooner date and
    time and shorter interval for a start, and then once you verify it’s working,
    you can set the timing back to a reasonable frequency.
  prefs: []
  type: TYPE_NORMAL
- en: Working with queries in Navicat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing a query in Navicat is much like designing a view except that views
    are limited to SELECT statements whereas the queries can perform any **CRUD**
    (**create**, **read**, **update**, and **delete**) operation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like the **View Builder**, Navicat’s visual query builder allows you to
    graphically represent tables and fields as well as relationships between them
    (JOINS) and by leaving the SQL generation to Navicat, however, this approach only
    works with SELECT queries. You still have to handcode the SQL for create, update,
    and delete queries.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll go through an imaginary scenario regarding the fictional
    company `Acme.com,` where the CEO is unhappy with the financial results from the
    past fiscal year and believes that the company’s organization should be revised.
    Toward this end, he wants preliminarily analysis of who’s doing what and how much
    salary he or she gets in the company.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will design a simple query to list all departments and their managers.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go to the **Queries** view by either clicking on the large **Query** button
    on the toolbar or by selecting **Queries** from the navigation pane on the left-hand
    side, and then click on the smaller **New Query** button on the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: In the window that opens, the **Query Editor** tab is active by default. This
    is where you can handcode the SQL language to construct a query. What we want
    is the visual designer, so we’ll switch to the **Query Builder** tab.
  prefs: []
  type: TYPE_NORMAL
- en: In this view, we have a visual diagram pane where we can create graphical representations
    of tables and views by either double-clicking on their names on the left pane,
    or simply by moving them to the empty area using drag-and-drop gestures.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this query, we need **department** and **employee** tables side-by-side;
    so after bringing them to the stage, start building a SELECT query by choosing
    the following fields by clicking on the tiny boxes next to their names: **name**
    of the **department** table, **first_name**, **last_name**, and **title** of the
    **employee** table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on **manager_id** of the **department** table and move it onto
    the **id** field of the **employee** table. A line with round ends bonding the
    two fields should appear, and in the pane below an editable SQL code is previewed.
    You can click on the gray words in the SQL query to make additions to the syntax,
    such as aliases for fields and tables. This query is now almost ready except that
    I want a **LEFT JOIN** between **department** and **employee** instead of an **INNER
    JOIN** here. Click on the blue **INNER JOIN** expression to change it to a **LEFT
    JOIN** using a drop-down list that will show up automatically, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the Query](img/7461EN_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s save this query and execute it to find out about the organization
    of the company. I named it `qry_departments`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Run** button on the window’s toolbar to execute the query. Invoking
    it will switch back to the query editor and retrieve the results in a data grid
    below the generated SQL code. At this stage, we have the option of exporting the
    resulting data to a variety of formats, such as text (csv), Excel spreadsheet,
    XML, MS Access database (Windows only), or even a DBase file. Details of importing/exporting
    data functionality of Navicat are covered in [Chapter 3,](ch03.html "Chapter 3. Data
    Management with Navicat") *Data Management with Navicat*. Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the Query](img/7461EN_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike other database objects, Navicat does not prompt you to save your query
    when you are closing the query designer window, so be sure to save your work to
    avoid losing your changes.
  prefs: []
  type: TYPE_NORMAL
- en: Building further queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having designed our first query in the previous section, I think that we could
    spice up what we have learned by adding some more to it.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our scenario, the boss wants a list of employees (specifically
    the managers) with a monthly salary amount of more than $15,000, which department
    they work in, and who they report to. That’s the specification of the next query
    we will design. If you are good at SQL programming, you could conceive such a
    query in a matter of minutes just by handcoding. Navicat’s code editor is very
    useful also for this kind of task, thanks to its code-completion aid, SQL formatting,
    code folding, and brace highlighting. However, I want to demonstrate a few more
    features of the visual builder for the sake of the ease-of-use it provides for
    setting filtering criteria. For this query, we’ll be working with the **department**
    table to retrieve the names of departments associated with the department ID of
    employees, and two instances of the **employee** table—one for the employees themselves
    and the second one to fetch the names of their managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new query window and add two **employee** tables and one **department**
    table to the (graphical) diagram view area by dragging them from the left pane
    or double-clicking on their names. Name the second **employee** table as **manager**
    using an alias. You can do this either by double-clicking on the table’s title
    bar or by clicking on the slightly dimmed **<Alias>** in the syntax view, and
    entering **manager**. (The former method is similar to renaming a file by clicking
    on its name under or next to its icon in Windows Explorer or the Macintosh Finder.)
    Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building further queries](img/7461EN_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connect the **department** table to the **employee** table by associating **id**
    of the **department** table to **department_id** of the **employee** table, and
    then connect the **employee** table to the **manager** table by associating **manager_id**
    of the **employee** table to **id** of the **manager** table. Convert these associations
    to **LEFT** **JOIN** instances, so that we also retrieve the employees who are
    not assigned to any manager or a department.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the following fields: **first_name** of the **employee** table,
    **last_name** of the **employee** table, **title** of the **employee** table,
    **salary** of the **employee** table, **perks** of the **employee** table, and
    **name** of the department table for the query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to specify two conditions: **employee.salary** must be greater
    than `15,000` or **employee.perks** must be greater than `1,500`.'
  prefs: []
  type: TYPE_NORMAL
- en: To add a condition in the visual editor, click on the symbol group **<--> =
    <-->** from the **WHERE** clause in the syntax view. Click on **<-->** to choose
    the field from the list of all the table fields, available in the query. To define
    your own criteria, you can type your values directly in the **Edit** tab. Click
    on the equals sign (**=**) to change the condition operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we execute the query, we’ll get more or less of what we wanted; all the
    employees with salaries over $15,000 or perks over $1,500\. But the CEO is also
    on the list. Besides, the result sheet is not very appealing to the eye with some
    of the bizarre column names and with the first names and last names appearing
    in different columns. While in the query editor, we shall manually edit the SQL
    to address these issues while enjoying the comfort of Navicat’s code editor.
  prefs: []
  type: TYPE_NORMAL
- en: I think it’s a good idea to concatenate the first and last names to show them
    in a single column, change the column title of department names to something sensible,
    exclude the CEO from the query results by adding another condition to the query,
    and sort the results by the amount of salaries in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve these little goals, we’ll modify the SQL to resemble the following
    code listing and re-run the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Navicat also provides us with the ability to show the query profile and status,
    thanks to which we can monitor certain status parameters, such as table locks,
    system locks, and statistics under the **Profile** tab in the query results window.
    Refer to the following screen shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building further queries](img/7461EN_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a great deal of database features from Navicat
    and we learned how to create and manage database objects using Navicat’s visual
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know how to make use of Navicat’s GUI tools to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database and perform its initial setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and manage database objects such as tables and views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define foreign key constraints and triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create stored procedures and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule tasks using MySQL events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design and customize queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will see in detail Navicat’s data management tools and
    learn how to manipulate and transform databases easily using Navicat.
  prefs: []
  type: TYPE_NORMAL
