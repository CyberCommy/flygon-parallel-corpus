- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The programming solutions for each chapters'' questions can be found in our
    GitHub repository at the following URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master).
    Each full program solution can be found in the GitHub under the appropriate chapter
    heading (subdirectory, such as `Chapter01`) in the subdirectory `Assessments`,
    in a file that corresponds to the chapter number, followed by a dash, followed
    by the solution number in the chapter at hand. For example, the solution for question
    3 in chapter 1 can be found in the subdirectory `Chapter01/Assessments` in a file
    named `Chp1-Q3.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The written responses for non-programming questions can be found in the following
    sections. Should an exercise have a programming portion and a follow-up question,
    the answer to the follow-up question may be found both in the next sections and
    in a comment at the top of the programming solution on GitHub (as it may be appropriate
    to review the solution in order to fully understand the answer to the question).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 – Understanding Basic C++ Assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `flush` may be useful, rather than an `endl`, for clearing the contents of
    a buffer associated with `cout` for the situations where you do not wish the cursor
    to be advanced to the next line for output. Recall, an `endl` manipulator is merely
    a newline character plus a buffer flush.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choosing a pre versus a post increment for a variable, such as `++i` (versus
    `i++`), will have an impact on the code when used in conjunction with a compound
    expression. A typical example would be `result = array[i++];` versus `result =
    array[++i];`. With the post-increment (`i++`), the contents of `array[i]` will
    be assigned to `result` and then `i` is incremented. With the pre-increment, `i`
    is first incremented and then `result` will have the value of `array[i]` (that
    is, using the new value of `i` as an index).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter01/Assessments/Chp1-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2 – Adding Language Necessities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The signature of a function is the function's name plus its type and number
    of arguments (no return type). This relates to name mangling as the signature
    helps the compiler provide a unique, internal name for each function. For example,
    `void Print(int, float);` may have mangled name of `Print_int_float();`. This
    facilitates overloaded functions by giving each function a unique name so that
    when a call is made, it is evident by the internal function name as to which function
    is being invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "`Chapter02/Assessments/Chp2-Q2.cpp` in the \LGitHub repository."
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Chapter 3 – Indirect Addressing: Pointers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter03/Assessments/Chp3-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Print(Student)` is less efficient than `Print(const Student *)` as the initial
    version of this function passes an entire object on the stack, whereas the overloaded
    version passes only a pointer on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have an existing pointer to an object of type `Student`, such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Student *s0 = new Student;` (this `Student` is not yet initialized with data)'
  prefs: []
  type: TYPE_NORMAL
- en: '`const Student *s1;` (does not require initialization)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Student *const s2 = s0;` (requires initialization)'
  prefs: []
  type: TYPE_NORMAL
- en: '`const Student *const s3 = s0;` (also requires initialization)'
  prefs: []
  type: TYPE_NORMAL
- en: Passing an argument of type `const Student *` to `Print()` would allow a pointer
    to a `Student` to be passed into `Print()` for speed, yet the object pointed to
    could not be dereferenced and modified. Yet passing a `Student * const` as a parameter
    to `Print()` would not make sense because a copy of the pointer would be passed
    to `Print()`. Marking that copy additionally as `const` (meaning not allowing
    changing where the pointer points) would then be meaningless as disallowing a
    *copy* of a pointer to be changed has no effect on the original pointer itself.
    The original pointer was never in jeopardy of its address being changed within
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many programming situations that might use a dynamically allocated
    3-D array. For example, if an image is stored in a 2-D array, a collection of
    images might be stored in a 3-D array. Having a dynamically allocated 3-D array
    allows for any number of images to be read in from a filesystem and stored internally.
    Of course, you'd need to know how many images you'll be reading in before making
    the 3-D array allocation. For example, a 3-D array might hold 30 images, where
    30 is the third dimension to collect the images in a set. To conceptualize a 4-D
    array, perhaps you would like to organize sets of the aforementioned 3-D arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, perhaps you have a set of 31 images for the month of January. That
    set of January images is a 3-D array (2-D for the image and the third dimension
    for the set of 31 images comprising January). You may wish to do the same for
    every month. Rather than having separate 3-D array variables for each month's
    image set, we can create a fourth dimension to collect the years' worth of data
    into one set. The fourth dimension would have an element for each of the 12 months
    of the year. How about a 5-D array? You can extend this image idea by making the
    fifth dimension a way to collect various years of data, such as collecting images
    for a century (fifth dimension). Now we have images organized by century, then
    organized by year, then by month, and then by image (the image requiring the first
    two dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 4 – Indirect Addressing: References'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter04/Assessments/Chp4-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReadData(Student *)` that accepts a pointer to a `Student` and reference variables
    need not only call the version of `ReadData(Student &)` that accepts a reference
    to a `Student`. For example, a pointer variable may be dereferenced with `*` and
    then call the version that accepts a reference. Likewise, a reference variable
    may have its address taken using `&` and then call the version that accepts a
    pointer (though this is less commonly done). You simply need to make the data
    types match with respect to what you are passing and what the function expects.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 – Exploring Classes in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter05/Assessments/Chp5-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6 – Implementing Hierarchies with Single Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter06/Assessments/Chp6-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Chapter06/Assessments/Chp6-Q2.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7 – Utilizing Dynamic Binding through Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter07/Assessments/Chp7-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8 – Mastering Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter08/Assessments/Chp8-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Shape` class may or may not be considered an interface class. If your implementation
    is an abstract class that contains no data members and only abstract methods (pure
    virtual functions), your `Shap`e implementation is considered an interface class.
    If your `Shape` class, however, stores `area` as a data member once it has been
    calculated by the overridden `Area()` method in the derived classes, it is then
    just an abstract base class.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 – Exploring Multiple Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Chapter09/Assessments/Chp9-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LifeForm` sub-object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LifeForm` constructor and destructor are each invoked once.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LifeForm` would be invoked if the specifications of an alternate constructor
    of `LifeForm(1000)` was removed in the member initialization list of the `Centaur`
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Please see `Chapter09/Assessments/Chp9-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LifeForm` sub-objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LifeForm` constructor and destructor are each invoked twice.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10 – Implementing Association, Aggregation, and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Chapter10/Assessments/Chp10-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (follow-up question) Once you have overloaded a constructor that accepts a `University
    &` as a parameter, this version may be invoked using a `University *` by first
    dereferencing the pointer to the `University` within the constructor call (to
    make a referenceable object).
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter10/Assessments/Chp10-Q2.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Chapter10/Assessments/Chp10-Q3.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11 – Handling Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter11/Assessments/Chp11-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12 – Friends and Operator Overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Chapter12/Assessments/Chp12-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter12/Assessments/Chp12-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter12/Assessments/Chp12-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13 – Working with Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter13/Assessments/Chp13-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter13/Assessments/Chp13-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14 – Understanding STL Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter14/Assessments/Chp14-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter14/Assessments/Chp14-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter14/Assessments/Chp14-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter14/Assessments/Chp14-Q4.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 15 – Testing Classes and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**a**: Your classes follow orthodox canonical class form if they each include
    a (user-specified) default constructor, copy constructor, overloaded assignment
    operator, and a virtual destructor. Your classes additionally follow extended
    canonical class form if they also include a move copy constructor and an overloaded
    move assignment operator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**b**: Your class will be considered robust if it follows canonical class form
    and ensures that all instances of a class have the means to be fully-constructed.
    Testing a class can ensure robustness.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter15/Assessments/Chp15-Q2.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter15/Assessments/Chp15-Q3.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 16 – Using the Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter16/Assessments/Chp16-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Observer pattern include any
    application requiring customers to receive a notification of backordered products
    that they desire. For example, many people may wish to receive the Covid-19 vaccine
    and wish to be on a waiting list at a vaccine distribution site. Here, a `VaccineDistributionSite`
    (the subject of interest) can be inherited from `Subject` and contain a list of
    `Person` objects, where `Person` inherits from `Observer`. The `Person` objects
    will contain a pointer to the `VaccineDistributionSite`. Once enough supply for
    the vaccine exists at a given `VaccineDistributionSite` (that is, a distribution
    event has occurred), `Notify()` can be called to update the `Observer` instances
    (people on the wait-list). Each `Observer` will be sent an `Update()`, which will
    be the means to allow that person to schedule an appointment. If the `Update()`
    returns success and the person has been scheduled for an appointment, the `Observer`
    can release itself from the waiting list with the `Subject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17 – Applying the Factory Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter17/Assessments/Chp17-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Factory Method pattern include
    many types of applications in which various derived classes may need to be instantiated
    based upon the specific values provided at construction. For example, a payroll
    application may require various types of `Employee` instances, such as `Manager`,
    `Engineer`, `Vice-President`, and so on. A factory method can provide a way to
    instantiate the various types of `Employee` based on the information provided
    when the `Employee` is hired. The Factory Method pattern is a pattern that can
    be applied to many types of applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 18 – Applying the Adapter Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter18/Assessments/Chp18-Q1.cpp` in the GitHub repository.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Adapter pattern include many
    examples of repurposing existing, well-tested non-OO code to provide an OO interface
    (that is, a wrapper type of Adapter). Other examples include creating an Adapter
    to convert a formerly used class into a currently needed class (again with the
    idea of reusing previously created and well-tested components). An example is
    to adapt a `Car` class that has been previously used to represent gasoline engine
    cars into a class that models an `ElectricCar`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 19 – Using the Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chapter19/Assessments/Chp19-Q1.cpp`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot label the `static instance()` method as virtual in `Singleton` and
    override it in `President` simply because static methods can never be virtual.
    They are statically bound and also never receive a `this` pointer. Also, the signature
    may need to be different (and no one likes an un-intentional function hiding situation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the Singleton pattern include creating
    a Singleton `CEO` of a company or a Singleton `TreasuryDepartment` for a country
    or a Singleton `Queen` of a nation. Each of these Singleton instances offers the
    opportunity to establish a registry to keep track of multiple Singleton objects.
    That is, many countries may have a single `Queen`. In this case, the registry
    would allow not just one Singleton per object type, but one Singleton per other
    qualifiers, such as *nation*. This is an example of the rare case where more than
    one Singleton object of a given type can occur (but always a controlled number
    of such objects).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 20 – Removing Implementation Details Using the pImpl Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Please see `Chapter20/Assessments/Chp20-Q1.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please see `Chapter20/Assessments/Chp20-Q2.cpp` in the GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Follow-up question) Simply inheriting `Student` from the `Person` class in
    this chapter that embraces the pImpl pattern presents no logistical difficulties.
    Additionally, modifying the `Student` class to also employ the pImpl pattern and
    utilize a unique pointer is more challenging. Various approaches may run across
    various difficulties, including dealing with inline functions, down-casting, avoiding
    explicit calls to the underlying implementation, or requiring back pointers to
    help invoke virtual functions. Please see the online solution for details.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples which may easily incorporate the pImpl pattern for relative implementation
    independence include creating generic GUI components, such as for `Window`, `Scrollbar`,
    `Textbox`, and so on, for various platforms (derived classes). The implementation
    details can easily be hidden. Other examples include proprietary commercial classes
    that the developer wishes to hide the implementation details that might otherwise
    be seen in a header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
