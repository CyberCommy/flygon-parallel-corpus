- en: Chapter 6. Solar System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was 8 years old, for a science project at school, I made a *Solar System*
    from wires, styrofoam balls, and paint. Today, 8-year olds all around the world
    will be able to make virtual Solar Systems in VR, especially if they read this
    chapter! This project creates a Cardboard VR app that simulates our Solar System.
    Well, maybe not with total scientific accuracy, but good enough for a kid's project
    and better than styrofoam balls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will create a new Solar System project with the `RenderBox`
    library by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `Sphere` component and a solid color material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an `Earth` texture material with lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arranging the Solar System geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating the heavenly bodies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactively changing camera locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the `RenderBox` library with our new code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we put these together, we will create planets and moons from a sphere. Much
    of the code, however, will be in the various materials and shaders for rendering
    these bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/solarsystem](https://github.com/cardbookvr/solarsystem)
    (with each topic as a separate commit).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build this project, we will use our `RenderBox` library created in [Chapter
    5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You can use yours,
    or grab a copy from the downloadable files provided with this book or our GitHub
    repository (use the commit tagged `after-ch5`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final *Using RenderBox in future projects* section of [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. Perform the following steps
    to create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: With Android Studio opened, create a new project. Let's name it `SolarSystem`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create new modules for each of `renderbox`, `common` and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the modules as dependencies for the app, using **File** | **Project Structure**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While we build this project, we will be creating new classes that could be
    good extensions to `RenderBox` lib. We''ll make them regular classes in this project
    at first. Then, at the end of the chapter, we''ll help you move them into the
    `RenderBox` lib project and rebuild the library:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `solarsystem` folder (`com.cardbookvr.solarsystem`), select
    **New** | **Package**, and name it `RenderBoxExt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `RenderBoxExt`, create package subfolders named `components` and `materials`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's no real technical need to make it a separate package, but this helps
    organize our files, as the ones in `RenderBoxExt` will be moved into our reusable
    library at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a cube to the scene, temporarily, to help ensure that everything
    is set up properly. Add it to the `setup` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you remember, a cube is a component that's added to a transform. The cube
    defines its geometry (for example, vertices). The transform defines its position,
    rotation, and scale in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to click on **Run 'app'** with no compile errors, and see
    the cube and Cardboard split screen view on your Android device.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Sphere component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our Solar System will be constructed from spheres, representing planets, moons,
    and the Sun. Let's first create a `Sphere` component. We are going to define a
    sphere as a triangle mesh of vertices that form the surface of the sphere (For
    more information on a triangle mesh, refer to [https://en.wikipedia.org/wiki/Triangle_mesh](https://en.wikipedia.org/wiki/Triangle_mesh)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `RenderBoxExt/components` folder, select **New** | **Java
    Class**, and name it `Sphere`. Define it as `public class Sphere extends RenderObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls a helper method, `allocateBuffers`, which allocates buffers
    for vertices, normals, textures, and indexes. Let''s declare variables for these
    at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've decided to declare the buffers `public` to afford future flexibility
    in creating arbitrary texture materials for objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define a sphere with a radius of 1\. Its vertices are arranged by 24
    longitude sections (as hours of the day) and 16 latitude sections, providing sufficient
    resolution for our purposes. The top and bottom caps are handled separately. This
    is a long method, so we''ll break it down for you. Here''s the first part of the
    code where we declare and initialize variables, including the vertices array.
    Similar to our `Material` setup methods, we only need to allocate the `Sphere`
    buffers once, and in this case, we use the vertex buffer variable to keep track
    of this state. If it is not null, the buffers have already been allocated. Otherwise,
    we should continue with the function, which will set this value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculate the vertex positions; first, the top and bottom ones and then along
    the latitude/longitude spherical grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we calculate the vertex normals and then the UVs for texture mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This next part of the same `allocateBuffers` method generates the triangular
    indices, which connect the vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, apply these calculated values to the corresponding `vertexBuffer`,
    `normalBuffer`, `texCoordBuffer`, and `indexBuffer` arrays, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a lot of code, and might be hard to read on the pages of a book; you
    can find a copy in the project GitHub repository if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, since the sphere is centered at the origin (0,0,0), the normal
    vectors at each vertex correspond to the vertex position itself (radiating from
    the origin to the vertex). Strictly speaking, since we used a radius of 1, we
    can avoid the `normalize()` step to generate the array of normals as an optimization.
    The following image shows the 24 x 16 vertex sphere with its normal vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Sphere component](img/B05144_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that our algorithm includes an interesting fix that avoids a single vertex
    at the poles (where all the UVs converge at a single point and cause some swirling
    texture artifacts).
  prefs: []
  type: TYPE_NORMAL
- en: 'We create *nLon-1* co-located vertices spread across the UV X, offset by *1/(nLon*2)*,
    drawing teeth at the top and bottom. The following image shows the flattened UV
    sheet for the sphere illustrating the polar teeth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Sphere component](img/B05144_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A solid color lighted sphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start by rendering our sphere in a solid color but with lighted
    shading. As usual, we start by writing the shader functions that, among other
    things, define the program variables they will need from the `Material` that uses
    it. Then, we'll define the `SolidColorLightingMaterial` class and add it to the
    `Sphere` component.
  prefs: []
  type: TYPE_NORMAL
- en: Solid color lighting shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapters, where we used shaders with lighting, we did the lighting
    calculations in the vertex shader. That's simpler (and faster), but transitioning
    the calculations to the fragment shader yields better results. The reason is that,
    in the vertex shader, you only have one normal value to compare against the light
    direction. In the fragment, all vertex attributes are interpolated, meaning that
    the normal value at a given point between two vertices will be some point in between
    their two normals. When this is the case, you see a smooth gradient across the
    triangle face, rather than localized shading artifacts around each vertex. We
    will be creating a new `Material` class to implement lighting in the fragment
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, create an Android Resource Directory for the shaders (resource
    type: `raw`), `res/raw/`. Then, create the `solid_color_lighting_vertex.shader`
    and `res/raw/solid_color_lighting_fragment.shader` files and define them as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/solid_color_lighting_vertex.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have separate uniform variables for `u_MV` and `u_MVP`. Also, if
    you remember that in the previous chapter, we separated the lighting model from
    the actual model because we did not want scale to affect lighting calculations.
    Similarly, the projection matrix is only useful to apply the camera FOV to vertex
    positions and will interfere with lighting calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/solid_color_lighting_fragment.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Solid color lighting material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we define the `Material` class for the shaders. In the materials folder,
    create a new Java class named `SolidColorLightingMaterial` and define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the variables for color, program references, and buffers, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add a constructor, which receives a color (RGBA) value and sets
    up the shader program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen earlier, the `setupProgram` method creates the shader program
    and obtains references to its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we add a `setBuffers` method that is called by the `RenderObject`
    component (`Sphere`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the `draw` code, which will be called from the `Camera` component,
    to render the geometry prepared in the buffers (via `setBuffers`). The `draw`
    method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a solid color lighting material and shaders, we can add them
    to the `Sphere` class to be used in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Material to a Sphere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this `Material` with the `Sphere`, we''ll define a new constructor (`Sphere`)
    that calls a helper method (`createSolidColorLightingMaterial`) to create the
    material and set the buffers. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we can now add the sphere to our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Sphere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how this looks! We'll create a scene with a sphere, a light, and a
    camera. Remember that, fortunately, the `RenderBox` class creates the default
    `Camera` and `Light` instances for us. We just need to add the `Sphere` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your `MainActivity.java` file to add the sphere in `setup`. We''ll color
    it yellowish and position it at *x*, *y*, *z* location (2, -2, 5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it should look like, a stereoscopic pair of golden globes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the Sphere](img/B05144_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you see what I see, you deserve an award for that!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Earth texture material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll terraform our sphere into a globe of the Earth by rendering a texture
    onto the surface of the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can get quite complex, implementing all kinds of specular highlights,
    reflections, shadows, and so on. A simpler algorithm that still makes use of a
    color texture and lighting is a diffuse material. This is what we'll use here.
    The word diffuse refers to the fact that light diffuses across the surface, as
    opposed to being reflective or shiny (specular lighting).
  prefs: []
  type: TYPE_NORMAL
- en: 'A texture is just an image file (for example, `.jpg`) that can be mapped (projected)
    onto a geometric surface. Since a sphere isn''t easily flattened or unpeeled into
    a two-dimensional map (as centuries of cartographers can attest), the texture
    image will look distorted. The following is the texture we''ll use for the Earth.
    (A copy of this file is provided with the download files for this book and similar
    ones can be found on the Internet at [http://www.solarsystemscope.com/nexus/textures/](http://www.solarsystemscope.com/nexus/textures/)):'
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we plan to make use of the standard practice of packaging
    image assets into the `res/drawable` folder. If necessary, create this folder
    now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `earth_tex.png` file to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `earth_tex` texture is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Earth texture material](img/B05144_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Loading a texture file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need a function to load the texture into our app. We can add it to `MainActivity`.
    Or, you can add it directly to the `RenderObject` class of your `RenderBox` lib.
    (It''s fine in `MainActivity` for now, and we''ll move it along with our other
    extensions to the library at the end of this chapter.) Add the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `loadTexture` method returns an integer handle that can be used to reference
    the loaded texture data.
  prefs: []
  type: TYPE_NORMAL
- en: Diffuse lighting shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may now be familiar, we are going to create a new `Material`, which uses
    new shaders. We'll write the shaders now. Create the two files in the `res/raw`
    folder named `diffuse_lighting_vertex.shader` and `diffuse_lighting_fragment.shader`,
    and define them as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `res/raw/diffuse_lighting_vertex.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'File: `res/raw/diffuse_lighting_fragment.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These shaders add attributes to a light source and utilize geometry normal vectors
    on the vertices to calculate the shading. You might have noticed that the difference
    between this and the solid color shader is the use of texture2D, which is a **sampler
    function**. Also, note that we declared `u_Texture` as sampler2D. This variable
    type and function make use of the texture units, which are built into the GPU
    hardware, and can be used with UV coordinates to return the color values from
    a texture image. There are a fixed number of texture units, depending on graphics
    hardware. You can query the number of texture units using OpenGL. A good rule
    of thumb for mobile GPUs is to expect eight texture units. This means that any
    shader may use up to eight textures simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Diffuse lighting material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can write a `Material` to use a texture and shaders. In the `materials/`
    folder, create a new Java class, `DiffuseLightingMaterial`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the variables for the texture ID, program references, and buffers, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add a constructor, which sets up the shader program and loads the
    texture for the given resource ID, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen earlier, the `setupProgram` method creates the shader program
    and obtains references to its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we add a `setBuffers` method that is called by the `RenderObject`
    component (`Sphere`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the `draw` code, which will be called from the `Camera` component,
    to render the geometry prepared in the buffers (via `setBuffers`). The `draw`
    method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this with the `SolidColorLightingMaterial` class that we defined earlier,
    you will notice that it's quite similar. We've replaced the single color with
    a texture ID, and we've added the requirements for a texture coordinate buffer
    (`texCoordBuffer`) given by a `Sphere` component. Also, note that we are setting
    the active texture unit to `GL_TEXTURE0` and binding the texture.
  prefs: []
  type: TYPE_NORMAL
- en: Adding diffuse lighting texture to a Sphere component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the new material to the `Sphere` component, we'll make an alternative
    constructor that receives a texture handle. It then creates an instance of the
    `DiffuseLightingMaterial` class and sets the buffers from the sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the material to the `Sphere` component by defining a new constructor
    (`Sphere`) that takes the texture ID and calls a new helper method named `createDiffuseMaterial`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the textured material.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Earth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add the Earth texture to our sphere, modify the `setup` method of `MainActivity`
    to specify the texture resource ID instead of a color, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There you have it, *Home Sweet Home!*
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the Earth](img/B05144_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That looks really cool. Oops, it''s upside down! Although there''s not really
    a specific up versus down in outer space, our Earth looks upside down from what
    we''re used to seeing. Let''s flip it in the `setup` method so that it starts
    at the correct orientation, and while we''re at it, let''s take advantage of the
    fact that the `Transform` methods return themselves, so we can chain the calls,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, the Earth is supposed to spin. Let''s animate it to rotate it like
    we''d expect the Earth to do. Add this to the `preDraw` method, which gets called
    before each new frame. It uses the `Time` class''s `getDeltaTime` method, which
    returns the current fraction of a second change since the previous frame. If we
    want it to rotate, say, -10 degrees per second, we use *-10 * deltaTime*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That looks good to me! How about you?
  prefs: []
  type: TYPE_NORMAL
- en: Changing the camera position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more thing. We seem to be looking at the Earth in line with the light source.
    Let's move the camera view so that we can see the Earth from the side. That way,
    we can see the lighted shading better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we leave the light source position at the origin, (0,0,0) as if it
    were the Sun at the center of the Solar System. The Earth is 147.1 million km
    from the Sun. Let''s place the sphere that many units to the right of the origin,
    and place the camera at the same relative position. Now, the `setup` method looks
    like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it and this is what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the camera position](img/B05144_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Does that look virtually realistic or what? NASA would be proud!
  prefs: []
  type: TYPE_NORMAL
- en: Day and night material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Honestly though, the back of the Earth looks uncannily dark. I mean, this isn't
    the 18th century. So much nowadays is 24 x 7, especially our cities. Let's represent
    this with a separate Earth night texture that has city lights.
  prefs: []
  type: TYPE_NORMAL
- en: We have a file for you to use named `earth_night_tex.jpg`. Drag a copy of the
    file into your `res/drawable/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be a little difficult to discern on this book''s page, but this is what
    the texture image looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Day and night material](img/B05144_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Day/night shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To support this, we will create a new `DayNightMaterial` class that takes both
    versions of the Earth texture. The material will also incorporate the corresponding
    fragment shader that takes into consideration the normal vector of the surface
    relative to the light source direction (using dot products, if you're familiar
    with vector math) to decide whether to render using the day or night texture image.
  prefs: []
  type: TYPE_NORMAL
- en: In your `res/raw/` folder, create files for `day_night_vertex.shader` and `day_night_fragment.shader`,
    and then define them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `day_night_vertex.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Except for the addition of `v_Texcoordinate`, this is exactly the same as our
    `SolidColorLighting` shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `day_night_fragment.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As always, for lighting, we calculate the dot product (`dotProd`) of the vertex
    normal vector and the light direction vector. When that value is negative, the
    vertex is facing away from the light source (the Sun), so we'll render using the
    night texture. Otherwise, we'll render using the regular daytime earth texture.
  prefs: []
  type: TYPE_NORMAL
- en: The lighting calculations also include a blend value. This is basically a way
    of squeezing the transitional zone closer around the terminator when calculating
    the `gl_FragColor` variable. We are multiplying the dot product by 2.0 so that
    it follows a steeper slope, but still clamping the blend value between 0 and 1\.
    It's a little complicated, but once you think about the math, it should make some
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: We are using two textures to draw the same surface. While this might seem unique
    to this day/night situation, it is actually a very common method known as multitexturing.
    You may not believe it, but 3D graphics actually got quite far before introducing
    the ability to use more than one texture at a time. These days, you see multitexturing
    almost everywhere, enabling techniques such as normal mapping, decal textures,
    and displacement/parallax shaders, which create greater detail with simpler meshes.
  prefs: []
  type: TYPE_NORMAL
- en: The DayNightMaterial class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can write the `DayNightMaterial` class. It's basically like the `DiffuseLightingMaterial`
    class that we created earlier but supports both the textures. Therefore, the constructor
    takes two texture IDs. The `setBuffers` method is identical to the earlier one,
    and the `draw` method is nearly identical but with the added binding of the night
    texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete code, highlighting the lines that differ from `DiffuseLightingMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As with our other materials, declare the variables we''ll need, including the
    texture ID for both the day and night:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the constructor that takes both the resource IDs and the `setupProgram`
    helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `draw` method that cranks it all out to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Rendering with day/night
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we're ready to integrate the new material into our `Sphere` component and
    see how it looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Sphere.java`, add a new constructor and the `createDayNightMaterial` helper
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call it from the `setup` method of `MainActivity`, and replace the call
    with the new `Sphere` instance passing both the textures'' resource IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run it now. That looks really cool! Classy! Unfortunately, it doesn't make a
    lot of sense to paste a screenshot here because the city night lights won't show
    very well. You'll just have to see it for yourself in your own Cardboard viewer.
    Believe me when I tell you, it's worth it!
  prefs: []
  type: TYPE_NORMAL
- en: Next, *here comes the Sun, and I say, it's alright...*
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Sun
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sun will be rendered as a textured sphere. However, it's not shaded with
    front and back sides like our Earth. We need to render it unlit or rather unshaded.
    This means we need to create the `UnlitTextureMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: We have a texture file for the Sun, too (and all the planets as well).We won't
    show all of them in the chapter although they're included with the downloadable
    files for the book.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a copy of the `sun_tex.png` file onto your `res/drawable/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Unlit texture shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen earlier in this book, unlit shaders are much simpler than ones
    with lighting. In your `res/raw/` folder, create files for `unlit_tex_vertex.shader`
    and `unlit_tex_fragment.shader`, and then define them, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'File: `unlit_tex_vertex.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'File: `unlit_tex_fragment.shader`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Yup, that's simpler than our earlier shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Unlit texture material
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can write the `UnlitTexMaterial` class. Here''s the initial code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the constructor, `setupProgram`, and `setBuffers` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be handy to have getter and setter methods for the texture ID (in later
    projects, not used here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, here''s the `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Rendering with an unlit texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're ready to integrate the new material into our `Sphere` class and see how
    it looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Sphere.java`, add a new constructor that takes a `boolean` parameter, indicating
    that the texture should be lighted, and the `createUnlitTexMaterial` helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the way in which we've defined constructors, you can call either
    new `Sphere(texId)` or `Sphere(texId, true)` to get lighted renders. But for unlit,
    you must use the second one as `Sphere(texId, false)`. Also note that setting
    up the whole component in the constructor is not the only way to go. We only do
    it this way because it keeps our `MainActivity` code concise. In fact, as we start
    expanding our use of `RenderBox` and its shader library, it will become necessary
    to put most of this code into our `MainActivity` class. It would be impossible
    to create a constructor for every type of material. Ultimately, a materials system
    is necessary to allow you to create and set materials without having to create
    a new class for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Sun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, all we need to do is add the Sun sphere to the `setup` method of `MainActivity`.
    Let's make it big, say, at a scale of 6.963 (remember that's in millions of kms).
    This value may seem arbitrary now, but you'll see where it comes from when we
    run the calculations on the Solar System geometry and scale the planets as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `setup` method of `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining an origin transform that will be the center of the Solar
    System. Then, we create the Sun, parented to the origin, with the given scale.
    Then, add a new sphere component with the Sun texture. We've also given our light
    a slightly yellowish color, which will blend with the Earth's texture colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the rendered Sun looks like, which seems to illuminate the Earth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Sun](img/B05144_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to the rest of the Solar System.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Planet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build our Solar System, it will be useful to abstract out a `Planet` class
    to be used for each planet.
  prefs: []
  type: TYPE_NORMAL
- en: Planets have a number of different attributes that define their unique characteristics
    in addition to their texture resource IDs. Planets have a distance from the Sun,
    size (radius), and an orbital speed. Planets all orbit around the Sun as their
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: The distance will be its distance from the Sun measured in millions of kilometers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The radius will be the planet's size in kilometers (actually in millions of
    kilometers, to be consistent).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotation is the rate at which the planet rotates about its own axis (one of
    its days).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orbit is the rate at which the planet rotates about the Sun (one of its years).
    We will assume a perfectly circular orbit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TexId` is the resource ID of the texture image for the planet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`origin` is the center of its orbit. For planets, this will be the Sun''s transform.
    For a moon, this will be the moon''s planet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Solar System is a really big thing. The distances and radii are measured
    in millions of kilometers. The planets are really far apart and relatively small
    compared to the size of their orbits. The rotation and orbit values are relative
    rates. You'll note that we'll normalize them to 10 seconds per Earth day.
  prefs: []
  type: TYPE_NORMAL
- en: 'From these attributes, a planet maintains two transforms: one transform for
    the planet itself and another transform that describes its location in orbit.
    In this way, we can rotate each planet''s separate parent transform which, when
    the planet is at a local position whose magnitude is equal to the orbital radius,
    causes the planet to move in a circular pattern. Then we can rotate the planet
    itself using its transform.'
  prefs: []
  type: TYPE_NORMAL
- en: For the Moon, we'll also use the `Planet` class (yeah, I know, maybe we should
    have named it `HeavenlyBody`?) but set its origin as the Earth. The moon does
    not rotate.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your app (for example, `app/java/com/cardbookvr/solarsystem/`), create a
    Java class and name it `Planet`. Add variables for its attributes (`distance`,
    `radius`, `rotation`, `orbit`, `orbitTransform`, and `transform`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a constructor that takes the planet''s attribute values, initializes
    the variables, and calculates the initial transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The constructor generates an initial transform for the planet and adds a `Sphere`
    component with the given texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'On each new frame, we will update the `orbitTransform` rotation around the
    Sun (year) and the planet''s rotation about its own axis (day):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also provide a couple of accessor methods for the `Planet` class''s
    transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at the geometry of our Solar System.
  prefs: []
  type: TYPE_NORMAL
- en: Formation of the Solar System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our chance to throw some real science into our project. The following
    table shows the actual distance, size, rotation, and orbit values for each of
    the planets. (Most of this data came from [http://www.enchantedlearning.com/subjects/astronomy/planets/](http://www.enchantedlearning.com/subjects/astronomy/planets/).)
  prefs: []
  type: TYPE_NORMAL
- en: '| Planet | Distance from Sun (millions km) | Radius size (km) | Day length
    (Earth hours) | Year length (Earth years) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mercury | 57.9 | 2440 | 1408.8 | 0.24 |'
  prefs: []
  type: TYPE_TB
- en: '| Venus | 108.2 | 6052 | 5832 | 0.615 |'
  prefs: []
  type: TYPE_TB
- en: '| Earth | 147.1 | 6371 | 24 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Earth''s Moon | 0.363 (from Earth) | 1737 | 0 |   |'
  prefs: []
  type: TYPE_TB
- en: '| Mars | 227.9 | 3390 | 24.6 | 2.379 |'
  prefs: []
  type: TYPE_TB
- en: '| Jupiter | 778.3 | 69911 | 9.84 | 11.862 |'
  prefs: []
  type: TYPE_TB
- en: '| Saturn | 1427.0 | 58232 | 10.2 | 29.456 |'
  prefs: []
  type: TYPE_TB
- en: '| Uranus | 2871.0 | 25362 | 17.9 | 84.07 |'
  prefs: []
  type: TYPE_TB
- en: '| Neptune | 4497 | 24622 | 19.1 | 164.81 |'
  prefs: []
  type: TYPE_TB
- en: '| Pluto (still counts) | 5913 | 1186 | 6.39 | 247.7 |'
  prefs: []
  type: TYPE_TB
- en: 'We also have texture images for each of the planets. These files are included
    with the downloads for this book. They should be added to the `res/drawable` folder,
    named `mercury_tex.png`, `venus_tex.png`, and so on. The following table identifies
    the sources we have used and where you can find them as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Planet | Texture |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Mercury | [http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Venus | [http://csdrive.srru.ac.th/55122420119/texture/venus.jpg](http://csdrive.srru.ac.th/55122420119/texture/venus.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Earth | [http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg)Night:
    [http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Earth''s Moon | [https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg](https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mars | [http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg](http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Jupiter | [http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Saturn | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Uranus | [http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg](http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Neptune | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pluto | [http://www.shatters.net/celestia/files/pluto.jpg](http://www.shatters.net/celestia/files/pluto.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sun | [http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg](http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Milky Way | [http://www.geckzilla.com/apod/tycho_cyl_glow.png](http://www.geckzilla.com/apod/tycho_cyl_glow.png)
    (by Judy Schmidt, [http://geckzilla.com/](http://geckzilla.com/)) |'
  prefs: []
  type: TYPE_TB
- en: Setting up planets in MainActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to set up all the planets in `MainActivity` using a `setupPlanets`
    method that will be called from `setup`. Let's go for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the class, declare a `planets` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we declare a number of constants which we''ll explain in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setupPlanets` method uses our celestial data and builds new planets accordingly.
    First, let''s define the physical data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `distances` array has the distance of each planet from the Sun in millions
    of km. This is really huge, especially for the outer planets that are really far
    away and are not very visible relative to other planets. To make things more interesting,
    we'll fudge the distance of those planets (Jupiter through Pluto), so the values
    that we'll use are in the `fudged_distances` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `radii` array has the actual size of each planet in kms.
  prefs: []
  type: TYPE_NORMAL
- en: The `rotations` array has the day length, in Earth hours. Since Mercury and
    Venus spin really fast compared to the Earth, we'll artificially slow them down
    by arbitrary scale factors.
  prefs: []
  type: TYPE_NORMAL
- en: The `orbits` array has the length of each planet's year in Earth years and the
    time it takes for one complete rotation around the Sun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up the texture IDs for each planet''s materials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now initialize the `planets` array, creating a new `Planet` object for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: While we fudged some of the planets' actual distances so that they'd be closer
    to the inner Solar System, we also multiply all the distances by a `DISTANCE_FACTOR`
    scalar, mostly to not blow up our float precision calculations. We scale all the
    planet sizes by a different `SCALE_FACTOR` variable to make them relatively larger
    than life (a factor of 0.0001 is actually a factor of 100 because radii are calculated
    in km while the distance is calculated in millions of km).
  prefs: []
  type: TYPE_NORMAL
- en: The rotation animation rate is the actual length of the day of the planet scaled
    by how fast we want to animate a day in VR. We default to 10 seconds per Earth
    day.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the planetary orbit animation has its own scale factor. We've sped it
    up about 2 X. You can also adjust the orbit rate of the distance fudge factors
    (for example, Pluto orbits the Sun once every 247 Earth years, but we've moved
    it a lot closer so it needs to slow down).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the Earth''s moon. We''ve used some artistic license here as well,
    adjusting the distance and radius and speeding up its orbit rate to make it compelling
    to watch in VR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at one more method: `goToPlanet`. It''ll be convenient to
    position the `Camera` near a specific planet. Since the planets are located at
    data-driven positions and will be moving in orbit, it''s best to make the camera
    a child of the planet''s transform. This is one of the reasons why we separated
    out the orbiting transform from the planet''s transform. We don''t want the camera
    to spin around with the planet—you might get sick! Here''s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the scale and distance values we finally use in the code are derived
    from but not the actual celestial measurements. For a lovely VR experience of
    the Solar System with real educational value, check out Titans of Space ([http://www.titansofspacevr.com/](http://www.titansofspacevr.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Camera's planet view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gotoPlanet` function is called with a planet index (for example, Earth
    is 2), so we can position the camera near the specified planet. The `Camera` component
    gets parented to the planet's `orbitTransform` variable as a way to obtain the
    planet's current orbit rotation. Then, it's positioned as the planet's distance
    from the Sun, and then offset a bit, relative to the planet's size.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity` class''s setup method, we have already set up the Sun and
    the Earth. We''ll replace the Earth sphere with a call to a `setupPlanets` helper
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run the project now, you will see the Earth, the Sun, and maybe
    some of the planets. But not until they're moving in their orbits will they come
    to life.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the heavenly bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the planets instantiated, we can animate their orbit and
    axis rotations. All it takes is updating their transforms in the `MainAcitvity`
    class''s `preDraw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Run! Oh, wow! I feel like a god. Well, not exactly, because it's dark outside.
    We need stars!
  prefs: []
  type: TYPE_NORMAL
- en: A starry sky dome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if the Universe was just a giant ball and we're inside it? That's what
    we're going to imagine to implement a starry sky spherical background.
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics, you can create backgrounds to make the scene look bigger
    than it really is. You can use a spherical texture, or skydome, as we will use
    here. (A common alternative in many game engines is a cuboid skybox, constructed
    from six internal faces of a cube.)
  prefs: []
  type: TYPE_NORMAL
- en: Among the set of textures that we provided with this book is `milky_way_tex.png`.
    Drag a copy of this file into your `res/drawable/` directory, if it's not there
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the starry sky dome to our scene. Add the following code to
    `MainActivity.setup()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This looks so much more celestial.
  prefs: []
  type: TYPE_NORMAL
- en: '![A starry sky dome](img/B05144_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might be wondering what that 0.99 factor is all about. Different GPUs deal
    with floating point numbers differently. While some might render a vertex at the
    draw distance one way, others might exhibit render glitches when the geometry
    is "on the edge" due to a floating point precision. In this case, we just pull
    the skybox toward the camera by an arbitrarily small factor. It is especially
    important in VR that the skybox be as far away as possible, so that it is not
    drawn with parallax. The fact that the skybox is in the same exact place for the
    left and right eye is what tricks your brain into thinking that it's infinitely
    far away. You may find that you need to tweak this factor to avoid holes in the
    skybox.
  prefs: []
  type: TYPE_NORMAL
- en: Fine tuning the Earth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're a space geek, you might be thinking that there are a few things we
    could do to our Earth model. For one, we should add the night view texture. (Mars
    and the other planets don't need one because their cities shut off all their lights
    at night.) Also, the Earth is slightly tilted on its axis. We can fix that.
  prefs: []
  type: TYPE_NORMAL
- en: The night texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s add the night texture. To do this, let''s make an `Earth` Java
    class a subclass of a `Planet`. Right-click on your Java `solarsystem` folder,
    select **New** | **Java Class**, and name it `Earth`. Then, start defining it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This requires that we add a new constructor to the `Planet` class, which omits
    `texId`, since the Earth constructor creates the new `Sphere` component, this
    time with two textures, `textId` and `nightTexId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Planet.java`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `MainActivity`, let''s create an Earth separately from the other planets.
    In `setupPlanets`, modify the loop to handle this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Axis tilt and wobble
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among all its greatness, like all nature and mankind, the Earth is not perfect.
    In this case, we're talking about tilt and wobble. The Earth's axis of rotation
    is not exactly perpendicular to the orbital plane. It also suffers from a slight
    wobble as it rotates. We can show this in our virtual model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Earth` class constructor to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Earth''s rotation on each frame is against this wobble transform,
    so give Earth its own `preDraw` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Changing the camera location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final feature of our Solar System is to make it more interactive. I mean
    all these planets look so cool, but you can't really see them from so far away.
    How about clicking on the Cardboard trigger to jump from planet to planet, nice
    and up close?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we already have a `goToPlanet` method that we used to set our initial
    view from the Earth. Because `MainActivity` extends `CardboardActivity`, we can
    use the Cardboard SDK's `onCardboardTrigger` method (refer to [https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger()](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger())).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The app will start with the camera near the Earth (index 2). When the user presses
    the cardboard trigger (or touches the screen), it'll go to Mars (3). Then, Jupiter,
    and so on, and then cycle back to Mercury (0).
  prefs: []
  type: TYPE_NORMAL
- en: Possible enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Can you think of other enhancements to this project? Here are a few you could
    consider and try to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Add rings to Saturn. (A cheap way to implement might be a plane with transparency.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve `goToPlanet` so that your camera position animates between positions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add controls to allow you to change the perspective or fly freely through space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a top-down view option, for a "traditional" picture of the Solar System.
    (Be aware of float precision issues at scale.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add moons to each of the other planets. (This can be implemented just like we
    did for the Earth's moon, with its mother planet as its origin.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Represent the asteroid belt between Mars and Jupiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add tilt and wobble to the other planets. Did you know that Uranus spins on
    its side?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add text labels to each planet that use the planet's transform but always face
    the camera. In lieu of 3D text objects, the labels could be prepared images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add background music.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the positional accuracy in such a way that it accurately represents
    the relative positions of each planet on a given date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the RenderBox library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Solar System project implemented and our code stabilized, you might
    realize that we've built some code that is not necessarily specific to this application,
    which can be reused in other projects, and ought to make its way back to the `RenderBox`
    library. That's what we'll do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend you do this directly within Android Studio, selecting and copying
    from this project''s hierarchy view to the other''s. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move all the `.shader` files from the Solar System's `res/raw/` directory into
    the `res/raw/` directory of the `RenderBox` lib's `RenderBox` module. If you've
    been following along, there will be eight files for the vertex and fragment `.shader`
    files for `day_night`, `diffuse_lighting`, `solid_color_lighting`, and `unilt_tex`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move all the `Component` and `Material` `.java` files from the Solar System's
    `RenderBoxExt` module folder to the corresponding folders in `RenderBox` lib's
    `RenderBox` module. Remove all invalid references to `MainActivity` in the source
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Solar System project, we implemented a method named `loadTexture` in
    `MainActivity`. It rightfully belongs to the `RenderBox` library. Find the declaration
    for `loadTexture` in the Solar System's `MainActivity.java` file, and cut the
    code. Then, open the `RenderObject.java` file in `RenderBox` lib and paste the
    definition into the `RenderObject` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `RenderBox` lib, replace (refactor) all the instances of `MainActivity.loadTexture`
    with `RenderObject.loadTexture`. These will be found in several `Material` Java
    files, where we load material textures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `RenderBox.java`, the `reset()` method destroys the handles of any materials.
    Add the calls for the new materials that we just introduced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DayNightMaterial.destroy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DiffuseLightingMaterial.destroy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SolidColorLightingMaterial.destroy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnlitTexMaterial.destroy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolve any package name mismatches, and fix any other compile-time errors,
    including removing any references to `solarsystem` throughout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should be able to successfully rebuild the library (**Build** | **Make
    Module 'renderbox'**) to generate an updated `renderbox[-debug].aar` library file.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the Solar System project can now use the new `.aar` library. Copy the
    `renderbox[-debug].aar` file from the `RenderBoxLib` project's `renderbox/build/output`
    folder into the SolarSystem `renderbox/` folder, replacing the older version of
    the same file with the newly built one. Build and run the Solar System project
    with this version of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! You received an "A" on your Solar System science project!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we built a Solar System simulation that can be viewed in virtual
    reality using a Cardboard VR viewer and an Android phone. This project uses and
    expands the `RenderBox` library, as discussed in [Chapter 5](ch05.html "Chapter 5. RenderBox
    Engine"), *RenderBox Engine*.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we added a `Sphere` component to our repertoire. Initially, it was
    rendered using a solid color lighting material. Then, we defined a diffuse lighting
    material and rendered the sphere with an Earth image texture, resulting in a rendered
    globe. Next, we enhanced the material to accept two textures, adding an additional
    one to the back/"night" side of the sphere. And lastly, we created an unlit texture
    material, which is used for the Sun. Armed with actual sizes of the planets and
    distances from the Sun, we configured a Solar System scene with nine planets,
    the Earth's moon, and the Sun. We added a star field as a sky dome, and we animated
    the heavenly bodies for their appropriate rotation (day) and orbit (year). We
    also implemented some interaction, responding to Cardboard trigger events by moving
    the camera view from planet to planet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll get to use our sphere again, this time, to view your
    library of 360-degree photos.
  prefs: []
  type: TYPE_NORMAL
