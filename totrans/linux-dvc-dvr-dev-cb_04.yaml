- en: Using the Device Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern computers are really complex systems composed of complex peripherals,
    which have tons of different configuration settings; that's why having all possible
    variants of device driver configurations in a dedicated file can solve a lot of
    problems. Having a logical description about how a system is structured (that
    is how they are interconnected to each other and not just their list) can allow
    system developers to focus their attention on device driver mechanisms without
    the boring job of managing all possible user settings.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, knowing how every peripheral is connected to the system (for example,
    which bus a peripheral is dependent on) allows the implementation of a really
    smart peripheral management system. Such a system can correctly activate (or deactivate),
    in the right order, all the subsystems needed, by a specific device, to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example: think about a USB key, which activates several devices
    when plugged into your PC. The system knows that the USB port is connected to
    a specific USB controller, which is mapped at a specific address into the system''s
    memory, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons (and others), Linux developers adopted **the device tree,** which
    is, simply speaking, a data structure to describe hardware. Rather than hard-coding
    every kernel setting into the code, it can be described in a well-defined data
    structure which is passed to the kernel during booting by the bootloader. This
    is also where all device drivers (and other kernel entities) can fetch their configuration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the device tree and the kernel configuration file
    (the `.config` file in the upper directory of Linux sources) is that while such
    files tell us which components of the kernel are enabled and which are not, the
    device tree holds their configurations. So, if we wish to add a driver from the
    kernel's sources to our system, we have to specify it in the `.config` file. On
    the other hand, if we wish to specify the driver's settings (memory addresses,
    special settings, and so on), we have to specify them in the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll see how to write a device tree and how we can get useful
    information for our driver from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the device tree compiler and utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting application-specific data from a device tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a device tree to describe a character driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading the firmware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a CPU's pin for specific peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more information on this chapter in the *Appendix.*
  prefs: []
  type: TYPE_NORMAL
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04).
  prefs: []
  type: TYPE_NORMAL
- en: Using the device tree compiler and utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need proper tools to convert our code into a binary format that Linux can
    understand. Specifically, we need a way to convert a **device tree source** (**DTS**)
    file into its binary form: **device tree binary** (**DTB**).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll discover how to install the **device tree compiler** (`dtc`)
    on our system and how we can use it to generate the binary for any device tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert a DTS file into a DTB one we have to use the **device tree compiler**
    (named `dtc`) and a set of proper tools we can use to inspect or manipulate DTB
    files (**device tree utilities**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Every recent Linux release has its own copy of the `dtc` program in the `linux/scripts/dtc` directory,
    which is used during kernel compilation. However, we don''t need to install Linux
    sources to have a working release of `dtc` and its utilities on Ubuntu; in fact,
    we can get them all by using the usual install command as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation, we can execute the `dtc` compiler as follows in order to
    display its release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are ready to convert our first DTS file into its equivalent DTB binary
    form using the following step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using the `dtc` compiler with the following command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`simple_platform.dts` can be retrieved from GitHub sources; however the reader
    can use his/her own DTS file to test `dtc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our DTB file should be available in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting a DTS file into a DTB one is similar to how a normal compiler works,
    but something should be said about the reverse operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at `simple_platform-reverted.dts`, we notice that it looks
    very similar to the original `simple_platform.dts` file (apart from phandles,
    labels, and numbers in hexadecimal form); in fact, we have the following differences
    regarding clock settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we have the following differences regarding the serial controller settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that the  `serial0` and `clks` labels
    have disappeared since they are not needed in a DTB file; phandles are also now
    explicitly reported and, with corresponding symbolic names such as `ipic` and `clks`, have
    been replaced accordingly, and all numbers have been converted to their hexadecimal
    form.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The device tree is a really complex piece of software and it's a powerful way
    to describe a system, which is why we need to talk a bit more about it. We should
    also take a look at device tree utilities due to the fact it is very useful for
    a kernel developer to manage a device tree binary form.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting a binary device tree into its source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dtc` program can revert the compilation process, allowing the developer
    to retrieve a source file from a binary using a command line such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This can be very useful when we need to inspect a DTB file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about the `dtc` compiler, the reader can take a look
    at the device tree user manual at [https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt](https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding device tree utilities, a good starting point is their respective man
    pages (`man fdtput`, `man fdtget` and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting application-specific data from a device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to read a device tree file and how to manage it in userspace.
    In this recipe, we will see how we can extract the configuration settings it holds
    within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To do our job, we can use all the data stored in the DTB to boot our ESPRESSObin
    and then use the ESPRESSObin as a system test.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, ESPRESSObin''s DTS file is stored in kernel sources at `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts` or
    it can be extracted from the running kernel by executing the `dtc` command as
    presented in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take this file apart since we can use it to verify that the data that
    we just read is correct.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show how we can read data from the running device tree, we can use a kernel
    module (like the one reported in file `get_dt_data.c`) from GitHub sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the file, we have an empty module `exit()` function, due to the fact we
    don''t allocate anything in the module''s `init()` function; in fact, it just
    shows us how we can parse a device tree. The `get_dt_data_init()` function takes
    an optional input parameter: a device tree path stored into the `path` variable
    defined in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as the first step, the `get_dt_data_init()` function uses the `of_find_node_by_path()`
    function to get a pointer to the desired node to inspect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, it calls the `print_main_prop()` function, which just prints the node''s
    main properties as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each printing function is reported as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last two steps, the  `get_dt_data_init()`function uses the `for_each_property_of_node()` macro
    to display all of the node''s property, and the  `for_each_child_of_node()` macro
    to iterate all the node''s children and display all of their main properties,
    as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In step 1, it's quite obvious that if we insert the module into the kernel specifying `path=<my_path>`, we
    force the desired value; otherwise, we simply accept the default, which is the
    root (represented by the  `/` character). The rest of the steps are quite self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the code should be very easy; in fact the `get_dt_data_init()`
    function simply calls `of_find_node_by_path()`, passing the device path name;
    no errors, we use `print_main_prop()` to display the node name and some main (or
    interesting) properties of the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `print_property_u32()` and `print_property_string()` functions
    are defined in such a way as to display nothing if the supplied property is not
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Functions such as `of_property_read_u32()`/`of_property_read_string()` and `for_each_child_of_node()`/`for_each_property_of_node()` and
    friends are defined in the header file `linux/include/linux/of.h` of kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once compiled from the `get_dt_data.c`  file, we should get its compiled version
    named `get_dt_data.ko`, which is suitable for loading into the ESPRESSObin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what we should get if we use `modinfo` in our newly created
    kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, so let''s try using the default value for the `path` by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get an output such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `/` as the path name, we obviously found a corresponding entry in
    the device tree, so the output continues as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are all properties of the root node that can be verified against
    the original sources or in the `espressobin-reverted.dts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Readers should notice that, in this case, the `name` property is empty due to
    the fact we are inspecting the root node, and for the `compatible` property only
    the first entry is displayed because we used the `of_property_read_string()` function
    instead of the corresponding array  `of_property_read_string_array()` version
    and friends.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of the node''s properties, our program will move through all of its
    children as reported in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `get_dt_data_init()` function does a `return -EINVAL`, not
    to return an error condition, but to force a module to unload; in fact, as the
    last printed out message, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just to show a different usage, we can try to ask for information regarding
    the system''s CPUs by specifying the `path=/cpus` command in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The program says that a node is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it starts printing the node''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it displays all of the children''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following error message can be safely ignored because we force
    it to automatically retrieve the module to be unloaded by the `insmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module get_dt_data.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, we can obtain information regarding the I2C controller
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see all available functions for inspecting a device tree, the reader can
    take a look at the included `linux/include/linux/of.h` file, which is well documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a device tree to describe a character driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have all the information needed to define a new character
    device by using a device tree. In particular, this time, to register our `chrdev`
    device, we can use the new API that we skipped in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated in the previous paragraph, we can use a device tree node to add a
    new device to our system. In particular, we can obtain a definition as reported
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All these modifications can be applied using the  `add_chrdev_devices.dts.patch` file  in
    the root directory of the kernel sources, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p1 < ../github/chapter_04/chrdev/add_chrdev_devices.dts.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: Then the kernel must be recompiled and reinstalled (with the ESPRESSObin's DTB
    file) in order to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are defining a `chrdev` node, which defines a new set of
    devices compatible with `"ldddc,chrdev"` and with two subnodes; each subnode defines
    a particular device with its own settings. The first subnode defines a `"ldddc,chrdev"`
    device labeled `"cdev-eeprom"` with a  `reg` property equal to `2`, while the
    second subnode defines another `"ldddc,chrdev"` device labeled `"cdev-rom"` with
    a  `reg` property equal to `4`, and with a  `read-only` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `#address-cells` and `#size-cells` properties must be 1 and 0 because the
    subdevice's `reg` property holds a single value representing something as the
    "device address". In fact, devices that are addressable use  `#address-cells`,  `#size-cells`, and
    the `reg` property to encode address information into the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each addressable device obtains a `reg` property, which is a list as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each tuple represents an address range used by the device and each address or
    length value is a list of one or more 32-bit integers called **cells** (the length
    can also be empty as in our example).
  prefs: []
  type: TYPE_NORMAL
- en: Since both the address and length fields may vary and be of variable size, the
    `#address-cells` and `#size-cells` properties in the parent node are used to state
    how many cells are in each subnode's field.
  prefs: []
  type: TYPE_NORMAL
- en: For further information regarding the  `#address-cells`, `#size-cells`, and
    `reg` properties, you can take a look at the device tree specification at [https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to see how we can use the preceding device tree definition to
    create our char devices (note that this time we're going to create more than one
    device!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the module''s `init()` and `exit()` functions must be rewritten as
    shown in the following code. `chrdev_init()` looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chrdev_exit()` function looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All code can be retrieved from GitHub sources in the `chrdev.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to insert the module into the kernel, we should get something like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the character device, we must use the next  `chrdev_device_register()` function,
    but we must first do some checks regarding whether the device has already been
    created or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we do something a little bit more complicated than we''ve done in the
    previous chapter, in which we simply called the `register_chrdev()` function;
    now the really important thing is the calling sequence of the  `cdev_init()`, `cdev_add()`, and `device_create()` functions,
    which actually do the job, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `device_create()` function returns success, we use the `dev_set_drvdata()` function to
    save a pointer to our driver data, which is then initialized like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'All these functions operate on `struct chrdev_device`, defined as  the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*,within `chrdev_init()` function, this time, we use the  `alloc_chrdev_region()` function, which
    asks the kernel to reserve some character devices named `chrdev` (in our case,
    this number is equivalent to the `MAX_DEVICES` definition). The `chrdev` information
    is then stored in the `chrdev_devt` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should be careful and notice that we also create a device class by
    calling the  `class_create()` function. Each device defined for the device tree
    must belong to a proper class and, since our `chrdev` driver is new, we need a
    dedicated class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next steps, I will be more clear about the reason we need to do it this
    way; for the moment, we should consider it as a compulsory data allocation.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite clear that the  `unregister_chrdev_region()` function just releases
    all of the `chrdev` data allocated in `with alloc_chrdev_region()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3*, if we take a look at the `/proc/devices` file, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Good! Now we've got something similar to [Chapter 3](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=27&action=edit#post_26), *Working
    with Char Drivers*! However, this time, if we try to create a special character
    file by using `mknod` and try to read from it, we get an error!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The kernel tells us that the device doesn't exist! This is because we have not
    yet created anything, but just reserved some kernel internal data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4*,the first fields are just relative to our specific implementation,
    while the last four are present in almost every character driver implementation:
    the  `id` field is just a unique identifier of each `chrdev` (remember that our
    implementation supports `MAX_DEVICES` instances), the  `owner` pointer is used
    to store the owner of our driver''s module, the  `cdev` structure holds all of
    the kernel data about our character device, and the  `dev` pointer points to a
    kernel `struct device` related to the one we specify in the device tree.'
  prefs: []
  type: TYPE_NORMAL
- en: So, `cdev_init()` is used to initialize `cdev` with our file operations; `cdev_add()` is
    used to define major and minor numbers of our driver; `device_create()` is used
    to glue the `devt` data to the data pointed to by `dev`; and our `chrdev` class
    (represented by the  `chrdev_class` pointer) actually creates the character device.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the  `chrdev_device_register()` function is not called by any function
    in the `chrdev.c` file; this is why it has been declared as an exported symbol
    using the  `EXPORT_SYMBOL()` definition. In fact, this function is called the 
     `chrdev_req_probe()` function, defined in another module as a file named `chrdev-req.c`, which
    is reported in the following snippet. The function first understands how many
    devices we have to register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for each device, after reading the device''s properties, the  `chrdev_device_register()` calls to
    register the device on the system (and it will do for every device reported in
    the device tree as illustrated in the preceding code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But how can the system know when the  `chrdev_req_probe()` function must be
    called? Well, it''s quite clear if we keep reading `chrdev-req.c`; in fact, near
    the end, we find the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When we insert the `chrdev-req.ko` module into the kernel, we define a new platform
    driver by using `module_platform_driver()`, then the kernel starts looking for
    a node with the `compatible` property set to `"ldddc,chrdev"`; if found, it executes
    the function pointed at by the `probe` pointer we set to `chrdev_req_probe()`.
    This causes a new driver to be registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before showing how it works, let''s take a look at the opposite steps, intended
    to deallocate whatever we requested from the kernel during character driver allocation.
    When we remove the `chrdev-req.ko` module, the kernel invokes the platform driver''s `remove` function,
    that is `chrdev_req_remove()` in the `chrdev-req.c` file, as partially reported
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This function, which is inside the `chrdev.c` file, calls `chrdev_device_unregister()` (for
    each `chrdev` node in the device tree) and is reported in the following; and it
    starts by doing some sanity checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But then it unregisters the driver by using the  `device_destroy()` and `cdev_del()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a device tree is not just useful for describing a peripheral (and then
    the whole system); by using it, we can also gain access to several ready-to-use
    features that Linux offers to kernel developers. So let's take a look at the most
    important (and useful) ones.
  prefs: []
  type: TYPE_NORMAL
- en: How device files are created in /dev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working with Char
    Drivers*, when we created a new character device nothing happened in the user
    space and we had to create a character device file by hand using the `mknod` command;
    however, in this chapter, when we inserted the second kernel module, which created
    our new `chrdev` devices. By getting their properties from the device tree, in
    the `/dev` directory, two new character files were automatically created.
  prefs: []
  type: TYPE_NORMAL
- en: It's Linux's kernel object mechanism that implements this magic; let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new device is created in the kernel, a new kernel event is generated
    and sent to the user space; this new event is then captured by a dedicated application
    that interprets it. These special applications may vary but the most famous application
    of this type used by almost all important Linux distributions is the `udev` application.
  prefs: []
  type: TYPE_NORMAL
- en: The `udev` daemon is born to replace and create a mechanism to automatically
    create special device files under the `/dev` directory, and it works so well that
    it is now used for several different tasks. In fact, the `udev` daemon receives
    device kernel events (called **uevents**) directly from the kernel whenever a
    device is added or removed from the system (or when it changes its state), and
    for each event, it executes a set of rules according to its configuration files.
    A rule is executed if it matches various device attributes and it then creates
    new files in the `/dev` directory accordingly; a matching rule may also provide
    additional device information to be used to create meaningful symlink names, execute
    scripts, and much more!
  prefs: []
  type: TYPE_NORMAL
- en: For further information regarding `udev` rules, a good starting point is a related
    page in the Debian Wiki at [https://wiki.debian.org/udev](https://wiki.debian.org/udev)[.](https://wiki.debian.org/udev)
  prefs: []
  type: TYPE_NORMAL
- en: 'To monitor these events, we can use the `udevadm` tool, which comes within
    the `udev` package as reported in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: By using the `monitor` subcommand, we select the  `udevadm` monitor features
    (since `udevadm` can do several other tasks) and by specifying the `-k` option
    argument we ask for kernel-generated messages only to be displayed (since some
    messages may come from the userspace too); also, by using the `-p`  option argument,
    we ask for event properties to be displayed and, with the `-s` option argument,
    we select messages from the subsystem matching the `chrdev` string only.
  prefs: []
  type: TYPE_NORMAL
- en: To see all kernel messages, during the `chrdev` module insertion the kernel
    sends just execute `udevadm monitor` command, dropping all of these option arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see new events, just execute the above command, and, in another terminal
    (or directly from the serial console) repeat the kernel module insertion. After
    inserting the `chrdev-req.ko` module we see the same kernel messages as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the terminal where we executed the `udevadm` message, we should
    now see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are the kernel messages informing `udev` that two new devices named `/dev/cdev-eeprom@2`
    and `/dev/cdev-rom@4` have been created (with other properties), so `udev` has
    all the information it needs to create new files under the `/dev` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the firmware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the device tree, we''re now able to specify a lot of different settings
    for our driver, but there is still one last thing we have to see: how to load
    firmware into our device. In fact, some devices may require a program for themselves
    to work which, for license reasons, cannot be linked within the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to see some examples of how we can ask the kernel
    to load firmware for our device.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some peripherals need firmware to work and then we need a mechanism to load
    such binary data into them. Linux provides us with different mechanisms to do
    this job and they all refer to the `request_firmware()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we use a `request_firmware(..., "filename", ...)` function call (or
    one of its friends) in our driver (specifying a filename), the kernel starts looking
    at different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it takes a look at the boot image file and, in case, the firmware
    is loaded from it; this is because we can bundle binary code with the kernel during
    compilation. However, this solution is permitted only if the firmware is free
    software; otherwise it cannot be linked to Linux. It is also not very flexible
    when changing firmware data if we have to recompile the kernel too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no data has been stored within the kernel, it starts to load the firmware
    data directly from the filesystem by looking for the `filename` in several path
    locations starting from the one specified for the kernel command line with the `firmware_class.path="<path>"`
    option argument, then in `/lib/firmware/updates/<UTS_RELEASE>`, then into `/lib/firmware/updates`,
    then into `/lib/firmware/<UTS_RELEASE>`, and, finally, in the  `/lib/firmware` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<UTS_RELEASE>` is the kernel release version number, which can be obtained
    directly from the kernel by using the `uname -r` command as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ uname -r`'
  prefs: []
  type: TYPE_NORMAL
- en: '`4.15.0-45-generic`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this last step fails too, then the kernel may try a fallback procedure,
    which consists of enabling the firmware loader user helper. This last chance to
    load firmware must be enabled for the kernel configuration by enabling the following
    kernel configuration settings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By using the usual `make menuconfig` method, we have to go through Device Drivers,
    then Generic Driver Options, and Firmware loader entries to enable them (see the
    following screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8414861b-4598-45f0-a655-6a71fa163629.png)'
  prefs: []
  type: TYPE_IMG
- en: After we have enabled these settings and recompiled the kernel, we can explore,
    in detail, how we can load custom firmware for our driver within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need a modified version of the `chrdev-req.c` file focused on firmware
    loading; that's why it's better to use another file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do our job, we can use the `chrdev-fw.c` file with the following device
    definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The  `chrdev-fw.c` file can be found in the GitHub sources for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this situation, our probing function can be implemented as follows, where
    at the beginning of the `chrdev_req_probe()` function we read some of the device''s
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We then register the char device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A former device type calls the  `chrdev_load_fw_wait()` function, which carries
    out the next steps. It starts by requesting the firmware''s data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It then dumps the data received and finally releases the firmware''s previously
    allocated data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FIRMWARE_VER` and `FIRMWARE_NLEN` macros have been defined within the  `chrdev-fw.c` file as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define FIRMWARE_VER     "1.0.0"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`#define FIRMWARE_NLEN    128`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, in the `of_chrdev_req_match[]` array, we now have two devices that
    we can use to test different ways of loading firmware. One device, named `ldddc,chrdev-fw_wait` can
    be used to test direct firmware loading from the filesystem, while the other,
    named `ldddc,chrdev-fw_nowait`, can be used to test the firmware loader's user
    helper.
  prefs: []
  type: TYPE_NORMAL
- en: I used these two examples to show the reader two different firmware loading
    techniques but, in reality, these two methods can be used for different purposes;
    the former can be used whenever our device needs its firmware since the startup
    otherwise it cannot work (this forces the driver not being built-in), while the
    former can be used when our device can be partially used even without any firmware
    and it can be loaded later after device initialization (which removes the mandatory
    built-in form).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, after reading the `firmware` property (holding the firmware file
    name) we check if the device is compatible with the `ldddc,chrdev-fw_wait` or `ldddc,chrdev-fw_nowait` device and
    then we call the proper firmware loading function, accordingly, before registering
    the new device.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*,the  `chrdev_load_fw_wait()` function builds up a filename in the
     `<name>-<version>.bin` form and then calls the effective firmware loading function
    named `request_firmware()`. In response, this function may return an error, which
    causes an error during the driver loading, or it can return a proper structure
    holding the firmware into the `buffer fw->data` pointer with the `long fw->size` size bytes.
    The `dump_data()` function simply dumps firmware data by printing it into kernel
    messages, but the   `release_firmware()` function is important and must be called
    to inform the kernel we have read all data and finished with it, and then it can
    release the resource.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we specify the `ldddc,chrdev-fw_nowait` device in the
    device tree, then the  `chrdev_load_fw_nowait()` function is called instead. This
    function operates in a similar manner as before, but at the end, it calls `request_firmware_nowait()`, which
    works like `request_firmware()`. However, if the firmware is not loaded directly
    from the filesystem, it executes the fallback procedure, which involves the firmware
    loader's user helper. This special helper sends a uevent message to the `udev` tool (or
    similar), which causes automatic firmware loading, or the creation of an entry
    within sysfs, which can be used by the user to manually load the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  `chrdev_load_fw_nowait()` function has the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Some important difference between `request_firmware_nowait()` and `request_firmware()` is
    that the former defines a callback function, which is invoked whenever the firmware
    is actually loaded from the user space, and it has, as a second parameter, a Boolean,
    which can be used to ask the kernel to send, or not, a uevent message to the userspace.
    By using a value, we achieve functionality similar to `request_firmware()`, while
    if we specify a false value (as in our case), we force manual firmware loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when a userspace process takes the required steps to load the desired
    firmware, the callback function is used and we can actually load firmware data
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we actually take the same steps as before to dump firmware
    data within kernel messages.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s just verify how everything works in this recipe. As the first step,
    let''s try using the  `ldddc,chrdev-fw_wait` device, which uses the `request_firmware()`
    function; we need the next entry in the device tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have to compile the code, and we can do this by simply adding our new  `chrdev-fw.c` file into
    the `makefile` as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have our new modules within ESPRESSObin''s filesystem, we can try inserting
    them into the kernel as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the kernel tries to load the `chrdev-wait-1.0.0.bin` file, but
    it cannot find it since it simply doesn't exist in the filesystem; then, the kernel
    moves to sysfs fallback, but since it fails again we get an error and the driver
    loading fails too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a positive result, we must add a file named `chrdev-wait-1.0.0.bin`
    into one of the search paths; for instance, we can put it in `/lib/firmware/`
    as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If the `/lib/firmware` directory doesn't exist, we can just create it using
    the `mkdir /lib/firmware` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can retry loading our `chrdev-fw.ko` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now the firmware has been loaded as desired and the `chrdev` device
    has been correctly created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try using the second device by modifying the device tree as follows
    and then rebooting the ESPRESSObin with the new DTB file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'With these new configuration settings, if we try to load the `chrdev` module,
    we get the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This time, the kernel still tries to directly load firmware from the filesystem,
    but it fails because no file named  `chrdev-nowait-1.0.0.bin` exists; it then
    falls back to the fallback firmware loader user helper, which we've forced into
    manual mode. However, the driver's probing function successfully registers our
    `chrdev` driver, which is now fully functional even if no firmware has been loaded
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually load firmware, we can use special sysfs entries in the `/sys/class/firmware/`
    directory as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The  `chrdev-nowait-1.0.0.bin` directory is called as the string passed as
    `fw_name` parameter to `request_firmware_nowait()` function, and, inside it, we
    find the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the required steps to automatically load firmware are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We start the download procedure by writing `1` into the `loading` file, then
    we have to copy all the firmware data into the `data` file; we then finish the
    download by writing `0` in the `loading` file. As soon as we do this, the kernel
    calls our driver's callback and the firmware is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding firmware loading, a good starting point is
    the Linux driver implementer's API guide, available online at [https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html](https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CPU pins for specific peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the device driver developer, this task is really important because to be
    able to talk with external devices (or internal ones but with external signal
    lines) we must be sure that each CPU pin is properly configured to talk with these
    external signals. In this recipe, we will look at how we can use the device tree
    to configure CPU pins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as a simple example, let's try to modify the pin configuration for our
    ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should take a look at the current configuration by looking
    at sysfs in the  `/sys/bus/platform/drivers/mvebu-uart/` directory, where we verify
    that only one UART is currently enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `mvebu-uart` drivers manage the  `d0012000.serial` device, which can
    be accessed using the `/dev/ttyMV0` file. We can also verify how the CPU''s pins
    are configured by taking a look at the `/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins` file in
    debugfs, where we can see that only the `uart1` group is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For further information about debugfs, see [https://en.wikipedia.org/wiki/Debugfs](https://en.wikipedia.org/wiki/Debugfs)
    [and then following some external links.](https://en.wikipedia.org/wiki/Debugfs)
  prefs: []
  type: TYPE_NORMAL
- en: 'We should then try to modify ESPRESSObin''s DTS file to enable another UART
    device named `uart1` with its own pins defined in the  `uart2_pins` group as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This pin group is defined in the `linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s check how this works by testing our pinctrl modification. For this,
    we have to regenerate ESPRESSObin''s DTB file, as usual, and restart the system.
    If everything works well, we should now have two UART devices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Also, if we take another look in the  `/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins` file, we
    see that this time the `uart2` pins group has been added and then our new serial
    port is available on extension connector P9 at pins 24 and 26.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information regarding the pinctrl subsystem, a good starting point
    is [https://www.kernel.org/doc/Documentation/pinctrl.txt](https://www.kernel.org/doc/Documentation/pinctrl.txt).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
