- en: Details of Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difficulty of designing, implementing, and maintaining a software project
    arises with respect to the complexity of the project. A simple calculator could
    be written using the procedural approach (that is, the procedural programming
    paradigm), while a bank account management system would be too complex to implement
    using the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ supports **Object-Oriented programming (OOP)**, a paradigm that is built
    upon dissecting entities into objects that exist in a web of close intercommunication.
    Imagine a simple scenario in the real world when you take the remote to change
    the TV channel. At least three different objects take part in this action: the
    remote, the TV, and, most importantly, you. To express the real-world objects
    and their relationship using a programming language, we aren''t forced to use
    classes, class inheritance, abstract classes, interfaces, virtual functions, and
    so on. The mentioned features and concepts make the process of designing and coding
    a lot easier as they allow us to express and share ideas in an elegant manner,
    but they are not mandatory. As the creator of C++, Bjarne Stroustrup, says, "Not
    every program should be object-oriented." To understand high-level concepts and
    features of the OOP paradigm, we will try to look behind the scenes. Throughout
    this book, we will dive into the design of object-oriented programs. Understanding
    the essence of objects and their relationship, and then using them to design object-oriented
    programs, is one of the goals of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ object model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class relationships, including inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the `-std=c++2a` option is used to compile the examples
    throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source files for this chapter at[ https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, we operate with a collection of data grouped under a certain
    name, thus making an **abstraction**. Variables such as `is_military`, `speed`,
    and `seats` don''t make much sense if they''re perceived separately. Grouping
    them under the name with `spaceship` changes the way we perceive the data stored
    in the variables. We now refer to the many variables packed as one single object.
    To do so, we use abstraction; that is, we collect the individual properties of
    a real-world object from the perspective of the observer. An abstraction is a
    key tool in the programmer''s toolchain as it allows them to deal with complexity.
    The C language introduced the `struct` as a way to aggregate data, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Grouping data is somewhat necessary for object-oriented programming. Each group
    of data is referred to as an object.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level details of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ does its best to support compatibility with the C language. While C structs
    are just a tool that allows us to aggregate data, C++ makes them equal to classes,
    allowing them to have constructors, virtual functions, inherit others structs,
    and so on. The only difference between a `struct` and a `class` is the default
    visibility modifier: `public` for structs and `private` for classes. There is
    usually no difference in using structs over classes or vice versa. OOP requires
    more than just a data aggregation. To fully understand OOP, let''s find out how
    we would we incorporate the OOP paradigm if we have only simple structs providing
    data aggregation and nothing more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A central entity of an e-commerce marketplace such as Amazon or Alibaba is
    the `Product`, which we represent in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add more members to the `Product` if necessary. The memory layout of
    an object of the `Product` type can be pictured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07ae95a7-5342-466b-84d1-60c5ffccb2a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Declaring a `Product` object takes `sizeof(Product)` space in memory, while
    declaring a pointer or a reference to the object takes the space required to store
    the address (usually 4 or 8 bytes). See the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can picture the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67e1849e-5135-4c27-ad35-ab9ef1638cfa.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's start with the space the `Product` object takes in memory. We can calculate
    the size of the `Product` object summing up the sizes of its member variables.
    The size of a `boolean` variable is 1 byte. The exact size of the `double` or
    the `int` is not specified in the C++ standard. In 64-bit machines, a `double` variable
    usually takes 8 bytes and an `int` variable takes 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `std::string` is not specified in the standard, so its
    size depends on the library implementation. `string` stores a pointer to a character
    array, but it also might store the number of allocated characters to efficiently
    return it when `size()` is called. Some implementations of `std::string` take
    8, 24, or 32 bytes of memory, but we will stick to 24 bytes in our example. By
    summing it up, the size of the `Product` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing the size of the `Product` outputs a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It outputs `40` instead of the calculated 37 bytes. The reason behind the redundant
    bytes is the padding of the struct, a technique practiced by the compiler to optimize
    the access to individual members of the object. The **Central Processing Unit
    (CPU)** reads the memory in fixed-size words. The size of the word is defined
    by the CPU (usually, it's 32 or 64 bits long). The CPU is able to access the data
    at once if it's starting from a word-aligned address. For example, the `boolean`
    data member of the `Product` requires 1 byte of memory and can be placed right
    after the rating member. As it turns out, the compiler aligns the data for faster
    access. Let's suppose the word size is 4 bytes. This means that the CPU will access
    a variable without redundant steps if the variable starts from an address that's
    divisible by 4\. The compiler augments the struct earlier with additional bytes
    to align the members to word-boundary addresses.
  prefs: []
  type: TYPE_NORMAL
- en: High-level details of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We deal with objects as entities representing the result of abstraction. We
    have already mentioned the role of the observer, that is, the programmer who defines
    the object based on the problem domain. The way the programmer defines this represents
    the process of abstraction. Let''s take an example of an e-commerce marketplace
    and its products. Two different teams of programmers might have different views
    of the same product. The team that implements the website cares about the properties
    of the object that are essential to website visitors: buyers. The properties that
    we showed earlier in the `Product` struct are mostly meant for website visitors,
    such as the selling price, the rating of the product, and so on. Programmers that
    implement the website touch the problem domain and verify the properties that
    are essential to defining a `Product` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The team that implements the online tools that help manage the products in
    the warehouse cares about the properties of the object that are essential in terms
    of product placement, quality control, and shipment. This team shouldn''t actually
    care about the **rating** of the product or even its **price**. This team mostly
    cares about the **weight**, **dimensions**, and **conditions** of the product. The
    following illustration shows the properties of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d45f90f5-f11f-41e0-8392-1f11fd254d95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that programmers should do when starting the project is to
    analyze the problem and gather the requirements. In other words, they should get
    familiar with the *problem domain* and define the *project requirements*. The
    process of analyzing leads to defining objects and their types, such as the `Product` we
    discussed earlier. To get proper results from analyzing, we should think in objects,
    and, by thinking in objects, we mean considering the three main properties of
    objects: **state**, **behavior**, and **identity**.'
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each object has a state that may or may not differ from the state of other
    objects. We''ve already introduced the `Product` struct, which represents an abstraction
    of a physical (or digital) product. All the members of a `product` object collectively
    represent the state of the object. For example, the `Product` contains members
    such as `available`, which is a Boolean; it equals `true` if the product is in
    stock. The values of the member variables define the state of the object. If you
    assign new values to the object member, its state will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The state of the object is the combination of all of its properties and values.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Identity is what differentiates one object from another. Even if we try to
    declare two physically indistinguishable objects, they will still have different
    names for their variables, that is, different identities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects in the preceding example have the same state, but they differ by
    the names we refer to them by, that is, `book1` and `book2`. Let''s say we had
    the ability to somehow create objects with the same name, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If this was the case, they would still have different addresses in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a53517c2-6eb7-46a1-80ba-806d57324296.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Identity is a fundamental property of the object and is one of the reasons
    why we can''t create *empty* objects, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will not output `0` as expected. The size of an empty object
    is not specified in the standard; compiler developers tend to allocate 1 byte
    for such objects, though you might encounter 4 or 8 as well. Two or more instances
    of `Empty` should have different addresses in memory, so the compiler must make
    sure objects will take up at least 1 byte of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous examples, we assigned `5` and then `4` to the `rating` member variable.
    We can easily make things unexpectedly wrong by assigning invalid values to the
    object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`-12` is invalid in terms of the rating of a product and will confuse users,
    if allowed to. We can control the behavior of the changes made to the object by
    providing **setter** functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An object acts and reacts to the requests from other objects. The requests are
    performed via function calls, which otherwise are called **messages**: an object
    passes a message to another. In the preceding example, the object that passed
    the corresponding `set_rating` message to the `cpp_book` object represents the
    object that we call the `set_rating()` function in. In this case, we suppose that
    we call the function from `main()`, which doesn't actually represent any object
    at all. We could say it's the global object, the one that operates the `main()`
    function, though there is not an entity like that in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'We distinguish the objects conceptually rather than physically. That''s the
    main point of thinking in objects. The physical implementation of some concepts
    of object-oriented programming is not standardized, so we can name the `Product` struct
    as a class and claim that `cpp_book` is an **instance** of the `Product` ,and
    that it has a member function called `set_rating()`. The C++ implementation almost
    does the same: it provides syntactically convenient structures (classes, visibility
    modifiers, inheritance, and so on) and translates them into simple structs with
    global functions such as `set_rating()` in the preceding example. Now, let''s
    dive into the details of the C++ object model.'
  prefs: []
  type: TYPE_NORMAL
- en: Mimicking a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A struct allows us to group variables, name them, and create objects. The idea
    of a class is to include the corresponding operations in the object, grouping
    both data and operations that are applicable to that particular data. For example,
    for the object of the `Product` type, it will be natural to call the `set_rating()` function
    on the object directly, rather than having a separate global function that takes
    a `Product` object via a pointer and modifies it. However, as we agreed to use
    structs in the C manner, we can''t afford it to have member functions. To mimic
    a class using a C struct, we have to declare functions that work with the `Product`
    object as global functions, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the struct as a class, we should manually call the functions in the
    proper order. For example, to use the object with properly initialized default
    values, we have to call the `initialize()` function first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems doable, but the preceding code will quickly turn into an unorganized
    mess if new types are added. For example, consider the `Warehouse` struct that
    keeps track of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first obvious issue is the naming of functions. We had to name the initializer
    function of the `Warehouse` `initialize_warehouse` to avoid conflict with the
    already declared `initialize()` function for the `Product`. We might consider
    renaming the functions for the `Product` type to avoid possible conflicts in the
    future. Next comes the mess with functions. Now, we have a bunch of global functions,
    which will increase in number as we add new types. It will be even more unmanageable
    if we add some hierarchy of types.
  prefs: []
  type: TYPE_NORMAL
- en: Though compilers tend to translate classes into structs with global functions,
    as we showed earlier, C++ and other high-level programming languages solve these
    and other issues that had not been mentioned by, introducing classes with smooth
    mechanisms of organizing them into hierarchies. Conceptually, keywords (`class`,
    `public`, or `private`) and mechanisms (inheritance and polymorphism) are there
    for developers to conveniently organize their code, but won't make the life of
    the compiler any easier.
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes make things a lot easier when dealing with objects. They do the simplest
    necessary thing in OOP: they combine data with functions for manipulating data.
    Let''s rewrite the example of the `Product` struct using a class and its powerful
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The class declaration seems more organized, even though it exposes more functions
    than we use to define a similar struct. Here''s how we should illustrate the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8a27344-1681-4f83-97ea-90d8f78dda1a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image is somewhat special. As you can see, it has organized sections,
    signs before the names of functions, and so on. This type of diagram is called
    a **Unified Modeling Language (UML)** class diagram. UML is a way to standardize
    the process of illustrating classes and their relationship. The first section
    is the name of the class (in bold), next comes the section for member variables,
    and then the section for member functions. The `+` (plus) sign in front of a function
    name means that the function is public. Member variables are usually private,
    but, if you need to emphasize this, you can use the `-` (minus) sign. We can omit
    all the details by simply illustrating the class, as shown in the following UML
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24e54100-c4fb-4c79-af94-8085e241f878.png)'
  prefs: []
  type: TYPE_IMG
- en: We will use UML diagrams throughout this book and will introduce new types of
    diagrams as needed. Before dealing with initializing, copying, moving, default
    and deleted functions, and, of course, operator overloading, let's clear a couple
    of things up.
  prefs: []
  type: TYPE_NORMAL
- en: Classes from the compiler perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, no matter how monstrous the class from earlier may seem in comparison
    to the previously introduced struct, the compiler will translate it into the following
    code (we slightly modified it for the sake of simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the compiler generates the same code that we introduced earlier as
    a way to mimic class behavior using a simple struct. Though compilers vary in
    techniques and methods of implementing the C++ object model, the preceding example
    is one of the popular approaches practiced by compiler developers. It balances
    the space and time efficiency in accessing object members (including member functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should consider that the compiler edits our code by augmenting and
    modifying it. The following code declares the global `create_apple()` function,
    which creates and returns a `Product` object with values specific to an apple.
    It also declares a book object in the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We already know that the compiler modifies the class to translate it into a
    struct and moves member functions to the global scope, each of which takes the
    reference (or a pointer) to the class as its first parameter. To support those
    modifications in the client code, it should also modify all access to the objects.
  prefs: []
  type: TYPE_NORMAL
- en: A line or lines of code that declare or use already declared class objects are
    referred to as **client code**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we will assume the compiler modifies the preceding code  (we used
    the word *assume* because we''re trying to introduce a compiler-abstract rather
    than a compiler-specific approach):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The compiler also optimized the call to the `create_apple()` function to avoid
    temporary object creation. We will discuss the invisible temporaries that were
    generated by the compiler later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown previously, the creation of an object is a two-step process: memory
    allocation and initialization. Memory allocation is a result of an object declaration.
    C++ doesn''t care about the initialization of variables; it allocates the memory
    (whether it is automatic or manual) and it''s done. The actual initialization
    should be done by the programmer, which is why we have a constructor in the first
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same logic follows for the destructor. If we skip the declarations of the
    default constructor or destructor, the compiler should generate them implicitly,
    which it would also remove in case they are empty (to eliminate redundant calls
    to empty functions). The default constructor will not be generated by the compiler
    if any constructor with parameters is declared, including the copy constructor.
    We can force the compiler to implicitly generate the default constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also can force it not to generate the compiler by using the `delete` specifier,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will prohibit default-initialized object declarations, that is, `Product
    p`; won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: Destructors are called in the order opposite to object declarations because
    the automatic memory allocation is managed by a stack and the stack, is a data
    structure adapter that follows the **last in, first out (****LIFO) **rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object initialization happens on its creation. Destruction usually happens
    when the object is no longer accessible. The latter may be tricky when the object
    is allocated on the heap. Take a look at the following code; it declares four
    `Product` objects in different scopes and segments of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`global_prod` has a static storage duration and is placed in the global/static
    section of the program; it is initialized before `main()` is called. When `main()`
    starts, `stack_prod` is allocated on the stack and will be destroyed when `main()`
    ends (the closing curly brace of the function is considered as its end). Though
    the conditional expression looks weird and too artificial, it''s a good way to
    express the block scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tmp` object will also be allocated on the stack, but its storage duration
    is limited to the scope it has been declared in: it will be automatically destroyed
    when the execution leaves the `if` block. That''s why variables on the stack have
    *automatic storage duration*. Finally, when the `foo()` function is called, it
    declares the `heap_prod` pointer, which points to the address of the `Product`
    object allocated on the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code contains a memory leak because the `heap_prod` pointer (which
    itself has an automatic storage duration) will be destroyed when the execution
    reaches the end of `foo()`, while the object allocated on the heap won''t be affected.
    Don''t mix the pointer and the actual object it points to: the pointer just contains
    the value of the object, but it doesn''t represent the object.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to deallocate the memory that's dynamically allocated on the heap,
    either by manually calling the delete operator or using smart pointers. Smart
    pointers will be discussed in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml), *Memory
    Management and Smart Pointers.*
  prefs: []
  type: TYPE_NORMAL
- en: When the function ends, the memory for its arguments and local variables allocated
    on the stack will be freed, but `global_prod` will be destroyed when the program
    ends, that is, after the `main()` function finishes. The destructor will be called
    when the object is about to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Copying objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of copying: a *deep* copy and a *shallow* copy of objects. The
    language allows us to manage copy-initialization and the assignment of objects
    with the **copy constructor** and the **assignment operator**. This is a necessary
    feature for programmers because we can control the semantics of copying. Take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The line `p1 = p2;` is a call to the assignment operator, while the last line
    is a call to the copy constructor. The equals sign shouldn't confuse you regarding
    whether it's an assignment or a copy constructor call. Each time you see a declaration
    followed by an assignment, consider it a copy construction. The same applies to
    the new initializer syntax (`Product p3{p2};`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler will generate the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The default implementation of the copy constructor (and assignment operator)
    performs a member-wise copy of objects, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a801266-0db0-4ca7-81e1-afa9b2da53a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Custom implementation is required in case the member-wise copy produces invalid
    copies. For example, consider the following copy of `Warehouse` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code declares two `Warehouse` objects, and two different products
    are then added to the warehouses. Though this example is somewhat unnatural, it
    shows the dangers of the default implementation of copying. The following illustration
    shows us what went wrong in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cb93f9f-29a1-4e3d-a0df-d9b226e141d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Assigning **w1** to **w2** leads to the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57f8bc17-d88a-4fd8-b03b-8263a6b20b2d.png)'
  prefs: []
  type: TYPE_IMG
- en: The default implementation simply copies each member of `w1` to `w2`. After
    copying, both `products_` members of `w1` and `w2` point to the same location
    on the heap. When we add a new product to `w2`, the array pointed to by `w1` is
    affected. It's a logical error that could lead to undefined behavior in the program.
    We need a *deep* rather than a *shallow* copy; that is, we need to actually create
    a new array of products that has a copy of w1's array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom implementation of the copy constructor and the assignment operator
    solves this issue of *shallow* copying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The custom implementation of the copy constructor creates a new array. Then,
    it copies the source objects' array elements one by one, this way eliminating
    the `product_` pointer from pointing to a wrong memory address. In other words,
    we implemented a deep copy of `Warehouse` objects by creating a new array.
  prefs: []
  type: TYPE_NORMAL
- en: Moving objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Temporary objects are everywhere in code. Most of the time, they are required
    to make the code work as expected. For example, when we add two objects together,
    a temporary object is created to hold the return value of `operator+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the implementation of the global `operator+()` for `Warehouse`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation declares a temporary object and returns it after
    filling it with necessary data. The call in the previous example could be translated
    into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The *move semantics*, which was introduced in C++11, allows us to skip the
    temporary creation by *moving* the return value into the `Warehouse` object. To
    do so, we should declare a **move constructor** for the `Warehouse`, which can
    *distinguish* between temporaries and treat them efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The parameter of the move constructor is an **rvalue reference** (**&&**).
  prefs: []
  type: TYPE_NORMAL
- en: Lvalue references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before understanding why rvalue references were introduced in the first place,
    let''s clear things up regarding `lvalues`, `references`, and `lvalue-references`.
    When a variable is an lvalue, it can be addressed, it can be pointed to, and it
    has a scoped storage duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`ref` is an `lvalue reference`, a synonym for a variable that can be treated
    as a `const` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Besides the ability to modify the objects by a reference, we pass heavy objects
    to functions by reference in order to optimize and avoid redundant object copies.
    For example, the `operator+` for the `Warehouse` takes two objects *by reference*,
    thus making it copy addresses of objects rather than full objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Lvalue` references optimize the code in terms of function calls, but, to optimize
    temporaries, we should move on to rvalue references.'
  prefs: []
  type: TYPE_NORMAL
- en: Rvalue references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cannot bind `lvalue` references to temporaries. The following code won''t
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to declare an `rvalue` reference to be able to bind to temporaries
    (including literal values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`Rvalue` references allow us to skip the generation of temporaries as much
    as possible. For example, a function that takes the result as an rvalue reference
    runs faster by eliminating temporary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To imagine the effect of moving, imagine that the preceding code will be translated
    into the following (just to get the full idea of moving):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving was introduced, the preceding code would look like this (with
    some compiler optimization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The move constructor, along with the move operator, `=()`, has the effect of
    copying without actually carrying out a copy operation when the input argument
    represents an `rvalue`. That''s why we should also implement these new functions
    in the class: so that we can optimize the code wherever it makes sense. The move
    constructor can grab the source object instead of copying it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of creating a new array of `capacity_` size and then copying each element
    of the `products_` array, we just grabbed the pointer to the array. We know that
    the `src` object is an rvalue and that it will soon be destroyed, which means
    the destructor will be called and the destructor will delete the allocated array.
    Now, we point to the allocated array from the newly created `Warehouse` object,
    which is why we cannot let the destructor delete the source array. Due to this,
    we assign `nullptr` to it to make sure the destructor will miss the allocated
    object. So, the following code will be optimized because of the move constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of `+` operator will be moved rather than copied. Take a look at
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7d0904d-6549-4c3c-aadd-6bb1785dfa17.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram demonstrates how the temporary is being moved to the large
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Notes on operator overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ provides a powerful mechanism for overloading operators for custom types.
    It''s much better to calculate the sum of two objects using the `+` operator,
    rather than calling a member function. Calling a member function also involves
    remembering its name before calling it. It might be `add`, `calculateSum`, `calculate_sum`,
    or something else. Operator overloading allows for a consistent approach in class
    design. On the other hand, overloading operators increases unnecessary verbosity
    in the code. The following snippet represents a list of comparison operators being
    overloaded, along with addition and subtraction for the `Money` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, most of the preceding functions directly access the value member
    of the `Money` instance. To make it work, we should declare them as friends for
    `Money`. Here''s what `Money` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The class looks monstrous. C++20 introduces the spaceship operator, which allows
    us to skip the definition of comparison operators. `operator<=>()`, also known
    as the three-way comparison operator, requests the compiler to generate relational
    operators. For the `Money` class, we can use the default `operator<=>()`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will generate the `==`, `!=`, `<`, `>`, `<=`, `>=` operators.
    The `spaceship` operator reduces the redundant definitions for operators and also
    provides a way to implement a generic behavior for all the generated operators.
    When implementing a custom behavior for the `spaceship` operator, we should note
    the return value type of the operator. It can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::strong_ordering`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::weak_ordering`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::partial_ordering`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::strong_equality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::weak_equality`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of them are defined in the `<compare>` header. The compiler generates operators
    based on the return type of the three-way operator.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and the public interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encapsulation** is a key concept in object-oriented programming. It allows
    us to hide the implementation details of objects from the client code. Take, for
    example, a computer keyboard; it has keys for letters, numbers, and symbols, each
    of which acts if we press on them. Its usage is simple and intuitive, and it hides
    a lot of low-level details that only a person familiar with electronics would
    be able to handle. Imagine a keyboard without keys— one that has a bare board
    with unlabeled pins. You would have to guess which one to press to achieve the
    desired key combination or text input. Now, imagine a keyboard without pins— you
    have to send proper signals to the corresponding sockets to get the key *pressed*
    event of a particular symbol. Users could be confused by the absence of labels
    and they also could use it incorrectly by pressing or sending signals to invalid
    sockets. The keyboard as we know it solves this issue by encapsulating the implementation
    details – the same way programmers encapsulate objects so that they don''t load
    the user with redundant members and to make sure users won''t use the object in
    the wrong way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visibility modifiers serve that purpose in the class by allowing us to define
    the accessibility level of any member. The `private` modifier prohibits any use
    of the `private` member from the client code. This allows us to control the modification
    of the `private` member by providing corresponding member functions. A `mutator`
    function, familiar to many as a setter function, modifies the value of a `private`
    member after testing the value against specified rules for that particular class.
    An example of this can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Modifying a data member through a `mutator` function allows us to control its
    value. The actual data member is private, which makes it inaccessible from the
    client code, while the class itself provides public functions to update or read
    the contents of its private members. These functions, along with the constructors,
    are often referred to as the *public interface* of the class. Programmers strive
    to make the class' public interface user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following class, which represents a quadratic equation solver:
    an equation of the form `ax² + bx + c = 0`. One of the solutions is finding a
    discriminant using the formula `D  = b2 - 4ac` and then calculating the value
    of `x` based on the value of the discriminant (D). The following class provides
    five functions, that is, for setting the values of `a`, `b`, and `c`, respectively,
    to find the discriminant, and to solve and return the value of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The public interface includes the previously mentioned four functions and the
    default constructor. To solve the equation *2x² + 5x - 8 = 0*, we should use `QuadraticSolver`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The public interface of the class should be designed wisely; the preceding
    example shows signs of bad design. The user must know the protocol, that is, the
    exact order to call the functions in. If the user misses the call to `find_discriminant()`,
    the result will be undefined or invalid. The public interface forces the user
    to learn the protocol and to call functions in the proper order, that is, setting
    values of `a`, `b`, and `c`, then calling the `find_discriminant()` function,
    and, finally, calling the `solve()` function to get the desired value of `x`.
    A good design should provide an intuitively easy public interface. We can overwrite
    `QuadraticSolver` so that it only has one function that takes all the necessary
    input values, calculates the discriminant itself, and returns the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding design is more intuitive than the previous one. The following
    code demonstrates the usage of `QuadraticSolver` to find the solution to the equation, *2x2 +
    5x - 8 = 0*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The last thing to consider here is the idea that a quadratic equation can be
    solved in more than one way. The one we introduced is done by finding the discriminant.
    We should consider that, in the future, we could add further implementation methods
    to the class. Changing the name of the function may increase the readability of
    the public interface and secure the future updates to the class. We should also
    note that the `solve()` function in the preceding example takes `a`, `b`, and
    `c` as arguments, and we don't need to store them in the class since the solution
    is calculated directly in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s obvious that declaring an object of the `QuadraticSolver` just to be
    able to access the `solve()` function seems to be a redundant step. The final
    design of the class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We renamed the `solve()` function to `solve_by_discriminant()`, which also
    exposes the underneath method of the solution. We also made the function *static*,
    thus making it available to the user without declaring an instance of the class.
    However, we also marked the default constructor *deleted*, which, again, forces
    the user not to declare an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The client code now spends less effort using the class.
  prefs: []
  type: TYPE_NORMAL
- en: Structs in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structs are almost the same as classes in C++. They have all the features of
    classes, and you can inherit a class from a structure and vice versa. The only
    difference between a `class` and a `struct` is the default visibility. For structs,
    the default visibility modifier is public. It relates to inheritance as well.
    For example, when you inherit a class from another class without using a modifier,
    it inherits privately. The following class inherits from `Base` privately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same logic, the following struct inherits the `Base` publicly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The same relates to the class that inherits from a struct. For example, the
    `Derived` class inherits from `Base` privately if not specified directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++, structs and classes are interchangeable, but most programmers prefer
    to use structs for simple types. The C++ standard gives a better definition of
    simple types and calls them **aggregates**. A class (struct) is an aggregate if
    it conforms to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: No private or protected non-static data members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No user-declared or inherited constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No virtual, private, or protected base classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No virtual member functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of these rules will be a lot clearer after you finish this chapter. The
    following struct is an example of an aggregate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Before diving into inheritance and virtual functions, let''s see what benefits
    aggregates bring when initializing. We can initialize `Person` objects in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'C++20 provides even more fancy ways to initialize aggregates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note how we mixed the initialization of members by designators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structured binding allows us to declare variables bound to aggregate members,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Structured binding is also applicable to arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Class relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object intercommunication is at the heart of object-oriented systems. The relationship
    is the logical link between objects. The way we can distinguish or set up a proper
    relationship between classes of objects defines both the performance and quality
    of the system design overall. Consider the `Product` and `Warehouse` classes;
    they are in a relationship called aggregation because the `Warehouse` contains
    `Products`, that is, the `Warehouse` aggregates `Products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76b956c9-22ba-4ee7-af40-f4edc84ae8ca.png)'
  prefs: []
  type: TYPE_IMG
- en: There are several kinds of relationships in terms of pure OOP, such as association,
    aggregation, composition, instantiation, generalization, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We encountered aggregation in the example of the `Warehouse` class. The `Warehouse`
    class stores an array of Products. In more general terms, it can be called an
    *association*, but to strongly emphasize the exact containment, we use the term *aggregation*
    or *composition*. In the case of aggregation, the class that contains an instance
    or instances of other classes could be instantiated without the aggregate. This
    means that we can create and use a `Warehouse` object without necessarily creating
    `Product` objects contained in the `Warehouse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of aggregation is the `Car` and the `Person`. A `Car` can contain
    a `Person` object (as a driver or passenger) since they are associated with each
    other, but the containment is not strong. We can create a `Car` object without
    a `Driver` in it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The strong containment is expressed by **composition**. For the `Car` example,
    an object of the `Engine` class is required to make a complete `Car` object. In
    this physical representation, the `Engine` member is automatically created when
    a `Car` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the UML representation of aggregation and composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e185cb8-02eb-4899-9520-8ca23b59015c.png)'
  prefs: []
  type: TYPE_IMG
- en: When designing classes, we have to decide on their relationship. The best way
    to define the composition between the two classes is the *has-a* relationship
    test. A `Car` has-a `Engine`, because a car has an engine. Any time you can't
    decide whether the relationship should be expressed in terms of composition, ask
    the *has-a* question. Aggregation and composition are somewhat similar; they just
    describe the strength of the connection. For aggregation, the proper question
    would be *can have a*; for example, a `Car` can have a driver (of the `Person` type);
    that is, the containment is weak.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance** is a programming concept that allows us to reuse classes. Programming
    languages provide different implementations of inheritance, but the general rule
    always stands: the class relationship should answer the *is-a* question. For example,
    a `Car` is-a `Vehicle`, which allows us to inherit the `Car` from the `Vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `Car` now has the `move()` member function derived from the `Vehicle`. Inheritance
    itself represents a generalization/specialization relationship, where the parent
    class (`Vehicle`) is the generalization and the child class (`Car`) is the specialization.
  prefs: []
  type: TYPE_NORMAL
- en: The parent class could be referred to as the base class or the superclass, while
    the child class could be referred to as the derived class or the subclass, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should only consider using inheritance if it is absolutely necessary. As
    we mentioned earlier, classes should satisfy the *is-a* relationship, and sometimes,
    this is a bit tricky. Consider the `Square` and `Rectangle` classes. The following
    code declares the `Rectangle` class in its simplest possible form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Square` *is-a *`Rectangle`, so we could easily inherit it from the `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Square` extends the `Rectangle` by adding a new data member, `area_`,
    and overwriting the `area()` member function with its own implementation. In practice,
    the `area_` and the way we calculate its value are redundant; we did this to demonstrate
    a bad class design and to make the `Square` extend its parent to some extent.
    Soon, we will conclude that the inheritance, in this case, is a bad design choice.
    `Square` is a `Rectangle`, so it should be used as a `Rectangle` wherever the
    `Rectangle` is used, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `make_big_rectangle()` function takes a reference to the `Rectangle` and
    the `Square` inherits it, so it's totally fine to send a `Square` object to the
    `make_big_rectangle()` function; the `Square` *is-a* a `Rectangle`. This example
    of the successful substitution of a type with its subtype is known as the **Liskov
    Substitution Principle**. Let's find out why this substitution works in practice
    and then decide if we made a design mistake by inheriting the `Square` from the
    `Rectangle` (yes, we did).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance from the compiler perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can picture the `Rectangle` class we declared earlier in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6008180-4ca7-4fb1-9983-255e24f7972d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we declare the `rect` object in the `main()` function, the space that''s
    required for the local objects of the function is allocated in the stack. The
    same logic follows for the `make_big_rectangle()` function when it''s called.
    It doesn''t have local arguments; instead, it has an argument of the `Rectangle&` type,
    which behaves in a similar fashion to a pointer: it takes the memory space required
    to store a memory address (4 or 8 bytes in 32- and 64-bit systems, respectively).
    The `rect` object is passed to `make_big_rectangle()` by reference, which means
    the `ref` argument refers to the local object in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4df863f-4b4a-4a28-ae69-dffaab6c6b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an illustration of the `Square` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d479be2-8fce-47b9-937f-062bbb09e7af.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding diagram, the `Square` object contains a **subobject**
    of `Rectangle`; it partially represents a `Rectangle`. In this particular example,
    the `Square` class doesn't extend the rectangle with new data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Square` object is passed to `make_big_rectangle()`, though the latter
    takes an argument of the `Rectangle&` type. We know that the type of the pointer
    (reference) is required when accessing the underlying object. The type defines
    how many bytes should be read from the starting address pointed to by the pointer.
    In this case, `ref` stores the copy of the starting address of the local `rect` object
    declared in `main()`. When `make_big_rectangle()` accesses the member functions
    via `ref`, it actually calls global functions that take a `Rectangle` reference
    as its first parameter. The function is translated into the following (again,
    we slightly modified it for the sake of simplicity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Dereferencing `ref` implies reading `sizeof(Rectangle)` bytes, starting from
    the memory location pointed to by `ref`. When we pass a `Square` object to `make_big_rectangle()`,
    we assign the starting address of `sq` (the `Square` object) to `ref`. This will
    work fine because the `Square` object actually contains a `Rectangle` subobject.
    When the `make_big_rectangle()` function dereferences `ref`, it is only able to
    access the `sizeof(Rectangle)` bytes of the object and doesn''t *see* the additional
    bytes of the actual `Square` object. The following diagram illustrates the part
    of the subobject `ref` points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e80a6dd3-39ba-4f60-9d03-d5eb016642aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inheriting the `Square` from the `Rectangle` is almost the same as declaring
    two structs, one of which (the child) contains the other (the parent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code demonstrates the compiler's way of supporting inheritance.
    Take a look at the commented lines of code for the `Square_set_side` and `Square_area` functions.
    We don't actually insist on this implementation, but it expresses the full idea
    of how the compiler processes OOP code.
  prefs: []
  type: TYPE_NORMAL
- en: Composition versus inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language provides us with convenient and OOP-friendly syntax so that
    we can express the inheritance relationship, but the way the compiler processes
    it resembles composition rather than inheritance. It''s actually even better to
    use composition instead of inheritance wherever it is applicable. The `Square` class
    and its relationship with the `Rectangle` was claimed to be a bad design choice.
    One of the reasons was the subtype substitution principle, which allowed us to
    use the `Square` the wrong way: pass it to a function that modifies it as a `Rectangle`
    rather than a `Square`. This tells us that the *is-a* relationship is not correct
    because the `Square` is not a `Rectangle` after all. It is an adaptation of a
    `Rectangle` rather than a `Rectangle` itself, which means it doesn''t actually represent
    a `Rectangle`; it uses it to provide limited functionality to class users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Users of the `Square` shouldn''t know that it can be used as a `Rectangle`;
    otherwise, at some point, they would send invalid or unsupported messages to `Square`
    instances. Examples of invalid messages are the calls to the `set_width` or `set_height` function.
    The `Square` shouldn''t actually support two different member functions to modify
    its sides separately, but it can''t hide this because it announced that it''s
    inherited from the `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we change the modifier from public to private? Well, C++ supports both
    public and private inheritance types. It also supports protected inheritance as
    well. When inheriting privately from a class, the subclass intends to use the
    parent class and has access to its public interface. However, the client code
    is not aware that it deals with a derived class. Furthermore, the public interface
    that''s inherited from the parent class becomes private for users of the child
    class. It seems like the `Square` transforms inheritance into a composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code cannot access members inherited from the `Rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved by declaring a `Rectangle` member in the private section
    of the `Square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You should carefully analyze usage scenarios and completely answer the *is-a*
    question in order to use inheritance without a doubt. Every time you encounter
    a choice between composition and inheritance, choose composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can omit the modifier when inheriting privately. The default access modifier
    for classes is private, so `class Square : private Rectangle {};` is the same
    as `class Square : Rectangle {};`. On the contrary, the default modifier for structs
    is public.'
  prefs: []
  type: TYPE_NORMAL
- en: Protected inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we have the **protected** access modifier. It specifies the access
    level of the class members if they're used in the class body. Protected members
    are private to the class users, but are public to derived classes. If the modifier
    is used to specify the type of inheritance, it behaves similarly to the private
    inheritance for derived class users. While private inheritance hides the public
    interface of the base class from all the derived class users, protected inheritance
    makes it accessible to descendants of the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: It's hard to imagine a scenario where you would need protected inheritance,
    but you should consider it as a tool that might be useful in unexpectedly obvious
    designs. Let's suppose we need to design a stack data structure adapter. The stack
    is usually implemented based on a vector (one-dimensional array), a linked list,
    or a dequeue.
  prefs: []
  type: TYPE_NORMAL
- en: The stack conforms to the LIFO rule, which states that the last element inserted
    into the stack will be accessed first. Similarly, the first element inserted into
    the stack will be accessed last. We will discuss data structures and data structure
    adapters in more detail in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging
    into Data Structures and Algorithms in STL*
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack itself doesn''t represent a data structure; it *sits* on top of a
    data structure and adapts its usage by limiting, modifying, or extending its functions.
    The following is a simple declaration of the `Vector` class representing a one-dimensional
    array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `Vector` is not an STL-compatible container with random access
    iterator support; it contains the bare minimum for a dynamically increasing array.
    It can be declared and used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `Vector` class provides `operator[]`, which allows us to access any
    of its items randomly, the `Stack` prohibits random accesses. The `Stack` provides
    `push` and `pop` operations so that we can insert a value into its underlying
    data structure and fetch the value, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Stack` can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The stack *adapts* the `Vector` and provides two member functions so that we
    can access it. Private inheritance allows us to use the full capabilities of the
    `Vector` and hide the inheritance information from the `Stack` users. What if
    we want to inherit the `Stack` to create an advanced version of it? Let's say
    the `AdvancedStack` class provides the `min()` function, which returns the minimum
    value contained in the stack in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private inheritance prohibits the `AdvancedStack` so that it uses the public
    interface of the `Vector`, so we need a way to allow the `Stack` subclasses to
    use its base class, but hide the base class'' existence from class users. Protected
    inheritance serves that goal, as shown in the following coe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: By inheriting the `Stack` from the `Vector`, we allow the subclass of the `Stack`
    to use the `Vector` public interface. But the users of both the `Stack` and `AdvancedStack`
    won't be able to access them as a `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** is another key concept in object-oriented programming. It
    allows subclasses to have their own implementation for the functions that are
    derived from the base class. Let''s suppose we have the `Musician` class, which
    has the `play()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare the `Guitarist` class, which has the `play_guitar()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the obvious case of using inheritance because the `Guitarist` just
    screams that it *is-a* `Musician`. It would be natural for the `Guitarist` to
    not extend the `Musician` by adding a new function (such as `play_guitar()`);
    instead, it should provide its own implementation of the `play()` function derived
    from the `Musician`. To accomplish this, we use **virtual functions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s obviously simple that the `Guitarist` class provides its own implementation
    to the `play()` function and that the client code can access it by just using
    the pointer to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows polymorphism in action. While the use of virtual
    functions comes naturally, it actually doesn''t make much sense unless we use
    it properly. First of all, the `play()` function of the `Musician` should not
    have any implementation at all. The reason for this is simple: a musician should
    be able to play on a concrete instrument as they cannot play on more than one
    instrument simultaneously. To get rid of the implementation, we set the function
    as a **pure virtual function** by assigning `0` to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to a compile error when the client code tries to declare an instance
    of the `Musician`. And, of course, it must lead to a compile error, because you
    shouldn''t be able to create an object that has an *undefined* function. The `Musician`
    serves a single purpose: it must only be inherited by other classes. The class
    that exists to be inherited is called an **abstract class**. Actually, the `Musician`
    is called an **interface** rather than an abstract class. An abstract class is
    a semi-interface semi-class that can have both types of functions: with and without
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our example, let''s add the `Pianist` class, which also implements
    the `Musician` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To express the full power of polymorphism, let''s suppose that we have a function
    declared somewhere that returns a collection of musicians, either guitarist or
    pianists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'From the perspective of the client code, it will be hard to dissect the return
    value of the `get_musicians()` function and find out what the actual subtype of
    the object is. It could be either `Guitarist` or `Pianist`, or even a pure `Musician`.
    The point is that the client shouldn''t really care about the actual type of objects
    as it knows that the collection contains Musicians and a `Musician` object has
    the `play()` function. So, to get them in action, the client can just iterate
    through the collection and make each musician play its instrument (each object
    calls its implementation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code expresses the full power of polymorphism. Now, let's understand
    how the language supports polymorphism at a low level.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although polymorphism is not limited to virtual functions, we will discuss them
    in more detail because dynamic polymorphism is the most popular form of polymorphism
    in C++. And again, the best way to better understand a concept or technology is
    by implementing it on your own. Whether we declare a virtual member function in
    a class or it has a base class with virtual functions, the compiler augments the
    class with an additional pointer. The pointer points to a table that's usually
    referred to as a virtual functions table, or simply a *virtual table*. We also
    refer to the pointer as the *virtual table pointer*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we are implementing a class subsystem for a bank customer account
    management. Let''s say that the bank asks us to implement cashing out based on
    the account type. For example, a savings account allows cashing out money once
    a year, while the checking account allows cashing out money whenever the customer
    wants. Without diving into any unnecessary details about the `Account` class,
    let''s declare the bare minimum that will help us understand virtual member functions.
    Let''s look at the `Account` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler transforms the `Account` class into a structure that has a pointer
    to the virtual functions table. The following code represents pseudocode, explaining
    what happens when we declare virtual functions in the class. As always, note that
    we provide a general explanation rather than a compiler-specific implementation
    (the name mangling is also in a generic form; for example, we rename `cash_out`
    `Account_cash_out`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a good look at the preceding pseudocode. The `Account` struct has `__vptr`
    as its first member. Since the previously declared `Account` class has two virtual
    functions, we can imagine the virtual table as an array with two pointers to virtual
    member functions. See the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'With our previous presumptions at hand, let''s find out what code the compiler
    will generate when we call a virtual function on an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what we can imagine the compiler''s generated code to be like for the
    preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Virtual functions show their power when they''re used in hierarchies. `SavingsAccount`
    inherits from the `Account` class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `cash_out()` via a pointer (or a reference), the virtual function
    is invoked based on the target object that the pointer points to. For example,
    suppose `get_savings_account()` returns a `SavingsAccount` as `Account*`. The
    following code will call the `SavingsAccount` implementation of `cash_out()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the compiler generates for `SavingsClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have two different tables of virtual functions. When we create an object
    of the `Account` type, its `__vptr` points to `Account_VTable`, while the object
    of the `SavingsAccount` type has its `__vptr` pointing to `SavingsAccount_VTable`.
    Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code translates into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's obvious that `__vptr[0]` resolves to the correct function because
    it is read via the `p` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if `SavingsAccount` doesn''t override the `cash_out()` function? In that
    case, the compiler just places the address of the base class implementation in
    the same slot as `SavingsAccount_VTable`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Compilers implement the virtual functions' representation and management differently.
    Some implementations use even different models, rather than the one we introduced
    earlier. We brought a popular approach and represented it in a generic way for
    the sake of simplicity. Now, we will take a look at what is going on under the
    hood of the code that incorporates dynamic polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are one of the most expressive tools for programmers. They allow
    us to solve design problems in an elegant and well-tested way. When you are struggling
    to provide the best possible design of your classes and their relationship, a
    well-known design pattern may come to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest example of a design pattern is a **Singleton**. It provides us
    with a way to declare and use only one instance of the class. For example, suppose
    that the e-commerce platform has only one `Warehouse`. To access the `Warehouse`
    class, the project may require that we include and use it in many source files.
    To keep things in sync, we should make the `Warehouse` a Singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We declared a static `Warehouse` object and two static functions for creating
    and destroying the corresponding instance. The private constructor leads to a
    compile error each time the user tries to declare a `Warehouse` object in the
    old way. To be able to use the `Warehouse`, the client code has to call the `create_instance()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The singleton implementation of the `Warehouse` is not complete and is just
    an example to introduce design patterns. We will introduce more design patterns
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the fundamental concepts of object-oriented programming.
    We touched on the low-level details of classes and the compiler implementation
    of the C++ object model. Knowing how to design and implement classes without actually
    having classes helps a lot in using the classes the right way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also discussed the need for inheritance and tried to employ composition
    instead of inheritance wherever it might be applicable. C++ supports three types
    of inheritance: public, private, and protected. All of these types have their
    applications in particular class designs. Finally, we understood the use and power
    of polymorphism by bringing an example that drastically increases the convenience
    of the client code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about templates and template metaprogramming,
    which we will use as the basis to dive into a new C++20 feature called concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the three properties of objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the advantage of moving objects instead of copying them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between structs and classes in C++?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between aggregation and composition relations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between private and protected inheritance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the size of the class affected if we define a virtual function in it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the point of using the Singleton design pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: Grady Booch, *Object-Oriented Analysis and Design* ([https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stanley Lippman, *Inside the C++ Object Model* ([https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/](https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
