- en: Workflow for HiDPI Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retina devices are now almost the default for Apple computers, tablets, and
    phones. Also, the word "retina" is actually trademarked by Apple for computer
    equipment, and is their branded way of describing double(or more)-density screens
    and devices. I'm going to use the word "retina" loosely to describe any device
    that has a high-density display, whether its made by Apple or not. Everything
    on a retina device is sharper and crisper because there are nearly four times
    the pixels as there are in a CSS device's display; for every "CSS pixel", there
    are now four "device pixels", allowing higher quality displays. The downside is
    that the images we've used so far are actually not going to look so good on such
    a device because we haven't accounted for higher density displays.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll go over a number of techniques for images that take retina
    displays into account. This includes making images twice their size. We'll also
    look into the background image technique, using SVG, and using the `srcset` attribute
    on the image element to further account for retina.
  prefs: []
  type: TYPE_NORMAL
- en: 2x images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2x images are twice the width and twice the height images. The basic idea is
    to make the image twice the width and height that we actually need. We''ll then
    add that image to our HTML. Then we''ll use CSS to constrain the image to the
    actual size that it will be on the screen. The way I like to do this is the same
    way I like to handle flexible images in responsive design: I like to make sure
    that the images will have a containing element with a set `width` and `height`
    value. Then, I make sure the image itself has its `max-width` set to 100%. Both
    these requirements are already in place. All my images typically have a container,
    and in CSS, and all my images have their `max-width` set to 100%.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a retina size image (2x)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So let''s get started with the raster images on the shark movies page. Right-click
    on the Jaws movie image and inspect this element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that these images on the shark movies page are 200 x 200 pixels.
    Our goal is to replace these with images that are 400 x 400 pixels. As you can
    see in my `images` folder, shown in the following screenshot, I''ve already created
    three images that are identical to the original images, except they are larger
    and suffixed with `@2x.jpg` to signify that these are the retina versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Switching over to the HTML, you can see I''ve added `@2x` to the image filename
    for all three images and have saved it. This is what our `Open Water movie` filename
    should look like, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sizing down the 2x image using CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go over to the browser and refresh it. Now, when you look at this image of
    Jaws, you really wouldn''t see any noticeable difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, a quick inspection shows that a `@2x` image is being served, but it''s
    being constrained to a size of 200 x 200, so you can see that the original image
    is `400 x 400`, but it''s showing as `200 x 200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Because of our foundation of responsive design, the immediate containing element
    `.figure` already has a width set of `23.958333333333` percent (as shown in the
    following code), which is equal to 200 pixels in the website''s widest context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we remove the `width` from the Styles pane of the Chrome DevTools, the image
    blows up to its actual size, which is `400 x 400`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00338.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So it''s the containing element, having a set `width`, along with the `max-width`
    set to 100%, that keeps the image constrained. If we remove this `max-width` from
    the Style pane of the Chrome DevTools, the image would no longer be constrained,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The parent element has the overflow option set to hidden, which is why the image
    isn't getting any wider than 23.95 percent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Checking the image quality on a retina device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now how do we know that the image is going to look good on a retina device?
    The best thing to do is test it on a retina device, but we can also cheat a little
    bit and zoom Chrome to 200 percent. First, let''s set this width to 200px directly
    in the DevTools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then let''s go to the Chrome toolbar and zoom in to 200%:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is supposed to demonstrate that at 200% zoom, the image
    is still very crisp, and this is kind of simulating a retina device.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't seem like a bad way to get your images retina ready. Well, if it
    were only that easy. It turns out that making your images twice the height and
    width really makes them about three to four times bigger than their 1x counterparts.
    So if you look at the Jaws image in the `images` folder, the original is 28 KB
    and the 2x version (the double-density version) is 105 KB. That's four times as
    large!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, in conclusion, this is just the beginning of our preparations for the retina
    web. Our biggest issue right now is that we are serving a huge retina-size image
    to all devices, even those that aren't retina. That's extra download and page
    weight to sites that won't get any benefit from it is not very responsible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at a similar technique for background images.
  prefs: []
  type: TYPE_NORMAL
- en: Background images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to handle background images, we can use a special media query to determine
    the pixel ratio and then modify the `background` property to serve up the retina
    image. In this section, we'll determine how we can account for background images
    in the sphere of retina. We'll first create a media query designed for determining
    the pixel ratio. Then, we'll update the image being served to be the retina version.
    The seaweed in the footer is a background image, and thus will be the perfect
    image for this task.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting the seaweed in the footer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the seaweed just above the footer on the movies page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the CSS, all that''s happening is that the footer has a repeating
    background image. The background is the seaweed, and we''re getting it to repeat
    along the *x* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So we need to have a retina-sized version of `seaweed.jpg`. I have that in
    my `images` folder, and I''ve named it `seaweed@2x.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the very bottom of the style sheet, after all our media queries, let''s
    reserve a spot for retina background images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is where we'll have the special media query to detect retina.
  prefs: []
  type: TYPE_NORMAL
- en: Media query for device pixel ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We remember media queries like this from [Chapter 6](part0133.html#3UQQQ0-a72d261cc09f412988422c8a08f12cd5),
    *Becoming Responsive*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two parts to the media query, the media *type* and media *feature*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The media type can be keyword values such as *screen*, *print*, *speech*, and
    *all*. The media feature can be a number of things as well. In the responsive
    chapter, the feature was the `max-width` of the browser. For retina however, we
    want to query for the pixel-ratio of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is going on in the preceding sample. There are two different queries
    targeting two different media features. The comma separating these two queries
    is similar to saying "or." So the media query will take affect if either of the
    preceding two queries are true. But why have two queries? Well, the first query
    is for webkit browsers such as Safari and older Chrome on devices with `min-device-pixel-ratio`
    of `2`. Next, we target devices that have 192 dots per inch or greater. Instead
    of using a device pixel ratio, which is webkit-specific, it''s just using `min-resolution:
    192dpi`. This accounts for different browsers, such as a Windows mobile. Both
    media features are basically targeting retina.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now inside of the media query, we will target the footer and change the background
    image to our retina version. I''ll type in the footer and add an opening curly
    brace and then `background-image`; the URL is going to be `../images/seaweed@2x.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We see no noticeable difference though in the browser. Let''s inspect the footer
    though, just to make sure that it''s still loading up the regular `seaweed.jpg`
    file, and not `seaweed@2x.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason we are checking this is because I''m not on a retina device. We
    can use some trickery to make sure this is working. Let''s go to our CSS and change
    the device pixel ratio to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what that looks like in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we are getting the 2x version, and we can see that it's noticeably larger.
    We have twice the size image; it visually looks like it's twice the size. It's
    not being constrained down to our intended display size. There's a property called
    `background-size` that we will use to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the 2x image only to retina devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to use the `background-size` property in order to ensure the seaweed
    is constrained appropriately. We will put the `background-size` property right
    in the ruleset that holds the non-retina version at the top of our footer section,
    not inside the media query. We could easily put it in the media query and that
    would be fine and dandy, but this is going to apply to non-retina devices and
    retina devices, so we''ll just add a background size of `200px` horizontally and
    `100px` vertically, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this and go to the browser. When we refresh the site, the seaweed should
    shrink down to 200 x 100, back to its regular size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at our styles in the DevTools, you can see we're getting the `@2x`
    version. You can see the way the browser is loading in the CSS—it sees the media
    query on top. This is what's getting used. Below it is the non-media query version
    that is not getting loaded. This is exactly how we want it to work, which is good.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is revert the media query to a `device-pixel-ratio`
    of two instead of one, so, we''ll change that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''ll load the non-retina version because I''m on a non-retina device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00349.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Only the retina-sized background image is downloaded by retina devices and the
    regular-sized background image is downloaded by non-retina devices. All is good,
    but this is still quite a bit of work. There's a better way that we can handle
    this seaweed that involves less work and only requires one image–using SVG instead
    of traditional raster graphics.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable Vector Graphic (SVG)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Scalable Vector Graphic**(**SVG**) - is an XML-based image format for graphics.
    It's different than raster formats, like JPEG and PNG, because it SVG scale to
    any size without losing any resolution or looking pixelated. This means that we
    don't need multiple images for retina or responsive layouts! Another bonus with
    SVG's is that the file size is can be much smaller than that of the same image,
    saved as a JPEG or PNG. All major browsers support the SVG format as far back
    as IE9\. SVGs aren't a replacement for every image on your site–they are particularly
    suited for line drawings, which are typically generated through design software,
    such as Adobe Illustrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''re going to look at how to save an Adobe Illustrator file
    as an SVG, and three different ways in which we can add SVG''s to our website:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an SVG as a `background-image`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an SVG using the `<img>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an inline SVG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve got plenty of images on our site that would lend themselves well to
    SVG, including the shark at the top of our site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00350.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'All the different ocean species we have in the middle of our site will also
    work great as SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00351.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even the seaweed we have in the footer, which we worked on in the last section
    is a great candidate for SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00352.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So what images aren''t great candidates for SVG? Well, our raster images on
    the movies page are definitely not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00353.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Saving an Illustrator file as an SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have an Adobe Illustrator file called `seaweed.ai` open in Illustrator. A
    program like Illustrator is where SVG's can be created or drawn from scratch.
    Creating SVG's in Illustrator is far out of scope for this book, but I want to
    start here just to show where an SVG's *could* come from.
  prefs: []
  type: TYPE_NORMAL
- en: In *Illustrator CC 2017*, one of the best ways to save an AI file down to SVG
    for web is by using the File *>* Export *>* Export for Screens... option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This option uses the `artboard` name as the name of the file, so before we
    export as an SVG, let''s rename the artboard by going to Window *>* `Artboards`.
    Let''s rename from artboard1 to seaweed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, by going to the File *>* Export *>* Export for Screens... option, we''ll
    get an SVG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'That brings up screen with a few options. Using the Export to field, we''ll
    choose where to save this file, which will inevitably be in our `images` folder.
    We''ll also change the Format to `SVG` before clicking the Export Artboard button
    in the bottom right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After saving, you can see that the SVG is 1 KB. The `@2x` version we used in
    the last section was 13 KB!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00357.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So not only is the SVG 13 times smaller than the `@2x` version, it's also six
    times smaller than the regular version, and that is truly amazing! Now let's integrate
    this into our CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SVG file as a background image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our CSS, inside the rule set targeting the footer, all I''m going to do
    is change the format from `.jpg` to `.svg`—that is, from (`''.../images/seaweed.jpg''`)
    to (`''.../images/seaweed.svg''`), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since now we have an SVG that''s going to work for both non-retina and retina
    devices, we''ll go down to the very bottom and comment out this media query from
    our last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is what we used in the last section to serve a larger image to retina devices,
    but we don't need all that extra code if we're using SVG. So I've gotten rid of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: I'll refresh the browser, and it looks exactly the same. Let's inspect the element,
    as shown in the following screenshot. We can see that it's serving up `seaweed.svg`.
    We went from 2 images to 1\. 13 KB to 1 KB. And we got rid of several lines of
    CSS in a complicated media query. Are you starting to understand why SVG is pure
    awesomeness?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the SVG as a regular ol' <img>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use an SVG as a regular `<img>`. We happen to have a couple of
    images in the middle of our site—the different ocean species that will make perfect
    candidates for implementing SVG with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ve already saved a copy of the octopus, crab, and whale as an `.svg` file.
    So let''s go over to the HTML and simply change the octopus, crab, and whale images
    from `.png` to `.svg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the files in the `images` folder are exactly the same. The only
    difference is that the suffix is `svg` instead of `png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Save this. We''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we can see that the files look good; the only problem
    is that they appear to have gotten a little bigger. So we'll constrain these down
    to the size we want.
  prefs: []
  type: TYPE_NORMAL
- en: You can't stop SVG's, you can only hope to constrain them!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To constrain the size of images, we need to set a `width` and/or a `max-width`.
    We actually already did this but only inside of a media query so it isn''t firing
    on larger screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove that rule set from the media query and add it up where we originally
    defined the 3 columns outside of our responsive media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And all we did there is center the `figure` element using auto margins, make
    sure the width is 100% of its container, as long as the width is never more than
    250px (`max-width`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this in the right place, this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We've constrained each SVG image to a maximum width of `250px`. Our crab, octopus,
    and whale look mighty good and are instantly retina ready.
  prefs: []
  type: TYPE_NORMAL
- en: Using an inline SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have one other option for SVG, called an inline SVG. Since an SVG is really
    just XML inside of a text file, we can actually embed the SVG code directly into
    our HTML. This makes it so that we don't need to have an additional HTTP request
    (good for performance). Also, it allows us to alter the SVG using CSS, for example,
    provides a cool hover state or an animation. This really gives us a huge advantage;
    it just can't be overstated.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what we''re going to do is go to the `images` folder in Sublime Text and
    open up `crab.svg`. But first, let''s look at what happens when I open `crab.png`,
    Sublime shows an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the SVG, it actually shows the code! You can see it''s XML, which is similar
    to HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll copy and paste all of the SVG code, and go over to our `index.html` file
    and get rid of the entire `img` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll replace it with the SVG code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Woah, that's a lot of code... The downside of SVG is it's a lot of code you're
    putting directly into your markup. You're still going to get better performance,
    because you don't have an HTTP request for it, but we're adding close to 30 lines
    of code for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see no change in the Chrome; the crab looks exactly the same. So we might
    as well inspect this element. Now we can see that it''s the inline SVG code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also see how you would think that you can use CSS to change these properties
    because each of these paths is literally a separate kind of node in the Dom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For instance, if we wanted to, we could change the fill color of this line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change it to green:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you get a green claw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00369.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So you can see how you might be able to change the properties of the SVG, animate
    it, or create a cool hover state. You can't do this with SVG as a `background-image`
    or an `img` tag, but you can do this with an inline SVGs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a different media format, it''s not an `img` tag and not a `video`
    tag. It''s really an `SVG` tag. Let''s go to the top of the style sheet, into
    my reset. This is where we set `max-width: 100%` on our media as shown in the
    following code. We''ll also add an SVG to this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we'll go over how we can use the `srcset` attribute on
    an `img` tag to serve retina images to high-density displays and normal-sized
    images to normal density displays.
  prefs: []
  type: TYPE_NORMAL
- en: Source set attribute (srcset)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SVG is still the most preferred way to serve retina images to HiDPI devices
    because the file size is nearly always smaller than JPG and PNG, and you only
    need one image for both retina and non- retina devices. But there is another,
    very good option that's emerged, called `srcset`. This option isn't meant to replace
    SVG, but rather complement it, since SVG can't be used for traditional raster
    images and photos, which are more suited for JPEG and PNG.
  prefs: []
  type: TYPE_NORMAL
- en: What is srcset?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `srcset` attribute is simply just a set of images, just like the name implies.
    What we can do is provide not just one image for the browser to serve, but a set
    of images that the browser can choose from and only fetch whichever image the
    browser decides is most appropriate for the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to focus on the three movie images on our movies page, which are
    all raster, photographic images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00370.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In `movies.html` we have an `img` tag and the appropriate image for each movie.
    So for Sharknado, we have `sharknado.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For Jaws, we have `jaws.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update the Jaws image and add a new attribute called `srcset` and we''ll
    put our Jaws image as the value of that attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like I mentioned, `srcset` is a set of image choices to provide to the browser
    so it can decide which is best suited for the situation. Let's add a set of images.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a set of images to srcset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a set of images to the `image` tag, comma separate each image. We''re
    providing the regular-sized image first. Then we''ll add `images/jaws@2x.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The browser actually needs something else to let it know that it''s a larger
    image, something called the *pixel density descriptor,* or just the *X descriptor*.
    Let''s add that, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Following each image string, I'm going to provide a space and then the X descriptor.
    So the first image string will be `1x`, and the second one will be `2x`. The X
    descriptor is a hint we provide to the browser. This means we are using the `images/jaws.jpg`
    for `1x`, or normal pixel density, displays, and using `images/jaws@2x.jpg`, the
    larger image, for `2x`, or retina, displays.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the image set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether the image set is working. This would be tough without testing
    it on a retina display, which we''re not doing. But let''s see whether we can
    do some rough testing. Chrome has a nice feature where, if we inspect an image,
    we can see its `src` attribute and the `srcset` attribute. Check out the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00371.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, if we hover the mouse over the path to each image, you can see that a
    popup appears over the image that''s being served. But when we hover over `jaws@2x`,
    no popup appears because that image is not being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00372.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This makes sense as I'm not on a retina display, so it's using a non-retina
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the browser zoom trick, which we used in earlier sections, to see
    whether we can fake a retina device. Let''s zoom up to 200 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00373.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, refresh the page so that it goes and fetches the image it thinks is best:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00374.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When I hover over `jaws.jpg` in the `src` and `srcset`, we don''t get a popup.
    But we do get it when we hover over the path to `jaws@2x.jpg`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This tells me that the larger image is getting fetched. That's good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the srcset attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code a little bit more to simplify the `srcset` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We need to keep the original `src` there as a fallback for browsers that don't
    support `srcset`. We'll talk about how awesomely good browser support is later
    in the section, but it's important to keep in mind that the `src` attribute is
    there so that unsupported browsers aren't left out in the lurch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one other thing to note is that we can simplify this code equation. The
    W3C spec mentions that for new user agents, the `src` attribute participates in
    the resource selection as if it were specified in the `srcset` with a `1x` descriptor.
    Since we have the traditional `src` attribute that will serve the `1x` version
    of the image, we can remove the first image string from our `srcset` attribute
    and simplify our markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In other words, we can remove the regular size image string with the `1x` descriptor
    from the `srcset` attribute since this is already being specified in the `src`
    attribute. This simplifies it, which is good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update our other two movies with similar markup starting with Sharknado:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll do the same thing for the movie, Open Water:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Browser support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss browser support [caniuse.com](http://caniuse.com/) shows an
    awful lot of green browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00376.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Microsoft Edge supports `srcset` and Chrome, Firefox, Safari, Opera, and starting
    with iOS Safari 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the option to *Date Relative* shows the support goes farther back
    for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It provides partial support from Safari 8.1 through to 8.4\. It supports "resolution
    switching", which is what we're doing using the X descriptor; however, it doesn't
    support the full syntax, which I'll talk about a little bit more later in the
    section. One notable non-supported browser is IE as recent as IE11\. But, Internet
    Explorer will get the regular-sized image we specified in the traditional source
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The nice part about this is that the overwhelming majority of high-density devices
    will ultimately end up getting the `2x` version, and unsupported browsers which
    are likely non-retina devices anyway, will receive the `1x` version.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to point out that you don''t have to use just one or two image paths.
    I''m going to copy and paste in three image paths, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, I've specified an `image` that I can use
    for `4x` displays, `2x` displays, and `1.5x` displays. This brings me to another
    point–you don't necessarily have to use whole numbers. You can use 1.5 or 1.325
    if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we're only providing hints to the browser, so even though we have
    what looks like a great amount of control over which image gets served, ultimately
    it's up to the browser to decide which is the most suitable to use. This is based
    on factors other than users' screen pixel density, for example, zoom level, as
    we saw already, and other factors, such as the user's network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: So, in theory, if a user has a retina device but poor internet, the browser
    would serve a smaller image because it would prioritize the speedy loading of
    images—the loading will be faster, but not as crisp. We've likely seen this type
    of prioritization in other technologies. For instance, a Netflix may show a fuzzy
    version of a movie until it gets enough bandwidth to show you the HD version of
    the same movie. We like this, because we'd rather get something to view faster
    than waiting for the best version of something to view.
  prefs: []
  type: TYPE_NORMAL
- en: Using the W descriptor and sizes attribute of the srcset attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that the `srcset` attribute is not a one-trick pony; we have talked about
    how it works for handling retina images easily. But there is another use case
    of the `srcset` attribute that uses the `W` descriptor and the `sizes` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It allows you to handle the serving of different images based on the width of
    the browser. A gigantic, hero, full-page image looks beautiful on a desktop, but
    would be bad for performance, if you just shrink it down and serve it on much
    smaller mobile devices, since small devices don't need a super large image.
  prefs: []
  type: TYPE_NORMAL
- en: The `w` descriptor is a hint to the browser about the size of the image; here
    `w` stands for the width. The `sizes` attribute adds media queries and a dimension
    telling the browser our preferred render size of the image if the browser width
    matches the media query and finally the preferred render size of the image if
    the browser width doesn't match the media query.
  prefs: []
  type: TYPE_NORMAL
- en: My intention isn't to explain the details, of this alternate usage of the `srcset`
    attribute but to let you know that there is more depth to the `srcset` attribute.
    If you'd like to dive deeper, I've written an article on my site at [richfinelli.com/srcset-part-2/](http://www.richfinelli.com/srcset-part-2/).
    I've also written an article on the X descriptor, available at [richfinelli.com/srcset-part-1/](http://www.richfinelli.com/srcset-part-1/)
    if you're still hungry to learn more about what we just talked about.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing for retina is extra effort. My recommendation is to use SVG when
    possible as your first choice for serving super crisp images to retina devices.
    In instances when SVG is not possible - that is photographs - use the `srcset`
    attribute of the `img` tag to enable your browser to make smart decisions about
    serving images. Browser support for `srcset` is great, and non-supporting browsers
    will fall back to the `src` attribute. The browser makes the final decision of
    which image is best to use, based on pixel density, zoom level, and other factors,
    such as network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [Chapter 9](part0199.html#5TOVU0-a72d261cc09f412988422c8a08f12cd5),
    *Flexbox*, *Part 1*, we'll look at an alternate and better solution for laying
    out parts of our web page using flexible boxes.
  prefs: []
  type: TYPE_NORMAL
