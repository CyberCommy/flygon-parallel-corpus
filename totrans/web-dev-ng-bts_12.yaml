- en: Integrating Backend Data Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to Chapter 12! This is definitely my favorite chapter, as we will be
    building many end-to-end use cases for our application.
  prefs: []
  type: TYPE_NORMAL
- en: A gentle warning—this chapter is dense—it is packed with a ton of information.
    You may have to read it at a slower pace and spend more time at the keyboard than
    you have with the previous chapters, but, I must say, it is well worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a great way to look at the overall progression of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything we've looked at so far, including the two most recent chapters ([Chapter
    10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml), *Working with Forms*, and [Chapter
    11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml), *Dependency Injection and Services*),
    has laid the foundation for this chapter. With that knowledge under our belts,
    we are now ready to put it all together in order to create our application. So,
    in essence, this chapter also serves the purpose of reviewing many of the topics
    we covered in previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is the pivotal turning point for us because we will take everything
    we've learned thus far to build 95% of our application in this single chapter.
    This is a lot of material for one chapter, but we have spent a good amount of
    time going over all the aspects of Angular that we will need to build our application,
    so we're going to breeze through it. There is some new and slightly off-topic
    material too—learning how to build backend APIs—which is less important than the
    Angular material. However, we need to have an API, so I selected a set of technologies
    that are simple enough to quickly get up to speed with. We are also going over
    this to help you get your mind around the technologies we will be using to construct
    the APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the chapters that follow this one, we will add a couple of things to our
    app (such as route guards and custom form validation) and we will learn how to
    test, debug, secure, and deploy our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, from that perspective, we're good to go. Many sections in this chapter are
    bonus material that I deem important to learn about because I want you to succeed,
    not only as an Angular developer, but as a web developer in general. This will
    help you to enhance your skills, and hands-on examples are sure to augment your
    technical knowledge as a web developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: ListingApp – an overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamental concepts for Angular applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ListingApp – technical requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building APIs for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google Firestore database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular HttpClient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating backend services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've spent a lot of time in this book discussing a myriad of things—mostly
    Angular-centric (such as components, routing, flex-layout, NG Bootstrap, Angular
    Material, and working with forms), and a few things that were standalone (such
    as wire-framing, ES6, TypeScript, and Bootstrap). It is important to possess all
    that knowledge, of course, but we haven't yet integrated live data to bring our
    Angular application to life. However, as you can see from the previous bullet-point
    list, this is about to change. This is where developing in Angular starts to get
    fun, and also much more practical, since an application that does not create and
    consume data is not much of an application at all.
  prefs: []
  type: TYPE_NORMAL
- en: OK. Let's get right into it by starting with learning about some of the fundamental
    concepts that form the foundation of any application. Then, we'll take a look
    at the steps involved in building our ListingApp.
  prefs: []
  type: TYPE_NORMAL
- en: ListingApp – an overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be building our `ListingApp` application. In this
    section, we will cover the functional requirement list. Our overall application
    plan can be broken down into three main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI layer**: The UI aspects involve designing or building the forms, displaying
    data, routing, and validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services or middleware layer**: We will learn how to write shared services,
    which will be responsible for backend integrations with APIs and databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database or fake API setup**: We will learn how to set up fake APIs using
    JSON Server and we will also learn how to create our NoSQL database using Firestore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the complete list of functional use cases we will be building as part
    of the learning experience in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Display all the listings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View listings by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit a listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the use cases listed will require us to implement HTTP calls. For some,
    we will need to make POST, GET, and PUT HTTP calls.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed any further, now is a good time to bring back all the learning
    and functionality we have implemented throughout the course of this book. We will
    need to recollect how we designed and developed our forms, how we captured the
    form data, how we displayed the data in the component templates, how we implemented
    routing with parameters, and how we call methods implemented in services inside
    components.
  prefs: []
  type: TYPE_NORMAL
- en: We have a lot of work to do, and a load of fun awaits us, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental concepts for Angular applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to learn and build a lot of interesting things in this chapter,
    but before we start doing that, we should learn about a number of fundamental
    concepts, including strongly typed language concepts, Angular models, observables, NoSQL
    databases, and CRUD operations in general.
  prefs: []
  type: TYPE_NORMAL
- en: Strongly typed languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A strongly typed programming language refers to the fact that each of the data
    types is predefined and tightly coupled with the variables. Take a look at the
    following variable that''s been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring a variable and explicitly mentioned the fact that the type
    of variable is an integer, which makes it very obvious that the variable cannot
    hold any other data type except an integer. If we try to provide any value that
    is not an integer, TypeScript will throw an error. TypeScript is also a strongly
    typed language and, since we write our Angular applications in TypeScript, we
    can conclude that Angular applications follow strongly typed formats.
  prefs: []
  type: TYPE_NORMAL
- en: Typescript interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create our own data types in TypeScript,
    which we can use in our Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Angular models are a way to create complex data structures by clubbing multiple
    data types into an object and defining a new object, which can then be used as
    a data type in itself. It's Angular's way of ensuring that complex data objects
    adhere to certain predefined data specs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TypeScript language provides interfaces that also serve the same purpose.
    We can also make use of ES6 classes to define our data structures. We can extend
    the programming syntax to create our custom data types. Let''s demonstrate this
    by creating a sample model. We are going to create a model and call it `Listing`,
    which will have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have created an Angular model, which is a class with properties such as `id`,
    `userId`, `title`, `status`, `price`, and `active`. We can now use this model
    as a data type in our application. We can import this class into all of our components
    and services to make sure our data map adheres to the `Listing` data spec.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the previously defined model throughout this chapter while building
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most traditional applications work on the request and response architecture,
    which means our application client will make a request for data to the server,
    and, in return, the server will give us a response. While the server is returning
    the response, our application goes into wait mode until all the responses are
    received, which obviously makes applications slow.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture has multiple drawbacks. First, the application waits for a
    response, which creates delays in applications. Second, there is no way we can
    handle multiple pieces of data coming in over a period of time. Third, since our
    application waits until it gets the response, which makes synchronous calls, we
    cannot execute asynchronous programming. And finally, event handling becomes a
    nightmare for developers. So, how do we address the preceding issues? The answer
    is by using observables.
  prefs: []
  type: TYPE_NORMAL
- en: Observables are a type of array that returns data over a period of time asynchronously.
    Angular uses a third-party library called **Reactive Extensions** (**RxJS**) and
    has observables implemented inside the framework mainly for event handling, tree
    shaking, and so on. We can also easily import, create, and subscribe to custom
    observables.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about NoSQL databases. Really? NoSQL?
    Are we not going to use a database to store our critical data? Of course we are
    going to use a database to store our data; however, it won't be a traditional
    relational database, which has a strict predefined schema and columns that have
    a standard data type. With NoSQL databases, everything is document-oriented and
    we can store data in one place without worrying about the data types. NoSQL databases
    hold collections of documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still perform database activities such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing an existing document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also perform a lot of advanced functionality, such as indexing and authentication.
    There are a lot of open source as well as commercial solutions that provide NoSQL
    databases. Here''s a quick list of some of the NoSQL database providers:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RavenDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firestore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MemcacheDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the course of developing our application in this chapter, we will implement
    Firestore as our backend system. In the next section, we will learn about some
    of the important tasks we will undertake involving these databases.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations – overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we consider using a database as a backend storage system for applications,
    the primary goal is to be able to add, retrieve, search, or modify the data, which
    are more commonly known as CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'CRUD stands for Create, Read, Update, and Delete in computer programming, and
    these terms are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**:Create or add new data to the database. We would usually be running
    an INSERT query in the database. This is associated with the HTTP POST method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**:Read or retrieve data based on a filter or search criteria. We will
    run the SELECT query in the database to do this. This is associated with the HTTP
    GET method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: Update or edit an existing record in the database. We will use
    the UPDATE query in the database. This is associated with the HTTP PUT method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete**:Delete an existing record in the database. We can either use the
    DELETE query to delete a record, or just set a column indicating that the record
    has been deleted using the UPDATE query. This is associated with the DELETE method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we'll use these concepts to build our `ListingApp`
    functionality and the technical requirements of our application.
  prefs: []
  type: TYPE_NORMAL
- en: ListingApp – technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any good dynamic application will require us to work with APIs and we will need
    to store the data in a database. This section covers two very important technical
    aspects required for building any dynamic application–JSON APIs and a dynamic
    database. We will be making use of the JSON server and for the database, we will
    use Google's Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: Building APIs for ListingApp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development cycle of any project, as a frontend developer, we will
    need to work with APIs and integrate them into our application. We will need to
    define and agree upon the JSON contracts that we expect from our APIs. In this
    section, we will learn about the various options we have to generate the APIs
    that we can use while the backend developers are still working on developing actual
    APIs. When we have fake APIs available, developers can work independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various tools and libraries (available for free) that we can use
    to work with fake APIs. We will be using the JSON server library to serve our
    APIs. So, let''s begin by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the `json-server` library, run the following command in the command-line
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the command has run successfully, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4e3c93b3-afdb-45b8-9161-78dda48b28e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have installed our `json-server` library, it''s time to create
    our APIs and JSON structure. In our project directory, we will create a new folder
    called APIs and create a new file named `data.json`, which will hold our JSON data.
    Take a look at the folder structure once you have created the folder and files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8237c689-9d04-4083-98a3-9e6ede3a2808.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we have created two JSON files, it''s time to add some JSON data to the
    files for listings, as well as users. Open the `listings.json` file by adding
    the following data to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are creating dummy data of JSON arrays for listings, users, and cities. Technically,
    in a real application scenario, this data would be retrieved from the database
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start serving the fake APIs with data, we need to start and initialize the
    JSON file. We will navigate to the `API` folder where we have created our `data.json`
    file and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have run the command successfully, we should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/89bc400c-4dc3-4bfa-b467-1bafd834cf43.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that, under Resources, we can see the fake APIs that are listed; that
    is, `http://localhost:3000/listings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try launching the URL in the browser. You should see the JSON data displayed
    for listings, users, and cities. The output is displayed in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6cf12696-4bd4-49c2-9fec-e7309c1bc69d.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! We can now use these APIs in our HTTP calls. We will have to wait for
    just one more section before we jump right into learning about HTTP functionality.
    For our friends who are full stack developers and know how to set up databases,
    the next section is certainly for you. We will learn about setting up our Firestore
    database, which will store our data. Later, we will use this to implement our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Google Firestore database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Google Firestore database is part of Google Cloud Platform. The official
    website of Google Cloud describes it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud Firestore** is a fast, fully managed, serverless, cloud-native NoSQL
    document database that simplifies storing, syncing, and querying data for your
    mobile, web, and IoT apps on a global scale. Reference: [https://cloud.google.com/firestore/](https://cloud.google.com/firestore/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firestore is a database as a service offered by Google and offers an easy-to-use
    NoSQL document database. Since Firestore is also coming from the makers of Angular,
    it''s natural that there are libraries that support easy integrations between
    the two. In this section, we will learn how to set up the Firestore database.
    So, let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to log in to our Firebase application using our credentials. Upon
    successful login, we should see the welcome screen, as displayed in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f0a7086f-2b95-410c-b9ec-0d48243ad883.png)'
  prefs: []
  type: TYPE_IMG
- en: The home page will list all the projects we created in the Firebase application,
    and you will also notice a big Add project link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new project for our application by clicking on the Add
    project link.We will be prompted by a modal window where we need to enter a Project
    name for our project, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b3635d56-27a4-41d2-ac9a-e7d101d1bbad.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we will enter `Listings` as our project name. Once our project has been
    provisioned, we will be taken to the newly created project page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now click on Databases in the sidebar menu. We will be prompted to select
    the mode in which we will initialize our database. We will select the test mode
    for our testing, and once we have performed the implementation, we will switch
    the security mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7899d48c-9591-4553-9148-0102594e5337.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we are using a database in test mode,
    which will allow us to read or write documents easily.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to change the settings of the database if you want to use the
    database in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now move on to create our `comments` collection. We''ll add a unique
    identifier called `commentId`. In addition, we are adding three fields as a schema
    for the documents that will be stored in the collections, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/143676a1-eaea-42ce-8193-f0e4785ffd31.png)'
  prefs: []
  type: TYPE_IMG
- en: Since Firestore is a NoSQL document database, the schema is not restricted by
    any data types. We can now perform CRUD operations, such as adding a new document,
    editing, or even deleting documents, in the Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two sections, we have learned about creating fake APIs using the
    JSON Server, and we have also created a NoSQL document database using Firestore.
    Now that we have reached a stage where we have learned about all the fundamental
    concepts needed to start implementing the end-to-end functionality of our `ListingApp`,
    let's jump into the HTTP world!
  prefs: []
  type: TYPE_NORMAL
- en: Angular HttpClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the most important aspect of Angular—`HttpClient`.
    Using the `HttpClient` interface, we can perform HTTP request and response calls. In
    the previous chapter, we learned about dependency injection and services; in this
    chapter, we will learn how to write services, which will include methods so that
    we can make HTTP calls and process responses using `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` is a small, easy-to-use, powerful library for performing HTTP
    request and response calls. Using `HttpClient`, we can easily communicate with
    backend services, and the module supports most modern web browsers. `HttpClient`
    comes with a lot of advanced functionality, such as interceptors and progress
    events. `HttpClient` supports various HTTP methods, including GET, POST, PUT,
    PATCH, DELETE, JSONP, and options. Each of these calls always returns an observable.
    We have to subscribe to the observables in order to process the responses. If
    we do not subscribe, nothing will happen.'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClientModule` is available in the `@angular/common/http` library and needs
    to be imported into the `app.module.ts` file; otherwise, we will encounter errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now know about the `HttpClient` module, but before we jump into implementing
    the module in our applications, it''s good to know about some of the key functionality
    that got added to `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpClient` provides a strongly typed response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request/response objects in `HttpClient` are immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON format response is the default. We no longer have to map it into a
    JSON object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` provides interceptors that are really helpful in middleware for
    intercepting an `HttpRequest` for transforming or processing a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpClient` includes testability features. We can easily mock the requests
    and process headers more efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we will learn about the `HttpClient` module, which
    needs to be imported into the component or service where we can make the HTTP
    calls. We will also learn about the HTTP verbs that are available and learn about
    their purpose in modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient and HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the previous section was an introduction to `HttpClientModule` and `HttpClient`
    and its advantages, in this section, we will dig deeper and also learn how to
    write some sample code for implementing `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, `HttpClient` supports GET, POST, PUT, PATCH, DELETE,
    JSONP, and options methods, which will return observables. `HttpClient` also provides
    modules, which can easily pass various options and data using `HttpHeaders` and
    `HttpParams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use `HttpClient`, we will need to import `HttpClientModule` into
    our application module (`app.module.ts`) file, and we also need to import `HttpClient`
    into our services or components and inject `HttpClient` inside the constructor
    so that we can use it to make HTTP calls. Add the following line of code to your
    `app.module.ts` file, and don''t forget to add it to the list of import modules
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's implement some of the most frequently used HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement the HTTP methods separately for both the JSON server APIs
    and the Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the HTTP GET method to communicate with backend services to retrieve
    information from a particular URL resource. The sample code to get all listings
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have created a method named `getAllListings`, and we have explicitly mentioning
    the fact that the method will return an observable value of any data type. We
    have to pass the URL to the GET method. The URL is a mandatory value we need to
    pass. We can also pass optional data such as `Headers`, `Params`, `reportProgress`,
    and `responseType`. The GET method will return an instance of an RxJS observable,
    and we can subscribe to listen to the response.
  prefs: []
  type: TYPE_NORMAL
- en: On similar terms, we can easily create HTTP calls using the POST, PUT, and DELETE
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we need to send any data or information securely to the server, such
    as a username, password, and email, we always use the POST method. The HTTP POST
    verb is always associated with creating or adding new data. It''s secure and does
    not make data visible in the URL, unlike GET. In the POST method, along with the
    URL as a string, we will need to pass data to the URL. We can also pass options
    to the POST method, such as Headers, and Params. The following is the sample code
    for writing a sample HTTP POST call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are creating a new method called `addNewListing`,
    which is accepting a param listing, which we will use as our data. We are creating
    an instance of `HttpHeaders`, so we create an object of the class, and we are
    setting the value of the `Content-Type` object to be `application/json`. We are
    then creating variable options and formatting them to send headers. Finally, we
    are making use of the `http.post` method to make a POST request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to make HTTP PUT calls. The PUT method is
    used to update or edit an existing dataset in the server. The HTTP PUT method
    involves a two-step process. First, we will need to retrieve data that we need
    to update and then pass the updated information back to the server using the POST
    method. The following is the sample code for creating the PUT method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need to pass the URL as a mandatory parameter for the PUT method. Fortunately,
    there are various options available. For example, we can pass headers, params,
    and suchlike in the options.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DELETE is an important operation of CRUD functionality. We can easily perform
    delete operations using the HTTP DELETE method. The `delete` operation can be
    achieved depending on the use case and the application''s compliance. There are
    two types of deletions we can do—soft delete and hard delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft delete**: When using soft delete, we do not delete or erase the records
    from our database systems; instead, we update the records and set a column or
    field and mark it as deleted so that the records are not displayed to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hard delete**: The requested data is deleted permanently from the database
    system. Once the data is erased, it cannot be reverted or restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me give you a good example of both use cases. If you try to delete your
    Google account, it notifies you that you can come back and restore your account
    within *x* number of days, after which the data will be completely erased from
    their servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our implementation. We can use the `http.delete()` method to implement
    the DELETE functionality in our applications. The sample code is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We need to pass the URL value as mandatory and options, as the name implies,
    are optional for the `delete` method.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP via promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises are just a technical implementation of what real-world promises do!
    Suppose you had promised your boss that you would complete tasks assigned to you.
    If you do, that means a promise has been resolved and if you don't, it means it's
    been rejected. Similarly, a Promise in HTTP implementation means that we will
    wait for future data, either resolved or rejected, and then we'll do some logical
    processing based on the output received.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP promises are a way to keep a placeholder for future data based on the success
    or failed states. Does this sound similar to regular HTTP calls? Yes, they are,
    with a major striking difference—*promises are asynchronous in nature*. When we
    make HTTP calls in Angular, it will wait until the request is completed and we
    receive the response; JavaScript will continue with the execution and, if it encounters
    synchronous assignments/operations, it will execute them immediately and fail
    if they are dependent on previous states or data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A promise takes a callback method, which will take two parameters—`resolve`
    and `reject`. `resolve` means the method will return a promise object with a given
    message, while `reject` means the promise object is rejected with a reason. Then,
    you can expect `.then` and `.catch` to be called back if all goes well or not,
    respectively. The following is the sample code for writing a promise, showing
    the handling responses of `resolve` and `reject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. We have implemented a promise and,
    as specified, the `callback` method will take two parameters, `resolve` and `reject`.
    We check whether the status of the listing is active; if yes, we resolve the promise;
    otherwise, we reject the promise. By default, the data returned by the resolved
    method will be passed to the `.then` method, and any failures or exceptions will
    be passed to the `.catch` method.
  prefs: []
  type: TYPE_NORMAL
- en: Since promises are asynchronous, which means we can chain events or methods,
    go ahead and add a method that will be called inside the `.then` method.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We are now armed with all the theoretical knowledge about the classes
    and modules provided by Angular for HTTP functionality. We learned about `HttpClientModule`,
    `HttpClient`, and, above all, we learned about the various HTTP verbs we can make
    use of in our application. We also learned about HTTP observables and promises.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to get our hands dirty with code. We will learn how to create
    our multiple data sources, which we will need to integrate using HTTP calls. The
    first one will be using the fake JSON server APIs, while the second one will be
    using the Firestore database. In the next section, we will learn about, and create,
    the services that we will need before we start our mission of integrating functionality
    end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating backend services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are making really good progress here, so let's keep rolling. One of the best
    practices in software development is to create code that is reusable, generic,
    and maintainable. In most applications that are dynamic in nature, we need to
    make a lot of HTTP calls to create, save, retrieve, edit, or delete data, as per
    the functional requirements of the application. If we do not have commonly shared
    HTTP calls, we may end up with a lot of methods having HTTP implementations, and
    it will be very difficult to maintain them in the long run. How do we address
    this situation? You already know the answer, my friend. That's right—by using
    services. In [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)*, Dependency
    Injection and Services, *we learned all about Angular services and best practices
    regarding dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular guidelines clearly state that all HTTP calls and functionality should
    be kept in services, which makes it easy to reuse existing code. Angular services
    are shared functions that allow us to access the properties and methods defined
    inside it. We will also create our custom services, in which we will implement
    our HTTP calls and which can be easily reused in various components. Let''s create
    two services—one for working with JSON server APIs, and one for Firestore database
    operations. For working with JSON server APIs, we will call our `DbOperationsService` service,
    and for working with the Firestore database, we will call our `CRUDService` service.
    Each of these services will have the methods to make HTTP calls for creating,
    reading, updating, and deleting the data. Now, let''s run the following `ng` command,
    which will generate our services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Upon successful execution of the preceding command, we will execute the following
    command to generate another service. Let's call it `crud`. We will use the following `ng`
    command to generate the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Following a successful run, we should see the service files being generated,
    along with their respective spec files. So far, so good. We will need these services
    when we start the end-to-end integration work. It may look complicated, but trust
    me, all of it will make a lot of sense in the sections to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Angular HTTP with backend APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is very important as this is the melting pot for most of the topics
    we have learned about throughout the course of this book. We are going to do complete
    end-to-end integration, from the UI to services, through to data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to generate the components that we are going to use in our application.
    Let''s run the following `ng` commands to generate four components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When these commands are run successfully, we should see the output shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/944fdf72-407c-45c0-95cc-7b26877b9220.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have generated our components, we will make use of the `DbOperationsService` service
    we generated in the previous section. We will also use our fake APIs that we created
    using the JSON server. We will implement methods for getting all the listings,
    viewing a particular listing, editing an existing listing, and finally, deleting
    a listing. In order to achieve this, we will need to import `HttpClientModule`
    into our `app.module.ts` file. We will also need to import `HttpClient` into our `db-operations.service.ts` service
    file. We will also import the `HttpHeaders` module. This is not mandatory, but,
    by way of good practice, we will be importing and using it while making our HTTP
    calls. We will be adding the following code to the `db-operations.service.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. First, we are importing the required
    modules: `Injectable`, `HttpClient`, `HttpHeaders`, and `HttpParams`. We are then
    injecting `HttpClient` into our constructor and creating an instance named `http`.
    We are then creating four methods, namely; `getListings`, `viewListing`, `editListing`,
    and `deleteListing`. In the `getListings` method, we are calling the API URL using
    the HTTP GET method. This will return all the listings from the `data.json` file
    we created earlier. In `viewListing`, we pass the ID of the Listing to retrieve
    the data of the listing using the HTTP GET method. In the `addListing` method,
    we are calling the API and passing the data object using the HTTP POST method.
    This will create a new row in our JSON file. Next up is the `editListing` method,
    which takes two parameters—the ID of the listing and the updated data object,
    which we need to save. The last method is `deleteListing`, to which we will pass
    the ID of the listing we want to delete.
  prefs: []
  type: TYPE_NORMAL
- en: In a more practical world, we would need to pass authentication tokens, additional
    security, cleaning data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now made our custom service, which includes the methods that will make
    HTTP calls. Before we start working on our components, we will create a few routes
    where we will map the components we have generated. Open the `app-routing.module.ts` file
    and import all our components inside it. Then, we will need to add the routes
    to it, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are updating our `AppRoutingModule` and adding five
    routes. We created the `create-listing` and `view-listing` routes and mapped them
    to `CreateListingComponent` and `ViewListingComponent`, respectively. That's very
    straightforward. For the `delete-listing` and `update-listing` routes, notice
    that we are passing a parameter named ID. We will use these and pass the listing
    ID in order to delete or update the data for a listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our service and routes, they are ready to be implemented
    in our components. Let''s start working on our components. First, we will start
    with `ViewListingComponent`. Open the `view-listing.component.ts` file and add
    functionality to retrieve all the listings, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. First, we need to import all the
    required modules and classes. We are importing `DbOperationsService` we created.
    We are also importing the listing interface class we created previously. Since
    we will be working with the `Listing` interface class, we will need to import `Observable`
    from `rxjs`. Next, we are declaring our selector as `app-view-listing`; we will
    call this directive in the template `view-listing.component.html` file. We will
    now create three variables, named `listArr`, `viewList`, and `isViewPage`. Note
    that `listArr` and `viewList` are declared as `Observable`. The difference between
    the `listArr` and `viewList` variables is that `listArr` is an observable of the
    Listing type and is an array, whereas `viewList` is an `Observable` of the Listing
    type and will hold a single list value. Since we have imported a service, we will
    need to create an instance called `dbOps` in our constructor method. We will implement
    the `ngOnInIt` method here; we are calling the `getListings` method using the
    instance of the `dbOps` service. We are subscribing to the method, which means
    we will map the data to the `listArr` variable. We will then use the `listArr` variable
    to display it in the template file. Finally, we are creating a `showListing` method
    to which we are passing the listing object. Using the instance of the service,
    we are calling the `viewListing` method and passing the listing ID. We are subscribing
    to the data and mapping it to the `viewList` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our template in the `view-listing.component.html` file
    and use the `listArr` and `viewList` variables to display the data in the page,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created a table. Using `ngFor`, we are looping
    the data that we get from the API, and, using interpolation, we are displaying
    the data in the table rows. Note that, for the anchor tags, we are using the `routerLink` directive
    to dynamically create the link, and we are passing the ID for the edit and delete
    links.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am sure you are excited about the end result. Let''s run the `ng serve` command.
    You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea6ccfac-c281-415e-806d-ca198cb3ef63.png)'
  prefs: []
  type: TYPE_IMG
- en: Beautiful! Now things are really cooking! There's no better encouragement than
    seeing the code in action. We have added the Add New Listing menu link, so now
    it's time to implement that functionality in our `createListing` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `createListingComponent` and modify the `create-listing.component.ts`
    file by adding the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the file. We are also importing the `DbOperationsService`, which we created
    earlier. We are creating a few variables; that is, `userId`, `newListing`, and
    `successMsg`, and assigning some initial values. We are creating an `addNewList` method,
    and we are passing the `listForm` data. We are also creating a data structure
    similar to our listing model that we created. Next, using the instance of the
    service, we are calling the `addListing` method and passing the data object that
    we need to save. This will create a new record in our `data.json` file. Finally,
    we are mapping the result to the `successMsg` variable. We will use this to display
    the success message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a fake API, we have stubbed the value of the ID. In a more
    real-time scenario, this ID will be auto-incremented on the database side and
    would always be a unique value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to update our template file so that we can get data from the
    user using the form. Open the `create-listing.component.html` file and add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are creating a form using the template-driven forms.
    We have created a few form fields to capture data, such as title, description,
    price, and active. We are using the template variables for the form and the fields.
    We are also calling the `addNewList` method on the `ngSubmit` event and submitting
    the entire form. By running the `ng serve` command, we should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25cfa752-5dbf-406c-9cb5-c36306ff7bf5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go ahead and add some data to the form fields and then click on the Submit
    button. You should see a success message if the record has been created successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45a7f6dd-fc19-4f86-b688-57a958605088.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Get All Listings link in the menu. You should see the newly
    created record in the listings displayed in the table. Do you remember that we
    added the edit and delete links for the listings? It's time to implement them
    now. We will start with the edit functionality first and then implement the delete
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our update listing component, edit the `update-listing.component.ts` file,
    and then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. We are importing the required modules
    into our component file. We are importing `ActivatedRoute`, our service, listing
    interface class, and observable into the component file. In order to achieve update
    functionality, we need to do two things. First, we will need to retrieve the data
    of the listing for which the ID is passed. Once the user updates the data and
    clicks on the Submit button, we will persist the data for that listing. We will
    also need to inject the router and service into our constructor. On the `ngOnInit`
    method, using the router snapshot, we are capturing the ID of the listing from
    the URL. Then, using the instance of the service, we are calling the `viewListing` method
    to get details of the listing based on the ID that's passed. Finally, we have
    created an `editListing` method. Using the instance of the service, we are calling
    the `editListing` method, and so we need to pass two parameters, one for passing
    the ID of the listing, and another for passing the updated data of the listings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update our template file. Open the `update-listing.component.html`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are once again creating a form based on the template-driven
    form approach. You will notice that the edit form is very much similar to the
    create listing form. You are almost correct, but there are some important differences.
    Note that we are now using two-way data binding with `ngModel` and binding the
    value to the form field. With this, when we get the initial data, it''s displayed
    in the form field. Now, the user can edit data and, when clicking on the Update
    Listing button, the data is sent to the `addListing` method and persisted in the
    backend API. Now, let''s see it in action. By running the `ng serve` command,
    we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a1dd547e-7a4d-4337-9167-8ff0b66d54ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the URL has the ID of the listing that was passed as the parameter.
    The data is retrieved and has been displayed on the page load. Now, when the user
    updates the details in the form and clicks on the Submit button, this will update
    the data of the listings. That's your homework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, so we have implemented create, edit, and view functionality. Next,
    we will implement the delete functionality of the listings. Remember that, for
    the delete and edit functionalities, the user will always navigate to the pages
    on click-through anchor tags. Open `DeleteListingComponent` and update the `delete-listing.component.ts`
    file, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the component file; that is, `ActivatedRoute`, `DbOperationsService`, `Listing`,
    and `Observable`. We are also creating a few variables—`viewList`, `ListId`, and
    `successMsg`. Then, we are injecting the route and service into the constructor
    method. Finally, with the `ngOnInIt` method, we are passing the ID of the listing
    that needs to be deleted. We are subscribing the data and mapping it to `successMsg`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to implement basic CRUD operations for
    our `ListingApp`. Then, we learned how to make HTTP calls for the GET, POST, PUT,
    and DELETE methods. Finally, we learned how to create fake APIs using the JSON
    Server. In the next section, we will learn how to implement CRUD operations using
    the cloud NoSQL Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Angular HTTP with Google Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to implement HTTP functionality for a NoSQL
    Firestore database. We created our Firestore database in an earlier section. Now
    is the right time to integrate the Angular HTTP calls, which will invoke and work
    with the Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: What are the use cases we will implement? For our `ListingApp`, we will need
    a commenting system. As a user, we should be able to add, edit, delete, and view
    comments. All of these use cases will require us to make HTTP calls to APIs to
    save, retrieve, and delete comments.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Fire is the official library for Firebase. The library provides a lot
    of built-in modules that support activities such as authentication, working with
    Firestore databases, observable-based push notifications, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to install this module under `@angular/fire`. Run the following
    command in the command-line interface to install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30d643f3-d22c-424b-8b87-083dfdafaa46.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have installed the library, we will proceed and create a new custom
    service for our integration pieces with the Firestore database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate a new service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64a22473-60eb-46b9-8af7-75c4fac4adbe.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that two files are generated. We will implement all our HTTP
    calls inside the service. As we mentioned previously, we will need to create a
    few components that will map to each piece of functionality and will internally
    call the service that has the HTTP implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `ng generate` commands to generate components for the comment''s
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding commands successfully, we should see the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07b0c36b-c14c-493d-b2ae-a4fc5e72edac.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that the components have been generated and added to our project
    directory. You will also notice that the `app.module.ts` file has been updated
    with entries for the components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have generated our components and the service that''s required for our integration.
    We have also installed the Angular Fire library. In order to use the Angular Fire
    library in our application, we will need to import the library into our `app.module.ts`
    file. Import the required modules into the app module file and list the modules
    in the import list of our application, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to note in the preceding code is that we are importing
    the required modules from Angular Fire and also listing them under the import
    module list. Notice that we have imported a file called `firebase-config`. These
    are environment variables, which will hold the API keys for authentication with
    Firebase. We can find the API keys listed under the Firebase account, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fe5f267-e6da-4265-8b00-f27ae9974cd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will need to copy the details into the `firebase-config.ts` file. The following
    screenshot displays the settings specified in our `ListingApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56f1af0c-5dc6-47e0-b652-87daf31e2832.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, so good. Now that we have installed the required library, imported the
    modules, and done the configuration settings, it's time to work on our application
    components. We are making great progress here. Let's keep this momentum going.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our components, we will quickly modify our `app-routing.module.ts`
    file and create a new route for each of these components.
  prefs: []
  type: TYPE_NORMAL
- en: We have already mastered Angular routing, in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing.* Revisit that chapter if you need a quick refresher.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have imported all the required component classes
    into the `app-routing.module.ts` file and added the respective routes to the routing
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the four newly created routes to implement the comment''s functionality
    in `ListingApp`. We are going to add the CRUD operations using the Firestore database.
    We will need to import the `AngularFirestore` module to our service, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have imported the module into our file, we will need to inject it
    inside the `constructor` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make use of the `AngularFirestore` module and implement CRUD operations
    using Firestore. Take a look at the complete updated code in the `crud-service.service.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code in detail. We have imported all the required
    modules, including our Angular Fire module and our `firebase-config` file. Since
    we have imported our `AngularFireStore` module, we will need to inject it into
    our `constructor` method and create an instance of it. We are creating methods
    for each of the actions for the comment's functionality. In the `getComments`
    method, we are retrieving all the data from the *comments *collection. In the `deleteComment`
    method, we are passing the ID of the comment we need to delete. In the `addComment`
    method, we are passing the data that we want to store in our collection. In the
    `updateComment` method, we are passing two parameters; the first is the ID of
    the comment we want to update, and the second is the updated data that we need
    to persist in the database.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we did not make any HTTP calls in these methods? The `AngularFireStore`
    module internally makes HTTP calls to the service and will authenticate and get
    account-specific information from the firebase config file.
  prefs: []
  type: TYPE_NORMAL
- en: In earlier sections, we learned how to send data from components to the service,
    right? Along the same lines, go ahead and try for comments functionality. That's
    your homework.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you feel? You should feel great and you should be proud of yourself!
    This chapter was a lot of work, but we're better off for having done it. It brought
    together all the aspects we have learned so far, such as forms, components, routing,
    services, and more.
  prefs: []
  type: TYPE_NORMAL
- en: For frontend developers, having a fake API setup in the local development environment
    always helps us to work independently without depending on backend developers
    or APIs. We learned about building fake APIs using the JSON server. We learned
    about the NoSQL document database, particularly the Firestore database provided
    by Google Cloud. We deep dived into Angular HTTP concepts and functionalities.
    We learned how to make HTTP POST, GET, PUT and DELETE calls. We also implemented
    our entire application's functional use cases using both the JSON Server and Firestore
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: We have made tremendous progress so far. We are now capable of developing Angular
    applications end to end, utilizing all the superpowers that Angular provides,
    including forms, components, services, routing, and much more. At the end of this
    chapter, I am confident that we are able to bring together all the pieces of the
    Angular framework into a single working app.
  prefs: []
  type: TYPE_NORMAL
- en: Having a working application up and running is a good sign of progress. But
    the important factor in terms of judging the application is to look at the quality
    checks or unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to write unit tests to make sure
    we catch any defects early in the product development life cycle. Writing test
    scripts ensures quality and is a great sign of handling all use cases, including
    both the happy and negative paths of our application.
  prefs: []
  type: TYPE_NORMAL
