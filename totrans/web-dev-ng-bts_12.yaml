- en: Integrating Backend Data Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成后端数据服务
- en: Welcome to Chapter 12! This is definitely my favorite chapter, as we will be
    building many end-to-end use cases for our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第12章！这绝对是我最喜欢的一章，因为我们将为我们的应用构建许多端到端的用例。
- en: A gentle warning—this chapter is dense—it is packed with a ton of information.
    You may have to read it at a slower pace and spend more time at the keyboard than
    you have with the previous chapters, but, I must say, it is well worth the effort.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个温和的警告——这一章内容密集——充满了大量的信息。你可能需要以较慢的速度阅读，并花更多时间在键盘上，比你在以前的章节中花的时间更多，但我必须说，这是非常值得的努力。
- en: 'Here is a great way to look at the overall progression of this book:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的方式来看待本书的整体进展：
- en: Everything we've looked at so far, including the two most recent chapters ([Chapter
    10](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml), *Working with Forms*, and [Chapter
    11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml), *Dependency Injection and Services*),
    has laid the foundation for this chapter. With that knowledge under our belts,
    we are now ready to put it all together in order to create our application. So,
    in essence, this chapter also serves the purpose of reviewing many of the topics
    we covered in previous chapters.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的一切，包括最近的两章（[第10章](5f27121b-6fb2-4429-aa6e-394aec2152ac.xhtml)，*使用表单*，和[第11章](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)，*依赖注入和服务*），都为这一章奠定了基础。有了这些知识，我们现在准备好把它们整合起来，以创建我们的应用。因此，从本质上讲，这一章也是为了回顾我们在以前章节中涵盖的许多主题。
- en: This chapter is the pivotal turning point for us because we will take everything
    we've learned thus far to build 95% of our application in this single chapter.
    This is a lot of material for one chapter, but we have spent a good amount of
    time going over all the aspects of Angular that we will need to build our application,
    so we're going to breeze through it. There is some new and slightly off-topic
    material too—learning how to build backend APIs—which is less important than the
    Angular material. However, we need to have an API, so I selected a set of technologies
    that are simple enough to quickly get up to speed with. We are also going over
    this to help you get your mind around the technologies we will be using to construct
    the APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一章对我们来说是一个关键的转折点，因为我们将把迄今为止学到的一切都用在这一章中构建我们应用的95%。这是一个章节中的大量材料，但我们已经花了很多时间来讨论我们需要构建应用的所有Angular方面，所以我们将轻松地完成它。还有一些新的和略微离题的材料——学习如何构建后端API——这比Angular材料更不重要。然而，我们需要有一个API，所以我选择了一套简单的技术，可以快速上手。我们还要讨论这个问题，以帮助你了解我们将用来构建API的技术。
- en: In the chapters that follow this one, we will add a couple of things to our
    app (such as route guards and custom form validation) and we will learn how to
    test, debug, secure, and deploy our application.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为我们的应用添加一些东西（如路由守卫和自定义表单验证），并学习如何测试、调试、保护和部署我们的应用。
- en: So, from that perspective, we're good to go. Many sections in this chapter are
    bonus material that I deem important to learn about because I want you to succeed,
    not only as an Angular developer, but as a web developer in general. This will
    help you to enhance your skills, and hands-on examples are sure to augment your
    technical knowledge as a web developer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从这个角度来看，我们已经准备好了。本章中的许多部分都是我认为重要学习的额外材料，因为我希望你不仅作为一个Angular开发者成功，而且作为一个网页开发者成功。这将帮助你提高你的技能，实际示例肯定会增加你作为网页开发者的技术知识。
- en: 'We will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: ListingApp – an overview
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListingApp - 概述
- en: Fundamental concepts for Angular applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular应用的基本概念
- en: ListingApp – technical requirements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListingApp - 技术要求
- en: Building APIs for our application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用构建APIs
- en: The Google Firestore database
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Firestore数据库
- en: Angular HttpClient
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular HttpClient
- en: Integrating backend services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成后端服务
- en: We've spent a lot of time in this book discussing a myriad of things—mostly
    Angular-centric (such as components, routing, flex-layout, NG Bootstrap, Angular
    Material, and working with forms), and a few things that were standalone (such
    as wire-framing, ES6, TypeScript, and Bootstrap). It is important to possess all
    that knowledge, of course, but we haven't yet integrated live data to bring our
    Angular application to life. However, as you can see from the previous bullet-point
    list, this is about to change. This is where developing in Angular starts to get
    fun, and also much more practical, since an application that does not create and
    consume data is not much of an application at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们花了很多时间讨论了许多事情 - 主要是与Angular相关的（如组件、路由、flex-layout、NG Bootstrap、Angular
    Material和处理表单），还有一些独立的事情（如线框、ES6、TypeScript和Bootstrap）。当然，拥有所有这些知识是很重要的，但我们还没有集成实时数据来使我们的Angular应用程序生动起来。然而，正如你从前面的项目列表中所看到的，这将发生改变。这就是Angular开发开始变得有趣的地方，也更加实用，因为一个不创建和使用数据的应用程序根本就不是一个应用程序。
- en: OK. Let's get right into it by starting with learning about some of the fundamental
    concepts that form the foundation of any application. Then, we'll take a look
    at the steps involved in building our ListingApp.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们立即开始学习构建任何应用程序基础的一些基本概念。然后，我们将看一下构建我们的ListingApp所涉及的步骤。
- en: ListingApp – an overview
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingApp - 概述
- en: 'In this chapter, we will be building our `ListingApp` application. In this
    section, we will cover the functional requirement list. Our overall application
    plan can be broken down into three main sections:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的“ListingApp”应用程序。在本节中，我们将介绍功能需求列表。我们的整体应用程序计划可以分为三个主要部分：
- en: '**UI layer**: The UI aspects involve designing or building the forms, displaying
    data, routing, and validations.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI层**：UI方面涉及设计或构建表单、显示数据、路由和验证。'
- en: '**Services or middleware layer**: We will learn how to write shared services,
    which will be responsible for backend integrations with APIs and databases.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务或中间件层**：我们将学习如何编写共享服务，这些服务将负责与API和数据库进行后端集成。'
- en: '**Database or fake API setup**: We will learn how to set up fake APIs using
    JSON Server and we will also learn how to create our NoSQL database using Firestore.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库或虚拟API设置**：我们将学习如何使用JSON Server设置虚拟API，并学习如何使用Firestore创建我们的NoSQL数据库。'
- en: 'Here''s the complete list of functional use cases we will be building as part
    of the learning experience in this chapter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本章学习过程中构建的功能用例的完整列表：
- en: Display all the listings
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有列表
- en: View listings by ID
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按ID查看列表
- en: Add a new listing
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的列表
- en: Edit a listing
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑列表
- en: Delete a listing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除列表
- en: Add comments
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加评论
- en: Update comments
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新评论
- en: Delete comments
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除评论
- en: Edit comments
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑评论
- en: All the use cases listed will require us to implement HTTP calls. For some,
    we will need to make POST, GET, and PUT HTTP calls.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的所有用例都需要我们实现HTTP调用。对于一些用例，我们需要进行POST、GET和PUT HTTP调用。
- en: Before we proceed any further, now is a good time to bring back all the learning
    and functionality we have implemented throughout the course of this book. We will
    need to recollect how we designed and developed our forms, how we captured the
    form data, how we displayed the data in the component templates, how we implemented
    routing with parameters, and how we call methods implemented in services inside
    components.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，现在是一个很好的时机，回顾我们在整本书中实施的所有学习和功能。我们需要回想一下我们如何设计和开发我们的表单，如何捕获表单数据，如何在组件模板中显示数据，如何使用参数实现路由，以及如何在组件内调用服务中实现的方法。
- en: We have a lot of work to do, and a load of fun awaits us, so let's get started!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多工作要做，还有很多乐趣在等着我们，所以让我们开始吧！
- en: Fundamental concepts for Angular applications
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular应用程序的基本概念
- en: We are going to learn and build a lot of interesting things in this chapter,
    but before we start doing that, we should learn about a number of fundamental
    concepts, including strongly typed language concepts, Angular models, observables, NoSQL
    databases, and CRUD operations in general.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习和构建许多有趣的东西，但在开始之前，我们应该了解一些基本概念，包括强类型语言概念、Angular模型、可观察对象、NoSQL数据库和一般的CRUD操作。
- en: Strongly typed languages
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型语言
- en: 'A strongly typed programming language refers to the fact that each of the data
    types is predefined and tightly coupled with the variables. Take a look at the
    following variable that''s been defined:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型编程语言指的是每种数据类型都是预定义的，并且与变量紧密耦合。看看下面定义的变量：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are declaring a variable and explicitly mentioned the fact that the type
    of variable is an integer, which makes it very obvious that the variable cannot
    hold any other data type except an integer. If we try to provide any value that
    is not an integer, TypeScript will throw an error. TypeScript is also a strongly
    typed language and, since we write our Angular applications in TypeScript, we
    can conclude that Angular applications follow strongly typed formats.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个变量，并明确指出变量的类型是整数，这使得很明显变量除了整数之外不能容纳任何其他数据类型。如果我们尝试提供任何不是整数的值，TypeScript会抛出错误。TypeScript也是一种强类型语言，因为我们在TypeScript中编写我们的Angular应用程序，我们可以得出结论，Angular应用程序遵循强类型格式。
- en: Typescript interfaces
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Typescript接口
- en: In this section, we will learn how to create our own data types in TypeScript,
    which we can use in our Angular applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在TypeScript中创建我们自己的数据类型，这些类型可以在我们的Angular应用程序中使用。
- en: Angular models are a way to create complex data structures by clubbing multiple
    data types into an object and defining a new object, which can then be used as
    a data type in itself. It's Angular's way of ensuring that complex data objects
    adhere to certain predefined data specs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular模型是一种通过将多个数据类型组合成一个对象并定义一个新对象来创建复杂数据结构的方法，然后可以将其作为数据类型本身使用。这是Angular确保复杂数据对象遵守某些预定义数据规范的方式。
- en: 'The TypeScript language provides interfaces that also serve the same purpose.
    We can also make use of ES6 classes to define our data structures. We can extend
    the programming syntax to create our custom data types. Let''s demonstrate this
    by creating a sample model. We are going to create a model and call it `Listing`,
    which will have the following properties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言提供了接口，也具有相同的作用。我们还可以利用ES6类来定义我们的数据结构。我们可以扩展编程语法来创建我们自定义的数据类型。让我们通过创建一个示例模型来演示这一点。我们将创建一个名为`Listing`的模型，它将具有以下属性：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created an Angular model, which is a class with properties such as `id`,
    `userId`, `title`, `status`, `price`, and `active`. We can now use this model
    as a data type in our application. We can import this class into all of our components
    and services to make sure our data map adheres to the `Listing` data spec.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个Angular模型，这是一个具有属性的类，例如`id`、`userId`、`title`、`status`、`price`和`active`。现在我们可以在我们的应用程序中使用这个模型作为数据类型。我们可以将这个类导入到所有的组件和服务中，以确保我们的数据映射符合`Listing`数据规范。
- en: We will use the previously defined model throughout this chapter while building
    our application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在构建应用程序时使用先前定义的模型。
- en: Observables
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象
- en: Most traditional applications work on the request and response architecture,
    which means our application client will make a request for data to the server,
    and, in return, the server will give us a response. While the server is returning
    the response, our application goes into wait mode until all the responses are
    received, which obviously makes applications slow.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: This architecture has multiple drawbacks. First, the application waits for a
    response, which creates delays in applications. Second, there is no way we can
    handle multiple pieces of data coming in over a period of time. Third, since our
    application waits until it gets the response, which makes synchronous calls, we
    cannot execute asynchronous programming. And finally, event handling becomes a
    nightmare for developers. So, how do we address the preceding issues? The answer
    is by using observables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Observables are a type of array that returns data over a period of time asynchronously.
    Angular uses a third-party library called **Reactive Extensions** (**RxJS**) and
    has observables implemented inside the framework mainly for event handling, tree
    shaking, and so on. We can also easily import, create, and subscribe to custom
    observables.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases concept
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn about NoSQL databases. Really? NoSQL?
    Are we not going to use a database to store our critical data? Of course we are
    going to use a database to store our data; however, it won't be a traditional
    relational database, which has a strict predefined schema and columns that have
    a standard data type. With NoSQL databases, everything is document-oriented and
    we can store data in one place without worrying about the data types. NoSQL databases
    hold collections of documents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still perform database activities such as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Creating a document
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a document
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing an existing document
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a document
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also perform a lot of advanced functionality, such as indexing and authentication.
    There are a lot of open source as well as commercial solutions that provide NoSQL
    databases. Here''s a quick list of some of the NoSQL database providers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RavenDB
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firestore
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MemcacheDB
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the course of developing our application in this chapter, we will implement
    Firestore as our backend system. In the next section, we will learn about some
    of the important tasks we will undertake involving these databases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: CRUD operations – overview
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we consider using a database as a backend storage system for applications,
    the primary goal is to be able to add, retrieve, search, or modify the data, which
    are more commonly known as CRUD operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们考虑将数据库作为应用程序的后端存储系统时，主要目标是能够添加、检索、搜索或修改数据，这更常被称为CRUD操作。
- en: 'CRUD stands for Create, Read, Update, and Delete in computer programming, and
    these terms are outlined as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD代表计算机编程中的创建、读取、更新和删除，这些术语如下所述：
- en: '**Create**:Create or add new data to the database. We would usually be running
    an INSERT query in the database. This is associated with the HTTP POST method.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：在数据库中创建或添加新数据。我们通常会在数据库中运行INSERT查询。这与HTTP POST方法相关联。'
- en: '**Read**:Read or retrieve data based on a filter or search criteria. We will
    run the SELECT query in the database to do this. This is associated with the HTTP
    GET method.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：根据过滤器或搜索条件读取或检索数据。我们将在数据库中运行SELECT查询来执行此操作。这与HTTP GET方法相关联。'
- en: '**Update**: Update or edit an existing record in the database. We will use
    the UPDATE query in the database. This is associated with the HTTP PUT method.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新或编辑数据库中的现有记录。我们将在数据库中使用UPDATE查询。这与HTTP PUT方法相关联。'
- en: '**Delete**:Delete an existing record in the database. We can either use the
    DELETE query to delete a record, or just set a column indicating that the record
    has been deleted using the UPDATE query. This is associated with the DELETE method.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除**：删除数据库中的现有记录。我们可以使用DELETE查询来删除记录，或者只是使用UPDATE查询设置一个指示记录已被删除的列。这与DELETE方法相关联。'
- en: In the upcoming sections, we'll use these concepts to build our `ListingApp`
    functionality and the technical requirements of our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将使用这些概念来构建我们的`ListingApp`功能和我们应用程序的技术要求。
- en: ListingApp – technical requirements
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListingApp - 技术要求
- en: Any good dynamic application will require us to work with APIs and we will need
    to store the data in a database. This section covers two very important technical
    aspects required for building any dynamic application–JSON APIs and a dynamic
    database. We will be making use of the JSON server and for the database, we will
    use Google's Firestore database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 任何良好的动态应用程序都需要我们处理API，并且我们需要将数据存储在数据库中。本节涵盖了构建任何动态应用程序所需的两个非常重要的技术方面 - JSON
    API和动态数据库。我们将使用JSON服务器，而对于数据库，我们将使用Google的Firestore数据库。
- en: Building APIs for ListingApp
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ListingApp构建API
- en: During the development cycle of any project, as a frontend developer, we will
    need to work with APIs and integrate them into our application. We will need to
    define and agree upon the JSON contracts that we expect from our APIs. In this
    section, we will learn about the various options we have to generate the APIs
    that we can use while the backend developers are still working on developing actual
    APIs. When we have fake APIs available, developers can work independently.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何项目的开发周期中，作为前端开发人员，我们将需要处理API并将其集成到我们的应用程序中。我们需要定义并就我们期望从API中得到的JSON合同达成一致。在本节中，我们将了解我们在后端开发人员仍在开发实际API时可以使用的各种生成API的选项。当我们有虚假API可用时，开发人员可以独立工作。
- en: 'There are various tools and libraries (available for free) that we can use
    to work with fake APIs. We will be using the JSON server library to serve our
    APIs. So, let''s begin by taking the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的工具和库（可免费使用），我们可以用来处理虚假API。我们将使用JSON服务器库来提供我们的API。所以，让我们从以下步骤开始：
- en: 'To install the `json-server` library, run the following command in the command-line
    interface:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`json-server`库，请在命令行界面中运行以下命令：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the command has run successfully, you should see the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令成功运行时，您应该看到以下输出：
- en: '![](assets/4e3c93b3-afdb-45b8-9161-78dda48b28e0.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have installed our `json-server` library, it''s time to create
    our APIs and JSON structure. In our project directory, we will create a new folder
    called APIs and create a new file named `data.json`, which will hold our JSON data.
    Take a look at the folder structure once you have created the folder and files:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8237c689-9d04-4083-98a3-9e6ede3a2808.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Since we have created two JSON files, it''s time to add some JSON data to the
    files for listings, as well as users. Open the `listings.json` file by adding
    the following data to it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are creating dummy data of JSON arrays for listings, users, and cities. Technically,
    in a real application scenario, this data would be retrieved from the database
    at runtime.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'To start serving the fake APIs with data, we need to start and initialize the
    JSON file. We will navigate to the `API` folder where we have created our `data.json`
    file and run the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we have run the command successfully, we should see the following output:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/89bc400c-4dc3-4bfa-b467-1bafd834cf43.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Notice that, under Resources, we can see the fake APIs that are listed; that
    is, `http://localhost:3000/listings`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Try launching the URL in the browser. You should see the JSON data displayed
    for listings, users, and cities. The output is displayed in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6cf12696-4bd4-49c2-9fec-e7309c1bc69d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Awesome! We can now use these APIs in our HTTP calls. We will have to wait for
    just one more section before we jump right into learning about HTTP functionality.
    For our friends who are full stack developers and know how to set up databases,
    the next section is certainly for you. We will learn about setting up our Firestore
    database, which will store our data. Later, we will use this to implement our
    application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Google Firestore database
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Google Firestore database is part of Google Cloud Platform. The official
    website of Google Cloud describes it as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud Firestore** is a fast, fully managed, serverless, cloud-native NoSQL
    document database that simplifies storing, syncing, and querying data for your
    mobile, web, and IoT apps on a global scale. Reference: [https://cloud.google.com/firestore/](https://cloud.google.com/firestore/)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Firestore is a database as a service offered by Google and offers an easy-to-use
    NoSQL document database. Since Firestore is also coming from the makers of Angular,
    it''s natural that there are libraries that support easy integrations between
    the two. In this section, we will learn how to set up the Firestore database.
    So, let''s begin:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to log in to our Firebase application using our credentials. Upon
    successful login, we should see the welcome screen, as displayed in the following
    screenshot:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f0a7086f-2b95-410c-b9ec-0d48243ad883.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: The home page will list all the projects we created in the Firebase application,
    and you will also notice a big Add project link.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new project for our application by clicking on the Add
    project link.We will be prompted by a modal window where we need to enter a Project
    name for our project, as shown in the following screenshot:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b3635d56-27a4-41d2-ac9a-e7d101d1bbad.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Here, we will enter `Listings` as our project name. Once our project has been
    provisioned, we will be taken to the newly created project page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We now click on Databases in the sidebar menu. We will be prompted to select
    the mode in which we will initialize our database. We will select the test mode
    for our testing, and once we have performed the implementation, we will switch
    the security mode:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7899d48c-9591-4553-9148-0102594e5337.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we are using a database in test mode,
    which will allow us to read or write documents easily.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to change the settings of the database if you want to use the
    database in a production environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now move on to create our `comments` collection. We''ll add a unique
    identifier called `commentId`. In addition, we are adding three fields as a schema
    for the documents that will be stored in the collections, as shown here:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/143676a1-eaea-42ce-8193-f0e4785ffd31.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Since Firestore is a NoSQL document database, the schema is not restricted by
    any data types. We can now perform CRUD operations, such as adding a new document,
    editing, or even deleting documents, in the Firestore database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In the last two sections, we have learned about creating fake APIs using the
    JSON Server, and we have also created a NoSQL document database using Firestore.
    Now that we have reached a stage where we have learned about all the fundamental
    concepts needed to start implementing the end-to-end functionality of our `ListingApp`,
    let's jump into the HTTP world!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两个部分中，我们已经学习了如何使用JSON Server创建虚拟API，并且还使用Firestore创建了一个NoSQL文档数据库。现在我们已经达到了一个阶段，我们已经学习了开始实现`ListingApp`端到端功能所需的所有基本概念，让我们进入HTTP世界吧！
- en: Angular HttpClient
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular HttpClient
- en: In this section, we will learn about the most important aspect of Angular—`HttpClient`.
    Using the `HttpClient` interface, we can perform HTTP request and response calls. In
    the previous chapter, we learned about dependency injection and services; in this
    chapter, we will learn how to write services, which will include methods so that
    we can make HTTP calls and process responses using `HttpClient`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习Angular最重要的方面——`HttpClient`。使用`HttpClient`接口，我们可以执行HTTP请求和响应调用。在上一章中，我们学习了依赖注入和服务；在本章中，我们将学习如何编写包含方法的服务，以便我们可以使用`HttpClient`进行HTTP调用和处理响应。
- en: '`HttpClient` is a small, easy-to-use, powerful library for performing HTTP
    request and response calls. Using `HttpClient`, we can easily communicate with
    backend services, and the module supports most modern web browsers. `HttpClient`
    comes with a lot of advanced functionality, such as interceptors and progress
    events. `HttpClient` supports various HTTP methods, including GET, POST, PUT,
    PATCH, DELETE, JSONP, and options. Each of these calls always returns an observable.
    We have to subscribe to the observables in order to process the responses. If
    we do not subscribe, nothing will happen.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient`是一个小巧、易于使用、功能强大的库，用于执行HTTP请求和响应调用。使用`HttpClient`，我们可以轻松地与后端服务进行通信，该模块支持大多数现代Web浏览器。`HttpClient`具有许多高级功能，如拦截器和进度事件。`HttpClient`支持各种HTTP方法，包括GET、POST、PUT、PATCH、DELETE、JSONP和options。这些调用中的每一个都会返回一个observable。我们必须订阅这些observable以处理响应。如果我们不订阅，将不会发生任何事情。'
- en: '`HttpClientModule` is available in the `@angular/common/http` library and needs
    to be imported into the `app.module.ts` file; otherwise, we will encounter errors.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClientModule`位于`@angular/common/http`库中，需要被导入到`app.module.ts`文件中；否则，我们将遇到错误。'
- en: 'We now know about the `HttpClient` module, but before we jump into implementing
    the module in our applications, it''s good to know about some of the key functionality
    that got added to `HttpClient`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了`HttpClient`模块，但在我们开始在应用程序中实现该模块之前，了解一些被添加到`HttpClient`中的关键功能是很重要的：
- en: '`HttpClient` provides a strongly typed response body.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`提供了强类型的响应体。'
- en: The request/response objects in `HttpClient` are immutable.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`中的请求/响应对象是不可变的。'
- en: The JSON format response is the default. We no longer have to map it into a
    JSON object.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON格式的响应是默认的。我们不再需要将其映射为JSON对象。
- en: '`HttpClient` provides interceptors that are really helpful in middleware for
    intercepting an `HttpRequest` for transforming or processing a response.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`提供了拦截器，这在中间件中拦截`HttpRequest`以进行转换或处理响应非常有帮助。'
- en: '`HttpClient` includes testability features. We can easily mock the requests
    and process headers more efficiently.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpClient`包括可测试性功能。我们可以轻松模拟请求并更有效地处理标头。'
- en: In the following section, we will learn about the `HttpClient` module, which
    needs to be imported into the component or service where we can make the HTTP
    calls. We will also learn about the HTTP verbs that are available and learn about
    their purpose in modern applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习`HttpClient`模块，它需要被导入到组件或服务中，我们可以在那里进行HTTP调用。我们还将学习现代应用程序中可用的HTTP动词以及它们的目的。
- en: HttpClient and HTTP verbs
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the previous section was an introduction to `HttpClientModule` and `HttpClient`
    and its advantages, in this section, we will dig deeper and also learn how to
    write some sample code for implementing `HttpClient`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, `HttpClient` supports GET, POST, PUT, PATCH, DELETE,
    JSONP, and options methods, which will return observables. `HttpClient` also provides
    modules, which can easily pass various options and data using `HttpHeaders` and
    `HttpParams`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use `HttpClient`, we will need to import `HttpClientModule` into
    our application module (`app.module.ts`) file, and we also need to import `HttpClient`
    into our services or components and inject `HttpClient` inside the constructor
    so that we can use it to make HTTP calls. Add the following line of code to your
    `app.module.ts` file, and don''t forget to add it to the list of import modules
    as well:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's implement some of the most frequently used HTTP verbs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: We will implement the HTTP methods separately for both the JSON server APIs
    and the Firestore database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: HTTP GET
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the HTTP GET method to communicate with backend services to retrieve
    information from a particular URL resource. The sample code to get all listings
    is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created a method named `getAllListings`, and we have explicitly mentioning
    the fact that the method will return an observable value of any data type. We
    have to pass the URL to the GET method. The URL is a mandatory value we need to
    pass. We can also pass optional data such as `Headers`, `Params`, `reportProgress`,
    and `responseType`. The GET method will return an instance of an RxJS observable,
    and we can subscribe to listen to the response.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: On similar terms, we can easily create HTTP calls using the POST, PUT, and DELETE
    methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: HTTP POST
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we need to send any data or information securely to the server, such
    as a username, password, and email, we always use the POST method. The HTTP POST
    verb is always associated with creating or adding new data. It''s secure and does
    not make data visible in the URL, unlike GET. In the POST method, along with the
    URL as a string, we will need to pass data to the URL. We can also pass options
    to the POST method, such as Headers, and Params. The following is the sample code
    for writing a sample HTTP POST call:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are creating a new method called `addNewListing`,
    which is accepting a param listing, which we will use as our data. We are creating
    an instance of `HttpHeaders`, so we create an object of the class, and we are
    setting the value of the `Content-Type` object to be `application/json`. We are
    then creating variable options and formatting them to send headers. Finally, we
    are making use of the `http.post` method to make a POST request.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: HTTP PUT
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to make HTTP PUT calls. The PUT method is
    used to update or edit an existing dataset in the server. The HTTP PUT method
    involves a two-step process. First, we will need to retrieve data that we need
    to update and then pass the updated information back to the server using the POST
    method. The following is the sample code for creating the PUT method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to pass the URL as a mandatory parameter for the PUT method. Fortunately,
    there are various options available. For example, we can pass headers, params,
    and suchlike in the options.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: HTTP DELETE
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DELETE is an important operation of CRUD functionality. We can easily perform
    delete operations using the HTTP DELETE method. The `delete` operation can be
    achieved depending on the use case and the application''s compliance. There are
    two types of deletions we can do—soft delete and hard delete:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft delete**: When using soft delete, we do not delete or erase the records
    from our database systems; instead, we update the records and set a column or
    field and mark it as deleted so that the records are not displayed to the user.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hard delete**: The requested data is deleted permanently from the database
    system. Once the data is erased, it cannot be reverted or restored.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let me give you a good example of both use cases. If you try to delete your
    Google account, it notifies you that you can come back and restore your account
    within *x* number of days, after which the data will be completely erased from
    their servers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our implementation. We can use the `http.delete()` method to implement
    the DELETE functionality in our applications. The sample code is given here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to pass the URL value as mandatory and options, as the name implies,
    are optional for the `delete` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: HTTP via promises
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises are just a technical implementation of what real-world promises do!
    Suppose you had promised your boss that you would complete tasks assigned to you.
    If you do, that means a promise has been resolved and if you don't, it means it's
    been rejected. Similarly, a Promise in HTTP implementation means that we will
    wait for future data, either resolved or rejected, and then we'll do some logical
    processing based on the output received.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: HTTP promises are a way to keep a placeholder for future data based on the success
    or failed states. Does this sound similar to regular HTTP calls? Yes, they are,
    with a major striking difference—*promises are asynchronous in nature*. When we
    make HTTP calls in Angular, it will wait until the request is completed and we
    receive the response; JavaScript will continue with the execution and, if it encounters
    synchronous assignments/operations, it will execute them immediately and fail
    if they are dependent on previous states or data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'A promise takes a callback method, which will take two parameters—`resolve`
    and `reject`. `resolve` means the method will return a promise object with a given
    message, while `reject` means the promise object is rejected with a reason. Then,
    you can expect `.then` and `.catch` to be called back if all goes well or not,
    respectively. The following is the sample code for writing a promise, showing
    the handling responses of `resolve` and `reject`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's analyze the preceding code in detail. We have implemented a promise and,
    as specified, the `callback` method will take two parameters, `resolve` and `reject`.
    We check whether the status of the listing is active; if yes, we resolve the promise;
    otherwise, we reject the promise. By default, the data returned by the resolved
    method will be passed to the `.then` method, and any failures or exceptions will
    be passed to the `.catch` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Since promises are asynchronous, which means we can chain events or methods,
    go ahead and add a method that will be called inside the `.then` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We are now armed with all the theoretical knowledge about the classes
    and modules provided by Angular for HTTP functionality. We learned about `HttpClientModule`,
    `HttpClient`, and, above all, we learned about the various HTTP verbs we can make
    use of in our application. We also learned about HTTP observables and promises.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to get our hands dirty with code. We will learn how to create
    our multiple data sources, which we will need to integrate using HTTP calls. The
    first one will be using the fake JSON server APIs, while the second one will be
    using the Firestore database. In the next section, we will learn about, and create,
    the services that we will need before we start our mission of integrating functionality
    end to end.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Integrating backend services
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are making really good progress here, so let's keep rolling. One of the best
    practices in software development is to create code that is reusable, generic,
    and maintainable. In most applications that are dynamic in nature, we need to
    make a lot of HTTP calls to create, save, retrieve, edit, or delete data, as per
    the functional requirements of the application. If we do not have commonly shared
    HTTP calls, we may end up with a lot of methods having HTTP implementations, and
    it will be very difficult to maintain them in the long run. How do we address
    this situation? You already know the answer, my friend. That's right—by using
    services. In [Chapter 11](437face8-d59c-42f3-a49a-af43f2892f7a.xhtml)*, Dependency
    Injection and Services, *we learned all about Angular services and best practices
    regarding dependency injection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular guidelines clearly state that all HTTP calls and functionality should
    be kept in services, which makes it easy to reuse existing code. Angular services
    are shared functions that allow us to access the properties and methods defined
    inside it. We will also create our custom services, in which we will implement
    our HTTP calls and which can be easily reused in various components. Let''s create
    two services—one for working with JSON server APIs, and one for Firestore database
    operations. For working with JSON server APIs, we will call our `DbOperationsService` service,
    and for working with the Firestore database, we will call our `CRUDService` service.
    Each of these services will have the methods to make HTTP calls for creating,
    reading, updating, and deleting the data. Now, let''s run the following `ng` command,
    which will generate our services:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Upon successful execution of the preceding command, we will execute the following
    command to generate another service. Let's call it `crud`. We will use the following `ng`
    command to generate the service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Following a successful run, we should see the service files being generated,
    along with their respective spec files. So far, so good. We will need these services
    when we start the end-to-end integration work. It may look complicated, but trust
    me, all of it will make a lot of sense in the sections to follow.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Angular HTTP with backend APIs
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is very important as this is the melting pot for most of the topics
    we have learned about throughout the course of this book. We are going to do complete
    end-to-end integration, from the UI to services, through to data sources.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to generate the components that we are going to use in our application.
    Let''s run the following `ng` commands to generate four components:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When these commands are run successfully, we should see the output shown in
    the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/944fdf72-407c-45c0-95cc-7b26877b9220.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have generated our components, we will make use of the `DbOperationsService` service
    we generated in the previous section. We will also use our fake APIs that we created
    using the JSON server. We will implement methods for getting all the listings,
    viewing a particular listing, editing an existing listing, and finally, deleting
    a listing. In order to achieve this, we will need to import `HttpClientModule`
    into our `app.module.ts` file. We will also need to import `HttpClient` into our `db-operations.service.ts` service
    file. We will also import the `HttpHeaders` module. This is not mandatory, but,
    by way of good practice, we will be importing and using it while making our HTTP
    calls. We will be adding the following code to the `db-operations.service.ts`
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's analyze the preceding code in detail. First, we are importing the required
    modules: `Injectable`, `HttpClient`, `HttpHeaders`, and `HttpParams`. We are then
    injecting `HttpClient` into our constructor and creating an instance named `http`.
    We are then creating four methods, namely; `getListings`, `viewListing`, `editListing`,
    and `deleteListing`. In the `getListings` method, we are calling the API URL using
    the HTTP GET method. This will return all the listings from the `data.json` file
    we created earlier. In `viewListing`, we pass the ID of the Listing to retrieve
    the data of the listing using the HTTP GET method. In the `addListing` method,
    we are calling the API and passing the data object using the HTTP POST method.
    This will create a new row in our JSON file. Next up is the `editListing` method,
    which takes two parameters—the ID of the listing and the updated data object,
    which we need to save. The last method is `deleteListing`, to which we will pass
    the ID of the listing we want to delete.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In a more practical world, we would need to pass authentication tokens, additional
    security, cleaning data, and so on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now made our custom service, which includes the methods that will make
    HTTP calls. Before we start working on our components, we will create a few routes
    where we will map the components we have generated. Open the `app-routing.module.ts` file
    and import all our components inside it. Then, we will need to add the routes
    to it, as shown in the following code block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we are updating our `AppRoutingModule` and adding five
    routes. We created the `create-listing` and `view-listing` routes and mapped them
    to `CreateListingComponent` and `ViewListingComponent`, respectively. That's very
    straightforward. For the `delete-listing` and `update-listing` routes, notice
    that we are passing a parameter named ID. We will use these and pass the listing
    ID in order to delete or update the data for a listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our service and routes, they are ready to be implemented
    in our components. Let''s start working on our components. First, we will start
    with `ViewListingComponent`. Open the `view-listing.component.ts` file and add
    functionality to retrieve all the listings, as shown in the following code block:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's analyze the preceding code in detail. First, we need to import all the
    required modules and classes. We are importing `DbOperationsService` we created.
    We are also importing the listing interface class we created previously. Since
    we will be working with the `Listing` interface class, we will need to import `Observable`
    from `rxjs`. Next, we are declaring our selector as `app-view-listing`; we will
    call this directive in the template `view-listing.component.html` file. We will
    now create three variables, named `listArr`, `viewList`, and `isViewPage`. Note
    that `listArr` and `viewList` are declared as `Observable`. The difference between
    the `listArr` and `viewList` variables is that `listArr` is an observable of the
    Listing type and is an array, whereas `viewList` is an `Observable` of the Listing
    type and will hold a single list value. Since we have imported a service, we will
    need to create an instance called `dbOps` in our constructor method. We will implement
    the `ngOnInIt` method here; we are calling the `getListings` method using the
    instance of the `dbOps` service. We are subscribing to the method, which means
    we will map the data to the `listArr` variable. We will then use the `listArr` variable
    to display it in the template file. Finally, we are creating a `showListing` method
    to which we are passing the listing object. Using the instance of the service,
    we are calling the `viewListing` method and passing the listing ID. We are subscribing
    to the data and mapping it to the `viewList` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to update our template in the `view-listing.component.html` file
    and use the `listArr` and `viewList` variables to display the data in the page,
    as shown in the following code block:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have created a table. Using `ngFor`, we are looping
    the data that we get from the API, and, using interpolation, we are displaying
    the data in the table rows. Note that, for the anchor tags, we are using the `routerLink` directive
    to dynamically create the link, and we are passing the ID for the edit and delete
    links.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'I am sure you are excited about the end result. Let''s run the `ng serve` command.
    You should see the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea6ccfac-c281-415e-806d-ca198cb3ef63.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Beautiful! Now things are really cooking! There's no better encouragement than
    seeing the code in action. We have added the Add New Listing menu link, so now
    it's time to implement that functionality in our `createListing` component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `createListingComponent` and modify the `create-listing.component.ts`
    file by adding the following code to it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the file. We are also importing the `DbOperationsService`, which we created
    earlier. We are creating a few variables; that is, `userId`, `newListing`, and
    `successMsg`, and assigning some initial values. We are creating an `addNewList` method,
    and we are passing the `listForm` data. We are also creating a data structure
    similar to our listing model that we created. Next, using the instance of the
    service, we are calling the `addListing` method and passing the data object that
    we need to save. This will create a new record in our `data.json` file. Finally,
    we are mapping the result to the `successMsg` variable. We will use this to display
    the success message to the user.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using a fake API, we have stubbed the value of the ID. In a more
    real-time scenario, this ID will be auto-incremented on the database side and
    would always be a unique value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to update our template file so that we can get data from the
    user using the form. Open the `create-listing.component.html` file and add the
    following code to it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we are creating a form using the template-driven forms.
    We have created a few form fields to capture data, such as title, description,
    price, and active. We are using the template variables for the form and the fields.
    We are also calling the `addNewList` method on the `ngSubmit` event and submitting
    the entire form. By running the `ng serve` command, we should see the following
    output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/25cfa752-5dbf-406c-9cb5-c36306ff7bf5.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Now, go ahead and add some data to the form fields and then click on the Submit
    button. You should see a success message if the record has been created successfully:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45a7f6dd-fc19-4f86-b688-57a958605088.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Get All Listings link in the menu. You should see the newly
    created record in the listings displayed in the table. Do you remember that we
    added the edit and delete links for the listings? It's time to implement them
    now. We will start with the edit functionality first and then implement the delete
    functionality.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our update listing component, edit the `update-listing.component.ts` file,
    and then add the following code to it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    into our component file. We are importing `ActivatedRoute`, our service, listing
    interface class, and observable into the component file. In order to achieve update
    functionality, we need to do two things. First, we will need to retrieve the data
    of the listing for which the ID is passed. Once the user updates the data and
    clicks on the Submit button, we will persist the data for that listing. We will
    also need to inject the router and service into our constructor. On the `ngOnInit`
    method, using the router snapshot, we are capturing the ID of the listing from
    the URL. Then, using the instance of the service, we are calling the `viewListing` method
    to get details of the listing based on the ID that's passed. Finally, we have
    created an `editListing` method. Using the instance of the service, we are calling
    the `editListing` method, and so we need to pass two parameters, one for passing
    the ID of the listing, and another for passing the updated data of the listings.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update our template file. Open the `update-listing.component.html`
    file and add the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we are once again creating a form based on the template-driven
    form approach. You will notice that the edit form is very much similar to the
    create listing form. You are almost correct, but there are some important differences.
    Note that we are now using two-way data binding with `ngModel` and binding the
    value to the form field. With this, when we get the initial data, it''s displayed
    in the form field. Now, the user can edit data and, when clicking on the Update
    Listing button, the data is sent to the `addListing` method and persisted in the
    backend API. Now, let''s see it in action. By running the `ng serve` command,
    we should see the following output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a1dd547e-7a4d-4337-9167-8ff0b66d54ad.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Notice that the URL has the ID of the listing that was passed as the parameter.
    The data is retrieved and has been displayed on the page load. Now, when the user
    updates the details in the form and clicks on the Submit button, this will update
    the data of the listings. That's your homework.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, so we have implemented create, edit, and view functionality. Next,
    we will implement the delete functionality of the listings. Remember that, for
    the delete and edit functionalities, the user will always navigate to the pages
    on click-through anchor tags. Open `DeleteListingComponent` and update the `delete-listing.component.ts`
    file, as shown in the following code block:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let's analyze the preceding code in detail. We are importing the required modules
    in the component file; that is, `ActivatedRoute`, `DbOperationsService`, `Listing`,
    and `Observable`. We are also creating a few variables—`viewList`, `ListId`, and
    `successMsg`. Then, we are injecting the route and service into the constructor
    method. Finally, with the `ngOnInIt` method, we are passing the ID of the listing
    that needs to be deleted. We are subscribing the data and mapping it to `successMsg`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to implement basic CRUD operations for
    our `ListingApp`. Then, we learned how to make HTTP calls for the GET, POST, PUT,
    and DELETE methods. Finally, we learned how to create fake APIs using the JSON
    Server. In the next section, we will learn how to implement CRUD operations using
    the cloud NoSQL Firestore database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Angular HTTP with Google Firebase
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to implement HTTP functionality for a NoSQL
    Firestore database. We created our Firestore database in an earlier section. Now
    is the right time to integrate the Angular HTTP calls, which will invoke and work
    with the Firestore database.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: What are the use cases we will implement? For our `ListingApp`, we will need
    a commenting system. As a user, we should be able to add, edit, delete, and view
    comments. All of these use cases will require us to make HTTP calls to APIs to
    save, retrieve, and delete comments.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Angular Fire is the official library for Firebase. The library provides a lot
    of built-in modules that support activities such as authentication, working with
    Firestore databases, observable-based push notifications, and much more.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to install this module under `@angular/fire`. Run the following
    command in the command-line interface to install the library:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30d643f3-d22c-424b-8b87-083dfdafaa46.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Once we have installed the library, we will proceed and create a new custom
    service for our integration pieces with the Firestore database.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to generate a new service:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run the preceding command successfully, we should see the following
    output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64a22473-60eb-46b9-8af7-75c4fac4adbe.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: You will notice that two files are generated. We will implement all our HTTP
    calls inside the service. As we mentioned previously, we will need to create a
    few components that will map to each piece of functionality and will internally
    call the service that has the HTTP implementations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `ng generate` commands to generate components for the comment''s
    functionality:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we run the preceding commands successfully, we should see the following
    output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07b0c36b-c14c-493d-b2ae-a4fc5e72edac.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: You will notice that the components have been generated and added to our project
    directory. You will also notice that the `app.module.ts` file has been updated
    with entries for the components.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'We have generated our components and the service that''s required for our integration.
    We have also installed the Angular Fire library. In order to use the Angular Fire
    library in our application, we will need to import the library into our `app.module.ts`
    file. Import the required modules into the app module file and list the modules
    in the import list of our application, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One important thing to note in the preceding code is that we are importing
    the required modules from Angular Fire and also listing them under the import
    module list. Notice that we have imported a file called `firebase-config`. These
    are environment variables, which will hold the API keys for authentication with
    Firebase. We can find the API keys listed under the Firebase account, as shown
    in the following screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fe5f267-e6da-4265-8b00-f27ae9974cd0.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'We will need to copy the details into the `firebase-config.ts` file. The following
    screenshot displays the settings specified in our `ListingApp`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56f1af0c-5dc6-47e0-b652-87daf31e2832.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: So far, so good. Now that we have installed the required library, imported the
    modules, and done the configuration settings, it's time to work on our application
    components. We are making great progress here. Let's keep this momentum going.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our components, we will quickly modify our `app-routing.module.ts`
    file and create a new route for each of these components.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We have already mastered Angular routing, in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing.* Revisit that chapter if you need a quick refresher.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have imported all the required component classes
    into the `app-routing.module.ts` file and added the respective routes to the routing
    file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use the four newly created routes to implement the comment''s functionality
    in `ListingApp`. We are going to add the CRUD operations using the Firestore database.
    We will need to import the `AngularFirestore` module to our service, as shown
    here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After we have imported the module into our file, we will need to inject it
    inside the `constructor` method, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now make use of the `AngularFirestore` module and implement CRUD operations
    using Firestore. Take a look at the complete updated code in the `crud-service.service.ts`
    file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's analyze the preceding code in detail. We have imported all the required
    modules, including our Angular Fire module and our `firebase-config` file. Since
    we have imported our `AngularFireStore` module, we will need to inject it into
    our `constructor` method and create an instance of it. We are creating methods
    for each of the actions for the comment's functionality. In the `getComments`
    method, we are retrieving all the data from the *comments *collection. In the `deleteComment`
    method, we are passing the ID of the comment we need to delete. In the `addComment`
    method, we are passing the data that we want to store in our collection. In the
    `updateComment` method, we are passing two parameters; the first is the ID of
    the comment we want to update, and the second is the updated data that we need
    to persist in the database.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why we did not make any HTTP calls in these methods? The `AngularFireStore`
    module internally makes HTTP calls to the service and will authenticate and get
    account-specific information from the firebase config file.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In earlier sections, we learned how to send data from components to the service,
    right? Along the same lines, go ahead and try for comments functionality. That's
    your homework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you feel? You should feel great and you should be proud of yourself!
    This chapter was a lot of work, but we're better off for having done it. It brought
    together all the aspects we have learned so far, such as forms, components, routing,
    services, and more.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: For frontend developers, having a fake API setup in the local development environment
    always helps us to work independently without depending on backend developers
    or APIs. We learned about building fake APIs using the JSON server. We learned
    about the NoSQL document database, particularly the Firestore database provided
    by Google Cloud. We deep dived into Angular HTTP concepts and functionalities.
    We learned how to make HTTP POST, GET, PUT and DELETE calls. We also implemented
    our entire application's functional use cases using both the JSON Server and Firestore
    databases.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We have made tremendous progress so far. We are now capable of developing Angular
    applications end to end, utilizing all the superpowers that Angular provides,
    including forms, components, services, routing, and much more. At the end of this
    chapter, I am confident that we are able to bring together all the pieces of the
    Angular framework into a single working app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Having a working application up and running is a good sign of progress. But
    the important factor in terms of judging the application is to look at the quality
    checks or unit tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to write unit tests to make sure
    we catch any defects early in the product development life cycle. Writing test
    scripts ensures quality and is a great sign of handling all use cases, including
    both the happy and negative paths of our application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
