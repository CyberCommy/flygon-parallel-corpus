- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to Choose Your Data Storage in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure, like other clouds, offers a wide range of storage devices. The simplest
    approach is to define a scalable set of virtual machines hosted in the cloud where
    we can implement our custom solutions. For instance, we can create a SQL Server
    cluster on our cloud-hosted virtual machines to increase reliability and computational
    power. However, usually, custom architectures are not the optimal solution and
    do not take full advantage of the opportunities offered by the cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this chapter will not discuss such custom architectures but will
    focus mainly on the various **Platform as a Service** (**PaaS**) storage offerings
    that are available in the cloud and on Azure. These offerings include scalable
    solutions based on plain disk space, relational databases, NoSQL databases, and
    in-memory data stores such as Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a more adequate storage type is based not only on the application's
    functional requirements but also on performance and scaling-out requirements.
    In fact, while scaling out when processing resources causes a linear increase
    in performance, scaling out storage resources does not necessarily imply an acceptable
    increase in performance. In a few words, no matter how much you duplicate your
    data storage devices, if several requests affect the same chunk of data, they
    will always queue for the same amount of time to access it!
  prefs: []
  type: TYPE_NORMAL
- en: Scaling out data causes linear increases in read operation throughput since
    each copy can serve a different request, but it doesn't imply the same increase
    in throughput for write operations since all copies of the same chunk of data
    must be updated! Accordingly, more sophisticated techniques are required to scale
    out storage devices, and not all storage engines scale equally well.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases do not scale well in all scenarios. Therefore, scaling
    needs and the need to distribute data geographically play a fundamental role in
    the choice of a storage engine, as well as in the choice of a SaaS offering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different repositories for different purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between relational or NoSQL storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – storing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community edition or better, with all the database tools
    components installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* subsection in *Chapter
    1*, *Understanding the Importance of Software Architecture*, explains how to create
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a better development experience, we advise that you also install the local
    emulator of Cosmos DB, which can be found at [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different repositories for different purposes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section describes the functionalities that are offered by the most popular
    data storage techniques. Mainly, we will focus on the functional requirements
    they are able to satisfy. Performance and scaling-out features will be analyzed
    in the next section, which is dedicated to comparing relational and NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: In Azure, the various offerings can be found by typing product names into the
    search bar at the top of all Azure portal pages.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections describe the various kinds of databases that we can
    use in our C# projects.
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relational databases are the most common and studied type of storage. With them,
    society evolves, guaranteeing a high level of service and an uncountable amount
    of stored data. Dozens of applications have been designed to store data in this
    kind of database, and we can find them in banks, stores, industries, and so on.
    When you store data in a relational database, the basic principle is to define
    the entities and properties you will save in each of them, defining the correct
    relationship between these entities.
  prefs: []
  type: TYPE_NORMAL
- en: For decades, relational databases were the only option imagined for designing
    great projects. Many big companies in the world have built their own database
    management system. Oracle, MySQL, and MS SQL Server would be listed by many as
    the ones you can trust to store your data.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, clouds offer several database engines. Azure offers a variety of popular
    database engines, such as Oracle, MySQL, and SQL Server (Azure SQL).
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the Oracle database engine, Azure offers configurable virtual machines
    with various Oracle editions installed on them, which you can easily verify by
    the suggestions you get after typing `Oracle` into the Azure portal search bar.
    Azure fees do not include Oracle licenses; they just include computation time,
    so you must bring your own license to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: With MySQL on Azure, you pay to use a private server instance. The fees you
    incur depend on the number of cores you have, how much memory must be allocated,
    and on backup retention time.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL instances are redundant, and you can choose between local or geographically
    distributed redundancy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Creating a MySQL server on Azure'
  prefs: []
  type: TYPE_NORMAL
- en: Azure SQL is the most flexible offer. Here, you can configure resources that
    are used by every single database. When you create a database, you have the option
    to place it on an existing server instance or create a new instance. There are
    several pricing options that you may choose while defining your solution and Azure
    keeps incrementing them to make sure you will be able to handle your data in the
    cloud. Basically, they vary due to the computing capacity you need.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the **Database Transaction Units** (**DTUs**) model, fees are
    based on the database storage capacity that has been reserved and a linear combination
    of I/O operations, CPU usage, and memory usage that is determined by a reference
    workload. Roughly, maximal database performance increases linearly when you increase
    DTUs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Creating an Azure SQL Database'
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure data replication by enabling read scale-out. This way,
    you can improve the performance of read operations. Backup retention is fixed
    for each offering level (basic, standard, and premium).
  prefs: []
  type: TYPE_NORMAL
- en: If you select **Yes** for **Want to use SQL elastic pool?**, the database will
    be added to an elastic pool. Databases that are added to the same elastic pool
    will share their resources, so resources that are not used by a database can be
    used during the usage CPU peaks of other databases. It is worth mentioning that
    elastic pools can only contain databases hosted on the same server instance. Elastic
    pools are an efficient way to optimize resource usage to reduce costs.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest challenges that relational databases have caused software
    architects is related to how we deal with database structural schema changes.
    The agility of changes needed at the beginning of this century brought the opportunity
    of using a new database style, called NoSQL. There are several types of NoSQL
    database, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Document-Oriented Database**: The most common one, where you have the key
    and complex data called a document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph Database**: Social media tend to use this kind of database since the
    data is stored as graphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key-Value Database**: A useful database for implementing caches since you
    have the opportunity of storing key-value pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wide-Column Store Database**: A database where the same column in each row
    can store different data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In NoSQL databases, relational tables are replaced with more general collections
    that can contain heterogeneous JSON objects. That is, collections have no predefined
    structure and no predefined fields with length constraints (in the case of strings)
    but can contain any type of object. The only structural constraint associated
    with each collection is the name of the property that acts as a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, each collection entry can contain nested objects and object
    collections nested in object properties, that is, related entities that, in relational
    databases, are contained in different tables and connected through external keys.
    In NoSQL, databases can be nested in their father entities. Since collection entries
    contain complex nested objects instead of simple property/value pairs, as is the
    case with relational databases, entries are not called tuples or rows, but *documents*.
  prefs: []
  type: TYPE_NORMAL
- en: No relations and/or external key constraints can be defined between documents
    that belong to the same collection or to different collections. If a document
    contains the primary key of another document in one of its properties, it does
    so at its own risk. The developer has the responsibility of maintaining and keeping
    these coherent references.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since NoSQL storage is quite cheap, whole binary files can be stored
    as the values of document properties as Base64 strings. The developer can define
    rules to decide what properties to index in a collection. Since documents are
    nested objects, properties are tree paths. Usually, by default, all the paths
    are indexed, but you can specify which collection of paths and sub-paths to index.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases are queried either with a subset of SQL or with a JSON-based
    language where queries are JSON objects whose paths represent the properties to
    query, and whose values represent the query constraints that have been applied
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: The possibility of nesting children objects inside documents can be simulated
    in relational databases with the help of one-to-many relationships. However, with
    relational databases, we are forced to redefine the exact structure of all the
    related tables, while NoSQL collections do not impose any predefined structure
    on the objects they contain. The only constraint is that each document must provide
    a unique value for the primary key property. Therefore, NoSQL databases are the
    only option when the structure of our objects is extremely variable.
  prefs: []
  type: TYPE_NORMAL
- en: However, often they are chosen for the way they scale out read and write operations
    and, more generally, for their performance advantages in distributed environments.
    Their performance features will be discussed in the next section, which compares
    them to relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: The graph data model is an extreme case of a completely unstructured document.
    The whole database is a graph where queries can add, change, and delete graph
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have two kinds of document: nodes and relationships. While
    relationships have a well-defined structure (the primary key of the nodes connected
    by the relationship, plus the relationship''s name), nodes have no structure at
    all since properties and their values are added together during node update operations.
    Graph data models were conceived to represent the features of people and the objects
    they manipulate (media, posts, and so on), along with their relationships in *social
    applications*. The Gremlin language was conceived specifically to query graph
    data models. We will not discuss this in this chapter, but references are available
    in the *Further reading* section.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases will be analyzed in detail in the remaining sections of this
    chapter, which are dedicated to describing Azure Cosmos DB and comparing it with relational
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is a distributed concurrent in-memory storage based on key-value pairs
    and supports distributed queuing. It can be used as permanent in-memory storage
    and as a web application cache for database data. Alternatively, it can be used
    as a cache for pre-rendered content.
  prefs: []
  type: TYPE_NORMAL
- en: Redis can also be used to store a web application's user session data. In fact,
    ASP.NET Core supports session data to overcome the fact that the HTTP protocol
    is stateless. More specifically, user data that is kept between page changes is
    maintained in server-side stores such as Redis and indexed by a session key stored
    in cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with the Redis server in the cloud is typically based on a client
    implementation that offers an easy-to-use interface. The client for .NET and .NET
    Core is available through the `StackExchange.Redis` NuGet package. The basic operations
    of the `StackExchange.Redis` client have been documented at [https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics),
    while the full documentation can be found at [https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis).
  prefs: []
  type: TYPE_NORMAL
- en: 'The user interface for defining a Redis server on Azure is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Creating a Redis cache'
  prefs: []
  type: TYPE_NORMAL
- en: The **Pricing tier** dropdown allows us to select one of the available memory/replication
    options. A quick-start guide that explains how to use Azure Redis credentials
    and the URI with the `StackExchange.Redis` .NET Core client can be found at [https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart).
  prefs: []
  type: TYPE_NORMAL
- en: Azure storage accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All clouds offer scalable and redundant general-purpose disk memory that you
    can use as virtual disks in virtual machines and/or as external file storage.
    Azure *storage account* disk space can also be structured in **Tables** and **Queues**.
    Consider using this option if you need cheap blob storage. However, there are
    more sophisticated options, as we have mentioned before. Depending on the scenario
    you have, Azure NoSQL databases are a better option than tables and Azure Redis
    is a better option than Azure storage queues.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Creating a storage account'
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will focus on NoSQL databases and how they differ
    from relational databases. Next, we will look at how to choose one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between structured or NoSQL storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a software architect, you may consider some aspects of structured and NoSQL
    storage to decide the best storage option for you. In many cases, both will be
    needed. The key point here will surely be how organized your data is and how big
    the database will become.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we stated that NoSQL databases should be preferred
    when data has almost no predefined structure. NoSQL databases not only keep variable
    attributes close to their owners, but they also keep some related objects close
    since they allow related objects to be nested inside properties and collections.
  prefs: []
  type: TYPE_NORMAL
- en: Unstructured data can be represented in relational databases since variable
    properties of a tuple, `t`, can be placed in a connected table containing the
    property name, property value, and the external key of `t`. However, the problem
    in this scenario is performance. In fact, property values that belong to a single
    object would be spread all over the available memory space. In a small database,
    *all over the available memory space* means far away but on the same disk; in
    a bigger database, it means far away but in different disk units; in a distributed
    cloud environment, it means far away but in different – and possibly geographically
    distributed – servers.
  prefs: []
  type: TYPE_NORMAL
- en: In NoSQL database design, we always try to put all related objects that are
    likely to be processed together into a single entry. Related objects that are
    accessed less frequently are placed in different entries. Since external key constraints
    are not enforced automatically and NoSQL transactions are very flexible, the developer
    can choose the best compromise between performance and coherence.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can conclude that relational databases perform well when tables
    that are usually accessed together can be stored close together. NoSQL databases,
    on the other hand, automatically ensure that related data is kept close together
    since each entry keeps most of the data it is related to inside it as nested objects.
    Therefore, NoSQL databases perform better when they are distributed to a different
    memory and to different geographically distributed servers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the only way to scale out storage write operations is to split
    collection entries across several servers according to the values of *shard keys*.
    For instance, we can place all the records containing usernames that start with
    **A** on a server, the records containing usernames that start with **B** on another
    server, and so on. This way, write operations for usernames with different start
    letters may be executed in parallel, ensuring that the write throughput increases
    linearly with the number of servers.
  prefs: []
  type: TYPE_NORMAL
- en: However, if a *shard* collection is related to several other collections, there
    is no guarantee that related records will be placed on the same server. Also,
    putting different collections on different servers without using collection sharding
    increases write throughput linearly until we reach the limit of a single collection
    per server, but it doesn't solve the issue of being forced to perform several
    operations on different servers to retrieve or update data that's usually processed
    together.
  prefs: []
  type: TYPE_NORMAL
- en: This issue becomes catastrophic for performance in relational databases if access
    to related distributed objects must be transactional and/or must ensure structural
    constraints (such as external key constraints) are not violated. In this case,
    all related objects must be blocked during the transaction, preventing other requests
    from accessing them during the whole lifetime of a time-consuming distributed
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases do not suffer from this problem and perform better with sharding
    and consequently with write-scaled output. This is because they do not distribute
    related data to different storage units and instead store them as nested objects
    of the same database entry. On the other hand, they suffer from different problems,
    like not supporting transactions by default.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that there are situations where relational databases
    perform well with sharding. A typical instance is a multi-tenant application.
    In a multi-tenant application, all entries collections can be partitioned into
    non-overlapping sets called **tenants**. Only entries belonging to the same tenant
    can refer to each other, so if all the collections are sharded in the same way
    according to their object tenants, all related records end up in the same shard,
    that is, in the same server, and can be navigated efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-tenant applications are not rare in the cloud since all applications that
    offer the same services to several different users are often implemented as multi-tenant
    applications, where each tenant corresponds to a user subscription. Accordingly,
    relational databases are conceived to work in the cloud, such as Azure SQL Server,
    and usually offer sharding options for multi-tenant applications. Typically, sharding
    is not a cloud service and must be defined with database engine commands. Here,
    we will not describe how to define shards with Azure SQL Server, but the *Further
    reading* section contains a link to the official Microsoft documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, relational databases offer a pure, logical view of data that
    is independent of the way they are actually stored and use a declarative language
    to query and update them. This simplifies development and system maintenance,
    but it may cause performance issues in a distributed environment that requires
    write scale-out. In NoSQL databases, you must handle more details about how to
    store data, as well as some procedural details for all the update and query operations,
    manually, but this allows you to optimize performance in distributed environments
    that require both read and write scale-out.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at Azure Cosmos DB, the main Azure NoSQL offering.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Cosmos DB is Azure's main NoSQL offering. Azure Cosmos DB has its own
    interface that is a subset of SQL, but it can be configured with a MongoDB interface.
    It can also be configured as a graph data model that can be queried with Gremlin.
    Cosmos DB allows replication for fault tolerance and read scale-out, and replicas
    can be distributed geographically to optimize communication performance. Moreover,
    you can specify which data center all the replicas are placed in. The user also
    has the option to write-enable all the replicas so that writes are immediately
    available in the geographical area where they are done. Write scale-up is achieved
    with sharding, which the user can configure by defining which properties to use
    as shard keys.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos DB account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define a Cosmos DB account by typing `Cosmos DB` into the Azure portal
    search bar and clicking **Add**. The following page will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Creating an Azure Cosmos DB account'
  prefs: []
  type: TYPE_NORMAL
- en: The account name you choose is used in the resource URI as `{account_name}.documents.azure.com`.
    The **API** dropdown lets you choose the kind of interface you prefer (for example,
    SQL, MongoDB, or Gremlin). Then, you can decide which data center the main database
    will be placed in and whether you want to enable geographically distributed replication.
    Once you have enabled geographically distributed replication, you can choose the
    number of replicas you want to use and where to place them.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has been improving many of its Azure services. By the time this book
    was written, the Serverless option for capacity mode and Notebooks were in Preview.
    The best way to keep updated about new features of any Azure Component is by checking
    its documentation from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: The **Multi-region Writes** toggle lets you enable writes on geographically
    distributed replicas. If you do not do this, all write operations will be routed
    to the main data center. Finally, you may also define backup policies and encryption
    during the creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have created your account, select **Data Explorer** to create your
    databases and containers inside of them. A container is the unit of scalability
    both for provisioned throughput and storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since databases just have a name and no configuration, you can directly add
    a container and then the database where you wish to place it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Adding a container in Azure Cosmos DB'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can decide on database and container names and the property to use
    for sharding (the partition key). Since NoSQL entries are object trees, property
    names are specified as paths. You can also add properties whose values are required
    to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: However, uniqueness IDs are checked inside each shard, so this option is only
    useful in certain situations, such as multi-tenant applications (where each tenant
    is included in a single shard). The fees depend on the collection throughput that
    you choose.
  prefs: []
  type: TYPE_NORMAL
- en: This is where you need to target all resource parameters to your needs. Throughput
    is expressed in request units per second, where request units per second is defined
    as the throughput we have when performing a read of 1 KB per second. Hence, if
    you check the *Provision database throughput* option, the chosen throughput is
    shared with the whole database, instead of being reserved as a single collection.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Azure Cosmos data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the Azure Cosmos container, you will be able to access data.
    To get connection information, you can select the **Keys** menu. There, you will
    see all the information you need to connect with your Cosmos DB account from your
    application. **The connection information page** will provide you with the account
    URI and two connection keys, which can be used interchangeably to connect with
    the account.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Connection information page'
  prefs: []
  type: TYPE_NORMAL
- en: There are also keys with read-only privileges. Every key can be regenerated,
    and each account has two equivalent keys, like many other Azure Components. This
    approach enables operations to be handled efficiently; that is, when a key is
    changed, the other one is kept. Therefore, existing applications can continue
    using the other key before upgrading to the new key.
  prefs: []
  type: TYPE_NORMAL
- en: Defining database consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering that you are in the context of a distributed database, Azure Cosmos
    DB enables you to define the default read consistency level you will have. By
    selecting **Default consistency** in the main menu of your Cosmos DB account,
    you can choose the default replication consistency that you wish to apply to all
    your containers.
  prefs: []
  type: TYPE_NORMAL
- en: This default can be overridden in each container, either from Data Explorer
    or programmatically. Consistency problems in read/write operations are a consequence
    of data replication. More specifically, the results of various read operations
    may be incoherent if the read operations are executed on different replicas that
    have received different partial updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the available consistency levels. These have been ordered
    from the weakest to the strongest:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eventual**: After enough time has passed, if no further write operations
    are done, all the reads converge and apply all the writes. The order of writes
    is also not guaranteed, so while writes are being processed, you could also end
    up reading an earlier version than the one you have previously read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent Prefix**: All the writes are executed in the same order on all
    the replicas. So, if there are `n` write operations, each read is consistent with
    the result of applying the first `m` writes for some `m` less or equal to `n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session**: This is the same as the consistency prefix but also guarantees
    that each writer sees the result of its own writes in all subsequent read operations
    and that subsequent reads of each reader are coherent (either the same database
    or a more updated version of it).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bounded Staleness**: This is associated either with a delay time, `Delta`,
    or with several operations, `N`. Each read sees the results of all the write operations
    that were performed before a time `Delta` (or before the last `N` operations).
    That is, its reads converge with the result of all the writes with a maximum time
    delay of `Delta` (or a maximum operations delay of `N`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong**: This is bounded staleness combined with `Delta = 0`. Here, each
    read reflects the result of all previous write operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strongest consistency can be obtained to the detriment of performance. By
    default, the consistency is set to **Session**, which is a good compromise between
    coherence and performance. A lower level of consistency is difficult to handle
    in applications and is only usually acceptable if sessions are either read-only
    or write-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the **Settings** option in the **Data Explorer** menu of the
    container of your database, you can configure which paths to index and which kind
    of indexing to apply to each data type of each path. The configuration consists
    of a JSON object. Let us analyze its various properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you set `indexingMode` to `none` instead of `consistent`, no index is generated,
    and the collection can be used as a key-value dictionary that is indexed by the
    collection primary key. In this scenario, no **secondary** indexes are generated,
    so the primary key could not efficiently be searched on. When `automatic` is set
    to `true`, all document properties are automatically indexed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the `IncludedPaths` specifies a path pattern such as `/subpath1/subpath2/?`
    (settings apply just to the `/subpath1/subpath2/property`) or `/subpath1/subpath2/*`
    (settings apply to all the paths starting with `/subpath1/subpath2/`).
  prefs: []
  type: TYPE_NORMAL
- en: Patterns contain the `[]` symbol when settings must be applied to child objects
    contained in collection properties; for example, `/subpath1/subpath2/[]/?`, `/subpath1/subpath2/[]/childpath1/?`,
    and so on. Settings specify the index type to apply to each data type (string,
    number, geographic point, and so on). Range indexes are needed for comparison
    operations, while hash indices are more efficient if we need equality comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to specify a precision, that is, the maximum number of characters
    or digits to use in all the index keys. `-1` means the maximum precision and is
    always recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Paths contained in `excludedPaths` are not indexed at all. Index settings can
    also be specified programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you have two options to connect to Cosmos DB: use a version of its official
    client for your preferred programming language or use Cosmos DB''s Entity Framework
    Core provider. In the following subsections, we will have a look at both options.
    Then, we will describe how to use Cosmos DB''s Entity Framework Core provider
    with a practical example.'
  prefs: []
  type: TYPE_NORMAL
- en: The Cosmos DB client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cosmos DB client for .NET 5 is available through the `Microsoft.Azure.Cosmos`
    NuGet package. It offers full control of all Cosmos DB features, while the Cosmos
    DB Entity Framework provider is easier to use but hides some Cosmos DB peculiarities.
    Follow these steps to interact with Cosmos DB through the official Cosmos DB client
    for .NET 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample shows the creation of a database and a container
    using the client component. Any operation requires the creation of a client object.
    Do not forget that the client must be disposed of by calling its `Dispose` method
    (or by enclosing the code that references it in a `using` statement) when you
    do not need it anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: During collection creation, you can pass a `ContainerProperties` object, where
    you can specify the consistency level, how to index properties, and all the other
    collection features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you must define the .NET classes that correspond to the structure of
    the JSON document you need to manipulate in your collections. You can also use
    the `JsonProperty` attribute to map class property names to JSON names if they
    are not equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have all the necessary classes, you can use client methods to `ReadItemAsync`,
    `CreateItemAsync`, and `DeleteItemAsync`. You can also query data using a `QueryDefinition`
    object that accepts SQL commands. You can find a complete introduction to this
    library at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started).
  prefs: []
  type: TYPE_NORMAL
- en: The Cosmos DB Entity Framework Core provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Cosmos DB provider for Entity Framework Core is contained in the `Microsoft.EntityFrameworkCore.Cosmos`
    NuGet package. Once you''ve added this to your project, you can proceed in a similar
    way to when you used the SQL Server provider in *Chapter 8*, *Interacting with
    Data in C# – Entity Framework Core*, but with a few differences. Let us look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no migrations since Cosmos DB databases have no structure to update.
    Instead, they have a method that ensures that the database, along with all the
    necessary collections, is created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the `DbSet<T>` properties from `DBContext` are mapped to a unique
    container since this is the cheapest option. You can override this default by
    explicitly specifying which container you want to map some entities to by using
    the following configuration instruction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only useful annotation on entity classes is the `Key` attribute, which becomes
    obligatory when the principal keys are not called `Id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principal keys must be strings and cannot be auto-incremented to avoid synchronization
    issues in a distributed environment. The uniqueness of primary keys can be ensured
    by generating GUIDs and transforming them into strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When defining relationships between entities, you can specify that an entity
    or a collection of entities is owned by another entity, in which case it is stored
    together with the father entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at the usage of Cosmos DB's Entity Framework provider in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – storing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to use NoSQL, we must decide whether NoSQL databases
    are adequate for our book use case WWTravelClub application. We need to store
    the following families of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information about available destinations and packages**: Relevant operations
    for this data are reads since packages and destinations do not change very often.
    However, they must be accessed as fast as possible from all over the world to
    ensure a pleasant user experience when users browse the available options. Therefore,
    a distributed relational database with geographically distributed replicas is
    possible, but not necessary since packages can be stored inside their destinations
    in a cheaper NoSQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination reviews**: In this case, distributed write operations have a
    non-negligible impact. Moreover, most writes are additions since reviews are not
    usually updated. Additions benefit a lot from sharding and do not cause consistency
    issues like updates do. Accordingly, the best option for this data is a NoSQL
    collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reservations**: In this case, consistency errors are not acceptable because
    they may cause overbooking. Reads and writes have a comparable impact, but we
    need reliable transactions and good consistency checks. Luckily, data can be organized
    in a multi-tenant database where tenants are destinations since reservation information
    belonging to different destinations is completely unrelated. Accordingly, we may
    use sharded SQL Azure database instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, the best option for data in the first and second bullet points
    is Cosmos DB, while the best option for the third point is Azure SQL Server. Actual
    applications may require a more detailed analysis of all data operations and their
    frequencies. In some cases, it is worth implementing prototypes for various possible
    options and executing performance tests with typical workloads on all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this section, we will migrate the destinations/packages
    data layer we looked at in *Chapter 8*, *Interacting with Data in C# – Entity
    Framework Core*, to Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the destinations/packages database with Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s move on to the database example we built in *Chapter 8*, *Interacting
    with Data in C# – Entity Framework Core*, to Cosmos DB by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to make a copy of the WWTravelClubDB project and make `WWTravelClubDBCosmo`
    the new root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project and delete the migrations folder since migrations are not required
    anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to replace the SQL Server Entity Framework provider with the Cosmos
    DB provider. To do this, go to **Manage NuGet Packages** and uninstall the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. Then, install the `Microsoft.EntityFrameworkCore.Cosmos` NuGet
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, do the following on the `Destination` and `Package` entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all data annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `[Key]` attribute to their `Id` properties since this is obligatory
    for Cosmos DB providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform the type of the `Id` properties of both `Package` and `Destination`,
    and the `PackagesListDTO` classes from `int` to `string`. We also need to turn
    the `DestinationId` external references in `Package` and in the `PackagesListDTO`
    classes into `string`. In fact, the best option for keys in distributed databases
    is a string generated from a GUID, because it is hard to maintain an identity
    counter when table data is distributed among several servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `MainDBContext` file, we need to specify that packages related to a
    destination must be stored inside the destination document itself. This can be
    achieved by replacing the Destination-Package relation configuration in the `OnModelCreatingmethod`
    method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we must replace `HasMany` with `OwnsMany`. There is no equivalent to `WithOne`
    since once an entity is owned, it must have just one owner, and the fact that
    the `MyDestination` property contains a pointer to the father entity is evident
    from its type. Cosmos DB also allows the use of `HasMany`, but in this case, the
    two entities are not nested one in the other. There is also an `OwnOne` configuration
    method for nesting single entities inside other entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actually, both `OwnsMany` and `OwnsOne` are available for relational databases,
    but in this case, the difference between `HasMany` and `HasOne` is that children
    entities are automatically included in all queries that return their father entities,
    with no need to specify an `Include` LINQ clause. However, child entities are
    still stored in separate tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LibraryDesignTimeDbContextFactory` must be modified to use Cosmos DB connection
    data, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our test console, we must explicitly create all entity principal
    keys using GUIDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call `context.Database.EnsureCreated()` instead of applying migrations
    since we only need to create the database. Once the database and collections have
    been created, we can fine-tune their settings from the Azure portal. Hopefully,
    future versions of the Cosmos DB Entity Framework Core provider will allow us
    to specify all collection options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the final query, which starts with `context.Packages.Where...` must
    be modified since queries can''t start with entities that are nested in other
    documents (in our case, `Packages` entities). Therefore, we must start our query
    from the unique root `DbSet<T>` property we have in our `DBContext`, that is,
    `Destinations`. We can move from listing the external collection to listing all
    the internal collections with the help of the `SelectMany` method, which performs
    a logical merge of all nested `Packages` collections. However, since `CosmosDB`
    SQL doesn''t support `SelectMany`, we must force `SelectMany` to be simulated
    on the client with `AsEnumerable()`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of the query remains unchanged. If you run the project now, you
    should see the same outputs that were received in the case of SQL Server (except
    for the primary key values).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the program, go to your Cosmos DB account. You should see something
    like the following:![](img/B16756_09_08.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.8: Execution results'
  prefs: []
  type: TYPE_NORMAL
- en: The packages have been nested inside their destinations as required and Entity
    Framework Core creates a unique collection that has the same name as the `DBContext`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to continue experimenting with Cosmos DB development without
    wasting all your free Azure portal credit, you can install the Cosmos DB emulator
    available at this link: [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the main storage options available in Azure and
    learned when to use them. Then, we compared relational and NoSQL databases. We
    pointed out that relational databases offer automatic consistency checking and
    transaction isolation, but NoSQL databases are cheaper and offer better performance,
    especially when distributed writes form a high percentage of the average workload.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we described Azure's main NoSQL option, Cosmos DB, and explained how to
    configure it and how to connect with a client.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to interact with Cosmos DB with Entity Framework Core
    and looked at a practical example based on the WWTravelClubDB use case. Here,
    we learned how to decide between relational and NoSQL databases for all families
    of data involved in an application. This way, you can choose the kind of data
    storage that ensures the best compromise between data coherence, speed, and parallel
    access to data in each of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn all about Serverless and Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is Redis a valid alternative to relational databases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are NoSQL databases a valid alternative to relational databases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What operation is more difficult to scale out in relational databases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main weakness of NoSQL databases? What is their main advantage?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you list all Cosmos DB consistency levels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use auto-increment integer keys with Cosmos DB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Entity Framework configuration method is used to store an entity inside
    its related father document?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can nested collections be searched efficiently with Cosmos DB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we did not talk about how to define sharding with Azure SQL.
    Here is the link to the official documentation if you want to find out more: [https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cosmos DB was described in detail in this chapter, but further details can
    be found in the official documentation: [https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a reference to the Gremlin language, which is supported by
    Cosmos DB: [http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a general description of the Cosmos DB Graph Data Model: [https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on how to use Cosmos DB's official .NET client can be found at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started).
    A good introduction to the `MvcControlsToolkit.Business.DocumentDB` NuGet package
    we mentioned in this chapter is the *Fast Azure Cosmos DB Development with the
    DocumentDB Package* article contained in Issue 34 of DNCMagazine. This can be
    downloaded from [https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb](https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
