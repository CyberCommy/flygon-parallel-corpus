- en: Creating an Augmented-Reality Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建增强现实游戏
- en: In this chapter, we will be exploring **augmented reality** (**AR**) using Xamarin.Forms.
    We will be using custom renderers to inject platform-specific code, **UrhoSharp** to
    render the scene and handle input, and `MessagingCenter` to pass internal messages
    around in the app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Xamarin.Forms探索**增强现实**（**AR**）。我们将使用自定义渲染器注入特定于平台的代码，使用**UrhoSharp**来渲染场景和处理输入，并使用`MessagingCenter`在应用程序中传递内部消息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up a project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Using ARKit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARKit
- en: Using ARCore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ARCore
- en: Learning how to use UrhoSharp to render graphics and handle input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用UrhoSharp来渲染图形和处理输入
- en: Using custom renderers to inject platform-specific code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义渲染器注入特定于平台的代码
- en: Using `MessagingCenter` to send messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MessagingCenter`发送消息
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, we need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*, for more details on how to set up your environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成这个项目，我们需要安装Visual Studio for Mac或PC，以及Xamarin组件。有关如何设置您的环境的更多详细信息，请参见[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)，*Xamarin简介*。
- en: 'You cannot run AR on an emulator. To run AR, you need a physical device, along
    with the following software:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在模拟器上运行AR。要运行AR，您需要一个物理设备，以及以下软件：
- en: On iOS, you need iOS 11 or higher and a device that has an A9 processor or above
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上，您需要iOS 11或更高版本，以及一个A9处理器或更高版本的设备
- en: On Android, you need Android 8.1 and a device that supports ARCore
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上，您需要Android 8.1和支持ARCore的设备
- en: Essential theory
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本理论
- en: This section will describe how AR works. The implementation differs slightly
    between platforms. Google's implementation is called **ARCore,** and Apple's implementation
    is called **ARKit**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述AR的工作原理。实现在不同平台之间略有不同。谷歌的实现称为**ARCore**，苹果的实现称为**ARKit**。
- en: AR is all about superimposing computer graphics on top of a camera feed. This
    sounds like a simple thing to do, except that you have to track the camera position
    with great accuracy. Both Google and Apple have written some great APIs to do
    this magic for you, with the help of the motion sensors in your phone and data
    from the camera. The computer graphics that we add on top of the camera feed are
    synced to be in the same coordinate space as the surrounding real-life objects,
    making them appear as if they are part of the image you see on your phone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: AR的全部内容都是关于在相机反馈的基础上叠加计算机图形。这听起来是一件简单的事情，除了您必须以极高的精度跟踪相机位置。谷歌和苹果都编写了一些很棒的API来为您完成这个魔术，借助手机的运动传感器和相机数据。我们添加到相机反馈上的计算机图形与周围真实物体的坐标空间同步，使它们看起来就像是图像上看到的一部分。
- en: An overview of the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we are going to create a game that explores the fundamentals
    of AR. We are also going to learn how to integrate AR control in Xamarin.Forms.
    Android and iOS implement AR differently, so we will need to unify the platforms
    along the way. We will do this using UrhoSharp, an open source 3D game engine,
    which will do the rendering for us. This is simply made up of bindings to the **Urho3D** engine,
    which allows us to use Urho3D with .NET and C#.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个探索AR基础知识的游戏。我们还将学习如何在Xamarin.Forms中集成AR控制。Android和iOS以不同的方式实现AR，因此我们需要在途中统一平台。我们将使用UrhoSharp，一个开源的3D游戏引擎，来进行渲染。这只是使用.NET和C#与Urho3D绑定的**Urho3D**引擎。
- en: The game will render boxes in AR that the user needs to tap to make disappear.
    You can then extend the game yourself by learning about the Urho3D engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将在AR中渲染盒子，用户需要点击以使其消失。然后，您可以通过学习Urho3D引擎来扩展游戏。
- en: The shared code will be placed in a shared project. This is different than the
    usual .NET Standard library approach we have taken so far. The reason for this
    is that UrhoSharp doesn't support .NET Standard (at the time of writing this book).
    It's also a good idea to learn how to create a shared project. The code in a shared
    library will not compile by itself. It needs to be linked to a platform project
    (such as iOS or Android) and then the compiler can compile all the source files
    along with the platform project. This is exactly the same thing as copying the
    files directly into that project. So, by defining a shared project, we don't need
    to write code twice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 共享代码将放置在一个共享项目中。这与我们迄今为止采取的通常的.NET标准库方法不同。这样做的原因是，UrhoSharp在撰写本书时不支持.NET标准。学习如何创建共享项目也是一个好主意。共享库中的代码本身不会编译。它需要链接到平台项目（如iOS或Android），然后编译器可以编译所有源文件以及平台项目。这与直接将文件复制到该项目中完全相同。因此，通过定义一个共享项目，我们不需要重复编写代码。
- en: 'This strategy also unlocks another powerful feature: **conditional compilation.**
    Consider the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略还解锁了另一个强大的功能：**条件编译**。考虑以下示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code shows how you can insert platform-specific code inside a
    shared code file. This will come in very handy in this project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了如何在共享代码文件中插入特定于平台的代码。这在这个项目中将非常有用。
- en: The estimated build time for this project is 90 minutes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的预计构建时间为90分钟。
- en: Beginning the project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: It's time to start coding! First, however, make sure you have your development
    environment set up as described in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始编码了！但首先，请确保您已经按照[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)中描述的设置好了开发环境，*Xamarin简介*。
- en: This chapter will be a classic File | New Project chapter, guiding you step-by-step
    through the process of creating the app. There will be no downloads required whatsoever.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个经典的*文件|新建项目*章节，将逐步指导您完成创建应用程序的过程。完全不需要下载。
- en: Creating the project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Open Visual Studio and click on File | New | Project, as shown in the following
    screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio，然后点击“文件”|“新建”|“项目”，如下截图所示：
- en: '![](img/6fca819a-f5c0-424e-a0b6-26d2133d2da9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fca819a-f5c0-424e-a0b6-26d2133d2da9.png)'
- en: 'This will open the New Project dialog. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item in the list. Complete
    the form by naming your project. We will be calling our application `WhackABox`
    in this example. Move on to the next dialog box by clicking OK, as shown in the
    following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开“新建项目”对话框。展开“Visual C#”节点，然后单击“跨平台”。在列表中选择“移动应用程序（Xamarin.Forms）”项目。通过为您的项目命名来完成表单。在本示例中，我们将称我们的应用程序为“WhackABox”。点击“确定”继续到下一个对话框，如下截图所示：
- en: '![](img/e3f05ec6-796d-4724-b354-c25d2171e43c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3f05ec6-796d-4724-b354-c25d2171e43c.png)'
- en: 'The next step is to select a project template and a Code Sharing Strategy.
    Select the Blank template option to create a bare minimum Xamarin.Forms app and
    make sure that the Code Sharing Strategy is set to Shared Project. Uncheck the Windows
    (UWP) checkbox under the Platform heading, since this app will only be supporting
    **iOS** and Android. Finish the setup wizard by clicking OK and let Visual Studio
    scaffold the project for you. This might take a couple of minutes. Please note
    that we will be using a Shared Project for this chapter—this is very important!
    You can see the aforementioned fields and options that you need to select in the
    following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择项目模板和代码共享策略。选择“空白模板”选项以创建最基本的Xamarin.Forms应用程序，并确保代码共享策略设置为“共享项目”。在“平台”标题下取消选中“Windows（UWP）”复选框，因为此应用程序只支持**iOS**和Android。点击“确定”完成设置向导，让Visual
    Studio为您创建项目。这可能需要几分钟。请注意，本章我们将使用共享项目——这一点非常重要！您可以在以下截图中看到需要选择的字段和选项：
- en: '![](img/78e4bcf2-f5d5-49a6-a4c1-e3dbefafd2df.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78e4bcf2-f5d5-49a6-a4c1-e3dbefafd2df.png)'
- en: Just like that, the app has been created. Let's move on to updating Xamarin.Forms
    to the latest version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，应用程序已经创建好了。让我们继续更新Xamarin.Forms到最新版本。
- en: Updating the Xamarin.Forms NuGet packages
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Xamarin.Forms NuGet包
- en: 'Currently, the Xamarin.Forms version that your project has been created with
    is most likely a bit old. To rectify this, we need to update the NuGet packages.
    Please note that you should only update the Xamarin.Forms packages and not the
    Android packages; updating the Android packages might cause your packages to get
    out of sync with each other, resulting in the app not building at all. To update
    the NuGet packages, go through the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的项目创建时使用的Xamarin.Forms版本很可能有点过时。为了纠正这一点，我们需要更新NuGet包。请注意，您应该只更新Xamarin.Forms包，而不是Android包；更新Android包可能导致包不同步，导致应用程序根本无法构建。要更新NuGet包，请按以下步骤操作：
- en: Right-click on our Solution in the Solution Explorer.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中右键单击我们的解决方案。
- en: 'Click Manage NuGet Packages for Solution..., as shown in the following screenshot:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理解决方案的NuGet包...”，如下截图所示：
- en: '![](img/542a5038-c9cb-4647-b14f-c940a60a2f88.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/542a5038-c9cb-4647-b14f-c940a60a2f88.png)'
- en: 'This will open the NuGet Package Manager in Visual Studio, as shown in the
    following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Visual Studio中打开NuGet包管理器，如下截图所示：
- en: '![](img/3a9e444d-fd64-499a-bcc6-afb117c82756.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a9e444d-fd64-499a-bcc6-afb117c82756.png)'
- en: 'To update Xamarin.Forms to the latest version, go through the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Xamarin.Forms更新到最新版本，请按以下步骤操作：
- en: Click the Updates tab.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“更新”选项卡。
- en: Check the Xamarin.Forms checkbox and click Update.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“Xamarin.Forms”复选框，然后点击“更新”。
- en: Accept any license agreements.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受任何许可协议。
- en: The update takes at most a few minutes. Look at the output pane to find information
    about the update. At this point, we can run the app to make sure it works. We
    should see the text Welcome to Xamarin.Forms! in the middle of the screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更新最多需要几分钟。查看输出窗格以获取有关更新的信息。此时，我们可以运行应用程序以确保其正常工作。我们应该在屏幕中央看到“欢迎使用Xamarin.Forms！”的文本。
- en: Setting the Android target to 8.1
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Android目标设置为8.1
- en: 'ARCore is available from Android version 8.1 and later. We will, therefore,
    verify the Target Framework for the Android project by going through the following
    steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ARCore可用于Android 8.1及更高版本。因此，我们将通过以下步骤验证Android项目的目标框架：
- en: Double-click on the Properties node under the Android project in the Solution
    Explorer.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中的Android项目下双击“属性”节点。
- en: 'Verify that the Target Framework version is at least Android 8.0 (Oreo), as
    shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证目标框架版本至少为Android 8.0（Oreo），如下截图所示：
- en: '![](img/09fe6cca-4790-4b04-8d7e-d6b20d0c4706.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09fe6cca-4790-4b04-8d7e-d6b20d0c4706.png)'
- en: 'If it''s not at least Android 8.0 (Oreo), you will need to select Android 8.1 (or
    above). If there is an asterisk next to the Target Framework name, then you will
    need to install that SDK by going through the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标框架不是至少Android 8.0（Oreo），则需要选择Android 8.1（或更高版本）。如果目标框架名称旁边有一个星号，则需要通过以下步骤安装该SDK：
- en: Locate the Android SDK Manager in the toolbar.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中找到Android SDK Manager。
- en: 'Click the highlighted button to open the SDK Manager, as shown in the following
    screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击突出显示的按钮打开SDK Manager，如下截图所示：
- en: '![](img/5c98de95-7c5c-4683-8f35-e1186ecf9de8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c98de95-7c5c-4683-8f35-e1186ecf9de8.png)'
- en: 'This is the control center for all SDK versions of Android that are installed
    on the system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统上安装的所有Android SDK版本的控制中心：
- en: Expand the SDK version you want to install. In our case, this should be at least
    Android 8.1 - Oreo.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开您想要安装的SDK版本。在我们的情况下，这应该至少是Android 8.1 - Oreo。
- en: Select the Android SDK Platform <version number> node. You can also to install emulator
    images that will be used by the emulator to run the selected version of Android.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Android SDK平台<版本号>节点。您还可以安装模拟器映像，供模拟器运行所选版本的Android。
- en: 'Click Apply Changes, as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用更改”，如下截图所示：
- en: '![](img/17c557be-4452-4ce7-83c0-23a5e57fd5ab.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17c557be-4452-4ce7-83c0-23a5e57fd5ab.png)'
- en: Adding the camera permission to Android
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Android添加相机权限
- en: 'In order to get access to the camera in Android we must add a required permission
    in the Android manifest. This can be done by following these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Open up the Android project node in the Solution Explorer.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the Properties node to open the properties for Android.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Android Manifest tab on the left and scroll down until you see the
    Required permissions section.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the CAMERA permission and check the box.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file by clicking *Ctrl* +* S* or File and the Save.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5be70e8f-186b-4838-8e0c-a49cd316f4a7.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Now that we have configured Android, we only have one small change to make on
    iOS before we are ready to write some code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Adding Camera Usage Description for iOS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS, you need to specify why you need access to the camera. The way to do
    this is to add an entry to the `info.plist` file in the root folder of the iOS
    project. The `info.plist` file is an XML file that you can edit in any text editor.
    A simpler way to this, however, is by using the Generic PList Editor provided
    by Visual Studio.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required Camera Usage Description using the Generic PList Editor, as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `WhackABox.iOS` project.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on `info.plist` and click Open With..., as shown in the following
    screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f854d634-aaab-4c4c-bdcb-6b714cb06938.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Select Generic PList Editor and click OK, as shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98665692-d865-434f-9658-4389050799c0.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Locate the plus (+) icon at the bottom of the property list.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the plus (+) icon to add a new key. Make sure that the key is in the
    root of the document and not under another property, as shown in the following
    screenshot:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abd89c94-b4d9-419f-af0e-8f374d027598.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'The Generic PList Editor helps you to find the right property by giving it
    a more user-friendly name. Let''s add the value we need to describe why we want
    to use the camera:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Open the drop-down menu on the newly created row.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Privacy - Camera Usage Description.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a good reason in the values field to the right, as shown in the following
    screenshot. The field for the reason is a free-text field, so use plain English
    to describe why your app needs access to the camera:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/14005e35-6acb-427d-be52-79da6f75f4e3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: That's it. The setup of both Android and iOS is complete, and we can now focus
    on the fun part—writing code!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: You can also open the `Info.plist` file in any text editor, since it's an XML
    file. The key's name is
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`NSCameraUsageDescription`, and it must be added as a direct child of the root
    node.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user interface
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start off by defining the user interface that will wrap the
    AR components. First, we will define a custom control that we will use as a placeholder
    for injecting an `UrhoSurface` that will contain the AR components. Then, we will
    add this control in a grid that will contain some statistics about how many planes
    we have found and how many boxes are active in the world. The goal of the game
    is to find boxes in AR using your phone and tapping on them to make them disappear.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining the custom `ARView` control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ARView control
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ARView` control belongs in the shared project, since it will be a part
    of both applications. It's a standard Xamarin.Forms control that inherits directly
    from `Xamarin.Forms.View`. It will not load any XAML (so it will simply be a single
    class), nor will it contain any functionality other than simply being defined,
    so we can add it to the main grid.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Go over to Visual Studio and go through the following three steps to create
    an `ARView` control:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a folder called `Controls`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `ARView` in the `Controls` folder.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `ARView` class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What we have created here is a simple class, without implementation, that inherits
    from `Xamarin.Forms.View`. The point of this is to make use of custom renderers
    for each platform, allowing us to specify platform-specific code to be inserted
    at the place in the XAML where we put this control. Your project should now look
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个简单的类，没有实现，它继承自`Xamarin.Forms.View`。这样做的目的是利用每个平台的自定义渲染器，允许我们指定特定于平台的代码插入到我们放置这个控件的XAML中。您的项目现在应该如下所示：
- en: '![](img/3dc949c2-7455-4476-b9c9-3b7018741a3b.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dc949c2-7455-4476-b9c9-3b7018741a3b.png)'
- en: The `ARView` control is no good just sitting there. We need to add it to the
    `MainPage`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARView`控件就那样坐在那里是不行的。我们需要将它添加到`MainPage`中。'
- en: Modifying the MainPage
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改MainPage
- en: 'We will be replacing the entire contents of the `MainPage` and adding a reference
    to the `WhackABox.Controls` namespace so that we can use the `ARView` control.
    Let''s set this up by going through the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换`MainPage`的全部内容，并添加对`WhackABox.Controls`命名空间的引用，以便我们可以使用`ARView`控件。让我们通过以下步骤来设置这个：
- en: In the `WhackABox` project, open the `MainPage.xaml` file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`MainPage.xaml`文件。
- en: 'Edit the XAML to look like the following code. The XAML in bold represents
    the new elements that must be added:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑XAML以使其看起来像以下代码。粗体的XAML表示必须添加的新元素：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Now that we have the code, let''s go through it step by step:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了代码，让我们一步一步地来看：
- en: First, we define a controls namespace that points to the `WhackABox.Controls`
    namespace in code. This namespace is used at the end of the XAML to locate the
    `ARView` control.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个控件命名空间，指向代码中的`WhackABox.Controls`命名空间。这个命名空间用于在XAML末尾定位`ARView`控件。
- en: We then define the content element by setting it to a `Grid`. A page can only
    have one child, which, in this case, is a `Grid`. The `Grid` defines two columns
    and two rows. The columns split the `Grid` into two equal parts, where we have
    one row that is `100` units high at the top and one row that takes up all the
    available space below it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过将其设置为`Grid`来定义内容元素。一个页面只能有一个子元素，在这种情况下是一个`Grid`。`Grid`定义了两列和两行。列将`Grid`分成两个相等的部分，其中有一行在顶部高度为`100`个单位，另一行占据了下面所有可用的空间。
- en: We use the top two cells to add instances of `StackLayout` that contain the
    information about the number of planes and the number of boxes in the game. The
    location of those instances of `StackLayout` in the grid is defined by the `Grid.Row=".."`
    and `Grid.Column=".."` attributes. Remember that the rows and columns are zero
    based. You don't actually have to add attributes for row or column `0`, but it
    can sometimes be a good practice to improve code readability.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用前两个单元格来添加`StackLayout`的实例，其中包含游戏中平面数量和箱子数量的信息。这些`StackLayout`的实例在网格中的位置由`Grid.Row=".."`和`Grid.Column=".."`属性定义。请记住，行和列是从零开始的。实际上，您不必为行或列`0`添加属性，但有时为了提高代码可读性，这样做可能是一个好习惯。
- en: Finally, we have the `ARView` control, which resides in row `1` but spans both
    columns by specifying `Grid.ColumnSpan="2"`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`ARView`控件，它位于第1行，但通过指定`Grid.ColumnSpan="2"`跨越了两列。
- en: The next step is to install UrhoSharp, which will be our library for rendering
    graphics to represent the augmented part of our reality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装UrhoSharp，它将是我们用来渲染表示现实增强部分的图形的库。
- en: Adding Urhosharp
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Urhosharp
- en: Urho is an open source 3D game engine. UrhoSharp is a package that contains
    bindings to iOS and Android binaries, enabling us to use Urho in .NET. It is a
    very competent piece of software, and we will only be using a very small part
    of it to do the heavy lifting when it comes to rendering planes and boxes in the
    app. We urge you to find out more about UrhoSharp to add your own cool features
    to the app.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Urho是一个开源的3D游戏引擎。UrhoSharp是一个包，其中包含了对iOS和Android二进制文件的绑定，使我们能够在.NET中使用Urho。这是一个非常有竞争力的软件，我们只会使用它的一小部分来在应用程序中渲染平面和箱子。我们建议您了解更多关于UrhoSharp的信息，以添加您自己的酷功能到应用程序中。
- en: All you have to do to install UrhoSharp is download a NuGet package for each
    platform. The iOS platform uses the UrhoSharp NuGet package, and Android uses
    the UrhoSharp.ARCore package. Also, in Android, we need to add some code to wire
    up life cycle events, but we will get to that later. Basically, we will set up
    an `UrhoSurface` on each platform. We will access this to add nodes to the node
    tree. These nodes will then be rendered based on their type and properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装UrhoSharp只需要为每个平台下载一个NuGet包。iOS平台使用UrhoSharp NuGet包，Android使用UrhoSharp.ARCore包。此外，在Android中，我们需要添加一些代码来连接生命周期事件，但我们稍后会讲到。基本上，我们将在每个平台上设置一个`UrhoSurface`。我们将访问这个平台以向节点树添加节点。然后根据它们的类型和属性来渲染这些节点。
- en: First, however, we need to install the packages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要安装这些包。
- en: Installing the UrhoSharp NuGet package for iOS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为iOS安装UrhoSharp NuGet包
- en: 'All we need to do for iOS is to add the UrhoSharp NuGet package. This contains
    everything we need for our AR app. You can add the package as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS，我们只需要添加UrhoSharp NuGet包。这个包包含了我们AR应用所需的一切。您可以按照以下步骤添加该包：
- en: Right-click on the `WhackABox.iOS` project.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`WhackABox.iOS`项目。
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理NuGet包...”，如下截图所示：
- en: '![](img/7beed9e8-ee72-4937-8275-18b877598992.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7beed9e8-ee72-4937-8275-18b877598992.png)'
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开NuGet包管理器。点击窗口左上角的“浏览”链接。
- en: Enter `UrhoSharp`in the search box and hit *Enter*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入`UrhoSharp`，然后按*Enter*。
- en: 'Select the UrhoSharppackage and click `Install` on the right side of the window,
    as shown in the following screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择UrhoSharp包，并在窗口右侧点击“安装”，如下截图所示：
- en: '![](img/30731bb9-fc86-4d9b-aa35-cbb970ec2fef.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30731bb9-fc86-4d9b-aa35-cbb970ec2fef.png)'
- en: That's it for iOS. Android is a little bit trickier to set up, since it needs
    a special UrhoSharp package and some code to be written to wire everything up.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是iOS的全部内容。Android设置起来有点棘手，因为它需要一个特殊的UrhoSharp包和一些代码来连接一切。
- en: Installing the UrhoSharp.ARCore Nuget Package for Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Android, we will be adding the UrhoSharp.ARCore package, which contains
    extensions for ARCore. It has a dependency on UrhoSharp, so we don''t have to
    add that package specifically. You can add theUrhoSharp.ARCore package as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `WhackABox.Android` project.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39392973-f2c7-4730-8438-00c3ac2c14fd.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `UrhoSharp.ARCore` in the search box and hit *Enter*.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the UrhoSharp.ARCore package and click Install on the right side of
    the window, as shown in the following screenshot:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/54863d4c-bb64-4284-a05e-97865506710e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: That's it—all your dependencies on UrhoSharp have been installed in the project.
    We now have to wire up some life cycle events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Android life cycle events
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, `Urho` needs to know about some specific events and be able to
    respond to them accordingly. We also need to add an internal message using `MessagingCenter`
    so that we can react to the `OnResume` event later on in the app. We will get
    to that when we add the code to initialize ARCore. But for now, add the five required
    overrides for Android events, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, open `MainActivity.cs`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the five overrides from the following code anywhere in the `MainActivity`
    class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve the unresolved references by adding `using` statements for `Urho.Droid`
    and `Xamarin.Forms`, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The events map one-on-one to internal UrhoSharp events, except for `OnBackPressed`,
    which calls `UrhoSharp.OnDestroy()`. The reason for this is memory management,
    so that UrhoSharp knows when to clean up.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The `MessagingCenter` library is a built-in Xamarin.Forms pub-sub library for
    passing internal messages in an app. It has a dependency on Xamarin.Forms. We
    have created a library of our own called `TinyPubSub` that breaks this dependency
    and has a slightly easier API (as well as some additional features). You can check
    it out on GitHub at [https://github.com/TinyStuff/TinyPubSub](https://github.com/TinyStuff/TinyPubSub).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Defining the PlaneNode
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `Urho`, you work with scenes that contain a tree of nodes. A node can be
    just about anything in the game, such as a renderer, a sound player, or simply
    a placeholder for subnodes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: As we talked about earlier when discussing AR fundamentals, planes are a common
    entity that is shared between the platforms. We need to create a common ground
    that represents a plane, which we can do by extending an `Urho` node. The position
    and the rotation will be tracked by the node itself, but we need to add a property
    to track the origin and the size of the plane, expressed by ARKit and ARCore as
    the extent of the plane.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add this class now and put it to use when we implement the AR-related
    code on each platform. The code to do this is straightforward, and can be set
    up by going through the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new file called `PlaneNode.cs` in the root
    of the project.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following implementation of the class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PlaneId` will be an identifier that allows us to track which platform-specific
    plane this node represents. In iOS, this will be a string, while in Android, it
    will be the hashcode of the plane-object that is converted to a string. The `ExtentY`
    and `ExtentZ` properties represent the size of the plane in meters. We are now
    ready to start creating the game logic and hooking up our application to the AR
    SDKs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom renderers for the ARView control
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom renderers are a very smart way of extending platform-specific behaviors
    to custom controls. They can also be used to override behaviors on controls that
    are already defined. In fact, all of the controls in Xamarin.Forms use renderers
    to translate the Xamarin.Forms control into a platform-specific control.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create two renderers, one for iOS and one for Android, that
    initialize the `UrhoSurface` on which we are going to render. The instantiation
    of the `UrhoSurface` differs on each platform, which is why we need two different
    implementations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个渲染器，一个用于iOS，一个用于Android，它们将初始化我们将要渲染的`UrhoSurface`。`UrhoSurface`的实例化在每个平台上都有所不同，这就是为什么我们需要两种不同的实现。
- en: For iOS
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于iOS
- en: 'A custom renderer is a class that inherits from another renderer. It allows
    us to add custom code for important events, such as when an element in XAML is
    created when the XAML file is parsed. Since the `ARView` control inherits from
    the `View`, we will be using the `ViewRenderer` as a base class. Let''s create
    the `ARViewRenderer` by going through the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义渲染器是从另一个渲染器继承的类。它允许我们为重要事件添加自定义代码，例如在解析XAML文件时创建XAML元素时。由于`ARView`控件继承自`View`，我们将使用`ViewRenderer`作为基类。通过以下步骤创建`ARViewRenderer`：
- en: In the iOS project, create a folder called `Renderers`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS项目中，创建一个名为`Renderers`的文件夹。
- en: Add a new class called `ARViewRenderer` to that folder.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中添加一个名为`ARViewRenderer`的新类。
- en: 'Add the following code to the class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ExportRenderer` attribute registers this renderer to Xamarin.Forms so
    that it knows that when it parses (or compiles) an `ARView` element, it should
    render it using this specific renderer. It takes two arguments: the first is the
    `Control` that we want to register a renderer to and the second is the type of
    the renderer. This attribute must be placed outside the namespace declarations.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExportRenderer`属性将此渲染器注册到Xamarin.Forms，以便它知道当解析（或编译）`ARView`元素时，应该使用此特定的渲染器进行渲染。它接受两个参数：第一个是我们要注册渲染器的`Control`，第二个是渲染器的类型。此属性必须放在命名空间声明之外。'
- en: The `ARViewRenderer` class inherits `ViewRenderer<ARView, UrhoSurface>`. This
    specifies which control this renderer is created for and which native control
    it should render. In this case, the `ARView` will be natively replaced by a `UrhoSurface`
    control that in itself is an iOS-specific `UIView`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARViewRenderer`类继承自`ViewRenderer<ARView, UrhoSurface>`。这指定了此渲染器为哪个控件创建，以及它应该渲染哪个本地控件。在这种情况下，`ARView`将被一个`UrhoSurface`控件本地替换，这本身是一个iOS特定的`UIView`。'
- en: We override the `OnElementChanged()` method that is called every time the `ARView`
    element changes, either when it is created or when it is replaced. We can then
    check whether the `Control` property is set. The control is of the `UrhoSurface` type, since
    we declared that in the class definition. If it's `null`, then we make a call
    to `Initialize()` to create it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`OnElementChanged()`方法，该方法在`ARView`元素每次更改时被调用，无论是创建还是替换。然后我们可以检查`Control`属性是否已设置。控件是`UrhoSurface`类型，因为我们在类定义中声明了它。如果它是`null`，那么我们就调用`Initialize()`来创建它。
- en: The creation is straightforward. We simply create a new `UrhoSurface` control
    and set the native control to this newly created object. We then call the `Show<Game>()`
    method to start the game by specifying which class represents our `Urho` game.
    Note that the `Game` class is not defined yet, but it will be very soon, right
    after we create the custom renderer for Android.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建非常简单。我们只需创建一个新的`UrhoSurface`控件，并将本地控件设置为这个新创建的对象。然后我们调用`Show<Game>()`方法来启动游戏，指定代表我们的`Urho`游戏的类。请注意，`Game`类尚未定义，但它将很快定义，就在我们为Android创建自定义渲染器之后。
- en: For Android
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Android
- en: 'The custom renderer for Android does the same thing as it does for iOS, but
    with the additional step of checking permissions. Let''s create the `ARViewRenderer`
    for Android by going through the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android的自定义渲染器与iOS的自定义渲染器做的事情相同，但还需要检查权限。通过以下步骤创建Android的`ARViewRenderer`：
- en: In the Android project, create a folder called `Renderers`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目中，创建一个名为`Renderers`的文件夹。
- en: Add a new class called `ARViewRenderer` to that folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中添加一个名为`ARViewRenderer`的新类。
- en: 'Add the following code to the class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE6]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This custom renderer also inherits from `ViewRenderer<T1, T2>`, where the first
    type is the type of the renderer itself and the second is the native control that
    the renderer will produce. In this case, the native control will be a control
    that inherits from `Android.Views.View`. The renderer creates a `UrhoSurfacePlaceholder`
    instance, which it assigns as the native control. The `UrhoSurfacePlaceholder`
    is a class that wraps some functionality of the **Simple DirectMedia Layer** (**SDL**)
    library that `Urho` uses on Android to access media functionality. The last thing
    it does is to start the game based on the soon-to-exist `Game`class. We will define
    this in the next section of this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义渲染器也继承自`ViewRenderer<T1, T2>`，其中第一个类型是渲染器本身的类型，第二个是渲染器将生成的本地控件的类型。在这种情况下，本地控件将是一个继承自`Android.Views.View`的控件。渲染器创建一个`UrhoSurfacePlaceholder`实例，并将其分配为本地控件。`UrhoSurfacePlaceholder`是一个包装`Urho`在Android上使用的**Simple
    DirectMedia Layer**（**SDL**）库的一些功能的类，用于访问媒体功能。它的最后一步是基于即将存在的`Game`类启动游戏。我们将在本章的下一部分中定义这个类。
- en: Creating the game
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏
- en: 'To write an application that uses `Urho`, we need to create a class that inherits
    from `Urho.Application`. This class defines some virtual methods that we can use
    to set up the scene. The method we will use is `Start()`. Before that, however,
    we need to create the class. The class will be split into three files using partial
    classes, as described in the following list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个使用`Urho`的应用程序，我们需要创建一个从`Urho.Application`继承的类。这个类定义了一些虚拟方法，我们可以用来设置场景。我们将使用的方法是`Start()`。然而，在那之前，我们需要创建这个类。这个类将被分成三个文件，使用部分类来描述，如下列表所述：
- en: The `Game.cs` file, which will contain code that is cross platform
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.cs`文件中将包含跨平台的代码'
- en: The `Game.iOS.cs` file, which will contain code that will only be compiled in
    the iOS version of the app
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.iOS.cs`文件中将包含仅在应用的iOS版本中编译的代码'
- en: The `Game.Android.cs` file, which will contain code that will only be compiled
    in the Android version of the app
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.Android.cs`文件中将包含仅在应用的Android版本中编译的代码'
- en: We will be using a conditional compile to do so. We discussed conditional compiling
    in the introduction to this project. Simply put, this means that we can use something
    called **preprocessor directives** to determine at compile time whether the code
    should be included. In practice, this means that we will be compiling different
    code in Android and iOS by defining the same `InitializeAR()` method in both `Game.iOS.cs`
    and `Game.Android.cs`. During initialization, we will call this method, and, depending
    on which platform we run it on, it will be implemented differently. This can only
    be done with a shared project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用条件编译来实现。我们在项目介绍中讨论了条件编译。简单来说，这意味着我们可以使用称为**预处理指令**的东西来确定在编译时是否应该包含代码。实际上，这意味着我们将通过在`Game.iOS.cs`和`Game.Android.cs`中定义相同的`InitializeAR()`方法来在Android和iOS中编译不同的代码。在初始化期间，我们将调用此方法，并且根据我们在其上运行的平台，它将以不同的方式实现。这只能通过共享项目完成。
- en: Visual Studio has excellent support for conditional compiling and will resolve
    the correct references depending on which project you have set as the startup
    project or what you select in the toolbar above the code file itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio对条件编译有很好的支持，并且将根据您设置为启动项目的项目或您在代码文件本身上方的工具栏中选择的项目来解析正确的引用。
- en: For this project, we could have moved the `Game.iOS.cs` file to the iOS project
    and the `Game.Android.cs` and removed the conditional compile preprocessor statements.
    The app would compile just fine, but for the purposes of learning how this works,
    we will include them in the shared project. This could also be a positive thing,
    since we are gathering related code in one place, making it easier to understand
    the architecture.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们可以将`Game.iOS.cs`文件移动到iOS项目中，将`Game.Android.cs`文件移动到Android项目中，并删除条件编译预处理语句。应用程序将编译正常，但为了学习如何工作，我们将把它们包含在共享项目中。这也可能是一个积极的事情，因为我们将相关代码聚集在一起，使架构更容易理解。
- en: Adding the shared partial Game class
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加共享的部分Game类
- en: 'We start by creating the `Game.cs` file that will contain shared code. Let''s
    set this up by going through the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建包含共享代码的`Game.cs`文件。让我们通过以下步骤设置这个：
- en: In the `WhackABox` project, create a new file called `Game.cs` in the root of
    the project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，在项目的根目录下创建一个名为`Game.cs`的新文件。
- en: 'Add the following code to the class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE7]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing to notice is the `partial` keyword in the class. This indicates
    to the compiler that this is not the entire implementation, and that more code
    will be present in other files. The code in those files will be treated as if
    it were in this file; it's a nice way to split large implementations into different
    files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是类中的`partial`关键字。这告诉编译器这不是整个实现，还会在其他文件中存在更多的代码。那些文件中的代码将被视为在这个文件中; 这是将大型实现拆分成不同文件的好方法。
- en: The `Game` inherits from `Urho.Application`, which will do most of the work
    regarding the game itself. We define a property called `scene` of the `Scene`type.
    A `Scene` in `Urho` represents one screen of the game (we could have different
    scenes for different parts of a game or for a menu, for example). In this game,
    we will only be defining one scene, which will be initialized later. A `scene`
    maintains a hierarchy of nodes that compose it, and each node can have any number
    of children and any number of components. It's the components that do the work.
    Later on, for example, we will be rendering boxes, which will be represented by
    a node that will have a `Box` component attached.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`继承自`Urho.Application`，它将处理关于游戏本身的大部分工作。我们定义了一个名为`scene`的`Scene`类型的属性。在`Urho`中，`Scene`代表游戏的一个屏幕（例如，我们可以为游戏的不同部分或菜单定义不同的场景）。在这个游戏中，我们只会定义一个场景，稍后将对其进行初始化。一个`scene`维护了组成它的节点的层次结构，每个节点可以有任意数量的子节点和任意数量的组件。它是组件在工作。例如，稍后我们将渲染盒子，这将由一个附加了`Box`组件的节点表示。'
- en: The `Game` class itself is instantiated from the custom renderers that we defined
    in the earlier section, and it takes an `ApplicationOptions` instance as a parameter
    in the constructor. This needs to be passed to the base class. We now need to
    write some methods that will be AR specific and used by the code we will write
    later on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类本身是从我们在前面部分定义的自定义渲染器中实例化的，并且它在构造函数中以`ApplicationOptions`实例作为参数。这需要传递给基类。现在我们需要编写一些将是AR特定的并且将在以后编写的代码中使用的方法。'
- en: CreateSubPlane
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CreateSubPlane
- en: The first method is the `CreateSubPlane()` method. When the application finds
    a plane on which we can place objects, it will create a node. We will write that
    code specifically for each platform soon. This node also defines a subplane that
    will position a box, representing the position and size of that plane. We have
    already defined the `PlaneNode` class earlier in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法是`CreateSubPlane()`方法。当应用程序找到可以放置对象的平面时，它将创建一个节点。我们很快将为每个平台编写该代码。该节点还定义了一个子平面，将定位一个代表该平面位置和大小的盒子。我们已经在本章前面定义了`PlaneNode`类。
- en: 'Let''s add the code by going through the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤添加代码：
- en: In the `WhackABox` project, open the `Game.cs` class.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WhackABox`项目中，打开`Game.cs`类。
- en: 'Add the following `CreateSubPlane()` method to the class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`CreateSubPlane()`方法添加到类中：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Any class inheriting from **`Urho.Node`**, such as `PlaneNode`, has the `CreateChild()` method.
    This allows us to create a child node and specify a name for that node. That name
    will be used later on to find specific children to perform operations on. We position
    the node at the same position as the parent node, except that we raise it `0.05`
    meters (5 cm) above the plane.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从**`Urho.Node`**继承的类，比如`PlaneNode`，都有`CreateChild()`方法。这允许我们创建一个子节点并为该节点指定一个名称。稍后将使用该名称来查找特定的子节点执行操作。我们将节点定位在与父节点相同的位置，只是将其提高`0.05`米（5厘米）以上平面。
- en: To see the plane, we add a `box` component with a semitransparent red color.
    The `box` is a component that is created with a call to `CreateComponent()` on
    our node. The color is defined in the AARRGGBB pattern, where AA is the alpha
    component (the transparency) and RRGGBB is the standard red-green-blue format.
    We use hexadecimal representation of the colors.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: UpdateSubPlane
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both ARKit and ARCore update planes continuously. What we are interested in
    are changes in the position of a subplane and the extent of it. By extension,
    we are referring to the size of the plane. Let''s set this up by going through
    the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` class.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UpdateSubPlane()` method in the code anywhere in the `Game.cs` class,
    as shown in the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method takes the `PlaneNode` that we want to update, along with a new position
    for it. We locate the subplane by querying the current node for any node called
    `"subplane"`. Remember that we named the subplane in the `AddSubPlane()` method.
    We can now easily access the node by name. We update the scale of the subplane
    node by taking the `ExtentX` and `ExtentZ` properties from the `PlaneNode`. The
    plane node will be updated by some platform-specific code before we call `UpdateSubPlane().` Finally,
    we set the position of the subplane to the passed `position `parameter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: FindNodeByPlaneId
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a method to quickly find nodes. Both ARKit and ARCore keep an internal
    track of their planes, and to map those internal representations of planes to
    our `PlaneNode`, we have to assign a custom ID to a plane when it's created. This
    will be done in the platform-specific code, but we can still write the function
    to query the scene for `PlaneNode`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaneNode` is a `string`, since ARKit defines the plane ID in a form that
    resembles a **Global Unique Identifier** (**GUID**). A GUID is a structured sequence
    of hexadecimal numbers that can be represented in a `string` format, as shown
    in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method queries the scene by using `Linq` and looks for the first child with
    the plane ID that it was given. If it can't find one, it returns `null`, since
    `null` is the default value of a reference type object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: These are all of the methods that we need in the shared code before dropping
    down into ARKit and ARCore.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Adding platform-specific partial classes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to take advantage of conditional compiling. We will create two
    partial classes, one for iOS and one for Android, that will be conditionally compiled
    into the `Game` class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will simply set up the skeleton code for these files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Adding the iOS-specific partial class
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `partial` class for `Game` on iOS and wrapping
    the whole code file within a preprocessor directive that specifies that this code
    will only be compiled on iOS:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a new file called `Game.iOS.cs`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and `partial`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `#if`and `#endif` preprocessor directives to allow for conditional
    compiling, as shown in the following code:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of code is a preprocessor directive that the compiler will use
    to determine whether the code within the `#if` and `#endif` directives should
    be included in the compilation. If it is included, a `partial` class will be defined.
    The code in this class can be iOS specific, even though we are defining it in
    the shared project. Visual Studio is smart enough to treat any code within this
    section as if it were present directly in the iOS project. There will be no problem
    with instantiating a `UIView` here, since the code will never be compiled for
    any platform other than iOS.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Android-specific partial class
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same goes for Android: only the name of the file and the preprocessor directive changes.
    Let''s set this up by going through the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a new file called `Game.Android.cs`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and `partial`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `#if` and `#endif` conditional compile statements, as shown in the
    following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with iOS, only code for Android will ever be compiled between the `#if` and
    `#endif` statements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Let's now start adding some platform-specific code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Writing the ARKit-specific code
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write the platform-specific code for iOS that will
    initialize ARKit, find planes, and create nodes for UrhoSharp to render on the
    screen. We will be taking advantage of an `Urho` component that wraps ARKit in
    iOS. We will also be writing all the functions that will position, add, and remove
    nodes. ARKit uses  `anchors`, which act as virtual points that glue the overlaid
    graphics to the real world. We are specifically looking for `ARPlaneAnchor`, which represents
    a plane in the AR world. There are other types of anchors available, but for this
    app, we only need to find horizontal planes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by defining the `ARKitComponent` so that we can use it later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ARKitComponent
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by adding a `private` field to an `ARKitComponent` that will be initialized
    later on. Let''s set this up by going through the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open `Game.iOS.cs`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `private` field that holds an `ARKitComponent`, as shown in bold in the
    following code :'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure that you add all the `using` statements to ensure that all the code
    we later use resolves the correct types.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Writing handlers for adding and updating anchors
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now add the necessary code that will add and update anchors. We will
    also add some methods to help set the orientation of the nodes after ARKit updates
    the anchors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: SetPositionAndRotation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SetPositionAndRotation()` method will be used by both the add and update
    anchors, so we need to define it before creating the handlers for the events that
    will be raised by ARKit. Let''s set this up by going through the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The method takes two parameters. The first is an `ARPlaneAnchor` defined by
    ARKit and the second is the `PlaneNode` that we have in the scene. The purpose
    of the method is to make sure that the `PlaneNode` is in sync with the `ARPlaneAnchor`
    object passed by ARKit. The `arkitComponent` has a helper method called `ApplyOpenTkTransform()`
    to translate the position and rotation of the `ARPlaneAnchor` object into the
    position and rotation objects used by `Urho`. We then update the `Extent` (size)
    of the plane to the `PlaneNode` and get the `anchor` center position from the
    `ARPlaneAnchor`. Finally, we call a method that we defined earlier to update the
    subplane node that holds the `Box` component that will do the actual rendering
    of the plane as a semitransparent red box.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We need one more method to handle the update and add functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: UpdateOrAddPlaneNode
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UpdateOrAddPlaneNode()` does exactly what the name implies: it takes an
    `ARPlaneAnchor` as an argument and either updates or adds a new `PlaneNode` to
    the `scene`. Let''s set this up by going through the following steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UpdateOrAddPlaneNode()` method, as described in the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A node is either already present in the scene or it needs to be added. The first
    line of code calls the `FindNodeByPlaneId()` to query the scene for an object
    with the given `PlaneId`. For iOS, we use the `anchor.Identifier` property to
    track planes defined by iOS. If this call returns `null`, it means that the plane
    is not present in the scene and we need to create it. To do this, we instantiate
    a new `PlaneNode`, giving it a `PlaneId` and a user-friendly name for debugging
    purposes. We then create the subplane to visualize the plane itself by calling
    `CreateSubPlane()`, which we defined earlier, and add the node to the `scene`. Lastly,
    we update the position and rotation. We do this for every call to the `UpdateOrAddPlaneNode()`
    method, since it's the same for both new and existing nodes. It's now time to
    write the handlers that we will eventually hook up to ARKit directly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: OnAddAnchor
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add some code. The `OnAddAnchor()` method will be called each time ARKit updates
    its collection of anchors that describe points that we will use to relate to within
    our virtual world. We are specifically looking for anchors of the `ARPlaneAnchor` type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `OnAddAnchor()` method to the `Game.iOS.cs` class by going through
    the following two steps:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnAddAnchor()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The method takes an array of `ARAnchors` as a parameter. We filter out the anchors
    that are of the `ARPlaneAnchor` type and iterate through the list. For each `ARPlaneAnchor`,
    we call the `UpdateOrAddPlaneNode()` method that we created earlier to add a node
    to the scene. Let's now do the same for when ARKit wants to update anchors.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: OnUpdateAnchors
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time ARKit receives new information about an anchor, it will call this
    method. We do the same as we did with the previous code and iterate through the
    list to update the extent and position of the `anchor` in the scene:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnUpdateAnchors()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code is a copy of the `OnAddAnchors()` method. It updates all nodes in the
    scene based on the information provided by ARKit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: We also need to write some code to remove the anchors that ARKit has removed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Writing a handler for removing anchors
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When ARKit decides that an anchor is invalid, it will remove it from the scene.
    This does not happen very often, but it's a good practice to handle this call
    anyway.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: OnRemoveAnchors
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a method to handle the removal of an `ARPlaneAnchor` by going through
    the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnRemoveAnchors()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with the `Add` and `Remove` functions, this method accepts an array of `ARAnchor`.
    We iterate through this array, looking for anchors of the `ARPlaneAnchor` type.
    We then look for a node that represents this plane by calling the `FindNodeByPlaneId()`
    method. If it's not `null`, then we call for that node to be removed. Note the
    null-check operator before the `Remove()` call.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Initializing ARKit
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now come to the last part of the iOS-specific code, which is where we
    initialize ARKit. This method is called `InitializeAR()`, and takes no parameters.
    It is the same as the method for Android, but since they are never compiled simultaneously
    because of the use of conditional compiling, the code calling this method will
    not know the difference.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to initialize ARKit is straightforward, and the `ARKitComponent` does
    a lot of work for us. Let''s set it up by going through the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code starts by creating an `ARKitComponent`. We then set the allowed orientation
    and create an `ARWorldTrackingConfiguration` class that states that we are only
    interested in horizontal planes. To respond to the addition, updating, and removal
    of planes, we attach the event handlers we created earlier.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We instruct the ARKit component to delay calling the callbacks to allow ARKit
    to initialize properly. Note the spelling error in the `RunEngineFramesInARKitCallbakcs`
    property. This is a good example of why you need to carry out a review of your
    code, since it will be hard to change this name without breaking backward compatibility.
    Naming is hard.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: The last thing is to tell ARKit to start running. We do this by calling the `arkitComponent.Run()`
    method.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Writing ARCore-specific code
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to do the same for Android with ARCore. Just as with iOS, we are
    going to put all Android-specific code in a file of its own. This file is the
    `Game.Android.cs` that we created earlier.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ARCoreComponent
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we are going to add a field that stores a reference to the `ARCoreComponent`.
    This wraps most of the interaction with ARCore. The `ARCoreComponent` is defined
    in the UrhoSharp.ARCore NuGet package that we installed at the beginning of the
    chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some `using` statements and the field by going through the following
    steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `arCore`private field, as described in the following code. Also, make
    sure that you add the `using` statements marked in bold:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `using` statements will allow us to resolve the types that we need in this
    file and the `arCore` property will be a shorthand when we want to access ARCore
    functions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue by adding some methods to this class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: SetPositionAndRotation
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add or update a `PlaneNode` whenever a plane is detected or updated.
    The `SetPositionAndRotation()` method updates the passed `PlaneNode` and sets
    properties on that node based on the content of the `AR.Core.Plane` object. Let''s
    set this up by going through the following steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous code updates the extent of the plane for the node and creates a
    rotation, `Quaternion`. Don't worry if you don't know what a `Quaternion` is—few
    people do—but they seem to magically hold the rotation information of the model
    in a very flexible way. The `plane.CenterPose` property is a matrix that holds
    the position and orientation of the plane. Finally, we update the position of
    the node from the `CenterPose` property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a method that handles frame updates from ARCore.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Writing a handler for ARFrame updates
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android handles updates from ARCore a little bit differently than ARKit, which
    exposes three different events for added, updated, and removed nodes. When using
    ARCore, we get called whenever any changes occur, and the handler that will take
    care of this is the one we are about to add.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the method by going through the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnARFrameUpdated()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start by querying the `arCore` component for all the planes that it keeps
    track of. We then iterate through this list and see whether we have any nodes
    in the scene by calling the `FindNodeByPlaneId()` method, using the hash code
    of the plane as the identifier. If we can't find any, we create a new `PlaneNode`
    and assign the hash code as the `PlaneId`. We then create a subplane that contains
    the `Box` component to visualize the plane, and, finally, we add it to the scene. We
    then update the position and the rotation of the plane and make a call to update
    the subplane as well. Now that we have the handler written, we need to hook it
    up.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Initializing ARCore
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To initialize ARCore, we will add two methods. The first one is a method that
    will take care of the configuration of ARCore, called `OnConfigRequested()`. The
    second one is the `InitializeAR()` method that will be called from the shared
    `Game` class later on. This method is also defined in the iOS-specific code, but,
    as we talked about earlier, this method in iOS will never be compiled when we
    compile for Android, since we are using conditional compiling, which filters out
    code from the platform that isn't selected.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: OnConfigRequested
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ARCore needs to know a few things, just like iOS. In Android, this is done
    by defining a method that the ARCore component will call upon initialization.
    To create the method, go through the following steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnConfigRequested()` method anywhere in the class, as shown in the 
    following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The method takes a `Config` object, which will store any configuration you make
    in this method. First, we set which type of plane we want to find. We are interested
    in `Horizontal` planes for this game. We define which kind of light-estimation
    mode we want to use and, finally, we select which update mode we want. In this
    case, we want to use the latest camera image available. You can do a lot of fine-tuning
    during configuration, but this is out of the scope of this book. Be sure to check
    out the documentation for ARCore to learn more about its awesome power.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the code we need to initialize ARCore.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: InitializeAR
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `InitializeAR()` method shares the same name as
    the iOS-specific code, but the compiler will only include one of them in the build
    because of the use of conditional compiling. Let''s set this up by going through
    the following steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first step is to create the `ARCoreComponent` provided by UrhoSharp. This
    component wraps the initialization of the native ARCore classes. We then add two
    event handlers: one for taking care of frame updates and one that will be called
    during initialization. The last thing we do is call the `Run()` method on the
    `ARCoreComponent` to start tracking the world.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both ARKit and ARCore configured and ready to go, it's time
    to write the actual game.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Writing the game
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will initialize `Urho` by setting up the camera, lighting,
    and a renderer. The camera is the object that determines where objects will be
    rendered. The AR components take care of updating the position of the camera to
    virtually track your phone so that any object we render will be in the same coordinate
    space as what you are looking at. First, we need a camera that will be the viewing
    point of the scene.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a camera is a straightforward process, as shown in the following steps:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `camera` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeCamera()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In UrhoSharp, everything is a node just like everything is a GameObject in Unity,
    including the `camera`. We create a new node, which we call `camera`, and then
    we create a `Camera` component on that node and keep the reference to it for later
    use.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a renderer
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UrhoSharp needs to render the scene to a `viewport`. A game can have multiple
    viewports, based on multiple cameras. Think of a game where you drive a car. The
    main `viewport` will be the game from the perspective of the driver. Another `viewport`
    might be the rear-view mirrors, which would actually be cameras themselves that
    render what they see on to the main `viewport`. Let''s set this up by going through
    the following steps:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `viewport` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeRenderer()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `viewport` property will hold a reference to the `viewport` for later use. The
    `viewport` is created by instantiating a new `viewport` class. The constructor
    of that class needs a `Context` provided by the base class, the `scene` that we
    will create while initializing the game, a camera to know which point in space
    to render from, and a render path, which we default to `null`. A render path allows
    for post-processing of the frame created while rendering. This is also outside
    the scope of this book, but it is worth checking out as well.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Now, let there be light.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Adding lights
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make objects visible, we need to define some lighting. We do this by creating
    a method that defines which type of lighting we want in the game. Let''s set this
    up by going through the following steps:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeLights()` method anywhere in the class, as shown in the
    following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, everything in UrhoSharp is a node, and lights are no exception to that
    rule. We create a generic node on the camera node by accessing the stored camera
    component and accessing the node it belongs to. We then set a direction of that
    node and create a `Light` component to define a light. The range of the light
    will be 10 units in length. The type is directional, meaning that it will shine
    from the position of the node in its defined direction. It will also cast shadows.
    We set the `ShadowMapSize` to four times the default value to give the shadow
    map some more resolution.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have all we need to initialize UrhoSharp and the AR components.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game startup
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The base class of the `Game` class provides some virtual methods that we can
    override. One of these is `Start()`, which will be called shortly after the custom
    renderer has set up the `UrhoSurface`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the method by going through the following steps:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Start()` method anywhere in the class, as shown in the following code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The scene that we have been talking about is created here in the first line
    of the method. This is the scene that we look at when UrhoSharp is running. It keeps
    track of all nodes that we add to it. All 3D games in UrhoSharp need an `Octree`,
    which is a component that implements spatial partitioning. It is used by the 3D
    engine to quickly find objects in a 3D space without having to query every single
    one in each frame. The second line of the method creates this component directly
    on the scene.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we have the four methods that initialize the camera, the lights,
    and the renderer, and that make a call to one of the two `InitializeAR()` methods,
    based on which platform we are compiling for. If you start the app at this point,
    you should see that it finds planes and renders them, but that nothing more happens.
    It's time to add something to interact with.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Adding boxes
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to focus on adding virtual boxes to our augmented world. We
    are going to write two methods. The first one is the `AddBox()` method, which
    will add a new box at a random position on a plane. The second is an override
    of the `OnUpdate()` method that UrhoSharp calls with each frame to perform game
    logic.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: AddBox()
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add boxes to a plane, we need to add a method to do so. This method is called
    `AddBox()`. Let''s set this up by going through the following steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `random` property to the class (preferably at the top, but anywhere
    in the class will work).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `AddBox()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The static `random` object that we create will be used for randomizing the location
    of a box on a plane. We want to use a static `Random` instance, since we don't
    want to risk creating multiple instances that may be seeded with the same value,
    and that therefore return the exact same sequence of random numbers. The method
    starts by finding the subplane child of the `PlaneNode` instance that we pass
    in by calling `planeNode.GetChild("subplane")`. We then create a node that will
    render the box. To make the box fit the world, we need to set the scale to `0.1`,
    which will make it 10 cm in size.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: We then randomize the position of the box using the `ExtentX` and `ExtentZ`
    properties, multiplied by a new random value between `0` and `1` that we first
    subtract `0.5` from. This is to center the position, since the position of the
    parent node is the center of the plane. Then, we set the position of the box node
    at the randomized position and 0.1 units above the plane. We also need to add
    the subplanes position, since it might be a little bit offset from the parent
    node. Finally, we add the actual box to be rendered and set the color to blue.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add code to call the `AddBox()` method, based on some game logic.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: OnUpdate()
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most games use a game loop. This calls an `Update()` method, which takes an
    input and calculates the state of the game. UrhoSharp is no exception. The base
    class of our game has a virtual `OnUpdate()` method that we can override so that
    we can write code that will be executed with each frame. This method is called
    frequently, usually about 50 times per second.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now override the `Update()` method to add game logic that adds a new
    box every other second. Let''s set this up by going through the following steps:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `newBoxTtl` field and the `newBoxIntervalInSeconds` field to the class
    at the top of the code.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnUpdate()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first field, `newBoxTtl` where `Ttl` is **time to live** (**TTL**), is an
    internal counter that will be reduced by the number of milliseconds that have
    passed since the last frame. When it fall below `0`, we will add a new box to
    each plane of the scene. We find all instances of `PlaneNode` by querying the
    `Children` collection of the scene and returning only the children of the `PlaneNode`
    type. The second field, `newBoxIntervalInSeconds`, indicates how many seconds
    we will add to the `newBoxTtl` once it reaches `0`. To know how much time has
    passed since the last frame, we use the `timeStep `parameter that is passed into
    the `OnUpdate()` method by UrhoSharp. The value of this parameter is the number
    of seconds since the last frame. It's usually a small value, which will be something
    like `0.016` if the update loop runs at 50 frames per second. It could vary though,
    which is why you will want to use this value to carry out the subtraction from
    `newBoxTtl`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, you will see that boxes appear on the detected planes.
    We still cannot interact with them, however, and they look pretty boring. Let's
    continue by making them rotate.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Making boxes rotate
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add your own components to UrhoSharp by creating a class that inherits
    from `Urho.Component`. We will be creating a component that will make the boxes
    spin around all three axes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Creating the rotate component
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, a component is a class that inherits from `Urho.Component`.
    This base class defines a virtual method called `OnUpdate()` that behaves the
    same way as the `Update()` method on the `Game` class itself. This allows us to
    add logic to the component so that it can modify the state of the node it belongs
    to.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `rotate` component by going through the following steps:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `Rotator.cs` in the root
    of the project.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `RotationSpeed` property will be used to determine the speed of rotation
    around any specific axis. It will be set when we assign the component to the box
    node in the next step. To enable the component to receive calls to the `OnUpdate()`
    method on each frame, we need to set the `ReceiveSceneUpdates` property to `true`.
    If we don't do this, the component will not be called by UrhoSharp at each update.
    It's set to `false` by default for performance reasons.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: All the fun happens in the `override` of the `OnUpdate()` method. We create
    a new quaternion to represent a new rotation state. Again, we don't need to know
    how this works in detail, only that quaternions belong to the mystical world of
    advanced mathematics. We multiply each axis in the `RotationSpeed` vector by the
    `timeStep` to generate a new value. The `timeStep` parameter is the number of
    seconds that have passed since the last frame. We also define the rotation as
    being around the local coordinate space of this box.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Now that the component is created, we need to add it to the boxes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the Rotator component
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding the `Rotator` component is as simple as adding any other component.
    Let''s set this up by going through the following steps:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AddBox()` method by adding the code marked in bold in the following
    code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We begin by defining how we want the box to rotate by creating a new `Vector3`
    struct and assigning it to a new variable called `rotationSpeed`. In this case,
    we want it to rotate `10` units around the *x *axis, `20` units around the *y *axis,
    and `30` units around the *z *axis. We use the `rotationSpeed` variable to set
    the `RotationSpeed` property of the `Rotator` component that we instantiate in
    the second row of the code we added.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the component to the `box` node. The boxes should now rotate
    in an interesting way.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Adding box hit-test
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have rotating boxes that keep piling up. We need to add a way to remove
    boxes. The simplest thing would be to add a feature that removes boxes when we
    touch them, but we are going to make it a little fancier than that: whenever we
    touch a box, we want it to shrink and disappear before we remove it from the scene.
    To do this, we are going to use our newly acquired knowledge of components and
    then add some code to determine whether we are touching a box.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Adding a death animation
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Death` component that we are about to add has the same template as the
    `Rotator` component that we created in the last section. Let''s add it by going
    through the following steps and taking a look at the code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `Death.cs`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code in the class with the following code:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first define two fields. The `deathTtl` field determines how long the animation
    will be in seconds. The `initialScale` field keeps track of the scale of the node
    when the component is attached to the node. To receive updates, we need to set
    `ReceiveSceneUpdates` to `true` in the constructor. The overridden `OnAttachedToNode()`
    method is called when the component is attached to a node. We use this method
    to set the `initialScale` field. After the component is attached, we start getting
    calls on each frame to `OnUpdate()`. On each call, we set a new scale of the node
    based on the `deathTtl` field multiplied by the `initialScale`field. When the
    `deathTtl` field reaches zero, we remove the node from the scene. If we don't
    reach zero, then we subtract the amount of time since the last frame was called,
    which is given to us by the `timeStep` parameter. All we need to do now is figure
    out when to add the `Death` component to a box.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: DetermineHit()
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a method that can interpret a touch on the 2D surface of the screen
    and figure out which boxes we are hitting using an imaginary ray travelling from
    the camera toward the scene we are looking at. This method is called `DetemineHit`.
    Let''s set this up by going through the following steps:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `DetemineHit()` method anywhere in the class, as shown in the following
    code:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `x` and `y` parameters that are passed into the method range from `0` to
    `1`, where `0` represents the left edge or top edge of the screen and `1` represents
    the right edge or bottom edge of the screen. The exact center of the screen would
    be `x=0.5` and `y=0.5`. Since we want to get a ray from the camera, we can use
    a method directly on the camera component called `GetScreenRay()`. It returns
    a ray from the camera in the scene in the same direction that the camera is set
    to. We use this ray and pass it to the `Octree` component's `RaycastSingle()`
    method, which returns a result that will contain a single node, if one is hit.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: We examine the results, perform multiple null checks, and finally check whether
    the name of the node starts with `Box`. If this is true, we check to see whether
    the box we hit is already doomed by examining whether there is a `Death` component
    attached. If there is, we `return`. If there isn't, we create a `Death` component
    and leave the box to die.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: This all looks good so far. We now need something to call the `DetermineHit()`
    method.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: OnTouchBegin()
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Touches are handled as events in UrhoSharp, and this means that they require
    event handlers. Let''s create a handler for the `TouchBegin` event by going through
    the following steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnTouchBegin()` method anywhere in the code, as shown in the following:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When a touch is registered, this method will be called and information about
    that touch event will be sent as a parameter. This parameter has an `X` and a `Y`
    property, which represent the point on the screen that we have touched. Since
    the `DetermineHit()` method wants the values in the range of `0` to `1`, we need
    to divide the `X` and `Y` coordinates by the width and height of the screen.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Once that is done, we call the `DetermineHit()` method. To complete this section,
    we just have to wire up the event.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up input
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All that''s left now is to wire up the event to the `Input` subsystem of UrhoSharp.
    This is done by adding a single line of code to the `Start()` method, as shown
    in the following steps:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Start()` method, add the code highlighted in bold in the following
    code fragment:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This wires up the `TouchBegin` event to our `OnTouchBegin` event handler.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, the boxes should animate and disappear when you tap
    on them. What we need now is some kind of statistic that shows how many planes
    there are and how many boxes are still alive.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Updating statistics
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we added some controls to the XAML that displayed
    the number of planes and boxes that were present in the game. It's now time to
    add some code to update those numbers. We will be using internal messaging to
    decouple the game from the Xamarin.Forms page that we use to display this information.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The game will send a message to the main page that will contain a class that
    has all the information we need. The main page will receive this message and update
    the labels.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Defining a statistics class
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use `MessagingCenter` in Xamarin.Forms, which allows us to
    send an object along with the message. We need to create a class that can carry
    the information we want to pass. Let''s set this up by going through the following
    steps:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `GameStats.cs`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The class will be a simple data carrier that indicates how many planes and boxes
    we have.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Sending updates via MessagingCenter
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a node is created or removed, we need to send statistics to anything that
    is listening. To do this, we need a new method that will go through the scene
    and count how many planes and boxes we have, and then send a message. Let''s set
    this up by going through the following steps:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs`file.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method called `SendStats()` anywhere in the class, as shown in the following
    code:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The method checks all children of the `scene` object to find nodes of the `PlaneNode`
    type. We iterate through all of these nodes and count how many of the node's children
    have the name `Box`, and then indicate this number in a variable called `boxCount`.
    When we have this information, we create a `GameStats` object and initialize it
    with the box count and the plane count.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to send the message. We have to make sure that we are using
    the UI thread (the `MainThread`) since we are going to update the GUI. Only the
    UI thread is allowed to touch the GUI. This is done by wrapping the `MessagingCenter.Send()`
    call in `BeginInvokeOnMainThread().`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: The message that is sent is `stats_updated`. It contains the stats information
    as an argument. Let's now make use of the `SendStats()` method.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up events
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scene has a lot of events that we can wire up. We will hook up to `NodeAdded`
    and `NodeRemoved` to determine when we need to send statistics information. Let''s
    set this up by going through the following steps:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Start()` method, add the code that is highlighted in bold in the following
    fragment:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each time a node is either added or removed, a new message will be sent to the
    GUI.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Updating the GUI
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be the last method we add to the game. It handles the information updates
    and also updates the labels in the GUI. Let''s add it by going through the following
    steps:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method called `StatsUpdated()` anywhere in the code, as shown in the
    following fragment:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The method receives the `GameStats` object that we sent and updates the two
    labels in the GUI.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the updates in the MainForm
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last line of code to add will wire up the `StatsUpdated` handler to an
    incoming message. Let''s set this up by going through the following steps:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, add the line of code that is highlighted in bold in the
    following fragment:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This line of code hooks up an incoming message with the content `stats_updated`
    to the `StatsUpdated` method. Now run the game and go out into the world to hunt
    down those boxes!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed app looks something like the following screenshot, with spinning
    boxes popping up at random locations:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06e11ed-7438-49eb-b0c0-2de12f314dd6.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to integrate AR into Xamarin.Forms by using
    custom renderers. We took advantage of UrhoSharp to use cross-platform rendering,
    components, and input management to interact with the world. We also learned a
    bit about `MessagingCenter`, which can be used to send internal in-process messages
    between different parts of an application to reduce coupling.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to dive into machine learning and create an app that can
    recognize a hotdog in an image.**
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
