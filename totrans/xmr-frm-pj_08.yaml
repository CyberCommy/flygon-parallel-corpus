- en: Creating an Augmented-Reality Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be exploring **augmented reality** (**AR**) using Xamarin.Forms.
    We will be using custom renderers to inject platform-specific code, **UrhoSharp** to
    render the scene and handle input, and `MessagingCenter` to pass internal messages
    around in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ARKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ARCore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use UrhoSharp to render graphics and handle input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using custom renderers to inject platform-specific code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `MessagingCenter` to send messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, we need to have Visual Studio for Mac or
    PC installed, as well as the Xamarin components. See [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*, for more details on how to set up your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot run AR on an emulator. To run AR, you need a physical device, along
    with the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: On iOS, you need iOS 11 or higher and a device that has an A9 processor or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Android, you need Android 8.1 and a device that supports ARCore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will describe how AR works. The implementation differs slightly
    between platforms. Google's implementation is called **ARCore,** and Apple's implementation
    is called **ARKit**.
  prefs: []
  type: TYPE_NORMAL
- en: AR is all about superimposing computer graphics on top of a camera feed. This
    sounds like a simple thing to do, except that you have to track the camera position
    with great accuracy. Both Google and Apple have written some great APIs to do
    this magic for you, with the help of the motion sensors in your phone and data
    from the camera. The computer graphics that we add on top of the camera feed are
    synced to be in the same coordinate space as the surrounding real-life objects,
    making them appear as if they are part of the image you see on your phone.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to create a game that explores the fundamentals
    of AR. We are also going to learn how to integrate AR control in Xamarin.Forms.
    Android and iOS implement AR differently, so we will need to unify the platforms
    along the way. We will do this using UrhoSharp, an open source 3D game engine,
    which will do the rendering for us. This is simply made up of bindings to the **Urho3D** engine,
    which allows us to use Urho3D with .NET and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The game will render boxes in AR that the user needs to tap to make disappear.
    You can then extend the game yourself by learning about the Urho3D engine.
  prefs: []
  type: TYPE_NORMAL
- en: The shared code will be placed in a shared project. This is different than the
    usual .NET Standard library approach we have taken so far. The reason for this
    is that UrhoSharp doesn't support .NET Standard (at the time of writing this book).
    It's also a good idea to learn how to create a shared project. The code in a shared
    library will not compile by itself. It needs to be linked to a platform project
    (such as iOS or Android) and then the compiler can compile all the source files
    along with the platform project. This is exactly the same thing as copying the
    files directly into that project. So, by defining a shared project, we don't need
    to write code twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This strategy also unlocks another powerful feature: **conditional compilation.**
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how you can insert platform-specific code inside a
    shared code file. This will come in very handy in this project.
  prefs: []
  type: TYPE_NORMAL
- en: The estimated build time for this project is 90 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to start coding! First, however, make sure you have your development
    environment set up as described in [Chapter 1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction
    to Xamarin*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be a classic File | New Project chapter, guiding you step-by-step
    through the process of creating the app. There will be no downloads required whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open Visual Studio and click on File | New | Project, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fca819a-f5c0-424e-a0b6-26d2133d2da9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the New Project dialog. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item in the list. Complete
    the form by naming your project. We will be calling our application `WhackABox`
    in this example. Move on to the next dialog box by clicking OK, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3f05ec6-796d-4724-b354-c25d2171e43c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to select a project template and a Code Sharing Strategy.
    Select the Blank template option to create a bare minimum Xamarin.Forms app and
    make sure that the Code Sharing Strategy is set to Shared Project. Uncheck the Windows
    (UWP) checkbox under the Platform heading, since this app will only be supporting
    **iOS** and Android. Finish the setup wizard by clicking OK and let Visual Studio
    scaffold the project for you. This might take a couple of minutes. Please note
    that we will be using a Shared Project for this chapter—this is very important!
    You can see the aforementioned fields and options that you need to select in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78e4bcf2-f5d5-49a6-a4c1-e3dbefafd2df.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like that, the app has been created. Let's move on to updating Xamarin.Forms
    to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Xamarin.Forms NuGet packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, the Xamarin.Forms version that your project has been created with
    is most likely a bit old. To rectify this, we need to update the NuGet packages.
    Please note that you should only update the Xamarin.Forms packages and not the
    Android packages; updating the Android packages might cause your packages to get
    out of sync with each other, resulting in the app not building at all. To update
    the NuGet packages, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on our Solution in the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Manage NuGet Packages for Solution..., as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/542a5038-c9cb-4647-b14f-c940a60a2f88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the NuGet Package Manager in Visual Studio, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a9e444d-fd64-499a-bcc6-afb117c82756.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To update Xamarin.Forms to the latest version, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Updates tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the Xamarin.Forms checkbox and click Update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept any license agreements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The update takes at most a few minutes. Look at the output pane to find information
    about the update. At this point, we can run the app to make sure it works. We
    should see the text Welcome to Xamarin.Forms! in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Android target to 8.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ARCore is available from Android version 8.1 and later. We will, therefore,
    verify the Target Framework for the Android project by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the Properties node under the Android project in the Solution
    Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the Target Framework version is at least Android 8.0 (Oreo), as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09fe6cca-4790-4b04-8d7e-d6b20d0c4706.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If it''s not at least Android 8.0 (Oreo), you will need to select Android 8.1 (or
    above). If there is an asterisk next to the Target Framework name, then you will
    need to install that SDK by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the Android SDK Manager in the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the highlighted button to open the SDK Manager, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5c98de95-7c5c-4683-8f35-e1186ecf9de8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the control center for all SDK versions of Android that are installed
    on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the SDK version you want to install. In our case, this should be at least
    Android 8.1 - Oreo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Android SDK Platform <version number> node. You can also to install emulator
    images that will be used by the emulator to run the selected version of Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Apply Changes, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17c557be-4452-4ce7-83c0-23a5e57fd5ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the camera permission to Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get access to the camera in Android we must add a required permission
    in the Android manifest. This can be done by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the Android project node in the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the Properties node to open the properties for Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Android Manifest tab on the left and scroll down until you see the
    Required permissions section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the CAMERA permission and check the box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file by clicking *Ctrl* +* S* or File and the Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5be70e8f-186b-4838-8e0c-a49cd316f4a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have configured Android, we only have one small change to make on
    iOS before we are ready to write some code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Camera Usage Description for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS, you need to specify why you need access to the camera. The way to do
    this is to add an entry to the `info.plist` file in the root folder of the iOS
    project. The `info.plist` file is an XML file that you can edit in any text editor.
    A simpler way to this, however, is by using the Generic PList Editor provided
    by Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the required Camera Usage Description using the Generic PList Editor, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `WhackABox.iOS` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on `info.plist` and click Open With..., as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f854d634-aaab-4c4c-bdcb-6b714cb06938.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Generic PList Editor and click OK, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98665692-d865-434f-9658-4389050799c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Locate the plus (+) icon at the bottom of the property list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the plus (+) icon to add a new key. Make sure that the key is in the
    root of the document and not under another property, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abd89c94-b4d9-419f-af0e-8f374d027598.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Generic PList Editor helps you to find the right property by giving it
    a more user-friendly name. Let''s add the value we need to describe why we want
    to use the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the drop-down menu on the newly created row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Privacy - Camera Usage Description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a good reason in the values field to the right, as shown in the following
    screenshot. The field for the reason is a free-text field, so use plain English
    to describe why your app needs access to the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/14005e35-6acb-427d-be52-79da6f75f4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it. The setup of both Android and iOS is complete, and we can now focus
    on the fun part—writing code!
  prefs: []
  type: TYPE_NORMAL
- en: You can also open the `Info.plist` file in any text editor, since it's an XML
    file. The key's name is
  prefs: []
  type: TYPE_NORMAL
- en: '`NSCameraUsageDescription`, and it must be added as a direct child of the root
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start off by defining the user interface that will wrap the
    AR components. First, we will define a custom control that we will use as a placeholder
    for injecting an `UrhoSurface` that will contain the AR components. Then, we will
    add this control in a grid that will contain some statistics about how many planes
    we have found and how many boxes are active in the world. The goal of the game
    is to find boxes in AR using your phone and tapping on them to make them disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining the custom `ARView` control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ARView control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ARView` control belongs in the shared project, since it will be a part
    of both applications. It's a standard Xamarin.Forms control that inherits directly
    from `Xamarin.Forms.View`. It will not load any XAML (so it will simply be a single
    class), nor will it contain any functionality other than simply being defined,
    so we can add it to the main grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go over to Visual Studio and go through the following three steps to create
    an `ARView` control:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a folder called `Controls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `ARView` in the `Controls` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `ARView` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have created here is a simple class, without implementation, that inherits
    from `Xamarin.Forms.View`. The point of this is to make use of custom renderers
    for each platform, allowing us to specify platform-specific code to be inserted
    at the place in the XAML where we put this control. Your project should now look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dc949c2-7455-4476-b9c9-3b7018741a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ARView` control is no good just sitting there. We need to add it to the
    `MainPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the MainPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be replacing the entire contents of the `MainPage` and adding a reference
    to the `WhackABox.Controls` namespace so that we can use the `ARView` control.
    Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `MainPage.xaml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML to look like the following code. The XAML in bold represents
    the new elements that must be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Now that we have the code, let''s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a controls namespace that points to the `WhackABox.Controls`
    namespace in code. This namespace is used at the end of the XAML to locate the
    `ARView` control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then define the content element by setting it to a `Grid`. A page can only
    have one child, which, in this case, is a `Grid`. The `Grid` defines two columns
    and two rows. The columns split the `Grid` into two equal parts, where we have
    one row that is `100` units high at the top and one row that takes up all the
    available space below it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the top two cells to add instances of `StackLayout` that contain the
    information about the number of planes and the number of boxes in the game. The
    location of those instances of `StackLayout` in the grid is defined by the `Grid.Row=".."`
    and `Grid.Column=".."` attributes. Remember that the rows and columns are zero
    based. You don't actually have to add attributes for row or column `0`, but it
    can sometimes be a good practice to improve code readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the `ARView` control, which resides in row `1` but spans both
    columns by specifying `Grid.ColumnSpan="2"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to install UrhoSharp, which will be our library for rendering
    graphics to represent the augmented part of our reality.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Urhosharp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Urho is an open source 3D game engine. UrhoSharp is a package that contains
    bindings to iOS and Android binaries, enabling us to use Urho in .NET. It is a
    very competent piece of software, and we will only be using a very small part
    of it to do the heavy lifting when it comes to rendering planes and boxes in the
    app. We urge you to find out more about UrhoSharp to add your own cool features
    to the app.
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do to install UrhoSharp is download a NuGet package for each
    platform. The iOS platform uses the UrhoSharp NuGet package, and Android uses
    the UrhoSharp.ARCore package. Also, in Android, we need to add some code to wire
    up life cycle events, but we will get to that later. Basically, we will set up
    an `UrhoSurface` on each platform. We will access this to add nodes to the node
    tree. These nodes will then be rendered based on their type and properties.
  prefs: []
  type: TYPE_NORMAL
- en: First, however, we need to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the UrhoSharp NuGet package for iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we need to do for iOS is to add the UrhoSharp NuGet package. This contains
    everything we need for our AR app. You can add the package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `WhackABox.iOS` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7beed9e8-ee72-4937-8275-18b877598992.png)'
  prefs: []
  type: TYPE_IMG
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `UrhoSharp`in the search box and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the UrhoSharppackage and click `Install` on the right side of the window,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30731bb9-fc86-4d9b-aa35-cbb970ec2fef.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it for iOS. Android is a little bit trickier to set up, since it needs
    a special UrhoSharp package and some code to be written to wire everything up.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the UrhoSharp.ARCore Nuget Package for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Android, we will be adding the UrhoSharp.ARCore package, which contains
    extensions for ARCore. It has a dependency on UrhoSharp, so we don''t have to
    add that package specifically. You can add theUrhoSharp.ARCore package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `WhackABox.Android` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Manage NuGet Packages..., as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39392973-f2c7-4730-8438-00c3ac2c14fd.png)'
  prefs: []
  type: TYPE_IMG
- en: This opens the NuGet Package Manager. Click the Browse link on the top-left
    of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `UrhoSharp.ARCore` in the search box and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the UrhoSharp.ARCore package and click Install on the right side of
    the window, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/54863d4c-bb64-4284-a05e-97865506710e.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it—all your dependencies on UrhoSharp have been installed in the project.
    We now have to wire up some life cycle events.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Android life cycle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, `Urho` needs to know about some specific events and be able to
    respond to them accordingly. We also need to add an internal message using `MessagingCenter`
    so that we can react to the `OnResume` event later on in the app. We will get
    to that when we add the code to initialize ARCore. But for now, add the five required
    overrides for Android events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, open `MainActivity.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the five overrides from the following code anywhere in the `MainActivity`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Resolve the unresolved references by adding `using` statements for `Urho.Droid`
    and `Xamarin.Forms`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The events map one-on-one to internal UrhoSharp events, except for `OnBackPressed`,
    which calls `UrhoSharp.OnDestroy()`. The reason for this is memory management,
    so that UrhoSharp knows when to clean up.
  prefs: []
  type: TYPE_NORMAL
- en: The `MessagingCenter` library is a built-in Xamarin.Forms pub-sub library for
    passing internal messages in an app. It has a dependency on Xamarin.Forms. We
    have created a library of our own called `TinyPubSub` that breaks this dependency
    and has a slightly easier API (as well as some additional features). You can check
    it out on GitHub at [https://github.com/TinyStuff/TinyPubSub](https://github.com/TinyStuff/TinyPubSub).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the PlaneNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `Urho`, you work with scenes that contain a tree of nodes. A node can be
    just about anything in the game, such as a renderer, a sound player, or simply
    a placeholder for subnodes.
  prefs: []
  type: TYPE_NORMAL
- en: As we talked about earlier when discussing AR fundamentals, planes are a common
    entity that is shared between the platforms. We need to create a common ground
    that represents a plane, which we can do by extending an `Urho` node. The position
    and the rotation will be tracked by the node itself, but we need to add a property
    to track the origin and the size of the plane, expressed by ARKit and ARCore as
    the extent of the plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add this class now and put it to use when we implement the AR-related
    code on each platform. The code to do this is straightforward, and can be set
    up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new file called `PlaneNode.cs` in the root
    of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following implementation of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `PlaneId` will be an identifier that allows us to track which platform-specific
    plane this node represents. In iOS, this will be a string, while in Android, it
    will be the hashcode of the plane-object that is converted to a string. The `ExtentY`
    and `ExtentZ` properties represent the size of the plane in meters. We are now
    ready to start creating the game logic and hooking up our application to the AR
    SDKs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom renderers for the ARView control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom renderers are a very smart way of extending platform-specific behaviors
    to custom controls. They can also be used to override behaviors on controls that
    are already defined. In fact, all of the controls in Xamarin.Forms use renderers
    to translate the Xamarin.Forms control into a platform-specific control.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create two renderers, one for iOS and one for Android, that
    initialize the `UrhoSurface` on which we are going to render. The instantiation
    of the `UrhoSurface` differs on each platform, which is why we need two different
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: For iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A custom renderer is a class that inherits from another renderer. It allows
    us to add custom code for important events, such as when an element in XAML is
    created when the XAML file is parsed. Since the `ARView` control inherits from
    the `View`, we will be using the `ViewRenderer` as a base class. Let''s create
    the `ARViewRenderer` by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the iOS project, create a folder called `Renderers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `ARViewRenderer` to that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExportRenderer` attribute registers this renderer to Xamarin.Forms so
    that it knows that when it parses (or compiles) an `ARView` element, it should
    render it using this specific renderer. It takes two arguments: the first is the
    `Control` that we want to register a renderer to and the second is the type of
    the renderer. This attribute must be placed outside the namespace declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ARViewRenderer` class inherits `ViewRenderer<ARView, UrhoSurface>`. This
    specifies which control this renderer is created for and which native control
    it should render. In this case, the `ARView` will be natively replaced by a `UrhoSurface`
    control that in itself is an iOS-specific `UIView`.
  prefs: []
  type: TYPE_NORMAL
- en: We override the `OnElementChanged()` method that is called every time the `ARView`
    element changes, either when it is created or when it is replaced. We can then
    check whether the `Control` property is set. The control is of the `UrhoSurface` type, since
    we declared that in the class definition. If it's `null`, then we make a call
    to `Initialize()` to create it.
  prefs: []
  type: TYPE_NORMAL
- en: The creation is straightforward. We simply create a new `UrhoSurface` control
    and set the native control to this newly created object. We then call the `Show<Game>()`
    method to start the game by specifying which class represents our `Urho` game.
    Note that the `Game` class is not defined yet, but it will be very soon, right
    after we create the custom renderer for Android.
  prefs: []
  type: TYPE_NORMAL
- en: For Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The custom renderer for Android does the same thing as it does for iOS, but
    with the additional step of checking permissions. Let''s create the `ARViewRenderer`
    for Android by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Android project, create a folder called `Renderers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `ARViewRenderer` to that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This custom renderer also inherits from `ViewRenderer<T1, T2>`, where the first
    type is the type of the renderer itself and the second is the native control that
    the renderer will produce. In this case, the native control will be a control
    that inherits from `Android.Views.View`. The renderer creates a `UrhoSurfacePlaceholder`
    instance, which it assigns as the native control. The `UrhoSurfacePlaceholder`
    is a class that wraps some functionality of the **Simple DirectMedia Layer** (**SDL**)
    library that `Urho` uses on Android to access media functionality. The last thing
    it does is to start the game based on the soon-to-exist `Game`class. We will define
    this in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write an application that uses `Urho`, we need to create a class that inherits
    from `Urho.Application`. This class defines some virtual methods that we can use
    to set up the scene. The method we will use is `Start()`. Before that, however,
    we need to create the class. The class will be split into three files using partial
    classes, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Game.cs` file, which will contain code that is cross platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Game.iOS.cs` file, which will contain code that will only be compiled in
    the iOS version of the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Game.Android.cs` file, which will contain code that will only be compiled
    in the Android version of the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using a conditional compile to do so. We discussed conditional compiling
    in the introduction to this project. Simply put, this means that we can use something
    called **preprocessor directives** to determine at compile time whether the code
    should be included. In practice, this means that we will be compiling different
    code in Android and iOS by defining the same `InitializeAR()` method in both `Game.iOS.cs`
    and `Game.Android.cs`. During initialization, we will call this method, and, depending
    on which platform we run it on, it will be implemented differently. This can only
    be done with a shared project.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio has excellent support for conditional compiling and will resolve
    the correct references depending on which project you have set as the startup
    project or what you select in the toolbar above the code file itself.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we could have moved the `Game.iOS.cs` file to the iOS project
    and the `Game.Android.cs` and removed the conditional compile preprocessor statements.
    The app would compile just fine, but for the purposes of learning how this works,
    we will include them in the shared project. This could also be a positive thing,
    since we are gathering related code in one place, making it easier to understand
    the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the shared partial Game class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating the `Game.cs` file that will contain shared code. Let''s
    set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new file called `Game.cs` in the root of
    the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is the `partial` keyword in the class. This indicates
    to the compiler that this is not the entire implementation, and that more code
    will be present in other files. The code in those files will be treated as if
    it were in this file; it's a nice way to split large implementations into different
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The `Game` inherits from `Urho.Application`, which will do most of the work
    regarding the game itself. We define a property called `scene` of the `Scene`type.
    A `Scene` in `Urho` represents one screen of the game (we could have different
    scenes for different parts of a game or for a menu, for example). In this game,
    we will only be defining one scene, which will be initialized later. A `scene`
    maintains a hierarchy of nodes that compose it, and each node can have any number
    of children and any number of components. It's the components that do the work.
    Later on, for example, we will be rendering boxes, which will be represented by
    a node that will have a `Box` component attached.
  prefs: []
  type: TYPE_NORMAL
- en: The `Game` class itself is instantiated from the custom renderers that we defined
    in the earlier section, and it takes an `ApplicationOptions` instance as a parameter
    in the constructor. This needs to be passed to the base class. We now need to
    write some methods that will be AR specific and used by the code we will write
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: CreateSubPlane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first method is the `CreateSubPlane()` method. When the application finds
    a plane on which we can place objects, it will create a node. We will write that
    code specifically for each platform soon. This node also defines a subplane that
    will position a box, representing the position and size of that plane. We have
    already defined the `PlaneNode` class earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the code by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `CreateSubPlane()` method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Any class inheriting from **`Urho.Node`**, such as `PlaneNode`, has the `CreateChild()` method.
    This allows us to create a child node and specify a name for that node. That name
    will be used later on to find specific children to perform operations on. We position
    the node at the same position as the parent node, except that we raise it `0.05`
    meters (5 cm) above the plane.
  prefs: []
  type: TYPE_NORMAL
- en: To see the plane, we add a `box` component with a semitransparent red color.
    The `box` is a component that is created with a call to `CreateComponent()` on
    our node. The color is defined in the AARRGGBB pattern, where AA is the alpha
    component (the transparency) and RRGGBB is the standard red-green-blue format.
    We use hexadecimal representation of the colors.
  prefs: []
  type: TYPE_NORMAL
- en: UpdateSubPlane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both ARKit and ARCore update planes continuously. What we are interested in
    are changes in the position of a subplane and the extent of it. By extension,
    we are referring to the size of the plane. Let''s set this up by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UpdateSubPlane()` method in the code anywhere in the `Game.cs` class,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The method takes the `PlaneNode` that we want to update, along with a new position
    for it. We locate the subplane by querying the current node for any node called
    `"subplane"`. Remember that we named the subplane in the `AddSubPlane()` method.
    We can now easily access the node by name. We update the scale of the subplane
    node by taking the `ExtentX` and `ExtentZ` properties from the `PlaneNode`. The
    plane node will be updated by some platform-specific code before we call `UpdateSubPlane().` Finally,
    we set the position of the subplane to the passed `position `parameter.
  prefs: []
  type: TYPE_NORMAL
- en: FindNodeByPlaneId
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a method to quickly find nodes. Both ARKit and ARCore keep an internal
    track of their planes, and to map those internal representations of planes to
    our `PlaneNode`, we have to assign a custom ID to a plane when it's created. This
    will be done in the platform-specific code, but we can still write the function
    to query the scene for `PlaneNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlaneNode` is a `string`, since ARKit defines the plane ID in a form that
    resembles a **Global Unique Identifier** (**GUID**). A GUID is a structured sequence
    of hexadecimal numbers that can be represented in a `string` format, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method queries the scene by using `Linq` and looks for the first child with
    the plane ID that it was given. If it can't find one, it returns `null`, since
    `null` is the default value of a reference type object.
  prefs: []
  type: TYPE_NORMAL
- en: These are all of the methods that we need in the shared code before dropping
    down into ARKit and ARCore.
  prefs: []
  type: TYPE_NORMAL
- en: Adding platform-specific partial classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to take advantage of conditional compiling. We will create two
    partial classes, one for iOS and one for Android, that will be conditionally compiled
    into the `Game` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will simply set up the skeleton code for these files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the iOS-specific partial class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `partial` class for `Game` on iOS and wrapping
    the whole code file within a preprocessor directive that specifies that this code
    will only be compiled on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a new file called `Game.iOS.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and `partial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `#if`and `#endif` preprocessor directives to allow for conditional
    compiling, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code is a preprocessor directive that the compiler will use
    to determine whether the code within the `#if` and `#endif` directives should
    be included in the compilation. If it is included, a `partial` class will be defined.
    The code in this class can be iOS specific, even though we are defining it in
    the shared project. Visual Studio is smart enough to treat any code within this
    section as if it were present directly in the iOS project. There will be no problem
    with instantiating a `UIView` here, since the code will never be compiled for
    any platform other than iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Android-specific partial class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same goes for Android: only the name of the file and the preprocessor directive changes.
    Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, add a new file called `Game.Android.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the class `Game` in the code, if Visual Studio doesn't do it automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the class `public` and `partial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `#if` and `#endif` conditional compile statements, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with iOS, only code for Android will ever be compiled between the `#if` and
    `#endif` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now start adding some platform-specific code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the ARKit-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write the platform-specific code for iOS that will
    initialize ARKit, find planes, and create nodes for UrhoSharp to render on the
    screen. We will be taking advantage of an `Urho` component that wraps ARKit in
    iOS. We will also be writing all the functions that will position, add, and remove
    nodes. ARKit uses  `anchors`, which act as virtual points that glue the overlaid
    graphics to the real world. We are specifically looking for `ARPlaneAnchor`, which represents
    a plane in the AR world. There are other types of anchors available, but for this
    app, we only need to find horizontal planes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start off by defining the `ARKitComponent` so that we can use it later.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ARKitComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by adding a `private` field to an `ARKitComponent` that will be initialized
    later on. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open `Game.iOS.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `private` field that holds an `ARKitComponent`, as shown in bold in the
    following code :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you add all the `using` statements to ensure that all the code
    we later use resolves the correct types.
  prefs: []
  type: TYPE_NORMAL
- en: Writing handlers for adding and updating anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now add the necessary code that will add and update anchors. We will
    also add some methods to help set the orientation of the nodes after ARKit updates
    the anchors.
  prefs: []
  type: TYPE_NORMAL
- en: SetPositionAndRotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SetPositionAndRotation()` method will be used by both the add and update
    anchors, so we need to define it before creating the handlers for the events that
    will be raised by ARKit. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The method takes two parameters. The first is an `ARPlaneAnchor` defined by
    ARKit and the second is the `PlaneNode` that we have in the scene. The purpose
    of the method is to make sure that the `PlaneNode` is in sync with the `ARPlaneAnchor`
    object passed by ARKit. The `arkitComponent` has a helper method called `ApplyOpenTkTransform()`
    to translate the position and rotation of the `ARPlaneAnchor` object into the
    position and rotation objects used by `Urho`. We then update the `Extent` (size)
    of the plane to the `PlaneNode` and get the `anchor` center position from the
    `ARPlaneAnchor`. Finally, we call a method that we defined earlier to update the
    subplane node that holds the `Box` component that will do the actual rendering
    of the plane as a semitransparent red box.
  prefs: []
  type: TYPE_NORMAL
- en: We need one more method to handle the update and add functionality.
  prefs: []
  type: TYPE_NORMAL
- en: UpdateOrAddPlaneNode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UpdateOrAddPlaneNode()` does exactly what the name implies: it takes an
    `ARPlaneAnchor` as an argument and either updates or adds a new `PlaneNode` to
    the `scene`. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `UpdateOrAddPlaneNode()` method, as described in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A node is either already present in the scene or it needs to be added. The first
    line of code calls the `FindNodeByPlaneId()` to query the scene for an object
    with the given `PlaneId`. For iOS, we use the `anchor.Identifier` property to
    track planes defined by iOS. If this call returns `null`, it means that the plane
    is not present in the scene and we need to create it. To do this, we instantiate
    a new `PlaneNode`, giving it a `PlaneId` and a user-friendly name for debugging
    purposes. We then create the subplane to visualize the plane itself by calling
    `CreateSubPlane()`, which we defined earlier, and add the node to the `scene`. Lastly,
    we update the position and rotation. We do this for every call to the `UpdateOrAddPlaneNode()`
    method, since it's the same for both new and existing nodes. It's now time to
    write the handlers that we will eventually hook up to ARKit directly.
  prefs: []
  type: TYPE_NORMAL
- en: OnAddAnchor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add some code. The `OnAddAnchor()` method will be called each time ARKit updates
    its collection of anchors that describe points that we will use to relate to within
    our virtual world. We are specifically looking for anchors of the `ARPlaneAnchor` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `OnAddAnchor()` method to the `Game.iOS.cs` class by going through
    the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnAddAnchor()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The method takes an array of `ARAnchors` as a parameter. We filter out the anchors
    that are of the `ARPlaneAnchor` type and iterate through the list. For each `ARPlaneAnchor`,
    we call the `UpdateOrAddPlaneNode()` method that we created earlier to add a node
    to the scene. Let's now do the same for when ARKit wants to update anchors.
  prefs: []
  type: TYPE_NORMAL
- en: OnUpdateAnchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each time ARKit receives new information about an anchor, it will call this
    method. We do the same as we did with the previous code and iterate through the
    list to update the extent and position of the `anchor` in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnUpdateAnchors()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code is a copy of the `OnAddAnchors()` method. It updates all nodes in the
    scene based on the information provided by ARKit.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to write some code to remove the anchors that ARKit has removed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a handler for removing anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When ARKit decides that an anchor is invalid, it will remove it from the scene.
    This does not happen very often, but it's a good practice to handle this call
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: OnRemoveAnchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a method to handle the removal of an `ARPlaneAnchor` by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnRemoveAnchors()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with the `Add` and `Remove` functions, this method accepts an array of `ARAnchor`.
    We iterate through this array, looking for anchors of the `ARPlaneAnchor` type.
    We then look for a node that represents this plane by calling the `FindNodeByPlaneId()`
    method. If it's not `null`, then we call for that node to be removed. Note the
    null-check operator before the `Remove()` call.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing ARKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now come to the last part of the iOS-specific code, which is where we
    initialize ARKit. This method is called `InitializeAR()`, and takes no parameters.
    It is the same as the method for Android, but since they are never compiled simultaneously
    because of the use of conditional compiling, the code calling this method will
    not know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to initialize ARKit is straightforward, and the `ARKitComponent` does
    a lot of work for us. Let''s set it up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.iOS.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by creating an `ARKitComponent`. We then set the allowed orientation
    and create an `ARWorldTrackingConfiguration` class that states that we are only
    interested in horizontal planes. To respond to the addition, updating, and removal
    of planes, we attach the event handlers we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We instruct the ARKit component to delay calling the callbacks to allow ARKit
    to initialize properly. Note the spelling error in the `RunEngineFramesInARKitCallbakcs`
    property. This is a good example of why you need to carry out a review of your
    code, since it will be hard to change this name without breaking backward compatibility.
    Naming is hard.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing is to tell ARKit to start running. We do this by calling the `arkitComponent.Run()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Writing ARCore-specific code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to do the same for Android with ARCore. Just as with iOS, we are
    going to put all Android-specific code in a file of its own. This file is the
    `Game.Android.cs` that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ARCoreComponent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we are going to add a field that stores a reference to the `ARCoreComponent`.
    This wraps most of the interaction with ARCore. The `ARCoreComponent` is defined
    in the UrhoSharp.ARCore NuGet package that we installed at the beginning of the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some `using` statements and the field by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `arCore`private field, as described in the following code. Also, make
    sure that you add the `using` statements marked in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `using` statements will allow us to resolve the types that we need in this
    file and the `arCore` property will be a shorthand when we want to access ARCore
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We'll continue by adding some methods to this class.
  prefs: []
  type: TYPE_NORMAL
- en: SetPositionAndRotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to add or update a `PlaneNode` whenever a plane is detected or updated.
    The `SetPositionAndRotation()` method updates the passed `PlaneNode` and sets
    properties on that node based on the content of the `AR.Core.Plane` object. Let''s
    set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SetPositionAndRotation()` method to the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous code updates the extent of the plane for the node and creates a
    rotation, `Quaternion`. Don't worry if you don't know what a `Quaternion` is—few
    people do—but they seem to magically hold the rotation information of the model
    in a very flexible way. The `plane.CenterPose` property is a matrix that holds
    the position and orientation of the plane. Finally, we update the position of
    the node from the `CenterPose` property.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create a method that handles frame updates from ARCore.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a handler for ARFrame updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android handles updates from ARCore a little bit differently than ARKit, which
    exposes three different events for added, updated, and removed nodes. When using
    ARCore, we get called whenever any changes occur, and the handler that will take
    care of this is the one we are about to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the method by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnARFrameUpdated()` method anywhere in the class, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start by querying the `arCore` component for all the planes that it keeps
    track of. We then iterate through this list and see whether we have any nodes
    in the scene by calling the `FindNodeByPlaneId()` method, using the hash code
    of the plane as the identifier. If we can't find any, we create a new `PlaneNode`
    and assign the hash code as the `PlaneId`. We then create a subplane that contains
    the `Box` component to visualize the plane, and, finally, we add it to the scene. We
    then update the position and the rotation of the plane and make a call to update
    the subplane as well. Now that we have the handler written, we need to hook it
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing ARCore
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To initialize ARCore, we will add two methods. The first one is a method that
    will take care of the configuration of ARCore, called `OnConfigRequested()`. The
    second one is the `InitializeAR()` method that will be called from the shared
    `Game` class later on. This method is also defined in the iOS-specific code, but,
    as we talked about earlier, this method in iOS will never be compiled when we
    compile for Android, since we are using conditional compiling, which filters out
    code from the platform that isn't selected.
  prefs: []
  type: TYPE_NORMAL
- en: OnConfigRequested
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ARCore needs to know a few things, just like iOS. In Android, this is done
    by defining a method that the ARCore component will call upon initialization.
    To create the method, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnConfigRequested()` method anywhere in the class, as shown in the 
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The method takes a `Config` object, which will store any configuration you make
    in this method. First, we set which type of plane we want to find. We are interested
    in `Horizontal` planes for this game. We define which kind of light-estimation
    mode we want to use and, finally, we select which update mode we want. In this
    case, we want to use the latest camera image available. You can do a lot of fine-tuning
    during configuration, but this is out of the scope of this book. Be sure to check
    out the documentation for ARCore to learn more about its awesome power.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the code we need to initialize ARCore.
  prefs: []
  type: TYPE_NORMAL
- en: InitializeAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `InitializeAR()` method shares the same name as
    the iOS-specific code, but the compiler will only include one of them in the build
    because of the use of conditional compiling. Let''s set this up by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.Android.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeAR()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to create the `ARCoreComponent` provided by UrhoSharp. This
    component wraps the initialization of the native ARCore classes. We then add two
    event handlers: one for taking care of frame updates and one that will be called
    during initialization. The last thing we do is call the `Run()` method on the
    `ARCoreComponent` to start tracking the world.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both ARKit and ARCore configured and ready to go, it's time
    to write the actual game.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will initialize `Urho` by setting up the camera, lighting,
    and a renderer. The camera is the object that determines where objects will be
    rendered. The AR components take care of updating the position of the camera to
    virtually track your phone so that any object we render will be in the same coordinate
    space as what you are looking at. First, we need a camera that will be the viewing
    point of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a camera is a straightforward process, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `camera` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeCamera()` method anywhere in the class, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In UrhoSharp, everything is a node just like everything is a GameObject in Unity,
    including the `camera`. We create a new node, which we call `camera`, and then
    we create a `Camera` component on that node and keep the reference to it for later
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UrhoSharp needs to render the scene to a `viewport`. A game can have multiple
    viewports, based on multiple cameras. Think of a game where you drive a car. The
    main `viewport` will be the game from the perspective of the driver. Another `viewport`
    might be the rear-view mirrors, which would actually be cameras themselves that
    render what they see on to the main `viewport`. Let''s set this up by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `viewport` property to the class, as shown in the following code. You
    should place it right after the declaration of the class itself, but placing it
    anywhere within the class will work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeRenderer()` method anywhere in the class, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `viewport` property will hold a reference to the `viewport` for later use. The
    `viewport` is created by instantiating a new `viewport` class. The constructor
    of that class needs a `Context` provided by the base class, the `scene` that we
    will create while initializing the game, a camera to know which point in space
    to render from, and a render path, which we default to `null`. A render path allows
    for post-processing of the frame created while rendering. This is also outside
    the scope of this book, but it is worth checking out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let there be light.
  prefs: []
  type: TYPE_NORMAL
- en: Adding lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make objects visible, we need to define some lighting. We do this by creating
    a method that defines which type of lighting we want in the game. Let''s set this
    up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `InitializeLights()` method anywhere in the class, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Again, everything in UrhoSharp is a node, and lights are no exception to that
    rule. We create a generic node on the camera node by accessing the stored camera
    component and accessing the node it belongs to. We then set a direction of that
    node and create a `Light` component to define a light. The range of the light
    will be 10 units in length. The type is directional, meaning that it will shine
    from the position of the node in its defined direction. It will also cast shadows.
    We set the `ShadowMapSize` to four times the default value to give the shadow
    map some more resolution.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have all we need to initialize UrhoSharp and the AR components.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the game startup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The base class of the `Game` class provides some virtual methods that we can
    override. One of these is `Start()`, which will be called shortly after the custom
    renderer has set up the `UrhoSurface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the method by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Start()` method anywhere in the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The scene that we have been talking about is created here in the first line
    of the method. This is the scene that we look at when UrhoSharp is running. It keeps
    track of all nodes that we add to it. All 3D games in UrhoSharp need an `Octree`,
    which is a component that implements spatial partitioning. It is used by the 3D
    engine to quickly find objects in a 3D space without having to query every single
    one in each frame. The second line of the method creates this component directly
    on the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we have the four methods that initialize the camera, the lights,
    and the renderer, and that make a call to one of the two `InitializeAR()` methods,
    based on which platform we are compiling for. If you start the app at this point,
    you should see that it finds planes and renders them, but that nothing more happens.
    It's time to add something to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Adding boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to focus on adding virtual boxes to our augmented world. We
    are going to write two methods. The first one is the `AddBox()` method, which
    will add a new box at a random position on a plane. The second is an override
    of the `OnUpdate()` method that UrhoSharp calls with each frame to perform game
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: AddBox()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add boxes to a plane, we need to add a method to do so. This method is called
    `AddBox()`. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `random` property to the class (preferably at the top, but anywhere
    in the class will work).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `AddBox()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The static `random` object that we create will be used for randomizing the location
    of a box on a plane. We want to use a static `Random` instance, since we don't
    want to risk creating multiple instances that may be seeded with the same value,
    and that therefore return the exact same sequence of random numbers. The method
    starts by finding the subplane child of the `PlaneNode` instance that we pass
    in by calling `planeNode.GetChild("subplane")`. We then create a node that will
    render the box. To make the box fit the world, we need to set the scale to `0.1`,
    which will make it 10 cm in size.
  prefs: []
  type: TYPE_NORMAL
- en: We then randomize the position of the box using the `ExtentX` and `ExtentZ`
    properties, multiplied by a new random value between `0` and `1` that we first
    subtract `0.5` from. This is to center the position, since the position of the
    parent node is the center of the plane. Then, we set the position of the box node
    at the randomized position and 0.1 units above the plane. We also need to add
    the subplanes position, since it might be a little bit offset from the parent
    node. Finally, we add the actual box to be rendered and set the color to blue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add code to call the `AddBox()` method, based on some game logic.
  prefs: []
  type: TYPE_NORMAL
- en: OnUpdate()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most games use a game loop. This calls an `Update()` method, which takes an
    input and calculates the state of the game. UrhoSharp is no exception. The base
    class of our game has a virtual `OnUpdate()` method that we can override so that
    we can write code that will be executed with each frame. This method is called
    frequently, usually about 50 times per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now override the `Update()` method to add game logic that adds a new
    box every other second. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `newBoxTtl` field and the `newBoxIntervalInSeconds` field to the class
    at the top of the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnUpdate()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first field, `newBoxTtl` where `Ttl` is **time to live** (**TTL**), is an
    internal counter that will be reduced by the number of milliseconds that have
    passed since the last frame. When it fall below `0`, we will add a new box to
    each plane of the scene. We find all instances of `PlaneNode` by querying the
    `Children` collection of the scene and returning only the children of the `PlaneNode`
    type. The second field, `newBoxIntervalInSeconds`, indicates how many seconds
    we will add to the `newBoxTtl` once it reaches `0`. To know how much time has
    passed since the last frame, we use the `timeStep `parameter that is passed into
    the `OnUpdate()` method by UrhoSharp. The value of this parameter is the number
    of seconds since the last frame. It's usually a small value, which will be something
    like `0.016` if the update loop runs at 50 frames per second. It could vary though,
    which is why you will want to use this value to carry out the subtraction from
    `newBoxTtl`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, you will see that boxes appear on the detected planes.
    We still cannot interact with them, however, and they look pretty boring. Let's
    continue by making them rotate.
  prefs: []
  type: TYPE_NORMAL
- en: Making boxes rotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add your own components to UrhoSharp by creating a class that inherits
    from `Urho.Component`. We will be creating a component that will make the boxes
    spin around all three axes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the rotate component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned, a component is a class that inherits from `Urho.Component`.
    This base class defines a virtual method called `OnUpdate()` that behaves the
    same way as the `Update()` method on the `Game` class itself. This allows us to
    add logic to the component so that it can modify the state of the node it belongs
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `rotate` component by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `Rotator.cs` in the root
    of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `RotationSpeed` property will be used to determine the speed of rotation
    around any specific axis. It will be set when we assign the component to the box
    node in the next step. To enable the component to receive calls to the `OnUpdate()`
    method on each frame, we need to set the `ReceiveSceneUpdates` property to `true`.
    If we don't do this, the component will not be called by UrhoSharp at each update.
    It's set to `false` by default for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: All the fun happens in the `override` of the `OnUpdate()` method. We create
    a new quaternion to represent a new rotation state. Again, we don't need to know
    how this works in detail, only that quaternions belong to the mystical world of
    advanced mathematics. We multiply each axis in the `RotationSpeed` vector by the
    `timeStep` to generate a new value. The `timeStep` parameter is the number of
    seconds that have passed since the last frame. We also define the rotation as
    being around the local coordinate space of this box.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the component is created, we need to add it to the boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the Rotator component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding the `Rotator` component is as simple as adding any other component.
    Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AddBox()` method by adding the code marked in bold in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We begin by defining how we want the box to rotate by creating a new `Vector3`
    struct and assigning it to a new variable called `rotationSpeed`. In this case,
    we want it to rotate `10` units around the *x *axis, `20` units around the *y *axis,
    and `30` units around the *z *axis. We use the `rotationSpeed` variable to set
    the `RotationSpeed` property of the `Rotator` component that we instantiate in
    the second row of the code we added.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we add the component to the `box` node. The boxes should now rotate
    in an interesting way.
  prefs: []
  type: TYPE_NORMAL
- en: Adding box hit-test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have rotating boxes that keep piling up. We need to add a way to remove
    boxes. The simplest thing would be to add a feature that removes boxes when we
    touch them, but we are going to make it a little fancier than that: whenever we
    touch a box, we want it to shrink and disappear before we remove it from the scene.
    To do this, we are going to use our newly acquired knowledge of components and
    then add some code to determine whether we are touching a box.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a death animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Death` component that we are about to add has the same template as the
    `Rotator` component that we created in the last section. Let''s add it by going
    through the following steps and taking a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `Death.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code in the class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We first define two fields. The `deathTtl` field determines how long the animation
    will be in seconds. The `initialScale` field keeps track of the scale of the node
    when the component is attached to the node. To receive updates, we need to set
    `ReceiveSceneUpdates` to `true` in the constructor. The overridden `OnAttachedToNode()`
    method is called when the component is attached to a node. We use this method
    to set the `initialScale` field. After the component is attached, we start getting
    calls on each frame to `OnUpdate()`. On each call, we set a new scale of the node
    based on the `deathTtl` field multiplied by the `initialScale`field. When the
    `deathTtl` field reaches zero, we remove the node from the scene. If we don't
    reach zero, then we subtract the amount of time since the last frame was called,
    which is given to us by the `timeStep` parameter. All we need to do now is figure
    out when to add the `Death` component to a box.
  prefs: []
  type: TYPE_NORMAL
- en: DetermineHit()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a method that can interpret a touch on the 2D surface of the screen
    and figure out which boxes we are hitting using an imaginary ray travelling from
    the camera toward the scene we are looking at. This method is called `DetemineHit`.
    Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `DetemineHit()` method anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `x` and `y` parameters that are passed into the method range from `0` to
    `1`, where `0` represents the left edge or top edge of the screen and `1` represents
    the right edge or bottom edge of the screen. The exact center of the screen would
    be `x=0.5` and `y=0.5`. Since we want to get a ray from the camera, we can use
    a method directly on the camera component called `GetScreenRay()`. It returns
    a ray from the camera in the scene in the same direction that the camera is set
    to. We use this ray and pass it to the `Octree` component's `RaycastSingle()`
    method, which returns a result that will contain a single node, if one is hit.
  prefs: []
  type: TYPE_NORMAL
- en: We examine the results, perform multiple null checks, and finally check whether
    the name of the node starts with `Box`. If this is true, we check to see whether
    the box we hit is already doomed by examining whether there is a `Death` component
    attached. If there is, we `return`. If there isn't, we create a `Death` component
    and leave the box to die.
  prefs: []
  type: TYPE_NORMAL
- en: This all looks good so far. We now need something to call the `DetermineHit()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: OnTouchBegin()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Touches are handled as events in UrhoSharp, and this means that they require
    event handlers. Let''s create a handler for the `TouchBegin` event by going through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `OnTouchBegin()` method anywhere in the code, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When a touch is registered, this method will be called and information about
    that touch event will be sent as a parameter. This parameter has an `X` and a `Y`
    property, which represent the point on the screen that we have touched. Since
    the `DetermineHit()` method wants the values in the range of `0` to `1`, we need
    to divide the `X` and `Y` coordinates by the width and height of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Once that is done, we call the `DetermineHit()` method. To complete this section,
    we just have to wire up the event.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All that''s left now is to wire up the event to the `Input` subsystem of UrhoSharp.
    This is done by adding a single line of code to the `Start()` method, as shown
    in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Start()` method, add the code highlighted in bold in the following
    code fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This wires up the `TouchBegin` event to our `OnTouchBegin` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the game now, the boxes should animate and disappear when you tap
    on them. What we need now is some kind of statistic that shows how many planes
    there are and how many boxes are still alive.
  prefs: []
  type: TYPE_NORMAL
- en: Updating statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the chapter, we added some controls to the XAML that displayed
    the number of planes and boxes that were present in the game. It's now time to
    add some code to update those numbers. We will be using internal messaging to
    decouple the game from the Xamarin.Forms page that we use to display this information.
  prefs: []
  type: TYPE_NORMAL
- en: The game will send a message to the main page that will contain a class that
    has all the information we need. The main page will receive this message and update
    the labels.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a statistics class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use `MessagingCenter` in Xamarin.Forms, which allows us to
    send an object along with the message. We need to create a class that can carry
    the information we want to pass. Let''s set this up by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, create a new class called `GameStats.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The class will be a simple data carrier that indicates how many planes and boxes
    we have.
  prefs: []
  type: TYPE_NORMAL
- en: Sending updates via MessagingCenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a node is created or removed, we need to send statistics to anything that
    is listening. To do this, we need a new method that will go through the scene
    and count how many planes and boxes we have, and then send a message. Let''s set
    this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs`file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method called `SendStats()` anywhere in the class, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The method checks all children of the `scene` object to find nodes of the `PlaneNode`
    type. We iterate through all of these nodes and count how many of the node's children
    have the name `Box`, and then indicate this number in a variable called `boxCount`.
    When we have this information, we create a `GameStats` object and initialize it
    with the box count and the plane count.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to send the message. We have to make sure that we are using
    the UI thread (the `MainThread`) since we are going to update the GUI. Only the
    UI thread is allowed to touch the GUI. This is done by wrapping the `MessagingCenter.Send()`
    call in `BeginInvokeOnMainThread().`
  prefs: []
  type: TYPE_NORMAL
- en: The message that is sent is `stats_updated`. It contains the stats information
    as an argument. Let's now make use of the `SendStats()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The scene has a lot of events that we can wire up. We will hook up to `NodeAdded`
    and `NodeRemoved` to determine when we need to send statistics information. Let''s
    set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `Game.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Start()` method, add the code that is highlighted in bold in the following
    fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Each time a node is either added or removed, a new message will be sent to the
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be the last method we add to the game. It handles the information updates
    and also updates the labels in the GUI. Let''s add it by going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a method called `StatsUpdated()` anywhere in the code, as shown in the
    following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The method receives the `GameStats` object that we sent and updates the two
    labels in the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to the updates in the MainForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last line of code to add will wire up the `StatsUpdated` handler to an
    incoming message. Let''s set this up by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WhackABox` project, open the `MainPage.xaml.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the constructor, add the line of code that is highlighted in bold in the
    following fragment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This line of code hooks up an incoming message with the content `stats_updated`
    to the `StatsUpdated` method. Now run the game and go out into the world to hunt
    down those boxes!
  prefs: []
  type: TYPE_NORMAL
- en: 'The completed app looks something like the following screenshot, with spinning
    boxes popping up at random locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b06e11ed-7438-49eb-b0c0-2de12f314dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to integrate AR into Xamarin.Forms by using
    custom renderers. We took advantage of UrhoSharp to use cross-platform rendering,
    components, and input management to interact with the world. We also learned a
    bit about `MessagingCenter`, which can be used to send internal in-process messages
    between different parts of an application to reduce coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to dive into machine learning and create an app that can
    recognize a hotdog in an image.**
  prefs: []
  type: TYPE_NORMAL
