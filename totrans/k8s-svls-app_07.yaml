- en: Apache OpenWhisk and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at Apache OpenWhisk. While not strictly
    a Kubernetes-only project, like, say, Kubeless and Fission (which are covered
    in the next chapter), it can be deployed on, and take advantage of, Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to be looking at three main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Apache OpenWhisk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Apache OpenWhisk locally using Vagrant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Apache OpenWhisk on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by finding out more about OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: Apache OpenWhisk overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache OpenWhisk is an open source, serverless cloud computing platform, designed
    to work in a similar way to all the tools we have been covering in other chapters
    of this book. Apache OpenWhisk started off life as, and continues to be, Functions
    as a Service part of IBM's public cloud offering, Bluemix.
  prefs: []
  type: TYPE_NORMAL
- en: 'It had its general availability release in December 2016\. The press release
    that accompanied the announcement had a quote from Luis Enriquez who is the Head
    of Platform Engineering and Architecture at Santander Group, one of the customers
    who had been using IBM Cloud Functions while it was in closed beta, Luis said:'
  prefs: []
  type: TYPE_NORMAL
- en: “Microservices and containers are changing the way we build apps, but because
    of serverless, we can take that transformation even further, OpenWhisk provides
    the instant infrastructure we need for intense tasks and unexpected peaks in workload,
    and is a key building block as we move to a real-time and event-driven architecture.”
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, this sounds a lot like Lambda from AWS and Microsoft
    Azure Functions—what sets IBM's service apart from its competitors is that IBM
    has submitted OpenWhisk to the Apache Incubator, this is the entry point for all
    externally developed projects to become part of The Apache Software Foundation
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache Software Foundation was founded in 1999 as a charitable organization
    that oversees the development and management of well over 350 open source software
    projects, which it does for the public good.
  prefs: []
  type: TYPE_NORMAL
- en: So why would IBM do this? Well, not only is IBM a gold sponsor of The Apache
    Software Foundation, it makes sense for them to open-source their Functions as
    a Service offering as it makes it the only public cloud offering where you can
    avoid vendor lock-in, as you can run Apache OpenWhisk locally or on your own hardware
    or virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: This gives you the freedom to run and deploy Apache OpenWhisk anywhere you like.
    However, if you would like to run it to scale like the Santander Group is, then
    you have the option of running it on an enterprise-class public cloud supported
    by IBM.
  prefs: []
  type: TYPE_NORMAL
- en: Running Apache OpenWhisk locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to be looking at running Apache OpenWhisk locally first. We will
    do this by using a combination of VirtualBox, which we installed in [Chapter 3](7836cfd9-bce3-4d77-9331-f8dda5a31999.xhtml),
    *Installing Kubernetes Locally*, and Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we launch our local Apache OpenWhisk server we need to install Vagrant,
    which is developed by HashiCorp. The best way I can describe Vagrant is as an
    open source, virtual machine manager, where your machine configuration is written
    using an easy-to-follow text configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Vagrant is quite simple. On macOS 10.13 High Sierra we can use Homebrew
    and Cask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running Windows 10 Professional you can use Chocolatey and run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you are running Ubuntu 17.04 you can install Vagrant directly from
    the core Ubuntu repositories by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please note, the version supplied by Ubuntu may be a little behind the versions
    installed using Homebrew and Chocolatey; however for our purposes, this should
    not present any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your Vagrant installation by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will create a basic Vagrantfile in the `vagrant-test` folder,
    which uses the official 64-bit Ubuntu 16.04 LTS (Xenial) image from the Vagrant
    website ([https://app.vagrantup.com/ubuntu/boxes/xenial64/](https://app.vagrantup.com/ubuntu/boxes/xenial64/)),
    downloads the image, launches a virtual machine using VirtualBox, configures networking,
    and exchanges keys with the server before finally mounting the current folder
    within the virtual machine at `/vagrant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/706d484d-29b9-4a27-821a-34156e2e7a80.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All of this is defined using the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the Vagrantfile you will notice that there are quite a few configuration
    options, such as the RAM and CPU allocations, networking, and scripts, which are
    executed once the virtual machine has successfully launched. You can run the following
    command to SSH into your Vagrant virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are running Windows 10 Professional you are going to have to install
    an SSH client. Vagrant will give you some options on how to do this when you execute
    the preceding command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following command will power down your virtual machine and remove
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/2ec7c6d5-556c-4acb-a9c1-ff59c3b362c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I would also recommend clearing your working folder by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Vagrant installed, and have quickly looked at how we can launch
    and interact with a virtual machine, we can now look at using it to launch our
    own local installation of Apache OpenWhisk.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and configuring Apache OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already mentioned, Apache OpenWhisk ships with a Vagrantfile that
    contains all of the commands to deploy a local Apache OpenWhisk installation from
    scratch. To download the Apache OpenWhisk repository and deploy the virtual machine,
    run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This process will take anywhere up to 30 minutes depending on the speed of
    your internet connectivity; you can find a copy of the Vagrantfile at the following
    URL: [https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile](https://github.com/apache/incubator-openwhisk/blob/master/tools/vagrant/Vagrantfile).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is just short of 200 lines long, which is a lot different
    from the three lines in our test Vagrantfile from the last section. The Vagrantfile
    uses a combination of bash scripts and Ansible to launch, install, and configure
    our Apache OpenWhisk virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is is an orchestration/configuration tool from Red Hat. It allows you
    to easily define your deployments in human-readable code, be it interacting with
    APIs to launch your infrastructure or logging in to servers and executing tasks
    against them to install and configure your software stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the process, it will execute a basic hello world check as seen
    in the following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ea18a54-5a0d-417d-8a2b-b5a55316388b.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we move on, make a note of the output, which starts with the `wsk property
    set` command. We will need this to configure the local client, which we are going
    to look at installing next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Apache OpenWhisk client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each Apache OpenWhisk comes with a download page for the macOS, Windows, and
    Linux versions of the Apache OpenWhisk client. You can access this from your local
    installation at the following URL: [https://192.168.33.13/cli/go/download/](https://192.168.33.13/cli/go/download/)
    or IBM at: [https://openwhisk.ng.bluemix.net/cli/go/download/](https://openwhisk.ng.bluemix.net/cli/go/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: As your local installation is using a self-signed SSL certificate, you may receive
    warnings when opening it in your browser. You will need to accept these warnings
    to proceed to the site. This process varies depending on your browser so you will
    need to follow the on-screen prompts to progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the client on macOS 10.13 High Sierra we simply need to run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will download the binary using `curl` and ignore the self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download on Windows 10 Professional, run the following. I would recommend
    downloading from IBM to avoid problems with the self-signed SSL certificate and
    PowerShell. To do this, first of all open a PowerShell window as an admin user.
    You can do this by selecting Run as Administrator from the PowerShell menu in
    the taskbar. Once open, you should see that you are in the `C:\WINDOWS\system32`
    folder; if you aren''t then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the macOS version, you can check that the client is installed by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on Ubuntu 17.04 you need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded and made executable you should be able to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the client installed we need to authenticate against our installation.
    To do this, run the command you made a note of at the end of the last section,
    minus the `--namespace guest` part. For me, this command was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you didn''t make a note, then you can dynamically pass the authorization
    token by running the following command from the folder you launch the Vagrant
    virtual machine from, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t run it from the folder you launched the machine from, the `vagrant
    ssh` command will fail, as it will not be able to find your machine configuration.
    Now that your local client is authenticated against your local installation of
    Apache OpenWhisk, we can execute the same hello world command that was run by
    the automation installation by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the message `hello` as per the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0a257e48-106c-4f26-9d5f-5e4a2dc1d523.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our local client, we can look at downloading and executing
    another example.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now deploy a more complex solution rather than just using the inbuilt
    `echo` utility to return a message. In a similar way to the previous hello world
    scripts we used, we are going to deploy a function, written in Node.js, that takes
    an input and displays it back to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a working directory, create a file that contains the following
    code and call it `hello.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the function that we are going to deploy, we first of all
    need to create a package, and then create the action that is exposed to the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the package and action, your Terminal should look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a8650b61-bd51-42d4-b5b3-d28e9c717fbd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that your function can be called using your browser at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications](https://192.168.33.13/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ef84888e-ce81-46cd-8bf5-cb91efbfe399.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see more information using HTTPie on macOS or Ubuntu by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the headers and also the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/950b8f7d-cf0d-44fd-8d66-e9151b0d01dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can list packages and actions, and remove them by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/186756db-fc2d-4231-a590-d8e4b7de57a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Feel free to have a play with your local installation of Apache OpenWhisk;
    there are more examples at the Awesome OpenWhisk page, which you can find at:
    [https://github.com/apache/incubator-openwhisk-external-resources/](https://github.com/apache/incubator-openwhisk-external-resources/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished with your local installation, you can run the following
    command to stop and destroy the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you must be in the `openwhisk/tools/vagrant/` folder to run this command
    otherwise Vagrant will not be able to find your virtual machine configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have installed and interacted with Apache OpenWhisk locally, let's
    look at deploying it on Kubernetes in a public cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Running Apache OpenWhisk on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an idea of how to interact with Apache OpenWhisk and the basic
    concepts behind it, we can look at deploying a copy on top of a Kubernetes cluster.
    To do this, I am going to launch a three-node cluster in Google Cloud by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the cluster is up-and-running, you can check that you can see three nodes
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/75a05a0d-c6bb-492a-a686-963bb127ca3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have our Kubernetes, we can progress with the Apache OpenWhisk deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the configuration needed to deploy Apache OpenWhisk on Kubernetes is
    available on GitHub, so before we start our deployment we should clone the repository
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a copy of the repository, we can make a start on deploying
    the individual components needed to run Apache OpenWhisk. To start with, we need
    to create a namespace called `openwhisk`. To do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start our deployment by launching CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: CouchDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy CouchDB, run the following command from within the `openwhisk-kube`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a pod running CouchDB using the parameters defined in the
    `couchdb.yml` file. You can check that everything is OK with the deployment by
    getting the name of the pod. You can do this by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the name, which for me was `couchdb-1146267775-v0sdm`, you can
    then run the following, making sure to update the name of the pod with your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Towards the end of the log output you should see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ed49833e-2e94-4ae7-929c-872715c616ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that our CouchDB pod is running we can move on to the next one, which is
    Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To launch the Redis pod, we just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up we have the API Gateway; this is launched by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: ZooKeeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can launch Apache ZooKeeper using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Kafka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to launch another Apache project, Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we should double-check that all of the pods we have launched
    are running. To do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see pods for `couchdb`, `redis`, `apigateway`, `zookeeper`, and
    `kafka`, all running with no restarts logged and `1/1` in the `READY` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7fabbba6-2215-4fe1-b633-5967d8fdcc12.png)'
  prefs: []
  type: TYPE_IMG
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we have the controller. This is slightly different from the other pods
    we have deployed, in that it is being deployed in a stateful state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You should see that a StatefulSet has been created rather than a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Invoker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, the next pod we are deploying is going to be a StatefulSet rather than
    a deployment. Before we deploy the pod we need to make a slight change to the
    `kubernetes/invoker/invoker.yml` file. This is because, by default, OpenWhisk
    assumes you are running Ubuntu as your base operating system, which Google Cloud
    isn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open `kubernetes/invoker/invoker.yml` in your text editor of choice
    and remove the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also another reference to `apparmor` we need to remove. This time
    it is towards the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the two code blocks that reference `apparmor` have been removed, you can
    deploy the `invoker` by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It may take a few minutes to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: NGINX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final part of the deployment is the NGINX container. We need to do a little
    more work on this one as we need to generate certificates for our cluster. To
    generate the certificates, we will need to use OpenSSL. This is not installed
    by default on Windows machines so you can use the following command to install
    OpenSSL using Chocolatey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have OpenSSL installed, you can generate the certificates by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the certificates, we need to create a `configmap` using the `nginx.conf`
    file in `kubernetes/nginx`. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to upload the certificate and key we generated as a `secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once they have been uploaded, we can launch the NGINX pod by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/96c0b0fe-1916-4676-b3e6-50bd5caa9f7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have all of the pods deployed, you should double-check that they
    are all running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/b3e76e58-0976-400e-8282-d164eb3adf24.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, everything is running. You can ignore any restarts just so long
    as the number is not increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OpenWhisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have all of the pods deployed, we can start interacting with our deployment.
    To start with, we need to find out the external IP address of the NGINX pod. You
    can find information about the pod by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37646d9e-670d-443a-b63a-2b6fa13e9bb9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, while the ports are exposed they are only exposed on the nodes
    themselves. As the nodes are on private addresses, we will not be able to access
    them from our local client. To expose the ports externally we need to create a
    load-balanced service, to do this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a Load Balancer and expose the three ports: `80`, `443`, and
    `8443`. You can find out the details on the external IP address by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you will find a line that says Load Balancer Ingress followed
    by an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99c8f054-4ab7-4f0e-8799-31cf597501dc.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the example output shown previously, I have an IP address
    of `35.188.204.73`. This will be used as the API endpoint I interact with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the IP address of our installation, we can go ahead and configure
    the authentication token by running the following command, making sure you update
    the IP address with that of your own installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once configured we can then run our hello-world test.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is exactly the same as the hello world in the previous section, so I won''t
    go into too much detail. Simply change to the folder where you have the `hello.js`
    file and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have run the commands creating the package and action, you will be
    able to access the URL. For me, it was the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://35.188.204.73/api/v1/web/guest/demo/hello.http?name=Kubernetes%20for%20Serverless%20Applications`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This showed the page we expected to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de235e08-b560-4d22-b3b5-c7b02f0709ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, we can see a little more by running HTTPie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae2ac2d9-2bdc-4a7e-ae6e-4638c1193f3a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, once you have deployed Apache OpenWhisk using the provided files,
    using it is a pretty consistent experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we finish this chapter we should remove our Kubernetes cluster. To do
    this run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once deleted, be sure to check your Google Cloud control panel at [https://console.cloud.google.com/](https://console.cloud.google.com/)
    to make sure there are no leftover resources, which could be incurring unexpected
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a slight diversion to look at Apache OpenWhisk.
    We have deployed a copy locally using a standard virtual machine and then we moved
    onto deploying it to a Kubernetes cluster running on Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw, once the deployment was complete, interacting with Apache OpenWhisk
    was a consistent experience and we were able to deploy our simple hello-world
    application with no modifications to both of our installations.
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes support for Apache OpenWhisk is still in its infancy, our diversion
    has shown that it isn't just frameworks that have been designed with Kubernetes
    in mind, like the tools we have looked at in the previous chapters, which will
    run on top of a Kubernetes and provide a consistent experience without having
    to lock you into a single vendor or technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to be looking at probably the most mature
    Kubernetes Function as a Service offering: Fission.'
  prefs: []
  type: TYPE_NORMAL
