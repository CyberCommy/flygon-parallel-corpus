- en: Game Objects and the Game Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will begin to put the framework of a game into place. All
    games have **game objects** and a **game loop**. A game loop exists in every game
    ever written. Some tools, such as Unity, do their best to abstract away the game
    loop so that the developer does not necessarily need to know it is there, but
    even in these cases it still is. All games must take some control over the rendering
    capabilities of the operating system or hardware it is running on and draw images
    out to the screen while the game is running. All of the work of the game is done
    within a **big loop**. Game objects can be either an instance of classes in the
    case of **Object-Oriented Programming** (**OOP**) languages such as C++, or in
    the case of procedural languages such as C, they could be loose collections of
    variables or structures. In this chapter, we will be learning how to design a
    game loop and some early versions of our game objects from within C++ compiled
    into **WebAssembly**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter06-game-object/sprites/` folder from
    the project''s GitHub repository. If you haven''t yet downloaded the GitHub project,
    you can get it online here: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Game loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player game object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy game object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projectiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A key concept in game design is the game loop. In any game, the code must run
    over and over again, performing a series of tasks such as input, AI, physics,
    and rendering. A game loop might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An SDL/C++ game targeting almost any platform except WebAssembly would have
    a `while` loop, probably located within the `main` function of the C++ code, that
    would exit only when the player exits the game. WebAssembly shares its runtime
    with the JavaScript engine inside your web browser. The JavaScript engine runs
    on a single thread, and Emscripten uses JavaScript **glue code** to take what
    you have done inside SDL within WebAssembly and render that to the HTML canvas
    element. Therefore, we need to use an Emscripten-specific piece of code for our
    game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next few chapters, we will be adding some of these functions to our
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: Game object management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collision detection between game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy spaceship AI using a **finite state machine** (**FSM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game camera for tracking our player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play audio and sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game physics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These will be functions called from the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic game loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To some degree, we already have a simple game loop, although we did not create
    a function called `game_loop` explicitly. We are going to modify our code to have
    a more explicit game loop that will separate the `input`, `move`, and `render`
    functions. At this point, our `main` function becomes an initialization function
    that finishes by using Emscripten to set the game loop. The code for this new
    app is larger than earlier apps. Let's first walk through the code at a high level,
    introducing each section. Then we will walk through each of the individual sections
    of code in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the code with our `#include` and `#define` preprocessor macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preprocessor macros, we have a few global time variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then define several SDL-related global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After our SDL global variables, we have a block of keyboard flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last global variables track player data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of our global variables defined, we need two functions
    that rotate the player''s spaceship left and right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have three movement-related functions for our player''s ship. We use
    them to accelerate and decelerate our spaceship, and to capp the velocity of our
    spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` function performs the high-level movement of the game objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `input` function determines the keyboard input states and sets our global
    keyboard flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` function draws the player''s sprite to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `game_loop` function runs all of our high-level game objects in each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, the `main` function does all of our initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that in the preceding code we have added a significant
    number of global variables to define player-specific values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the *Game objects* section, we will begin to create game objects and move
    these values from global definitions into objects, but, for the time being, having
    them as global variables will work. We are adding the ability to move the player's
    ship around in a way that is similar to the classic arcade game *Asteroids*. In
    the final version of our game, we will have two spaceships fighting in a duel.
    To do this, we will need to keep track of the *x* and *y* coordinates of our ship
    and the ship's rotation; `player_dx` and `player_dy` make up a normalized direction
    vector for our spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: The `player_vx` and `player_vy` variables are the player's current `x` and `y`
    velocities respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of having the left and right keys move the spaceship left or right
    while they are being held down, we are going to have those keys turn the spaceship
    to the left or the right. To do this, we will have our input function call the
    `rotate_left` and `rotate_right` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the player is turning left, we subtract the `delta_time` variable from the
    player rotation, which is the amount of time in seconds since the last frame rendered.
    The `player_rotation` variable is the player's rotation in radians, where 180
    degrees = π (3.14159…). That means that the player can turn 180 degrees by pressing
    and holding the left or right arrows for about three seconds. We also have to
    correct our rotation if the player's rotation goes below 0 or if the player's
    rotation goes above 2π (360 degrees). If you are not familiar with radians, it
    is an alternative to the system of measuring angles in which there are 360 degrees
    in a circle. Using radians, you think of how far you would have to walk around
    the circumference of a unit circle to get to that angle. A circle with a radius
    of 1 is called a **unit circle**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unit circle is on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a524c84-989f-42ee-a3bb-07d3d95fa6ef.png)'
  prefs: []
  type: TYPE_IMG
- en: A unit circle and a circle with a radius of 2
  prefs: []
  type: TYPE_NORMAL
- en: The formula for the diameter of a circle is 2πr (in our code `2 * PI * radius`).
    So, 2π in radians is the same as saying 360 degrees. Most game engines and math
    libraries use radians instead of degrees, but for some reason SDL uses degrees
    when it rotates sprites, so we will need to change our rotation in radians back
    to degrees when we render our game objects (yuck!).
  prefs: []
  type: TYPE_NORMAL
- en: Just to make sure everyone is following me, in our code the `PI` macro holds
    an approximate value for π that is defined as the ratio of a circle's diameter
    to its circumference. A typical approximation for π is 3.14, although we will
    approximate π as 3.14159 in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to accelerate or decelerate the spaceship if the player hits the
    up or down keys on the keyboard. To do this, we will create `accelerate` and `decelerate`
    functions that are called when the player holds down the up or down keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Both these functions take the `player_dx` and `player_dy` variables that were
    calculated using `sin` and `-cos` in our rotation functions and use those values
    to add to the player's *x* and *y* velocity stored in the `player_vx` and `player_vy`
    variables. We multiply the value by `delta_time`, which will set our acceleration
    to 1 pixel per second squared. Our decelerate function divides that value by 2,
    which sets our deceleration rate to 0.5 pixels per second squared.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we define the `accelerate` and `decelerate` functions, we will need to
    create a function that will cap the `x` and `y` velocity of our spaceship to 2.0
    pixels per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That is not the most efficient way to define this function, but it is the easiest
    to understand. The first line determines the magnitude of our velocity vector.
    If you do not know what that means, let me explain it a little better. We have
    a speed along the *x* axis. We also have a speed along the *y* axis. We want to
    cap the overall speed. If we capped the `x` and `y` velocities individually, we
    would be able to go faster by traveling diagonally. To calculate our total velocity,
    we need to use the Pythagorean theorem (do you remember high-school trigonometry?).
    If you don''t remember, when you have a right triangle, to calculate its hypotenuse
    you take the square root of the sum of the square of the other two sides (remember
    `A² + B² = C²`?):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58d0adaf-31a8-45fa-85aa-2ef16b155019.png)[Using the Pythagorean theorem
    to determine the magnitude of the velocity using the x and y velocities]'
  prefs: []
  type: TYPE_NORMAL
- en: So, to calculate our velocity overall we need to square the `x` velocity, square
    the `y` velocity, add them together, and then take the square root. At this point,
    we check our velocity against the `MAX_VELOCITY` value, which we have defined
    as `2.0`. If the current velocity is greater than this maximum velocity, we need
    to adjust our `x` and `y` velocities so that we are at a value of `2`. We do this
    by dividing both the `x` and `y` velocities by the overall velocity, then multiplying
    by `MAX_VELOCITY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will eventually need to write a `move` function that will move all of our
    game objects, but for the moment we will only be moving our player''s spaceship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is get the current time for this frame, and then
    use that in combination with our previous frame time to calculate the `delta_time`.
    The `delta_time` variable is the amount of time in seconds since the last frame
    time. We will need to tie much of the movement and animation to this value to
    get a consistent game speed that's independent of the frame rate on any given
    computer. After that, we need to rotate and accelerate or decelerate our spaceship
    based on the flags we set in our `input` function. We then cap our velocity and
    use the `x` and `y` values to modify the *x* and *y* coordinates of the player's
    spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: 'There were a series of flags we used in the `move` function that told us whether
    we were currently holding down specific keys on the keyboard. To set those flags,
    we need an `input` function that uses `SDL_PollEvent` to find keyboard events
    and set the flags accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function includes a few `switch` statements that look for the arrow key
    presses and releases. If one of the arrow keys is pressed, we set the appropriate
    flag to `true`; if one is released, we set that flag to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the `render` function. This function currently renders our
    spaceship sprite and will eventually render all of our sprites to the HTML canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function clears the HTML canvas, sets the destination `x` and `y` values
    to `player_x` and `player_y`, calculates the player's rotation in degrees, and
    then renders that sprite to the canvas. We swapped out our previous call to `SDL_RenderCopy`
    with a call to `SDL_RenderCopyEx`. This new function allows us to pass in a value
    that rotates the sprite of our spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we defined our `render` function, we have our new `game_loop` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function will be called by `emscripten_set_main_loop` from within our `main`
    function. This function runs every frame that is rendered and is responsible for
    managing all the activities that go on within our game. It currently calls the
    `input`, `move`, and `render` functions that we defined earlier in our game code,
    and in the future it will call our AI code, sound effects, physics code, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling gameloop.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have written our code, we can go ahead and compile our game loop
    app. Before you run this command, I want to reiterate that you need to have downloaded
    the project from GitHub ([https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly))
    because you will need the PNG files located in the `/Chapter06-game-loop/sprites`
    folder in order to build this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your folders set up properly, compile the app with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Serve the directory where you compiled it with a web server, or build and run
    it with emrun, and it should look like this when loaded into a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13918915-c0b6-448b-b3be-996e683d26a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The screenshot gameloop.html
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  prefs: []
  type: TYPE_NORMAL
- en: After the app has compiled, you should be able to move the spaceship around
    the canvas using the arrow keys. Now that we have a basic game loop, in the next
    section, we will be adding some game objects to our app, making it more of a game.
  prefs: []
  type: TYPE_NORMAL
- en: Game objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our approach so far has been entirely procedural and has been coded so that
    it could have been written in C and not C++. Developers have been writing games
    in C and even assembly language for a long time, so having an object-oriented
    approach to game design is not strictly necessary, but from a code management
    perspective OOP is a great way to design and write your games. Game objects can
    help us manage our allocated memory through object pooling. At this point, it
    will also make sense to begin breaking our program up into multiple files. My
    approach will be to have a single `.hpp` file that defines all of our game objects,
    and one `.cpp` file for each of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: The player's spaceship game object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have been keeping all of the values that track our player's
    ship in global variables. From an organizational perspective, this is less than
    ideal. The first game object we will create will be the player's ship object.
    We will start with a basic class and add more object-oriented features to our
    code later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for our new header file, `game.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All of our CPP files will include this `game.hpp` header file. The first few
    lines of this file are to make sure we do not include this file more than once.
    We are then defining all of the global variables we had defined in our older C
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the header file, we are not allocating space on to the heap. The use of the
    `extern` keyword before our global variable definitions tells the compiler that
    we declared the global variable in one of the `.cpp` files. Right now, we still
    have a lot of global variables. We will be reducing the number of these globals
    as we make modifications to our code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If this were production code, it would make sense to move all of these values
    into classes, but, for now, we are only creating a `PlayerShip` object. We also
    have our class definition for `PlayerShip`. Developers usually create class definitions
    inside header files.
  prefs: []
  type: TYPE_NORMAL
- en: After we define all of our global variables, we will need our class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of our `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this book, we are going to declare all of our attributes `public`. That means
    our code can access them from anywhere, not just from inside this function. If
    you are working on a project with more than one developer, this is not usually
    considered to be a good practice. Preventing other classes from being able to
    directly modify some of our attributes such as `m_DX` and `m_DY` is a good idea
    if you do not want another developer to directly alter specific attributes that
    only functions in a class are meant to modify. For demonstration purposes, however,
    having everything in our class defined as `public` will simplify our design.
  prefs: []
  type: TYPE_NORMAL
- en: After we define our attributes, we have a series of functions that will be associated
    with this class once defined. The first function, `PlayerShip()`, has the same
    name as our class, which makes it the constructor, that is, the function that
    is called by default when our app creates an object of the `PlayerShip` type.
    If we wished, we could define a destructor function, which would run when the
    object was destroyed, by calling it `~PlayerShip()`. We do not currently need
    a destructor for that object so we will not define it here, which means we will
    rely on C++ to create a *default destructor* for this class.
  prefs: []
  type: TYPE_NORMAL
- en: All of the other functions we have defined in this class correspond to functions
    we created in previous C versions of our game. Moving all of these functions to
    a class allows us to organize our code better. Notice that after our class definition,
    we created another global variable that is a `PlayerShip` called `player`. The
    compiler shares this player object in all of the `.cpp` files that include our
    `game.hpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Object pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have defined our first game object, which represents our player's spaceship,
    but all we can do is fly around the game screen. We need to allow our player to
    shoot a projectile. If we created a new projectile object every time a player
    shot a projectile, we would quickly fill up the WASM module's memory. What we
    need to do is create what is known as an **object pool**. Object pools are used
    to create objects with a fixed lifespan. Our projectiles only need to be alive
    long enough to either hit a target or travel a fixed distance before disappearing.
    If we create a set number of projectiles that is a little more than we need on
    the screen at one time, we can keep those objects in a pool in either an active
    or inactive state. When we need to launch a new projectile, we scan our object
    pool for an inactive one, then activate it and place it at the launch point. This
    way, we are not continually allocating and de-allocating memory to create our
    projectiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `game.hpp` file and add a few class definitions right
    before the `#endif` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have defined all of our classes inside the `game.hpp` file. Right now,
    we have three classes: `PlayerShip`, `Projectile`, and `ProjectilePool`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerShip` class existed before, but we are adding some additional functionality
    to that class to allow us to fire projectiles. To allow for this new functionality,
    we are adding some new public attributes to our class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We moved a few of the values we had in `#define` macros directly into the class.
    The `c_SpriteFile` constant is the name of the PNG file we will load to render
    our player's spaceship sprite. The `c_MinLaunchTime` constant is the minimum amount
    of time in milliseconds between two launches of projectiles. We have also defined
    the width and height of our sprite with the `c_Width` and `c_Height` constants.
    This way, we can have different values for different object types. The `m_LastLaunchTime`
    attribute tracks the most recent projectile launch time in milliseconds. The sprite
    texture, which had previously been a global variable, will move into the attributes
    of the player's ship class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making our modifications to the `PlayerShip` class definition, we must
    add a class definition for two new classes. The first of these two classes is
    the `Projectile` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This class represents the projectile game objects that will be shot by the
    player, and later the enemy spaceship. We start with several constants that define
    where we place our sprite in the virtual filesystem, as well as the width and
    height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The next attribute is `m_SpriteTexture`, which is a pointer to the SDL texture
    used to render our projectiles. We need a variable to tell our object pool that
    this game object is active. We have called that attribute `m_Active`. Next, we
    have a constant that defines how fast our projectile will move in pixels per second,
    called `c_Velocity`, and a constant that indicates how long the projectile will
    stay alive in milliseconds before self-destructing, called `c_AliveTime`.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_TTL` variable is a **time to live** variable that tracks how many milliseconds
    remain until this projectile will change its `m_Active` variable to `false` and
    recycle itself back into the **projectile pool**. The `m_X`, `m_Y`, `m_VX`, and
    `m_VY` variables are used to track the `x` and `y` position and the `x` and `y`
    velocity of our projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then declare four functions for our projectile class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `Projectile` function is our class constructor. If our projectile is currently
    active, `Move` and `Render` will be called once per frame. The `Move` function
    will manage the movement of an active projectile and `Render` will manage drawing
    the projectile sprite to our HTML canvas element. The `Launch` function will be
    called from our `PlayerShip` class to make our ship launch a projectile in the
    direction the ship is facing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final class definition we must add to our `game.hpp` file is the `ProjectilePool`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class manages a **pool** of 10 projectiles stored inside a vector attribute,
    `m_ProjectileList`. The functions for this class include a constructor and destructor,
    `MoveProjectiles`, `RenderProjectils`, and `GetFreeProjectile`.
  prefs: []
  type: TYPE_NORMAL
- en: The `MoveProjectiles()` function loops over our projectile list calling the
    `move` function on any active projectile. The `RenderProjectiles()` function loops
    over our projectile list and renders to canvas any active projectile, and `GetFreeProjectile`
    returns the first projectile in our pool that is not active.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling the player's projectiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have looked at the class definitions for our `Projectile` and `ProjectilePool`
    classes, we need to create a `projectile.cpp` file and a `projectile_pool.cpp`
    file to store the function code for those classes. Because this is in [Chapter
    6](ba16e692-1743-4031-bbff-cf2f23ea9a3c.xhtml), *Game Objects and the Game Loop*,
    I would recommend creating a new folder named `Chapter06` to hold these files.
    This code will do the work of pooling our projectiles, requesting an inactive
    projectile when we need one, and moving and rendering our active projectiles.
    First, let''s look at the code we have in `projectile.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That is the code that deals with moving, rendering, and launching a single
    projectile. The first function declared here is the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary concern of this constructor is to set the projectile to inactive
    and create an SDL texture that we will later use to render our sprite to the canvas
    element. After defining our constructor, we define our `Move` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This function changes the *x* and *y* position of our projectile based on the
    velocity, and reduces the time to live of our projectile, setting it to inactive
    and recycling it into the projectile pool if it''s time to live is less than or
    equal to zero. The next function we define is our `Render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is similar to the code we used to render our spaceship, so it should
    look pretty familiar to you. Our final projectile function is the `Launch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This function is called from the `PlayerShip` class whenever the player presses
    the spacebar on the keyboard. The `PlayerShip` object will pass in the *x* and
    *y* coordinates of the player's ship, as well as the direction the ship is facing
    in the `dx` and `dy` parameters. These parameters are used to set the *x* and
    *y* coordinates for the projectile as well as the `x` and `y` velocity of the
    projectile. The game sets the time to live to the default alive time and then
    sets the object to active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have fully defined our `Projectile` class, let''s set the `ProjectilePool`
    class that will manage those projectiles. The following code will be in our `projectile_pool.cpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first two functions are the constructor and destructor functions. These
    functions create and destroy the projectiles inside our list. The next function
    is the `MoveProjectiles` function, which loops through our `m_ProjectileList`
    looking for active projectiles and moving them. After that, we have a `RenderProjectiles`
    function, which is quite similar to our `MoveProjectiles` function. This function
    loops through our list calling the `Render` function on all active projectiles.
    The final function is the `GetFreeProjectile` function, which steps through `m_ProjectileList`
    looking for the first projectile that is not active in order to return it. Whenever
    we want to launch a projectile, we will need to call this function to find one
    that is not active.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that we have a player ship that is shooting, we can work on adding
    an enemy ship. It will be similar to the `PlayerShip` class. Later, we will get
    into class inheritance so that we will not end up with a copied and pasted version
    of the same code, but for right now we will add a new class definition to our
    `game.hpp` file that is almost identical to our `PlayerShip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that before the `EnemyShip` class we defined an `FSM_STUB` enumeration.
    An enumeration is like a new data type that you can define inside your C or C++
    code. We will be discussing **artificial intelligence** and **finite state machines**
    in another chapter, but right now we still want our enemy ship to do something,
    even if that something is not very intelligent. We created an `FSM_STUB` enumeration
    to define the things that our enemy ship can currently do. We have also created
    an `AIStub` inside our `EnemyShip` class that will act as a stand-in for future
    AI logic. The `m_AIStateTTL` integer attribute is a countdown timer to an AI state
    change. There is also a new constant called `c_AIStateTime` that has a value of
    `2000`. That is the number of milliseconds our AI state will persist before it
    changes randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an `enemy_ship.cpp` file and add nine functions to it. The first
    function is our constructor, which is preceded by the `#include` of our `game.hpp`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we have the functions `RotateLeft` and `RotateRight` which are
    used to turn the space ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions `Accelerate`, `Decelerate` and `CapVelocity` are all used to
    modify the Enemy Ship''s velocity.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we add to the file is the `Render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the `Move` and `AIStub` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are all the same as the functions defined in our `player_ship.cpp`
    file, except for the `Move` function. We have added a new function, `AIStub`.
    Here is the code in the `AIStub` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is meant to be temporary. We will eventually define a real AI
    for our enemy spaceship. Right now, this function uses `m_AIStateTTL` to count
    down a fixed number of milliseconds until it reaches or goes below `0`. At this
    point, it randomly sets a new AI state based on one of the values in the enumeration
    we defined earlier called `FSM_STUB`. We have also made some modifications to
    the `Move()` function that we created for the player ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: I have taken the code from our `PlayerShip::Move` function and made some modifications
    to it. At the beginning of this new function, we have added a call to the `AIStub`
    function. This function is a stand-in for our future AI. Instead of looking at
    our keyboard input as we did for the player ship, the enemy ship will look at
    the AI state and choose to rotate left, rotate right, accelerate, decelerate,
    or shoot. That is not real AI, it is just the ship doing random things, but it
    allows us to get an idea of what the ship will look like when it has real AI,
    and it will allow us to add more functionality later, such as collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling game_objects.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have built all of these game objects, we no longer have everything
    inside a single file. We will need to include several CPP files and compile them
    all into a single output file we will call `game_objects.html`. Because we have
    moved from the world of C to C++, we will be using em++ to indicate that the files
    we are compiling are C++ files and not C files. That is not strictly necessary,
    because Emscripten will figure out that we are compiling with C++ when it receives
    files with the `.cpp` extension as input. We are also telling the compiler explicitly
    the version of C++ we are using when we pass in the `-std=c++17` flag. Go ahead
    and compile the `game_objects.html` file with the following em++ command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `game_objects.html` file compiled use a web server to
    serve the files and open it in a browser, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23123d7f-c321-4339-b623-e4be90bc4388.png)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of game_objects.html
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that you must run WebAssembly apps using a web server, or with
    `emrun`. If you would like to run your WebAssembly app using `emrun`, you must
    compile it with the `--emrun` flag. The web browser requires a web server to stream
    the WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  prefs: []
  type: TYPE_NORMAL
- en: You can move your spaceship around the canvas with the arrow keys, and fire
    a projectile with the spacebar. The enemy ship will move around the canvas shooting
    randomly.
  prefs: []
  type: TYPE_NORMAL
- en: If you are having problems building this app, or any of the other apps in this
    book, please remember you can contact me on Twitter, [https://twitter.com/battagline/](https://twitter.com/battagline/),
    using the Twitter handle `@battagline` to ask questions. I am happy to help.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create a basic game framework. We learned
    what a game loop is and how we create one for WebAssembly using Emscripten. We
    learned about game objects and created classes to define our player's spaceship,
    an enemy spaceship, and projectiles. We learned about object pooling, and how
    we can use an object pool to recycle objects in memory so that we do not need
    to create and destroy new objects in memory continually. We used this knowledge
    to create an object pool for our projectiles. We also created an AI stub for our
    enemy spaceship that gave that object random behavior, and we created functions
    that let our player and enemy shoot at each other while our projectiles pass harmlessly
    through the spaceships.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the next chapter, we will add collision detection; this will allow
    our projectiles to destroy the spaceships they hit, and add an animation sequence
    that will show a ship being destroyed when it is hit by one of the projectiles.
  prefs: []
  type: TYPE_NORMAL
