- en: Chapter 14. ECMAScript-2015/2016 Solutions Today
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I cannot count the number of times I have mentioned upcoming versions of JavaScript
    in this module, rest assured that it's a large number. It is somewhat frustrating
    that the language is not keeping pace with the requirements of application developers.
    Many of the approaches we've discussed become unnecessary with a newer version
    of JavaScript. There are, however, some ways to get the next version of JavaScript
    working today.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at a couple of these, specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Typescript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BabelJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no shortage of languages that compile to JavaScript. CoffeeScript is
    perhaps the best known example of one of these languages, although the Google
    web toolkit that compiles Java to JavaScript was also once very popular. Never
    ones to be left behind or use somebody else's solution, Microsoft released a language
    called TypeScript in 2012\. It is designed to be a superset of JavaScript in the
    same way that C++ is a superset of C. This means that all syntactically valid
    JavaScript code is also syntactically valid TypeScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft itself is making heavy use of TypeScript in some of its larger web
    properties. Both Office 365 and Visual Studio Online have significant code bases
    written in TypeScript. These projects actually predate TypeScript by a significant
    margin. The transition from JavaScript to TypeScript was reportedly quite easy
    due to the fact that it is a superset of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: One of the design goals for TypeScript was to make it as compatible as possible
    with ECMAScript-2015 and future versions. This means that TypeScript supports
    some, although certainly not all, of the features of ECMAScript-2016, as well
    as a healthy chunk of ECMAScript-2015\. Two significant features from ECMAScript-2016
    which are partially supported by Typescript are decorators and async/await.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In an earlier chapter we explored **aspect oriented programming** (**AOP**).
    With AOP we wrap function with interceptors. Decorators offer an easy way of doing
    this. Let''s say that we have a class which dispatches messages in Westeros. Obviously
    there are no phones or internet there, so messages are dispatched via crows. It
    would be very helpful if we could spy on these messages. Our `CrowMessenger` class
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may note the `@spy` annotation on the `SendMessage` method. This is simply
    another function which intercepts and wraps the function. Inside of the spy we
    have access to the function descriptor. As you can see in the following code,
    we take the descriptor and manipulate it to capture the argument sent to the `CrowMessenger`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Spys would obviously be very useful for testing functions. Not only can we
    spy on the values here but we could replace the input and output to the function.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Decorators can be used for purposes other than AOP. For instance, you could
    annotate the properties on an object as serializable and use the annotations to
    control custom JSON serialization. It is my suspicion that decorators will become
    more useful and powerful as decorators become supported. Already Angular 2.0 is
    making extensive use of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 7](part0134_split_000.html#3VPBC1-015e68c68a464f18a9559f448be84435
    "Chapter 7. Reactive Programming"), *Reactive Programming*, we spoke about how
    the callback nature of JavaScript programming makes code very confusing. Nowhere
    is this more apparent than trying to chain together a series of asynchronous events.
    We rapidly fall into a trap of code, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only is this code difficult to read, it is nearly impossible to understand.
    The async/await syntax, which is borrowed from C#, allows for writing your code
    in a much more succinct fashion. Behind the scenes generators are used (or abused,
    if you like) to create the impression of true async/await. Let''s look at an example.
    In the preceding code we made use of the geolocation API which returns the location
    of a client. It is asynchronous as it performs some IO with the user''s machine
    to get a real world location. Our specification calls for us to get the user''s
    location, post it back to the server, and then get an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now introduce async/await, this can become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code assumes that all `async` responses return promises which are a construct
    that contains a status and a result. As it stands, most `async` operations do
    not return promises but there are libraries and utilities to convert callbacks
    to promises. As you can see, the syntax is much cleaner and easier to follow than
    the callback mess.
  prefs: []
  type: TYPE_NORMAL
- en: Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as the ECMAScript-2016 features we''ve mentioned in the preceding section,
    TypeScript has a rather intriguing typing system incorporated into it. One of
    the nicest parts of JavaScript is that it is a dynamically typed language. We''ve
    seen, repeatedly, how, not being burdened by types has saved us time and code.
    The typing system in TypeScript allows you to use as much or as little typing
    as you deem to be necessary. You can give variables a type by declaring them with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a variable has a type assigned to it, the TypeScript compiler will use
    that not only to check that variable''s usage, but also to infer what other types
    may be derived from that class. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the TypeScript compiler will know that `unknown` is a number. If you
    attempt to use it as something else, say as the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then the compiler will throw an error. However, you don't need to assign a type
    to any variable. This means that you can tune the degree to which the type checking
    is run. While it sounds odd, it is actually a brilliant solution for introducing
    the rigour of type checking without losing the pliability of JavaScript. The typing
    is only enforced during compilation, once the code is compiled to JavaScript,
    any hint that there was typing information associated with a field disappears.
    As a result, the emitted JavaScript is actually very clean.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in typing systems and know words like contravariant and
    can discuss the various levels of gradual typing, then TypeScript's typing system
    may be well worth your time to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this module were originally written in TypeScript and then
    compiled to JavaScript. This was done to improve the accuracy of the code and
    generally to save me from messing up quite so frequently. I'm horribly biased
    but I think that TypeScript is really well done and certainly better than writing
    pure JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: There is no support for typing in future versions of JavaScript. Thus, even
    with all the changes coming to future versions of JavaScript, I still believe
    that TypeScript has its place in providing compile time type checking. I never
    cease to be amazed by the number of times that the type checker has saved me from
    making silly mistakes when writing TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: BabelJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to TypeScript is to use the BabelJS compiler. This is an open
    source project ECMAScript-2015 and beyond to the equivalent ECMAScript 5 JavaScript.
    A lot of the changes put in place for ECMAScript-2015 are syntactic niceties,
    so they can actually be represented in ECMAScript 5 JavaScript, although not as
    succinctly or as pleasantly. We've seen that already using class-like structures
    in ES 5\. BabelJS is written in JavaScript, which means that the compilation from
    ECMAScript-2015 to ES 5 is possible directly on a web page. Of course, as seems
    to be the trend with compilers, the source code for BabelJS makes use of ES 6
    constructs, so BabelJS must be used to compile BabelJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the list of ES6 functions that are supported by BabelJS
    are extensive:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed property names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructuring assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators and for of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator comprehension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property method assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object initializer shorthand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BabelJS is multi-purpose JavaScript compiler, so compiling ES-2015 code is simply
    one of the many things it can do. There are numerous plugins which provide a wide
    array of interesting functionality. For instance, the "Inline environmental variable"
    plugin inserts compile time variables, allowing for conditional compilation based
    on environments.
  prefs: []
  type: TYPE_NORMAL
- en: There is already a fair bit of documentation available on how each of these
    features work so we won't go over all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up Babel JS is a fairly simple exercise if you already have node and
    npm installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a BabelJS binary which can do compilation like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For most use cases you'll want to investigate using build tools such as Gulp
    or Grunt, which can compile many files at once and perform any number of post-compilation
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you should be getting sick of reading about different ways to make classes
    in JavaScript. Unfortunately for you I'm the one writing this module so let's
    look at one final example. We'll use the same castle example from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Modules within files are not supported in BabelJS. Instead, files are treated
    as modules, which allows for dynamic loading of modules in a fashion not unlike
    `require.js`. Thus we'll drop the module definition from our castle and stick
    to just the classes. One other feature that exists in TypeScript and not ES 6
    is prefacing a parameter with `public` to make it a public property on a class.
    Instead we make use of the `export` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve made these changes, the source ES6 file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting ES 5 JavaScript looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Right away it is apparent that the code produced by BabelJS is not as clean
    as the code from TypeScript. You may also have noticed that there are some helper
    functions employed to handle inheritance scenarios. There are also a number of
    mentions of `"use strict";`. This is an instruction to the JavaScript engine that
    it should run in strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict mode prevents a number of dangerous JavaScript practices. For instance,
    in some JavaScript interpreters it is legal to use a variable without declaring
    it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will throw an error if `x` has not previously been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Duplicating properties in objects is disallowed, as well as double declaring
    a parameter. There are a number of other practises that `"use strict";` will treat
    as errors. I like to think of `"use strict";` as being similar to treating all
    warnings as errors. It isn't, perhaps, as complete as `–Werror` in GCC but it
    is still a good idea to use strict mode on new JavaScript code bases. BabelJS
    simply enforces that for you.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not a huge feature but a real nicety in ES 6 is the introduction of default
    parameters. It has always been possible to call a function in JavaScript without
    specifying all the parameters. Parameters are simply populated from left to right
    until there are no more values and all remaining parameters are given undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Default parameters allow setting a value other than undefined for parameters
    that aren''t filled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript code produced is actually very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Template literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the surface, template literals seem to be a solution for the lack of string
    interpolation in JavaScript. In some languages, such as Ruby and Python, you can
    inject substitutions from the surrounding code directly into a string without
    having to pass them into some sort of string formatting function. For instance,
    in Ruby you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will bind the `${name}` parameter to the name from the surrounding scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 supports template literals that allow something similar in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be difficult to see but that string is actually surrounded by backticks
    and not quotation marks. Tokens to bind to the scope are denoted by `${}`. Within
    the braces you can put complex expressions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The BabelJS compiled version of this code simply substitutes appending strings
    for the string interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Template literals also solve a number of other problems. New line characters
    inside of a template literal are legal, meaning that you can use template literals
    to create multiline strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the multiline string idea in mind, it seems like template literals might
    be useful for building domain specific languages: a topic we''ve seen a number
    of times already. The DSL can be embedded in a template literal and then values
    from outside plugged in. An example might be using it to hold HTML strings (certainly
    a DSL) and inserting values in from a model. These could, perhaps, take the place
    of some of the template tools in use today.'
  prefs: []
  type: TYPE_NORMAL
- en: Block bindings with let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scoping of variables in JavaScript is weird. If you define a variable inside
    a block, say inside an `if` statement, then that variable is still available outside
    of the block. For example, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code will print `9`, even though the variable outside is clearly out of
    scope. At least it is out of scope if you assume that JavaScript is like other
    C-syntax languages and supports block level scoping. The scoping in JavaScript
    is actually function level. Variables declared in code blocks like those found
    attached to `if` and `for` loop statements are hoisted to the beginning of the
    function. This means that they remain in scope for the entirety of the function.
  prefs: []
  type: TYPE_NORMAL
- en: ES 6 introduces a new keyword, `let`, which scopes variables to the block level.
    This sort of variable is ideal for use in loops or to maintain proper variable
    values inside an `if` statement. Traceur implements support for block scoped variables.
    However, the support is experimental at the moment due to performance implications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the inner variable is replaced with a renamed one. Once outside
    the block, the variable is no longer replaced. Running this code will report that
    inside is undefined when the `console.log` method occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In production
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BabelJS is a very powerful tool for replicating many of the structures and features
    of the next version of JavaScript today. However, the code generated is never
    going to be quite as efficient as having native support for the constructs. It
    may be worth benchmarking the generated code to ensure that it continues to meet
    the performance requirements of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two excellent libraries for working with collections functionally
    in JavaScript: Underscore.js and Lo-Dash. Used in combination with TypeScript
    or BabelJS they have a very pleasant syntax and provide immense power.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, finding all the members of a collection that satisfy a condition
    using Underscore looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This code will find all the items where the ID is greater than `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Either of these libraries is one of the first things I add to a new project.
    Underscore is actually bundled with backbone.js, an MVVM framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks for Grunt and Gulp exist for compiling code written in TypeScript or BabelJS.
    There is, of course, also good support for TypeScript in much of Microsoft's development
    tool chain, although BabelJS is currently not supported directly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the functionality of JavaScript expands, the need for third party frameworks
    and even transpilers starts to drop off. The language itself replaces many of
    these tools. The end game for tools like jQuery is that they are no longer required
    as they have been absorbed into the ecosystem. For many years the velocity of
    web browsers has been unable to keep pace with the rate of change of people's
    desires.
  prefs: []
  type: TYPE_NORMAL
- en: There is a large effort behind the next version of AngularJS but great efforts
    are being made to align the new components with the upcoming web component standards.
    Web components won't fully replace AngularJS but Angular will end up simply enhancing
    web components.
  prefs: []
  type: TYPE_NORMAL
- en: Of course the idea that there won't be a need for any frameworks or tools is
    ridiculous. There is always going to be a new method of solving a problem and
    new libraries and frameworks will show up. The opinions of people on how to solve
    problems is also going to differ. That's why there is space in the market for
    the wide variety of MVVM frameworks that exist.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JavaScript can be a much more pleasant experience if you make use
    of ES6 constructs. There are a couple of possible approaches to doing so, which
    of these is best suited to your specific problem is a matter for closer investigation.
  prefs: []
  type: TYPE_NORMAL
