- en: Chapter 9. Administration Calls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。管理调用
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Gathering information about processes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于进程的信息收集
- en: Killing processes and send or respond to signals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止进程并发送或响应信号
- en: Which, whereis, file, whatis, and loadavg explained
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Which、whereis、file、whatis和loadavg的解释
- en: Sending messages to user terminals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户终端发送消息
- en: Gathering system information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集系统信息
- en: Using /proc – gathering information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用/proc – 收集信息
- en: Scheduling with cron
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cron进行调度
- en: Writing and reading MySQL database from Bash
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Bash中写入和读取MySQL数据库
- en: User administration script
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理脚本
- en: Bulk image resizing and format conversion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量图像调整和格式转换
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A GNU/Linux ecosystem consists of running programs, services, connected devices,
    filesystems, users, and a lot more. Having an overview of the entire system and
    managing the OS as a whole, according to the way we want, is the primary purpose
    of system administration. One should be armed with the knowledge of commonly-used
    commands and proper usage practices to gather system information and manage resources
    to write script and automation tools that perform management tasks. This chapter
    will introduce several commands and methods for gathering information about your
    system and make use of these commands to write administration scripts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GNU/Linux生态系统由运行的程序、服务、连接的设备、文件系统、用户等组成。全面了解整个系统并根据我们的意愿管理操作系统，是系统管理的主要目的。人们应该掌握常用命令和适当的使用方法，以收集系统信息和管理资源，编写脚本和自动化工具来执行管理任务。本章将介绍几个命令和方法，用于收集关于系统的信息，并利用这些命令来编写管理脚本。
- en: Gathering information about processes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于进程的信息收集
- en: Processes are the running instance of a program. Several processes run on a
    computer and each process is assigned a unique identification number called a
    process ID. It is an integer. Multiple instances of the same program with the
    same name can be executed at a time. But they all will have different process
    IDs. A process consists of several attributes, such as which user owns the process,
    the amount of memory used by the program, the amount of CPU used by the program,
    and so on. This recipe will go through how to gather information about processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是程序的运行实例。计算机上运行多个进程，每个进程都被分配一个称为进程ID的唯一标识号。它是一个整数。可以同时执行相同名称的程序的多个实例。但它们都将有不同的进程ID。进程包括多个属性，例如拥有进程的用户、程序使用的内存量、程序使用的CPU量等。本教程将介绍如何收集关于进程的信息。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Important commands related to process management are `top`, `ps`, and `pgrep`
    . Let's see how we can gather information about processes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程管理相关的重要命令是`top`、`ps`和`pgrep`。让我们看看如何收集关于进程的信息。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`ps` is an important tool for gathering information about the processes. `ps`
    provides information on a user who owns the process, the time when a process started,
    command path used for executing the process, process ID (PID), the terminal it
    is attached with (TTY), the memory used by the process, CPU used by the process,
    and so on. For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`是收集关于进程的信息的重要工具。`ps`提供了有关拥有进程的用户、进程启动时间、用于执行进程的命令路径、进程ID（PID）、它附加的终端（TTY）、进程使用的内存、进程使用的CPU等信息。例如：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ps` command is usually used with a set of parameters. When it is run without
    any parameter, `ps` will display processes that are running on the current (TTY)
    terminal. The first column shows the process ID (PID), the second column is the
    TTY (terminal), the third column is how much time has elapsed since the process
    started, and finally CMD (the command).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令通常与一组参数一起使用。当没有任何参数运行时，`ps`将显示在当前（TTY）终端上运行的进程。第一列显示进程ID（PID），第二列是TTY（终端），第三列是进程启动后经过的时间，最后是CMD（命令）。'
- en: 'In order to show more columns consisting of more information, use `-f` (this
    stands for full) as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示包含更多信息的更多列，使用`-f`（表示完整）如下：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above `ps` commands are not useful since it does not provide any information
    about processes other than the ones attached to the current terminal. In order
    to get information about every process running on the system, add the `-e` (every)
    option. The `-ax` (all) option will also produce an identical output.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`ps`命令并不实用，因为它没有提供除了附加到当前终端的进程之外的任何信息。为了获取关于系统上运行的每个进程的信息，添加`-e`（每个）选项。`-ax`（全部）选项也会产生相同的输出。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `-x` argument along with `-a` specifies to remove the TTY restriction imparted,
    by default, by `ps`. Usually, using `ps` without arguments prints processes that
    are attached to terminal only.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`-x`参数与`-a`一起指定了默认情况下由`ps`施加的去除TTY限制。通常，使用`ps`而不带参数会打印仅附加到终端的进程。'
- en: 'Run `ps -e` or `ps –ef` else `ps -ax` or `ps –axf`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`ps -e`或`ps –ef`，否则运行`ps -ax`或`ps –axf`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will be a long list. The example filters the output using `head` so we only
    get the first 10 entries.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个很长的列表。示例使用`head`过滤输出，所以我们只得到前10个条目。
- en: The `ps` command supports several information to be displayed along with the
    process name and process ID. By default, `ps` shows the information as different
    columns. Most of them are not useful for us. We can actually specify the columns
    to be displayed using the `-o` flag. Hence we can print only the required columns.
    Different parameters associated with a process are specified with options for
    that parameter. The list of parameters and usage of `-o` are discussed next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令支持显示进程名称和进程ID以及其他信息。默认情况下，`ps`将信息显示为不同的列。其中大部分对我们来说并不实用。我们实际上可以使用`-o`标志指定要显示的列。因此，我们可以只打印所需的列。下面将讨论与参数相关的不同参数和`-o`的用法。'
- en: 'In order to display the required columns of output using `ps`, use:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`ps`显示所需的输出列，使用：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Parameters for `-o` are delimited by using the comma (,) operator. It should
    be noted that there is no space in between the comma operator and next parameter.
    Mostly, the `-o` option is combined with the `-e` (every) option (`-oe`) since
    it should list every process running in the system. However, when certain filters
    are used along with `–o`, such as those used for listing the processes owned by
    specified users, `-e` is not used along with `–o`. Usage of `-e` with a filter
    will nullify the filter and it will show all process entries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逗号（,）运算符来分隔`-o`的参数。应该注意的是逗号运算符和下一个参数之间没有空格。大多数情况下，`-o`选项与`-e`（every）选项（`-oe`）结合使用，因为它应该列出系统中运行的每个进程。然而，当与`–o`一起使用某些过滤器时，比如用于列出指定用户拥有的进程的过滤器时，`-e`不会与`–o`一起使用。使用带有过滤器的`-e`将使过滤器无效，并显示所有进程条目。
- en: 'An example is as follows. Here, `comm` stands for COMMAND and `pcpu` is percent
    of CPU usage:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子如下。这里，`comm`代表COMMAND，`pcpu`代表CPU使用率的百分比：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The different parameters that can be used with the `-o` option and their descriptions
    are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-o`选项的不同参数及其描述如下：
- en: '| Parameter | Description |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pcpu` | Percentage of CPU |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `pcpu` | CPU百分比 |'
- en: '| `pid` | Process ID |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `pid` | 进程ID |'
- en: '| `ppid` | Parent Process ID |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `ppid` | 父进程ID |'
- en: '| `pmem` | Percentage of Memory |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `pmem` | 内存百分比 |'
- en: '| `comm` | Executable file name |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `comm` | 可执行文件名 |'
- en: '| `cmd` | Simple command |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `cmd` | 简单命令 |'
- en: '| `user` | The user who started process |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 启动进程的用户 |'
- en: '| `nice` | The priority (niceness) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `nice` | 优先级（niceness） |'
- en: '| `time` | Cumulative CPU time |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 累积CPU时间 |'
- en: '| `etime` | Elapsed time since the process started |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `etime` | 进程启动后的经过时间 |'
- en: '| `tty` | The associated TTY device |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `tty` | 关联的TTY设备 |'
- en: '| `euid` | The effective user |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `euid` | 有效用户 |'
- en: '| `stat` | Process state |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `stat` | 进程状态 |'
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through additional usage examples of process manipulation commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进程操作命令的其他用法示例。
- en: top
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: top
- en: '`top` is a very important command for system administrators. The `top` command
    will, by default, output a list of top CPU consuming processes. The command is
    used as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`对于系统管理员来说是一个非常重要的命令。`top`命令默认会输出CPU消耗最多的进程列表。该命令的使用如下：'
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will display several parameters along with the top CPU consuming processes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示与CPU消耗最多的进程相关的几个参数。
- en: Sorting ps output with respect to a parameter
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据参数对ps输出进行排序
- en: Output of the `ps` command can be sorted according to specified columns with
    the `--sort` parameter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令的输出可以根据指定的列使用`--sort`参数进行排序。'
- en: 'The ascending or descending order can be specified by using the `+` (ascending)
    or `-` (descending) prefix to the parameter as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`+`（升序）或`-`（降序）前缀来指定升序或降序排序。
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For example, to list the top 10 CPU consuming processes use:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要列出前10个CPU消耗最多的进程，请使用：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here processes are sorted in descending order by percentage of CPU usage and
    `head` is applied to extract the top 10 processes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，进程按CPU使用率的降序排序，并且应用`head`来提取前10个进程。
- en: 'We can use `grep` to extract entries in the `ps` output related to a given
    process name or another parameter. In order to find out entries about running
    bash processes use:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`grep`来提取与给定进程名称或其他参数相关的`ps`输出条目。为了找出关于运行bash进程的条目，请使用：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finding process ID when given command names
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找给定命令名称时的进程ID
- en: 'Suppose several instances of a command are being executed, we may need to identify
    the process ID of the processes. This information can be found by using the `ps`
    or the `pgrep` command. We can use `ps` as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设正在执行某个命令的几个实例，我们可能需要识别这些进程的进程ID。可以通过使用`ps`或`pgrep`命令来找到这些信息。我们可以使用`ps`如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `-o` user defined format specifier was described in the earlier part of
    the recipe. But here you can see `=` appended with `pid`. This is to remove the
    header PID in the output of `ps`. In order to remove headers for each column,
    append `=` to the parameter. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的前面部分描述了`-o`用户定义格式说明符。但是在这里你可以看到`=`与`pid`附加在一起。这是为了在`ps`的输出中移除标题PID。为了移除每列的标题，将`=`附加到参数上。例如：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command lists the process IDs of bash processes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列出bash进程的进程ID。
- en: 'Alternately, there is a handy command called `pgrep`. You should use `pgrep`
    to get a quick list of process IDs for a particular command. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个方便的命令叫做`pgrep`。您应该使用`pgrep`来快速获取特定命令的进程ID列表。例如：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`pgrep` requires only a portion of the command name as its input argument to
    extract a Bash command, for example, `pgrep ash` or `pgrep bas` will also work.
    But `ps` requires you to type the exact command.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`只需要命令名称的一部分作为其输入参数来提取Bash命令，例如，`pgrep ash`或`pgrep bas`也可以工作。但是`ps`需要您输入确切的命令。'
- en: '`pgrep` accepts many more output-filtering options. In order to specify a delimiter
    character for output rather than using a newline as the delimiter use:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`接受许多其他输出过滤选项。为了指定一个分隔符字符来输出，而不是使用换行符作为分隔符，请使用：'
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Specify a list of owners of the user for the matching processes as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 指定匹配进程的用户所有者列表如下：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this command, `root` and `slynux` are users.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`root`和`slynux`是用户。
- en: 'Return the count of matching processes as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回匹配进程的计数如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Filters with ps for real user or ID, effective user or ID
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ps进行真实用户或ID、有效用户或ID的过滤
- en: 'With `ps`, it is possible to group processes based on the real and effective
    user name or ID specified. Specified arguments can be used to filter the `ps`
    output by checking whether each entry belongs to a specific, effective user or
    real user from the list of arguments and shows only the entries matching them.
    This can be done as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps`可以根据指定的真实用户和有效用户名称或ID对进程进行分组。指定的参数可以用来通过检查每个条目是否属于特定的有效用户或真实用户的列表来过滤`ps`的输出，并仅显示与它们匹配的条目。可以按以下方式完成：
- en: Specify an effective users list by using `-u EUSER1, EUSER2` and so on
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`-u EUSER1, EUSER2`等来指定有效用户列表
- en: Specify a real users list by using `-U RUSER1, RUSER2` and so on
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`-U RUSER1, RUSER2`等指定真实用户列表
- en: 'For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command will show all processes running with `root` as the effective user
    ID and real user ID, and will also show the user and percentage CPU usage columns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示所有以`root`作为有效用户ID和真实用户ID运行的进程，并且还将显示用户和CPU使用率百分比列。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Mostly, we find `-o` along with `-e` as `-eo`. But when filters are applied
    `-o` should act alone as mentioned above.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在`-eo`中找到`-o`和`-e`。但是当应用筛选器时，`-o`应该像上面提到的那样单独起作用。
- en: TTY filter for ps
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于ps的TTY筛选器
- en: 'The `ps` output can be selected by specifying the TTY to which the process
    is attached. Use the `-t` option to specify the TTY list as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定进程附加到的TTY来选择`ps`输出。使用`-t`选项来指定TTY列表如下：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Information about process threads
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有关进程线程的信息
- en: 'Usually, information about process threads are hidden in the `ps` output. We
    can show information about threads in the `ps` output by adding the `-L` option.
    Then it will show two columns NLWP and NLP. NLWP is the thread count for a process
    and NLP is the thread ID for each entry in PS. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于进程线程的信息在`ps`输出中是隐藏的。我们可以通过添加`-L`选项来在`ps`输出中显示有关线程的信息。然后它将显示两列NLWP和NLP。NLWP是进程的线程计数，NLP是PS中每个条目的线程ID。例如：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command lists 10 processes with maximum number of threads.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出了具有最大线程数的10个进程。
- en: Specifying output width and columns to be displayed
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定输出宽度和要显示的列
- en: 'We can specify the columns to be displayed in the `ps` output using the user-defined
    output format specifier `-o`. Another way to specify the output format is with
    "standard" options. Practice them according to your usage style. Try these options:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用用户定义的输出格式说明符`-o`来指定要在`ps`输出中显示的列。另一种指定输出格式的方法是使用“标准”选项。根据您的使用风格进行练习。尝试这些选项：
- en: '`-f ps –ef`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f ps –ef`'
- en: '`u ps -e u`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u ps -e u`'
- en: '`ps ps -e w` (w stands for wide output)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps ps -e w`（w代表宽输出）'
- en: Showing environment variables for a process
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示进程的环境变量
- en: Understanding which environment variables a process is depended on is a very
    useful bit of information we might need. Whether or not a process works might
    be heavily dependent on the environmental variables set. We can debug and make
    use of environment data for fixing several problems related to running of processes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 了解进程依赖的环境变量是我们可能需要的非常有用的信息。进程是否工作可能严重依赖于设置的环境变量。我们可以调试并利用环境数据来解决与进程运行相关的几个问题。
- en: 'In order to list environment variables along with `ps` entries use:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出`ps`条目以及环境变量，请使用：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An example of where this type of environment tracing can come in handy is in
    tracing problems with the apt-get package manager. If you use an HTTP proxy to
    connect to the internet, you may need to set environment variables `http_proxy=host:port`.
    But sometimes even when it is set, the `apt-get` command will not select the proxy
    and hence it returns an error. Then you can actually look at an environment variable
    and track the issue.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的环境跟踪可以派上用场的一个例子是跟踪apt-get软件包管理器的问题。如果您使用HTTP代理连接到互联网，您可能需要设置环境变量`http_proxy=host:port`。但有时即使设置了，`apt-get`命令也不会选择代理，因此会返回错误。然后您可以实际查看环境变量并跟踪问题。
- en: 'We may need some applications to be run automatically with scheduling tools
    such as `crontab`. But it might be dependent on some environment variables. Suppose
    we want to open a GUI-windowed application at a given time. We schedule it using
    `crontab` at a specified time. However, you will notice that the application will
    not start at a given time if an entry like the following is given:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要一些应用程序使用诸如`crontab`之类的调度工具自动运行。但它可能取决于一些环境变量。假设我们想在指定时间打开一个GUI窗口应用程序。我们使用`crontab`在指定时间安排它。但是，如果给出以下条目，您会注意到该应用程序不会在指定时间启动：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is because a windowed application always depends on the DISPLAY environment
    variable. Environment variables need to be passed to the application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为窗口应用程序始终依赖于DISPLAY环境变量。环境变量需要传递给应用程序。
- en: First run `windowapp` manually, and then run `ps -C windowapp -eo cmd e`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先手动运行`windowapp`，然后运行`ps -C windowapp -eo cmd e`。
- en: Find out the environment variables. Prefix them before a command name appears
    in `crontab`. The issue will get resolved.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查找环境变量。在`crontab`中出现命令名称之前加上前缀。问题将得到解决。
- en: 'Modify the entry as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将条目修改如下：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`DISPLAY=:0` can be obtained from the `ps` output.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`DISPLAY=:0`可以从`ps`输出中获取。'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Scheduling with cron*, explains how to schedule tasks'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用cron进行调度*，解释如何安排任务'
- en: Killing processes and send or respond to signals
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程并发送或响应信号
- en: Termination of processes is an important task we always come across. Sometimes
    we may need to terminate all the instances of a program. The command line provides
    several options for terminating programs. An important concept regarding processes
    in UNIX-like environments is that of signals. Signals are an inter-process communication
    mechanism used to interrupt running process to perform some action. Termination
    of a program is also performed by using the signals technique. This recipe is
    an introduction to signals and the usage of signals.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 终止进程是我们经常遇到的重要任务。有时我们可能需要终止程序的所有实例。命令行提供了几种终止程序的选项。关于类UNIX环境中进程的一个重要概念是信号。信号是一种用于中断运行进程以执行某些操作的进程间通信机制。程序的终止也是通过使用信号技术来执行的。本文介绍了信号和信号的使用。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Signals are an inter-process mechanism available in Linux. We can interrupt
    a process by using a specific signal. Each signal is associated with an integer
    value. When a process receives a signal, it responds by executing a signal handler.
    In Shell scripting also, it is possible to send and receive signals and respond
    according to the signals. `KILL` is a signal used to terminate a process. Events
    such as *Ctrl* + *C*, *Ctrl* + *Z* are also types of signals. The `kill` command
    is used to send signals to processes and the `trap` command is used to handle
    the received signals.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to list all the signals available, use:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It will print the signal number and signal names.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminate a process as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `kill` command issues a TERM signal by default. The process ID list is to
    be specified with space as a delimiter between process IDs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to specify a signal to be sent to a process via the `kill` command
    use:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `SIGNAL` argument is either a signal name or a signal number. Though there
    are many signals specified for different purposes, we frequently use only a few
    signals. They are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP 1`—hangup detection on death of controlling process or terminal'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT 2`—signal which is emitted when *Ctrl* + *C* is pressed'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL 9`—signal used to force kill the process'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM -15`—signal used to terminate a process by default'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTSTP 20`—signal emitted when *Ctrl* + *Z* is pressed'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We frequently use force kill for processes. In order to force kill a process,
    use:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's walk through additional commands used for terminating and signalling processes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: kill family of commands
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `kill` command takes the process ID as argument. There are also a few other
    commands in the `kill` family that accept the command name as argument and send
    a signal to the process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The `killall` command terminates the process by name as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order to send a signal to a process by name use:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to force kill process by name use:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Specify the process by name, which is specified by users who own it, by using:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In order to ask interactively before killing processes, use the `-i` argument
    along with `killall`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pkill` command is similar to the `kill` command but it, by default, accepts
    a process name instead of a process ID. For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`SIGNAL` is the signal number. `SIGNAL` name is not supported with `pkill`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: It provides many of the same options that the `kill` command does. Check the
    `pkill` manpages for more details.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and responding to signals
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`trap` is a command used to assign signal handler to signals in a script. Once
    a function is assigned to a signal using the `trap` command, while the script
    runs and it receives a signal, this function is executed upon reception of a corresponding
    signal.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`SIGNAL LIST` is delimited by space. It can be a signal number or a signal
    name.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a shell script that responds to the `SIGINT` signal:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run this script in a terminal. When the script is running, if you press *Ctrl*
    + *C* it will show the message by executing the signal handler associated with
    it. *Ctrl* + *C* is a `SIGINT` signal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is used to keep the process running without going to termination
    by using an infinite loop. Thus the process is kept running infinitely so that
    it can respond to the signals that are sent to the process asynchronously by another
    process. The loop that is used to keep the process alive infinitely is often called
    as the event loop. If an infinite loop is not available, the script will terminate
    after executing the statements. But for signal handler scripts, it has to wait
    and respond to the signals.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We can send a signal to the script by using the `kill` command and the process
    ID of the script:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `PROCESS_ID` of the above script will be printed when it is executed. Or
    you can find it out by using the `ps` command
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If no signal handlers are specified for signals, it will call the default signal
    handlers assigned by the operating system. Generally, pressing *Ctrl* + *C* will
    terminate a program since the default handler provided by the operating system
    will terminate the process. But the custom handler defined here specifies a custom
    action upon receipt of the signal.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We can define signal handlers for any signals available (`kill -l`), by using
    the `trap` command. It is also possible to set a single signal handler for multiple
    signals.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: which, whereis, file, whatis, and loadavg explained
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe aims to explain a few commands we come across. Understanding these
    commands is helpful for users.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through each of the commands and their usage examples.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**which**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `which` command is used to find the location of a command. We type commands
    in the terminal without knowing the location where the executable file is stored.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'When we type a command, the terminal looks for the command in a set of locations
    and executes the executable file if found at the location. This set of locations
    is specified using an environment variable `PATH`. For example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can export `PATH` and can add our own locations to be searched when command
    names are typed. For example, to add `/home/slynux/bin` to `PATH` use the following
    command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `which` command outputs the location of the command given as argument.
    For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**whereis**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereis` is similar to the `which` command. But it not only returns the path
    of the command, it will also print the location of the manpage, if available,
    and also the path of the source code for the command if available. For example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**file**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `file` command is an interesting and frequently-used command. It is used
    for determining the file type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will print the details of the file regarding its file type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**whatis**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `whatis` command outputs a one-line description of the command given as
    an argument. It parses information from the manpage. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**apropos**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to search if some command related to a word exists. Then
    we can search the manpages for strings in the command. For this we can use:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`apropos COMMAND`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '**Load average**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load average is an important parameter for total load on the running system.
    It specifies the average of the total number of runnable processes on the system.
    It is specified by three values. The first value indicates the average in one
    minute, the second indicates average in five minutes, and third indicates the
    average in 15 minutes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be obtained by running `uptime`. For example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Sending messages to user terminals
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system administrator may need to send messages to the terminal screen of every
    user or a specified user on all the machines over a network. This recipe is a
    guide to perform this task.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wall` is a command that is used to write messages on the terminals of all
    logged in users. It can be used to convey messages to all logged in users in a
    server or multiple access machines. Sending messages to all users may, sometimes,
    not be useful. We may need to send messages to specific users or a specific terminal.
    Terminals are treated as devices in a Linux system and hence these opened terminals
    will have a corresponding device node file at `/dev/pts/`. Writing data to a specific
    device will display messages on the corresponding terminal.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to broadcast a message to all users and all logged in terminals, use:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The message outline will show who sent the message (which user and which host).
    The message gets OR is displayed to the current terminal if some other users send
    a message, only if the "write message" option is enabled. By default, in most
    distros "write message" is enabled by default. If the sender of the message is
    root, then the message gets displayed on the screen irrespective of whether the
    "write message" option is enabled or disabled by the user.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable write messages use:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用写入消息，请使用：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to disable write messages use:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了禁用写入消息，请使用：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s write a script for sending messages specifically to a given user''s
    terminal:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个专门向给定用户终端发送消息的脚本：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the script as:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行脚本：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, slynux's terminal will receive the message text.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，slynux的终端将接收消息文本。
- en: How it works...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `/dev/pts` directory will contain character devices corresponding to each
    of the logged in terminals on the system. We can find out who logged into which
    terminal by looking at the owner of the device files. The `ls -l` output will
    contain the owner name and the device path. This information is extracted by using
    `awk`. Then it uses `grep` to extract the lines corresponding to specified user
    only. The username is accepted as the first argument for the script as stored
    as variable USER. Then a list of terminals for a given user is made. A `for` loop
    is used to iterate through each device path. `/dev/stdin` will contain standard
    input data passed to the current process. Therefore, by reading `/dev/stdin`,
    data is read and redirected to the corresponding terminal (TTY) devices. Hence
    the message gets displayed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/pts`目录将包含与系统上每个已登录终端对应的字符设备。我们可以通过查看设备文件的所有者来找出谁登录到哪个终端。`ls -l`输出将包含所有者名称和设备路径。这些信息是通过使用`awk`提取的。然后它使用`grep`仅提取对应于指定用户的行。用户名作为脚本的第一个参数被接受并存储为变量USER。然后制作给定用户的终端列表。使用`for`循环来迭代每个设备路径。`/dev/stdin`将包含传递给当前进程的标准输入数据。因此，通过读取`/dev/stdin`，数据被读取并重定向到相应的终端（TTY）设备。因此消息被显示。'
- en: Gathering system information
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集系统信息
- en: Collecting information about the current system from the command line is very
    important in logging system data. The different system information data includes
    hostname, kernel version, Linux distro name, CPU information, memory information,
    disk partition information, and so on. This recipe will show you different sources
    in a Linux system to gather information about the system.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行收集有关当前系统的信息非常重要，用于记录系统数据。不同的系统信息数据包括主机名、内核版本、Linux发行版名称、CPU信息、内存信息、磁盘分区信息等。本教程将向您展示在Linux系统中收集有关系统信息的不同来源。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to print the hostname of the current system, use:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印当前系统的主机名，使用：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Print long details about the Linux kernel version, hardware architecture, and
    more by using:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下方式打印有关Linux内核版本、硬件架构等的详细信息：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In order to print the kernel release, use:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印内核版本，使用：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Print the machine type as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式打印机器类型：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to print details about CPU details, use:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印有关CPU详细信息，使用：
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to extract the processor name, use:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取处理器名称，使用：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The fifth line contains the processor name. Therefore, the first five lines
    are extracted first. Then the last one line is extracted to print processor name.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第五行包含处理器名称。因此，首先提取前五行。然后提取最后一行以打印处理器名称。
- en: 'Print details about memory or RAM as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式打印有关内存或RAM的详细信息：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Print the total memory (RAM) available on the system as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式打印系统上可用的总内存（RAM）：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In order to list out the partitions information available on the system, use:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出系统上可用的分区信息，使用：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Or:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Get the entire details about the system as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式获取有关系统的完整详细信息：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using /proc – gathering information
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用/proc – 收集信息
- en: '`/proc` is an in-memory pseudo filesystem available on GNU/Linux operating
    systems. It was introduced to provide an interface to read several system parameters
    from a user space. It is very interesting and we can gather lots of information
    from it. Let''s see few of the features available with the `proc` filesystem.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc`是GNU/Linux操作系统上可用的内存伪文件系统。它被引入以提供一个接口，从用户空间读取几个系统参数。这非常有趣，我们可以从中收集大量信息。让我们看看`proc`文件系统提供的一些功能。'
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you look at `/proc`, you can see several files and directories. Some of them
    are already explained in another recipe in this chapter. You can simply `cat`
    files in `/proc` and the subdirectories to get information. All of them are well-formatted
    text.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`/proc`，您可以看到几个文件和目录。其中一些在本章的另一个教程中已经解释过。您可以简单地`cat`文件和子目录中的文件，以获取信息。所有这些都是格式良好的文本。
- en: There will be a directory in `/proc` for every process that is running on the
    system. The directory name for a process in `/proc` is same as that of process
    ID of that process.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上运行的每个进程都将在`/proc`中有一个目录。在`/proc`中进程的目录名称与该进程的进程ID相同。
- en: Suppose for Bash, the process ID is 4295 (`pgrep bash`), `/proc/4295` will exist.
    Each of the directories corresponding to the process will contain a lot of information
    regarding that process. Few of the important files in `/proc/PID` are as follows.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于Bash，进程ID为4295（`pgrep bash`），`/proc/4295`将存在。与该进程对应的每个目录都将包含有关该进程的大量信息。`/proc/PID`中的一些重要文件如下。
- en: '`environ`—contains environment variables associated with that process.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environ`—包含与该进程关联的环境变量。'
- en: By `cat /proc/4295/environ` we can display all the environment variables passed
    to that process.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`cat /proc/4295/environ`，我们可以显示传递给该进程的所有环境变量。
- en: '`cwd`—is a symlink to a working directory of the process.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cwd`—是进程的工作目录的符号链接。'
- en: '`exe`—is a symlink to the running executable for the current process.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exe`—是当前进程的运行可执行文件的符号链接。'
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`fd`—is the directory consisting of entries on file descriptors used by the
    process.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fd`—是由进程使用的文件描述符条目组成的目录。'
- en: Scheduling with cron
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cron进行调度
- en: It is a common requirement to schedule the execution of scripts at a given time
    or at given time intervals. The GNU/Linux system comes with different utilities
    for scheduling tasks. `cron` is such a utility that allows tasks to automatically
    run in the background of the system at regular intervals by use of the `cron`
    daemon. The `cron` utility makes use of a file called "cron table" that stores
    a list of schedule of scripts or commands to be executed and the time at which
    they are to be executed. It is a very useful utility. A common example usage is
    to schedule downloads of files from the Internet during the free hours (certain
    ISPs provide free usage - usually during the night when most people are sleeping).
    Users are not required to wake up in the night to start the download. Users can
    write a cron entry and schedule the download. You can also schedule to drop the
    Internet connection automatically and shut down the system when the free usage
    hours end.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定时间或给定时间间隔执行脚本是一个常见的需求。GNU/Linux系统配备了不同的实用程序来安排任务。`cron`就是这样一个实用程序，它允许任务在系统的后台通过`cron`守护程序定期自动运行。`cron`实用程序使用一个名为“cron表”的文件，其中存储了要执行的脚本或命令的时间表以及它们要执行的时间。这是一个非常有用的实用程序。一个常见的用法是在空闲时间（某些ISP提供免费使用的时间，通常是在大多数人睡觉的夜间）安排从互联网下载文件。用户不需要在夜间醒来开始下载。用户可以编写一个cron条目并安排下载。您还可以安排在免费使用时间结束时自动断开互联网连接并关闭系统。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The cron scheduling utility comes with all the GNU/Linux distributions by default.
    Once we write the cron table entry, the commands will be executed at the time
    specified for execution. The command `crontab` is used to add schedule entries
    to the cron schedule domain. A cron schedule is a simple text file. Each user
    has his or her own cron schedule. A cron schedule is often called a cron job.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: cron调度实用程序默认随所有GNU/Linux发行版一起提供。一旦我们编写了cron表条目，命令将在指定的执行时间执行。`crontab`命令用于向cron调度域添加调度条目。cron调度是一个简单的文本文件。每个用户都有自己的cron调度。cron调度通常称为cron作业。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to schedule tasks, we should know the format for writing the cron
    table. A cron job specifies the path of a script or command to be executed and
    the time at which it is to be executed. Each cron table consists of six sections
    in the following order:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安排任务，我们应该知道编写cron表的格式。cron作业指定要执行的脚本或命令的路径以及要执行的时间。每个cron表由以下顺序的六个部分组成：
- en: Minute (0 - 59)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟（0-59）
- en: Hour (0 - 23)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时（0-23）
- en: Day (1 - 31)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天（1-31）
- en: Month (1 - 12)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月（1-12）
- en: Weekday (0 - 6)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作日（0-6）
- en: COMMAND (the script or command to be executed at the specified time)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COMMAND（要在指定时间执行的脚本或命令）
- en: The first five sections specify the time at which an instance of the command
    is to be executed. There are a few additional options to specify the time schedule.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个部分指定要执行命令的实例的时间。还有一些其他选项可以指定时间表。
- en: 'An asterisk (`*`) is used to specify that the command should be executed at
    every instance of time. That is, if `*` is written in the hours field in the cron
    job, the command will be executed for every hour. Similarly, if you would like
    to execute the command at multiple instances of a particular time period, specify
    the time period separated by comma in the corresponding time field (for example,
    for running the command at the fifth minute and tenth minute, enter `5,10` in
    the minutes field). We also have another nice option to run the command at particular
    divisions of time. Use `*/5` in the minutes field for running the command at every
    five minutes. We can apply this to any time field. A cron table entry can consist
    of one or more lines of cron jobs. Each line in the cron table entry is a single
    job. For example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）用于指定命令应在每个时间实例执行。也就是说，如果在cron作业的小时字段中写入`*`，则命令将每小时执行一次。同样，如果您想要在特定时间段的多个实例执行命令，请在相应的时间字段中用逗号分隔指定时间段（例如，要在第五分钟和第十分钟运行命令，请在分钟字段中输入`5,10`）。我们还有另一个很好的选项，可以在特定的时间间隔运行命令。在分钟字段中使用`*/5`以在每五分钟运行一次命令。我们可以将此应用于任何时间字段。cron表条目可以包含一个或多个cron作业的行。cron表条目中的每一行都是一个作业。例如：
- en: 'Let''s write a sample `crontab` entry for illustration:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们写一个示例`crontab`条目以进行说明：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This cron job will execute the `test.sh` script at the second minute of all
    hours on all days.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此cron作业将在所有小时的所有天的第二分钟执行`test.sh`脚本。
- en: 'In order to run the script at fifth, sixth, and seventh hours on all days,
    use:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在所有天的第五、第六和第七小时运行脚本，使用：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Execute `script.sh` at every hour on Sundays as follows:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个星期日的每个小时执行`script.sh`如下：
- en: '[PRE69]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Shut down the computer at 2am everyday as follows:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天凌晨2点关闭计算机如下：
- en: '[PRE70]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, let us see how to schedule a cron job. You can execute the `crontab` command
    in multiple ways to schedule the scripts.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何安排cron作业。您可以以多种方式执行`crontab`命令以安排脚本。
- en: 'When you run the `crontab` manually, use the `–e` option to enter the cron
    job:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当您手动运行`crontab`时，使用`-e`选项输入cron作业：
- en: '[PRE71]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When `crontab –e` is entered, the default text editor (usually vi) is opened
    up and the user can type the cron job and save it. This cron job will be scheduled
    and executed at specified time intervals.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`crontab -e`后，将打开默认的文本编辑器（通常是vi），用户可以输入cron作业并保存。此cron作业将按指定的时间间隔进行调度和执行。
- en: 'There are two other methods we usually use when we invoke the `crontab` command
    inside a script for scheduling tasks:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在脚本中调用`crontab`命令进行任务调度时，我们通常使用另外两种方法：
- en: Create a text file (for example, `task.cron`) and write the cron job.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件（例如`task.cron`）并编写cron作业。
- en: 'Then run the `crontab` with the filename as the command argument:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用文件名作为命令参数运行`crontab`：
- en: '[PRE72]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'By using the next method we can specify the cron job inline without creating
    a separate file. For example:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用下一种方法，我们可以在不创建单独文件的情况下指定内联的cron作业。例如：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The cron job needs to be written in between `crontab<<EOF and EOF`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: cron作业需要在`crontab<<EOF和EOF`之间编写。
- en: Cron jobs are executed with privileges with which the `crontab` command is executed.
    If you need to execute commands that require higher privileges, such as a command
    for shutting down the computer, run the `crontab` command as root.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`crontab`命令执行Cron作业时具有特权。如果需要执行需要更高特权的命令，比如关机命令，需要以root身份运行`crontab`命令。
- en: The commands specified in the cronjob are written with the full path to the
    command. This is because the environment in which a cron job is executed is different
    from the one that we execute on a terminal. Hence the `PATH` environment variable
    may not be set. If your command requires certain environment variables to be set
    for running, you should explicitly set the environment variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在cron作业中指定的命令使用完整路径写入。这是因为cron作业执行的环境与我们在终端上执行的环境不同。因此`PATH`环境变量可能未设置。如果您的命令需要设置某些环境变量才能运行，您应该显式设置环境变量。
- en: There's more…
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `crontab` command has more options. Let's see a few of them.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`crontab`命令还有更多选项。让我们看一些。'
- en: Specifying environment variables
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定环境变量
- en: Many of the commands require environment variables to be set properly for execution.
    We can set environment variables by inserting a line with variable assignment
    statement in the cron table of the user.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令要求环境变量正确设置才能执行。我们可以通过在用户的cron表中插入一个带有变量赋值语句的行来设置环境变量。
- en: 'For example, if you are using a proxy server for connecting to the Internet,
    to schedule a command that uses Internet you have to set the HTTP proxy environment
    variable `http_proxy`. It can be done as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您使用代理服务器连接到互联网，要安排使用互联网的命令，您必须设置HTTP代理环境变量`http_proxy`。可以按以下方式完成：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Viewing the cron table
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看cron表
- en: 'We can list the existing cronjobs using the `–l` option:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-l`选项列出现有的cron作业：
- en: '[PRE75]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `crontab –l` lists the existing entries in the cron table for the current
    user.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`crontab -l`列出当前用户的cron表中的现有条目。'
- en: 'We can also view the cron table for other users by specifying username with
    the `–u` option as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`-u`选项指定用户名来查看其他用户的cron表，如下所示：
- en: '[PRE76]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You should run as root when you use the `–u` option to gain higher privilege.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`-u`选项获取更高特权时，应以root身份运行。
- en: Removing the cron table
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除cron表
- en: 'We can remove the crontable for the current user using the `–r` option:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-r`选项删除当前用户的cron表：
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In order to remove crontab for another user, use:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除另一个用户的cron表，使用：
- en: '[PRE78]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Run as root to get higher privilege.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以root身份运行以获得更高特权。
- en: Writing and reading MySQL database from Bash
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Bash中写入和读取MySQL数据库
- en: 'MySQL is a widely used Database System. Usually, MySQL databases are used as
    the storage systems for applications that are written in languages such as PHP,
    Python, C++, and so on. Accessing and manipulating MySQL databases from shell
    script will be interesting. We can write scripts to write contents from a text
    file or CSV (Comma Separated Values) into tables and interact with the MySQL database
    to read and manipulate data. For example, we can read all the e-mail addresses
    stored in a guestbook program''s database by running a query from the shell script.
    In this recipe, we will see how to read and write to a MySQL database from Bash.
    For illustration, here is an example problem:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL是一个广泛使用的数据库系统。通常，MySQL数据库用作使用PHP、Python、C++等语言编写的应用程序的存储系统。从shell脚本访问和操作MySQL数据库将会很有趣。我们可以编写脚本将文本文件或CSV（逗号分隔值）中的内容写入表中，并与MySQL数据库交互以读取和操作数据。例如，我们可以通过从shell脚本运行查询来读取存储在留言板程序数据库中的所有电子邮件地址。在本教程中，我们将看到如何从Bash中读取和写入MySQL数据库。例如，这是一个示例问题：
- en: I have a CSV file containing details of students. I need to insert the contents
    of the file to a database table. From this data, I need to generate a separate
    rank list for each department.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个包含学生详细信息的CSV文件。我需要将文件内容插入数据库表中。根据这些数据，我需要为每个部门生成一个单独的排名表。
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to handle MySQL databases, you should have mysql-server and mysql-client
    packages installed on your system. These tools do not come with a Linux distribution
    by default. Since MySQL comes with a username and password for authentication,
    you should have a username and password to run the scripts.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理MySQL数据库，您应该在系统上安装mysql-server和mysql-client软件包。这些工具不会默认随Linux发行版提供。由于MySQL带有用于身份验证的用户名和密码，您应该有一个用户名和密码来运行脚本。
- en: How to do it…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The above problem can be solved using Bash utilities such as `sort`, `awk`,
    and so on. Alternately, we can solve it by using an SQL database table. We will
    write three scripts for the purpose of creating a database and table, inserting
    student data into the table, and reading and displaying processed data from the
    table.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Bash实用程序（如`sort`、`awk`等）解决上述问题。或者，我们可以通过使用SQL数据库表来解决。我们将为创建数据库和表、将学生数据插入表中以及从表中读取和显示处理后的数据编写三个脚本。
- en: 'Create the database and table script as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库和表的脚本如下：
- en: '[PRE79]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The script for inserting data into the table is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 插入数据到表的脚本如下：
- en: '[PRE80]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The script for the query from the database is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库查询的脚本如下：
- en: '[PRE81]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The data for the input CSV file (`studentdata.csv`) is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输入CSV文件（`studentdata.csv`）的数据如下：
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Execute the scripts in the following sequence:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下顺序执行脚本：
- en: '[PRE83]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We will now see the explanation of the above scripts one by one. The first script
    `create_db.sh` is used to create database called `students` and a table named
    `students` inside it. We need the MySQL username and password to access or modify
    data in the DBMS. The variables `USER` and `PASS` are used to store the username
    and password. The `mysql` command is used for MySQL manipulations. The `mysql`
    command can specify the username by using `–u` and the password by using `–pPASSWORD`.
    The other command argument for the `mysql` command is the database name. If a
    database name is specified as an argument to the `mysql` command, it will use
    that for database operations, else we have to explicitly specify in the SQL query
    about which database is to be used with the `use database_name` query. The `mysql`
    command accepts the queries to be executed through standard input (`stdin`). The
    convenient way of supplying multiple lines through `stdin` is by using the `<<EOF`
    method. The text that appears in between `<<EOF` and `EOF` is passed to `mysql`
    as standard input. In the `CREATE DATABASE` query, we have redirected `stderr`
    to `/dev/null` in order to prevent displaying an error message. Also, in the table
    creation query, we have redirected `stderr` to `/dev/null` to ignore any errors
    that occur. Then we check the exit status for the `mysql` command by using the
    exit status variable `$?` to know if a table or database already exists. If the
    database or table already exists, a message is displayed to notify that. Else
    we will create them.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: The next script `write_to_db.sh` accepts a filename of the student data CSV
    file. We read each line of the CSV file by using the `while` loop. So in each
    iteration a line with comma separated values will be received. We then need to
    formulate the values in the line to an SQL query. For that, the easiest way to
    store data items in the comma separated line is by using an array. We know that
    an array assignment is in the form `array=(val1 val2 val3)`. Here the space character
    is the **Internal** **Field** **Separator** (**IFS**). We have a line with comma
    separated values, hence by changing the IFS to a comma, we can easily assign values
    to the array (`IFS=,`). The data items in the comma separated line are `id`, `name`,
    `mark`, and `department`. `id` and `mark` are integer values whereas `name` and
    `dept` are strings (strings must be quoted). Also the name can contain space characters.
    Space can conflict with the Internal Field Separator. Hence we should replace
    the space in the name with some character (`#`) and replace it later after formulating
    the query. In order to quote the strings, the values in the array are prefixed
    and suffixed with `\"`. The `tr` is used to substitute space in the name to `#`.
    Finally, the query is formed by replacing the space character with comma and replacing
    `#` with space and this query is executed.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The third script `read_db.sh` is used to find out the department and print the
    rank list of students for each department. The first query is used to find distinct
    names of departments. We use a `while` loop to iterate through each department
    and run the query to display student details in the order of highest marks. `SET
    @i=0` is an SQL construct used to set the variable `i=0`. On each row it is incremented
    and is displayed as the rank of the student.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: User administration script
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU/Linux is a multi user operating system. Many users can log in and perform
    several activities at a time. There are several administration tasks that are
    handled with user management. The tasks includes setting the default shell for
    the user, disabling a user account, disabling a shell account, adding new users,
    removing users, setting a password, setting an expiry date for a user account,
    and so on. This recipe aims at writing a user management tool that can handle
    all of these tasks.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the user administration script:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'A sample output is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works…
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `user_adm.sh` script can be used to perform many user management tasks.
    You can follow the `usage()` text for the proper usage of the script. A function
    `usage()` is defined to display how to execute the script with different options
    for the user when any of the parameters given by user gets wrong or has run the
    `–usage` parameter. A case statement is used to match the command arguments and
    execute the corresponding commands according to that. The valid command options
    for the `user_adm.sh` script are: `-adduser`, `-deluser`, `-shell`, `-disable`,
    `-enable`, `-expiry`, `-passwd`, `-newgroup`, `-delgroup`, `-addgroup`, `-details`,
    and `-usage`. When the `*)` case is matched, it means its a wrong option and hence
    `usage()` is invoked. For each match case, we have used `[ $# -ne 3 ] && usage`.
    It is used for checking number of arguments. If the number of command arguments
    are not equal to required number, the `usage()` function is invoked and the script
    will exit without executing further. In order to run the user management commands,
    the script needs to be run as root. Hence a check for user ID 0 (the root has
    user ID 0) is performed. If the user has a non-zero user ID, this means it is
    executing as non-root. Hence a message to run as root is displayed and the script
    exits.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain each case one by one:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '`-useradd`:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `useradd` command can be used to create a new user. It has the syntax:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `-m` option is used to create the home directory
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to provide the full name of the user by using the `–c FULLNAME`
    option.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`-deluser`:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `deluser` command can be used to remove the user. The syntax is:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`--remove-all-files` is used to remove all files associated with the user including
    the home directory.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`-shell`:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chsh` command is used to change the default shell for the user. The syntax
    is:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`-disable` and `–enable`:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `usermod` command is used to manipulate several attributes related to user
    accounts.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`usermod –L USER` locks the user account and `usermod –U USER` unlocks the
    user account.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '`-expiry`:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chage` command is used manipulate user account expiry information. The
    syntax is:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '`chage –E DATE`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional options as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`-m MIN_DAYS` (set the minimum number of days between password changes to `MIN_DAYS`)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-M MAX_DAYS` (set the maximum number of days during which a password is valid)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-W WARN_DAYS` (set the number of days of warning before a password change
    is required)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-passwd`:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `passwd` command is used to change passwords for the users. The syntax
    is:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`passwd USER`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The command will prompt to enter new password.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`-newgroup` and `addgroup`:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `addgroup` command will add a new usergroup to the system. The syntax is:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`addgroup GROUP`'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add an existing user to a group use:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '`addgroup USER GROUP`'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`-delgroup`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delgroup` command will remove a user group. The syntax is:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`delgroup GROUP`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`-details`:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finger USER` command will display the user information for the user, which
    includes details such as user home directory path, last login time, default shell,
    and so on. The `chage –l` command will display the user account expiry information.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Bulk image resizing and format conversion
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of us use digital cameras and download photos from the cameras as well as
    the Internet. When we need to deal with large number of image files, we can use
    scripts to easily perform actions on the files in bulk. A regular task we come
    across with photos is resizing the file. Also, format conversion from one image
    format to another comes to use (for example, JPEG to PNG conversion). When we
    download pictures from a camera, the large resolution pictures take a large size.
    But we may need pictures of lower sizes that are convenient to store and e-mail
    over the internet. Hence we resize it to lower resolutions. This recipe will discuss
    how to use scripts for image management.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Imagemagick** is an excellent tool for manipulating images that can work
    across several image formats and different constructs with rich options. Most
    of the GNU/Linux distributions don''t come with Imagemagick installed. You need
    to manually install the package. `convert` is the command that we will use frequently.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: How to do it..
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to convert from one image format to another image format use:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'For example:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We can resize an image size to a specified image size either by specifying the
    scale percentage or by specifying width and height of the output image.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Resize the image by specifying the `WIDTH` or `HEIGHT` as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For example:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It is required to provide either `WIDTH` or `HEIGHT` so that the other will
    be automatically calculated and resized so as to preserve the image size ratio:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'For example:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Resize the image by specifying the percentage scale factor as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Let''s see a script for image management:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The following is a sample output, to scale the images in the directory `sample_dir`
    to `20%` size:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In order to scale the images to width 1024 use:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Change the files to PNG format by adding `–ext png` along with the above commands.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Scale or convert files with specified destination directory as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works…
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above `image_help.sh` script can accept several command-line arguments,
    such as -`source`, `-percent`, `-scale`, `–ext`, and `-dest`. A brief explanation
    of each is as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The `-source` parameter is used to specify the source directory for the images.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–percent` parameter is used to specify the scale percent and `–scale` is
    used to specify scale width and height.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either `–percent` or `–scale` is used. Both of them do not appear simultaneously.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–ext` parameter is used to specify the target file format. `–ext` is optional;
    if it is not specified, format conversion is not performed.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–dest` parameter is used to specify the destination directory for scale
    or conversion of image files. `–dest` is optional. If `–dest` is not specified,
    the destination directory will be same as the source directory. As the first step
    in the script, it checks whether the number of command arguments given to the
    script are correct. Either 4 or 6 or 8 parameters can appear.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, by using a `while` loop and case statement, we will parse the command-line
    arguments corresponding to variables. `$#` is a special variable that returns
    the number of arguments. The `shift` command shifts the command arguments one
    position to left, so that on each execution of shift, we can access command arguments
    one by one, by using the same `$1` variable rather than using `$1`, `$2`, `$3,`
    and so on. The case statement matches the value of `$1`. It is like a switch statement
    in the C programming language. When a case is matched, the corresponding statements
    are executed. Each match case statement is terminated with `;;`. Once all the
    parameters are parsed in variables `percent`, `scale`, `source_dir`, `ext`, and
    `dest_dir`, a `for` loop is used to iterate through path of each file in the source
    directory and the corresponding action to convert file is performed.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: If the variable `ext` is defined (if `-ext` is given in the command argument),
    the extension of the destination file is changed from `source_file.extension`
    to `source_file.$ext`. In the next statement it checks whether the `-dest` parameter
    is provided. If the destination directory is specified, the destination file path
    is crafted by replacing the directory in source path with destination directory
    by using file name slicing. In the next statement, it crafts the parameter to
    the `convert` command for performing resize (`-resize widthx` or `-resize perc%`
    ). After the parameters are crafted, the `convert` command is executed with proper
    arguments.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Slicing filenames based on extension* of [Chapter 2](ch02.html "Chapter 2. Have
    a Good Command")*,* explains how to extract portion of file name'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
