- en: Chapter 9. Administration Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information about processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing processes and send or respond to signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which, whereis, file, whatis, and loadavg explained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages to user terminals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using /proc – gathering information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling with cron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and reading MySQL database from Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User administration script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk image resizing and format conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GNU/Linux ecosystem consists of running programs, services, connected devices,
    filesystems, users, and a lot more. Having an overview of the entire system and
    managing the OS as a whole, according to the way we want, is the primary purpose
    of system administration. One should be armed with the knowledge of commonly-used
    commands and proper usage practices to gather system information and manage resources
    to write script and automation tools that perform management tasks. This chapter
    will introduce several commands and methods for gathering information about your
    system and make use of these commands to write administration scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information about processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes are the running instance of a program. Several processes run on a
    computer and each process is assigned a unique identification number called a
    process ID. It is an integer. Multiple instances of the same program with the
    same name can be executed at a time. But they all will have different process
    IDs. A process consists of several attributes, such as which user owns the process,
    the amount of memory used by the program, the amount of CPU used by the program,
    and so on. This recipe will go through how to gather information about processes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Important commands related to process management are `top`, `ps`, and `pgrep`
    . Let's see how we can gather information about processes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ps` is an important tool for gathering information about the processes. `ps`
    provides information on a user who owns the process, the time when a process started,
    command path used for executing the process, process ID (PID), the terminal it
    is attached with (TTY), the memory used by the process, CPU used by the process,
    and so on. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ps` command is usually used with a set of parameters. When it is run without
    any parameter, `ps` will display processes that are running on the current (TTY)
    terminal. The first column shows the process ID (PID), the second column is the
    TTY (terminal), the third column is how much time has elapsed since the process
    started, and finally CMD (the command).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to show more columns consisting of more information, use `-f` (this
    stands for full) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above `ps` commands are not useful since it does not provide any information
    about processes other than the ones attached to the current terminal. In order
    to get information about every process running on the system, add the `-e` (every)
    option. The `-ax` (all) option will also produce an identical output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-x` argument along with `-a` specifies to remove the TTY restriction imparted,
    by default, by `ps`. Usually, using `ps` without arguments prints processes that
    are attached to terminal only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `ps -e` or `ps –ef` else `ps -ax` or `ps –axf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It will be a long list. The example filters the output using `head` so we only
    get the first 10 entries.
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command supports several information to be displayed along with the
    process name and process ID. By default, `ps` shows the information as different
    columns. Most of them are not useful for us. We can actually specify the columns
    to be displayed using the `-o` flag. Hence we can print only the required columns.
    Different parameters associated with a process are specified with options for
    that parameter. The list of parameters and usage of `-o` are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to display the required columns of output using `ps`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parameters for `-o` are delimited by using the comma (,) operator. It should
    be noted that there is no space in between the comma operator and next parameter.
    Mostly, the `-o` option is combined with the `-e` (every) option (`-oe`) since
    it should list every process running in the system. However, when certain filters
    are used along with `–o`, such as those used for listing the processes owned by
    specified users, `-e` is not used along with `–o`. Usage of `-e` with a filter
    will nullify the filter and it will show all process entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is as follows. Here, `comm` stands for COMMAND and `pcpu` is percent
    of CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The different parameters that can be used with the `-o` option and their descriptions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pcpu` | Percentage of CPU |'
  prefs: []
  type: TYPE_TB
- en: '| `pid` | Process ID |'
  prefs: []
  type: TYPE_TB
- en: '| `ppid` | Parent Process ID |'
  prefs: []
  type: TYPE_TB
- en: '| `pmem` | Percentage of Memory |'
  prefs: []
  type: TYPE_TB
- en: '| `comm` | Executable file name |'
  prefs: []
  type: TYPE_TB
- en: '| `cmd` | Simple command |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | The user who started process |'
  prefs: []
  type: TYPE_TB
- en: '| `nice` | The priority (niceness) |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Cumulative CPU time |'
  prefs: []
  type: TYPE_TB
- en: '| `etime` | Elapsed time since the process started |'
  prefs: []
  type: TYPE_TB
- en: '| `tty` | The associated TTY device |'
  prefs: []
  type: TYPE_TB
- en: '| `euid` | The effective user |'
  prefs: []
  type: TYPE_TB
- en: '| `stat` | Process state |'
  prefs: []
  type: TYPE_TB
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional usage examples of process manipulation commands.
  prefs: []
  type: TYPE_NORMAL
- en: top
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`top` is a very important command for system administrators. The `top` command
    will, by default, output a list of top CPU consuming processes. The command is
    used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will display several parameters along with the top CPU consuming processes.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting ps output with respect to a parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Output of the `ps` command can be sorted according to specified columns with
    the `--sort` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ascending or descending order can be specified by using the `+` (ascending)
    or `-` (descending) prefix to the parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to list the top 10 CPU consuming processes use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here processes are sorted in descending order by percentage of CPU usage and
    `head` is applied to extract the top 10 processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `grep` to extract entries in the `ps` output related to a given
    process name or another parameter. In order to find out entries about running
    bash processes use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finding process ID when given command names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose several instances of a command are being executed, we may need to identify
    the process ID of the processes. This information can be found by using the `ps`
    or the `pgrep` command. We can use `ps` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-o` user defined format specifier was described in the earlier part of
    the recipe. But here you can see `=` appended with `pid`. This is to remove the
    header PID in the output of `ps`. In order to remove headers for each column,
    append `=` to the parameter. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command lists the process IDs of bash processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternately, there is a handy command called `pgrep`. You should use `pgrep`
    to get a quick list of process IDs for a particular command. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pgrep` requires only a portion of the command name as its input argument to
    extract a Bash command, for example, `pgrep ash` or `pgrep bas` will also work.
    But `ps` requires you to type the exact command.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pgrep` accepts many more output-filtering options. In order to specify a delimiter
    character for output rather than using a newline as the delimiter use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify a list of owners of the user for the matching processes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `root` and `slynux` are users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the count of matching processes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Filters with ps for real user or ID, effective user or ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `ps`, it is possible to group processes based on the real and effective
    user name or ID specified. Specified arguments can be used to filter the `ps`
    output by checking whether each entry belongs to a specific, effective user or
    real user from the list of arguments and shows only the entries matching them.
    This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify an effective users list by using `-u EUSER1, EUSER2` and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a real users list by using `-U RUSER1, RUSER2` and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command will show all processes running with `root` as the effective user
    ID and real user ID, and will also show the user and percentage CPU usage columns.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mostly, we find `-o` along with `-e` as `-eo`. But when filters are applied
    `-o` should act alone as mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: TTY filter for ps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ps` output can be selected by specifying the TTY to which the process
    is attached. Use the `-t` option to specify the TTY list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Information about process threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually, information about process threads are hidden in the `ps` output. We
    can show information about threads in the `ps` output by adding the `-L` option.
    Then it will show two columns NLWP and NLP. NLWP is the thread count for a process
    and NLP is the thread ID for each entry in PS. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command lists 10 processes with maximum number of threads.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying output width and columns to be displayed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify the columns to be displayed in the `ps` output using the user-defined
    output format specifier `-o`. Another way to specify the output format is with
    "standard" options. Practice them according to your usage style. Try these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f ps –ef`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u ps -e u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps ps -e w` (w stands for wide output)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing environment variables for a process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding which environment variables a process is depended on is a very
    useful bit of information we might need. Whether or not a process works might
    be heavily dependent on the environmental variables set. We can debug and make
    use of environment data for fixing several problems related to running of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list environment variables along with `ps` entries use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: An example of where this type of environment tracing can come in handy is in
    tracing problems with the apt-get package manager. If you use an HTTP proxy to
    connect to the internet, you may need to set environment variables `http_proxy=host:port`.
    But sometimes even when it is set, the `apt-get` command will not select the proxy
    and hence it returns an error. Then you can actually look at an environment variable
    and track the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may need some applications to be run automatically with scheduling tools
    such as `crontab`. But it might be dependent on some environment variables. Suppose
    we want to open a GUI-windowed application at a given time. We schedule it using
    `crontab` at a specified time. However, you will notice that the application will
    not start at a given time if an entry like the following is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is because a windowed application always depends on the DISPLAY environment
    variable. Environment variables need to be passed to the application.
  prefs: []
  type: TYPE_NORMAL
- en: First run `windowapp` manually, and then run `ps -C windowapp -eo cmd e`.
  prefs: []
  type: TYPE_NORMAL
- en: Find out the environment variables. Prefix them before a command name appears
    in `crontab`. The issue will get resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the entry as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`DISPLAY=:0` can be obtained from the `ps` output.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Scheduling with cron*, explains how to schedule tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing processes and send or respond to signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Termination of processes is an important task we always come across. Sometimes
    we may need to terminate all the instances of a program. The command line provides
    several options for terminating programs. An important concept regarding processes
    in UNIX-like environments is that of signals. Signals are an inter-process communication
    mechanism used to interrupt running process to perform some action. Termination
    of a program is also performed by using the signals technique. This recipe is
    an introduction to signals and the usage of signals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signals are an inter-process mechanism available in Linux. We can interrupt
    a process by using a specific signal. Each signal is associated with an integer
    value. When a process receives a signal, it responds by executing a signal handler.
    In Shell scripting also, it is possible to send and receive signals and respond
    according to the signals. `KILL` is a signal used to terminate a process. Events
    such as *Ctrl* + *C*, *Ctrl* + *Z* are also types of signals. The `kill` command
    is used to send signals to processes and the `trap` command is used to handle
    the received signals.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to list all the signals available, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It will print the signal number and signal names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terminate a process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `kill` command issues a TERM signal by default. The process ID list is to
    be specified with space as a delimiter between process IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to specify a signal to be sent to a process via the `kill` command
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SIGNAL` argument is either a signal name or a signal number. Though there
    are many signals specified for different purposes, we frequently use only a few
    signals. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP 1`—hangup detection on death of controlling process or terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT 2`—signal which is emitted when *Ctrl* + *C* is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL 9`—signal used to force kill the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM -15`—signal used to terminate a process by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTSTP 20`—signal emitted when *Ctrl* + *Z* is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We frequently use force kill for processes. In order to force kill a process,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's walk through additional commands used for terminating and signalling processes.
  prefs: []
  type: TYPE_NORMAL
- en: kill family of commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `kill` command takes the process ID as argument. There are also a few other
    commands in the `kill` family that accept the command name as argument and send
    a signal to the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `killall` command terminates the process by name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to send a signal to a process by name use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to force kill process by name use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the process by name, which is specified by users who own it, by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In order to ask interactively before killing processes, use the `-i` argument
    along with `killall`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pkill` command is similar to the `kill` command but it, by default, accepts
    a process name instead of a process ID. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`SIGNAL` is the signal number. `SIGNAL` name is not supported with `pkill`.'
  prefs: []
  type: TYPE_NORMAL
- en: It provides many of the same options that the `kill` command does. Check the
    `pkill` manpages for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and responding to signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`trap` is a command used to assign signal handler to signals in a script. Once
    a function is assigned to a signal using the `trap` command, while the script
    runs and it receives a signal, this function is executed upon reception of a corresponding
    signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`SIGNAL LIST` is delimited by space. It can be a signal number or a signal
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a shell script that responds to the `SIGINT` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Run this script in a terminal. When the script is running, if you press *Ctrl*
    + *C* it will show the message by executing the signal handler associated with
    it. *Ctrl* + *C* is a `SIGINT` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is used to keep the process running without going to termination
    by using an infinite loop. Thus the process is kept running infinitely so that
    it can respond to the signals that are sent to the process asynchronously by another
    process. The loop that is used to keep the process alive infinitely is often called
    as the event loop. If an infinite loop is not available, the script will terminate
    after executing the statements. But for signal handler scripts, it has to wait
    and respond to the signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can send a signal to the script by using the `kill` command and the process
    ID of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `PROCESS_ID` of the above script will be printed when it is executed. Or
    you can find it out by using the `ps` command
  prefs: []
  type: TYPE_NORMAL
- en: If no signal handlers are specified for signals, it will call the default signal
    handlers assigned by the operating system. Generally, pressing *Ctrl* + *C* will
    terminate a program since the default handler provided by the operating system
    will terminate the process. But the custom handler defined here specifies a custom
    action upon receipt of the signal.
  prefs: []
  type: TYPE_NORMAL
- en: We can define signal handlers for any signals available (`kill -l`), by using
    the `trap` command. It is also possible to set a single signal handler for multiple
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: which, whereis, file, whatis, and loadavg explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe aims to explain a few commands we come across. Understanding these
    commands is helpful for users.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through each of the commands and their usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**which**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `which` command is used to find the location of a command. We type commands
    in the terminal without knowing the location where the executable file is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we type a command, the terminal looks for the command in a set of locations
    and executes the executable file if found at the location. This set of locations
    is specified using an environment variable `PATH`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can export `PATH` and can add our own locations to be searched when command
    names are typed. For example, to add `/home/slynux/bin` to `PATH` use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `which` command outputs the location of the command given as argument.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**whereis**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereis` is similar to the `which` command. But it not only returns the path
    of the command, it will also print the location of the manpage, if available,
    and also the path of the source code for the command if available. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**file**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `file` command is an interesting and frequently-used command. It is used
    for determining the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will print the details of the file regarding its file type.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**whatis**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `whatis` command outputs a one-line description of the command given as
    an argument. It parses information from the manpage. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**apropos**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to search if some command related to a word exists. Then
    we can search the manpages for strings in the command. For this we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apropos COMMAND`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load average**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load average is an important parameter for total load on the running system.
    It specifies the average of the total number of runnable processes on the system.
    It is specified by three values. The first value indicates the average in one
    minute, the second indicates average in five minutes, and third indicates the
    average in 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be obtained by running `uptime`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Sending messages to user terminals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A system administrator may need to send messages to the terminal screen of every
    user or a specified user on all the machines over a network. This recipe is a
    guide to perform this task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wall` is a command that is used to write messages on the terminals of all
    logged in users. It can be used to convey messages to all logged in users in a
    server or multiple access machines. Sending messages to all users may, sometimes,
    not be useful. We may need to send messages to specific users or a specific terminal.
    Terminals are treated as devices in a Linux system and hence these opened terminals
    will have a corresponding device node file at `/dev/pts/`. Writing data to a specific
    device will display messages on the corresponding terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to broadcast a message to all users and all logged in terminals, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The message outline will show who sent the message (which user and which host).
    The message gets OR is displayed to the current terminal if some other users send
    a message, only if the "write message" option is enabled. By default, in most
    distros "write message" is enabled by default. If the sender of the message is
    root, then the message gets displayed on the screen irrespective of whether the
    "write message" option is enabled or disabled by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable write messages use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to disable write messages use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a script for sending messages specifically to a given user''s
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now, slynux's terminal will receive the message text.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `/dev/pts` directory will contain character devices corresponding to each
    of the logged in terminals on the system. We can find out who logged into which
    terminal by looking at the owner of the device files. The `ls -l` output will
    contain the owner name and the device path. This information is extracted by using
    `awk`. Then it uses `grep` to extract the lines corresponding to specified user
    only. The username is accepted as the first argument for the script as stored
    as variable USER. Then a list of terminals for a given user is made. A `for` loop
    is used to iterate through each device path. `/dev/stdin` will contain standard
    input data passed to the current process. Therefore, by reading `/dev/stdin`,
    data is read and redirected to the corresponding terminal (TTY) devices. Hence
    the message gets displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering system information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting information about the current system from the command line is very
    important in logging system data. The different system information data includes
    hostname, kernel version, Linux distro name, CPU information, memory information,
    disk partition information, and so on. This recipe will show you different sources
    in a Linux system to gather information about the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to print the hostname of the current system, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Print long details about the Linux kernel version, hardware architecture, and
    more by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print the kernel release, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the machine type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print details about CPU details, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to extract the processor name, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The fifth line contains the processor name. Therefore, the first five lines
    are extracted first. Then the last one line is extracted to print processor name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print details about memory or RAM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the total memory (RAM) available on the system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to list out the partitions information available on the system, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the entire details about the system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using /proc – gathering information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/proc` is an in-memory pseudo filesystem available on GNU/Linux operating
    systems. It was introduced to provide an interface to read several system parameters
    from a user space. It is very interesting and we can gather lots of information
    from it. Let''s see few of the features available with the `proc` filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at `/proc`, you can see several files and directories. Some of them
    are already explained in another recipe in this chapter. You can simply `cat`
    files in `/proc` and the subdirectories to get information. All of them are well-formatted
    text.
  prefs: []
  type: TYPE_NORMAL
- en: There will be a directory in `/proc` for every process that is running on the
    system. The directory name for a process in `/proc` is same as that of process
    ID of that process.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose for Bash, the process ID is 4295 (`pgrep bash`), `/proc/4295` will exist.
    Each of the directories corresponding to the process will contain a lot of information
    regarding that process. Few of the important files in `/proc/PID` are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`environ`—contains environment variables associated with that process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By `cat /proc/4295/environ` we can display all the environment variables passed
    to that process.
  prefs: []
  type: TYPE_NORMAL
- en: '`cwd`—is a symlink to a working directory of the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exe`—is a symlink to the running executable for the current process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`fd`—is the directory consisting of entries on file descriptors used by the
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling with cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a common requirement to schedule the execution of scripts at a given time
    or at given time intervals. The GNU/Linux system comes with different utilities
    for scheduling tasks. `cron` is such a utility that allows tasks to automatically
    run in the background of the system at regular intervals by use of the `cron`
    daemon. The `cron` utility makes use of a file called "cron table" that stores
    a list of schedule of scripts or commands to be executed and the time at which
    they are to be executed. It is a very useful utility. A common example usage is
    to schedule downloads of files from the Internet during the free hours (certain
    ISPs provide free usage - usually during the night when most people are sleeping).
    Users are not required to wake up in the night to start the download. Users can
    write a cron entry and schedule the download. You can also schedule to drop the
    Internet connection automatically and shut down the system when the free usage
    hours end.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cron scheduling utility comes with all the GNU/Linux distributions by default.
    Once we write the cron table entry, the commands will be executed at the time
    specified for execution. The command `crontab` is used to add schedule entries
    to the cron schedule domain. A cron schedule is a simple text file. Each user
    has his or her own cron schedule. A cron schedule is often called a cron job.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to schedule tasks, we should know the format for writing the cron
    table. A cron job specifies the path of a script or command to be executed and
    the time at which it is to be executed. Each cron table consists of six sections
    in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Minute (0 - 59)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hour (0 - 23)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day (1 - 31)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Month (1 - 12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekday (0 - 6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COMMAND (the script or command to be executed at the specified time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first five sections specify the time at which an instance of the command
    is to be executed. There are a few additional options to specify the time schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 'An asterisk (`*`) is used to specify that the command should be executed at
    every instance of time. That is, if `*` is written in the hours field in the cron
    job, the command will be executed for every hour. Similarly, if you would like
    to execute the command at multiple instances of a particular time period, specify
    the time period separated by comma in the corresponding time field (for example,
    for running the command at the fifth minute and tenth minute, enter `5,10` in
    the minutes field). We also have another nice option to run the command at particular
    divisions of time. Use `*/5` in the minutes field for running the command at every
    five minutes. We can apply this to any time field. A cron table entry can consist
    of one or more lines of cron jobs. Each line in the cron table entry is a single
    job. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a sample `crontab` entry for illustration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This cron job will execute the `test.sh` script at the second minute of all
    hours on all days.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to run the script at fifth, sixth, and seventh hours on all days,
    use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `script.sh` at every hour on Sundays as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the computer at 2am everyday as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us see how to schedule a cron job. You can execute the `crontab` command
    in multiple ways to schedule the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `crontab` manually, use the `–e` option to enter the cron
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When `crontab –e` is entered, the default text editor (usually vi) is opened
    up and the user can type the cron job and save it. This cron job will be scheduled
    and executed at specified time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other methods we usually use when we invoke the `crontab` command
    inside a script for scheduling tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a text file (for example, `task.cron`) and write the cron job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then run the `crontab` with the filename as the command argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the next method we can specify the cron job inline without creating
    a separate file. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The cron job needs to be written in between `crontab<<EOF and EOF`.
  prefs: []
  type: TYPE_NORMAL
- en: Cron jobs are executed with privileges with which the `crontab` command is executed.
    If you need to execute commands that require higher privileges, such as a command
    for shutting down the computer, run the `crontab` command as root.
  prefs: []
  type: TYPE_NORMAL
- en: The commands specified in the cronjob are written with the full path to the
    command. This is because the environment in which a cron job is executed is different
    from the one that we execute on a terminal. Hence the `PATH` environment variable
    may not be set. If your command requires certain environment variables to be set
    for running, you should explicitly set the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `crontab` command has more options. Let's see a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the commands require environment variables to be set properly for execution.
    We can set environment variables by inserting a line with variable assignment
    statement in the cron table of the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are using a proxy server for connecting to the Internet,
    to schedule a command that uses Internet you have to set the HTTP proxy environment
    variable `http_proxy`. It can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Viewing the cron table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can list the existing cronjobs using the `–l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `crontab –l` lists the existing entries in the cron table for the current
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also view the cron table for other users by specifying username with
    the `–u` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You should run as root when you use the `–u` option to gain higher privilege.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the cron table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can remove the crontable for the current user using the `–r` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to remove crontab for another user, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Run as root to get higher privilege.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and reading MySQL database from Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MySQL is a widely used Database System. Usually, MySQL databases are used as
    the storage systems for applications that are written in languages such as PHP,
    Python, C++, and so on. Accessing and manipulating MySQL databases from shell
    script will be interesting. We can write scripts to write contents from a text
    file or CSV (Comma Separated Values) into tables and interact with the MySQL database
    to read and manipulate data. For example, we can read all the e-mail addresses
    stored in a guestbook program''s database by running a query from the shell script.
    In this recipe, we will see how to read and write to a MySQL database from Bash.
    For illustration, here is an example problem:'
  prefs: []
  type: TYPE_NORMAL
- en: I have a CSV file containing details of students. I need to insert the contents
    of the file to a database table. From this data, I need to generate a separate
    rank list for each department.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to handle MySQL databases, you should have mysql-server and mysql-client
    packages installed on your system. These tools do not come with a Linux distribution
    by default. Since MySQL comes with a username and password for authentication,
    you should have a username and password to run the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above problem can be solved using Bash utilities such as `sort`, `awk`,
    and so on. Alternately, we can solve it by using an SQL database table. We will
    write three scripts for the purpose of creating a database and table, inserting
    student data into the table, and reading and displaying processed data from the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the database and table script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The script for inserting data into the table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The script for the query from the database is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The data for the input CSV file (`studentdata.csv`) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the scripts in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now see the explanation of the above scripts one by one. The first script
    `create_db.sh` is used to create database called `students` and a table named
    `students` inside it. We need the MySQL username and password to access or modify
    data in the DBMS. The variables `USER` and `PASS` are used to store the username
    and password. The `mysql` command is used for MySQL manipulations. The `mysql`
    command can specify the username by using `–u` and the password by using `–pPASSWORD`.
    The other command argument for the `mysql` command is the database name. If a
    database name is specified as an argument to the `mysql` command, it will use
    that for database operations, else we have to explicitly specify in the SQL query
    about which database is to be used with the `use database_name` query. The `mysql`
    command accepts the queries to be executed through standard input (`stdin`). The
    convenient way of supplying multiple lines through `stdin` is by using the `<<EOF`
    method. The text that appears in between `<<EOF` and `EOF` is passed to `mysql`
    as standard input. In the `CREATE DATABASE` query, we have redirected `stderr`
    to `/dev/null` in order to prevent displaying an error message. Also, in the table
    creation query, we have redirected `stderr` to `/dev/null` to ignore any errors
    that occur. Then we check the exit status for the `mysql` command by using the
    exit status variable `$?` to know if a table or database already exists. If the
    database or table already exists, a message is displayed to notify that. Else
    we will create them.
  prefs: []
  type: TYPE_NORMAL
- en: The next script `write_to_db.sh` accepts a filename of the student data CSV
    file. We read each line of the CSV file by using the `while` loop. So in each
    iteration a line with comma separated values will be received. We then need to
    formulate the values in the line to an SQL query. For that, the easiest way to
    store data items in the comma separated line is by using an array. We know that
    an array assignment is in the form `array=(val1 val2 val3)`. Here the space character
    is the **Internal** **Field** **Separator** (**IFS**). We have a line with comma
    separated values, hence by changing the IFS to a comma, we can easily assign values
    to the array (`IFS=,`). The data items in the comma separated line are `id`, `name`,
    `mark`, and `department`. `id` and `mark` are integer values whereas `name` and
    `dept` are strings (strings must be quoted). Also the name can contain space characters.
    Space can conflict with the Internal Field Separator. Hence we should replace
    the space in the name with some character (`#`) and replace it later after formulating
    the query. In order to quote the strings, the values in the array are prefixed
    and suffixed with `\"`. The `tr` is used to substitute space in the name to `#`.
    Finally, the query is formed by replacing the space character with comma and replacing
    `#` with space and this query is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The third script `read_db.sh` is used to find out the department and print the
    rank list of students for each department. The first query is used to find distinct
    names of departments. We use a `while` loop to iterate through each department
    and run the query to display student details in the order of highest marks. `SET
    @i=0` is an SQL construct used to set the variable `i=0`. On each row it is incremented
    and is displayed as the rank of the student.
  prefs: []
  type: TYPE_NORMAL
- en: User administration script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU/Linux is a multi user operating system. Many users can log in and perform
    several activities at a time. There are several administration tasks that are
    handled with user management. The tasks includes setting the default shell for
    the user, disabling a user account, disabling a shell account, adding new users,
    removing users, setting a password, setting an expiry date for a user account,
    and so on. This recipe aims at writing a user management tool that can handle
    all of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go through the user administration script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `user_adm.sh` script can be used to perform many user management tasks.
    You can follow the `usage()` text for the proper usage of the script. A function
    `usage()` is defined to display how to execute the script with different options
    for the user when any of the parameters given by user gets wrong or has run the
    `–usage` parameter. A case statement is used to match the command arguments and
    execute the corresponding commands according to that. The valid command options
    for the `user_adm.sh` script are: `-adduser`, `-deluser`, `-shell`, `-disable`,
    `-enable`, `-expiry`, `-passwd`, `-newgroup`, `-delgroup`, `-addgroup`, `-details`,
    and `-usage`. When the `*)` case is matched, it means its a wrong option and hence
    `usage()` is invoked. For each match case, we have used `[ $# -ne 3 ] && usage`.
    It is used for checking number of arguments. If the number of command arguments
    are not equal to required number, the `usage()` function is invoked and the script
    will exit without executing further. In order to run the user management commands,
    the script needs to be run as root. Hence a check for user ID 0 (the root has
    user ID 0) is performed. If the user has a non-zero user ID, this means it is
    executing as non-root. Hence a message to run as root is displayed and the script
    exits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain each case one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-useradd`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `useradd` command can be used to create a new user. It has the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` option is used to create the home directory
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to provide the full name of the user by using the `–c FULLNAME`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '`-deluser`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `deluser` command can be used to remove the user. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '`--remove-all-files` is used to remove all files associated with the user including
    the home directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-shell`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chsh` command is used to change the default shell for the user. The syntax
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '`-disable` and `–enable`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `usermod` command is used to manipulate several attributes related to user
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: '`usermod –L USER` locks the user account and `usermod –U USER` unlocks the
    user account.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-expiry`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `chage` command is used manipulate user account expiry information. The
    syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chage –E DATE`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m MIN_DAYS` (set the minimum number of days between password changes to `MIN_DAYS`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-M MAX_DAYS` (set the maximum number of days during which a password is valid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-W WARN_DAYS` (set the number of days of warning before a password change
    is required)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-passwd`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `passwd` command is used to change passwords for the users. The syntax
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`passwd USER`'
  prefs: []
  type: TYPE_NORMAL
- en: The command will prompt to enter new password.
  prefs: []
  type: TYPE_NORMAL
- en: '`-newgroup` and `addgroup`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `addgroup` command will add a new usergroup to the system. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addgroup GROUP`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add an existing user to a group use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addgroup USER GROUP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-delgroup`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delgroup` command will remove a user group. The syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delgroup GROUP`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-details`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finger USER` command will display the user information for the user, which
    includes details such as user home directory path, last login time, default shell,
    and so on. The `chage –l` command will display the user account expiry information.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk image resizing and format conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of us use digital cameras and download photos from the cameras as well as
    the Internet. When we need to deal with large number of image files, we can use
    scripts to easily perform actions on the files in bulk. A regular task we come
    across with photos is resizing the file. Also, format conversion from one image
    format to another comes to use (for example, JPEG to PNG conversion). When we
    download pictures from a camera, the large resolution pictures take a large size.
    But we may need pictures of lower sizes that are convenient to store and e-mail
    over the internet. Hence we resize it to lower resolutions. This recipe will discuss
    how to use scripts for image management.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Imagemagick** is an excellent tool for manipulating images that can work
    across several image formats and different constructs with rich options. Most
    of the GNU/Linux distributions don''t come with Imagemagick installed. You need
    to manually install the package. `convert` is the command that we will use frequently.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it..
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to convert from one image format to another image format use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We can resize an image size to a specified image size either by specifying the
    scale percentage or by specifying width and height of the output image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resize the image by specifying the `WIDTH` or `HEIGHT` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'It is required to provide either `WIDTH` or `HEIGHT` so that the other will
    be automatically calculated and resized so as to preserve the image size ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Resize the image by specifying the percentage scale factor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a script for image management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample output, to scale the images in the directory `sample_dir`
    to `20%` size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to scale the images to width 1024 use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Change the files to PNG format by adding `–ext png` along with the above commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scale or convert files with specified destination directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above `image_help.sh` script can accept several command-line arguments,
    such as -`source`, `-percent`, `-scale`, `–ext`, and `-dest`. A brief explanation
    of each is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-source` parameter is used to specify the source directory for the images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–percent` parameter is used to specify the scale percent and `–scale` is
    used to specify scale width and height.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either `–percent` or `–scale` is used. Both of them do not appear simultaneously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–ext` parameter is used to specify the target file format. `–ext` is optional;
    if it is not specified, format conversion is not performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `–dest` parameter is used to specify the destination directory for scale
    or conversion of image files. `–dest` is optional. If `–dest` is not specified,
    the destination directory will be same as the source directory. As the first step
    in the script, it checks whether the number of command arguments given to the
    script are correct. Either 4 or 6 or 8 parameters can appear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, by using a `while` loop and case statement, we will parse the command-line
    arguments corresponding to variables. `$#` is a special variable that returns
    the number of arguments. The `shift` command shifts the command arguments one
    position to left, so that on each execution of shift, we can access command arguments
    one by one, by using the same `$1` variable rather than using `$1`, `$2`, `$3,`
    and so on. The case statement matches the value of `$1`. It is like a switch statement
    in the C programming language. When a case is matched, the corresponding statements
    are executed. Each match case statement is terminated with `;;`. Once all the
    parameters are parsed in variables `percent`, `scale`, `source_dir`, `ext`, and
    `dest_dir`, a `for` loop is used to iterate through path of each file in the source
    directory and the corresponding action to convert file is performed.
  prefs: []
  type: TYPE_NORMAL
- en: If the variable `ext` is defined (if `-ext` is given in the command argument),
    the extension of the destination file is changed from `source_file.extension`
    to `source_file.$ext`. In the next statement it checks whether the `-dest` parameter
    is provided. If the destination directory is specified, the destination file path
    is crafted by replacing the directory in source path with destination directory
    by using file name slicing. In the next statement, it crafts the parameter to
    the `convert` command for performing resize (`-resize widthx` or `-resize perc%`
    ). After the parameters are crafted, the `convert` command is executed with proper
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Slicing filenames based on extension* of [Chapter 2](ch02.html "Chapter 2. Have
    a Good Command")*,* explains how to extract portion of file name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
