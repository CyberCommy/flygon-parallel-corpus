- en: GPIO Controller Drivers â€“ gpio_chip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we dealt with GPIO lines. Those lines are exposed
    to the system by means of a special device called the GPIO controller. This chapter
    will explain step by step how to write drivers for such devices, thus covering
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GPIO controller driver architecture and data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysfs interface for GPIO controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPIO controllers representation in DT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver architecture and data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drivers for such devices should provide:'
  prefs: []
  type: TYPE_NORMAL
- en: Methods to establish GPIO direction (input and output).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods used to access GPIO values (get and set).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods to map a given GPIO to IRQ and return the associated number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag saying whether calls to its methods may sleep, this is very important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional `debugfs dump` method (showing extra state like pullup config).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional numbers called base number, from which GPIO numbering should start.
    It will be automatically assigned if omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the kernel, a GPIO controller is represented as an instance of `struct gpio_chip`
    , defined in `linux/gpio/driver.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the meaning of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`request` is an optional hook for chip-specific activation. If provided, it
    is executed prior to allocating GPIO whenever one calls `gpio_request()` or `gpiod_get()`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free` is an optional hook for chip-specific deactivation. If provided, it
    is executed before the GPIO is deallocated whenever one calls `gpiod_put()` or
    `gpio_free()` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_direction` is executed whenever one needs to know the direction of the
    GPIO `offset` . Return value should be 0 to mean out, and 1 to mean in, (same
    as `GPIOF_DIR_XXX` ), or negative error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction_input` configures the signal `offset` as input, or returns error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get` returns value of GPIO `offset` ; for output signals, this returns either
    the value actually sensed, or zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` assigns output value to GPIO `offset` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_multiple` is called when one needs to assign output values for multiple
    signals defined by `mask` . If not provided, the kernel will install a generic
    hook that will walk through `mask` bits and execute `chip->set(i)` on each bit
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please see the following which shows how one can implement this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`set_debounce` if supported by the controller, this hook is an optional callback
    provided to set the debounce time for specified GPIO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_irq` is an optional hook to provide GPIO to IRQ mapping. This is called
    whenever one wants to execute the `gpio_to_irq()` or `gpiod_to_irq()` function.
    This implementation may not sleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base` identifies the first GPIO number handled by this chip; or, if negative
    during registration, the kernel will automatically (dynamically) assign one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngpio` is the number of GPIOs this controller provides, starts from `base`
    , to `(base + ngpio - 1)` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`names` , if set, must be an array of strings to use as alternative names for
    the GPIOs in this chip. The array must be `ngpio` sized, and any GPIO that does
    not need an alias may have its entry set to `NULL` in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_sleep` is a Boolean flag to be set if `get()` /`set()` method may sleep.
    It is the case for GPIO controller (also known as expander) sitting on a bus,
    such as I2C or SPI, whose accesses may lead to sleep. This implies that if the
    chip supports IRQs, these IRQs need to be threaded as the chip access may sleep
    when, for example, reading out the IRQ status registers. For GPIO controller mapped
    to memory (part of SoC), this can be set to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_not_threaded` is a Boolean flag and must be set if `can_sleep` is set,
    but the IRQs don''t need to be threaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each chip exposes a number of signals, identified in method calls by offset
    values in the range 0 (`ngpio - 1` ). When those signals are referenced through
    calls like `gpio_get_value(gpio)` , the offset is calculated by subtracting base
    from the GPIO number.
  prefs: []
  type: TYPE_NORMAL
- en: After every callback has been defined and other fields set, one should call
    `gpiochip_add()` on the configured `struct gpio_chip` structure in order to register
    the controller with the kernel. When it comes to unregister, use `gpiochip_remove()`
    . That is all. You can see how easy it is to write your own GPIO controller driver.
    In the book sources repository, you will find a working GPIO controller driver,
    for MCP23016 I2C I/O expander from microchip, whose data sheet is available at
    [http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To write such drivers, you should include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an excerpt from the driver we have written for our controller,
    just to show you how easy the task, of writing a GPIO controller driver is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To request a self-owned GPIO from within the controller driver, one should
    not use `gpio_request()` . A GPIO driver can use the following functions instead
    to request and free descriptors without being pinned to the kernel forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Descriptors requested with `gpiochip_request_own_desc()` must be released with
    `gpiochip_free_own_desc()` .
  prefs: []
  type: TYPE_NORMAL
- en: Pin controller guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending on the controller you write the driver for, you may need to implement
    some pin control operation to handle pin multiplexing, configuration, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: For a pin controller that can only do simple GPIO, a simple `struct gpio_chip`
    will be sufficient to handle it. There is no need to set up a `struct pinctrl_desc`
    structure, just write the GPIO controller driver as it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the controller can generate interrupts on top of the GPIO functionality,
    a `struct irq_chip` must be set up and registered to the IRQ subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a controller having pin multiplexing, advanced pin driver strength, complex
    biasing, you should set up the following three interfaces :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct gpio_chip` , discussed earlier in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_chip` , discussed in the next chapter ([Chapter 16](http://advanced)
    , *Advanced IRQ Management* )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct pinctrl_desc` , not discussed in the book, but well explained in the
    kernel documentation in *Documentation/pinctrl.txt*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysfs interface for GPIO controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On successful `gpiochip_add()` , a directory entry with a path like `/sys/class/gpio/gpiochipX/`
    will be created, where `X` is the GPIO controller base (controller providing GPIOs
    starting at `#X` ), having the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base` , whose value is same as `X` , and which corresponds to `gpio_chip.base`
    (if assigned statically), and being the first GPIO managed by this chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label` , which is provided for diagnostics (not always unique).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngpio` , which tells how many GPIOs this controller provides (`N to N + ngpio
    - 1` ). This is the same as defined in `gpio_chip.ngpios` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding attributes are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO controllers and DT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every GPIO controller declared in the DT must have the Boolean property `gpio-controller`
    set. Some controllers provide IRQ mapped to the GPIO. In that case, the property
    `interrupt-cells` should be set too and usually one uses `2` , but it depends
    on the need. The first cell is the pin number, and the second represents the interrupt
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: '`gpio-cells` should be set to identify how many cells are used to describe
    a GPIO specifier. One usually uses `<2>` , the first cell to identify the GPIO
    number, and the second for flags. Actually, most of the nonmemory mapped GPIO
    controllers do not use the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample is the node of our GPIO-controller device, and the complete
    device driver is provided with the sources of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is much more than a basis to write the driver for a GPIO controller
    that you may encounter. It explains the main structure to describe such devices.
    The next chapter deals with advanced IRQ management, in which we will see how
    to manage an interrupt controller and thus add such functionality in the driver
    of the MCP23016 expander from microchip.
  prefs: []
  type: TYPE_NORMAL
