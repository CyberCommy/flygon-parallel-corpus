- en: Interacting with the Adafruit FeatherWing OLED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the Adafruit FeatherWing **organic light-emitting
    diode** (**OLED**) display. The Adafruit Feather is a standard board arrangement,
    which allows upgrades to those boards to be plugged into each other. These can
    run either stacked on top of each other or as standalone boards. FeatherWings
    are accessories that can be plugged into these Feather boards.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will plug the Adafruit FeatherWing OLED display into the
    Adafruit Feather HUZZAH ESP8266 MicroPython board. This will create the powerful
    combination of a microcontroller with internet connectivity, which has a display
    that can output text graphics and interact with the user using three hardware
    push buttons that are a part of the display.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will help you build a whole array of projects. You
    can make little MicroPython boards that display a menu, which you can navigate
    through, and each selected action could post sensor data to other servers on your
    network or to the internet. You could also use it to fetch data from servers on
    command and display it on the screen. This chapter will focus on all the main
    features of the display, such as displaying texts, lines, and rectangle graphics,
    as well as interacting with the built-in buttons that come with the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting button presses with GPIO pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the SSD1306 display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling and clearing the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting pixels on the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and rectangles on the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text on the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverting colors on the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit FeatherWing OLED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FeatherWing OLED display uses an OLED that has a number of benefits compared
    to other display technologies. For example, it has a much lower power consumption
    than other display technologies. This makes it very useful for embedded projects,
    where the power requirements need to be kept as low as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'OLEDs also have a much higher contrast ratio than other display technologies,
    making the text and graphics being displayed much clearer. The screen comes with
    three user buttons and has a number of different options in terms of headers and
    screen resolution. The following photograph shows one of these displays attached
    to an Adafruit Feather HUZZAH ESP8266 board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/71a2df18-6864-4813-a115-e48db0e6c628.png)'
  prefs: []
  type: TYPE_IMG
- en: The board comes in a configuration with loose headers that require soldering
    and another version with assembled headers that require no soldering. The board
    that is shown in the preceding photograph uses assembled headers and plugs right
    into the ESP8266 mainboard with no need for soldering.
  prefs: []
  type: TYPE_NORMAL
- en: Where to buy it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the Assembled Adafruit FeatherWing OLED – 128 x 32 OLED Add-on
    for Feather. This FeatherWing can be purchased directly from Adafruit ([https://www.adafruit.com/product/3045](https://www.adafruit.com/product/3045)).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files of this chapter can be found in the `Chapter13` folder of the
    following GitHub repository: [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit Feather HUZZAH ESP8266 board and the Assembled
    Adafruit FeatherWing OLED – 128 x 32 OLED Add-on for Feather board. CircuitPython
    3.1.2 was used for all the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires some specific modules from the CircuitPython library,
    and they will be mentioned at the beginning of each recipe. For details on downloading
    and extracting these libraries, you can refer to the *Updating the CircuitPython
    library* recipe from [Chapter 1](1c277918-6daf-4a83-8a06-6012ceda9ac1.xhtml),
    *Getting Started with MicroPython*. Version 20190212 of the CircuitPython library
    is used for all the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting button presses with GPIO pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to check the state of the three push buttons
    that come with the Adafruit FeatherWing OLED. We will poll each of these three
    buttons and continually print out their state so that we can detect the moment
    a button is pressed and when it is realized.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these push buttons is attached to a different GPIO pin, so we will use
    a dictionary to map the button names to their associated GPIO pins. The physical
    buttons on the board are labeled *A*, *B*, and *C*. We will use the same naming
    to map the button events to print statements in the script.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is useful because it will enable your project to take different
    actions, depending on which buttons are being pressed. Because there are three
    buttons on this board, you have a lot of options in terms of how you can design
    your application. For example, you could make two of the buttons up and down menu
    options, while the third button could allow users to choose a menu option. Alternatively,
    you could have one button that increases a setting value and another button that
    decreases a setting value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now imported the necessary Python libraries and have set up a `PINS`
    dictionary, which will map the button names to their associated GPIO pins as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_buttons` function will return a dictionary that maps each button to
    its associated `Pin` object. On this board, buttons A and C require `PULL_UP`
    to be configured while button B does not. Run the following block of code and
    it will return a value of `1`, which indicates that button A is not pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold down button A while running the next block of code, and the `Pin` value
    will show that the button is being pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next block of code creates the `names` list, which has a sorted list of
    the button names. We define a function called `get_status`, which will return
    the status of each of the three buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, the following block of code calls the `get_status` function and returns
    the current state of the push buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold down button B while running the next block of code and the status of push
    button B will show that it is being pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be added to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will continually print out the status of each
    of the buttons with a delay of `0.1` seconds between each loop.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe defines a data structure called `PINS`, which will map each of the
    three buttons to their correct GPIO pin on the ESP8266\. The `get_buttons` function
    creates `Pin` objects for each of these buttons with their correct `PULL_UP` settings.
    This `get_buttons` function is called in the `main` function and the returned
    dictionary is saved in the `buttons` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `names` variable is simply the sorted list of button names. It is created
    to ensure that the status update is always presented in alphabetical order. The
    `get_status` function loops through each button and calls the `format` function
    to generate the status line, which gets printed out each time the status is checked.
    The main loop enters into an infinite loop, printing the button status in each
    iteration, and then pausing for `0.1` seconds before continuing to the next loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using GPIO pins to interact with push buttons, they need to be properly
    configured. The correct pins need to be used and the `PULL_UP` settings need to
    be applied correctly to each pin configuration. These settings can usually be
    found with the board's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this board, the reason why push button B doesn't require a `PULL_UP`
    setting is that the button and hardware level have a 100k pull-up value included,
    and so that addresses the issue that the ESP8266 doesn't have an internal pull-up
    on pin 16\. However, the other two buttons do require `PULL_UP` to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation on the FeatherWing OLED pinouts can be found at [https://learn.adafruit.com/adafruit-oled-featherwing/pinouts](https://learn.adafruit.com/adafruit-oled-featherwing/pinouts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further documentation on the `Pin` object in the `machine` module can be found
    at [https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin](https://docs.micropython.org/en/latest/library/machine.Pin.html#machine.Pin).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the SSD1306 display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to use the `adafruit_ssd1306` library to connect
    to the FeatherWing OLED display. The recipe will show you how to initialize the
    **Inter-Integrated Circuit** (**I2C**) bus that the OLED display is connected
    to. Then, we can create an `SSD1306_I2C` object that connects to the display using
    the I2C bus.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you in a number of ways; there are a whole array of components
    that connect using I2C, so this recipe will give you exposure to this technology
    so that you are familiar with it whenever you need to use it in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: You will gain an understanding of how to use a display library that can work
    with MicroPython, which can then be included in any projects that you might want
    to add a display to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe. Version 20190212 of the CircuitPython library is used for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the CircuitPython library bundle. You will need both the `.mpy` and
    `.py` versions of the bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract both of the `.zip` files to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is not necessary to install all the libraries in the bundle on the ESP8266.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three specific libraries are required to connect to the display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `adafruit_bus_device` and `adafruit_framebuf` libraries should have their
    `.mpy` files installed on the ESP8266\. The files for these libraries should be
    transferred to the ESP8266 and into the `.lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following code in the REPL to verify that these two libraries were
    installed correctly on the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `adafruit_ssd1306` library should have the `.py` version of the `adafruit_ssd1306.py` file
    in the library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The library will try to use the built-in `framebuf` MicroPython library instead
    of `adafruit_framebuf`. The library will fail to connect to the display if it
    uses the `framebuf` library for its frame buffer manipulation. To fix this issue,
    download and run the `fix_framebuf_import.py` file in the same directory as `adafruit_ssd1306.py`.
    You can find this script in the `Chapter13` folder of the book's GitHub repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the fixed version of the `adafruit_ssd1306.py` file to the board's root
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following block of code to verify that the `adafruit_ssd1306` library
    was installed correctly on the board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, all additional libraries have been installed and imported successfully.
    Run the following block of code to import the libraries that are required to initialize
    the I2C bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to initialize the I2C bus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to create an `SSD1306_I2C` display object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will initialize the I2C bus and create an
    `SSD1306_I2C` object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The libraries that are required to interact with the FeatherWing OLED are not
    a part of the CircuitPython firmware, so they require further installation before
    they can be used. Three libraries need to be installed, and they are called `adafruit_ssd1306`,
    `adafruit_bus_device`, and `adafruit_framebuf`.
  prefs: []
  type: TYPE_NORMAL
- en: The `adafruit_ssd1306` library is the main library that we will interact with
    and it relies on the other libraries we have installed to work correctly. Once
    these libraries are installed, we can then start importing them and using their
    code to connect to the display. The first step is to initialize the I2C bus. This
    is done by creating an I2C object and passing it references to the SCL and SDA
    pins. The object is then saved in the `i2c` variable. An `SSD1306_I2C` object
    is created by passing it the values of `128` and `32`, which refer to the display
    resolution since we are using the 128 x 32 OLED. The other parameter that is passed
    is the `i2c` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I2C is a very popular protocol for a whole range of devices. I2C is relatively
    simple to connect to and use, which is one of the reasons why it is widely used
    with many microcontrollers. It only requires two wires to connect to it and can
    use the general-purpose I/O pins that come with many microcontroller boards.
  prefs: []
  type: TYPE_NORMAL
- en: A single connection can control multiple devices, which adds to its flexibility.
    One of the downsides of this protocol, however, is its low speeds compared to
    other protocols. This means that we can use it for a small monochrome display,
    but if we wanted to control a display with a higher resolution and more colors,
    then it wouldn't be fast enough.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More details on the I2C protocol can be found at [https://i2c.info/](https://i2c.info/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further documentation on installing the CircuitPython SSD1306 library can be
    found at [https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-setup).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling and clearing the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to use the `adafruit_ssd1306` library to connect
    to the FeatherWing OLED display. It will demonstrate how to initialize the I2C
    bus that the OLED display is connected to. Then, we can create an `SSD1306_I2C`
    object that connects to the display using the I2C bus. This recipe will help you
    in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: There are a whole array of components that can connect using I2C; this recipe
    will give you exposure to this technology so that you are familiar with it whenever
    you need to use it in your own projects. The recipe will also help you with the
    first steps for using a display library that can work with MicroPython, which
    can then be included in any projects that you might want to add a display to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The required libraries have now all been imported. Run the next block of code
    to create the `i2c` object and the `SSD1306_I2C` object called `oled`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following block of code, set all the pixels on the screen to the
    color white and apply the changes to the display by calling the `show` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will turn off all the pixels on the screen with the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block will loop 10 times and repeatedly turn all the pixels
    on the screen on and off, creating a blinking-screen effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will make the screen flash black and white
    10 times.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function first sets up the `i2c` object and saves the `SSD1306_I2C` object
    as a variable called `oled`. The `oled` object has two methods that we will use
    in this recipe. The `fill` method receives one argument and fills all the pixels
    on the display to either white or black. If `1` is provided, then the pixels will
    become white, otherwise, they will become black (or turned off).
  prefs: []
  type: TYPE_NORMAL
- en: The `show` method must be called after each change for the changes to take effect
    on the display. A `for` loop is started that will loop 10 times and turn the display
    all white and then all black during each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two `fill` and `show` methods are great starting points for when you are
    interacting with the display, as they are relatively easy to use. Even though
    they seem simple, they are needed for a lot of operations.
  prefs: []
  type: TYPE_NORMAL
- en: In later recipes, we will explore how to draw lines, rectangles, and text. In
    all of these cases, we will need to call `show` for the changes to be rendered
    to the screen. We will also frequently call `fill` to clear the contents of the
    screen before we write or draw something new on the display.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using `fill` and `show` can be found at [https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/examples.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further documentation on the `SSD1306_I2C` object can be found at [https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html](https://circuitpython.readthedocs.io/projects/ssd1306/en/latest/api.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting pixels on the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to turn individual pixels on the screen on
    and off. The recipe starts by setting pixels with specific *x* and *y* coordinates
    to indicate on or off. Then, we'll create a simple animation that repeatedly draws
    pixels in a certain direction, and so creating a line that grows in length. We
    will place this simple line animation into its own function so that we can call
    it multiple times and create a type of zigzag line animation.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this recipe useful for when you start controlling the display
    from your projects and want control over individual pixels. The operation of controlling
    individual pixels becomes the building block to produce ever more complex drawings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `BLACK` and `WHITE` constants, which represent the values for the
    two possible pixel colors. Then, set up the `i2c` and `oled` objects. The following
    block of code will clear the contents of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will draw the pixel at (*x*, *y*), that is, position
    (`0`, `0`) for the color white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will turn the pixel off at position (`0`, `0`)
    by setting its color to black:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will set the color of the pixel at position (`10`, `30`)
    to white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block will clear the screen, and then loop 10 times, setting
    a diagonal line of pixels on, one after the other, as an animation that will appear
    like a growing line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following code block, define a function that will perform a line
    animation from a starting position of (`x`, `y`) and will then move steps in the
    *x* and *y* direction for a certain `count` of iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block will clear the screen and call `animate_pixel` to
    draw a line from position (`0`, `0`) to (`30`, `30`), composed of 30 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block of code will then draw a line from position (`30`, `30`)
    to (`60`, `0`). The line will continue where the last animation completed but
    move in a different direction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now define a function called `zig_zag`, which will draw four line animations.
    Each one will continue from the point the last one finished at, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following block of code to clear the display and run the `zig_zag`
    line animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will draw four line animations in a zigzag
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the `main` function has set up the `oled` object, it calls the `zig_zag`
    function. The `zig_zag` function makes four calls to the `animate_pixel` function.
    Each call moves the line in a different diagonal direction.
  prefs: []
  type: TYPE_NORMAL
- en: Each new line animation starts off where the last one finished so that it appears
    as one long animation from start to finish. The `animate_pixel` function takes
    a starting *x* and *y* position and loops for the number of iterations specified
    by the `count` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In each loop iteration, the values of *x* and *y* are changed by the specified
    *x* and *y* step values. Once the new values are calculated, a pixel is drawn
    at that position and the `show` method is called to show it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe started off with a few simple examples of setting pixels on and
    off and the different positions on the display. Then, it expanded to do a simple
    animation and an even more involved zigzag animation. The following photograph
    shows what this animation looks like on the display once it is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dcdf610e-0164-4693-ac71-673c54ae39f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Many more different types of shapes and animations can be created by using the
    `math` module that comes with MicroPython. The `sine` and `cosine` functions can
    be used to draw wave animations. We can also use these trigonometric functions
    to draw circles and ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation on drawing pixels on the FeatherWing OLED can be found at
    [https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage](https://learn.adafruit.com/adafruit-oled-featherwing/circuitpython-and-python-usage).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More documentation on the `sin` function in the `math` module can be found at [https://docs.micropython.org/en/latest/library/math.html#math.sin](https://docs.micropython.org/en/latest/library/math.html#math.sin).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing lines and rectangles on the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to use the methods that come with the `SSD1306_I2C`
    object, which will let us draw horizontal lines, vertical lines, squares, and
    rectangles. We can now move beyond setting individual pixels and explore drawing
    a wider range of shapes using the methods that come out of the box with the `adafruit_ssd1306`
    display library.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this recipe useful for when you want to draw some different shapes;
    for example, to build a simple user interface on the display. There is enough
    resolution on the display to draw a number of boxes and borders that represent
    different parts of your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The necessary modules are imported, `oled` is created, and then the display
    is cleared. Using the following block of code, draw a vertical line starting at
    coordinates (`0`, `0`) with a height of 20 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar fashion, draw a horizontal line starting at coordinates (`0`,
    `0`) with a width of 80 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A rectangle at position (`0`, `0`) having a width of 10 pixels and height of
    20 pixels can be drawn using the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function will draw the `HI` text. The `H` character will be drawn
    using vertical lines and one horizontal line. The `I` character will then be drawn
    using a single vertical line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block will clear the screen and call the `draw_hi` function
    to render the message, `HI`, on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following code block, define a function that will perform an animation
    involving boxes, which are of a certain size and are shifted in position by step
    *x* and *y* in each iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the following code block to call `animate_boxes` and draw six boxes
    in a diagonal formation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Define and call the `draw_x_boxes` function, which draws a set of boxes in
    two diagonal lines to create a large letter `X` made of small boxes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will draw a letter `X` made up of small boxes
    and draw the `HI` text, which is made of vertical and horizontal lines.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `draw_hi` function uses the `vline` and `hline` methods on the `oled` object
    to draw the three lines that will make up `H`. After the letter `H` is drawn,
    a vertical line is drawn using `vline` to represent the letter `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the `draw_x_boxes` function will, in turn, call the `animate_boxes`
    function. The first call to the `animate_boxes` function draws six boxes in a
    diagonal direction to make the first part of the `X` character. The second call
    to `animate_boxes` also makes six boxes, but from a different starting position
    and going in a different direction. The second call will cut through the first
    line to form the `X` character.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The line drawing and rectangle drawing methods can be combined in many different
    ways to create all sorts of shapes and drawings. The following photograph shows
    what the display will look like once you run the `main.py` script in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b17657f1-6db0-40b9-a81b-501a016c42e2.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next recipe, we will learn how to draw text on the display. It is very
    useful to combine box and line drawings and then render text on different parts
    of the display.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Further documentation on the main features of the FeatherWing OLED can be found
    at [https://learn.adafruit.com/adafruit-oled-featherwing/overview](https://learn.adafruit.com/adafruit-oled-featherwing/overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More documentation on the `busio` module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/__init__.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing text on the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to write text output to the FeatherWing OLED.
    The recipe will show you how to control the position and content of the text to
    be displayed. A text animation will be created to perform a countdown on the display,
    and then a function will be created to show all lowercase, uppercase, and digit
    characters on the screen at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you whenever you have some information that you want to
    communicate with people using your devices. Because the display can show three
    rows of text, it gives a lot of room for presenting all sorts of information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the followings steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the CircuitPython library bundle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the bundle of `.zip` files to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `font5x8.bin` font file, which is located in the bundle of the ESP8266
    root folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the display cleared and are ready to show some text on the screen.
    Using the following block of code, display the `''hello''` text on the screen
    drawn at position (`0`, `0`) in the color white:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following block of code to clear the screen and show three lines of
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function and then call it; this will count down from the number 10
    to 0 on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following block of code, define a constant called `ALPHA_NUMERIC`.
    It contains all the lowercase, uppercase, and digit characters, which are organized
    in a structure that will fit on the display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following block of code, define and call the `show_alpha_numeric` function,
    which loops through the `ALPHA_NUMERIC` list and shows each string on a separate
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it will perform a count down animation and then
    display some alphanumeric text.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `countdown` function starts a `for` loop that will count from 10 to 0\.
    During each iteration, the screen is cleared and then the current number is displayed
    on the screen. The `ALPHA_NUMERIC` variable combines lowercase, uppercase, and
    digit characters in a format that is structured over three lines. The display
    can show 3 rows and 21 columns of text. This data fits within these limits so
    that all the characters can be displayed clearly without any cropping of text.
    The `countdown` function loops through each line of text and displays it at the
    correct position so that the 3 rows of text on the screen get filed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sky is the limit when it comes to what you can represent using textual
    output. The output you displayed could be as varied as sensor readings to the
    latest news headlines fetched live from the internet. The following photograph
    shows the display after the `show_alpha_numeric` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/efcd4925-a427-4cbe-939c-f805db778e89.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though the screen is physically quite small, it has a good resolution,
    and the font that comes with the CircuitPython library bundle has done a good
    job of using the limited screen space efficiently. This has made it possible to
    show three lines of text on a very small display.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation on a MicroPython project that creates an OLED watch can be
    found at [https://learn.adafruit.com/micropython-oled-watch](https://learn.adafruit.com/micropython-oled-watch).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further documentation on the I2C communication protocol can be found at [https://learn.sparkfun.com/tutorials/i2c/all](https://learn.sparkfun.com/tutorials/i2c/all).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverting colors on the display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to use the `invert` feature to flip the color
    of all the pixels. This can be used for when you are displaying white text on
    a black background, and then want the colors to be flipped so that the screen
    shows black text on a white background. A number of key operations on the display,
    such as clearing the screen, can be quite slow compared to features such as invert.
    We can take advantage of these performance differences to use invert when we want
    fast, visual feedback to appear to people using the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will help you whenever you are creating a project using a slow microcontroller
    and you need to find creative ways to make the device more responsive so that
    you can improve its usability.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the ESP8266 to run the code presented in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After the initial setup, the `oled` object is available for us to start inverting
    the screen. Use the following block of code to display some white text on a black
    background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The screen will now have black text on a white background. To flip the colors
    back, run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `invert` feature is much faster than some of the other methods that are
    used to update the screen. Use the following function to time this speed difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the next block of code to call the `measure_time` function, and time how
    long the `fill` operation takes in milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now time the `show` method, and you will see that it is faster than `fill`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to check the speed of the `text` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `invert` method has its speed checked, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When this script gets executed, it prints out the performance results for a
    number of screen-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `measure_time` function, by default, loops for three rounds. It saves the
    current time in the `start` variable, calls the function being tested, and then
    calculates the total execution time of the function call. This value is converted
    into milliseconds and the result is then printed out. The `main` function calls
    `measure_time` four times. It calls it to measure the execution time of `fill`,
    `show`, `text`, and the `invert` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the performance results, a number of things are quite evident. The
    good thing is that the results are pretty consistent. In this recipe, we have
    taken three readings for each measurement. It's always a good idea to take more
    than one sample when measuring execution speed. From the samples, it seems that
    a call to `fill` is approximately 500 times slower than a call to `invert`. For
    an application to feel responsive, operations shouldn't take more than 100 milliseconds,
    or it will appear to be sluggish or unresponsive. Operations such as `invert`,
    `text`, and `show` perform at a good speed. But since `fill` takes so long, we
    might want to call `invert` before performing `fill` so that users get a sign
    that our application is responding to their inputs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation on a CircuitPython project that uses the OLED display and
    the ESP8266 can be found at [https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend](https://learn.adafruit.com/circuitpython-totp-otp-2fa-authy-authenticator-friend).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further details on OLEDs can be found at [https://www.oled-info.com/oled-introduction](https://www.oled-info.com/oled-introduction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
