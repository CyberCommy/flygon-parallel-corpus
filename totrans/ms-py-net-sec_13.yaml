- en: Cryptography and Steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the main modules we have in python for encrypting and decrypting
    information, such as pycrypto and cryptography. Also we cover steganography techniques
    and how to hide information in images with the `stepic` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pycrypto` module for encrypting and decrypting information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cryptography` module for encrypting and decrypting information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main steganography techniques for hiding information in images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to hide information in images with the `stepic` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter13` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install python distribution in your local machine with at least
    4 GB memory.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and decrypting information with pycrypto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review cryptographic algorithms and the `pycrypto` module
    for encrypting and decrypting data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography can be defined as the practice of hiding information, and includes
    techniques for message-integrity checking, sender/receiver identity authentication,
    and digital signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the four most common types of cryptography algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hash functions:** Also known as one-way encryption, these have no key. A
    `hash` function outputs a fixed-length hash value for plaintext input, and in
    theory it''s impossible to recover the length or content of the plaintext. One
    way `cryptographic` functions are used in websites to store passwords in a manner
    that they cannot be retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyed hash functions:** Used to build message-authentication codes (MACs);
    MACs are intended to prevent brute-force attacks. So, they are intentionally designed
    to be slow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symmetric encryption:** Output a ciphertext for some text input using a variable
    key, and we can decrypt the ciphertext using the same key. Algorithms that use
    the same key for both encryption and decryption are known as symmetric key algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public key algorithms:** For public key algorithms, we have two different
    keys: one for encryption and the other for decryption. This practice uses a pair
    of keys: one to encrypt and another to decrypt. Users of this technology publish
    their public key, while keeping their private key secret. This enables anyone
    to send them a message encrypted with the public key, which only the holder of
    the private key can decrypt. These algorithms are designed so that finding out
    the private key is extremely difficult, even if the corresponding public key is
    known to an attacker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, for hash functions, Python provides some modules, such as `hashlib`.
  prefs: []
  type: TYPE_NORMAL
- en: The following script returns the `md5` checksum of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `md5.py` file inside the `hashlib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`The MD5 checksum is 8eec2037fe92612b9a141a45b60bec26`'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to pycrypto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to encrypting information with Python, we have some options, but
    one of the most reliable is the PyCrypto cryptographic library, which supports
    functions for block-encryption, flow-encryption, and hash-calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The `PyCrypto` module provides all needed functions for implementing strong
    cryptography in a Python program, including both hash functions and encryption
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the block ciphers supported by `pycrypto` are:'
  prefs: []
  type: TYPE_NORMAL
- en: AES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ARC2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blowfish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CAST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DES3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDEA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RC5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, all these ciphers are used in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Crypto.Cipher` package to import a specific cipher type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from Crypto.Cipher import [Chiper_Type]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the new method constructor to initialize the cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new ([key], [mode], [Vector IV])`'
  prefs: []
  type: TYPE_NORMAL
- en: With this method, only the key is mandatory, and we must take into account whether
    the type of encryption requires that it has a specific size. The possible modes
    are `MODE_ECB`, `MODE_CBC`, `MODE_CFB`, `MODE_PGP`, `MODE_OFB`, `MODE_CTR`, and
    `MODE_OPENPGP`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `MODE_CBC` or `MODE_CFB` modes are used, the third parameter (Vector
    IV) must be initialized, which allows an initial value to be given to the cipher.
    Some ciphers may have optional parameters, such as AES, which can specify the
    block and key size with the `block_size` and `key_size` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way we have seen with hashlib, hash Functions also are supported
    by `pycrypto`. The use of general hash functions with `pycrypto` is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the **`Crypto.Hash`** package to import a specific hash type:`from
    Crypto.Hash import [Hash Type]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the update method to set the data we need obtain the hash:`update('data')`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `hexdigest()` method to generate the hash: `hexdigest()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is the same example that we saw for obtaining the checksum of
    a file, in this case we are using `pycrypt` instead of `hashlib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `hash.py` file inside the `pycrypto`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To encrypt and decrypt data, we can use the `**encrypt**` and `**decrypt**`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting and decrypting with the DES algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DES  is a block cipher, which means that the text to be encrypted is a multiple
    of eight, so I added spaces at the end of the text. When I deciphered it, I removed
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The following script encrypts a user and a password and, finally, simulating
    that it is the server that has received these credentials, decrypts and displays
    this data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `Encrypt_decrypt_DES.py` file inside
    the `pycrypto` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The program encrypts the data using DES, so the first thing it does is import
    the `DES` module and create an encoder with the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cipher = DES.new(''mycipher'')`'
  prefs: []
  type: TYPE_NORMAL
- en: The ‘`mycipher`’ parameter value is the encryption key. Once the cipher is created,
    as you can see in the sample program, encryption and decryption is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting and decrypting with the AES algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AES encryption needs a strong key. The stronger the key, the stronger your encryption. Our
    AES Key needs to be either 16, 24, or 32 bytes long and our **Initialization Vector**
    needs to be **16 Bytes** long. That will be generated using the `random` and `string`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: To use an encryption algorithm such as AES, we can import it from the **`Crypto.Cipher.AES` **package.
    As the PyCrypto block-level encryption API is very low level, it only accepts
    16-, 24-, or 32-bytes-long keys for AES-128, AES-196, and AES-256, respectively.
    The longer the key, the stronger the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Also, for AES encryption using pycrypto, you need to ensure that the data is
    a multiple of 16 bytes in length. Pad the buffer if it is not and include the
    size of the data at the beginning of the output, so the receiver can decrypt properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `Encrypt_decrypt_AES.py` file inside
    the `pycrypto` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The **output** of the previous script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(''Cipher text: '', ''\xf2\xda\x92:\xc0\xb8\xd8PX\xc1\x07\xc2\xad"\xe4\x12\x16\x1e)(\xf4\xae\xdeW\xaf_\x9d\xbd\xf4\xc3\x87\xc4'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(''Decrypted text: '', ''This is the secret message'')`'
  prefs: []
  type: TYPE_NORMAL
- en: File encryption with AES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AES encryption requires that each block being written be a multiple of 16 bytes
    in size. So we read, encrypt, and write the data in chunks. The chunk size is
    required to be a multiple of 16.
  prefs: []
  type: TYPE_NORMAL
- en: The following script encrypts the file provided by the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `aes-file-encrypt.py` file inside the
    `pycrypto` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output of the previous script is a file called `file.txt.encrypted`, which
    contains the same content of the original file but the information is not legible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous script works in the way that first we load all required modules
    and define the function to encrypt the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to obtain our initialization Vector. A 16-byte initialization
    vector is required, which is generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can initialize the AES encryption method in the `PyCrypto` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: File decryption with AES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For decrypting, we need to reverse the preceding process to decrypt the file
    using AES.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `aes-file-decrypt.py`** file inside
    the `pycrypto` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting and decrypting information with cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review the `cryptography` module for encrypting and decrypting
    data. `Cryptography` is a module more recent and it has better performance and
    security than `pycrypto`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography is available in the `pypi` repository and you can install with
    the `pip install cryptography` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the [https://pypi.org/project/cryptography](https://pypi.org/project/cryptography) URL,
    we can see the last version of this module.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about installation and supported platforms, check out [https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography includes both high-level and low-level interfaces to common cryptographic
    algorithms, such as symmetric ciphers, message digests, and key-derivation functions.
    For example, we can use symmetric encryption with the `fernet` package.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric encryption with the fernet package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fernet is an implementation of symmetric encryption and guarantees that an encrypted
    message cannot be manipulated or read without the key.
  prefs: []
  type: TYPE_NORMAL
- en: For generating the key, we can use the `generate_key()` method from the `Fernet`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`encrypt_decrypt.py` file inside the
    cryptography folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ff216ff-69d5-4ad1-be86-befeb736603c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using passwords with the fernet package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to use passwords with Fernet. To do this, you need to run the
    password through a key-derivation function, such as **PBKDF2HMAC.**
  prefs: []
  type: TYPE_NORMAL
- en: '**PBKDF2 (Password Based Key Derivation Function 2)** is typically used for
    deriving a cryptographic key from a password.'
  prefs: []
  type: TYPE_NORMAL
- en: More information about key derivation functions can be found at [https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/](https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are using this function to generate a key from a password,
    and we use that key to create the Fernet object we will use for encrypting and
    decrypting data. In this case, the data to encrypt is a simple message string.
    We can use the `verify()` method, which checks whether deriving a new key from
    the supplied key generates the same key as expected_key.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`encrypt_decrypt_kdf.py` file inside
    the cryptography folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the **output** of the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c13daa7-c80c-44a2-82b6-1c19d484817e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we are verifying the key with the `verify()` method and it checks that keys
    not match during the process, it launches the `cryptography.exceptions.InvalidKey` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26d6ed93-5f7b-43d5-b0fb-ff9448d2e7ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Symmetric encryption with the ciphers package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ciphers package from the `cryptography` module provides a class for symmetric
    encryption with the`cryptography.hazmat.primitives.ciphers.Cipher` class.
  prefs: []
  type: TYPE_NORMAL
- en: Cipher objects combine an algorithm, such as AES, with a mode, such as CBC or
    CTR.
  prefs: []
  type: TYPE_NORMAL
- en: In the the following script, we can see an example of encrypting and then decrypting
    content with AES.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `encrypt_decrypt_AES.py` file inside
    the cryptography folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab420ee2-3e50-4975-b462-08b648925f9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Steganography techniques for hiding information in images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review Steganography techniques and stepic as the `python`
    module for hiding information in images.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Steganography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steganography ([http://en.wikipedia.org/wiki/Steganography](http://en.wikipedia.org/wiki/Steganography)) 
    is a specific branch of cryptography that allows us to hide a secret message into
    public information, that is, into apparently innocuous information.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main techniques for hiding information is use the **Least Significant
    Bit (LSB).**
  prefs: []
  type: TYPE_NORMAL
- en: When passing through each pixel of the image, we obtain an RGB triplet composed
    of whole numbers from (0) to (255), and since each number has its own representation
    in binary, we convert that triplet into its equivalent in binary; for example,
    the pixel formed by (148, 28, 202) is binary equivalent to (10010100, 00011100,
    11001010).
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to edit the least significant bit, that is, the one that is last
    to the right. In the following LSB column we have altered the bits (in red) but
    the rest are still intact, and the result of the RGB triplet undergoes some changes,
    but they are minimal. If they are carefully set in both colors, it is very unlikely
    that they will find any kind of visual difference but in reality there was a change,
    after altering the least significant bit, the RGB triplet is different from the
    one we had at the beginning, but the color apparently is the same.
  prefs: []
  type: TYPE_NORMAL
- en: We can alter the information and send it without an attacker realizing that
    there is something strange.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is ones and zeros and we can make the LSB follow the sequence that
    we want, for example, if we want to hide the word "Hacking," we have to remember
    that each letter (character) can be represented by a Byte being the "H" = 01001000
    so if we have 3 pixels we can hide that sequence using LSB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this image, we can see the representation of the "H" letter in Binary and
    LSB formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c79ec798-3c4c-4d66-9ce4-ab30a1ae8ec2.png)'
  prefs: []
  type: TYPE_IMG
- en: Since each pixel has three values ​​that compose it and in each one we can only
    alter a bit, then three pixels are necessary to hide the letter "H," since its
    representation in binary corresponds to eight bits. The preceding table is very
    intuitive; to get three pixels of the original image, we take out their respective
    RGB, and since we want to hide the letter "H" in binary, we simply replace the
    least significant bits in the order of the "H." Then we go back to reconstruct
    the three pixels, only now that we hide a letter in them, their values ​​have
    changed but no change perceptible to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can hide not only text but all kinds of information, since everything
    is representable in binary values; the way to recover the information is just
    to receive the altered image and start reading the least significant bits, because
    every eight bits, we have the representation of a character.
  prefs: []
  type: TYPE_NORMAL
- en: In the next script, we will implement this technique with python.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the following code in the `steganography_LSB.py` fileinside the
    steganography folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define our functions for get, set the **Least Significant Bit (LSB)**,
    and set the `extract_message()` method that reads the image and accesses the LSB
    for each pixel pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define our `hide_message` method, which reads the image and hides the
    message in the image using the LSB for each pixel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Steganography with Stepic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stepic provides a `Python` module and a command-line interface to hide arbitrary
    data within images. It slightly modifies the colours of the pixels in the image
    to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: To set up stepic, just install it with the `pip install stepic` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stepic’s `Steganographer` class is the main class of the module,where we can
    see the methods available for encoding and decoding data in images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d0c2b78-ae66-4ca7-99d1-b282cd23d612.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following script, compatible with python version 2.x, we can see the
    implementation of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the  `**stepic.py**`fileinside the `steganography`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this part of code, we can see methods related to encoding data in the image
    using the LSB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stepic reads pixels image from left to right, starting at the top. Each pixel
    is defined by a triplet of integers between 0 and 255, the first one provides
    the red component, the second one the green, and the third the blue. It reads
    three pixels at a time, each of which contains three values: red, green, and blue.
    Each group of pixels has nine values. A byte of data has eight bits, so if each
    color can be modified just slightly, by setting the least significant bit to zero
    or one, these three pixels can store a byte, with one color value left over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part of the code, we can see methods related to decoding data from
    the image using the LSB. Basically, given a sequence of pixels from the image,
    it returns an iterator of characters encoded in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Stepic uses the the least significant bit (**[http://en.wikipedia.org/wiki/Least_significant_bit](http://en.wikipedia.org/wiki/Least_significant_bit)**)
    of this leftover value to signify the end of the data.The coding scheme gives
    no clue as to whether an image contains data, so Stepic will always extract at
    least one byte from any image, whether or not someone intentionally hides data
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decode it, we can use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this function is the inverse of the `encode_imdata(imdata, data)`
    function, where three pixels are read at the same time from left to right, from
    top to bottom, until the last bit of the last color of the last pixel that reads
    its equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding data inside images with stepic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the script that follows, we are using the Image package from the `PIL` module
    form read an image. Once  we have read the image, we use the encode function from
    stepic to hide some text in the image. We save this information in a second image,
    and to obtain the hidden text, we use the decode function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `stepic_example.py` fileinside the `steganography`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the objectives of this chapter was to learn about the `pycrypto` and
    `cryptography` modules that allow us to encrypt and decrypt information with the
    AES and DES algorithms. We also we looked at steganography techniques, such as
    least significant bit, and how to hide information in images with the stepic module.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this book, I would like to emphasize that readers should learn more
    about the topics they consider most important. Each chapter covers the fundamental
    ideas, from there, readers can use the *Further reading* section to find resources
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which algorithm type uses the same key to encrypt and decrypt data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which algorithm type uses two different keys, one for encryption and the other
    for decryption?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package can we use in pycrypto to use an encryption algorithm such as
    AES?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which algorithm needs to ensure that the data is a multiple of 16 bytes in length?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which package for the `cryptography` module we can use symmetric encryption?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which algorithm is used to derive a cryptographic key from a password?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What provides the fernet package for symmetric encryption and what is the method
    used for generating the key**?**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class provides ciphers package symmetric encryption?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method from stepic generates an image with hidden data, starting with
    an existing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: image and arbitrary data?
  prefs: []
  type: TYPE_NORMAL
- en: Which package from pycrypto contains some `hash` functions that allow one-way
    encryption?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the tools mentioned in
    this chapter and their official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pycryptodome` is a module based in the `pycrypto` library available in the
    `pypi` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pypi.org/project/pycryptodome/](https://pypi.org/project/pycryptodome/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Legrandin/pycryptodome](https://github.com/Legrandin/pycryptodome)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.pycryptodome.org/en/latest/](https://www.pycryptodome.org/en/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In these links, we can see other examples related to the `Pycrypto` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x](https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/jmortega/pycon-security_criptography](https://github.com/jmortega/pycon-security_criptography)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to explore password-generation in greater depth, you can find other
    interesting modules such as Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/secrets.html#module-secrets](https://docs.python.org/3/library/secrets.html#module-secrets)'
  prefs: []
  type: TYPE_NORMAL
- en: The `secrets` module is used for generating cryptographically-strong random
    numbers that are suitable for managing data, such as passwords,  account authentication,
    security tokens, and related secrets.
  prefs: []
  type: TYPE_NORMAL
