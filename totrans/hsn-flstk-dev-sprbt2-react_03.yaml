- en: Creating a RESTful Web Service with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will first create a RESTful web service using the controller
    class. After that, we will demonstrate how to use Spring Data REST to create a RESTful
    web service that also covers all CRUD functionalities automatically. We are using
    the database application that we created in the previous chapter as a starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What the RESTful web service is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a RESTful web service with Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to test the RESTful web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Boot application that has been created in previous chapters is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Postman, cURL, or another suitable tool for transferring data using various
    HTTP methods is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services are applications that communicate over the internet using the HTTP
    protocol. There are many different types of web service architectures, but the
    main idea across all designs is the same. In this book, we are creating a RESTful
    web service from what is a really popular design nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** (**Representational State Transfer**) is an architectural style for
    creating web services. REST is not standard, but it defines a set of constraints
    defined by Roy Fielding. The six constraints are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless**: The server doesn''t hold any information about the client state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client server**: The client and server act independently. The server does
    not send any information without a request from the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Many clients often request the same resources, therefore it
    is useful to cache responses in order to improve performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform interface**: Requests from different clients look the same. Clients
    may be, for example, a browser, a Java application, and a mobile application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered system**: REST allows us to use a layered system architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code on demand**: This is an optional constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The uniform interface is an important constraint and it defines that every
    REST architecture should have following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identification of resources**: There are resources with their unique identifiers,
    for example, URIs in web-based REST services. REST resources should expose easily
    understood directory structure URIs. Therefore, a good resource naming strategy
    is very important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource manipulation through representation**: When making a request to
    a resource, the server responds with a representation of the resource. Typically,
    the format of the representation is JSON or XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self descriptive messages**: Messages should have enough information that
    the server knows how to process them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypermedia and the Engine of Application State (HATEOAS)**: Responses can
    contain links to other areas of service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RESTful web service that we are going to develop in the following topics
    follows the REST architectural principles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring Boot, all the HTTP requests are handled by controller classes. To
    be able to create a RESTful web service, first, we have to create a controller
    class. We will create our own Java package for our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the root package in the Eclipse Project Explorer and right-click.
    Select New | Package from the menu. We will name our new package `com.packt.cardatabase.web`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8af105c5-d9c6-40c6-a1a4-99e4ba6af9d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create a new controller class in a new web package. Activate
    the `com.packt.cardatabase.web` package in the Eclipse project explorer and right-click.
    Select New | Class from the menu. We will name our class  `CarController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06e6c5f3-0ea3-429f-bea1-7a14ef6362e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, your project structure should look like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/decf853a-39e9-4624-a18e-f0f8869a8db1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you create classes in a wrong package accidentally, you can drag and drop
    the files between packages in the Eclipse Project Explorer. Sometimes, the Eclipse
    Project Explorer view might not be rendered correctly when you make some changes.
    Refreshing the project explorer helps (Activate Project Explorer and press *F5*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your controller class in the editor window and add the `@RestController`
    annotation before the class definition. See the following source code. The `@RestController`
    annotation identifies that this class will be the controller for the RESTful web
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a new method inside our controller class. The method is annotated
    with the `@RequestMapping` annotation, which defines the endpoint that the method
    is mapped to. Following, you can see the sample source code. In this example,
    when a user navigates to the `/cars` endpoint, the `getCars()` method is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getCars()` method returns all the car objects, which are then marshalled
    to JSON objects by Jackson library.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `@RequestMapping` handles all the HTTP method (`GET`, `PUT`, `POST`,
    and more) requests. You can define which method is accepted with the following
    `@RequestMapping("/cars", method=GET)` parameter.  Now, this method handles only
    `GET` requests from the `/cars` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to return cars from the database, we have to inject our `CarRepository` into
    the controller. Then, we can use the `findAll()` method that the repository provides
    to fetch all cars. The following source code shows the controller code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run our application and navigate to `localhost:8080/cars`.
    We can see that there is something wrong, and the application seems to be in an
    infinite loop. That happens due to our one-to-many relationship between the car
    and owner tables. So, what happens in practice—first, the car is serialized, and
    it contains an owner that is then serialized, and that, in turn, contains cars
    that are then serialized... and so on. To avoid this, we have to add the `@JsonIgnore`
    annotation to the `cars` field in the `Owner` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run the application and navigate to `localhost:8080/cars` , everything
    should go as expected and you will get all the cars from the database in JSON
    format, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/305e5dea-ad05-46ca-a230-e663c0f62b14.png)'
  prefs: []
  type: TYPE_IMG
- en: We have done our first RESTful web service, which return all the cars. Spring
    Boot provides a much more powerful way of creating RESTful Web Services and this
    is investigated in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Data REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data REST is part of the Spring Data project. It offers an easy and
    fast way to implement RESTful Web Services with Spring. To start, using Spring
    Data REST you have to add the following dependency to the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, Spring Data REST finds all public repositories from the application
    and creates automatically RESTful Web Services for your entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the endpoint of service in your `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can access the RESTful web service from the `localhost:8080/api` endpoint.
    By calling the root endpoint of the service it returns the resources that are
    available. Spring Data REST returns JSON data in the **HAL** (**Hypertext Application
    Language**) format. The HAL format provides a set of conventions for expressing
    hyperlinks in JSON and it makes your RESTful web service easier to use for frontend
    developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85f89d74-3ada-4901-a9ca-4f71b1c75236.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that there are links to the car and owner entity services. The Spring
    Data Rest service pathname is derived from the entity name. The name will then
    be pluralized and uncapitalized. For example, the entity Car service pathname
    will be named `cars`. The profile link is generated by Spring Data Rest and it
    contains application-specific metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we start to examine different services more carefully. There are multiple
    tools available for testing and consuming RESTful Web Services. In this book,
    we are using Postman, but you can use tools that you are familiar with, such as
    cURL. Postman can be acquired as a desktop application or as a browser plugin.
    cURL is also available for Windows 10 by using Windows Ubuntu Bash.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make a request to the `cars` endpoint `http://localhost:8080/api/cars`
    using the `GET` method, you will get a list of all the `cars`, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bda9f9b-22a3-45e9-9a81-4404dc9617c1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the JSON response, you can see that there is an array of `cars` and each
    car contains car specific data. All the cars also have the `"_links"` attribute,
    which is a collection of links, and with these you can access the car itself or
    get the owner of the car. To access one specific car, the path will be `http://localhost:8080/api/cars/{id}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request to `http://localhost:8080/api/cars/3/owner` returns the owner of
    the car. The response now contains owner data, a link to the owner, and links
    to other `cars` that the user owns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f3bd7b-74e7-4630-ae0f-1236c809c3f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Spring Data Rest service provides all CRUD operations. The following table
    shows which HTTP methods you can use for different CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Method** | **CRUD** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `Read` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `Create` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT`/`PATCH` | `Update` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `Delete` |'
  prefs: []
  type: TYPE_TB
- en: 'Next, we will look at how to delete a car from the database by using our RESTful
    web service. In a delete operation, you have to use the `DELETE` method and the
    link to the car that will be deleted (`http://localhost:8080/api/cars/{id}`).
    The following screenshot shows how you can delete one car with the ID `4` by using
    cURL. After the delete request, you can see that there are now two cars left in
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/407f8dec-9bcd-4873-94c7-d8511f5f6df1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we want to add a new car to the database, we have to use the `POST` method,
    and the link is `http://localhost:8080/api/cars`. The header must contain the Content-Type
    field with the value `Content-Type:application/json`, and the new car object will
    be embedded in the request body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e18bf0b-cb25-4518-a14f-e75a5f33bd58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The response will send a newly created car object back. Now, if you again make
    a `GET` request to the `http://localhost:8080/api/cars` path, you can see that
    the new car exists in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5145856e-3e35-4b27-9db3-68430cddd478.png)'
  prefs: []
  type: TYPE_IMG
- en: To update entities, we have to use the `PATCH` method and the link to the car
    that we want to update  (`http://localhost:8080/api/cars/{id}`). The header must
    contain the Content-Type field with the value `Content-Type:application/json` and
    the car object, with edited data, will be given inside the request body. If you
    are using `PATCH`, you have to send only fields that are updates. If you are using
    `PUT`, you have to include all fields to request. Let's edit our car that we created
    in the previous example. We will change the color to white and fill in the register
    number that we left empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also link an owner to the car by using the owner field. The content
    of the owner field is the link to the owner (`http://localhost:8080/api/owners/{id}`).
    The following screenshot shows the `PATCH` request content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08f4c1d3-94ce-423b-9fee-680672fc9265.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that the car is updated after you fetch all cars by using `GET`
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac790642-d5a0-4cda-b59e-1dac6a3d63aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapter, we created queries to our repository. These queries
    can also be included in our service. To include queries, you have to add the `@RepositoryRestResource`
    annotation to the repository class. Query parameters are annotated with the `@Param`
    annotation. The following source code shows our `CarRepository` with these annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you make a `GET` request to the `http://localhost:8080/api/cars` path,
    you can see that there is a new endpoint called `/search`. Calling the `http://localhost:8080/api/cars/search`
    path returns the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0858edd-43c9-4651-9cf3-cf8cbad926c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the response, you can see that both queries are now available in our service.
    The following URL demonstrates how to fetch cars by brand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/e13154d6-9ac3-4f7d-bd97-1b99d6954498.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a RESTful web service with Spring Boot. First, we
    created a controller and one method that returns all cars in JSON format. Next,
    we used Spring Data REST to get a fully functional web service with all CRUD functionalities.
    We covered different types of requests that are needed to use CRUD functionalities
    of the service that we created. Finally, we also included our queries to service.
    In the next chapter we will secure our backend using Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is REST?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a RESTful web service with Spring Boot?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you fetch items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you delete items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you add items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you update items using our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use queries with our RESTful web service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pack has other great resources for learning about Spring Boot RESTful Web Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/learning-spring-boot-20-second-edition](https://www.packtpub.com/application-development/learning-spring-boot-20-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/spring-boot-getting-started-integrated-course](https://www.packtpub.com/web-development/spring-boot-getting-started-integrated-course)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/building-restful-web-service-spring](https://www.packtpub.com/web-development/building-restful-web-service-spring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
