- en: Chapter 11. Odds and Ends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling weeks in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Currency in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the NumericShaper.Range enumeration to support the display of digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaBean improvements in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling locales and the Locale.Builder class in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling null references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new BitSet methods in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will address many new additions to Java 7 that do not fit into
    the previous chapters. Many of these enhancements have potentially widespread
    application, such as the `java.lang.Objects` class and `java.util.Locale` class
    improvements as discussed in the *Handling locales and the Locale.Builder class
    in Java 7* recipe. Others are more specialized, such as the improvements made
    to the `java.util.BitSet` class, which is covered in the *Using the new BitSet
    methods in Java 7* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There have been a number of improvements in the handling of weeks and currency.
    The calculation of the current week and the number of weeks per year is impacted
    by the locale. In addition, it is now possible to determine the currencies available
    on a platform. These issues are illustrated in the *Handling weeks in Java 7*
    and *Using Currency on Java 7* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: A new enumeration has been added that eases the display of digits in different
    languages. The use of the `java.awt.font.NumericShaper` class for this endeavor
    is discussed in the *Using the NumericShaper.Range enumeration to support the
    display of digits* recipe. Improvements in the support of JavaBeans are discussed
    in the *JavaBean improvements in Java 7* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a number of enhancements, which do not warrant separate recipes.
    The rest of this introduction is devoted to these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode 6.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Unicode 6.0** is the newest revision of the Unicode standard. Java 7 supports
    this release with the addition of thousands of more characters and numerous new
    methods. In addition, regular expression pattern matching supports Unicode 6.0
    using either **\u** or **\x** escape sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numerous new character blocks were added to the `Character.UnicodeBlock` class.
    The `Character.UnicodeScript` enumeration was added in Java 7 to represent the
    character scripts defined in the **Unicode Standard Annex #24: Script Names.**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information regarding Unicode Standard Annex #24: Script Names can be
    found at [http://download.oracle.com/javase/7/docs/api/index.html](http://download.oracle.com/javase/7/docs/api/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several methods have been added to the `Character` class in support of the
    Unicode operations. The following illustrates their use with the string 朝鲜圆, which
    is the display name for North Korean Won in Chinese based on the locale, and the
    simplified script as used in mainland China. Add the following code sequence to
    a new application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, your output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**isBmpCodePoint: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**isSurrogate: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**highSurrogate: 55257**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lowSurrogate: 57117**'
  prefs: []
  type: TYPE_NORMAL
- en: '**isAlphabetic: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**isIdeographic: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getName: CJK UNIFIED IDEOGRAPHS 671D**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the character is not a Unicode surrogate code, the `highSurrogate` and
    `lowSurrogate` method results are not useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information regarding Unicode 6.0 can be found at [http://www.unicode.org/versions/Unicode6.0.0/](http://www.unicode.org/versions/Unicode6.0.0/).
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types and the compare method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java 7 introduced new static methods for comparing primitive data types `Boolean,
    byte, long, short`, and `int`. Each wrapper class now has a `compare` method,
    which takes two instances of the data type as arguments and returns an integer
    representing the result of the comparison. For example, you would have previously
    needed to use the `compareTo` method to compare two Boolean variables, x and y
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now use the `compare` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While this is new to Java for the Boolean data type, the `compare` method was
    previously available for `doubles` and `floats`. Additionally in 7, the `parse,
    valueof`, and `decode` methods, used for converting strings to numeric values,
    will accept a leading plus (+) sign with data types `Byte, Short, Integer, Long`,
    and `BigInteger`, in addition to `Float, Double`, and `BigDecimal`, which previously
    accepted the sign.
  prefs: []
  type: TYPE_NORMAL
- en: Global logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `java.util.logging.Logger` class has a new method, `getGlobal`, used for
    retrieving the global logger object named `GLOBAL_LOGGER_NAME`. The static field
    global of the `Logger` class is prone to deadlocks when the `Logger` class is
    used in conjunction with the `LogManager` class, as both classes will wait on
    each other to complete initialization. The `getGlobal` method is the preferred
    way to access the `global logger` object, in order to prevent such deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: JavaDocs improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There have been significant improvements in JavaDocs as of Java 7\. From a structural
    standpoint, the generation of the HTML pages is now accomplished by using the
    `HTMLTree` classes to create a document tree, which results in more accurate HTML
    generation and fewer invalid pages.
  prefs: []
  type: TYPE_NORMAL
- en: There have also been external changes to the JavaDocs, some of which were in
    order to comply with the new **Section 508** accessibility guidelines. These are
    developed to ensure screen readers, used for translating web-based text into audible
    output, are able to accurately translate an HTML page. Primarily, this has resulted
    in the addition of more captions and headings on the tables. JavaDocs now also
    use a CSS stylesheet to simplify changes to the appearance of the pages.
  prefs: []
  type: TYPE_NORMAL
- en: JVM performance enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The performance of the Java HotSpotTM virtual machine has been improved. Most
    of these improvements are not under the control of the developer and are specialized
    in nature. The interested reader will find more details about these enhancements
    at [http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html](http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Handling weeks in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some applications are concerned with the number of weeks in a year and the current
    week of the year. It is common knowledge that there are 52 weeks in a year, but
    52 weeks multiplied by 7 days per week equals 364 days per year, not the actual
    365 days. A **week number** is used to refer to the week of the year. But how
    is that calculated? Java 7 has introduced several methods to support determining
    the week of the year. In this recipe we will examine these methods, and see how
    week-related values are calculated. The **ISO 8601** standard provides methods
    for representing dates and time. The `java.util.GregorianCalendar` class supports
    this standard, except as described in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use these week-based methods we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `Calendar` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use its methods as appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some implementations of the abstract `java.util.Calendar` class do not support
    week calculations. To determine if the `Calendar` implementation supports week
    calculations, we need to execute the `isWeekDateSupported` method. It returns
    `true` if the support is provided. To return the number of weeks for the current
    calendar year, use the `getWeeksInWeekYear` method. To determine the week for
    the current date, use the `get` method with the `WEEK_OF_YEAR` as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application. Add the following code to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should appear as follows, but the values
    will be dependent upon the date the application was executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Number of weeks in this year: 53**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current week number: 48**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An instance of the `Calendar` class was created. This is normally an instance
    of the `GregorianCalendar` class. An `if` statement was controlled by the `isWeekDateSupported`
    method. It returned `true`, which resulted in the execution of the `getWeeksInWeekYear`
    and `get` methods. The `get` method was passed in the field `WEEK_OF_YEAR`, which
    returned the current week number.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The date can be set using the `setWeekDate` method. This method has three arguments
    specifying the year, week, and day. It provides a convenient technique for setting
    the date based on weeks. The following illustrates this process by setting the
    year to 2012, the week to the 16th week of the year, and the day to the third
    day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**April 17, 2012 12:00:08 PM CDT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that the first and last week of the year is calculated is locale-dependent.
    The `GregorianCalendar` class'' `WEEK_OF_YEAR` field ranges from 1 to 53, where
    53 represents a leap week. The first week of the year is:'
  prefs: []
  type: TYPE_NORMAL
- en: The earliest seven day period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting on the first day of the week (`getFirstDayOfWeek`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That contains at least the minimal days in a week (`getMinimalDaysInFirstWeek`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getFirstDayOfWeek` and `getMinimalDaysInFirstWeek` methods are locale-dependent.
    For example, the `getFirstDayOfWeek` method returns an integer representing the
    first day of the week for a locale. In the U.S., it is SUNDAY, but in France it
    is MONDAY.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and last week of a week year may have different calendar years. Consider
    the following code sequence. The calendar is set to the first day of the first
    week of 2022:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**December 26, 2021 12:15:39 PM CST**'
  prefs: []
  type: TYPE_NORMAL
- en: This shows that the week actually starts in the previous year.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the `TimeZone` and `SimpleTimeZone` classes have an `observesDaylightTime`
    method that returns `true` if the time zone observes daylight saving time. The
    following code sequence creates an instance of a `SimpleTimeZone` class and then
    determines if daylight saving time is supported. The time zone used is for **Central
    Standard Time** (**CST**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When this sequence is executed, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central Standard Time - true**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Currency class in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `java.util.Currency` class introduced four new methods for retrieving information
    about available currencies and their properties. This recipe illustrates the use
    of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAvailableCurrencies:` This method returns a set of currencies available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNumericCode:` This method returns the ISO 4217 numeric code for the currency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDisplayName:` This overloaded method returns a string representing the
    display name of the currency. One method is passed a `Locale` object. The string
    returned is specific for that locale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `getAvailableCurrencies` method is static, so it should be executed against
    the class name. The other methods execute against an instance of the `Currency`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Add the following code to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the application is executed, you should get output similar to the following.
    However, the first part of each may differ depending on the current locale.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**North Korean Won - Nordkoreanischer Won - 408**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Euro - Euro - 978**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dutch Guilder - Holländischer Gulden - 528**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Falkland Islands Pound - Falkland-Pfund - 238**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Danish Krone - Dänische Krone - 208**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Belize Dollar - Belize-Dollar - 84**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code sequence begins with the generation of a `Set` of the `Currency` objects
    representing the current system's configuration. The overloaded `getDisplayName`
    methods were executed against each element of the set. The `Locale.GERMAN` argument
    was used to illustrate the use of this method. The last value displayed was the
    numeric code for the currency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the NumericShaper.Range enumeration to support the display of digits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will demonstrate the use of `java.awt.font.NumericShaper.Range`
    enumeration to support the display of digits using the `java.awt.font.NumericShaper`
    class. Sometimes it is desirable to display numeric digits using a different language
    than is currently being used. For example, in an English language tutorial regarding
    the Mongolian language, we may want to explain the numeric system in English,
    but display numbers using the Mongolian digits. The `NumericShaper` class provides
    this support. The new `NumericShaper.Range` enumeration has simplified this support.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display digits using the `NumericShaper.Range` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `HashMap` to hold display attribute information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Font` object to define the font to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the range of Unicode characters to display the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `FontRenderContext` object to hold information about how to measure
    the text to be displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of `TextLayout` and use it in the `paintComponent` method
    to render the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will illustrate the use of the `NumericShaper.Range` enumeration to display
    Mongolian digits. This is a simplified version of the example found at [http://download.oracle.com/javase/tutorial/i18n/text/shapedDigits.html](http://download.oracle.com/javase/tutorial/i18n/text/shapedDigits.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application that extends the `JFrame` class, which is shown as follows.
    We will illustrate the use of the `NumericShaper` class in the `NumericShaperPanel`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `NumericShaperPanel` class to the project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, an instance of the `NumericShaperExample` class was created.
    Within its constructor, an instance of the `NumericShaperPanel` class was created
    and added to the center of the window. The title, default close operation, and
    size of the window were set. Next, the window was made visible.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor of the `NumericShaperPanel` class, a text string was created
    along with a `HashMap` to hold the essential features of the display. This map
    was used as an argument to the `TextLayout` constructor along with the string
    to be displayed and the map. The text was displayed in Mongolian using the Mongolian
    Baiti font and with the MONGOLIAN range. We used this font to demonstrate the
    new methods of the `NumericShaper` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `NumericShaper` class has added new methods to make it easier to display
    numeric values in a different language. The `getShaper` method is overloaded with
    one version accepting a `NumericShaper.Range` enumeration value. The value specifies
    the language to use. The `NumericShaper.Range` enumeration has been added to represent
    a range of Unicode characters for digits in a given language.
  prefs: []
  type: TYPE_NORMAL
- en: In the `paintComponent` method, the `Graphics2D` object was used as an argument
    of the `draw` method to render the string to the window.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `getContextualShaper` method is used to control how digits are displayed
    when used with a different script. This means if Japanese script is used before
    digits, then Japanese digits are displayed. The method takes a set of `NumericShaper.Range`
    enumeration values.
  prefs: []
  type: TYPE_NORMAL
- en: The `shape` method also uses a range to specify the script to use for an array
    of char given a start and an end index in the array. The `getRangeSet` method
    returns a set of `NumericShaper.Range` used by the `NumericShaper` instance.
  prefs: []
  type: TYPE_NORMAL
- en: JavaBean enhancements in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaBean** is a way of building reusable components for Java applications.
    They are Java classes that follow certain naming conventions. There have been
    several JavaBean enhancements added in Java 7\. Here we will focus on the `java.beans.Expression`
    class, which is useful in executing methods. The `execute` method has been added
    to facilitate this capability.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `Expression` class to execute a method:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an array of arguments for the method, if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Expression` class specifying the object that the
    method is to be executed against, the method name, and any arguments needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the `execute` method against the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `getValue` method to obtain the results of the method execution, if
    necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Create two classes: `JavaBeanExample`, which
    contains the `main` method and a `Person` class. The `Person` class contains a
    single field for a name along with constructors, a getter method, and a setter
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method of the `JavaBeanExample` class, we will create an instance
    of the `Person` class, and use the `Expression` class to execute its `getName`
    and `setName` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Its output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name: Jane**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: Peter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name: Peter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getValue: Peter**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Person` class used a single field, name. The `getName` and `setName` methods
    were used from the `main` method, where a `Person` instance was created. The `Expression`
    class' constructor has four arguments. The first argument was not used in this
    example, but can be used to define a return value for the method executed. The
    second argument was the object that the method would be executed against. The
    third argument is a string containing the name of the method, and the last argument
    was an array containing the parameters used by the method.
  prefs: []
  type: TYPE_NORMAL
- en: In the first sequence, the `setName` method was executed using an argument of
    `Peter`. The output of the application shows that the name was initially `Jane`,
    but was changed to `Peter` after the `execute` method was executed.
  prefs: []
  type: TYPE_NORMAL
- en: In the second sequence, the `getName` method was executed. The `getValue` method
    returns the results of the execution of the method. The output shows that the
    `getName` method returned `Peter`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There have been other enhancements to the classes of the `java.bean` package.
    For example, the `toString` method has been overridden in the `FeatureDescriptor`
    and `PropertyChangeEvent` classes to provide a more meaningful description.
  prefs: []
  type: TYPE_NORMAL
- en: The `Introspector` class provides a way of learning about the properties, methods,
    and events of a Java Bean without using the Reflection API, which can be tedious.
    The class has added a `getBeanInfo` method, which uses the `Inspector` class'
    control flags to affect the `BeanInfo` object returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `Transient` annotation has been added to control what is included. A `true`
    value for the attribute means that the annotated feature should be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: A new constructor has been added to the `XMLDecoder` class that accepts an `InputSource`
    object. Also, the `createHandler` method has been added, which returns a `DefaultHandler`
    object. This handler is used to parse XML archives created by the `XMLEncoder`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: A new constructor has been added to the `XMLEncoder` class. This permits writing
    out JavaBeans to an `OutputStream` using a specific charset with a specific indention.
  prefs: []
  type: TYPE_NORMAL
- en: Handling locales and the Locale.Builder class in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.Locale.Builder` class has been added to Java 7 and provides an
    easy way of creating a locale. The `Locale.Category` enumeration is also new and
    makes using different locales for display and formatting purposes easy. We will
    first look at the use of the `Locale.Builder` class and then examine other locale
    improvements and the use of the `Locale.Category` enumeration in the *There's
    more..*. section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build and use a new `Locale` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `Builder` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the relevant methods of the class to set up the attributes needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Locale` object as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. In the `main` method, add the following code.
    We will create a new locale based on Eastern Armenian using Latin script as found
    in Italy. The locale is demonstrated by displaying the date for the third day
    of the 16th week in 2012 using the `setWeekDate` method. This method is discussed
    in more detail in the *Handling Weeks in Java 7* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A second example builds a locale based on Chinese using the Simplified script,
    which is used in mainland China:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**April 17, 2012 7:25:42 PM CDT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Armenian**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2012年4月17日 下午07时25分42秒**'
  prefs: []
  type: TYPE_NORMAL
- en: '**中文**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Builder` object was created. Using this object, we applied methods to set
    the language, script, and region for the locale. The `build` method was then executed
    and a `Locale` object was returned. We used this locale to display the date and
    the display language for the locale. This was performed twice. First, for the
    Armenian language, and then for Chinese.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to be able to label a piece of information to indicate the language
    being used. A tag is used for this purpose. A standard set of tags is defined
    by the **IETF BCP 47** standard. Java 7 conforms to this standard and has added
    several methods to handle tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard supports the concept of extensions to a tag. These extensions
    can be used to provide more information about the locale. There are two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode locale extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private use extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unicode locale extensions are defined by the **Unicode Common Locale Data
    Repository** (**CLDR**) ([http://cldr.unicode.org/](http://cldr.unicode.org/)).
    These extensions are concerned with non-language information, such as currency
    and dates. The CLDR maintains a standard repository of locale information. Private
    use extensions are used to specify platform-specific information, such as that
    related to operating systems or programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information regarding the IETF BCP 47 standard can be found at [http://tools.ietf.org/rfc/bcp/bcp47.txt](http://tools.ietf.org/rfc/bcp/bcp47.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'An extension consists of a key/value pair. The key is a single character and
    the value follows the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A `SUBTAG` consists of a series of alphanumeric characters. For Unicode locale
    extensions, the value must be at least two characters, but not more than 8 characters
    in length. For private use extensions, 1 to 8 characters are permitted. All extension
    strings are case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: The key for Unicode locale extension is **u**, and for private use extensions
    it is **x**. These extensions can be added to a locale to provide additional information,
    such as the calendar number types to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys that can be used are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *ca* | Calendar algorithm for determining dates |'
  prefs: []
  type: TYPE_TB
- en: '| *co* | Collation—type the ordering used in a language |'
  prefs: []
  type: TYPE_TB
- en: '| *ka* | Collation parameters—used to specify the ordering |'
  prefs: []
  type: TYPE_TB
- en: '| *cu* | Currency type information |'
  prefs: []
  type: TYPE_TB
- en: '| *nu* | Numbering system |'
  prefs: []
  type: TYPE_TB
- en: '| *va* | Common variant type |'
  prefs: []
  type: TYPE_TB
- en: 'Examples of key and types are found in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key/Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nu-armnlow | Armenian lowercase numerals |'
  prefs: []
  type: TYPE_TB
- en: '| ca-indian | Indian calendar |'
  prefs: []
  type: TYPE_TB
- en: Several methods have been added to use these extensions. The `getExtensionKeys`
    method returns a set of `Character` objects of all keys used with the locale.
    Likewise, the `getUnicodeLocaleAttributes` and `getUnicodeLocaleKeys` methods
    return a set of strings listing the attributes and the Unicode keys available.
    The methods return an empty set if there are no extensions available. If the key
    is known, the `getExtension` method or `getUnicodeLocaleType` methods will return
    a string containing the value for that key.
  prefs: []
  type: TYPE_NORMAL
- en: For a given locale, the `getScript, getDisplayScript`, and `toLanguageTag` methods
    return the script, a displayable name for the script, and a well-formed **BCP
    47** tag for the locale respectively. The `getDisplayScript` method will also
    return a displayable name for the script, given a locale as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses the use of the `setDefault` method to control the
    display of information using two different locales at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Locale.Category enumeration to display information using two different
    locales
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Locale.Category` enumeration has been added to Java 7\. It has two values,
    `DISPLAY` and `FORMAT`. This permits the default locale to be set for format type
    resources (dates, numbers, and currency) and for display resources (GUI aspects
    of an application). For example, part of an application may set the format to
    accommodate one locale, such as `JAPANESE` while displaying related information
    in another, such as `GERMAN.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When this code sequence is executed, you should get output similar to the following.
    The initial date and display language may differ depending on your default locale.
  prefs: []
  type: TYPE_NORMAL
- en: '**April 17, 2012 7:15:14 PM CDT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**English**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2012/04/17 19:15:14 CDT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**English**'
  prefs: []
  type: TYPE_NORMAL
- en: The default locale was retrieved and the `setWeekDate` method was used to set
    a date. This method is discussed in more detail in the *Using Weeks in Java 7*
    recipe. Next, the date and the display language are printed. The display was repeated,
    except that the default locale is changed using the `setDefault` method. The display
    resources were changed to use `Locale.JAPANESE`, and the format type resources
    were changed to `Locale.GERMAN`. The output reflected this change.
  prefs: []
  type: TYPE_NORMAL
- en: Handling null references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fairly common exception is the `java.lang.NullPointerException`. This occurs
    when an attempt is made to execute a method against a reference variable, which
    contains a value of null. In this recipe we will examine various techniques that
    are available to address this type of exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.Objects` class has been introduced and provides a number of static
    methods that address situations where null values need to be handled. The use
    of this class simplifies the testing for null values.
  prefs: []
  type: TYPE_NORMAL
- en: The *There's more..*. section examines the use of empty lists, which could be
    used instead of returning null. The `java.util.Collections` class has three methods
    that return empty lists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `Objects` class to override the `equals` and `hashCode` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the methods in the target class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Objects` class' `equals` method to avoid explicit code to check for
    null values in the `equals` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Objects` class' `hashCode` method to avoid the need for explicit code
    to check for null values in the `hashCode` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. We will create an `Item` class to demonstrate
    the use of the `Objects` class. In the `Item` class, we will override the `equals`
    and `hashCode` methods. These methods were generated by the NetBeans'' insert
    code command. We use these methods, because they illustrate the `Objects` class''
    methods and are well structured. Start by creating the class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, override the `equals` and `hashCode` methods as follows. They provide
    code to check for null values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the class by adding a `toString` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**item1 equals item1: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**item1 equals item2: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**item1 equals item3: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**item1 equals item4: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception in thread "main" java.lang.NullPointerException**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at java.util.Objects.requireNonNull(Objects.java:201)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.Item.setName(Item.java:23)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**at packt.NullReferenceExamples.main(NullReferenceExamples.java:71)**'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see shortly, the `NullPointerException` is the result of trying to
    assign a null value to an Item's name field.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `equals` method, a test was first made to determine if the object passed
    was null. If it was, then `false` is returned. A test was made to ensure that
    the classes were of the same type. The `equals` method was then used to see if
    the two name fields were equal to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Objects` class'' `equals` method behaves as summarized in the following
    table. The meaning of equality is determined by the `equals` method of the first
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '| First argument | Second argument | Returns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Not null | Not null | `true` if they are the same object, otherwise `false`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Not null | null | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| null | Not null | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| null | null | `true` |'
  prefs: []
  type: TYPE_TB
- en: The last test compared the two integer `partNumber` fields for equality.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Item` class' `hashCode` method, the `Objects` class' `hashCode` method
    was applied to the name field. This method will return 0 if its argument is null
    otherwise it returns the hash code for the argument. The `partNumber` was then
    used to compute the final value for the hash code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `requireNonNull` method in the two argument constructors
    and the `setName` method. The method checks for a non-null argument. If the argument
    is null, it then throws a `NullPointerException`. This effectively catches a potential
    error earlier in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `requireNonNull` method is overloaded with a second version accepting a
    second string argument. This argument changes the message generated, when an exception
    occurs. Replace the body of the `setName` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Re-execute the application. The exception message will now appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception in thread "main" java.lang.NullPointerException: The name field
    requires a non-null value**'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several other `Objects` class methods that may be of interest. In
    addition, the second section will examine the use of empty iterators to avoid
    null pointer exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Objects class methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Objects` class'' `hashCode` method is overloaded. A second version takes
    a variable number of objects as arguments. The method will generate a hash code
    using this sequence of objects. For example, the `Item` class'' `hashCode` method
    could have been written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `deepEquals` method compares two objects deeply. This means it compares
    more than just the reference values. Two null arguments are considered to be deeply
    equal. If both arguments are arrays, then the `Arrays.deepEqual` method is invoked.
    Equality of objects is determined by the `equals` method of the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `compare` method is used to compare the first two arguments returning either
    a negative value, a zero, or a positive value depending on the relationship between
    the arguments. Typically, returning a 0 indicates that the arguments are the same.
    A negative value means that the first argument is less than the second argument.
    A positive value indicates that the first argument is greater than the second
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: The method will return a zero if its arguments are identical, or if both arguments
    are null. Otherwise, the return value is determined using the `Comparator` interface's
    `compare` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Objects` class'' `toString` method is used to guarantee that a string
    is returned even if the object is null. The following sequence illustrates the
    use of this overloaded method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the first use of the method displays the word **null**. In the
    second version, the string argument is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**toString: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**toString: Item is null**'
  prefs: []
  type: TYPE_NORMAL
- en: Using empty iterators to avoid null pointer exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One approach to avoid a `NullPointerException` is to return a non-null value,
    when the list could not be created. It could be beneficial to return an empty
    `Iterator` instead.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 7, the `Collections` class has added three new methods that return an
    `Iterator`, a `ListIterator`, or an `Enumeration`, all of which are empty. By
    returning empty, they can be used without incurring a null pointer exception.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the use of an empty list iterator, create a new method that returns
    a generic `ListIterator<String>` as shown in the following code. An `if` statement
    is used to return either a `ListIterator` or an empty `ListIterator:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following `main` method to test the behavior of the iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When it executes, there should be no output. This indicates that the iterator
    is empty. If we had returned null instead, we would have received a `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Collections` class'' static `emptyListIterator` method returns a `ListIterator`,
    whose methods work as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `hasNext``hasPrevious` | Always returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `next``Previous` | Always throws `NoSuchElementException` |'
  prefs: []
  type: TYPE_TB
- en: '| `remove``set` | Always throws `IllegalStateException` |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Always throws `UnsupportedOperationException` |'
  prefs: []
  type: TYPE_TB
- en: '| `nextIndex` | Always returns 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `previousIndex` | Always returns -1 |'
  prefs: []
  type: TYPE_TB
- en: 'The `emptyIterator` method will return an empty iterator with the following
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `hasNext` | Always returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Always throws `NoSuchElementException` |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | Always throws `IllegalStateException` |'
  prefs: []
  type: TYPE_TB
- en: The `emptyEnumeration` method returns an empty enumeration. Its `hasMoreElements`
    will always return `false`, and its `nextElement` will always throw a `NoSuchElementException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new BitSet methods in Java 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.util.BitSet` class gained several new methods with the latest release
    of Java. These are designed to simplify the manipulation of large sets of bits
    and provide easier access to information about bit location. Bit sets can be used
    for priority queues or compressed data structures. This recipe demonstrates some
    of the new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the new `BitSet` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of a `BitSet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute methods against the `BitSet` object as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application. In the `main` method, create an instance of
    a `BitSet` object. Then declare an array of long numbers and use the static `valueOf`
    method to set our `BitSet` object to the value of this long array. Add a `println`
    statement, so we see the way our long numbers are represented in the `BitSet:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `toLongArray` method to convert the `BitSet` back to an array
    of long numbers. Use a for loop to print out the values in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**{0, 64, 66, 68, 128, 129}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**21**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating our `BitSet` object, we created an array containing three `long`
    numbers, which serve as a representation of the sequence of bits that we wish
    to use in our `BitSet`. The `valueOf` method takes this representation and converts
    it to the sequence of bits.
  prefs: []
  type: TYPE_NORMAL
- en: When we printed out the `BitSet`, we saw the sequence {0, 64, 66, 68, 128, 129}.
    Each number in this `BitSet` represents the index of the bit that was set in our
    sequence of bits. For example, the 0 represents the `long` number 1 in our array,
    as the index of the bit used to represent the one was at position 0\. Likewise,
    bits 64, 66, and 68 were set to represent our `long` number 21\. The 128th and
    129th bits in the sequence were set to represent our `long` number 3\. We reversed
    the process in the next section, when we used the `toLongArray` method to return
    our `BitSet` to its original form.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used an array of `long` numbers. Similar `valueOf` methods
    exist for `byte, LongBuffer`, and `ByteBuffer` arrays. When using a `LongBuffer`
    or `ByteBuffer` array, the buffers are not modified by the `valueOf` method, and
    the `BitSet` cannot be converted back to the buffer. Instead, the `BitSet` must
    be converted by using the `toLongArray` method, or the similar `toByteArray` method
    that converts a `BitSet` into an array of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two new methods useful for locating a set or clearing bits in a `BitSet`.
    The method `previousSetBit` takes an integer representing a specific index as
    its argument and returns an integer representing the closest bit in the `BitSet`
    that is set. For example, add the following code sequence to our previous example
    (using `BitSet` represented by long numbers `{1, 21, 3}):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This would result in an output of integer 0\. This is because we passed an argument
    of index 1 to the `previousSetBit` method and the closest previous bit set in
    our `BitSet` was at index 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `previousClearBit` method operates in a similar fashion. If we were to
    execute the following code in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We would get output of integer 65\. The bit sitting at index 65 is the closest
    clear bit to our argument 66\. Both methods will return a -1 if no such bit exists
    in the `BitSet`.
  prefs: []
  type: TYPE_NORMAL
