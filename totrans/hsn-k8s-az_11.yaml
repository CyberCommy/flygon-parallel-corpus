- en: 8\. Connecting an app to an Azure database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we stored the state of our application in our cluster,
    either on a Redis cluster or on MariaDB. You might remember that both had some
    issues when it came to high availability. This chapter will take you through the
    process of connecting to a MySQL database managed by Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the benefits of using a hosted database versus running **StatefulSets**
    on Kubernetes itself. To create this hosted and managed database, we will make
    use of **Open Service Broker for Azure** (**OSBA**). OSBA is a way to create Azure
    resources, such as a managed MySQL database, from within a Kubernetes cluster.
    In this chapter, we will explain more details about the OSBA project and we will
    set up and configure OSBA on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We will then make use of OSBA to create a MySQL database in Azure. We will use
    this managed database as part of a WordPress application. This will show you how
    you can connect an application to a managed database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we will show you aspects of security, backup, **disaster recovery**
    (**DR**), authorization, and audit logging. The independent scaling of the database
    and the cluster will also be explored. We will break down the discussion of this
    chapter into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OSBA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending our app to connect to an Azure database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring advanced database operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing audit logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by setting up OSBA on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OSBA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will set up OSBA on our cluster. OSBA will allow us to create
    a MySQL database without leaving the Kubernetes cluster. We will start this section
    by explaining the benefits of using a hosted database versus running StatefulSets
    on Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using a managed database service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the examples that we have gone through so far have been self-contained,
    that is, everything ran inside the Kubernetes cluster. Almost any production application
    has state, which is generally stored in a database. While there is a great advantage
    to being mostly cloud-agnostic, this has a huge disadvantage when it comes to
    managing a stateful workload such as a database.
  prefs: []
  type: TYPE_NORMAL
- en: When you are running your own database on top of a Kubernetes cluster, you need
    to take care of scalability, security, high availability, disaster recovery, and
    backup. Managed database services offered by cloud providers can offload you or
    your team from having to execute these tasks. For example, Azure Database for
    MySQL comes with enterprise-grade security and compliance, built-in high availability,
    and automated backups. The service scales within seconds and can optionally very
    easily be configured for disaster recovery.
  prefs: []
  type: TYPE_NORMAL
- en: It is a lot simpler to consume a production-grade database from Azure than it
    is to set up and manage your own on Kubernetes. In the next section, we will explore
    a way that Kubernetes can be used to create these databases on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: What is OSBA?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will explore what OSBA is.
  prefs: []
  type: TYPE_NORMAL
- en: As with most applications these days, much of the hard work has already been
    done for us by the open-source community (including those who work for Microsoft).
    Microsoft has realized that many users would like to use their managed services
    from Kubernetes and that they require an easier way of using the same methodologies
    that are used for Kubernetes deployment. To aid in this effort, they have released
    Helm charts that use these managed services as a backend ([https://github.com/Azure/helm-charts](https://github.com/Azure/helm-charts)).
  prefs: []
  type: TYPE_NORMAL
- en: A key part of the architecture that allows you to create Azure resources from
    within Kubernetes is OSBA ([https://osba.sh/](https://osba.sh/)). OSBA is an **Open
    Service Broker** (**OSB**) implementation for Azure. The OSB API is a spec that
    defines a common language for platform providers that cloud-native applications
    can use to manage cloud services without lock-in.
  prefs: []
  type: TYPE_NORMAL
- en: The OSB API itself isn't Azure or Kubernetes specific. It is an industry effort
    to simplify the provisioning of resources through a standardized API. It allows
    you to connect to third-party services in a standardized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the OSB API with Kubernetes, an extension called the **Service Catalog**
    is run on the cluster. The Service Catalog will listen to the Kubernetes API for
    requests and will translate them to the OSB API to interface with the platform
    provider. This means that when you make a request for a database, the Kubernetes
    API will send that request to the Service Catalog, which in turn will use the
    OSB API to interface with the platform. *Figure 8.1* illustrates this logical
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user requests a database to the Kubernetes API. The Kubernetes API then
    forwards this request to the Service Catalog. The Service Catalog then creates
    a database using the OSB API on the platform.](image/Figure_8.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Logical flow of requesting a database using OSB on a Kubernetes
    cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: OSBA is an implementation of OSB for multiple Azure services. It allows a user
    to use the OSB API to create any of 14 supported Azure services. One of those
    services is Azure Database for MySQL. This means that you can define a MySQL database
    on Azure through OSBA without having to use the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will focus on how to install OSBA on our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OSBA on the cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will install OSBA on our cluster. There are two elements to this installation.
    First, we will install the Service Catalog extension on our cluster. After that,
    we can install OSBA on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will be installing multiple components on our cluster, our two-node cluster
    won''t suffice for this example. Let''s proactively scale our AKS cluster to three
    nodes so we don''t run into any issues during this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This scaling will take a couple of minutes. When the cluster is scaled out to
    three nodes, we can start with deploying the Service Catalog on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying the Service Catalog on the cluster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Service Catalog provides the catalog servers that are required for the
    OSB. To deploy the Service Catalog on the cluster, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deploy the Service Catalog by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the Service Catalog is deployed. You can check this by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Verify that both Pods in the deployment are `Running` and fully ready:![The
    output screen represents the successful Service Catalog deployment using the kubectl
    get all -n catalog command. You will see four types of objects created, namely
    a pod catalog, service catalog, deployment catalog, and replicasetcatalog.](image/Figure_8.2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.2: Successful Service Catalog deployment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To interface with the service broker, we need to install another CLI tool,
    namely `svcat`. We can do that with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We now have a Service Catalog configured on top of our cluster. Now, we can
    move on and install OSBA on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying OSBA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will deploy the actual OSBA on our cluster. For this setup,
    we need to obtain the subscription ID, tenant ID, client ID, and secrets for OSBA
    to launch Azure services on our behalf:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to obtain the required lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in *Figure 8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The screen displays the required list (the subscription ID and the tenant
    ID) using the az account list command.](image/Figure_8.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Output displaying the required list â€“ subscription ID and the tenant
    ID'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Copy your `subscription ID` along with the `tenant ID` and save it in an environment
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a service principal with RBAC enabled so that it can launch Azure services.
    If you are sharing your subscription with somebody else, make sure that the name
    of the service principal is unique in your directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an output as shown in *Figure 8.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output displays the service principal credentials such as AppID, DisplayName,
    Name, and the password using the az ad sp create-for-rbac --name osba-quickstart
    -o table command.](image/Figure_8.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Output displaying service principal credentials'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the previous step to complete successfully, you need to have the owner role
    on your Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the values from the command output in the environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can deploy OSBA as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that everything got deployed correctly, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until both Pods are in the `Running` state. If one of the Pods is in the
    `Error` state, you don''t have to be concerned. The OSBA Pods will automatically
    restart and should reach a healthy state. In our case, one of the Pods restarted
    three times, as shown in *Figure 8.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output will show the OSBA Pods with a status of Running using the kubectl
    get all -n osba command. Here, both the pods are in the Running state and one
    of the pods restarted three times.](image/Figure_8.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Output displaying OSBA Pods in the Running status'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To verify that our deployment was completely successful, we can use the `svcat`
    utility we downloaded in the previous section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you your Azure broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![You can view the Azure broker running in the cluster using the ./svcat get
    brokers command.](image/Figure_8.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Output displaying the Azure broker running in the cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can additionally also verify all the services you can deploy via the OSBA
    driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you a list of services that can be created using OSBA, as shown
    in *Figure 8.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A (cropped) list of the services can be obtained by using the ./svcat get
    classes command. Here, you can see the Name along with the description. The namespace
    column in between the Name and description column is blank.](image/Figure_8.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: A (cropped) list of the services that can be created using OSBA'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we set up the Service Catalog and OSBA on our cluster. This
    means we can now create managed services by Azure from our cluster. We will use
    this capability in the next section, when we deploy WordPress using an Azure-managed
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying WordPress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to deploy WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install WordPress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the status of the WordPress Pod, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show the status of a single WordPress Pod as displayed in *Figure
    8.8*. In our previous WordPress examples, we always had two Pods running, but
    we were able to offload the database functionality to Azure here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![This image shows that the wordpress deployment only creates a single pod.
    You will see the name of the pod and whetherit is in the Ready state. It also
    shows the status ofContainerCreating, the number of times it restarted, and the
    time taken to obtain this status.](image/Figure_8.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Output displaying only one WordPress Pod and no database on our
    cluster'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'While the WordPress Pod is being created, we can check on the status of the
    database as well. We can use two tools to get this status, either `svcat` or `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the output shown in *Figure 8.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the ./svcat get instances -n wordpress command you can get your MySQL
    instance. You will see the name, namespace, class, plan, and status.](image/Figure_8.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Output displaying the use of svcat to get our MySQL instance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can get a similar result by using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an output as shown in *Figure 8.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output represents the use of svcat to get our MySQL instance using the
    kubectl get serviceinstances -n wordpress command. You will see the name, class,
    plan, status and the age.](image/Figure_8.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Output displaying the use of kubectl to get our MySQL instance'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the outputs of each method are similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give the deployment a couple of minutes to complete. First, the database needs
    to be fully provisioned, and afterward, the WordPress Pod needs to enter the `Running`
    state. To verify everything is running correctly, check the status of the WordPress
    Pod and ensure it is `Running`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an output as shown in *Figure 8.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output displays an output showing the use of kubectl to get our MySQL
    instance using the kubectl get pods -n wordpress command. You will see the Status
    change to Running after a time frame.](image/Figure_8.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Output displaying the status of WordPress Pod'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have now deployed WordPress using an Azure-managed database. However, the
    connectivity to our database, by default, is open to the internet. We will change
    this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Securing MySQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many steps are automated for us, this doesn't mean our MySQL database
    is production-ready. For instance, the network settings for MySQL Server have
    a default rule that allows traffic from everywhere. We will change this to a more
    secure service endpoint rule, also called **VNet rules**.
  prefs: []
  type: TYPE_NORMAL
- en: A service endpoint in Azure is a security connection between the network (also
    called a VNet) you use for your deployment and the service it connects to. In
    the case of AKS and MySQL, this would make a secure connection between the VNet
    that AKS is deployed into and the MySQL service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure our MySQL database to use a service endpoint in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: To make this change, look for `mysql` in the Azure search bar:![Type mysql in
    the Azure search bar to find it.](image/Figure_8.12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.12: Searching for MySQL in the Azure search bar'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the MySQL blade, go to **Connection security** in the left-hand navigation:![In
    the MySQL blade, click on the connection security tab on the left-hand side.](image/Figure_8.13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.13: Clicking on Connection security'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a default rule that allows a connection to the database from any IP
    address. You can add the AKS VNet to the **VNet rules** section and delete the
    **AllowAll 0.0.0.0** rule, as shown in *Figure 8.14*:![In the Azure Database for
    MySQL servers, click on the connection security tab located on the left side of
    the screen. This will allow you to add the AKS VNet to the VNet rules section
    and delete the AllowAll rule.](image/Figure_8.14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.14: Adding your AKS VNet to the VNet rules section and deleting the
    AllowAll rule'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have reduced the attack surface tremendously by performing this simple change.
    We can now connect to our WordPress site.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the WordPress site
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can verify that your blog site is available and running by using `EXTERNAL_IP`,
    which is obtained by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate an output as shown *Figure 8.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The output displays the external IP of the service using the kubectl get
    service -n wordpress command.](image/Figure_8.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Output displaying the external IP of the service'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, open a web browser and go to `http://<EXTERNAL_IP>/`. You should see
    your brand new blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The screen will display the default look of the WordPress blog.](image/Figure_8.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.16: The final look of the WordPress blog'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we have launched a WordPress site that is backed by an Azure-managed
    database. We have also secured it by modifying the firewall. In the next section,
    we will go through the advantages of letting Azure manage your database.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring advanced database operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running your database as a managed service on top of Azure has many advantages.
    In this section, we'll explore those benefits. We will explore restoring from
    a backup, how you can set up disaster recovery, and how you can access audit logs
    to verify who made changes to your database.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by restoring our database from a backup.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring from a backup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you run a database within your Kubernetes cluster, **high availability**
    (**HA**), backups, and DR are your responsibilities. Let''s take some time to
    explain the differences between those three concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HA**: HA refers to local redundancy in a service to ensure that the service
    remains available in the event that a single component fails. This means setting
    up multiple replicas of a service and coordinating the state between them. In
    a database context, this means setting up a database cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure Database for MySQL service comes with HA built in. It offers, at the
    time of writing, an availability SLA of 99.99% per month.
  prefs: []
  type: TYPE_NORMAL
- en: '**Backups**: Backups refer to making historical copies of your data. Backups
    are useful when something unforeseen happens to your data, such as accidental
    data deletion or data being overwritten. If you run your own database, you need
    to set up `cron` jobs to take backups and store them separately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Database for MySQL handles backups automatically, without additional configuration.
    The service takes a backup every 5 minutes and makes it possible for you to restore
    to any point in time. Backups are retained by default for 7 days, with optional
    configuration making it possible to keep backups for up to 25 days.
  prefs: []
  type: TYPE_NORMAL
- en: '**DR**: DR refers to the ability of a system to recover from a disaster. This
    typically refers to the ability to recover from a full regional outage. If you
    run your own database, this would involve setting up a secondary database in a
    second region and replicating data to that database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of Azure Database for MySQL, it is easy to configure DR. The service
    makes it possible to set up a secondary managed database and replicate data from
    your primary region to the secondary region.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can refer to [https://docs.microsoft.com/azure/mysql/concepts-backup](https://docs.microsoft.com/azure/mysql/concepts-backup)
    to find up-to-date information on the backup frequency, replication, and restore
    options.
  prefs: []
  type: TYPE_NORMAL
- en: The terms HA, backup, and DR often get confused with each other. It is important
    to use the right terminology and for you to understand the difference between
    the three concepts. In this section, we'll focus on backups, and we'll perform
    a restore from our WordPress database. To demonstrate that the restore operation
    will restore user data, we will first create a blog post.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a blog post on WordPress**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a blog post to demonstrate that the restore operation will capture
    new data that we generate on the database. To be able to make this post, we need
    the admin credentials for our site. We will first get those credentials and then
    make a new post:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the admin credentials, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you the password to connect to your admin website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the command provided by Helm to get the password of the WordPress admin
    user.](image/Figure_8.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Getting the admin credentials'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now browse to `http://<EXTERNAL IP>/admin` to open the admin page for the WordPress
    site. Use the username `user` and the password from the previous step to log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once connected, select the **Write your first blog post** link:![On the dashboard,
    you will see a welcome message where you will find the "Write your first blog
    post"link located below the Next Steps title. Click on this link.](image/Figure_8.18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.18: Clicking the link to write a post'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a blog post. The content isn't important. Once you are happy with your
    blog post, select the **Publish** button to save and publish the blog post:![After
    typing the content on the blog, go to the Publish tab on the rightside of the
    window. Click on the Publish button under this tab to save and publish it.](image/Figure_8.19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.19: Creating a sample blog post and clicking the Publish button to
    save it'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can now connect to `http://<EXTERNAL IP>` to see your blog post:![On clicking
    on the Publish button, you will see a white screen with a message- this blog post
    will confirm backup and restore. This shows the successful status of the blog
    post.](image/Figure_8.20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.20: Note displaying the successful status of the blog post'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we have a blog post saved, please wait for at least 5 minutes. Azure
    takes a backup of the MySQL database every 5 minutes, and we want to make sure
    that our new data has been backed up. Once those 5 minutes have passed, we can
    continue to the next step and perform the actual restore.
  prefs: []
  type: TYPE_NORMAL
- en: '**Performing a restore**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have actual content on our blog and in the database. Let''s assume that
    during an update, the database was corrupted, and so we want to do a point-in-time
    restore:'
  prefs: []
  type: TYPE_NORMAL
- en: To start the restore operation, click on **Restore** in the MySQL blade in the
    Azure portal:![In the Azure Database for MySQL servers portal, you will see a
    Restore button atthe topof the screen. Click on it to initiate the restore process.](image/Figure_8.21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.21: Clicking the Restore button to initiate the restore process'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Then, you need to choose the point in time from which you want to perform the
    restore. This point in time can be the current time. Give the restored database
    a name, which must be unique as shown in *Figure 8.22*. Finally, click **OK**.
    After approximately 5 to 10 minutes, the MySQL service should be restored:![Upon
    clicking the Restore button, you will get a window in which you need to enter
    the date and time you want to perform the restore. Give the restored database
    a unique name and click on OK.](image/Figure_8.22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.22: Selecting the point in time to restore and clicking the OK button'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we restored our MySQL database. When the restore operation
    is complete, one step remains, which is to connect WordPress to the restored database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Connecting WordPress to the restored database**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The restore operation created a new instance of the database. To make our WordPress
    installation connect to the restored database, we need to modify the Kubernetes
    deployment files. Ideally, you will modify the Helm values file and perform a
    Helm upgrade; however, that is beyond the scope of this book. The following steps
    will help you connect WordPress to the restored database:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Azure portal, note down the **Server name**, as shown in *Figure 8..23*:![The
    screen shows the details of the restored database. Note down the server name given
    in the top-right corner of the portal.](image/Figure_8.23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.23: Displaying the full name of the restored database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Also, modify **Connection security**, as we did before, to allow the cluster
    to talk to the restored database. Remove the Allow All rule and add a VNet rule
    to the network of your AKS cluster. The result is shown in *Figure 8.24*:![In
    the Azure Database for MySQL servers, click on the connection security tab located
    in the navigation pane on the left side of the screen. When you edit the information,
    the screen will display a "No firewalls configured"message.](image/Figure_8.24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.24: Editing the connection security for the restored database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we need to connect our WordPress Pod to the new database. Let''s point
    out how that happens. To get that info, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the values to connect to the database are obtained from a
    secret, as shown in *Figure 8.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output displays a list of environment variables such as host, port number,
    database name, database user, and password. The values to connect the database
    to WordPress are obtained from a Secret.](image/Figure_8.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.25: Displaying the environment variables for the WordPress Pod'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'During the setup of WordPress, the installer will save this configuration in
    a file: `/bitname/wordpress/wp-config.php`. In the next steps, we''ll first edit
    the secret and then reconfigure `wp-config.php`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set secrets, we need the `base64` value. Obtain the `base64` value of the
    server name by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the `base64` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll go ahead and edit the hostname in the secret. To do this, we''ll
    use the `edit` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open up a `vi` editor. Navigate to the line that contains `host`
    and press the `I` button. Delete the current value for the host and paste in the
    new `base64` encoded value. Then hit *Esc*, type :`wq!`, and hit *Enter*. Your
    secret should look as shown in *Figure 8.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigate to the host line upon opening the vi editor. Delete the current
    value of the host and paste the base64-encoded value instead. This will change
    the secret.](image/Figure_8.26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.26: Editing the host line to contain the base64 encoded value of the
    new server name'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we''ll need to change this in the `wp-config.php` file as well. To do
    this, let''s `exec` into the current WordPress container and change that value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again open a `vi` editor. Navigate to line 32, which contains the
    `DB_HOST` config line. Hit `I` to enter insert mode, and delete the current value
    and replace that with the restored database''s name as shown in *Figure 8.27*.
    Then hit *Esc*, type :`wq!`, and hit *Enter*. Make sure to paste in the real value,
    not the `base64` encoded one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![In the vi editor, go to line 32,which contains the database hostname. Replace
    this name with the restored database''s name. This will generate an output screen
    with the name of a restored database.](image/Figure_8.27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.27: Changing the name of the database to the restored database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, exit out of the Pod with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have now reset the secret value and the config file, this doesn't
    mean that our server will automatically pick up the new value. We'll have to restart
    our Pod now to ensure the config is read in again.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to do this, and we are going to delete the existing Pod.
    Once this Pod is deleted, our `ReplicaSet` controller will pick up on this and
    create a new Pod. To delete the Pod, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After a couple of seconds, you should see a new Pod being created. It will
    take between 5 and 10 minutes for that new Pod to come online. Once it is online,
    you can watch the container logs from that Pod and verify that you are indeed
    connected to the new database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should contain a line as shown in *Figure 8.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The kubectl logs <new wordpress pod> -n wordpress command generates an output
    that displays logs of the WordPress Pod that is connected to the restored database.](image/Figure_8.28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.28: Logs displaying the WordPress Pod connected to the restored database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This shows us that we are now connected to our restored database. We can confirm
    that the actual content was restored. You can connect to the WordPress site itself
    by browsing to `http://<EXTERNAL IP>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![On clicking connecting to the WordPress site, you will see a white screen
    with a message saying this blog post will confirm backup and restore. This shows
    the successful restoration of the blog post.](image/Figure_8.29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.29: Note displaying the successful restoration of the blog post'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we explored the backup and restore capabilities of Azure Database
    for MySQL. We published a blog post and restored the database where this blog
    post was stored. We connected our WordPress instance to the restored database
    and were able to verify that the blog post was successfully restored.
  prefs: []
  type: TYPE_NORMAL
- en: Performing backups is just one of the capabilities of Azure Database for MySQL.
    In the next section, we will explore the DR capabilities of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Disaster Recovery (DR) options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on your application requirements and DR needs, you can add replicas
    to your MySQL server. Replicas can be created either in the same region to improve
    read performance or in a secondary region.
  prefs: []
  type: TYPE_NORMAL
- en: If you are preparing for a DR scenario, you will need to set up a replica in
    a secondary region. This will protect you from regional Azure outages. When you
    set this up, Azure will asynchronously replicate data from the master server to
    the replica server you set up. While replication is ongoing, the replica server
    can be used to read from, but cannot be used to write to. If a disaster occurs,
    meaning an Azure region has a regional outage, you would need to stop replication
    to turn the replica server into a server capable of serving both read and write
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very straightforward to create a replica in a new region. Although setting
    up and testing replication is out of the scope of this book, we will show how
    this can be set up. To configure replication, you need to open the **Replication**
    tab in the MySQL blade, as shown in *Figure 8.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![To create a replica via the Azure portal, click on the Replication tab in
    the MySQL blade on the left side of the navigation pane. No results are shown
    for the replicas. On the right side of the screen enter the server name and the
    location. This will show you the monthly cost.](image/Figure_8.30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.30: Creating a replica via the Azure portal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A full list of backup, restore, and replication options are documented at [https://docs.microsoft.com/azure/mysql/concepts-backup](https://docs.microsoft.com/azure/mysql/concepts-backup)
    and [https://docs.microsoft.com/azure/mysql/concepts-read-replicas](https://docs.microsoft.com/azure/mysql/concepts-read-replicas).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we described the capability of Azure Database for MySQL to
    replicate to a secondary region. This replica can be used to build a DR strategy
    for your database. In the next section, we will cover how the activity log can
    be used to audit who has made changes to your server.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing audit logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A database contains business-critical data. You will want to have a logging
    system in place that can show you who has made changes to your database.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the database on the Kubernetes cluster, it is difficult to get
    audit logs if something goes wrong. You need a robust way of dynamically setting
    the audit level depending on the scenario. You also have to ensure that the logs
    are shipped outside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure Database for MySQL service solves the preceding issues by providing
    a robust auditing mechanism via the Azure portal. The service has two different
    views into logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity logs**: The activity logs show you all the changes that happened
    to the Azure object of your database. Azure records all create, update, and delete
    transactions against Azure resources, and keeps those logs for 90 days. In the
    case of MySQL, this means all changes to the size, to the backup and replication
    settings, and so on. These logs are useful to determine who made changes to your
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server logs**: The server logs include logs from the actual data in your
    database. MySQL has multiple logs available that can be configured. It is typically
    recommended to turn on audit logging to verify who has accessed your database
    and to turn on slow query monitoring to track any queries that are running slowly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at both logs:'
  prefs: []
  type: TYPE_NORMAL
- en: To access the activity logs, open the MySQL database blade in the Azure portal.
    In the left-hand navigation, look for **Activity log**. This will open the activity
    log view, as in *Figure 8.31*:![Click on the Activity logs tab located in the
    leftpane of the Azure portal. You will see the actions taken against the respective
    Azure databases.](image/Figure_8.31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.31: Azure activity logs showing the actions taken against the Azure
    database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Activity log provides very valuable information in retracing the activities
    that have been performed. You should find events in the activity log that point
    to the changes you made earlier to the connection security settings.
  prefs: []
  type: TYPE_NORMAL
- en: Server logs can be obtained by looking for **Server logs** in the left-hand
    navigation. Server logs aren't turned on by default, as can be seen in *Figure
    8.32*:![If you click on the server logs tab in the navigation pane on the leftside
    of the Azure portal, it will indicate that there are no server logs by default.](image/Figure_8.32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.32: Navigation displaying no sever logs by default'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's turn on the server logs. We will enable the audit log and monitoring for
    performance issues by enabling the `log_slow...` statements and `slow_query_log`,
    as shown in *Figure 8.33*:![Once the server parameters page opens, click on the
    parameters with names such as log_slow... statement and slow_query_log. Ensure
    that their values are ON.](image/Figure_8.33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 8.33: Enabling the audit log and slow query logging'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once you have turned on these logs, it will take a couple of minutes for the
    actual logs to show up. After a couple of minutes, you should see the logs in
    the **Server logs** tab in the Azure portal as shown in *Figure 8.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![After a couple of minutes you can view the actual logs by clicking on the
    server logs tab in the navigation pane on the leftside of the MySQL blade.](image/Figure_8.34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.34: Displaying the Server logs in the Azure portal'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s make sure to again clean up after our deployment and scale our cluster
    back down to two nodes. Scaling down to two nodes will make sure you save costs
    on your Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we covered the two types of logs that Azure generates for a
    MySQL database. We looked into the activity log to see which actions have been
    taken against the Azure database, and we turned on server logs to get insights
    into what happened inside the database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter focused on working with a WordPress sample solution that leverages
    a MySQL database as a data store. We started by showing you how to set up the
    cluster to connect the MySQL database by installing Open Service Broker for Azure.
    We then showed you how to set up a MySQL database and drastically minimize the
    attack surface by changing the default configuration to not allow public access
    to the database. Then, we discussed how to restore the database from a backup
    and how to leverage the solution for DR. Finally, we discussed how to configure
    the audit logs for troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement microservices on AKS, including
    by using Event Hubs for loosely coupled integration between applications.
  prefs: []
  type: TYPE_NORMAL
