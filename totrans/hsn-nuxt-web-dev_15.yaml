- en: Writing Route Middlewares and Server Middlewares
  prefs: []
  type: TYPE_NORMAL
- en: Remember when you created a middleware on the server side using Koa in [Chapter
    8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding a Server-Side Framework*?
    Middlewares are both useful and powerful, as you will have noted in cascading
    with Koa apps, where you can predict and control the flow of your entire app sequentially.
    So, what about in Nuxt? Well, there are two types of middleware we should explore
    in Nuxt: route middleware and server middleware. In this chapter, you will learn
    how to differentiate between them and create some basic middlewares before moving
    on to the next chapter on authentication, where middlewares are very much needed. We
    will also use middlewares in the chapters after the next one. So, in this chapter,
    just like in many of the previous chapters, you will create some middlewares in
    a Vue app with navigation guards so that you can grasp the middleware mechanism
    in the Vue/Nuxt system before creating the route middlewares and server middlewares in
    a Nuxt app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing middlewares with Vue Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Vue CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing route middlewares in Nuxt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Nuxt server middlewares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing middlewares with Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before learning how middleware works in a Nuxt app, we should understand how
    it works in a standard Vue app. Additionally, before creating middlewares in the
    Vue app, let's first understand what they are.
  prefs: []
  type: TYPE_NORMAL
- en: What is middleware?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put simply, a middleware is a software layer situated between two or more pieces
    of software. This is an old concept in software development. Middleware is a term
    that has been in use since 1968\. It gained popularity in the 1980s as a solution
    to the problem of how to link newer apps to older legacy systems. There are many
    definitions for it, such as (from *Google Dictionary*) "[middleware is a] software
    that acts as a bridge between an operating system or database and apps, especially
    on a network."
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web development world, server-side software or apps, such as Koa and
    Express, take in a request and output a response. The middlewares are programs
    or functions that are executed in the middle after the incoming request, and they
    produce an output that could either be the final output or be used by the next
    middleware until the cycle is completed. This also means that we can have **more**
    than one middleware, and they will execute in the order they are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cda0dfde-bb0a-4fe4-9a36-ebc285e49a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Furthermore, middleware is not only limited to server-side technologies. It
    is also very common on the client side when you have routing in your app. Vue
    Router by Vue.js is a good example of using this middleware concept. We have studied
    and used Vue Router already in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),* Adding
    Views, Routes, and Transitions*, to create the router for our Vue apps. Now, let's
    dive deeper into the advanced usage of Vue Router – navigation guards.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have followed the chapters of this book from the beginning, you should
    already know how to install Vue Router from [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*. However, here is a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to download Vue Router directly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the following link and download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the router after Vue so that it can be installed automatically by itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can install Vue Router via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the router to your project using npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the router explicitly using the `use` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the router in place, you can start creating middlewares using
    the navigation guards that come with Vue Router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` navigation guard in the preceding example is a global navigation
    guard that is called when navigating to any route. Apart from global guards, there
    are navigation guards for specific routes too, and that is what we are going to
    explore in more detail in the next section. So, let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more information about Vue Router, please visit [https://router.vuejs.org/](https://router.vuejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Using navigation guards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigation guards are used to guard the navigation in your app. These guards
    allow us to call functions before entering, updating, and leaving a route. When
    certain conditions are not met, they can either redirect or cancel the route.
    There are several ways in which to hook into the route navigation process: globally,
    per-route, or in-component. Let''s explore the global guard in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can find all of the following examples in `/chapter-11/vue/non-sfc/`
    from our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating global guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two global guards offered by Vue Router – global before guards and
    global after guards. Let''s learn how to use them before applying them to our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global before guards**: Global before guards are called when a route is being
    entered. They are called in a specific order and can be asynchronous. The navigation
    is always in wait until all the guards are resolved. We can register these guards
    using the `beforeEach` method from Vue Router, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Global after guards**: Global after guards are called after a route has been
    entered. Unlike global before guards, global after guards do not have the `next`
    function, and so they do not affect navigation. We can register these guards using
    the `afterEach` method from Vue Router, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a Vue app with a simple HTML page and use these guards in the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two routes with the `<router-link>` elements, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the components (`Page1` and `Page2`) for the routes, and pass them to
    the router instance in the `<script>` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the global before guard and the global after guard **after** the route
    instance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount the root instance after the guards and run our app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when you switch between the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Global guards can be useful when you want to apply something common to all routes. However,
    sometimes, we need something specific for certain routes only. For this, you should
    use per-route guards. Let's learn how to deploy them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating per-route guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create per-route guards by using `beforeEnter` as a method or property directly
    on the configuration object of a route. For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s duplicate our previous Vue app and change the configuration of the routes
    to use these per-route guards, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should get the `before entering page 1` log on your browser's console when
    you navigate to `/page1` and the `before entering page 2` log when you are on
    `/page2`. So, since we can apply a guard to the route of a page, what about applying
    guards to the route component itself? The answer is yes, we can. Let's move on
    to the next section and learn how to use in-component guards to guard a specific
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating in-component guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the following methods individually or together inside a route component to
    create the navigation guards for a specific component.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** **beforeRouteEnter guard**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like in the global before guard and the `beforeEnter` per-route guard,
    the `beforeRouteEnter` guard is called before the route renders the component,
    but it is applied to the component itself. We can register this type of guard
    using the `beforeRouteEnter` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because it is called before the component instance, it does not have access
    to the Vue component via the `this` keyword. But this can be resolved by passing
    a callback of the Vue component to the `next` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**The beforeRouteLeave guard**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In comparison, the `beforeRouteLeave` guard is called when the component that
    is rendered by the route is about to navigate away from it. Since it is called
    when the Vue component is rendered, it can access the Vue component via the `this`
    keyword. We can register this type of guard using the `beforeRouteLeave` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, this type of guard is best used to prevent the user from leaving the
    route accidentally. So, the navigation can be canceled by calling `next(false)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**The beforeRouteUpdate guard**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `beforeRouteUpdate` guard is called when the component that is rendered
    by the route has changed but the component is reused in the new route; for example,
    if you have subroute components that use the same route component: `/page1/foo`
    and `/page1/bar`. So, navigating from `/page1/foo` to `/page1/bar` will trigger
    this method. And since it is called when the component is rendered, it has access
    to the Vue component via the `this` keyword. We can register this type of guard
    using the `beforeRouteUpdate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `beforeRouteEnter` method is the only guard that supports a callback
    in the `next` method. The Vue component is already available before calling the
    `beforeRouteUpdate` and `beforeRouteLeave` methods. Therefore, using a callback
    in the `next` method in either of them is unsupported because it is unnecessary.
    So, just use the `this` keyword if you want to access the Vue component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a Vue app with a simple HTML page using the following guards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a page component with the `beforeRouteEnter`, `beforeRouteUpdate`, and
    `beforeRouteLeave` methods all together, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another page component with just the `beforeRouteEnter` and `beforeRouteLeave`
    methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the main routes and the subroute before initiating the router instance,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the navigation links with the `<router-link>` Vue component, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when switching between the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When navigating from `/` to `/page1`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating from `/page1` to `/page2`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating from `/page2` to `/page1/foo`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating from `/page1/foo` to `/page1/bar`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating from `/page1/bar` to `/`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the navigation guards in Vue are simply JavaScript functions
    that allow us to create middlewares with some default arguments. Now, let's take
    a closer look at the arguments (`to`, `from`, and `next`) that each guard method
    gets in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the navigation guard arguments: to, from, and next'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already seen these arguments in the navigation guards used in the previous
    sections, but we haven't walked you through them yet. All guards, except the `afterEach`
    global guard, use these three arguments: `to`, `from`, and `next`.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `to` **argument**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument is the route object that you navigate to (hence, it is called
    the *to* argument). This object holds the parsed information of the URL and the
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '| namemetapathhash | queryparamsfullPathmatched |'
  prefs: []
  type: TYPE_TB
- en: If you want to know more about each of these object properties, please visit
    [https://router.vuejs.org/api/the-route-object](https://router.vuejs.org/api/#the-route-object).
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `from` **argument**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument is the current route object that you navigate from. Again, this
    object holds the parsed information of the URL and the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '| namemetapathhash | queryparamsfullPathmatched |'
  prefs: []
  type: TYPE_TB
- en: '**The** `next` **argument**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This argument is a function you must call to move on to the next guard (middleware)
    in the queue. If you want to abort the current navigation, you can pass a `false` Boolean to
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to redirect to a different location, you can use the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to abort the navigation with an instance of `Error`, you can use
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can catch the error from the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a Vue app with a simple HTML page and experiment with the
    next function in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following page components with the `beforeRouteEnter` method, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we pass the `Error` instance to the next function for
    `Page1` while redirecting the route to the home page for `Page2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the routes before initiating the router instance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an instance of the router and *listen* to the error using the `onError`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following navigation links with the `<router-link>` Vue component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app in your browser, and you should get the following logs in the browser
    console when switching between the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When navigating from `/` to `/page1`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When navigating from `/page1` to `/page2`, you should see the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also notice that you are directed to `/` when navigating from `/page1`
    to `/page2` because of this line of code: `next({ path: ''/'' })`.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created middlewares in a single HTML page. However, in a real-life
    project, we should try creating them with the Vue Single-File Component (SFC)
    that you learned about in previous chapters. So, in the next section, you will
    learn to create middlewares in the Vue SFC with Vue CLI, as opposed to the custom
    webpack build process that you have learned so far. So, let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Vue CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used webpack to create our custom Vue SFC apps in [Chapter 5](099c1dc8-8dfa-46f8-bfbd-bfa036eefbb7.xhtml),
    *Adding Vue Components.* As a developer, it is useful to know how to peer into
    the mechanism of a complex thing, and we must also understand how to use common
    and standard patterns to work with others collaboratively. Therefore, these days,
    we are inclined to use frameworks. Vue CLI is the standard tooling for Vue app
    development. It does what our webpack custom tool does and more. If you don't
    want to create your own Vue SFC developing tool, Vue CLI is a great choice. It
    supports Babel, ESLint, TypeScript, PostCSS, PWA, unit testing, and end-to-end
    testing out of the box. To read more about Vue CLI, please visit [https://cli.vuejs.org/](https://cli.vuejs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is very easy to get started with Vue CLI. Perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use npm to install it globally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a project when you want to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted to pick a preset – `default` or `manually select features`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Choose the `default` preset as we can install what we need manually later on.
    You should see something similar to the last part of the following output in your
    terminal when the installation is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your directory to `my-project` and start the development process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we are going to transform the navigation guards that
    you learned about in the previous sections into proper middlewares using Vue CLI.
    That means we will separate all of the hooks and guards into separate `.js` files
    and keep them in a common folder called `middlewares`. However, before we do that,
    we should first understand the project directory structure that Vue CLI generates
    for us and then add our own required directories. Let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Vue CLI's project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating the project with Vue CLI, if you take a look inside the project
    directory, you''ll see that it provides us with a barebones structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'From this basic structure, we can build and grow our app. So, let''s develop
    our app in the `/src/` directory and add the following directories to it using
    a router file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create two route components, login and secured, as SFC pages, and make
    the secured page a 403 protected page, which will require the user to log in to
    provide their name and age to access the page. The following are the files and
    the structure inside the `/src/` directory that we will need for this simple Vue
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We now have an idea of what directories and files we need for our app. Next,
    we will move on to writing the code for these files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing middlewares and a Vuex store with Vue CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you take a look at `package.json`, you will see that the default dependencies
    that come with Vue CLI are very basic and minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we will install our project dependencies and write the code we need in
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the following packages via npm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that Vue does not support multiple guards per route. So, if you want to
    create more than one guard for a route, Vue Router Multiguard allows you to do
    this. For more information about this package, please visit [https://github.com/atanas-dev/vue-router-multiguard](https://github.com/atanas-dev/vue-router-multiguard).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the state, actions, and mutations to store the authenticated user details
    in the Vuex store so that these details can be accessed by any component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of readability and simplicity, we will separate the store''s actions
    into a separate file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also separate the store''s mutations into a separate file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a middleware to ensure the user has logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another middleware to ensure the user is over 18 years old:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Import these two middlewares in the secured route by using `vue-router-multiguard`
    to insert multiple middlewares in `beforeEnter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a client-side authentication with a simple login page. Here are the
    basic input fields we need for the `login` and `logout` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Complete the preceding `login` and `logout` methods by dispatching the `login`
    and `logout` action methods in the `try` and `catch` blocks, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the completed login component into the login route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that we name this route `login` because we will need this name later to
    redirect the navigation route when we get the authentication error from the preceding
    middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `login` and `secured` routes to the index route, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the preceding index route into the Vue Router instance and catch the
    route errors using `router.onError`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this step, we use `router.onError` to handle the `Error` object that passed
    from the middlewares, and `router.push` to redirect the navigation route to the
    login page when the authentication conditions are not met. The name of the object
    must be the same as the login route in *step 7*, which is *login*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the router and store it in the `main` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project with `npm run serve`, and you should see that the app is loaded
    at `localhost:8080`. If you type a name and a number less than 18 into the input
    fields on the home page and then click on the login button, you should get an
    alert saying that "You must be over 18" when trying to access the secured page.
    On the other hand, if you type in a number higher than 18, you should see the
    name and the number on the secured page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can find the entire code for this app in `/chapter-11/vue/vue-cli/basic/`
    from our GitHub repository. You can also find the app with the custom webpack
    in `/chapter-11/vue/webpack/`.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have managed to get through all of the sections on middleware
    for Vue projects. Now, let's apply what you have just learned about Nuxt projects
    in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing route middlewares in Nuxt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, once we understand how middleware works in Vue, it will then be easier
    to work with it in Nuxt as Nuxt has taken care of Vue Router for us. In the coming
    sections, we will learn how to work with global and per-route middlewares for
    Nuxt apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Nuxt, all middleware should be kept in the `/middleware/` directory, and
    the middleware filename will be the name of the middleware. For example, `/middleware/user.js`
    is the user middleware. A middleware gets the Nuxt context as its first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, middleware can be asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In universal mode, middlewares are called on the server side once (for example,
    when first requesting the Nuxt app or when refreshing a page) and then on the
    client side when navigating to other routes. On the other hand, middlewares are
    always called on the client side whether you are requesting the app for the first
    time or when you are navigating to further routes after the first request. Middlewares
    are executed in the Nuxt configuration file first, then in layouts, and, finally,
    in pages. We will now start writing some global middlewares in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing global middlewares
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding global middlewares is very straightforward; you just have to declare
    them in the `middleware` key in the `router` option of the `config` file. For
    example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some global middleware in the following steps. In this exercise,
    we want to to get the information of the user agent from the HTTP request header
    and to track the routes the user is navigating to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two middlewares in the `/middleware/` directory, one for obtaining the
    user agent information and the other for obtaining the route path information
    that the user is navigating to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the preceding middlewares in the `middleware` key in the `router` option,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in Nuxt, we do not need a third-party package like we do in the Vue
    app to call multiple guards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the store''s state and mutations for storing the visited route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `user-agent` middleware in the `about` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `visits` middleware, we want to use it on a component and then inject
    this component into our layout, that is, the `default.vue` layout. First, create
    the `visits` component in the `/components/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: So, we have created two filters in this component. The `date` filter is used
    to obtain the date from a string. For example, we will get `2019-05-24` from `2019-05-24T21:55:44.673Z`. In
    comparison, the `time` filter is used to obtain the time from a string. For example,
    we will get `21:55:44` from `2019-05-24T21:55:44.673Z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `visits` component into our layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following results in our browser when we navigate around
    the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we should get the information of the user agent from the request
    headers when you are on the about page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/route-middleware/global/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: That's all for global middleware. Now, let's move on to per-route middlewares in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing per-route middlewares
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding per-route middlewares is also very straightforward; you just have to
    declare them in the `middleware` key in the specific layout or page. For example,
    take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: So, let's create some per-route middlewares in the following steps. In this
    exercise, we will use sessions and JSON Web Tokens (JWTs) to access restricted
    pages or a secured API. Although in real life, we can either just use a session
    or a token for an authentication system, we will use both for our exercise so
    that we know how to use them together for potentially more complex production
    systems. In our exercise, we will want the user to log in and get the token from
    the server. The user will be not able to access the secured routes when the token
    is expired or invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the user will be logged out when the session time is over:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `auth` middleware to check whether the state in our store has any
    data. If there is no authenticated data, then we use the `error` function in the
    Nuxt context to send the error to the front:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `token` middleware to ensure the token is in the store; otherwise,
    it sends the error to the front. If the token is present in the store, we set
    `Authorization` with the token to the default `axios` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Add these two preceding middlewares to the `middleware` key on the secured
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: After setting the `Authorization` header with the JWT in the headers, we can
    access the secured API routes, which are guarded by a server-side middleware (we
    will learn more about this in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*). We will get the data from the
    secured API route that we want to access and will be prompted with the error message
    if the token is incorrect or has expired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the store''s state, mutations, and actions in the `/store/` directory
    to store the authenticated data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A known and expected behavior is that, when the​ page is refreshed, the state
    of the store is reset to default. There are a few solutions that we can use if
    we want to persist in the state:'
  prefs: []
  type: TYPE_NORMAL
- en: localStorage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sessionStorage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: vuex-persistedstate (a Vuex plugin)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, however, since we use the session to store the authenticated information,
    we can actually retrace our data from the session via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: req.ctx.session (Koa) or req.session (Express)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: req.headers.cookie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have decided which solution or option we want to go for (let''s say
    `req.headers.cookie`), then we can refill the state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/route-middleware/per-route/` in
    our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: When all the preceding steps are followed and the middlewares are created, we
    can run this simple authentication app with `npm run dev` to see how it works.
    We will get to server-side authentication in the next chapter. Right now, we just
    have to focus on the middleware and understand how it works, which will help us
    in the next chapter. Now, let's move on to the final part of this chapter – server
    middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Nuxt server middlewares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Put simply, server middlewares are server-side apps that are used as middlewares
    in Nuxt. We have been running our Nuxt apps under a server-side framework such
    as Koa since [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*. If you are using Express, this is the `scripts` object in
    your `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In this npm script, the `dev` and `start` scripts instruct the server to run
    your app from `/server/index.js`. This might not be ideal as we have coupled Nuxt
    and the server-side framework tightly, and it results in extra work in the configuration.
    However, we can tell Nuxt not to attach to the server-side framework''s configurations
    in `/server/index.js` and keep our original Nuxt run scripts as they are shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'On the contrary, we can have the server-side framework running under Nuxt instead,
    by using the `serverMiddleware` property in the Nuxt configuration file. For example,
    take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Unlike route middlewares, which are called before each route on the client side,
    server middlewares are always called on the server side before `vue-server-renderer`.
    Therefore, server middlewares can be used for server-specific tasks, just like
    we did with Koa or Express in previous chapters. So, let's explore how to use
    Express and Koa as our server middleware in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Using Express as Nuxt's server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple authentication app using Express as Nuxt''s server middleware.
    We will be still using the client-side code from the authentication exercise along
    with the per-route middlewares that you learned about in the preceding section,
    where the user is required to provide a username and password to access a secured page.
    Additionally, we will be using a Vuex store to centralize the authenticated user
    data just like before. The major difference in this exercise is that our Nuxt
    app will be *moved out* of the server-side app as a middleware, and, instead,
    the server-side app will be *moved into* the Nuxt app as middleware. So, let''s
    get started by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `cookie-session` and `body-parser` as server middlewares, and add the
    path of our API after them in the Nuxt `config` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note that cookie-session is a cookie-based session middleware for Express that
    stores the session in a cookie on the client side. In comparison, body-parser
    is a body-parsing middleware for Express, just like the `koa-bodyparser` for Koa
    that you learned about in [Chapter 8](1d20b423-d93c-454a-91b5-f7207e1988fb.xhtml), *Adding
    a Server-Side Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `cookie-session` and `body-parser` for Express, please
    visit [https://github.com/expressjs/cookie-session](https://github.com/expressjs/cookie-session)
    and [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `/api/` directory using an `index.js` file, in which Express is imported
    and exported as another server middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Run the app using `npm run dev`, and you should get the "Hello World!" message
    in `localhost:3000/api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `login` and `logout` post methods in `/api/index.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we store the authenticated payload to the Express session
    as `auth` in the HTTP request object when the user has logged in successfully.
    Then, we will clear the `auth` session by deleting it when the user has logged
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a store with `state.js` and `mutations.js`, just like you did for writing
    a per-route middleware, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with writing per-route middleware, create the `login` and `logout`
    action methods in the `actions.js` file in the store, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `nuxtServerInit` action to `index.js` in the store to repopulate the
    state from the Express session in the HTTP request object when refreshing pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, just like in per-route middleware authentication, create a login page
    in the `/pages/` directory with a form. Use the same `login` and `logout` methods
    you did before to dispatch the `login` and `logout` action methods in the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Run the app with `npm run dev`. You should have an authentication app that works
    just like before, but it is no longer running from `/server/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the preceding source code in `/chapter-11/nuxt-universal/server-middleware/express/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `serverMiddleware` property allows our Nuxt app to look neat and feel
    light again by freeing it from the server-side app, don't you think? With this
    approach, we can make it more flexible too, as we can use any server-side framework
    or app. For example, instead of using Express, we can use Koa, which we will look
    at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Koa as Nuxt's server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like Koa and Express, Connect is a simple framework that is used to glue
    together various middlewares for handling HTTP requests. Nuxt internally uses
    Connect as a server, so most Express middleware works with Nuxt''s server middleware.
    In comparison, it is a bit harder for Koa middleware to work as Nuxt''s server
    middleware because the `req` and `res` objects are *tucked away* and kept inside
    `ctx` in Koa. We can compare these three frameworks with a simple "Hello World"
    message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `req` is a Node.js HTTP request object, while `res` is a Node.js
    HTTP response object. They can be named anything you like, for example, *request*
    instead of *req* and *response* instead of *res*. From the preceding comparisons,
    you can see how Koa handles these two objects differently from the other frameworks. So,
    we can''t use Koa as Nuxt''s server middleware like in Express, and we can''t
    define any Koa middleware in the `serverMiddleware` property but just add the
    path of the directory where the Koa API is kept. Rest assured, it is not difficult
    to get them working as middleware in our Nuxt app. Let''s proceed with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the path where we want to create our API with Koa, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `koa` and `koa-router`, create a `Hello World!` message with the router,
    and then export them to the `index.js` file inside the `/api/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `koa-bodyparser` and `koa-session`, and register them as middlewares
    in the Koa instance in the `/api/index.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `login` and `logout` routes using the Koa router, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, just like in the Express example in the previous section,
    we store the authenticated payload to the Koa session as `auth` in the Koa context
    object when the user has logged in successfully. Then, we will clear the `auth` session
    by setting the session to `null` when the user has logged out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a store with the state, mutations, and actions just like you did in
    the Express example. Additionally, create `nuxtServerInit` in the `index.js` file
    in the store just like you did when writing per-route middlewares:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like before, create the form `login` and `logout` methods in the `/pages/`
    directory to dispatch the action methods from the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Run the app with `npm run dev`. You should have an authentication app that works
    just like the one in Express in the previous section, but it is no longer running
    from `/server/index.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the entire source code for this example in `/chapter-11/nuxt-universal/server-middleware/koa/`
    in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your preference, you can use Express or Koa as Nuxt's server middleware
    in your next project. In this book, we mostly use Koa for its simplicity. You
    even can create custom server middleware without needing either of them. Let's
    take a look at how to create custom server middleware in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom server middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Nuxt internally uses Connect as the server, we can add our custom middlewares
    without the need for an external server such as Koa or Express. You can develop
    a complex Nuxt server middleware just like we did with Koa and Express in the
    previous sections. However, let''s not endlessly repeat what we have already done.
    Let''s create a very basic custom middleware that prints a "Hello World" message
    to confirm the feasibility of building a complex one from a basic middleware in
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the path where we want to create our custom middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the API routes to the `index.js` file inside the `/api/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Run the app with `npm run dev` and navigate to `localhost:3000/api`. You should
    see the "Hello World!" message printed on your screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can refer to the Connect documentation at [https://github.com/senchalabs/connect](https://github.com/senchalabs/connect)
    for more information. Additionally, you can find the source code for this example
    in `/chapter-11/nuxt-universal/server-middleware/custom/` in our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You have managed to get through another big chapter on Nuxt. Before
    moving on to the next chapter, let's summarize what you have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the distinction between route middleware and server
    middleware. You used navigation guards from Vue Router to create middlewares for
    Vue apps. You also used Vue CLI to develop a simple Vue authentication app. Taking
    what you learned about Vue apps, you implemented the same concept (of route middleware)
    in Nuxt apps with global and per-route middlewares. After that, you managed to
    learn about Nuxt's server middleware and how to use Express and Koa as server
    middlewares. Middlewares are important and useful, especially for authentication
    and security. We have already made a few authentication apps, and we are going
    to study and understand them in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn, in detail, about developing user logins
    and authentication APIs to improve the authentication apps that you have created
    in this chapter. We will walk you through session-based authentication and token-based
    authentication. While you have created an authentication app using these two technologies,
    we haven't explained what they are yet. But rest assured, you will understand
    them better in the next chapter. Besides this, you will learn how to create backend
    and frontend authentication and signing in with Google OAuth for your Nuxt app.
    So, stay tuned!
  prefs: []
  type: TYPE_NORMAL
