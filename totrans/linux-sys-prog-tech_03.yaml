- en: '*Chapter 3*: Diving Deep into C in Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to take an in-depth look at C programming in Linux. Here, we will
    learn more about the **compiler**, the four stages from source code to **binary
    program**, how to use the **Make** tool, and differences between system calls
    and standard library functions. We will also take a look at some essential header
    files when it comes to Linux, and look at some **C** and **Portable Operating
    System Interface** (**POSIX**) **standards**. C is tightly integrated with Linux,
    and mastering C will help you understand Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop both programs and libraries for Linux. We will
    also write both a generic **Makefile** and more advanced ones for more significant
    projects. While doing this, we will also learn about the different **C standards**,
    why they matter, and how they affect your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Linking against libraries using the **GNU Compiler Collection** (**GCC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing C standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using system calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sand when not to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information about Linux- and Unix-specific header files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining feature test macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the four stages of compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling with Make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a generic Makefile with GCC options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a simple Makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a more advanced Makefile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will need the Make tool and the GCC compiler, preferably
    installed via the meta-package or group install mentioned in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: All source code for this chapter is available at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3sElIvu](https://bit.ly/3sElIvu)'
  prefs: []
  type: TYPE_NORMAL
- en: Linking against libraries using GCC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to link a program to an external **library**,
    both one that's installed system-wide and one that resides in our home directory.
    Before we can link to a library, however, we need to create it. This is also something
    that we are going to cover in this recipe. Knowing how to link against libraries
    will enable you to make use of a wide variety of ready-to-use functions. Instead
    of writing everything by yourself, you can use libraries that are already available.
    Often, there is no need to reinvent the wheel, thus saving you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need what's listed under the *Technical requirements*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will learn how to link against both a **shared library** installed
    on your system and a library from your home directory. We will begin with a library
    already on your system: the **math library**.'
  prefs: []
  type: TYPE_NORMAL
- en: Linking against the math library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will make a small program that calculates the compound interest on
    a bank account. For this, we need the `pow()` function, which is included in the
    math library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it in a file called `interest.c`. Note that
    we include `math.h` at the top. The `pow()` function''s first argument is the
    base; the second argument is the exponent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile and `-l`, and the name of the library is `m` (see the `man 3 pow`
    manual page for more information):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s try the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating our own library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we'll create our very own shared library. In the next section of this
    recipe, we'll link a program to this library. The library we are creating here
    is used to find out if a number is a prime number or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with creating a simple header file. This file will only contain
    a single line—the function prototype. Write the following content in a file and
    name it `prime.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to write the actual function that will be included in the library.
    Write the following code in a file and save it as `primc.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to convert this to a library somehow. The first step is to compile
    it into something that''s called an object file. We also need to parse some extra
    arguments to the compiler to make it work in a library. More specifically, we
    need to make it `prime.o`, which we''ll see with the `ls -l` command. We''ll learn
    more about object files later in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must package the object file as a library. In the following command,
    the `-shared` option is just what it sounds like: it creates a `-Wl,-soname,libprime.so`
    options are for the linker. This tells the linker that the shared library name
    (`soname`) will be `libprime.so`. The `-o` option specifies the output filename,
    which is `libprime.so`. This is a standard naming convention for `so` ending stands
    for *shared object*. When the library is to be used system-wide, a number is often
    added to indicate the version. At the very end of the command, we have the `prime.o`
    object file that is included in this library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Linking against a library in your home directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you have a shared library you want to link against in your home directory
    (or some other directory). Maybe it's a library you downloaded from the internet
    or a library you have built yourself, as in this case. We will learn more about
    making our own libraries in a later chapter of this book. Here, we use the small
    sample library we've just made, called `libprime.so`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following source code in a file and name it `is-it-a-prime.c`. This
    program will use the library we just downloaded. We must also include the header
    file we created, `prime.h`. Note the different syntax for including a local header
    file (not a system-wide header file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile it and link it to `libprime.so`. Since the library resides in
    our home directory, we need to specify the path to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to set the `$LD_LIBRARY_PATH` **environment variable** to our current
    directory (where the library resides) before we can run the program. The reason
    for this is that the library is dynamically linked and is not on the usual system
    path for libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we can finally run the program. Test it with some different numbers
    to find out if they are prime numbers or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: $> ldd is-it-a-prime
  prefs: []
  type: TYPE_NORMAL
- en: linux-vdso.so.1 (0x00007ffc3c9f2000)
  prefs: []
  type: TYPE_NORMAL
- en: libprime.so => /home/jake/libprime.so (0x00007fd8b1e48000)
  prefs: []
  type: TYPE_NORMAL
- en: libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd8b1c4c000)
  prefs: []
  type: TYPE_NORMAL
- en: /lib64/ld-linux-x86-64.so.2 (0x00007fd8b1e54000)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pow()` function we used in the *Linking against the math library* section
    requires us to link against the math library, `libm.so`. You can find this file
    in one of the system's library locations, often in `/usr/lib` or `/usr/lib64`.
    On Debian and Ubuntu, it's often `/usr/lib/x86_64-linux-gnu` (for 64-bit systems).
    Since the file is in the system's default library location, we can include it
    using only the `-l` option. The full name of the library file is `libm.so`, but
    when we specify the library to link against, we only specify the `m` part (that
    is, we remove the `lib` part and the `.so` extension). There shouldn't be any
    space between `-l` and the `m` part, so to link against it, we type `-lm`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need to link against the library to use the `pow()` function is
    that the math library is separate from the standard C library, `libc.so`. All
    the functions we have used previously have been part of the *standard library*,
    which is the `libc.so` file. This library is linked by default, so there's no
    need to specify it. If we really wanted to specify the linkage to `libc.so` when
    compiling, we could do so with `gcc -lc some-program.c -o some-program`.
  prefs: []
  type: TYPE_NORMAL
- en: The `pow()` function takes two arguments, *x*, and *y*, such as `pow(x,y)`.
    The function then returns the value of *x* raised to the power of *y*. For example,
    `pow(2,8)` will return 256\. The returned value is a **double float**, and both
    *x* and *y* are double floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for calculating compound interest is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13043_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the starting capital you put in the account, *r* is the interest
    rate in percent, and *y* is the number of years that the money should stay untouched
    in the account.
  prefs: []
  type: TYPE_NORMAL
- en: Linking against a library in your home directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `is-it-a-prime.c` C program, we needed to include the `prime.h` header
    file. The header file only contains one line: the function prototype for the `isprime()`
    function. The actual `isprime()` function is included in the `libprime.so` library
    we created from `prime.o`, which we created from `prime.c`. A `.so` file is a
    **shared library** or **shared object file**. A shared library contains compiled
    object files for functions. We will cover what object files are later in this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to link against a library that we have downloaded or created ourselves,
    and that is not installed in the system's default location for libraries, things
    get a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to specify the library's name and the path where the library
    is located. The path is specified with the `-L` option. Here, we set the path
    to the current directory where we created the library. `${PWD}` is a shell environment
    variable that contains the full path to the current directory. You can try it
    with `echo ${PWD}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then, to be able to run the program, we need to set an environment variable
    called `$LD_LIBRARY_PATH` to our current directory (and whatever it already contains).
    The reason for this is that the program is `$LD_LIBRARY_PATH`. We also don''t
    want to overwrite what''s already in the `$LD_LIBRARY_PATH` variable; that''s
    why we also include the variable''s content. If we hadn''t set that environment
    variable, we would get an error message when executing the program, saying "*error
    while loading shared libraries: libprime.so*". When we listed the dependencies
    with `ldd`, we saw that `libprime.so` is located in a home directory, not in the
    system''s library locations.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested in reading more about the standard C library, you can
    read `man libc`. To read more about the `pow()` function, you can read `man 3
    pow`.
  prefs: []
  type: TYPE_NORMAL
- en: I also encourage you to read the manual page for `ldd` with `man ldd`. Also,
    check out some program's dependencies with `ldd`—for example, the `interest` program
    we wrote in this recipe. While doing so, you'll see `libm.so` and its location
    in the system. You can also try `ldd` on system binaries, such as `/bin/ls`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing C standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will be learning and exploring different **C standards**,
    what they are, why they matter, and how they affect our programs. We will also
    learn how to set the C standard at **compile** time.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used C standards today are **C89**, **C99**, and **C11** (C89
    for 1989, C11 for 2011, and so on). Many compilers still default to using C89
    because it's the most compatible, widespread, and complete implementation. However,
    C99 is a more flexible and modern implementation. Often, under newer versions
    of Linux, the default is **C18**, together with some POSIX standards.
  prefs: []
  type: TYPE_NORMAL
- en: We will write two programs and compile them with both C89 and C99, and see their
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need for this recipe is a Linux computer with GCC installed, preferably
    via the meta-package or package group described in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow along to explore the differences between the C standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the small C program shown here and save it as `no-return.c`. Note the
    missing `return` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile it using the C89 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program and check the exit code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, recompile the program with the same C standard, but enable *all warnings*,
    *extra warnings*, and *pedantic* checking (`-W` is the option for warnings, and
    `all` is which warnings, hence `-Wall`). Note the error message we get from GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, recompile the program using the C99 standard instead and enable all warnings
    and pedantic checking. No errors should be displayed this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the program and check the exit code. Note the difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following program and name it `for-test.c`. This program creates
    an `i` integer variable inside the `for` loop. This is only allowed in C99:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it using the C99 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it. Everything should work just fine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead, try to compile it with the C89 standard. Note that the error
    message clearly explains that this only works in C99 or higher. The error messages
    from GCC are useful, so always make sure to read them. They can save you a lot
    of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the following small program and name it `comments.c`. In this program,
    we use C99 comments (also called C++ comments):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it using C99:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, try to compile it using C89\. Note that this error message is also
    helpful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are some of the more common differences between C89 and C99\. There are
    other differences that aren't apparent in Linux using GCC. We will discuss some
    of those invisible differences in the *There's more…* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We change the C standard with the `-std` option to GCC. In this recipe, we try
    the two standards, C89 and C99.
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 1-6*, we saw the difference in what happens when we forget the return
    value. In C99, a return value of 0 is assumed since no other value was specified.
    In C89, on the other hand, it's not okay to forget the return value. The program
    will still compile, but the program will return the value 13 (an error code),
    which is wrong since no error occurred in our program. The actual code returned
    could differ, though, but it will always be greater than 0\. When we enabled *all
    warnings*, *extra warnings*, and *pedantic* checking of the code (`-Wall -Wextra
    -pedantic`), we also saw that the compiler issued a warning message, meaning it
    isn't legal to forget the return value. So, always return a value with `return`
    in C89.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in *Steps 7-10*, we saw that in C99 it's okay to declare a new variable
    inside a `for` loop, something that is not okay in C89.
  prefs: []
  type: TYPE_NORMAL
- en: In *Steps 11-13*, we saw a new way of using comments, two slashes `//`. This
    isn't legal in C89.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more C standards and dialects than just C89 and C99\. Just to mention
    a few more, there are *C11*, *GNU99* (GNU's dialect of C99), *GNU11* (GNU's dialect
    of C11), and some others, but the most commonly used today are C89, C99, and C11\.
    C18 is starting to appear as default for some compilers and distributions.
  prefs: []
  type: TYPE_NORMAL
- en: There are actually more differences between C89 and C99 than what we've seen
    here. Some of these differences can't be demonstrated in Linux with GCC, since
    GCC has implemented workarounds for the differences. The same goes for some other
    compilers out there. But in C89, for example, the `long long int` type isn't specified;
    it was specified in C99\. But despite that, some compilers (including GCC) support
    `long long int` in C89, but we should be careful with using it in C89 since not
    all compilers support it. If you want to use `long long int`, it's safer to use
    C99, C11, or C18.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you always compile your programs with the `-Wall`, `-Wextra`,
    and `-pedantic` options. These will warn you about all sorts of things that would
    otherwise go unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Using system calls – and when not to use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`printf()`, `fgets()`, `putc()`, and so on. Below them, at the lowest levels,
    we have the system calls, such as `creat()`, `write()`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.1_B13043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – High-level functions and low-level functions
  prefs: []
  type: TYPE_NORMAL
- en: When I talk about system calls here in this book, I mean system calls as C functions
    provided by the kernel, not the actual system call table. The system call functions
    we use here reside in **user space**, but the functions themselves execute in
    **kernel space**.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the standard C library functions, such as `putc()`, use one or more
    system call functions behind the curtains. The `putc()` function is an excellent
    example; this uses `write()` to print a character on the screen (which is a system
    call). There are also standard C library functions that don't use any system calls
    at all, such as `atoi()`, which resides entirely in user space. There is no need
    to involve the kernel to convert a string into a number.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, if there is a standard C library function available, we
    should use that instead of a system call. System calls are often harder to work
    with and more primitive. Think of system calls as *low-level* operations, and
    standard C functions as *high-level* operations.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases, though, when we need to use system calls, or when they are
    easier to use or more beneficial. Learning when and why to use system calls will
    make you a better system programmer altogether. For example, there are many filesystem
    operations we can perform on Linux via system calls that aren't available elsewhere.
    Another example when we need to use a system call is when we want to `fork()`
    a process, something we will discuss in more detail later on. In other words,
    we need to use system calls when we need to perform some form of *system operation*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be using a Linux-specific system call, so you'll need
    a Linux computer (which you most probably already have since you're reading this
    book). But do notice that the `sysinfo()` system call won't work under FreeBSD
    or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn't actually much difference between using a function from the standard
    C library versus using a system call function. System calls in Linux are declared
    in `unistd.h`, so we need to include this file when using system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following small program and name it `sys-write.c`. It uses the `write()`
    system call. Notice that we don''t include `stdio.h` here. Since we aren''t using
    any `printf()` function or any of the stdin, stdout, or stderr file streams, we
    don''t need `stdio.h` here. We print directly to file descriptor 1, which is standard
    output. The three standard file descriptors are always opened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it. From now on, we will always include `-Wall`, `-Wextra`, and `-pedantic`
    to write cleaner and better code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write the same program but with the `fputs()` function instead—a higher-level
    function. Notice that we include `stdio.h` here, instead of `unistd.h`. Name the
    program `write-chars.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to write a program that reads some user and system information.
    Save the program as `my-sys.c`. All the system calls in the program are highlighted.
    This program fetches your user''s ID, current working directory, the machine''s
    total and free **random-access memory** (**RAM**), and current **process ID**
    (**PID**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the program. You should now see some information about your user
    and the machine you are using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Steps 1-6*, we explored the difference between `write()` and `fputs()`.
    The difference might not be that obvious but `write()`, the system call, uses
    `printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Steps 7-9*, we wrote a program that fetches some system and user information.
    Here, we included three system call-specific header files: `unistd.h`, `sys/types.h`,
    and `sys/sysinfo.h`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen `unistd.h`, a common header file for system calls in Unix
    and Linux systems. The `sys/types.h` header file is another common header file
    for system calls, especially when it comes to getting values from the system.
    This header file contains special variable types; for example, `uid_t` and `gid_t`
    for `int`. Others are `ino_t` for `pid_t` for PIDs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `sys/sysinfo.h` header file is specifically for the `sysinfo()` function,
    which is a system call specifically for Linux, and hence this won't work under
    other Unix systems such as macOS, Solaris, or FreeBSD/OpenBSD/NetBSD. This header
    file declares the `sysinfo` struct, which we populate with information by calling
    the `sysinfo()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first system call we use in the program is `getcwd()`, to get the current
    working directory. The function takes two arguments: a buffer where it should
    save the path, and the length of that buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: The next system call is the Linux-specific `sysinfo()` function. This one gives
    us a lot of information. When the function executes, all data is saved to the
    struct `sysinfo`. This information includes the `man 2 sysinfo`, you can find
    information on the variables in the struct `sysinfo` and their data types. Further
    down in the code, we print some of these values using `printf()`—for example,
    `si.totalram`, which contains the size of the system's memory.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the system calls are called directly from `printf()` and returns
    integer values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot of detailed information about Linux system calls in the manual.
    A good starting point is `man 2 intro` and `man 2 syscalls`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Most system calls will return -1 if an error occurs. It's generally a good idea
    to check for this value to detect errors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about Linux- and Unix-specific header files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of specific functions and `sysinfo()`. We have already seen
    two of the POSIX files in the previous recipe: `unistd.h` and `sys/types.h`. Since
    they''re POSIX files, they''re available in all Unix-like systems such as Linux,
    FreeBSD, OpenBSD, macOS, and Solaris.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn more about these POSIX header files, what they
    do, and when and how you can use them. We will also learn how to look up information
    about these files in the manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will look up header files in the manual. If you are using
    a Fedora-based system, such as `dnf install man-pages` as root, or with `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, you are using a Debian-based system such as **Ubuntu**
    or **Debian**, you will need to install those manual pages first. Follow the instructions
    here to install the manual pages required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Debian
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debian is more strict about not including non-free software, so there are a
    few extra steps we need to take.
  prefs: []
  type: TYPE_NORMAL
- en: Open up `/etc/apt/sources.list` in an editor as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the word `non-free` after the lines that say `main` at the end of them (with
    a space between `main` and `non-free`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `apt update` as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the manual pages by running `apt install manpages-posix-dev` as root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ubuntu and other distributions based on Ubuntu aren't as strict about non-free
    software, so here we can install the correct package right away.
  prefs: []
  type: TYPE_NORMAL
- en: Simply run `sudo apt install manpages-posix-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many header files to cover, so what's more important is learning how
    to know which header files we should use and how to find information about them,
    reading their manual pages, and knowing how to list them all. We will cover all
    of this here.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we used the `sysinfo()` and `getpid()` functions. Here,
    we will learn how to find every possible piece of information related to those
    system calls and the required header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we start by reading the manual page for `sysinfo()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the **SYNOPSIS** heading, we find the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This information means that we need to include `sys/sysinfo.h` to use `sysinfo()`.
    It also shows that the function takes a struct called `sysinfo` as an argument.
    Under `sysinfo` struct looks like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s look up `getpid()`. It''s a POSIX function, and hence there is
    more information available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue investigating. Open up the manual page for `sys/types.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s investigate further. Let''s read the manual page for `unistd.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, search this manual page for the word `pid_t`, and we'll find even more
    information about it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type a `/` character and then type `pid_t`, and press *Enter* to search. Press
    the letter *n* on your keyboard to search for the next occurrence of the word.
    You'll find that other functions also return a `pid_t` type—for example, `fork()`,
    `getpgrp()`, and `getsid()`, to mention a few.
  prefs: []
  type: TYPE_NORMAL
- en: While you are reading the manual page for `unistd.h`, you can also see all functions
    that are declared in this header file. If you can't find it, search for `Declarations`.
    Press */*, type `Declarations`, and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The manual pages in the *7posix* or *0p* special section, depending on your
    Linux distribution, are from something called *POSIX Programmer's Manual*. If
    you open, for example, `man unistd.h`, you can see the text *POSIX Programmer's
    Manual*, as opposed to `man 2 write`, which says *Linux Programmer's Manual*.
    *POSIX Programmer's Manual* is from the **Institute of Electrical and Electronics
    Engineers** (**IEEE**) and **The Open Group**, not from the **GNU Project** or
    the Linux community.
  prefs: []
  type: TYPE_NORMAL
- en: Since *POSIX Programmer's Manual* isn't free (as in open source), Debian has
    chosen not to include it in their main repository. That's why we need to add the
    non-free repository to Debian.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX is a set of standards specified by IEEE. The purpose of the standard is
    to have a common programming interface among all POSIX operating systems (most
    Unix and Unix-like systems). If you only use POSIX functions and POSIX header
    files in your program, it will be compatible with all other Unix and Unix-like
    systems out there. The actual implementation can differ from system to system,
    but the overall functions should be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, when we need some specific information (such as which type `pid_t`
    is), we need to read more than one manual page, as we did in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway here is to use the manual page for the function to find the
    corresponding header file, and then to use the manual page for the header file
    to find more specific information.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The manual pages for POSIX header files are in a special section of the manual
    page, not listed in `man man`. Under Fedora and CentOS, the section is called
    *0p*, and under Debian and Ubuntu, it's called *7posix*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can list all of the manual pages available in a given section using the
    `apropos` command with a dot (a dot means to match all).
  prefs: []
  type: TYPE_NORMAL
- en: For example, to list all of the manual pages in *Section 2*, type `apropos -s
    2.` (include the dot—it's part of the command). To list all of the manual pages
    in the *7posix* special section under Ubuntu, type `apropos -s 7posix.`
  prefs: []
  type: TYPE_NORMAL
- en: Defining feature test macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn what some common POSIX standards are, how and why
    to use them, and how we specify them using **feature test macros**.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen several examples of when we have included either a POSIX
    standard or some specific C standard. For example, when we used `getopt()`, we
    defined `_XOPEN_SOURCE 500` at the very top of the source code file (`mph-to-kph_v2.c`
    from [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050), *Making Your
    Programs Easy to Script*).
  prefs: []
  type: TYPE_NORMAL
- en: A feature test macro controls the definitions that are exposed by system header
    files. We can leverage this in two ways. Either we can use it to create portable
    applications by using a feature test macro that prevents us from using non-standard
    definitions or we can use it the other way around, allowing us to use non-standard
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write two small programs in this recipe, `str-posix.c` and `which-c.c`.
    You can either download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)
    or follow along and write them. You'll also need the GCC compiler we installed
    in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the
    Necessary Tools and Writing Our First Linux Programs*. It's also a good idea to
    have access to all the manual pages, including the ones from *POSIX Programmer's
    Manual* covered in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will explore the dark corners of the inner workings of feature test
    macros, POSIX and C standards, and other related things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it in a file called `str-posix.c`. This program
    will simply copy a string using `strdup()` and then print it. Note that we include
    `string.h` here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we begin with compiling it using the C99 standard and see what happens.
    More than one error message will be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That generated a pretty severe warning. The compilation succeeded, though.
    If we try to run the program, it will fail on some distributions but not others.
    This is what''s called **undefined behavior**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'On another Linux distribution, we might see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the fascinating—and somewhat confusing—part. There is one reason
    why this program crashes sometimes, but there are several possible solutions to
    it. We will cover them all here. But first, the reason it failed is that `strdup()`
    isn''t part of C99 (we will cover why it *sometimes* works in the *How it works…*
    section). The most straightforward solution is to look at the manual page, which
    clearly states that we need the `_XOPEN_SOURCE` feature test macro set to `500`
    or higher. For the sake of this experiment, let''s set it to `700` (I''ll explain
    why later). Add the following line at the very top of `str-posix.c`. It needs
    to be on the very first line before any `include` statement; otherwise, it won''t
    work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have added the preceding line, let''s try to recompile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'No warnings this time, so let''s run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So, that was one of the possible solutions and the most obvious one. Now, delete
    that first line again (the entire `#define` line).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have deleted the `#define` line we''ll recompile the program, but
    this time, we set the feature test macro at the command line instead. We use the
    `-D` flag in GCC to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'That was the second solution. But if we read the manual page for feature test
    macros with `man feature_test_macros`, we see that `_XOPEN_SOURCE` with a value
    of 700 or greater has the same effect as defining `_POSIX_C_SOURCE` with a value
    of 200809L or greater. So, let''s try to recompile the program using `_POSIX_C_SOURCE`
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'That worked just fine. Now, for the final—and possibly dangerous—solution.
    This time, we''ll recompile the program without setting any C-standard or any
    feature test macros at all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'No warning, so let''s try to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'How on earth could that work when we just had to define all of these macros
    and standards? Well, it turns out that when we don''t set any C-standard or any
    feature test macros, the compiler sets a couple of standards of its own. To prove
    this, and to know how your compiler works, let''s write the following program.
    Name it `which-c.c`. This program will print the C-standard that is being used
    and any commonly defined feature test macros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile and run this program without setting any C standard or feature
    test macros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to specify that we want to use C-standard C99, and recompile `which.c`.
    What will happen here is that the compiler will enforce a strict C standard mode
    and disable the default feature test macros it might otherwise have set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we set `_XOPEN_SOURCE` to `600`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Steps 1-10*, we saw what happened to our program when we used different
    standards and feature test macros. We also noticed that it surprisingly worked
    without specifying any C standard or feature test macro. That's because GCC—and
    other compilers as well—set a lot of these features and standards by default.
    But we can't count on it. It's always safer to specify it ourselves; that way,
    we know it will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 13*, we wrote a program to print out the feature test macros used
    at compile time. To prevent the compiler from generating errors if a feature test
    macro was not set, we wrapped all the `printf()` lines inside `#ifdef` and `#endif`
    statements. These statements are `if` statements for the compiler, not the resulting
    program. For example, let''s take the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If `_XOPEN_SOURCE` is not defined, then this `printf()` line isn't included
    after the `_XOPEN_SOURCE`, on the other hand, is defined, it will be included.
    We will cover what preprocessing is in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 14*, we saw that on my system, the compiler sets `_POSIX_C_SOURCE`
    to `200809`. But the manual said that we should set `_XOPEN_SOURCE` to `500` or
    greater. But it still worked—how come?
  prefs: []
  type: TYPE_NORMAL
- en: If we read the manual page for the feature test macros (`man feature_test_macros`),
    we see that `_XOPEN_SOURCE` of a value greater than `700` has the same effect
    as setting `_POSIX_C_STANARD` to `200809` or greater. And since GCC has set `_POSIX_C_STANDARD`
    to `200809` for us, this has the same impact as `_XOPEN_SOURCE` `700`.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 15*, we learned that the compiler enforces a strict C standard when
    we specify a standard—for example, `-std=c99`. This is the reason why `str-posix.c`
    failed to run (and got warning messages during compilation). The `strdup()` function
    isn't a standard C function; it's a POSIX function. That's why we needed to include
    some POSIX standard to use it. When the compiler uses a strict C standard, no
    other features are enabled. This enables us to write code that is portable to
    all systems with a C compiler that supports C99.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 16*, we specified `_XOPEN_SOURCE` `600` when we compiled the program—doing
    so also sets `_POSIX_C_STANDARD` to `200112`. We can read about this in the manual
    page (`man feature_test_macros`). From the manual: *"[When] _XOPEN_SOURCE is defined
    with a value greater than or equal to 500 […] the following macros are implicitly
    defined, _POSIX_C_SOURCE […]*".'
  prefs: []
  type: TYPE_NORMAL
- en: But what do feature macros do, then? How do they modify the code?
  prefs: []
  type: TYPE_NORMAL
- en: The header files on the system are full of `#ifdef` statements, enabling and
    disabling various functions and features, depending on which feature test macros
    are set. For example, in our case with `strdup()`, the `string.h` header file
    has the `strdup()` function wrapped in `#ifdef` statements. Those statements check
    if either `_XOPEN_SOURCE` or some other POSIX standard is defined. If no such
    standards are specified, then `strdup()` is not visible. That is how feature test
    macros work.
  prefs: []
  type: TYPE_NORMAL
- en: But why did the program end with a segmentation fault in *Step 3* on some Linux
    distribution and not others? As already mentioned, the `strdup()` function is
    there, but without the feature test macro there's no declaration for it. What
    happens then is *undefined*. It could work because of some specific implementation
    detail, but it could also not work. When we program, we should always avoid *undefined
    behavior*. Just because something works on this specific computer, on this Linux
    distribution, with this compiler version, on this particular night when it's a
    full moon, this doesn't guarantee that it will work on someone else's computer
    on some other night. Therefore, we should always strive to write correct code
    following a specific standard. That way, we avoid undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of these feature test macros we have defined correspond to a POSIX or other
    standard of some sort. The idea behind these standards is to create a uniform
    programming interface among the different Unix versions and Unix-like systems
    out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'For anyone who wants to dig deep into standards and feature test macros, there
    are some excellent manual pages available. Just to mention a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 7 feature_test_macros` (Here, you can read all about which feature test
    macros correspond to which standard, such as POSIX, Single Unix Specification,
    XPG (X/Open Portability Guide), and so on.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 standards` (Even more information about the standards)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man unistd.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 libc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 posixoptions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the four stages of compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we generally speak of compilation, we mean the entire process of turning
    code into a running binary program. But there are actually four steps involved
    in compiling a source code file into a running binary program, and it's just one
    of these steps that's called compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about these four steps, and how to extract the intermediate files, enables
    us to do everything from writing efficient Makefiles to writing shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will write three small C source code files. You can also
    download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
    You'll also need the GCC compiler that we installed in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a small program and then manually compile it
    by executing each step individually, using the compiler's flags. We will also
    look at the files generated from each step. The program we will write is intentionally
    small so that we can look at the resulting code without too much clutter. The
    program we will write will simply return a cubed number—in our case, 4 cubed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first source code file for this recipe is a file called `cube-prog.c`.
    This will be the source code file with the `main()` function in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we write the function for `cube()` in a file called `cubed-func.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we write the header file, `cube.h`. This is just the function
    prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Before we build the program step by step, we first compile it as usual since
    we haven't covered how to compile a program that consists of several files yet.
    To compile a program that's made up of more than one source file, we simply list
    them at the GCC command line. Note, however, that we don't list the header file
    here. Since the header file is included with a `#include` line, the compiler already
    knows about it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how we compile a program with several files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, let''s run it, and also check the return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we begin to build the program step by step instead. First, we delete the
    binary file already produced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s begin compiling the program step by step. The first step is what
    is called the `#include` files in the program itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two *preprocessed* files (`cube-prog.i` and `cube-func.i`). Let's
    take a look at them with `cat` or an editor. I have highlighted the changes in
    the following code snippet. Note how the `#include` statement has been replaced
    by the code from the header file, and how the `NUMBER` macro has been replaced
    by a `4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we take a look at `cube-prog.i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: int cube(int n)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return n*n*n;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is the **compilation**. It is here that our preprocessed files
    are translated into *assembly language*. The resulting assembly files will look
    different on different machines and architectures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at these files as well, but do note that these files can be
    different on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we take a look at `cube-prog.s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we take a look at `cube-func.s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The third step is called **assembly**. This step is where the assembly source
    code files are built to what are called **object files**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two object files. We can''t look at them since they are binary
    files, but we can use the `file` command to see what they are. The description
    here can also differ on different architectures—for example, 32-bit x86 machines,
    ARM64, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are at the fourth and final step. This is where we combine all the
    object files into a single binary file. This step is called the **linker**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a binary file ready, called `cube`. Let''s see what `file` has
    to say about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s run it to verify that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 7* (the first step in the process), we used the `-E` and `-P` options
    to produce *preprocessed files*. The `-E` option makes GCC stop after preprocessing
    the files— that is, creating preprocessed files. The `-P` option is an option
    for the preprocessor not to include line markers in the preprocessed files. We
    want clean output files.
  prefs: []
  type: TYPE_NORMAL
- en: All `#include` statements include the content of those files in the preprocessed
    files. Likewise, any macros—such as `NUMBERS`—are replaced by the actual number.
    Preprocessed files usually have a `.i` extension.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 9* (the second step in the process), we compiled the preprocessed files.
    The compilation step creates assembly language files. For this step, we used the
    `-S` option, which tells GCC to stop after the compilation process is complete.
    Assembly files usually have a `.s` extension.
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 11* (the third step in the process), we *assembled* the files. This
    step is also called the *assembly* stage. This step takes the assembly language
    files and makes *object files*. We will use object files later in this book when
    we create libraries. The `-c` option tells GCC to stop after the assembly stage
    (or after compiling). Object files usually have a `.o` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in *Step 13* (the fourth and final step), we *linked* the files, creating
    a single binary file that we can execute. No options were needed for this since
    the default action GCC takes is to run through all the steps and, finally, link
    the files to a single binary file. After we linked the files, we got a running
    binary file called `cube`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The four stages of compilation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B13043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – The four stages of compilation
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with Make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen some example usage with **Make**. Here, we will recap on
    what Make is and how we can use it to compile programs so that we don't have to
    type GCC commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need for this recipe is the GCC compiler and Make. You have already
    installed these tools if you followed [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write a small program that calculates the circumference of a circle,
    given the radius. We will then use the Make tool to compile it. The Make tool
    is smart enough to figure out the name of the source code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it as `circumference.c`. This program is
    built on the same code as `mph-to-kph.c` from the previous chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile it with Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to recompile it, it will only tell us that the program is up to date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some more decimal places to the `PI` macro, making it 3.14159265 instead.
    The fourth line in the code should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Save the file once you have made the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to recompile the program now it will do so, since it notices that
    the code has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try out the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Make tool is a tool to ease the compilation of larger projects, but it is
    useful even for small programs like this.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute `make circumference`, it assumes that we want to build a program
    called `circumference` and that its source code file is `circumference.c`. It
    also assumes that our compiler command is `cc` (`cc` is a *link* to `gcc` on most
    Linux systems), and compiles the program using the `cc circumference.c -o circumference`
    command. This command is the same that we run for ourselves when we compile a
    program, except that we have used the real name—`gcc`—instead. In the next recipe,
    we will learn how to change this default command.
  prefs: []
  type: TYPE_NORMAL
- en: The Make tool is also smart enough not to recompile a program unless it's necessary.
    This feature comes in handy on massive projects, where it can take several hours
    to recompile. Only recompiling the changed files saves a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic Makefile with GCC options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned that Make compiles a program using the `cc
    prog.c -o prog` command. In this recipe, we will learn how to change that default
    command. To control the default command, we write a **Makefile** and place that
    file in the same directory as the source file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic Makefile for all your projects is an excellent idea since
    you can then enable `-Wall`, `-Wextra`, and `-pedantic` for all files you compile.
    With these three options enabled, GCC will warn you about many more errors and
    irregularities in your code, making your programs better. That is what we will
    do in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `circumference.c` source code file that we wrote
    in the previous recipe. If you don't already have the file on your computer, you
    can download it from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will write a generic Makefile that you can use for all your projects
    to ensure your programs follow the C99 standard and don't contain any apparent
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it as a file called `Makefile` in the same
    directory as `circumference.c`. This Makefile sets your default compiler and some
    common compiler options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now, remove the `circumference` binary file if you still have it from the previous
    recipe. If you don't have it, skip ahead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, compile the `circumference` program with Make, and notice how the compilation
    command has changed from the previous recipe. The options we just specified in
    the Makefile should now be applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program to make sure it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Makefile we created controls the Make behavior. Since this Makefile isn't
    written for any particular project, it works for all programs in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: On the first line of the Makefile, we set the compiler to `gcc` using the special
    `CC` variable. On the second line, we set the flags to the compiler using the
    special `CFLAGS` variable. We set this variable to `-Wall -Wextra -pedantic -std=c99`.
  prefs: []
  type: TYPE_NORMAL
- en: When we execute `make`, it puts together the `CC` variable and the `CFLAGS`
    variable, which results in a `gcc -Wall -Wextra -pedantic -std=c99` command. And,
    as we learned in the previous recipe, Make assumes the binary name we wish to
    use is the name we gave it. It also assumes the source code file has the same
    name, but with a `.c` ending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even on a small project like this with only one file, Make saves us from typing
    a long GCC command every time we want to recompile it. And that is what Make is
    all about: saving us time and energy.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to learn more about Make, you can read `man 1 make`. There is even
    more detailed information in `info make`. If you don't have the `info` command,
    you'll need to install it first using your package manager as root. The package
    is called `info` on most Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write a Makefile for a specific project.
    The Makefile we wrote in the previous recipe was generic, but this will be for
    a single project only. Knowing how to write Makefiles for your projects will save
    you a lot of time and energy as you start making more complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Also, including a Makefile in a project is considered good manners. The person
    downloading your project usually has no idea how to build it. That person only
    wants to use your program, not be forced to understand how things fit together
    and how to compile it. After downloading, for example, an open source project,
    they would expect to be able just to type `make` and `make install` (or possibly
    also some form of configuration script, but we won't cover that here). The program
    should then be ready to run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `cube` program we made in the *Looking at the
    four stages of compilation* recipe in this chapter. The source code files we will
    use are `cube-prog.c`, `cube-func.c`, and `cube.h`. They can all be downloaded
    from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Save these three files in a new and separate directory, preferably called `cube`.
    Make sure you are inside that directory when you create the Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start writing the code, make sure you are in the directory where you
    saved the source code files for the `cube` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Makefile for the `cube` program. Save the file as `Makefile`.
    In this Makefile we have only one *target*, `cube`. Below the target, we have
    the command that compiles the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to try to build the program using Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we execute the program. Don''t forget to also check the return
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to rebuild the program now, it will say that everything is up to
    date, which it is. Let''s try it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we change something in one of the source code files, it will rebuild
    the program. Let''s change the `NUMBER` macro to `2`. The second line in the `cube-prog.c`
    file should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can recompile the program with Make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, let''s view the changes that are made to our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, delete the `cube` program so that we can try to recompile it in the next
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Rename one of the source code files—for example, `cube.h` to `cube.p`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to recompile it now, Make will protest that it''s missing `cube.h`
    and refuse to go any further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen the first two lines in the Makefile. The first one, `CC`,
    sets the default C compiler to `gcc`. The second one, `CFLAGS`, sets the flags
    we want to pass to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The next line—the one that starts with `cube:`—is called a **target**. Right
    after the target, on the same line, we list all the files that this target is
    dependent upon, which are all the source code files and header files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the target, we have an indented line with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: This line is the command that will compile the program. `$(CC)` and `$(CFLAGS)`
    will be replaced with the content of those variables, which is `gcc` and `-Wall
    -Wextra -pedantic -std=c99`. Basically, we have just written what we would usually
    write at the command line, but in a Makefile instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to leverage some of the smarter stuff
    in Make.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a more advanced Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we wrote a basic Makefile without using any of its more
    advanced features. In this recipe, however, we will write a more advanced Makefile,
    using object files, more variables, dependencies, and other fancy things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will create a new program. The program will calculate the area of
    three different objects: circles, triangles, and rectangles. Each calculation
    will be performed in its own function, and every function will reside in its own
    file. On top of that, we will have a function in a separate file for the help
    text. There will also be a header file that holds all of the function prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project will consist of a total of seven files. If you want, you can choose
    to download all the files from the directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area).
  prefs: []
  type: TYPE_NORMAL
- en: Since we will create a Makefile for this project, I really recommend that you
    place all of the project files in a new and separate directory.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the Make tool and the GCC compiler installed in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we write all of the code files required for this program. Then,
    we try to compile the program using Make, and finally, we try to run it. Follow
    along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a main program file called `area.c`. This is the main
    part of the program, and it contains the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write the header file, called `area.h`. This file contains all of
    the function prototypes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, add the `help` function in its own file, called `help.c`: (Shankar)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a function for calculating the area of a circle. We write
    this in a file called `circle.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is a function for calculating the area of a rectangle. We name this
    file `rectangle.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last function is for calculating the area of a triangle. We name this
    file `triangle.c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the exciting part: the `Makefile`. Note that the indentations in
    a Makefile must be precisely one tab character. Note that the `area` target lists
    all the object files using the `OBJS` variable. The command for this target, `$(CC)
    -o area $(OBJS) $(LIBS)`, links together all the object files into a single binary,
    using what''s called a linker. But since the linker depends on all the object
    files, Make builds them first before linking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can try to compile this entire program by typing `make`. Note that
    you must be in the same directory as the source code files and the Makefile. Notice
    here that all the object files get compiled first, then they are linked in the
    final step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s try out the program. Test all the different functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s pretend we have changed some part of the `circle.c` file by updating
    its timestamp. We can update the timestamp of a file by running `touch` on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rebuild the program. Compare the output from *Step 8*, where all the
    object files were compiled. This time, the only file that gets recompiled is `circle.o`.
    After the recompilation of `circle.o`, the binary is relinked into a single binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try to install the program on the system by using the `install`
    target. For this to succeed, you need to run it as root using either `su` or `sudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s uninstall the program from the system. It''s good practice to include
    an `uninstall` target, especially if the `install` target installs lots and lots
    of files on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also try the target called `clean`. This will delete all the object
    files and the binary file. It''s good practice to include a target for cleaning
    up object files and other temporary files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though the program example for this recipe was rather big, it's a pretty
    straightforward program. There are some parts of it, though, that are worth commenting
    on.
  prefs: []
  type: TYPE_NORMAL
- en: All of the C files get compiled to object files independently of each other.
    That's the reason why we need to include `stdio.h` in every single file that uses
    `printf()` or `scanf()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `circle.c` file, we have included the `math.h` header file. This header
    file is for the `pow()` function. We also defined `_XOPEN_SOURCE` with a value
    of `700`. The reason is that the `M_PI` macro that holds the value of Pi isn't
    included in the C standard but it is, on the other hand, included in the **X/Open**
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: The Makefile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, it's time to discuss the Makefile in greater detail. We have already seen
    the first two variables, `CC` and `CFLAGS`, in previous recipes, but notice that
    we haven't used the `CFLAGS` variable anywhere in the code. We don't need to.
    `CFLAGS` is automatically applied when compiling the object files. If we had applied
    the `CFLAGS` variable manually after the `CC` variable in the command for the
    `area` target, those flags would also have been used for the linking process.
    In other words, the command we have specified for the target called `area` is
    just for the linking stage. The compilation of the object files happens automatically.
    Since the object files are a dependency, Make tries to figure out how to build
    them all on its own.
  prefs: []
  type: TYPE_NORMAL
- en: When we run Make without specifying a target, Make will run the first target
    in the Makefile. That's the reason why we put the `area` target first in the file,
    so that when we simply type `make`, the program is built.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have `LIBS=-lm`. This variable is added to the end of the `area` target
    to link against the math library, but do note that it is only the linker that
    makes use of this. Look at the output in *Step 8*. All the object files are compiled
    as usual, but at the last stage, when the linker assembles all the object files
    in to a single binary, `-lm` is added at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This variable lists all the object files. This is where Make gets really smart.
    The first place where we use `OBJS` is the dependency for the `area` target. To
    put together the `area` binary program, we need all of the object files.
  prefs: []
  type: TYPE_NORMAL
- en: The next place where we use `OBJS` is in the build command for the `area` binary.
    Note that we don't specify the C files here, only the object files (via `OBJS`).
    Make is smart enough to figure out that to build the binary, we first need the
    object files, and to compile the object files, we need the C files with the same
    names as the object files. Therefore, we don't need to spell out the entire command
    with all the source code files. Make figures this out all on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next new variable is `DEPS`. In this variable, we list the header file
    required to build the `area.o` object file. We specify this dependency on the
    `area.o: $(DEPS)` line. This target doesn''t contain any command; we just use
    it to verify the dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: The final variable is `bindir`, which contains the full path to where the binary
    file should be installed. This variable is used in the `install` and `uninstall`
    targets, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: We have already covered the `area` and `area.o` targets in the discussion about
    variables. So, let's move on to the `clean`, `install`, and `uninstall` targets.
    These targets are common in most projects. It's considered good manners to include
    them. They have nothing to do with compiling and building the program, but they
    help the end user to install and uninstall the software on the system. The `clean`
    target helps the end user in keeping the source code directory clean from temporary
    files such as object files. The commands under each of these targets are typical
    Linux commands, combined with the variables we have already covered.
  prefs: []
  type: TYPE_NORMAL
- en: The `install` command used in the `install` target copies the `area` file to
    where `bindir` points (`/usr/local/bin` in our case). It also sets the user and
    group for the installed file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have specified dependencies for the `install` and `uninstall` targets
    (the dependency is the file that is to be installed or removed). This makes sense;
    there is no need to run these commands if the file doesn't exist. But for the
    `clean` target, we didn't specify any dependency. It could happen that the user
    has already deleted *some* of the object files themself. When they run `make clean`,
    they don't want the entire target to fail but to continue removing any leftover
    files.
  prefs: []
  type: TYPE_NORMAL
