- en: '*Chapter 3*: Diving Deep into C in Linux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：深入学习Linux中的C'
- en: It's time to take an in-depth look at C programming in Linux. Here, we will
    learn more about the **compiler**, the four stages from source code to **binary
    program**, how to use the **Make** tool, and differences between system calls
    and standard library functions. We will also take a look at some essential header
    files when it comes to Linux, and look at some **C** and **Portable Operating
    System Interface** (**POSIX**) **standards**. C is tightly integrated with Linux,
    and mastering C will help you understand Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解Linux中的C编程了。在这里，我们将更多地了解编译器，从源代码到二进制程序的四个阶段，如何使用Make工具，以及系统调用和标准库函数之间的区别。我们还将看一些关于Linux的基本头文件，并查看一些C和便携操作系统接口（POSIX）标准。C与Linux紧密集成，掌握C将帮助您了解Linux。
- en: In this chapter, we will develop both programs and libraries for Linux. We will
    also write both a generic **Makefile** and more advanced ones for more significant
    projects. While doing this, we will also learn about the different **C standards**,
    why they matter, and how they affect your programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为Linux开发程序和库。我们还将编写一个通用的Makefile和更复杂的Makefile，用于更大的项目。在这样做的同时，我们还将了解不同的C标准，它们为什么重要，以及它们如何影响您的程序。
- en: 'This chapter will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Linking against libraries using the **GNU Compiler Collection** (**GCC**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GNU编译器集合（GCC）链接库
- en: Changing C standards
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改C标准
- en: Using system calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统调用
- en: sand when not to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用它们，何时不使用它们
- en: Getting information about Linux- and Unix-specific header files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关Linux和Unix特定头文件的信息
- en: Defining feature test macros
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义特性测试宏
- en: Looking at the four stages of compilation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看编译的四个阶段
- en: Compiling with Make
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Make进行编译
- en: Writing a generic Makefile with GCC options
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GCC选项编写通用Makefile
- en: Writing a simple Makefile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的Makefile
- en: Writing a more advanced Makefile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个更高级的Makefile
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will need the Make tool and the GCC compiler, preferably
    installed via the meta-package or group install mentioned in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要Make工具和GCC编译器，最好是通过[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中提到的元包或组安装来安装。
- en: All source code for this chapter is available at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码都可以在[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)上找到。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3sElIvu](https://bit.ly/3sElIvu)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看“代码实战”视频：[https://bit.ly/3sElIvu](https://bit.ly/3sElIvu)
- en: Linking against libraries using GCC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCC链接库
- en: In this recipe, we will learn how to link a program to an external **library**,
    both one that's installed system-wide and one that resides in our home directory.
    Before we can link to a library, however, we need to create it. This is also something
    that we are going to cover in this recipe. Knowing how to link against libraries
    will enable you to make use of a wide variety of ready-to-use functions. Instead
    of writing everything by yourself, you can use libraries that are already available.
    Often, there is no need to reinvent the wheel, thus saving you a lot of time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何将程序链接到外部库，包括系统范围内安装的库和位于我们家目录中的库。然而，在我们可以链接到库之前，我们需要创建它。这也是我们将在这个示例中涵盖的内容。了解如何链接到库将使您能够使用各种各样的现成函数。您可以使用已经可用的库，而不是自己编写所有内容。通常情况下，没有必要重新发明轮子，从而节省大量时间。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed under the *Technical requirements*
    section of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，您只需要本章的*技术要求*部分中列出的内容。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we will learn how to link against both a **shared library** installed
    on your system and a library from your home directory. We will begin with a library
    already on your system: the **math library**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何链接到系统上安装的共享库和家目录中的库。我们将从系统上已有的库开始：数学库。
- en: Linking against the math library
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到数学库
- en: Here, we will make a small program that calculates the compound interest on
    a bank account. For this, we need the `pow()` function, which is included in the
    math library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将制作一个小程序，用于计算银行账户上的复利。为此，我们需要数学库中包含的`pow()`函数。
- en: 'Write the following code and save it in a file called `interest.c`. Note that
    we include `math.h` at the top. The `pow()` function''s first argument is the
    base; the second argument is the exponent:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码，并将其保存在名为`interest.c`的文件中。请注意，我们在顶部包含了`math.h`。`pow()`函数的第一个参数是底数；第二个参数是指数：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, compile and `-l`, and the name of the library is `m` (see the `man 3 pow`
    manual page for more information):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译和`-l`，库的名称是`m`（有关更多信息，请参阅`man 3 pow`手册页）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And finally, let''s try the program:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一下程序：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating our own library
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们自己的库
- en: Here, we'll create our very own shared library. In the next section of this
    recipe, we'll link a program to this library. The library we are creating here
    is used to find out if a number is a prime number or not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建我们自己的共享库。在本示例的下一部分中，我们将将程序链接到此库。我们在这里创建的库用于查找一个数字是否是质数。
- en: 'Let''s start with creating a simple header file. This file will only contain
    a single line—the function prototype. Write the following content in a file and
    name it `prime.h`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的头文件开始。这个文件只包含一行内容——函数原型。在文件中写入以下内容，并将其命名为`prime.h`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it''s time to write the actual function that will be included in the library.
    Write the following code in a file and save it as `primc.c`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写实际的函数，该函数将被包含在库中。在文件中写入以下代码，并将其保存为`primc.c`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to convert this to a library somehow. The first step is to compile
    it into something that''s called an object file. We also need to parse some extra
    arguments to the compiler to make it work in a library. More specifically, we
    need to make it `prime.o`, which we''ll see with the `ls -l` command. We''ll learn
    more about object files later in this chapter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we must package the object file as a library. In the following command,
    the `-shared` option is just what it sounds like: it creates a `-Wl,-soname,libprime.so`
    options are for the linker. This tells the linker that the shared library name
    (`soname`) will be `libprime.so`. The `-o` option specifies the output filename,
    which is `libprime.so`. This is a standard naming convention for `so` ending stands
    for *shared object*. When the library is to be used system-wide, a number is often
    added to indicate the version. At the very end of the command, we have the `prime.o`
    object file that is included in this library:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Linking against a library in your home directory
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you have a shared library you want to link against in your home directory
    (or some other directory). Maybe it's a library you downloaded from the internet
    or a library you have built yourself, as in this case. We will learn more about
    making our own libraries in a later chapter of this book. Here, we use the small
    sample library we've just made, called `libprime.so`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following source code in a file and name it `is-it-a-prime.c`. This
    program will use the library we just downloaded. We must also include the header
    file we created, `prime.h`. Note the different syntax for including a local header
    file (not a system-wide header file):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, compile it and link it to `libprime.so`. Since the library resides in
    our home directory, we need to specify the path to it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to set the `$LD_LIBRARY_PATH` **environment variable** to our current
    directory (where the library resides) before we can run the program. The reason
    for this is that the library is dynamically linked and is not on the usual system
    path for libraries:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now, we can finally run the program. Test it with some different numbers
    to find out if they are prime numbers or not:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: $> ldd is-it-a-prime
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: linux-vdso.so.1 (0x00007ffc3c9f2000)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: libprime.so => /home/jake/libprime.so (0x00007fd8b1e48000)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd8b1c4c000)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: /lib64/ld-linux-x86-64.so.2 (0x00007fd8b1e54000)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pow()` function we used in the *Linking against the math library* section
    requires us to link against the math library, `libm.so`. You can find this file
    in one of the system's library locations, often in `/usr/lib` or `/usr/lib64`.
    On Debian and Ubuntu, it's often `/usr/lib/x86_64-linux-gnu` (for 64-bit systems).
    Since the file is in the system's default library location, we can include it
    using only the `-l` option. The full name of the library file is `libm.so`, but
    when we specify the library to link against, we only specify the `m` part (that
    is, we remove the `lib` part and the `.so` extension). There shouldn't be any
    space between `-l` and the `m` part, so to link against it, we type `-lm`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need to link against the library to use the `pow()` function is
    that the math library is separate from the standard C library, `libc.so`. All
    the functions we have used previously have been part of the *standard library*,
    which is the `libc.so` file. This library is linked by default, so there's no
    need to specify it. If we really wanted to specify the linkage to `libc.so` when
    compiling, we could do so with `gcc -lc some-program.c -o some-program`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The `pow()` function takes two arguments, *x*, and *y*, such as `pow(x,y)`.
    The function then returns the value of *x* raised to the power of *y*. For example,
    `pow(2,8)` will return 256\. The returned value is a **double float**, and both
    *x* and *y* are double floats.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for calculating compound interest is shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B13043_03_001.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Here, *P* is the starting capital you put in the account, *r* is the interest
    rate in percent, and *y* is the number of years that the money should stay untouched
    in the account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*P*是您放入账户的起始资本，*r*是百分比利率，*y*是资金应该在账户中保持不变的年数。
- en: Linking against a library in your home directory
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到主目录中的库
- en: 'In the `is-it-a-prime.c` C program, we needed to include the `prime.h` header
    file. The header file only contains one line: the function prototype for the `isprime()`
    function. The actual `isprime()` function is included in the `libprime.so` library
    we created from `prime.o`, which we created from `prime.c`. A `.so` file is a
    **shared library** or **shared object file**. A shared library contains compiled
    object files for functions. We will cover what object files are later in this
    chapter.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`is-it-a-prime.c`的C程序中，我们需要包含`prime.h`头文件。头文件只包含一行：`isprime()`函数的函数原型。实际的`isprime()`函数包含在我们从`prime.c`创建的`prime.o`中，我们从`prime.o`创建的`libprime.so`库中。`.so`文件是一个**共享库**或**共享对象文件**。共享库包含函数的已编译对象文件。我们将在本章后面介绍对象文件是什么。
- en: When we want to link against a library that we have downloaded or created ourselves,
    and that is not installed in the system's default location for libraries, things
    get a bit more complicated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要链接到一个我们下载或自己创建的库，而该库未安装在系统默认的库位置时，事情就会变得有点复杂。
- en: First, we need to specify the library's name and the path where the library
    is located. The path is specified with the `-L` option. Here, we set the path
    to the current directory where we created the library. `${PWD}` is a shell environment
    variable that contains the full path to the current directory. You can try it
    with `echo ${PWD}`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定库的名称和库所在的路径。路径是用`-L`选项指定的。在这里，我们将路径设置为我们创建库的当前目录。`${PWD}`是一个shell环境变量，它包含当前目录的完整路径。您可以使用`echo
    ${PWD}`来尝试它。
- en: 'But then, to be able to run the program, we need to set an environment variable
    called `$LD_LIBRARY_PATH` to our current directory (and whatever it already contains).
    The reason for this is that the program is `$LD_LIBRARY_PATH`. We also don''t
    want to overwrite what''s already in the `$LD_LIBRARY_PATH` variable; that''s
    why we also include the variable''s content. If we hadn''t set that environment
    variable, we would get an error message when executing the program, saying "*error
    while loading shared libraries: libprime.so*". When we listed the dependencies
    with `ldd`, we saw that `libprime.so` is located in a home directory, not in the
    system''s library locations.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，为了能够运行程序，我们需要设置一个名为`$LD_LIBRARY_PATH`的环境变量到我们的当前目录（以及它已经包含的内容）。这样做的原因是程序是`$LD_LIBRARY_PATH`。我们也不想覆盖`$LD_LIBRARY_PATH`变量中已经存在的内容；这就是为什么我们还包括了该变量的内容。如果我们没有设置这个环境变量，当执行程序时会收到一个错误消息，说“*error
    while loading shared libraries: libprime.so*”。当我们用`ldd`列出依赖项时，我们看到`libprime.so`位于主目录中，而不是系统的库位置。'
- en: There's more…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you are interested in reading more about the standard C library, you can
    read `man libc`. To read more about the `pow()` function, you can read `man 3
    pow`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对标准C库感兴趣，可以阅读`man libc`。要了解有关`pow()`函数的更多信息，可以阅读`man 3 pow`。
- en: I also encourage you to read the manual page for `ldd` with `man ldd`. Also,
    check out some program's dependencies with `ldd`—for example, the `interest` program
    we wrote in this recipe. While doing so, you'll see `libm.so` and its location
    in the system. You can also try `ldd` on system binaries, such as `/bin/ls`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我还鼓励您阅读`man ldd`的手册页。还可以使用`ldd`检查一些程序的依赖项，例如我们在本示例中编写的`interest`程序。在这样做时，您将看到`libm.so`及其在系统中的位置。您还可以尝试在系统二进制文件上使用`ldd`，例如`/bin/ls`。
- en: Changing C standards
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改C标准
- en: In this recipe, we will be learning and exploring different **C standards**,
    what they are, why they matter, and how they affect our programs. We will also
    learn how to set the C standard at **compile** time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习和探索不同的**C标准**，它们是什么，为什么它们很重要，以及它们如何影响我们的程序。我们还将学习如何在**编译**时设置C标准。
- en: The most commonly used C standards today are **C89**, **C99**, and **C11** (C89
    for 1989, C11 for 2011, and so on). Many compilers still default to using C89
    because it's the most compatible, widespread, and complete implementation. However,
    C99 is a more flexible and modern implementation. Often, under newer versions
    of Linux, the default is **C18**, together with some POSIX standards.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 今天最常用的C标准是**C89**、**C99**和**C11**（C89代表1989年，C11代表2011年，依此类推）。许多编译器仍然默认使用C89，因为它是最兼容、最广泛和最完整的实现。然而，C99是一种更灵活和现代的实现。通常，在较新版本的Linux下，默认是**C18**，还有一些POSIX标准。
- en: We will write two programs and compile them with both C89 and C99, and see their
    differences.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写两个程序，并用C89和C99编译它们，看看它们的区别。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need for this recipe is a Linux computer with GCC installed, preferably
    via the meta-package or package group described in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing our First Linux Programs*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要的只是一台安装了GCC的Linux计算机，最好是通过[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中描述的元包或软件包组来安装。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Follow along to explore the differences between the C standards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着来探索C标准之间的差异。
- en: 'Write the small C program shown here and save it as `no-return.c`. Note the
    missing `return` statement:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写这里显示的小型C程序，并将其保存为`no-return.c`。注意缺少`return`语句：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, compile it using the C89 standard:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用C89标准编译它：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program and check the exit code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查退出代码：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, recompile the program with the same C standard, but enable *all warnings*,
    *extra warnings*, and *pedantic* checking (`-W` is the option for warnings, and
    `all` is which warnings, hence `-Wall`). Note the error message we get from GCC:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用相同的C标准重新编译程序，但启用*所有警告*、*额外警告*和*严格检查*（`-W`是警告的选项，`all`是哪些警告，因此是`-Wall`）。注意我们从GCC得到的错误消息：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, recompile the program using the C99 standard instead and enable all warnings
    and pedantic checking. No errors should be displayed this time:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新使用C99标准编译程序，并启用所有警告和严格检查。这次不应该显示错误：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rerun the program and check the exit code. Note the difference:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行程序并检查退出代码。注意区别：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write the following program and name it `for-test.c`. This program creates
    an `i` integer variable inside the `for` loop. This is only allowed in C99:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下程序并将其命名为`for-test.c`。该程序在`for`循环内部创建了一个`i`整数变量。这只在C99中允许：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile it using the C99 standard:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C99标准编译它：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, run it. Everything should work just fine:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它。一切应该正常工作：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, instead, try to compile it with the C89 standard. Note that the error
    message clearly explains that this only works in C99 or higher. The error messages
    from GCC are useful, so always make sure to read them. They can save you a lot
    of time:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用C89标准编译它。请注意，错误消息清楚地解释了这只适用于C99或更高版本。GCC的错误消息很有用，所以一定要确保阅读它们。它们可以节省您很多时间：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, write the following small program and name it `comments.c`. In this program,
    we use C99 comments (also called C++ comments):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写以下小程序并将其命名为`comments.c`。在这个程序中，我们使用C99注释（也称为C++注释）：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compile it using C99:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C99编译它：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now, try to compile it using C89\. Note that this error message is also
    helpful:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用C89编译它。请注意，这个错误消息也很有帮助：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: These are some of the more common differences between C89 and C99\. There are
    other differences that aren't apparent in Linux using GCC. We will discuss some
    of those invisible differences in the *There's more…* section of this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是C89和C99之间一些更常见的差异。在Linux使用GCC时，还有其他一些差异是不明显的。我们将在本示例的*还有更多…*部分讨论一些看不见的差异。
- en: We change the C standard with the `-std` option to GCC. In this recipe, we try
    the two standards, C89 and C99.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GCC的`-std`选项来改变C标准。在这个示例中，我们尝试了两种标准，C89和C99。
- en: In *Steps 1-6*, we saw the difference in what happens when we forget the return
    value. In C99, a return value of 0 is assumed since no other value was specified.
    In C89, on the other hand, it's not okay to forget the return value. The program
    will still compile, but the program will return the value 13 (an error code),
    which is wrong since no error occurred in our program. The actual code returned
    could differ, though, but it will always be greater than 0\. When we enabled *all
    warnings*, *extra warnings*, and *pedantic* checking of the code (`-Wall -Wextra
    -pedantic`), we also saw that the compiler issued a warning message, meaning it
    isn't legal to forget the return value. So, always return a value with `return`
    in C89.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1-6*中，我们看到了当我们忘记返回值时会发生什么的区别。在C99中，假定返回值为0，因为没有指定其他值。另一方面，在C89中，忘记返回值是不可以的。程序仍然会编译，但程序将返回值13（错误代码），这是错误的，因为我们的程序没有发生错误。实际返回的代码可能会有所不同，但它总是大于0。当我们启用*所有警告*、*额外警告*和*严格*检查代码（`-Wall
    -Wextra -pedantic`）时，我们还看到编译器发出了警告消息，这意味着忘记返回值是不合法的。因此，在C89中，始终使用`return`返回一个值。
- en: Then, in *Steps 7-10*, we saw that in C99 it's okay to declare a new variable
    inside a `for` loop, something that is not okay in C89.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤7-10*中，我们看到在C99中，在`for`循环内部声明一个新变量是可以的，而在C89中是不可以的。
- en: In *Steps 11-13*, we saw a new way of using comments, two slashes `//`. This
    isn't legal in C89.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11-13*中，我们看到了一种使用注释的新方法，即两条斜杠`//`。这在C89中是不合法的。
- en: There's more…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are more C standards and dialects than just C89 and C99\. Just to mention
    a few more, there are *C11*, *GNU99* (GNU's dialect of C99), *GNU11* (GNU's dialect
    of C11), and some others, but the most commonly used today are C89, C99, and C11\.
    C18 is starting to appear as default for some compilers and distributions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C89和C99之外还有更多的C标准和方言。还有*C11*、*GNU99*（GNU的C99方言）、*GNU11*（GNU的C11方言）等等，但今天最常用的是C89、C99和C11。C18正在成为一些编译器和发行版的默认标准。
- en: There are actually more differences between C89 and C99 than what we've seen
    here. Some of these differences can't be demonstrated in Linux with GCC, since
    GCC has implemented workarounds for the differences. The same goes for some other
    compilers out there. But in C89, for example, the `long long int` type isn't specified;
    it was specified in C99\. But despite that, some compilers (including GCC) support
    `long long int` in C89, but we should be careful with using it in C89 since not
    all compilers support it. If you want to use `long long int`, it's safer to use
    C99, C11, or C18.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C89和C99之间的差异比我们在这里看到的要多。在Linux中使用GCC，一些差异无法演示，因为GCC已经为这些差异实施了解决方法。其他一些编译器也是如此。但是在C89中，例如，`long
    long int`类型没有被指定；它是在C99中指定的。但尽管如此，一些编译器（包括GCC）在C89中支持`long long int`，但在C89中使用它时应该小心，因为并非所有编译器都支持它。如果要使用`long
    long int`，最好使用C99、C11或C18。
- en: I recommend that you always compile your programs with the `-Wall`, `-Wextra`,
    and `-pedantic` options. These will warn you about all sorts of things that would
    otherwise go unnoticed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您始终使用`-Wall`、`-Wextra`和`-pedantic`选项编译您的程序。这些选项将警告您各种可能被忽略的问题。
- en: Using system calls – and when not to use them
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统调用-以及何时不使用它们
- en: '`printf()`, `fgets()`, `putc()`, and so on. Below them, at the lowest levels,
    we have the system calls, such as `creat()`, `write()`, and so on:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()`、`fgets()`、`putc()`等。在它们下面，最低级别是系统调用，比如`creat()`、`write()`等：'
- en: '![](img/Figure_3.1_B13043.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.1_B13043.jpg)'
- en: Figure 3.1 – High-level functions and low-level functions
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1-高级函数和低级函数
- en: When I talk about system calls here in this book, I mean system calls as C functions
    provided by the kernel, not the actual system call table. The system call functions
    we use here reside in **user space**, but the functions themselves execute in
    **kernel space**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在这本书中谈论系统调用时，我指的是内核提供的C函数，而不是实际的系统调用表。我们在这里使用的系统调用函数驻留在**用户空间**，但函数本身在**内核空间**中执行。
- en: Many of the standard C library functions, such as `putc()`, use one or more
    system call functions behind the curtains. The `putc()` function is an excellent
    example; this uses `write()` to print a character on the screen (which is a system
    call). There are also standard C library functions that don't use any system calls
    at all, such as `atoi()`, which resides entirely in user space. There is no need
    to involve the kernel to convert a string into a number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准的C库函数，比如`putc()`，在幕后使用一个或多个系统调用函数。`putc()`函数是一个很好的例子；它使用`write()`在屏幕上打印一个字符（这是一个系统调用）。还有一些标准的C库函数根本不使用任何系统调用，比如`atoi()`，它完全驻留在用户空间。没有必要涉及内核来将字符串转换为数字。
- en: Generally speaking, if there is a standard C library function available, we
    should use that instead of a system call. System calls are often harder to work
    with and more primitive. Think of system calls as *low-level* operations, and
    standard C functions as *high-level* operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果有标准的C库函数可用，我们应该使用它，而不是系统调用。系统调用通常更难处理，更原始。将系统调用视为*低级*操作，将标准C函数视为*高级*操作。
- en: There are cases, though, when we need to use system calls, or when they are
    easier to use or more beneficial. Learning when and why to use system calls will
    make you a better system programmer altogether. For example, there are many filesystem
    operations we can perform on Linux via system calls that aren't available elsewhere.
    Another example when we need to use a system call is when we want to `fork()`
    a process, something we will discuss in more detail later on. In other words,
    we need to use system calls when we need to perform some form of *system operation*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，我们需要使用系统调用，或者它们更容易使用或更有益。学会何时以及为什么使用系统调用将使你成为一个更好的系统程序员。例如，在Linux上，我们可以通过系统调用执行许多文件系统操作，而这些操作在其他地方是不可用的。另一个需要使用系统调用的例子是当我们想要`fork()`一个进程时，这是我们稍后将更详细讨论的事情。换句话说，当我们需要执行某种形式的*系统操作*时，我们需要使用系统调用。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will be using a Linux-specific system call, so you'll need
    a Linux computer (which you most probably already have since you're reading this
    book). But do notice that the `sysinfo()` system call won't work under FreeBSD
    or macOS.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个特定于Linux的系统调用，所以你需要一台Linux计算机（你很可能已经有了，因为你正在阅读这本书）。但请注意，`sysinfo()`系统调用在FreeBSD或macOS下不起作用。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: There isn't actually much difference between using a function from the standard
    C library versus using a system call function. System calls in Linux are declared
    in `unistd.h`, so we need to include this file when using system calls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在使用标准C库函数和使用系统调用函数之间并没有太大的区别。Linux中的系统调用在`unistd.h`中声明，因此在使用系统调用时需要包含这个文件。
- en: 'Write the following small program and name it `sys-write.c`. It uses the `write()`
    system call. Notice that we don''t include `stdio.h` here. Since we aren''t using
    any `printf()` function or any of the stdin, stdout, or stderr file streams, we
    don''t need `stdio.h` here. We print directly to file descriptor 1, which is standard
    output. The three standard file descriptors are always opened:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下小程序，并将其命名为`sys-write.c`。它使用`write()`系统调用。请注意，我们这里没有包含`stdio.h`。因为我们没有使用任何`printf()`函数或任何stdin、stdout或stderr文件流，所以我们这里不需要`stdio.h`。我们直接打印到文件描述符1，这是标准输出。三个标准文件描述符总是打开的：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile it. From now on, we will always include `-Wall`, `-Wextra`, and `-pedantic`
    to write cleaner and better code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它。从现在开始，我们将始终包括`-Wall`，`-Wextra`和`-pedantic`来编写更清洁、更好的代码：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the program:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, write the same program but with the `fputs()` function instead—a higher-level
    function. Notice that we include `stdio.h` here, instead of `unistd.h`. Name the
    program `write-chars.c`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写相同的程序，但使用`fputs()`函数——一个更高级的函数。请注意，我们在这里包含了`stdio.h`，而不是`unistd.h`。将程序命名为`write-chars.c`：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, run it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, it''s time to write a program that reads some user and system information.
    Save the program as `my-sys.c`. All the system calls in the program are highlighted.
    This program fetches your user''s ID, current working directory, the machine''s
    total and free **random-access memory** (**RAM**), and current **process ID**
    (**PID**):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写一个程序，读取一些用户和系统信息。将程序保存为`my-sys.c`。程序中的所有系统调用都已经突出显示。这个程序获取你的用户ID、当前工作目录、机器的总和空闲的**随机存取内存**（**RAM**），以及当前的**进程ID**（**PID**）：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Compile the program:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, run the program. You should now see some information about your user
    and the machine you are using:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行程序。现在你应该能看到有关你的用户和你正在使用的机器的一些信息：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *Steps 1-6*, we explored the difference between `write()` and `fputs()`.
    The difference might not be that obvious but `write()`, the system call, uses
    `printf()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1-6*中，我们探讨了`write()`和`fputs()`之间的区别。区别可能并不那么明显，但`write()`这个系统调用使用了`printf()`。
- en: 'In *Steps 7-9*, we wrote a program that fetches some system and user information.
    Here, we included three system call-specific header files: `unistd.h`, `sys/types.h`,
    and `sys/sysinfo.h`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7-9*中，我们编写了一个获取一些系统和用户信息的程序。在这里，我们包含了三个特定于系统调用的头文件：`unistd.h`，`sys/types.h`和`sys/sysinfo.h`。
- en: We have already seen `unistd.h`, a common header file for system calls in Unix
    and Linux systems. The `sys/types.h` header file is another common header file
    for system calls, especially when it comes to getting values from the system.
    This header file contains special variable types; for example, `uid_t` and `gid_t`
    for `int`. Others are `ino_t` for `pid_t` for PIDs, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`unistd.h`，这是Unix和Linux系统中系统调用的一个常见头文件。`sys/types.h`头文件是另一个常见的系统调用头文件，特别是在从系统获取值时。这个头文件包含特殊的变量类型；例如，`uid_t`和`gid_t`用于`int`。其他的是`ino_t`用于`pid_t`用于PIDs，等等。
- en: The `sys/sysinfo.h` header file is specifically for the `sysinfo()` function,
    which is a system call specifically for Linux, and hence this won't work under
    other Unix systems such as macOS, Solaris, or FreeBSD/OpenBSD/NetBSD. This header
    file declares the `sysinfo` struct, which we populate with information by calling
    the `sysinfo()` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys/sysinfo.h` 头文件专门用于 `sysinfo()` 函数，这是一个专门为 Linux 设计的系统调用，因此在其他类Unix系统（如
    macOS、Solaris 或 FreeBSD/OpenBSD/NetBSD）下不起作用。这个头文件声明了 `sysinfo` 结构，我们通过调用 `sysinfo()`
    函数来填充它的信息。'
- en: 'The first system call we use in the program is `getcwd()`, to get the current
    working directory. The function takes two arguments: a buffer where it should
    save the path, and the length of that buffer.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中使用的第一个系统调用是 `getcwd()`，用于获取当前工作目录。该函数有两个参数：一个缓冲区，用于保存路径，以及该缓冲区的长度。
- en: The next system call is the Linux-specific `sysinfo()` function. This one gives
    us a lot of information. When the function executes, all data is saved to the
    struct `sysinfo`. This information includes the `man 2 sysinfo`, you can find
    information on the variables in the struct `sysinfo` and their data types. Further
    down in the code, we print some of these values using `printf()`—for example,
    `si.totalram`, which contains the size of the system's memory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个系统调用是特定于 Linux 的 `sysinfo()` 函数。这个函数给了我们很多信息。当函数执行时，所有数据都保存在结构 `sysinfo`
    中。这些信息包括 `man 2 sysinfo` 中，您可以找到关于结构 `sysinfo` 中变量和它们的数据类型的信息。在代码的后面，我们使用 `printf()`
    打印了其中一些值，例如 `si.totalram`，它包含了系统内存的大小。
- en: The rest of the system calls are called directly from `printf()` and returns
    integer values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的系统调用直接从 `printf()` 中调用，并返回整数值。
- en: There's more…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is a lot of detailed information about Linux system calls in the manual.
    A good starting point is `man 2 intro` and `man 2 syscalls`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 手册中有关 Linux 系统调用的详细信息。一个很好的起点是 `man 2 intro` 和 `man 2 syscalls`。
- en: Tip
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Most system calls will return -1 if an error occurs. It's generally a good idea
    to check for this value to detect errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统调用在发生错误时会返回 -1。通常最好检查这个值以检测错误。
- en: Getting information about Linux- and Unix-specific header files
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取关于 Linux 和 Unix 特定头文件的信息
- en: 'There are a lot of specific functions and `sysinfo()`. We have already seen
    two of the POSIX files in the previous recipe: `unistd.h` and `sys/types.h`. Since
    they''re POSIX files, they''re available in all Unix-like systems such as Linux,
    FreeBSD, OpenBSD, macOS, and Solaris.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多特定的函数和 `sysinfo()`。在前面的示例中，我们已经看到了两个 POSIX 文件：`unistd.h` 和 `sys/types.h`。由于它们是
    POSIX 文件，它们在所有类Unix系统（如 Linux、FreeBSD、OpenBSD、macOS 和 Solaris）中都可用。
- en: In this recipe, we will learn more about these POSIX header files, what they
    do, and when and how you can use them. We will also learn how to look up information
    about these files in the manual page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习更多关于这些 POSIX 头文件的知识，它们的作用，以及何时以及如何使用它们。我们还将学习如何在手册页中查找有关这些文件的信息。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look up header files in the manual. If you are using
    a Fedora-based system, such as `dnf install man-pages` as root, or with `sudo`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在手册中查找头文件。如果您使用的是基于 Fedora 的系统，如 `dnf install man-pages` 作为 root 用户，或者使用
    `sudo`。
- en: If, on the other hand, you are using a Debian-based system such as **Ubuntu**
    or **Debian**, you will need to install those manual pages first. Follow the instructions
    here to install the manual pages required for this recipe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您使用的是基于 Debian 的系统，如 **Ubuntu** 或 **Debian**，您需要先安装这些手册页。按照这里的说明安装此示例所需的手册页。
- en: Debian
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Debian
- en: Debian is more strict about not including non-free software, so there are a
    few extra steps we need to take.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 对不包括非自由软件更严格，因此我们需要采取一些额外的步骤。
- en: Open up `/etc/apt/sources.list` in an editor as root.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 身份在编辑器中打开 `/etc/apt/sources.list`。
- en: Add the word `non-free` after the lines that say `main` at the end of them (with
    a space between `main` and `non-free`).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些行的末尾（`main` 之后，用一个空格隔开），在它们后面加上单词 `non-free`。
- en: Save the file.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run `apt update` as root.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 身份运行 `apt update`。
- en: Install the manual pages by running `apt install manpages-posix-dev` as root.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 用户身份运行 `apt install manpages-posix-dev` 安装手册页。
- en: Ubuntu
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ubuntu
- en: Ubuntu and other distributions based on Ubuntu aren't as strict about non-free
    software, so here we can install the correct package right away.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Ubuntu 和其他基于 Ubuntu 的发行版对非自由软件不那么严格，因此我们可以立即安装正确的软件包。
- en: Simply run `sudo apt install manpages-posix-dev`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行 `sudo apt install manpages-posix-dev`。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: There are many header files to cover, so what's more important is learning how
    to know which header files we should use and how to find information about them,
    reading their manual pages, and knowing how to list them all. We will cover all
    of this here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多头文件需要涵盖，因此更重要的是学习如何知道我们应该使用哪些头文件，以及如何找到有关它们的信息，阅读它们的手册页，并知道如何列出它们。我们将在这里涵盖所有这些内容。
- en: In the previous recipe, we used the `sysinfo()` and `getpid()` functions. Here,
    we will learn how to find every possible piece of information related to those
    system calls and the required header files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `sysinfo()` 和 `getpid()` 函数。在这里，我们将学习如何找到与这些系统调用和所需的头文件相关的每一个可能的信息。
- en: 'First of all, we start by reading the manual page for `sysinfo()`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从阅读 `sysinfo()` 的手册页开始：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Under the **SYNOPSIS** heading, we find the following two lines:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SYNOPSIS** 标题下，我们找到了以下两行：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This information means that we need to include `sys/sysinfo.h` to use `sysinfo()`.
    It also shows that the function takes a struct called `sysinfo` as an argument.
    Under `sysinfo` struct looks like.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些信息意味着我们需要包含 `sys/sysinfo.h` 来使用 `sysinfo()`。它还显示该函数以一个名为 `sysinfo` 的结构作为参数。`sysinfo`
    结构是什么样子呢？
- en: 'Now, let''s look up `getpid()`. It''s a POSIX function, and hence there is
    more information available:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们查找 `getpid()`。这是一个 POSIX 函数，因此有更多的信息可用：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s continue investigating. Open up the manual page for `sys/types.h`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续调查。打开 `sys/types.h` 的手册页：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But let''s investigate further. Let''s read the manual page for `unistd.h`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但让我们进一步调查。让我们阅读 `unistd.h` 的手册页：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, search this manual page for the word `pid_t`, and we'll find even more
    information about it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个手册页中搜索`pid_t`这个词，我们会找到更多关于它的信息。
- en: Type a `/` character and then type `pid_t`, and press *Enter* to search. Press
    the letter *n* on your keyboard to search for the next occurrence of the word.
    You'll find that other functions also return a `pid_t` type—for example, `fork()`,
    `getpgrp()`, and `getsid()`, to mention a few.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`/`字符，然后输入`pid_t`，按*Enter*进行搜索。在键盘上按下字母*n*以搜索单词的下一个出现位置。您会发现其他函数也返回`pid_t`类型，例如`fork()`、`getpgrp()`和`getsid()`等。
- en: While you are reading the manual page for `unistd.h`, you can also see all functions
    that are declared in this header file. If you can't find it, search for `Declarations`.
    Press */*, type `Declarations`, and press *Enter*.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您阅读`unistd.h`的手册页时，您还可以看到在此头文件中声明的所有函数。如果找不到，请搜索`Declarations`。按下*/*，输入`Declarations`，然后按*Enter*。
- en: How it works…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The manual pages in the *7posix* or *0p* special section, depending on your
    Linux distribution, are from something called *POSIX Programmer's Manual*. If
    you open, for example, `man unistd.h`, you can see the text *POSIX Programmer's
    Manual*, as opposed to `man 2 write`, which says *Linux Programmer's Manual*.
    *POSIX Programmer's Manual* is from the **Institute of Electrical and Electronics
    Engineers** (**IEEE**) and **The Open Group**, not from the **GNU Project** or
    the Linux community.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页在*7posix*或*0p*特殊部分中，取决于您的Linux发行版，来自一个称为*POSIX程序员手册*的东西。例如，如果您打开`man unistd.h`，您会看到*POSIX程序员手册*，而不是`man
    2 write`，它说*Linux程序员手册*。*POSIX程序员手册*来自**电气和电子工程师学会**（**IEEE**）和**开放组织**，而不是**GNU项目**或Linux社区。
- en: Since *POSIX Programmer's Manual* isn't free (as in open source), Debian has
    chosen not to include it in their main repository. That's why we need to add the
    non-free repository to Debian.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*POSIX程序员手册*不是免费的（开源的），Debian选择不将其包含在其主要存储库中。这就是为什么我们需要将非自由存储库添加到Debian中。
- en: POSIX is a set of standards specified by IEEE. The purpose of the standard is
    to have a common programming interface among all POSIX operating systems (most
    Unix and Unix-like systems). If you only use POSIX functions and POSIX header
    files in your program, it will be compatible with all other Unix and Unix-like
    systems out there. The actual implementation can differ from system to system,
    but the overall functions should be the same.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX是由IEEE指定的一组标准。标准的目的是在所有POSIX操作系统（大多数Unix和类Unix系统）之间具有一个共同的编程接口。如果您的程序只使用POSIX函数和POSIX头文件，它将与所有其他Unix和类Unix系统兼容。实际的实现可能因系统而异，但总体功能应该是相同的。
- en: Sometimes, when we need some specific information (such as which type `pid_t`
    is), we need to read more than one manual page, as we did in this recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们需要一些特定的信息（比如`pid_t`是哪种类型），我们需要阅读多个手册页，就像在这个示例中所做的那样。
- en: The main takeaway here is to use the manual page for the function to find the
    corresponding header file, and then to use the manual page for the header file
    to find more specific information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要要点是使用函数的手册页来查找相应的头文件，然后使用头文件的手册页来查找更具体的信息。
- en: There's more…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The manual pages for POSIX header files are in a special section of the manual
    page, not listed in `man man`. Under Fedora and CentOS, the section is called
    *0p*, and under Debian and Ubuntu, it's called *7posix*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX头文件的手册页位于手册页的特殊部分中，不在`man man`中列出。在Fedora和CentOS下，该部分称为*0p*，在Debian和Ubuntu下，称为*7posix*。
- en: Tip
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can list all of the manual pages available in a given section using the
    `apropos` command with a dot (a dot means to match all).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`apropos`命令加上一个点（点表示匹配所有）来列出特定部分中所有可用的手册页。
- en: For example, to list all of the manual pages in *Section 2*, type `apropos -s
    2.` (include the dot—it's part of the command). To list all of the manual pages
    in the *7posix* special section under Ubuntu, type `apropos -s 7posix.`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要列出*Section 2*中的所有手册页，输入`apropos -s 2.`（包括点号—它是命令的一部分）。要列出Ubuntu下*7posix*特殊部分中的所有手册页，输入`apropos
    -s 7posix.`。
- en: Defining feature test macros
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义特性测试宏
- en: In this recipe, we'll learn what some common POSIX standards are, how and why
    to use them, and how we specify them using **feature test macros**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习一些常见的POSIX标准，以及如何以及为什么使用它们，以及如何使用**特性测试宏**来指定它们。
- en: We have already seen several examples of when we have included either a POSIX
    standard or some specific C standard. For example, when we used `getopt()`, we
    defined `_XOPEN_SOURCE 500` at the very top of the source code file (`mph-to-kph_v2.c`
    from [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050), *Making Your
    Programs Easy to Script*).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个例子，当我们包含了POSIX标准或一些特定的C标准时。例如，当我们使用`getopt()`时，我们在源代码文件的顶部定义了`_XOPEN_SOURCE
    500`（来自[*第2章*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050)，*使您的程序易于脚本化*）。
- en: A feature test macro controls the definitions that are exposed by system header
    files. We can leverage this in two ways. Either we can use it to create portable
    applications by using a feature test macro that prevents us from using non-standard
    definitions or we can use it the other way around, allowing us to use non-standard
    definitions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 特性测试宏控制了系统头文件中暴露的定义。我们可以以两种方式利用它。一种是通过使用特性测试宏来创建可移植的应用程序，从而防止我们使用非标准定义，另一种是相反，允许我们使用非标准定义。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will write two small programs in this recipe, `str-posix.c` and `which-c.c`.
    You can either download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)
    or follow along and write them. You'll also need the GCC compiler we installed
    in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the
    Necessary Tools and Writing Our First Linux Programs*. It's also a good idea to
    have access to all the manual pages, including the ones from *POSIX Programmer's
    Manual* covered in the previous recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写两个小程序，`str-posix.c`和`which-c.c`。您可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)下载它们，或者跟着编写它们。您还需要我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中安装的GCC编译器。还有一个好主意是要有访问所有手册页的权限，包括上一个配方中涵盖的*POSIX程序员手册*中的手册页。
- en: How to do it…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Here, we will explore the dark corners of the inner workings of feature test
    macros, POSIX and C standards, and other related things.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探索特性测试宏、POSIX和C标准以及其他相关事物的内部工作的黑暗角落。
- en: 'Write the following code and save it in a file called `str-posix.c`. This program
    will simply copy a string using `strdup()` and then print it. Note that we include
    `string.h` here:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码并将其保存在名为`str-posix.c`的文件中。该程序将简单地使用`strdup()`复制一个字符串，然后打印它。请注意，我们在这里包括`string.h`：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we begin with compiling it using the C99 standard and see what happens.
    More than one error message will be printed:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们开始使用C99标准编译它，看看会发生什么。将打印出多个错误消息：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That generated a pretty severe warning. The compilation succeeded, though.
    If we try to run the program, it will fail on some distributions but not others.
    This is what''s called **undefined behavior**:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这产生了一个相当严重的警告。尽管编译成功了。如果我们尝试在一些发行版上运行程序，它会失败，但在其他发行版上不会。这就是所谓的**未定义行为**：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On another Linux distribution, we might see the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个Linux发行版上，我们可能会看到以下内容：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now comes the fascinating—and somewhat confusing—part. There is one reason
    why this program crashes sometimes, but there are several possible solutions to
    it. We will cover them all here. But first, the reason it failed is that `strdup()`
    isn''t part of C99 (we will cover why it *sometimes* works in the *How it works…*
    section). The most straightforward solution is to look at the manual page, which
    clearly states that we need the `_XOPEN_SOURCE` feature test macro set to `500`
    or higher. For the sake of this experiment, let''s set it to `700` (I''ll explain
    why later). Add the following line at the very top of `str-posix.c`. It needs
    to be on the very first line before any `include` statement; otherwise, it won''t
    work:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是迷人的——有些令人困惑的——部分。这个程序有时会崩溃的原因有一个，但是有几种可能的解决方案。我们将在这里涵盖它们。但首先，它失败的原因是`strdup()`不是C99的一部分（我们将在*它是如何工作的…*部分解释为什么它有时会工作）。最直接的解决方案是查看手册页，手册页清楚地说明我们需要将`_XOPEN_SOURCE`特性测试宏设置为`500`或更高。为了这个实验，让我们将其设置为`700`（稍后我会解释为什么）。在`str-posix.c`的最顶部添加以下行。它需要在任何`include`语句之前的第一行；否则，它将不起作用：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that you have added the preceding line, let''s try to recompile the program:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经添加了前面的行，让我们尝试重新编译程序：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'No warnings this time, so let''s run the program:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次没有警告，所以让我们运行程序：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, that was one of the possible solutions and the most obvious one. Now, delete
    that first line again (the entire `#define` line).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，这是可能的解决方案之一，也是最明显的解决方案。现在，再次删除第一行（整个`#define`行）。
- en: 'Once you have deleted the `#define` line we''ll recompile the program, but
    this time, we set the feature test macro at the command line instead. We use the
    `-D` flag in GCC to accomplish this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您删除了`#define`行，我们将重新编译程序，但这次我们在命令行上设置特性测试宏。我们使用GCC中的`-D`标志来实现这一点：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s try to run it:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行它：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'That was the second solution. But if we read the manual page for feature test
    macros with `man feature_test_macros`, we see that `_XOPEN_SOURCE` with a value
    of 700 or greater has the same effect as defining `_POSIX_C_SOURCE` with a value
    of 200809L or greater. So, let''s try to recompile the program using `_POSIX_C_SOURCE`
    instead:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第二种解决方案。但是，如果我们阅读特性测试宏的手册页`man feature_test_macros`，我们会发现`_XOPEN_SOURCE`的值为700或更高时具有与将`_POSIX_C_SOURCE`的值定义为200809L或更高相同的效果。因此，让我们尝试使用`_POSIX_C_SOURCE`重新编译程序：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That worked just fine. Now, for the final—and possibly dangerous—solution.
    This time, we''ll recompile the program without setting any C-standard or any
    feature test macros at all:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做得很好。现在，进行最终的——可能危险的——解决方案。这一次，我们将重新编译程序，而不设置任何C标准或任何特性测试宏：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'No warning, so let''s try to run it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有警告，所以让我们尝试运行它：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'How on earth could that work when we just had to define all of these macros
    and standards? Well, it turns out that when we don''t set any C-standard or any
    feature test macros, the compiler sets a couple of standards of its own. To prove
    this, and to know how your compiler works, let''s write the following program.
    Name it `which-c.c`. This program will print the C-standard that is being used
    and any commonly defined feature test macros:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们刚刚定义了所有这些宏和标准时，它怎么可能会工作呢？嗯，事实证明，当我们不设置任何C标准或特性测试宏时，编译器会设置一些自己的标准。为了证明这一点，并了解您的编译器是如何工作的，让我们编写以下程序。将其命名为`which-c.c`。该程序将打印正在使用的C标准和任何常见定义的特性测试宏：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s compile and run this program without setting any C standard or feature
    test macros:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行这个程序，而不设置任何C标准或特性测试宏：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s try to specify that we want to use C-standard C99, and recompile `which.c`.
    What will happen here is that the compiler will enforce a strict C standard mode
    and disable the default feature test macros it might otherwise have set:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试指定我们要使用C标准C99，并重新编译`which.c`。这里会发生的是编译器将强制执行严格的C标准模式，并禁用它可能设置的默认特性测试宏：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s see what happens when we set `_XOPEN_SOURCE` to `600`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们将`_XOPEN_SOURCE`设置为`600`时会发生什么：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *Steps 1-10*, we saw what happened to our program when we used different
    standards and feature test macros. We also noticed that it surprisingly worked
    without specifying any C standard or feature test macro. That's because GCC—and
    other compilers as well—set a lot of these features and standards by default.
    But we can't count on it. It's always safer to specify it ourselves; that way,
    we know it will work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 13*, we wrote a program to print out the feature test macros used
    at compile time. To prevent the compiler from generating errors if a feature test
    macro was not set, we wrapped all the `printf()` lines inside `#ifdef` and `#endif`
    statements. These statements are `if` statements for the compiler, not the resulting
    program. For example, let''s take the following line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If `_XOPEN_SOURCE` is not defined, then this `printf()` line isn't included
    after the `_XOPEN_SOURCE`, on the other hand, is defined, it will be included.
    We will cover what preprocessing is in the next recipe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 14*, we saw that on my system, the compiler sets `_POSIX_C_SOURCE`
    to `200809`. But the manual said that we should set `_XOPEN_SOURCE` to `500` or
    greater. But it still worked—how come?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: If we read the manual page for the feature test macros (`man feature_test_macros`),
    we see that `_XOPEN_SOURCE` of a value greater than `700` has the same effect
    as setting `_POSIX_C_STANARD` to `200809` or greater. And since GCC has set `_POSIX_C_STANDARD`
    to `200809` for us, this has the same impact as `_XOPEN_SOURCE` `700`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 15*, we learned that the compiler enforces a strict C standard when
    we specify a standard—for example, `-std=c99`. This is the reason why `str-posix.c`
    failed to run (and got warning messages during compilation). The `strdup()` function
    isn't a standard C function; it's a POSIX function. That's why we needed to include
    some POSIX standard to use it. When the compiler uses a strict C standard, no
    other features are enabled. This enables us to write code that is portable to
    all systems with a C compiler that supports C99.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Step 16*, we specified `_XOPEN_SOURCE` `600` when we compiled the program—doing
    so also sets `_POSIX_C_STANDARD` to `200112`. We can read about this in the manual
    page (`man feature_test_macros`). From the manual: *"[When] _XOPEN_SOURCE is defined
    with a value greater than or equal to 500 […] the following macros are implicitly
    defined, _POSIX_C_SOURCE […]*".'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: But what do feature macros do, then? How do they modify the code?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The header files on the system are full of `#ifdef` statements, enabling and
    disabling various functions and features, depending on which feature test macros
    are set. For example, in our case with `strdup()`, the `string.h` header file
    has the `strdup()` function wrapped in `#ifdef` statements. Those statements check
    if either `_XOPEN_SOURCE` or some other POSIX standard is defined. If no such
    standards are specified, then `strdup()` is not visible. That is how feature test
    macros work.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: But why did the program end with a segmentation fault in *Step 3* on some Linux
    distribution and not others? As already mentioned, the `strdup()` function is
    there, but without the feature test macro there's no declaration for it. What
    happens then is *undefined*. It could work because of some specific implementation
    detail, but it could also not work. When we program, we should always avoid *undefined
    behavior*. Just because something works on this specific computer, on this Linux
    distribution, with this compiler version, on this particular night when it's a
    full moon, this doesn't guarantee that it will work on someone else's computer
    on some other night. Therefore, we should always strive to write correct code
    following a specific standard. That way, we avoid undefined behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of these feature test macros we have defined correspond to a POSIX or other
    standard of some sort. The idea behind these standards is to create a uniform
    programming interface among the different Unix versions and Unix-like systems
    out there.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'For anyone who wants to dig deep into standards and feature test macros, there
    are some excellent manual pages available. Just to mention a few:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`man 7 feature_test_macros` (Here, you can read all about which feature test
    macros correspond to which standard, such as POSIX, Single Unix Specification,
    XPG (X/Open Portability Guide), and so on.)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 standards` (Even more information about the standards)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man unistd.h`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 libc`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 7 posixoptions`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the four stages of compilation
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we generally speak of compilation, we mean the entire process of turning
    code into a running binary program. But there are actually four steps involved
    in compiling a source code file into a running binary program, and it's just one
    of these steps that's called compilation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about these four steps, and how to extract the intermediate files, enables
    us to do everything from writing efficient Makefiles to writing shared libraries.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will write three small C source code files. You can also
    download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
    You'll also need the GCC compiler that we installed in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a small program and then manually compile it
    by executing each step individually, using the compiler's flags. We will also
    look at the files generated from each step. The program we will write is intentionally
    small so that we can look at the resulting code without too much clutter. The
    program we will write will simply return a cubed number—in our case, 4 cubed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The first source code file for this recipe is a file called `cube-prog.c`.
    This will be the source code file with the `main()` function in it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we write the function for `cube()` in a file called `cubed-func.c`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And finally, we write the header file, `cube.h`. This is just the function
    prototype:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Before we build the program step by step, we first compile it as usual since
    we haven't covered how to compile a program that consists of several files yet.
    To compile a program that's made up of more than one source file, we simply list
    them at the GCC command line. Note, however, that we don't list the header file
    here. Since the header file is included with a `#include` line, the compiler already
    knows about it.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how we compile a program with several files:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And then, let''s run it, and also check the return value:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we begin to build the program step by step instead. First, we delete the
    binary file already produced:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s begin compiling the program step by step. The first step is what
    is called the `#include` files in the program itself:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, we have two *preprocessed* files (`cube-prog.i` and `cube-func.i`). Let's
    take a look at them with `cat` or an editor. I have highlighted the changes in
    the following code snippet. Note how the `#include` statement has been replaced
    by the code from the header file, and how the `NUMBER` macro has been replaced
    by a `4`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we take a look at `cube-prog.i`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: int cube(int n)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: return n*n*n;
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second step is the **compilation**. It is here that our preprocessed files
    are translated into *assembly language*. The resulting assembly files will look
    different on different machines and architectures:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's take a look at these files as well, but do note that these files can be
    different on your machine.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we take a look at `cube-prog.s`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we take a look at `cube-func.s`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The third step is called **assembly**. This step is where the assembly source
    code files are built to what are called **object files**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we have two object files. We can''t look at them since they are binary
    files, but we can use the `file` command to see what they are. The description
    here can also differ on different architectures—for example, 32-bit x86 machines,
    ARM64, and so on:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we are at the fourth and final step. This is where we combine all the
    object files into a single binary file. This step is called the **linker**:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we have a binary file ready, called `cube`. Let''s see what `file` has
    to say about it:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And finally, let''s run it to verify that it works:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Step 7* (the first step in the process), we used the `-E` and `-P` options
    to produce *preprocessed files*. The `-E` option makes GCC stop after preprocessing
    the files— that is, creating preprocessed files. The `-P` option is an option
    for the preprocessor not to include line markers in the preprocessed files. We
    want clean output files.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: All `#include` statements include the content of those files in the preprocessed
    files. Likewise, any macros—such as `NUMBERS`—are replaced by the actual number.
    Preprocessed files usually have a `.i` extension.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 9* (the second step in the process), we compiled the preprocessed files.
    The compilation step creates assembly language files. For this step, we used the
    `-S` option, which tells GCC to stop after the compilation process is complete.
    Assembly files usually have a `.s` extension.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In *Step 11* (the third step in the process), we *assembled* the files. This
    step is also called the *assembly* stage. This step takes the assembly language
    files and makes *object files*. We will use object files later in this book when
    we create libraries. The `-c` option tells GCC to stop after the assembly stage
    (or after compiling). Object files usually have a `.o` extension.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in *Step 13* (the fourth and final step), we *linked* the files, creating
    a single binary file that we can execute. No options were needed for this since
    the default action GCC takes is to run through all the steps and, finally, link
    the files to a single binary file. After we linked the files, we got a running
    binary file called `cube`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The four stages of compilation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B13043.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – The four stages of compilation
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with Make
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen some example usage with **Make**. Here, we will recap on
    what Make is and how we can use it to compile programs so that we don't have to
    type GCC commands.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need for this recipe is the GCC compiler and Make. You have already
    installed these tools if you followed [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will write a small program that calculates the circumference of a circle,
    given the radius. We will then use the Make tool to compile it. The Make tool
    is smart enough to figure out the name of the source code file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it as `circumference.c`. This program is
    built on the same code as `mph-to-kph.c` from the previous chapter:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, let''s compile it with Make:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we try to recompile it, it will only tell us that the program is up to date:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add some more decimal places to the `PI` macro, making it 3.14159265 instead.
    The fourth line in the code should now look like this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Save the file once you have made the changes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to recompile the program now it will do so, since it notices that
    the code has changed:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s try out the program:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works…
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Make tool is a tool to ease the compilation of larger projects, but it is
    useful even for small programs like this.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: When we execute `make circumference`, it assumes that we want to build a program
    called `circumference` and that its source code file is `circumference.c`. It
    also assumes that our compiler command is `cc` (`cc` is a *link* to `gcc` on most
    Linux systems), and compiles the program using the `cc circumference.c -o circumference`
    command. This command is the same that we run for ourselves when we compile a
    program, except that we have used the real name—`gcc`—instead. In the next recipe,
    we will learn how to change this default command.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The Make tool is also smart enough not to recompile a program unless it's necessary.
    This feature comes in handy on massive projects, where it can take several hours
    to recompile. Only recompiling the changed files saves a lot of time.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic Makefile with GCC options
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned that Make compiles a program using the `cc
    prog.c -o prog` command. In this recipe, we will learn how to change that default
    command. To control the default command, we write a **Makefile** and place that
    file in the same directory as the source file.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic Makefile for all your projects is an excellent idea since
    you can then enable `-Wall`, `-Wextra`, and `-pedantic` for all files you compile.
    With these three options enabled, GCC will warn you about many more errors and
    irregularities in your code, making your programs better. That is what we will
    do in this recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use the `circumference.c` source code file that we wrote
    in the previous recipe. If you don't already have the file on your computer, you
    can download it from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we will write a generic Makefile that you can use for all your projects
    to ensure your programs follow the C99 standard and don't contain any apparent
    errors.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code and save it as a file called `Makefile` in the same
    directory as `circumference.c`. This Makefile sets your default compiler and some
    common compiler options:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, remove the `circumference` binary file if you still have it from the previous
    recipe. If you don't have it, skip ahead.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, compile the `circumference` program with Make, and notice how the compilation
    command has changed from the previous recipe. The options we just specified in
    the Makefile should now be applied:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the program to make sure it works:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Makefile we created controls the Make behavior. Since this Makefile isn't
    written for any particular project, it works for all programs in the same directory.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: On the first line of the Makefile, we set the compiler to `gcc` using the special
    `CC` variable. On the second line, we set the flags to the compiler using the
    special `CFLAGS` variable. We set this variable to `-Wall -Wextra -pedantic -std=c99`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: When we execute `make`, it puts together the `CC` variable and the `CFLAGS`
    variable, which results in a `gcc -Wall -Wextra -pedantic -std=c99` command. And,
    as we learned in the previous recipe, Make assumes the binary name we wish to
    use is the name we gave it. It also assumes the source code file has the same
    name, but with a `.c` ending.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Even on a small project like this with only one file, Make saves us from typing
    a long GCC command every time we want to recompile it. And that is what Make is
    all about: saving us time and energy.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to learn more about Make, you can read `man 1 make`. There is even
    more detailed information in `info make`. If you don't have the `info` command,
    you'll need to install it first using your package manager as root. The package
    is called `info` on most Linux distributions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple Makefile
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write a Makefile for a specific project.
    The Makefile we wrote in the previous recipe was generic, but this will be for
    a single project only. Knowing how to write Makefiles for your projects will save
    you a lot of time and energy as you start making more complex programs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Also, including a Makefile in a project is considered good manners. The person
    downloading your project usually has no idea how to build it. That person only
    wants to use your program, not be forced to understand how things fit together
    and how to compile it. After downloading, for example, an open source project,
    they would expect to be able just to type `make` and `make install` (or possibly
    also some form of configuration script, but we won't cover that here). The program
    should then be ready to run.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will use the `cube` program we made in the *Looking at the
    four stages of compilation* recipe in this chapter. The source code files we will
    use are `cube-prog.c`, `cube-func.c`, and `cube.h`. They can all be downloaded
    from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Save these three files in a new and separate directory, preferably called `cube`.
    Make sure you are inside that directory when you create the Makefile.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start writing the code, make sure you are in the directory where you
    saved the source code files for the `cube` program.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Makefile for the `cube` program. Save the file as `Makefile`.
    In this Makefile we have only one *target*, `cube`. Below the target, we have
    the command that compiles the program:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, it''s time to try to build the program using Make:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And finally, we execute the program. Don''t forget to also check the return
    value:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If we try to rebuild the program now, it will say that everything is up to
    date, which it is. Let''s try it:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'But if we change something in one of the source code files, it will rebuild
    the program. Let''s change the `NUMBER` macro to `2`. The second line in the `cube-prog.c`
    file should now look like this:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we can recompile the program with Make:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'And then, let''s view the changes that are made to our program:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, delete the `cube` program so that we can try to recompile it in the next
    step:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Rename one of the source code files—for example, `cube.h` to `cube.p`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we try to recompile it now, Make will protest that it''s missing `cube.h`
    and refuse to go any further:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen the first two lines in the Makefile. The first one, `CC`,
    sets the default C compiler to `gcc`. The second one, `CFLAGS`, sets the flags
    we want to pass to the compiler.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: The next line—the one that starts with `cube:`—is called a **target**. Right
    after the target, on the same line, we list all the files that this target is
    dependent upon, which are all the source code files and header files.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the target, we have an indented line with the following content:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This line is the command that will compile the program. `$(CC)` and `$(CFLAGS)`
    will be replaced with the content of those variables, which is `gcc` and `-Wall
    -Wextra -pedantic -std=c99`. Basically, we have just written what we would usually
    write at the command line, but in a Makefile instead.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will learn how to leverage some of the smarter stuff
    in Make.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Writing a more advanced Makefile
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we wrote a basic Makefile without using any of its more
    advanced features. In this recipe, however, we will write a more advanced Makefile,
    using object files, more variables, dependencies, and other fancy things.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will create a new program. The program will calculate the area of
    three different objects: circles, triangles, and rectangles. Each calculation
    will be performed in its own function, and every function will reside in its own
    file. On top of that, we will have a function in a separate file for the help
    text. There will also be a header file that holds all of the function prototypes.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project will consist of a total of seven files. If you want, you can choose
    to download all the files from the directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Since we will create a Makefile for this project, I really recommend that you
    place all of the project files in a new and separate directory.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: You will also need the Make tool and the GCC compiler installed in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we write all of the code files required for this program. Then,
    we try to compile the program using Make, and finally, we try to run it. Follow
    along.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a main program file called `area.c`. This is the main
    part of the program, and it contains the `main()` function:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we write the header file, called `area.h`. This file contains all of
    the function prototypes:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And now, add the `help` function in its own file, called `help.c`: (Shankar)'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, let''s write a function for calculating the area of a circle. We write
    this in a file called `circle.c`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next up is a function for calculating the area of a rectangle. We name this
    file `rectangle.c`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And the last function is for calculating the area of a triangle. We name this
    file `triangle.c`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now comes the exciting part: the `Makefile`. Note that the indentations in
    a Makefile must be precisely one tab character. Note that the `area` target lists
    all the object files using the `OBJS` variable. The command for this target, `$(CC)
    -o area $(OBJS) $(LIBS)`, links together all the object files into a single binary,
    using what''s called a linker. But since the linker depends on all the object
    files, Make builds them first before linking:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we can try to compile this entire program by typing `make`. Note that
    you must be in the same directory as the source code files and the Makefile. Notice
    here that all the object files get compiled first, then they are linked in the
    final step:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'And now, let''s try out the program. Test all the different functions:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, let''s pretend we have changed some part of the `circle.c` file by updating
    its timestamp. We can update the timestamp of a file by running `touch` on it:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, we rebuild the program. Compare the output from *Step 8*, where all the
    object files were compiled. This time, the only file that gets recompiled is `circle.o`.
    After the recompilation of `circle.o`, the binary is relinked into a single binary:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, let''s try to install the program on the system by using the `install`
    target. For this to succeed, you need to run it as root using either `su` or `sudo`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s uninstall the program from the system. It''s good practice to include
    an `uninstall` target, especially if the `install` target installs lots and lots
    of files on the system:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s also try the target called `clean`. This will delete all the object
    files and the binary file. It''s good practice to include a target for cleaning
    up object files and other temporary files:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though the program example for this recipe was rather big, it's a pretty
    straightforward program. There are some parts of it, though, that are worth commenting
    on.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: All of the C files get compiled to object files independently of each other.
    That's the reason why we need to include `stdio.h` in every single file that uses
    `printf()` or `scanf()`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: In the `circle.c` file, we have included the `math.h` header file. This header
    file is for the `pow()` function. We also defined `_XOPEN_SOURCE` with a value
    of `700`. The reason is that the `M_PI` macro that holds the value of Pi isn't
    included in the C standard but it is, on the other hand, included in the **X/Open**
    standard.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The Makefile
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, it's time to discuss the Makefile in greater detail. We have already seen
    the first two variables, `CC` and `CFLAGS`, in previous recipes, but notice that
    we haven't used the `CFLAGS` variable anywhere in the code. We don't need to.
    `CFLAGS` is automatically applied when compiling the object files. If we had applied
    the `CFLAGS` variable manually after the `CC` variable in the command for the
    `area` target, those flags would also have been used for the linking process.
    In other words, the command we have specified for the target called `area` is
    just for the linking stage. The compilation of the object files happens automatically.
    Since the object files are a dependency, Make tries to figure out how to build
    them all on its own.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: When we run Make without specifying a target, Make will run the first target
    in the Makefile. That's the reason why we put the `area` target first in the file,
    so that when we simply type `make`, the program is built.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have `LIBS=-lm`. This variable is added to the end of the `area` target
    to link against the math library, but do note that it is only the linker that
    makes use of this. Look at the output in *Step 8*. All the object files are compiled
    as usual, but at the last stage, when the linker assembles all the object files
    in to a single binary, `-lm` is added at the end.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have the following line:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This variable lists all the object files. This is where Make gets really smart.
    The first place where we use `OBJS` is the dependency for the `area` target. To
    put together the `area` binary program, we need all of the object files.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: The next place where we use `OBJS` is in the build command for the `area` binary.
    Note that we don't specify the C files here, only the object files (via `OBJS`).
    Make is smart enough to figure out that to build the binary, we first need the
    object files, and to compile the object files, we need the C files with the same
    names as the object files. Therefore, we don't need to spell out the entire command
    with all the source code files. Make figures this out all on its own.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The next new variable is `DEPS`. In this variable, we list the header file
    required to build the `area.o` object file. We specify this dependency on the
    `area.o: $(DEPS)` line. This target doesn''t contain any command; we just use
    it to verify the dependency.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The final variable is `bindir`, which contains the full path to where the binary
    file should be installed. This variable is used in the `install` and `uninstall`
    targets, which we will discuss next.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: We have already covered the `area` and `area.o` targets in the discussion about
    variables. So, let's move on to the `clean`, `install`, and `uninstall` targets.
    These targets are common in most projects. It's considered good manners to include
    them. They have nothing to do with compiling and building the program, but they
    help the end user to install and uninstall the software on the system. The `clean`
    target helps the end user in keeping the source code directory clean from temporary
    files such as object files. The commands under each of these targets are typical
    Linux commands, combined with the variables we have already covered.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The `install` command used in the `install` target copies the `area` file to
    where `bindir` points (`/usr/local/bin` in our case). It also sets the user and
    group for the installed file.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have specified dependencies for the `install` and `uninstall` targets
    (the dependency is the file that is to be installed or removed). This makes sense;
    there is no need to run these commands if the file doesn't exist. But for the
    `clean` target, we didn't specify any dependency. It could happen that the user
    has already deleted *some* of the object files themself. When they run `make clean`,
    they don't want the entire target to fail but to continue removing any leftover
    files.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
