- en: Docker Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be looking at Docker and various workflows for Docker.
    We''ll put all the pieces together so you can start using Docker in your production
    environments and feel comfortable doing so. Let''s take a peek at what we will
    be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker for development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending to external platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does production look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using Docker on the desktop. Like previous chapters,
    I will be using my preferred operating system, which is macOS. The Docker commands
    we will be running will work on all three of the operating systems we have installed
    Docker on so far. However, some of the supporting commands, which will be few
    and far between, may only apply to macOS and Linux- based operating system.
  prefs: []
  type: TYPE_NORMAL
- en: A full copy of the code used in this chapter can be found in the GitHub repository
    at [https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter14](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2SaG0uP](http://bit.ly/2SaG0uP)'
  prefs: []
  type: TYPE_NORMAL
- en: Docker for development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start our look at the workflows by discussing how Docker can
    be used to aid developers. Right back at the start of [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml),
    *Docker Overview*, one of the first things we discussed in the *Understanding
    Docker* section was developers and the *Works on my machine* problem. So far,
    we have not really fully addressed this, so let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we are going to look at how a developer could develop their
    WordPress project on their local machine using Docker for macOS or Docker for
    Windows along with Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this is for us to launch a WordPress installation, which is what
    you will do with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install WordPress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow access to the WordPress files from desktop editors, such as Atom, Visual
    Studio Code, or Sublime Text, on your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure and manage WordPress using the WordPress command-line tool (`WP-CLI`). 
    This allows you to stop, start, and even remove containers without losing your
    work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we launch our WordPress installation, let''s take a look at the Docker
    Compose file and what services we have running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize the Docker Compose file using the `docker-compose-viz` tool
    from PMSIpilot. To do this, run the following command in the same folder as the
    `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a file called `docker-compose.png`, and you should get something
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7a4d5fa8-68e1-4249-b542-17d059154743.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use `docker-compose-viz` to give yourself a visual representation of
    any Docker Compose file. As you can see from ours, we have four services defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is called `web`. This service is the only one of the four that is
    exposed to the host network, and it acts as a frontend to our WordPress installation.
    It runs the official nginx image from [https://store.docker.com/images/nginx/](https://store.docker.com/images/nginx/),
    and it performs two roles. Before we look at these, take a look at the following
    nginx configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are serving all content, apart from PHP, using nginx from
    `/var/www/html/`, which we are mounting from our host machine using nginx, and
    all requests for PHP files are being proxied to our second service, which is called
    `wordpress`, on port `9000`. The nginx configuration itself is being mounted from
    our host machine to `/etc/nginx/conf.d/default.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: This means our nginx container is acting as a web server for the static content,
    the first role, and also as a proxy through to the WordPress container for the
    dynamic content, which is the second role the container takes on.
  prefs: []
  type: TYPE_NORMAL
- en: The second service is `wordpress`; this is the official WordPress image from
    [https://store.docker.com/images/wordpress](https://store.docker.com/images/wordpress),
    and I am using the `php7.2-fpm-alpine` tag. This gives us a WordPress installation
    running on PHP 7.2 using `PHP-FPM` built on top of an Alpine Linux base.
  prefs: []
  type: TYPE_NORMAL
- en: '**FastCGI Process Manager** (**PHP-FPM**) is a PHP FastCGI implementation with
    some great features. For us, it allows PHP to run as a service that we can bind
    to a port and pass requests to; this fits in with the Docker approach of running
    a single service on each container.'
  prefs: []
  type: TYPE_NORMAL
- en: We are mounting the same web root as we are doing for the web service, which
    on the host machine is `wordpress/web` and on the service is `/var/www/html/`.
    To start off with, the folder on our host machine will be empty; however, once
    the WordPress service starts, it will detect that there isn't any core WordPress
    installation and copy one to that location, effectively bootstrapping our WordPress
    installation and copying it to our host machine, ready for us to start work on.
  prefs: []
  type: TYPE_NORMAL
- en: The next service is MySQL, which uses the official MySQL image ([https://store.docker.com/images/mysql/](https://store.docker.com/images/mysql/))
    and is the only image out of the four we are using that doesn't use Alpine Linux
    (come on MySQL, pull your finger out and publish an Alpine Linux-based image!).
    Instead, it uses `debian:stretch-slim`. We are passing a few environment variables
    so that a database, username, and password are all created when the container
    first runs; the password is something you should change if you ever use this as
    a base for one of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `web` and `wordpress` containers, we are mounting a folder from our
    host machine. In this case, it is `wordpress/mysql`, and we are mounting it to
    `/var/lib/mysql/`, which is the default folder where MySQL stores its databases
    and associated files.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that when the container starts, `wordpress/mysql` is populated
    with a few files. I do not recommend editing them using your local IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final service is simply called `wp`. It differs from the other three services:
    this service will immediately exit when executed because there is no long-running
    process within the container. Instead of a long-running process, it provides access
    to the WordPress command-line tool in an environment that exactly matches our
    main `wordpress` container.'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we are mounting the web root as we have done on web and
    WordPress as well as a second mount called `/export`; we will look at this in
    more detail once we have WordPress configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start WordPress, we just need to run the following command to pull the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will pull the images and start the `web`, `wordpress`, and `mysql` services
    as well as readying the `wp` service. Before the services start, our `wordpress`
    folder looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a43578b3-ae10-48cd-a955-c9ae51cf4a22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we only have `nginx.conf` in there, which is part of the Git
    repository. Then we can use the following commands to start the containers and
    check their status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](Images/32a9383e-8a5f-446e-a591-56c5824da777.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see that three folders have been created in the `wordpress` folder:
    `export`, `mysql`, and `web`. Also, remember that we are expecting `dockerwordpress_wp_1`
    to have an `exit` state, so that''s fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2c39b6fd-5299-4d71-b8ec-e949ab69dfba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Opening a browser and going to `http://localhost:8080/` should show you the
    standard WordPress pre-installation welcome page, where you can select the language
    you wish to use for your installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/002b9525-f3e6-4362-82ee-c457ac83674b.png)'
  prefs: []
  type: TYPE_IMG
- en: Do not click on **Continue**, as it will take you to the next screen of the
    GUI-based installation. Instead, return to your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using the GUI to complete the installation, we are going to use
    WP-CLI. There are two steps to this. The first step is to create a `wp-config.php`
    file. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will see in the following Terminal output, before I ran the command,
    I just had the `wp-config-sample.php` file, which ships with core WordPress. Then,
    after running the command, I had my own `wp-config.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/93ff2e9d-9e0e-4c46-bdc6-438a7e65c5bf.png)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that in the command, we are passing the database details we
    defined in the Docker Compose file and telling WordPress that it can connect to
    the database service at the address of `mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have configured database connection details, we need to configure
    our WordPress site as well a create an admin user and set a password. To do this,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command will produce an error about the email service; do not
    worry about that message, as this is only a local development environment. We
    are not too worried about emails leaving our WordPress installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/20b6bd8f-dcf6-4822-a6e0-7ca29deddc65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have used WP-CLI to configure the following in WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: Our URL is `http://localhost:8080`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our site title should be `Blog Title`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our admin username is `admin` and password is `password`, and the user has an
    email of `email@domain.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to your browser and entering [http://localhost:8080/](http://localhost:8080/)
    should present you with a vanilla WordPress site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8375e8c2-0472-4227-bdfe-5db42c6b12ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we do anything further, let''s customize our installation a little,
    first by installing and enabling the JetPack plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7eb7c72d-cad0-4837-9df6-5cdd0c6d30b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, install and enable the `sydney` theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a5063118-333d-47e6-b534-9c7ebadbcabc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Refreshing our WordPress page at [http://localhost:8080/](http://localhost:8080/)
    should show something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8957b6fe-d698-4b21-9f37-292acb3742a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we open our IDE, let''s destroy the containers running our WordPress
    installation using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d4e8f2f0-b75d-4f41-a203-be965f441683.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As our entire WordPress installation, including all of the files and database,
    is stored on our local machine, we should be able to run the following command
    to return to our WordPress site where we left it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have confirmed it is up and running as expected by going to [http://localhost:8080/](http://localhost:8080/),
    open the `docker-wordpress` folder in your desktop editor. I used Sublime Text.
     In your editor, open the `wordpress/web/wp-blog-header.php` file and add the
    following line to the opening PHP statement and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The file should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/522fd0f5-a1e0-4f20-aca7-f5d9f1b45843.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once saved, refresh your browser and you should see the message **Testing editing**
    in the IDE at the very bottom of the page (the following screen is zoomed; it
    may be more difficult to spot if you are following along, as the text is is quite
    small):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/28881359-ecf2-43c1-a05c-91a7904d1bab.png)'
  prefs: []
  type: TYPE_IMG
- en: The final thing we are going to look at is why we had the `wordpress/export`
    folder mounted on the `wp` container.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned earlier in the chapter, you shouldn't be really touching
    the contents of the `wordpress/mysql` folder; this also includes sharing it. While
    it would probably work if you were to zip up your project folder and pass it to
    a colleague, it is not considered as best practice. Because of this, we have mounted
    the export folder to allow us to use WP-CLI to make a database dump and import
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Terminal output shows the export and also the contents of `wordpress/export`
    before and after, and finally, the top few lines of the MySQL dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/05768ab0-7d48-487d-ab2e-a1e4d693a0f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I needed to,  because, say, I had made a mistake during development, I could
    roll back to that version of the database by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2f5dcc3c-517c-485c-8463-5b12d7aa5fb1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you have seen, we have installed WordPress, interacted with it both using
    WP-CLI and the browser, edited the code, and also backed up and restored the database,
    all without having to install or configure nginx, PHP, MySQL, or WP-CLI. Nor did
    we have to log in to a container. By mounting volumes from our host machine, our
    content was safe when we tore our WordPress containers down and we didn't lose
    any work.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if needed, we could have easily passed a copy of our project folder to
    a colleague who has Docker installed, and with a single command, they could be
    working on our code, knowing it is running in the exact environment as our own
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we're using official images from the Docker Store, we know we can
    safely ask to have them deployed into production as they have been built with
    Docker's best practices in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to stop and remove your WordPress containers by running `docker-compose
    down`.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to take a look at monitoring our containers and also Docker
    hosts. In [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*, Managing Containers*,
    we discussed the `docker container top` and `docker container stats` commands.
    You may recall that both of these commands show real-time information only; there
    is no historical data kept.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is great if you are trying to debug a problem as it is running or
    want to quickly get an idea of what is going on inside your containers, it is
    not too helpful if you need to look back at a problem: maybe you have configured
    your containers to restart if they have become unresponsive. While that will help
    with the availability of your application, it isn''t much of a help if you need
    to look at why your container became unresponsive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GitHub repository in the `/chapter14` folder, there is a folder called
    `prometheus` in which there is a Docker Compose file that launches three different
    containers on two networks. Rather than looking at the Docker Compose file, itself
    let''s take a look at the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3efc549a-54a8-4083-8edc-b1679455d5af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is a lot going on. The three services we are running
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cadvisor**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prometheus**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grafana**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we launch and configure our Docker Compose services, we should talk about
    why each one is needed, starting with cadvisor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cadvisor` is a project released by Google. As you can see from Docker
    Hub username in the image we are using, the service section in the Docker Compose
    file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are mounting the various parts of our host's filesystem to allow `cadvisor`
    access to our Docker installation in much the same way as we did in [Chapter 11](d1ef4eff-f35b-47b2-8efc-24a90caa254b.xhtml)*,
    Portainer – A GUI for Docker*. The reason for this is that in our case, we are
    going to be using `cadvisor` to collect statistics on our containers. While it
    can be used as a standalone container-monitoring service, we do not want to publicly
    expose the cadvisor container. Instead, we are just making it available to other
    containers within our Docker Compose stack on the back network.
  prefs: []
  type: TYPE_NORMAL
- en: '`cadvisor` is a self-contained web frontend to the Docker container `stat`
    command, displaying graphs and allowing you to drill down from your Docker host
    into your containers from an easy-to-use interface. However, it doesn''t keep
    more than 5 minutes'' worth of metrics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are attempting to record metrics that can be available hours or even
    days later, having no more than 5 minutes of metrics means that we are going to
    have to use additional tools to record the metrics it processes. `cadvisor` exposes
    the information we want to record our containers as structured data at the following
    endpoint: `http://cadvisor:8080/metrics/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at why this is important in a moment. The `cadvisor` endpoint
    is being scraped automatically by our next service, `prometheus`. This is where
    most of the heavy lifting happens. The `prometheus` is a monitoring tool written
    and open sourced by SoundCloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding service definition, we are mounting a configuration
    file called `./prometheus/prometheus.yml` and also a volume called `prometheus_data`.
    The configuration file contains information about the sources we want to scrape,
    as you can see from the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are instructing Prometheus to scrape data from our endpoints every `15` seconds.
    The endpoints are defined in the `scrape_configs` section, and as you can see,
    we have `cadvisor` in there as well as Prometheus itself defined. The reason we
    are creating and mounting the `prometheus_data` volume is that Prometheus is going
    to be storing all of our metrics, so we need to keep it safe.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Prometheus is a time-series database. It takes the data it has
    scraped, processes it to find the metric name and value, and then stores it along
    with a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus also comes with a powerful query engine and API, making it the perfect
    database for this kind of data. While it does come with basic graphing capabilities,
    it is recommended that you use Grafana, which is our final service and also the
    only one to be exposed publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grafana** is an open source tool for displaying monitoring graphs and metric
    analytics, which allows you to create dashboards using time-series databases,
    such as Graphite, InfluxDB, and also Prometheus. There are also further backend
    database options that are available as plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose definition for Grafana follows a similar pattern to our
    other services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `grafana_data` volume to store Grafana's own internal configuration
    database, and rather than storing the environment variables in the Docker Compose
    file, we are loading them from an external file called `./grafana/grafana.config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting the username and password here, so having them
    in an external file means that you can change these values without editing the
    core Docker Compose file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the role that each of the four services fulfills, let''s launch
    them. To do this, simply run the following commands from the `prometheus` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a network and the volumes and pull the images from the Docker
    Hub. It will then go about launching the four services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9f337042-8244-4838-bff2-40c8d518ba0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may be tempted to go immediately to your Grafana dashboard. If you did
    so, you would not see anything, as Grafana takes a few minutes to initialize itself.
    You can follow its progress by following the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/385e8580-5b68-48c3-b69e-abd387fb61b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you see the `HTTP Server Listen` message, Grafana will be available. With
    Grafana 5 you can now import data sources and dashboards, which is why we are
    mounting `./grafana/provisioning/` to `/etc/grafana/provisioning/`. This folder
    contains the configuration which automatically configures Grafana to talk to our
    Prometheus service and also imports the dashboard, which will display the data
    that Prometheus is scraping from cadvisor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your browser and enter `http://localhost:3000/`, and you should be greeted
    with a login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/649978eb-8e40-4a14-9f29-58f31272ae83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the **User** as `admin` and the **Password** as `password`. Once logged
    in, if you have configured the data source, you should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ddac6a6f-0e09-439a-a2cb-9cf553af9050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the initial steps of Install Grafana | Create your first data
    source | Create your first dashboard have all been executed, leaving just the
    remaining two. For now, we will ignore these. Clicking on the Home button in the
    top left will bring up a menu that lists the available dashboards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ed39f3be-0f1b-4fd7-9dac-6a257b5ff551.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have one called Docker Monitoring. Clicking on it will take
    you to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e4442959-0f79-4cf4-a8c0-7a057e461f22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the timing information on the top right of the screen,
    by default it displays the last five minutes worth of data. Clicking on it will
    allow you to change the time frame displays. For example, the following screen
    shows the last 15 minutes, which obviously is more than the five minutes that
    cadvisor is recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/461543ed-904b-47f9-a747-8fcd743f3e3f.png)'
  prefs: []
  type: TYPE_IMG
- en: I have already mentioned that this is a complex solution; eventually, Docker
    will expand the recently released built-in endpoint, which presently only exposes
    information about the Docker Engine and not the containers themselves. For more
    information on the built-in endpoint, check out the official Docker documentation,
    which can be found at [https://docs.docker.com/config/thirdparty/prometheus/](https://docs.docker.com/config/thirdparty/prometheus/).
  prefs: []
  type: TYPE_NORMAL
- en: There are other monitoring solutions out there; most of them take the form of
    third-party **Software as a service** (**SaaS**). As you can see from the list
    of services in the *Further reading* section, there are a few well-established
    monitoring solutions listed. In fact, you may already be using them, so it would
    be easy for you when expanding your configuration to take into account when monitoring
    your containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished exploring your Prometheus installation, don''t forget
    to remove it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This removes all of the containers, volumes, images, and network.
  prefs: []
  type: TYPE_NORMAL
- en: Extending to external platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already looked at how we can extend to some other external platforms
    using tools such as Docker Machine, Docker Swarm, Docker for Amazon Web Services,
    and Rancher to launch clusters and also clusters and container services from public
    cloud services, such as Amazon Web Services, Microsoft Azure, and DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Heroku** is a little different than the other cloud services, as it is a
    considered a **Platform as a service** (**PaaS**). Instead of deploying containers
    on it, you link your containers to that Heroku platform, from which it will be
    running a service, such as PHP, Java, Node.js, or Python. So, you can run your
    Rails application on Heroku and then attach your Docker container to that platform.'
  prefs: []
  type: TYPE_NORMAL
- en: We will not be covering installing Heroku here as it is a little off topic.
    Please see the *Further readin*g section of the chapter for more details on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you can use Docker and Heroku together is to create your application
    on the Heroku platform, and then in your code, you will have something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To take a step back, we first need to install the plugin to be able to get
    this functionality working. Simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you are wondering what image you can or should be using from the Docker
    Hub, Heroku maintains a lot of images you can use in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`heroku/nodejs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/ruby`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/jruby`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/python`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/scala`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/clojure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/gradle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku/go-gb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does production look like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final section of this chapter, we are going to discuss what production
    should look like. This section isn't going to be as long as you think it will
    be. This is due to the sheer number of options that are available, so it would
    be impossible to cover them all. Also, you should already have a good idea based
    on the previous sections and chapters on what would work best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we are going to be looking at some questions you should be asking yourself
    when planning your environments.
  prefs: []
  type: TYPE_NORMAL
- en: Docker hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker hosts are the key component of your environment. Without these, you won't
    have anywhere to run your containers. As we have already seen in previous chapters,
    there are a few considerations when it comes to running your Docker hosts. The
    first thing you need to take into account is that, if your hosts are running Docker,
    they should not run any other services.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing of processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should resist the temptation of quickly installing Docker on an existing
    host and launching a container. This might not only have a security implication
    with you having a mixture of isolated and non-isolated processes on a single host,
    but it can also cause performance issues as you are not able to add resource limits
    to your non-containerized applications, meaning that, potentially, they can also
    have a negative impact on your running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple isolated Docker hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have more than a few Docker hosts, how are you going to manage them?
    Running a tool such as Portainer is great, but it can get troublesome when attempting
    to manage more than a few hosts. Also, if you are running multiple isolated Docker
    hosts, you do not have the option of moving containers between hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, you can use tools such as Weave Net to span the container network across
    multiple individual Docker hosts. Depending on your hosting environment, you may
    also have the option of creating volumes on external storage and presenting them
    to Docker hosts as needed, but you are very much creating a manual process to
    manage the migration of containers between hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Routing to your containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to consider how are you going to route requests among your containers
    if you have multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have an external load balancer, such as an ELB in AWS, or
    a dedicated device in front of an on-premise cluster, do you have the ability
    to dynamically add routes for traffic hitting `port x` on your Load Balancer to
    `port y` on your Docker hosts, at which point the traffic is then routed through
    to your container?
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple containers that all need to be accessible on the same external
    port, how are you going handle that?
  prefs: []
  type: TYPE_NORMAL
- en: Do you need to install a proxy such as Traefik, HAProxy, or nginx to accept
    and then route your requests based on virtual hosts based on domains or subdomains,
    rather than just using port-based routing?
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could use just ports for a website, everything on ports `80`
    and `443` to the container that is configured by Docker, to accept traffic on
    those ports. Using virtual host routing means that you can route `domain-a.com`
    to `container a` and then [domainb.com](https://www.domain-b.com/) to `container
    b`. Both `domain-a.com` and `domain-b.com` can point toward the same IP address
    and port.
  prefs: []
  type: TYPE_NORMAL
- en: Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of what we have discussed in the previous section can be solved by introducing
    clustering tools, such as Docker Swarm and Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though an application works fine on a developer's local Docker installation,
    you need to be able to guarantee that if you take the application and deploy it
    to, for example, a Kubernetes cluster, it works in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Nine out of ten times, you will not have a problem, but you do need to consider
    how the application is communicating internally with other containers within the
    same application set.
  prefs: []
  type: TYPE_NORMAL
- en: Reference architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are there reference architectures available for your chosen clustering technology?
    It is always best to check when deploying a cluster. There are best practice guides
    that are close to or match your proposed environment. After all, no one wants
    to create one big single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Also, what are the recommended resources? There is no point in deploying a cluster
    with five management nodes and a single Docker host, just like there is little
    point in deploying five Docker hosts and single management server, as you have
    quite a large single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: What supporting technologies does your cluster technology support (for example,
    remote storage, load balancers, and firewalls)?
  prefs: []
  type: TYPE_NORMAL
- en: Cluster communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the requirements when it comes to the cluster communicating with either
    management or Docker hosts? Do you need an internal or separate network to isolate
    the cluster traffic?
  prefs: []
  type: TYPE_NORMAL
- en: Can you easily lock a cluster member down to only your cluster? Is the cluster
    communication encrypted? What information about your cluster could be exposed?
    Does this make it a target for hackers?
  prefs: []
  type: TYPE_NORMAL
- en: What external access does the cluster need to APIs, such as your public cloud
    providers? How securely are any API/access credentials stored?
  prefs: []
  type: TYPE_NORMAL
- en: Image registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is your application packaged? Have you baked the code into the image? If
    so, do you need to host a private local image registry, or are you okay with using
    an external service such as Docker Hub, Docker Trusted Registry (DTR), or Quay?
  prefs: []
  type: TYPE_NORMAL
- en: If you need to host your own private registry, where in your environment should
    it sit? Who has or needs access? Can it hook into your directory provider, such
    as an Active Directory installation?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a few different workflows for Docker along with
    how to get some monitoring for your containers and Docker hosts up and running.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing you can do when it comes to your own environment is building
    a proof of concept and trying as hard as you can to cover every disaster scenario
    you can think of. You can get a head start by using the container services provided
    by your cloud provider or by looking for a good reference architecture, which
    should all limit your trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at what your next step in the
    world of containers could be.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which container serves our WordPress website?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why doesn't the `wp` container remain running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In minutes, how long does cadvisor keep metrics for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Docker Compose command can be used to remove everything to do with the
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find details on the software we have used in this chapter at the following
    sites:'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress: [http://wordpress.org/](http://wordpress.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WP-CLI: [https://wp-cli.org/](https://wp-cli.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHP-FPM: [https://php-fpm.org/](https://php-fpm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'cAdvisor: [https://github.com/google/cadvisor/](https://github.com/google/cadvisor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana: [https://grafana.com/](https://grafana.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prometheus data model: [https://prometheus.io/docs/concepts/data_model/](https://prometheus.io/docs/concepts/data_model/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Traefik: [https://traefik.io/](https://traefik.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HAProxy: [https://www.haproxy.org/](https://www.haproxy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NGINX: [https://nginx.org/](https://nginx.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heroku: [https://www.heroku.com](https://www.heroku.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other externally hosted Docker monitoring platforms include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sysdig Cloud: [https://sysdig.com/](https://sysdig.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datadog: [http://docs.datadoghq.com/integrations/docker/](http://docs.datadoghq.com/integrations/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CoScale: [http://www.coscale.com/docker-monitoring](http://www.coscale.com/docker-monitoring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynatrace: [https://www.dynatrace.com/capabilities/microservices-and-container-monitoring/](https://www.dynatrace.com/capabilities/microservices-and-container-monitoring/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SignalFx: [https://signalfx.com/docker-monitoring/](https://signalfx.com/docker-monitoring/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New Relic: [https://newrelic.com/partner/docker](https://newrelic.com/partner/docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sematext: [https://sematext.com/docker/](https://sematext.com/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also other self-hosted options, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Elastic Beats: [https://www.elastic.co/products/beats](https://www.elastic.co/products/beats)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sysdig: [https://www.sysdig.org](https://www.sysdig.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zabbix: [https://github.com/monitoringartist/zabbix-docker-monitoring](https://github.com/monitoringartist/zabbix-docker-monitoring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
