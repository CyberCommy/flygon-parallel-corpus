- en: Chapter 5. Symfony at a Glance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Full-stack frameworks like Symfony help ease the process of building modular
    applications by providing all of the necessary components, from user interface
    to data store. This enables a much rapid cycle of delivering individual bits and
    pieces of application as it grows. We will experience this later on by segmenting
    our application in several smaller modules, or bundles in Symfony terminology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward we will install Symfony, create a blank project, and start looking
    into individual framework features essential for building modular application:'
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bundle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases and Doctrine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Symfony
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Symfony is pretty straightforward. We can use the following command
    to install Symfony on Linux or Mac OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following command to install Symfony on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once the command is executed, we can simply move the newly created `symfony`
    file to our project directory and execute it further as `symfony`, or `php symfony`
    in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should trigger an output shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Symfony](graphics/B05460_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preceding response indicates we have successfully setup Symfony and are now
    ready to start creating new projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a blank project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a Symfony installer all setup, let''s go ahead and create
    a new blank project. We do so by simply executing a `symfony new test-app` command,
    as shown in the following command line instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a blank project](graphics/B05460_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we are creating a new project, called `test-app`. We can see that the Symfony
    installer is downloading the latest Symfony framework from the internet, alongside
    outputting a brief instruction on how to run the built in PHP server via Symfony
    console application. The whole process might take up to a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of newly created `test-app` directory occurs similar to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a blank project](graphics/B05460_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are numerous files and directories created here for us. Our interest,
    however, is focused on `app` and `src` directories. The `app` directory is where
    the site wide application configuration resides. Here we can find configuration
    for database, routing, security, and other services. Also, this is where default
    layout and template file reside, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a blank project](graphics/B05460_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `src` directory on the other hand contains already modularized code in
    form of the base `AppBundle` module, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a blank project](graphics/B05460_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to speak about the role of these files in more details later as
    we progress. For now, its worth nothing that pointing our browser to this project
    would make `DefaultController.php` the one to actually render the output.
  prefs: []
  type: TYPE_NORMAL
- en: Using Symfony console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Symfony framework comes with a built-in console tool that we can trigger by
    simply executing the following command within our project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing so, an extensive list of available commands is shown on screen, sectioned
    into the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doctrine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swiftmailer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These empower us with various functionalities. Our special interest moving forward
    is going to be around `doctrine` and `generate` commands. The `doctrine` command,
    more specifically `doctrine:generate:crud`, generates a CRUD based on an existing
    Doctrine entity. Furthermore, the `doctrine:generate:entity` command generates
    a new Doctrine entity inside an existing bundle. These can be extremely handy
    for cases where we want a quick and easy entity creation, alongside the entire
    CRUD around it. Similarly, `generate:doctrine:entity` and `generate:doctrine:crud`
    do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go ahead and test these commands, we need to make sure we have our
    database configuration parameters in place so that Symfony can see and talk to
    our database. To do so, we need to set appropriate values in `app/config/parameters.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this section, let''s go ahead and create a simple Customer
    entity within the default `AppBundle` bundle, with entire CRUD around it, assuming
    the following properties on Customer entity: `firstname`, `lastname`, and `e-mail`.
    We start by running the `php bin/console generate:doctrine:entity` command from
    within the project root directory, which results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we first provided `AppBundle:Customer` as entity name and confirmed the
    use of annotations as configuration format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are asked to start adding the fields to our entity. Typing in the
    first name and hitting enter moves us through a series of short questions about
    our field type, length, nullable, and unique states, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We should now have two classes generated for our Customer entity. Via the help
    of Symfony and Doctrine, these classes are put in context of **Object Relational
    Mapper** (**ORM**), as they link the Customer entity with the proper database
    table. However, we haven''t yet instructed Symfony to actually create the table
    for our entity. To do so, we execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now take a look at the database, we should see a `customer` table with
    all the proper columns created with SQL create dsyntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we still do not have an actual CRUD functionality in place.
    We simply have an ORM empowered Customer entity class and appropriate database
    table behind it. The following command will generate the actual CRUD controllers
    and templates for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following interactive output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By providing the fully classified entity name `AppBundle:Customer`, generator
    proceeds with a series of additional inputs, from generating write actions, type
    of configuration to read, to prefix of route, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, we should be able to access our Customer CRUD actions by simply
    opening a URL like `http://test.app/customer/` (assuming `test.app` is the host
    we set for our example) as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on the **Create a new entry** link, we will be redirected to the
    `/customer/new/` URL, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we can enter the actual values for our Customer entity and click **Create**
    button in order to persist it into the database `customer` table. After adding
    a few entities, the initial `/customer/` URL is now able to list them all, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we see links to **show** and **edit** actions. The **show** action is
    what we might consider the customer facing action, whereas the **edit** action
    is the administrator facing action. Clicking on the **edit** action, takes us
    to the URL of the form `/customer/1/edit/`, whereas number `1` in this case is
    the ID of customer entity in database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can change the property values and click **Edit** to persist them back
    into the database, or we can click on the **Delete** button to remove the entity
    from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to create a new entity with an already existing e-mail, which is
    flagged as a unique field, the system would throw a generic error as such the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Symfony console](graphics/B05460_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is merely default system behavior, and as we progress further we will look
    into making this more user friendly. By now, we have seen how powerful Symfony's
    console is. With a few simple commands, we were able to create our entity and
    its entire CRUD actions. There is plenty more the console is capable of. We can
    even create our own console commands as we can implement any type of logic. However,
    for the purpose of our needs, current implementation will suffice for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controllers play a major role in web applications by being at the forefront
    of any application output. They are the endpoints, the code that executes behind
    each URL. In a more technical manner, we can say the controller is any callable
    (a function, method on an object, or a closure) that takes the HTTP request and
    returns an HTTP response. The response is not bound to a single format like HTML,
    it can be anything from XML, JSON, CSV, image, redirect, error, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the previously created (partial) `src/AppBundle/Controller/CustomerController.php`
    file, more precisely its `newAction` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ignore the actual data retrieval part (`//…`), there are three important
    things to note in this little example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Route`: this is the Symfony''s annotation way of specifying HTTP endpoint,
    the URL we will use to access this. The first `"/new"` parameter states the actual
    endpoint, the second `name="customer_new"` parameter sets the name for this route
    that we can then use as an alias in URL generation functions in templates and
    so on. It is worth noting, that this builds upon the `@Route("/customer")` annotation
    set on the actual `CustomerController` class where the method is defined, thus
    making for the full URL to be something like `http://test.app/customer/new`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Method`: This takes the name of one or more HTTP methods. This means that
    the `newAction` method will trigger only if the HTTP requests match the previously
    defined `@Route` and are of one or more HTTP method types defined in `@Method`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->render`: This returns the `Response` object. The `$this->render` calls
    the `render` function of the `Symfony\Bundle\FrameworkBundle\Controller\Controller`
    class, which instantiates new `Response()`, sets its content, and returns the
    whole instance of that object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the `editAction` method within our controller, as
    partially shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a route that accepts a singe ID, marked as `{id}` within the first
    `@Route` annotation parameter. The body of the method (excluded here), does not
    contain any direct reference to fetching the `id` parameter. We can see that the
    `editAction` function accepts two parameters, one being `Request`, the other being
    `Customer`. But how does the method know to accept the `Customer` object? This
    is where Symfony's `@ParamConverter` annotation comes into play. It calls converters
    to convert the request parameters to objects.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about `@ParamConverter` annotation is that we can use it explicitly
    or implicitly. That is, if we do not add `@ParamConverter` annotation but add
    type hinting to the method parameter, Symfony is going to try and load the object
    for us. This is the exact case we have in our example above, as we did not explicitly
    type the `@ParamConverter` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology wise, controllers are often exchanged for routing. However, they
    are not the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the shortest terms, routing is about linking the controllers with URLs entered
    in browser. Todays modern web applications need nice URLs. This means moving away
    from URLs like `/index.php?product_id=23` to something like `/catalog/product/t-shirt`.
    This is where routing comes in to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symfony has a powerful routing mechanism that enables us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create complex routes which map to controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate URLs inside templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate URLs inside controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load routing resources from various locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way routing works in Symfony is that all of the requests come through `app.php`.
    Then, the Symfony core asks the router to inspect the request. The router then
    matches the incoming URL to a specific route and returns information about the
    route. This information, among other things, includes the controller that should
    be executed. Finally, the Symfony kernel executes the controller, which returns
    a response object.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the application routes are loaded from a single routing configuration
    file, usually `app/config/routing.yml` file, as shown by our test app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The app is simply one of many possible entries. Its resource value points to
    `AppBundle` controller directory, and type is set to annotation which means that
    the class annotations will be read to specify exact routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a route with several variations. One of them is shown in the
    following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding examples show several ways we can define our route. The interesting
    one is the case with required and optional parameter. If we think about it, removing
    ID from the latest example will match the example before it with sku. The Symfony
    router will always choose the first matching route it finds. We can solve the
    problem by adding regular expression requirements attributed on `@Route` annotation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is more to be said about controllers and routing, as we will see once
    we start building our application.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously we said that controllers accept request and return response. The
    response, however, can often be any content type. The production of actual content
    is something controllers delegate to the templating engine. The templating engine
    then has the capability to turn the response into HTML, JSON, XML, CSV, LaTeX,
    or any other text-based content type.
  prefs: []
  type: TYPE_NORMAL
- en: In the old days, programmers mixed PHP with HTML into the so called PHP templates
    (`.php` and `.phtml`). Though still used with some platforms, this kind of approach
    is considered insecure and lacking in many aspects. One of which was cramming
    business logic into template files.
  prefs: []
  type: TYPE_NORMAL
- en: To address these shortcomings, Symfony packs its own templating language called
    Twig. Unlike PHP, Twig is meant to strictly express presentation and not to thinker
    about program logic. We cannot execute any of the PHP code within the Twig. And
    the Twig code is nothing more than an HTML with a few special syntax types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Twig defines three types of special syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ ... }}`: This outputs variable or the result of an expression to the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{% ... %}`: This tag controls the logic of the template (`if` and `for` loops,
    and others).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{# ... #}`: It is the equivalent of the PHP `/* comment */` syntax. The Comments
    content isn''t included in the rendered page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filters are another nice feature of Twig. They act like chained method calls
    upon a variable value, modifying the content before it is outputted, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It also supports functions listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding random function call would return one random value from within
    the array. With all the built-in list of filters and functions, Twig also allows
    for writing our own if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to PHP class inheritance, Twig also supports template and layout inheritance.
    Let''s take a quick look back at the the `app/Resources/views/customer/index.html.twig`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see a customer `index.html.twig` template using the `extends` tag to
    extend a template from another one, in this case `base.html.twig` found in `app/Resources/views/`
    directory with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see several block tags: `title`, `stylesheets`, `body`, and `javascripts`.
    We can declare as many blocks as we want here and name them any way we like. This
    makes the `extend` tag a key to template inheritance. It tells the Twig to first
    evaluate the base template, which sets the layout and defines blocks, after which
    the child template like `customer/index.html.twig` fills in the content of these
    blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates live in two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/Resources/views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bundle-directory/Resources/views/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is in order to `render/extend app/Resources/views/base.html.twig`
    we would use `base.html.twig` within our template file, and to `render/extend
    app/Resources/views/customer/index.html.twig` we would use the `customer/index.html.twig`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: When used with templates that reside in bundles, we have to reference them slightly
    differently. In this case, the `bundle:directory:filename` string syntax is used.
    Take the `FoggylineCatalogBundle:Product:index.html.twig` path for example. This
    would be a full path to use one of the bundles template file. Here the `FoggylineCatalogBundle`
    is a bundle name, `Product` is a name of a directory within that bundle `Resources/views`
    directory, and `index.html.twig` is the name of the actual template within the
    `Product` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Each template filename has two extensions that first specify the format and
    then the engine for that template; such as `*.html.twig`, `*.html.php`, and`*.css.twig`.
  prefs: []
  type: TYPE_NORMAL
- en: We will get into more details regarding these templates once we move onto building
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sign up, sign in, add to cart, checkout, all of these and more are actions that
    make use of HTML forms in web shop applications and beyond. Building forms is
    one of the most common tasks for developers. One that often takes time to do it
    right.
  prefs: []
  type: TYPE_NORMAL
- en: Symfony has a `form` component through which we can build HTML forms in an OO
    way. The component itself is also a standalone library that can be used independently
    of Symfony.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the content of the `src/AppBundle/Entity/Customer.php`
    file, our `Customer` entity class that was auto-generated for us when we defined
    it via console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a plain PHP class, which does not extend anything nor is in any
    other way linked to Symfony. It represents a single customer entity, for which
    it sets and gets the data. With the entity class in place, we would like to render
    a form that will pick up all of the relevant data used by our class. This is where
    the `Form` component comes in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we used the CRUD generator via console earlier, it created the `Form`
    class for our Customer entity within the `src/AppBundle/Form/CustomerType.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the simplicity behind the form component comes down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extend form type**: We extend from `Symfony\Component\Form\AbstractType`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement buildForm method**: This is where we add actual fields we want
    to show on the form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement configureOptions**: This specifies at least the `data_class` configuration
    which points to our Customer entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The form builder object is the one doing the heavy lifting here. It does not
    take much for it to create a form. With the `form` class in place, let''s take
    a look at the `controller` action in charge of feeding the template with the form.
    In this case, we will focus on `newAction` within the `src/AppBundle/Controller/CustomerController.php`
    file, with content shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first instantiates the `Customer` entity class. The `$this->createForm(…)`
    is actually calling `$this->container->get('form.factory')->create(…)`, passing
    it our `form` class name and instance of `customer` object. We then have the `isSubmitted`
    and `isValid` check, to see if this is a GET or valid POST request. Based on that
    check, the code either returns to customer listing or sets the `form` and `customer`
    instance to be used with the template `customer/new.html.twig`. We will speak
    more about the actual validation later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, lets take a look at the actual template found in the `app/Resources/views/customer/new.html.twig`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see `extends` and `block` tags, alongside some form of related functions.
    Symfony adds several form rendering function to Twig as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`form(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_start(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_end(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_label(view, label, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_errors(view)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_widget(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_row(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_rest(view, variables)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of our application forms will be auto-generated like this one, so we are
    able to get a fully functional CRUD without going too deep into the rest of form
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Symfony
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to keep up with modern demands, today's frameworks and applications
    require a flexible configuration system. Symfony fulfils this role nicely through
    its robust configuration files and environments concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default Symfony configuration file `config.yml` is located under the `app/config/`
    directory, with (partial) content sectioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The top-level entries like `framework`, `twig`, `doctrine`, and `swiftmailer`
    define the configuration of an individual bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the configuration file can be of XML or PHP format (`config.xml`
    or `config.php`). While YAML is simple and readable, XML is more powerful, whereas
    PHP is powerful but less readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the console tool to dump the entire configuration as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example lists the config file for core `FrameworkBundle`. We can
    use the same command to show possible configurations for any bundle that implements
    container extension, something we will look into later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symfony has a nice implementation of environment concept. Looking into the
    `app/config` directory, we can see that default Symfony project actually starts
    with three different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config_dev.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_prod.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config_test.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each application can run in various environments. Each environment shares the
    same code, but different configuration. Whereas dev environment might make use
    of extensive logging, a prod environment might make use of extensive caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way these environments get triggered is via the front controller file,
    as in the following partial examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The test environment is missing here, as it is used only when running automated
    tests and cannot be accessed directly via a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app/AppKernel.php` file is the one that actually loads the configuration,
    whether it is YAML, XML, or PHP as shown in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The environments follow the same concept, whereas each environment imports the
    base configuration file and then modifies its values to suit the needs of the
    specific environment.
  prefs: []
  type: TYPE_NORMAL
- en: The bundle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the popular frameworks and platforms support some form of modules, plugins,
    extensions or bundles. For most of the time, the difference really lies just in
    the naming, while the concept of extensibility and modularity is the same. With
    Symfony, these modular blocks are called bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Bundles are a first-class citizen in Symfony, as they support all of the operations
    available to other components. Everything in Symfony is a bundle, even the core
    framework. Bundles enable us to build modularized applications, whereas the entire
    code for a given feature is contained within a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: A single bundle holds all its PHP files, templates, style sheets, JavaScript
    files, tests, and anything else in one root directory.
  prefs: []
  type: TYPE_NORMAL
- en: When we first setup our test app, it created an `AppBundle` for us, under the
    `src` directory. As we moved forward with the auto-generated CRUD, we saw our
    bundle getting all sorts of directories and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a bundle to be noticed by Symfony, it needs to be added to the `app/AppKernel.php`
    file, with the `registerBundles` method as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new bundle is as simple as creating a single PHP file. Let''s go
    ahead and create an `src/TestBundle/TestBundle.php` file with content that looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file is in place, all we need to do is to register it via the `registerBundles`
    method of the `app/AppKernel.php` file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'An even easier way to create a bundle would be to just run a console command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This would trigger a series of questions about bundle that in the end results
    in bundle creation that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bundle system](graphics/B05460_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the process is complete, a new bundle with several directories and files
    is created as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bundle system](graphics/B05460_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bundle generator was kind enough to create controller, dependency injection
    extension extension, routing, prepare services configuration, templates, and even
    tests. Since we chose to share our bundle, Symfony opted for XML as default configuration
    format. The dependency extension simply means we can access our bundle configuration
    by using `foggyline_test` as the root element in Symfony's main `config.yml`.
    The actual `foggyline_test` element is defined within the `DependencyInjection/Configuration.php`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Databases and Doctrine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases are the backbone of almost every web application. Every time we need
    to store or retrieve data, we do so with the help of databases. The challenge
    in the modern OOP world is to abstract the database so that our PHP code is database
    agnostic. MySQL is probably the most known database in the PHP world. PHP itself
    has a great support for working with MySQL, whether it is via the `mysqli_*` extension
    or via PDO. However, both approaches are MySQL specific, to o close to database.
    Doctrine solves this problem by introducing a level of abstraction, enabling us
    to work with PHP objects that represent tables, rows, and their relations in MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine is completely decoupled from Symfony, so using it is completely optional.
    The great thing about it, however, is that the Symfony console provides great
    auto-generated CRUD based on Doctrine ORM, as we saw in previous examples when
    creating Customer entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we created the project, Symfony provided us with an auto-generated
    `app/config/parameters.yml` file. This is the file in which we, among other things,
    provide database access information as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once we configure proper parameters, we can use console generation features.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that parameters within this file are merely a convention,
    as `app/config/config.yml` is pulling them under `doctrine dbal` configuration
    like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The Symfony console tool allows us to drop and create a database based on this
    config, which comes in handy during development, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw previously how the console tool enables us to create entities and their
    mapping into database tables. This will suffice for our needs throughout this
    book. Once we have them created, we need to be able to perform CRUD operations
    on them. If we gloss over the auto-generated CRUD controller `src/AppBundle/Controller/CustomerController.php`
    file, we can the CRUD related code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot more to be said about Doctrine, which is far out of the scope
    of this book. More information can be found at the official page ([http://www.doctrine-project.org](http://www.doctrine-project.org)).
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays testing has become an integral part of every modern web application.
    Usually the term testing implies unit and functional testing. Unit testing is
    about testing our PHP classes. Every single PHP class is considered to be a unit,
    thus the name unit test. Functional tests on the other hand test various layers
    of our application, usually concentrated on testing the functionality overall,
    like the sign in or sign up process.
  prefs: []
  type: TYPE_NORMAL
- en: The PHP ecosystem has a great unit testing framework called **PHPUnit**, available
    for download at [https://phpunit.de](https://phpunit.de). It enables us to write
    primarily unit, but also functional type tests. The great thing about Symfony
    is that it comes with built in support for PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start running Symfony's tests, we need to make sure we have PHPUnit
    installed and available as console command. When executed, PHPUnit automatically
    tries to pick up and read testing configuration from `phpunit.xml` or `phpunit.xml.dist`
    within the current working directory, if available. By default Symfony comes with
    a `phpunit.xml.dist` file in its root folder, thus making it possible for the
    `phpunit` command to pick up its test configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a partial example of a default `phpunit.xml.dist` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `testsuites` element defines the directory tests, in which all of our tests
    are located. The `filter` element with its children is used to configure the whitelist
    for the code coverage reporting. The `php` element with its children is used to
    configure PHP settings, constants, and global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a `phpunit` command against a default project like ours would result
    in output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing](graphics/B05460_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that bundle tests are not automatically picked up. Our `src/AppBundle/Tests/Controller/CustomerControllerTest.php`
    file, which was created for us automatically when we used auto-generated CRUD,
    was not executed. Not because its content is commented out by default, but because
    the `bundle` test directory isn''t visible to `phpunit`. To make it execute, we
    need to extend the `phpunit.xml.dist` file by adding to directory `testsuite`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how we build our application, we might want to add all of our bundles
    to the `testsuite` list, even if we plan on distributing bundles independently.
  prefs: []
  type: TYPE_NORMAL
- en: There is plenty more to be said about testing. We will do so bit by bit as we
    progress through further chapters and cover the needs of individual bundles. For
    the moment, it is suffice to know how to trigger tests and how to add new locations
    to testing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validation plays an essential role in modern applications. When talking about
    web applications, we can say we differentiate between two main types of validation;
    form data and persisted data validation. Taking input from a user via a web form
    should be validated, the same as any persisting data that goes into a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symfony excels here by providing a Validation component based on JSR 303 Bean
    Validation drafted and available at [http://beanvalidation.org/1.0/spec/](http://beanvalidation.org/1.0/spec/).
    If we look back at our `app/config/config.yml`, under the `framework` root element,
    we can see that the `validation` service is turned on by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the validation service from any controller class by simply calling
    it via the `$this->get(''validator'')` expression, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the example above is that validation would never return any
    errors. The reason for this is that we do not have any assertions set on our class.
    The console auto-generated CRUD did not really define any constraints on our `Customer`
    class. We can confirm that by trying to add a new customer and typing in any text
    in the e-mail field, as we can see the e-mail wont be validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and edit the `src/AppBundle/Entity/Customer.php` file by adding
    the `@Assert\Email` function to the `$email` property like the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about assertions constraints is that they accept parameters
    just as functions. We can therefore fine-tune individual constraints to our specific
    needs. If we now try to skip or add a faulty e-mail address, we would get a message
    like **Email "john@gmail.test" is invalid**.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous constraints available, for the full list we can consult the
    [http://symfony.com/doc/current/book/validation.html](http://symfony.com/doc/current/book/validation.html)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints can be applied to a class property or a public getter method. While
    the property constraints are most common and easy to use, the getter method constraints
    allow us to specify more complex validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take look at the `newAction` method of an `src/AppBundle/Controller/CustomerController.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here we see an instance of a `CustomerType` form being bind to the `Customer`
    instance. The actual GET or POST request data is passed to an instance of a form
    via the `handleRequest` method. The form is now able to understand entity validation
    constraints and respond properly via its `isValid` method call. What this means
    is that we do not have to manually validate by using the validation service ourselves,
    the forms can do it for us.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue to expand on validation features as we progress through individual
    bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we touched on some important functionality, which makes
    Symfony so great. Controllers, templates, Doctrine, ORM, forms, and validation
    make for a complete solution from data presentation and persistence. We have seen
    the flexibility and power behind each of the components. The bundle system takes
    it a step further by wrapping these into individual mini applications, or modules.
    We are now able to take full control of incoming HTTP requests, manipulate the
    data store, and present data to the user, all of this within a single bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will utilize the insights and knowledge
    gained throughout the previous chapters to finally start building our modular
    application according to the requirements.
  prefs: []
  type: TYPE_NORMAL
