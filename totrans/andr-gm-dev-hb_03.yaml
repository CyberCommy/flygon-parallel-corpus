- en: Chapter 3. Different Android Development Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed the different Android target devices for game development.
    In this chapter, we will take a look at the different ways and tools to develop
    games for Android. Other than development skill and knowledge, it is very important
    to know about the helpful software that can make the development process easier
    and effective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android game development is supported or backed by many powerful tools and
    libraries. Let''s have a look at the list of mandatory tools for the development
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Development Tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Virtual Device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Debug Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dalvik Debug Monitor Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the must-have tools that should be installed in an Android game developer's
    system. Without these, it is impossible to develop anything for the Android platform.
    Although ADB and AVD are not mandatory for development, they are required to test
    and deploy the game on physical as well as virtual devices in order to debug the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android SDK is the main development kit required to build any application for
    Android. Without going into details, it can be said that the SDK is the skeleton
    for any Android development. This SDK itself comes with dozens of support tools.
    It contains platform details, APIs, and libraries along with ADT and AVD. So having
    Android SDK integrated in the system provides the developer with all the necessary
    tools. It is a very good practice to always update the SDK with the latest platforms
    and other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrading can be done through the Android SDK manager. However, platform selection
    is manual, and it is recommended to have only the necessary platforms as per requirements.
    Another best practice is to have the latest released platform along with the minimum
    targeted version of Android (image source: [http://photos4.meetupstatic.com/photos/event/1/1/0/f/highres_441724367.jpeg](http://photos4.meetupstatic.com/photos/event/1/1/0/f/highres_441724367.jpeg)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android SDK](img/B05069_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Android Development Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Android Development Tool** (**ADT**) is a plugin for the Eclipse IDE that
    is designed to give a powerful, integrated environment in which to build Android
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: ADT extends the capabilities of Eclipse to let the developer quickly set up
    new Android projects, create an application UI, add packages based on the Android
    framework API, debug the applications using the Android SDK tools, and even export
    signed (or unsigned) `.apk` files in order to distribute the application.
  prefs: []
  type: TYPE_NORMAL
- en: Developing in Eclipse with ADT is highly recommended, and is the fastest way
    to get started. With the guided project setup it provides, as well as tools integration,
    custom XML editors, and the debug output pane, ADT gives an incredible boost to
    developing Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, ADT support for Eclipse is being pulled by Google, so developers are
    recommended to switch to Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Android Virtual Device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **Android Virtual Device** (**AVD**) is a software-produced model of a real
    device, which can be configured with custom hardware specifications. It can be
    a virtual copy of the real device as well. This is one of the most important tools
    for any Android developer. This lets the developer test the application in a typical
    Android environment without using an actual hardware device, to cut short the
    development time (image source: [http://www.geeknaut.com/images/2014/08/top-android-emulators-for-windows3.png](http://www.geeknaut.com/images/2014/08/top-android-emulators-for-windows3.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android Virtual Device](img/B05069_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring AVD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An AVD consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware profile**: This profile describes the hardware features of the virtual
    device. This can be configured with hardware options like a QWERTY keypad, camera,
    integrated memory, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System image mapping**: The running Android platform version can be configured
    depending on the installed set of Android platforms. Android platforms can be
    installed by the Android SDK manager.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dedicated disk space**: Dedicated storage area on your development machine
    can be set with this feature, which saves the emulator''s user data and the virtual
    SD card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other features**: The developer can even specify the look and feel of the
    virtual device such as device skin, screen dimension, and appearance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the brief procedure to create an AVD through AVD manager,
    which is located in the `<SDK Path>/tools` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: On the main screen, click on **Create Virtual Device**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Select Hardware** window, select a device configuration such as **Nexus
    5**, then click on **Next**, then click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To begin customizing the device by using an existing device profile as a template,
    select a device profile and then click on **Clone Device**. Or, to create a complete
    custom emulator, click on **New Hardware Profile**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the following to create a new custom emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Device name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensor options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After setting every property, click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The developer can also create a new custom emulator using the command line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the following options can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This will be the custom AVD name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetID`: This will be the custom ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`option`: This can include options such as device screen density, resolution,
    camera, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The developer can execute this command to use a previously defined AVD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the developer can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Android Debug Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Android Debug Bridge** (**adb**) is a tool used to establish communication
    between the development environment and a virtual device or the connected Android
    device. It is a client-server command-line program, which works on three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client on the development machine**: Works as the client, which can be invoked
    by adb commands. Other Android tools such as the ADT plugin and DDMS also create
    adb clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Daemon**: A background process that runs in the background on each emulator
    or device instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server on the development machine**: This is a background process that runs
    on the development machine and manages the communication between the client and
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On starting adb, the client first checks whether there is an adb server process
    already running. If there isn't, it starts the server process. When the server
    starts, it binds to the local TCP port `5037` and listens for commands sent from
    adb clients—all adb clients use port `5037` to communicate with the adb server.
  prefs: []
  type: TYPE_NORMAL
- en: The server then sets up connections to all running emulator/device instances.
    It locates emulator/device instances by scanning odd-numbered ports in the range
    `5555` to `5585`, the range used by emulators/devices. Where the server finds
    an adb daemon, it sets up a connection to that port. Note that each emulator/device
    instance acquires a pair of sequential ports—an even-numbered port for console
    connections and an odd-numbered port for adb connections.
  prefs: []
  type: TYPE_NORMAL
- en: Once the server has set up connections to all emulator instances, the developer
    can use adb commands to access those instances. Because the server manages connections
    to emulator/device instances, and handles commands from multiple adb clients,
    the developer can control any emulator/device instance from any client (or from
    a script).
  prefs: []
  type: TYPE_NORMAL
- en: Using adb on an Android device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first things to remember is to put the development device in the
    USB debugging mode. This can be done by navigating to Settings, tapping on **Developer
    options**, and checking the box named **USB debugging** for Android 5.0 and above
    (for other Android versions, refer to [https://www.recovery-android.com/enable-usb-debugging-on-android.html](https://www.recovery-android.com/enable-usb-debugging-on-android.html)).
    Without doing this, the development PC won't recognize the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to know is simply how to get to the adb folder via
    the command line. This is done with the `cd` (change directory) command. So, if
    (on Windows) the SDK folder is called `android-SDK`, and it''s in the root (`c:`)
    directory, you can enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to get into the adb folder, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the prompt will say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the developer can connect the device, and test the adb connection, after
    locating and installing the drivers for a particular device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If everything is set up properly, there should be a list of devices attached.
    The phone or tablet will have a number assigned to it, so don't be surprised if
    it doesn't say "Droid Razr" or "Galaxy Nexus".
  prefs: []
  type: TYPE_NORMAL
- en: For average users, adb is more of a tool for basic hacking tasks than it is
    a task in itself. Unless the developers know what they are doing, they probably
    shouldn't go poking around too much without clear instructions. When rooting the
    device, knowing these basics can help save some time and let the developer be
    prepared in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Beside the specific instructions to root a particular device, the next thing
    the developer needs will be the drivers for the phone or tablet.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is usually to simply Google search for the *specific
    device plus drivers*. So if the developer has a Droid Razr, he/she should search
    for `Droid Razr Windows Drivers`. This will almost always direct the developer
    to the best link.
  prefs: []
  type: TYPE_NORMAL
- en: Another option, which will only work for stock Android devices, is to download
    the USB drivers from the SDK. To do this, launch the SDK manager again. Go to
    the **Available packages** tab on the left, expand the **Third party add-ons**
    entry, and then expand the **Google Inc. add-ons** entry. Finally, check the entry
    for the **Google USB Driver** package.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the USB driver package isn't compatible with OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Dalvik Debug Monitor Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Dalvik Debug Monitor Server** (**DDMS**), whether it''s accessed through
    the standalone application or the Eclipse perspective with the same name, provides
    handy features for inspecting, debugging, and interacting with emulator and device
    instances. You can use DDMS to inspect running processes and threads, explore
    the filesystem, gather heap and other memory information, attach debuggers, and
    even take screenshots. For emulators, you can also simulate mock location data,
    send SMS messages, and initiate incoming phone calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dalvik Debug Monitor Server](img/B05069_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the preceding screenshot shows, DDMS can primarily track, update, and display
    the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: All running processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All running threads per process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumed heap per process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Android, every application runs in its own process, each of which runs in
    its own virtual machine. The debugger can be attached to the exposed port of VM.
    DDMS connects to adb on start. On successful connection, a VM monitoring service
    is created between adb and DDMS, which informs DDMS upon starting and ending a
    VM on the device. DDMS retrieves the VM's process ID via adb, and opens a connection
    to the VM's debugger when there is an active VM running through the adb daemon
    on the device. DDMS can now communicate to the VM using a custom wire protocol.
  prefs: []
  type: TYPE_NORMAL
- en: DDMS also listens on the default debugging port, called **base port**. The base
    port is a port forwarder, which can accept VM traffic from any debugging port
    and forward it to the debugger. The traffic that is forwarded is determined by
    the currently selected process in the DDMS **Devices** view.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The elements mentioned in the previous sections are the minimum requirement
    for Android development, with which a full application can be created. However,
    the development process can become much easier with the support of a few other
    tools. Let's have a look at a few of such tools. These tools are not mandatory
    for Android development, but they are recommended to be used for a better development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Eclipse is not the only Java development environment that can be used
    to develop Android applications, it is by far the most popular. This is partially
    due to its cost (free!), but mostly due to the strong integration of Android tools
    with Eclipse. This integration is achieved with the ADT plugin for Eclipse, which
    can be downloaded from the Android website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use of Eclipse for Android development is a well-known practice for many developers.
    Some of the reasons for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Free Eclipse IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct Android plugin support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct DDMS support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android NDK support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The launch of Android Studio reduced the popularity of Eclipse among Android
    developers, because Android Studio has everything inbuilt to support any Android
    development. Moreover, it is a much simplified tool to use in design view. Google
    itself is promoting the new tool massively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few drawbacks in Eclipse Android development, because it uses Android
    SDK as a third-party tool. The significant drawbacks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging through Eclipse is sometimes difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADB configuration is tricky
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android manifest has to be managed manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design view is very complex through Eclipse IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse is an excellent standalone IDE, but when it comes to Android development,
    Android Studio wins the race.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy Viewer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hierarchy Viewer, whether it's accessed through the standalone application or
    the relatively new Eclipse perspective, is used to see how your layouts and screens
    resolve at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides a graphical representation of the layout and view hierarchy of
    your application, and can be used to diagnose layout problems (image source: [https://media-mediatemple.netdna-ssl.com/wp-content/uploads/2012/03/da_hierarchy_viewer.png](https://media-mediatemple.netdna-ssl.com/wp-content/uploads/2012/03/da_hierarchy_viewer.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hierarchy Viewer](img/B05069_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Draw 9-Patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to graphics design, the Draw 9-patch tool comes in handy. This
    tool allows you to convert traditional PNG graphic files into stretchable graphics
    that are more flexible and efficient for mobile development use. The tool simplifies
    the creation of NinePatch files in an environment that instantly displays the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Draw 9-Patch](img/B05069_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ProGuard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ProGuard is not directly associated with Android development, but it helps in
    protecting the intellectual property of the developer. It is a very common practice
    for Android game developers to use ProGuard.
  prefs: []
  type: TYPE_NORMAL
- en: ProGuard basically wraps the members and methods to a non-readable code structure.
    This tool can be configured to obfuscate the resulting binary. ProGuard also helps
    in optimizing the binary, so that the overall package size is reduced.
  prefs: []
  type: TYPE_NORMAL
- en: ProGuard can be difficult to use when developers try to integrate pre-compiled
    JARs into the Android project. Sometimes conflicts are created in class structures
    if the JAR is already optimized through ProGuard. In those situations, ProGuard
    must be configured to exclude the precompiled JARs in order to achieve a successful
    build.
  prefs: []
  type: TYPE_NORMAL
- en: It is always recommended to use ProGuard to protect the game classes from reverse
    engineering or decompilation.
  prefs: []
  type: TYPE_NORMAL
- en: Asset optimization tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We all know the vast range of Android hardware configurations. It is always
    necessary to optimize the assets to reduce runtime memory usage and unnecessary
    data processing. In games, graphical assets take most of the storage and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Full asset optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An unoptimized asset may hold some unnecessary data, like transparency information
    in an opaque asset, EXIF data, unused color information, extra bit depth, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Asset optimizer tools help to get rid of this burden. However, it is tricky
    to use such tools as the asset quality may be lost. A developer should be very
    cautious while using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an asset is supposed to be at 24 bit, but was optimized with
    an 8 bit optimizer tool, it will surely lose its visual quality. So, over-optimization
    is never recommended for any games, and it is the developer's responsibility to
    use proper optimization techniques to maintain the game quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few such asset optimizer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: PNGOUT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TinyPNG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RIOT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPEGmini
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PNGGauntlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the help of such tools, art assets can be optimized up to 80-90% of their
    size. But many developers don''t prefer to use them on a regular basis because
    of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The developers do not optimize each asset separately, which results in quality
    loss for a few assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is really difficult to choose the right tools for optimization. Sometimes,
    multiple tools are required for the same job, which slows down the overall development
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating sprites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, it is noticed that a large number of small art assets are being
    used in games individually. This may cause critical performance lag for the game.
    It is recommended to use a sprite building tool to merge those assets into one
    to save space and time. SpriteBuilder and TexturePacker are two good examples
    of such tools.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any development process, testing is of major importance. For Android game
    development too, there are a few tools and processes to make testing easier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activity tests are written in a structured way. Make sure to put your tests
    in a separate package, distinct from the code under test. By convention, your
    test package name should follow the same name as the application package, suffixed
    with `.tests`. In the test package you created, add the Java class for your test
    case. By convention, your test case name should also follow the same name as the
    Java or Android class that you want to test, but suffixed with `Test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new test case in Eclipse, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Package Explorer, right-click on the `/src` directory for your test project,
    and select **New** | **Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Name** field to `<package_name>.tests` (for example, `com.example.android.testingfun.tests`),
    and click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the test package you created, and select **New** | **Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Name** field to `<activity_name>Test` (for example, `MyFirstTestActivityTest`),
    and click on **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up your test fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A test fixture consists of objects that must be initialized for running one
    or more tests. To set up the test fixture, you can override the `setUp()` and
    `tearDown()` methods in your test. The test runner automatically runs `setUp()`
    before running any other test methods, and `tearDown()` at the end of each test
    method execution. You can use these methods to keep the code for test initialization
    and clean up separate from the tests methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a test fixture in Eclipse, follow the steps listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Package Explorer, double-click on the test case that you created earlier
    to bring up the Eclipse Java editor, then modify your test case class to extend
    one of the subclasses of `ActivityTestCase`. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the constructor and `setUp()` methods to your test case, and add
    variable declarations for the activity that you want to test. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is invoked by the test runner to instantiate the test class,
    while the `setUp()` method is invoked by the test runner before it runs any tests
    in the test class.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, in the `setUp()` method, you should invoke the superclass constructor
    for `setUp()`, which is required by JUnit
  prefs: []
  type: TYPE_NORMAL
- en: 'You can initialize your test fixture state by:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the instance variables that store the state of the fixture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating and storing a reference to an instance of the activity under test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtaining a reference to any UI components in the activity that you want to
    test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developers can use the `getActivity()` method to get a reference to the activity
    under test.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test preconditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a sanity check, it is good practice to verify that the test fixture has been
    set up correctly, and the objects that you want to test have been correctly instantiated
    or initialized. That way, you won't have to see tests failing because something
    was wrong with the setup of your test fixture. By convention, the method for verifying
    your test fixture is called `testPreconditions()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to add a `testPreconditions()` method like this
    to your test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The assertion methods are from the Junit `Assert` class. Generally, you can
    use assertions to verify if a specific condition that you want to test is true.
  prefs: []
  type: TYPE_NORMAL
- en: If the condition is false, the assertion method throws an `AssertionFailedError`
    exception, which is then typically reported by the test runner. You can provide
    a string in the first argument of your assertion method to give some contextual
    details if the assertion fails.
  prefs: []
  type: TYPE_NORMAL
- en: If the condition is true, the test passes. In both cases, the test runner proceeds
    to run the other test methods in the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test methods to verify an activity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, add one or more test methods to verify the layout and functional behavior
    of your activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your activity includes a TextView, you can add a test method
    like this to check that it has the correct label text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `testMyFirstTestTextView_labelText()` method simply checks that the default
    text of the TextView, which is set by the layout, is the same as the expected
    text defined in the `strings.xml` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When naming test methods, you can use an underscore to separate what is being
    tested from the specific case being tested. This style makes it easier to see
    exactly what cases are being tested.
  prefs: []
  type: TYPE_NORMAL
- en: When doing this type of string value comparison, it's a good practice to read
    the expected string from your resources instead of hardcoding the string in your
    comparison code. This prevents your test from easily breaking whenever the string
    definitions are modified in the resource file.
  prefs: []
  type: TYPE_NORMAL
- en: To perform the comparison, pass both the expected and actual strings as arguments
    to the `assertEquals()` method. If the values are not the same, the assertion
    will throw an `AssertionFailedError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: If you added a `testPreconditions()` method, put your test methods after the
    `testPreconditions()` definition in your Java class.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can build and run your test easily from the Package Explorer in Eclipse.
    To build and run your test, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect an Android device to your machine. On the device or emulator, open the
    **Settings** menu, select **Developer options**, and make sure that **USB debugging**
    is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project Explorer, right-click on the test class that you created earlier,
    and select **Run As** | **Android JUnit Test**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Android Device Chooser** dialog, select the device that you just connected,
    then click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JUnit view, verify that the test passes with no errors or failures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance profiling tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Putting pixels on the screen involves four primary pieces of hardware: the
    CPU computes display lists, the GPU renders images to the display, the memory
    stores images and data, and the battery provides electrical power. Each of these
    pieces of hardware has constraints; pushing or exceeding those constraints causes
    your app to be slow, worsens the display performance, or exhausts the battery.'
  prefs: []
  type: TYPE_NORMAL
- en: To discover what causes your specific performance problems, you need to take
    a look under the hood, use tools to collect data about your app's execution behavior,
    surface that data as lists and graphics, understand and analyze what you see,
    and improve your code.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio and your device provide profiling tools to record and visualize
    the rendering, computing, memory, and battery performance of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Studio is the official IDE for Android application development, based
    on IntelliJ IDEA. On top of the capabilities you expect from IntelliJ, Android
    Studio offers the following among many others:'
  prefs: []
  type: TYPE_NORMAL
- en: Flexible Gradle-based build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build variants and multiple `.apk` file generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code templates to help you build common app features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich layout editor with support for drag and drop theme editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lint tools to catch performance, usability, version compatibility, and other
    problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ProGuard and app-signing capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in support for the Google Cloud platform, making it easy to integrate
    Google Cloud messaging and App Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're new to Android Studio or the IntelliJ IDEA interface, this section
    provides an introduction to some key Android Studio features.
  prefs: []
  type: TYPE_NORMAL
- en: Android project view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Android Studio displays your project files in the Android project
    view. This view shows a flattened version of your project''s structure, which
    provides quick access to the key source files of Android projects, and helps you
    work with the Gradle-based build system. The Android project view:'
  prefs: []
  type: TYPE_NORMAL
- en: Shows the most important source directories at the top level of the module hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups the build files for all modules in a common folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups all the manifest files for each module in a common folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shows resource files from all Gradle source sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups resource files for different locales, orientations, and screen types
    in a single group per resource type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Android project view shows all the build files at the top level of the
    project hierarchy under `Gradle Scripts`. Each project module appears as a folder
    at the top level of the project hierarchy, and contains these four elements at
    the top level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java/`: Source files for the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`manifests/`: Manifest files for the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res/`: Resource files for the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gradle Scripts/`: Gradle build and property files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, the Android project view groups all the instances of the `ic_launcher.png`
    resource for different screen densities under the same element.
  prefs: []
  type: TYPE_NORMAL
- en: The project structure on disk differs from this flattened representation. To
    switch back to the segregated project view, select your project from the **Project**
    drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: Memory and CPU monitor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Studio provides a memory and CPU monitor view so that you can easily
    monitor your app's performance and memory usage to track CPU usage, find deallocated
    objects, locate memory leaks, and track the amount of memory the connected device
    is using. With your app running on a device or emulator, click on the **Android**
    tab in the lower-left corner of the runtime window to launch the **Android runtime**
    window. Click on the **Memory | CPU** tab.
  prefs: []
  type: TYPE_NORMAL
- en: When you're monitoring memory usage in Android Studio, you can initiate garbage
    collection, and dump the Java heap to a heap snapshot in an Android-specific HPROF
    binary format file at the same time. The HPROF viewer displays classes, instances
    of each class, and a reference tree to help you track memory usage and find memory
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio allows you to track memory allocation as it monitors memory use.
    Tracking memory allocation allows you to monitor where objects are being allocated
    when you perform certain actions. Knowing these allocations enables you to adjust
    the method calls related to those actions to optimize your app's performance and
    memory use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory and CPU monitor](img/B05069_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cross-platform tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we are only talking about Android game development, game development
    cannot be efficient without cross-platform support. We have already discussed
    game design flexibility. From a typical technical perspective, it should be possible
    to deploy the game for various platforms such as iOS, Windows, consoles, and the
    like.
  prefs: []
  type: TYPE_NORMAL
- en: Always keep in mind that cross-platform mobile development isn't quite as simple
    as writing the code once, putting it through a tool for translation, and publishing
    both an iOS and Android app to the respective app stores.
  prefs: []
  type: TYPE_NORMAL
- en: Using a cross-platform mobile development tool can reduce the time and cost
    associated with developing apps on both platforms, but the UI needs to be updated
    to match each system. For example, adjustments are needed between the two so that
    the menu and control commands match the UX of how Android devices and iOS devices
    inherently operate in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of tools that support cross-platform development. Let''s take
    a look at a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Cocos2d-x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cocos2d is primarily used in two-dimensional game development. It gives developers
    the option of five different forks or platforms to develop on, based on their
    preferred programming languages, such as C++, JavaScript, Objective C, Python,
    and C# (image source: [http://www.cocos2d-x.org/attachments/802/cocos2dx_landscape.png](http://www.cocos2d-x.org/attachments/802/cocos2dx_landscape.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cocos2d-x](img/B05069_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Primarily, this tool is efficient for Android, iOS, and Windows Phone. The development
    platform is mainly 2D; however, from Cocos2d-x 3.x it is possible to develop games
    in 3D also.
  prefs: []
  type: TYPE_NORMAL
- en: Cocos2d-x works with native Android, and can support different processor architectures
    separately. This tool works in a Unix-based environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a huge developer community that develops games on Cocos2d-x. Here
    are the pros and cons of this cross-platform development engine from the Android
    game development perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Supports the most common programming languages such as C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Works in the native environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight and optimized library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common OpenGL rendering system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All smartphone features supported for 2D development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completely free open source Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Majorly supports 2D development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform deployment is tricky and complicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance and memory optimization is weak
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No visual programming support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No debugging tool is provided within the engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly works on mobile phone platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity3D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity3D is the most popular cross-platform engine among Android and iOS game
    developers. Although it is mainly optimized for mobile platforms, it is powerful
    enough to deploy games for other major gaming platforms as well, for example,
    PC, Mac, consoles, web, Linux, Xbox, PlayStation, and so on. Currently, it supports
    17 different platforms for game development (image source: [http://img.danawa.com/images/descFiles/3/545/2544550_1_1390443907.png](http://img.danawa.com/images/descFiles/3/545/2544550_1_1390443907.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unity3D](img/B05069_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you've got your game on all your chosen platforms, Unity3D will even help
    you distribute it to the appropriate stores, get social shares, and track user
    analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Unity3D has the largest game developer community, with huge support on almost
    every aspect of game development. It has its separate store where you can find
    an effective prebuilt custom library, prebuilt plugins, and so on, which helps
    a developer in terms of reducing development time significantly. Here are the
    main pros and cons of Unity3D.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Supports 17 different platforms for gaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very simple deployment procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual editor to support visual programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inbuilt powerful debug tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huge library support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hassle-free development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inbuilt powerful memory and performance optimizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparatively bigger library size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slightly performance heavy (however, it is improving day by day)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports only scripting languages (C#, JavaScript, and Boo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not completely free for commercial purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mainly works well with 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreal Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recently released Unreal Engine 4 is a very powerful cross-platform game
    engine. Previously, this engine focused on the console and PC platforms only,
    but it has extended its support to mobile gaming platforms such as Android and
    iOS (image source: [http://up.11t.ir/view/691714/1425334231-unreal-engine-logo.png](http://up.11t.ir/view/691714/1425334231-unreal-engine-logo.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unreal Engine](img/B05069_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There have been a lot of debates about whether Unreal Engine 4 is better than
    Unity3D. They both have their own pros and cons. Let''s have a look at the pros
    and cons of Unreal Engine 4:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint feature allows flexible visual programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic C++ language is more developer friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphic processing is excellent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inbuilt dynamic shadow system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple to understand and start making games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vast support in terms of device scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-editor material designing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile optimization is still not up to the mark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of 2D development tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of availability of third-party plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with sprites is a pain for mobile development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still focused on high configuration hardware platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhoneGap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Owned by Adobe, PhoneGap is a free resource that first-time app developers can
    use to translate code from HTML5, CSS, and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: They maintain SDKs at their end for each of the platforms you can develop an
    app for, so it's one less thing you have to worry about. And once your app is
    completed, you can share it with your team members for review to see if you need
    to make any improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond iOS and Android, PhoneGap also creates apps for BlackBerry and Windows.
    So it is truly a cross-platform mobile development tool (image source: [http://blogs.perceptionsystem.com/wp-content/uploads/2016/03/phonegap.png](http://blogs.perceptionsystem.com/wp-content/uploads/2016/03/phonegap.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![PhoneGap](img/B05069_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'PhoneGap features the following pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Supports almost all mobile platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight application build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports HTML, CSS, and JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cordova apps install just like a native application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhoneGap is open source and free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has the following cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of platform support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of third-party plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native UI is still difficult to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Corona
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Corona''s SDK comes with the promise that you can start coding your new app
    in as little as five minutes after the download. It''s another cross-platform
    mobile development tool that''s optimized for 2D gaming graphics, and helps you
    make games 10 times faster than it would take to code everything from scratch
    (image source: [https://qph.ec.quoracdn.net/main-qimg-fad64a16e531773325448e6ca699d117](https://qph.ec.quoracdn.net/main-qimg-fad64a16e531773325448e6ca699d117)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Corona](img/B05069_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Corona's programming language is Lua, which is written in C, making it a cross-platform
    language. Corona chose Lua because they found it to be really robust, with a small
    footprint for mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corona has the following pros:'
  prefs: []
  type: TYPE_NORMAL
- en: Good application performance in terms of FPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good inbuilt emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Light application build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has the following cons:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the less popular scripting language Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less plugin support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No on-device debugging support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Titanium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using JavaScript, Titanium''s SDK creates native iOS and Android apps while
    reusing anywhere from 60% to 90% of the same code for all the apps you make, thereby
    saving you a significant amount of time (image source: [http://mobile.e20lab.info/wp-content/uploads/sites/2/2014/04/titanium.png](http://mobile.e20lab.info/wp-content/uploads/sites/2/2014/04/titanium.png)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Titanium](img/B05069_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because Titanium is an open-source tool, hundreds of thousands of your fellow
    developers are constantly contributing to it to make it better, and give it more
    functionality. And if you happen to find a bug in its system, you can do so too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick-start flexibility for the initial phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight application build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common JavaScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web and mobile support on Android and iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of plugin support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of platform support range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script-based development increases complexity and effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance varies with different platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor optimization compared to other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development tools are essential for any game development; however, they have
    always been low priority in game design and the pre-development analysis stage.
    The necessity for these tools is realized when they are required.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed all the mandatory tools for Android development only. But
    modern age game development demands flexibility across hardware platforms as well
    as operating systems. This is where cross-platform development engines come into
    the picture. These tools help the development process to become faster and more
    efficient; however, this comes at the cost of a little drop in performance and
    a larger build size. In most cases, developers have limited control over the cross-platform
    engine, but full control can be gained if the game is developed on native SDKs.
  prefs: []
  type: TYPE_NORMAL
- en: Development tools are not just useful for development and debugging—they are
    very efficient in optimizing the game along with data protection, which might
    not have a direct impact on games. A good developer must use optimization tools
    to deliver a better performing game.
  prefs: []
  type: TYPE_NORMAL
