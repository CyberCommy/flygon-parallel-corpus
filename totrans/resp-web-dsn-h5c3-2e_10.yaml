- en: Chapter 10. Approaching a Responsive Web Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my favorite stories and films, there's usually a scene where a mentor passes
    on valuable advice and some magical items to the hero. You know those items will
    prove useful; you just don't know when or how.
  prefs: []
  type: TYPE_NORMAL
- en: Well, I'd like to assume the role of the mentor in this final chapter (plus
    my hair has waned, and I don't have the looks for the hero role). I would like
    you, my fine apprentice, to spare me just a few more moments of your time while
    I offer up some final words of advice before you set forth on your responsive
    quest.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be half philosophical musings and guidance, and half grab-bag
    of unrelated tips and techniques. I hope at some point in your responsive adventures,
    these tips will prove useful. Here''s what we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting designs in the browser and on real devices as soon as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting the design dictate the breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing progressive enhancement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a browser support matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive enhancement in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking CSS breakpoints to JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding CSS frameworks in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing pragmatic solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the simplest possible code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hiding, showing, and loading content across viewports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letting CSS do the (visual) heavy lifting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using validators and linting tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing and testing web page performance ([webpagetest.org](http://webpagetest.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing faster and more effective techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping an eye out for the next 'big' things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get designs in the browser as soon as possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The more responsive design work I have done, the more important I have found
    it to get designs up and running in a browser environment as soon as possible.
    If you are a designer as well as a developer, that simplifies matters. As soon
    as you have enough of a feel, visually, for what you need, you can get it prototyped
    in a browser and develop the idea further in a browser environment. This approach
    can be embraced more fully by letting go of high-fidelity full-page mock-ups altogether.
    Instead, consider things like Style Tiles—positioned between a moodboard and full
    mockup. The introduction to Style Tiles ([http://styletil.es/](http://styletil.es/))
    describes them as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Style Tiles are a design deliverable consisting of fonts, colors and interface
    elements that communicate the essence of a visual brand for the web."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I've found graphical deliverables of this nature can be useful for presenting
    and communicating look and feel between stakeholders without resorting to the
    endless rounds of composites.
  prefs: []
  type: TYPE_NORMAL
- en: Let the design dictate the breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'd like to reiterate a point made in previous chapters. Let the design define
    where breakpoints should be set. With a design in the browser, it makes this process
    far easier. You should always start amending the design from the smallest screen
    sizes upwards, so as the viewport size increases, you can see how far your design
    works before you need to introduce a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll also find that coding the design will be easier this way. Write the
    CSS for the smallest viewport first and then add any changes to different elements
    within media queries afterwards. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: View and use the design on real devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can, start to build up a 'device lab' of older devices (phones/tablets)
    to view your work on. Having a number of varied devices is hugely beneficial.
    Not only does it let you feel how a design actually works across different devices,
    it also exposes layout/rendering peculiarities earlier in the process. After all,
    no one enjoys believing they have finished on a project to be told it doesn't
    work properly in a certain environment. Test early, test often! It need not cost
    the earth. For example, you can pick up older phone and tablet models on eBay,
    or buy them from friends/relatives as they upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use tools such as BrowserSync to synchronize your work**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest time-saving tools I''ve used lately is **BrowserSync**.
    Once configured, as you save your work, any changes to things like CSS are injected
    into the browser without you needing to constantly refresh your screen. If that
    wasn''t good enough, any other browser windows on devices you have on the same
    WiFi refresh too. This saves having to pick up each of your testing devices and
    clicking refresh with each change. It even synchronizes scrolling and clicks too.
    Highly recommended: [http://browsersync.io/](http://browsersync.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Embracing progressive enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have considered briefly the notion of progressive enhancement.
    It's an approach to development that I have found so useful in practice I think
    it bears repeating. The fundamental idea with progressive enhancement is that
    you begin all your front-end code (HTML, CSS, JavaScript) with the lowest common
    denominator in mind. Then, you progressively enhance the code for more capable
    devices and browsers. That may seem simplistic and it is, but if you are used
    to working the other way around; designing the optimum experience and then figuring
    out a way of making that thing work on lesser devices/browsers, you'll find progressive
    enhancement an easier approach.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a low powered, poorly featured device. No JavaScript, no Flexbox support,
    no CSS3/CSS4 support. In that instance what can you do to provide a usable experience?
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, you should write meaningful HTML5 markup that accurately describes
    the content. This is an easier task if you're building text and content-based
    websites. In that instance, concentrate on using elements such as `main`, `header`,
    `footer`, `article`, `section`, and `aside` correctly. Not only will it help you
    discern different sections of your code, it will also provide greater accessibility
    for your users at no extra cost.
  prefs: []
  type: TYPE_NORMAL
- en: If you're building something like a web-based application or visual UI components
    (carousels, tabs, accordions, and the like) you'll need to think about how to
    distil the visual pattern down into accessible markup.
  prefs: []
  type: TYPE_NORMAL
- en: The reason good markup is so crucial is that it provides a base level experience
    for all users. The more you can achieve with HTML, the less you have to do in
    CSS and JavaScript to support older browsers. And nobody, and I really mean nobody,
    likes writing the code to support older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For further reading and great practical examples on the subject, I would recommend
    the following two articles. They provide great insight into how fairly complex
    interactions can be handled with the constructs of HTML and CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cssmojo.com/how-to-style-a-carousel/](http://www.cssmojo.com/how-to-style-a-carousel/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cssmojo.com/use-radio-buttons-for-single-option/](http://www.cssmojo.com/use-radio-buttons-for-single-option/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's by no means a simple feat to start thinking in this manner. It is however,
    an approach that is likely to serve you well in your quest to do as little as
    possible to support ailing browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, about those browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a browser support matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the browsers and devices a web project needs to support up front can
    be crucial to developing a successful responsive web design. We've already considered
    why progressive enhancement is so useful in this respect; if done correctly, it
    means that the vast majority of your site will be functional on even the oldest
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: However, there may also be times when you need to start your experience with
    a higher set of prerequisites. Perhaps you are working on a project where JavaScript
    is essential, not an uncommon scenario. In that instance, you can still progressively
    enhance. Instead, you are merely enhancing from a different start point.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your starting point, the key thing is establishing what it is. Then,
    and only then, can you define and agree upon what visual and functional experiences
    the different browsers and devices that you intend to support will get.
  prefs: []
  type: TYPE_NORMAL
- en: Functional parity, not aesthetic parity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's both unrealistic and undesirable to try and get any website looking and
    working the same in every browser. Besides quirks specific to certain browsers,
    there are essential functional considerations. For example, we have to consider
    things like touch targets for buttons and links on touch screens that aren't relevant
    on mouse-based devices.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, some part of your role as a responsive web developer is educating
    whoever you are answerable to (boss, client, shareholders) that 'supporting older
    browsers' does not mean 'looks the same in older browsers'. The line I tend to
    run with is that all browsers in the support matrix will get task parity, not
    visual parity. This means that if you have a checkout to build, all users will
    be able to get through the checkout and purchase goods. There may visual and interaction
    flourishes afforded to the users of more modern browsers, but the core task will
    be achievable by all.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the browsers to support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, when we talk about which browsers to support, we're talking about
    how far back we need to look. Here are a couple of possibilities to consider,
    depending upon the situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s an existing website, look at visitor statistics (Google Analytics
    or similar). Armed with some figures you can likely do some rough calculations.
    For example: if cost of supporting browser X is less than the value produced by
    supporting browser X, then support browser X!'
  prefs: []
  type: TYPE_NORMAL
- en: Also, consider that if there are browsers in the statistics that represent less
    than 10% of users, look further back and consider trends. How has usage changed
    over the last 3, 6, and 12 months? If it's currently 6% and that value has halved
    over the last 12 months you have a more compelling argument to consider ruling
    that browser out for specific enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: If it's a new project and statistics are unavailable, I usually opt for a 'previous
    two' policy. This would be the current version plus the previous two versions
    of each browser. For example, if Internet Explorer 12 was the current version,
    look to offer your enhancements for that version plus IE10 and IE11 (the previous
    two). This choice is easier with the 'evergreen' browsers, the term given to browsers
    that continually update on a rapid release cycle (Firefox and Chrome for example).
  prefs: []
  type: TYPE_NORMAL
- en: Tiering the user experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, let's assume shareholders are educated and on board. Let's also
    assume you have a clear set of browsers that you would like to add enhanced experiences
    for. We can now set about tiering the experience. I like to keep things simple,
    so where possible I opt to define a simple 'base' tier and a more 'enhanced' tier.
  prefs: []
  type: TYPE_NORMAL
- en: The base experience being the minimal viable version of the site and the enhanced
    version being the most fully-featured and aesthetically pleasing version. You
    might need to accommodate more granularity in your tiers, for example, forking
    the experience in relation to browser features; support for Flexbox or support
    for `translate3d` for example. Regardless of how the tiers are defined, ensure
    you define them and what you expect to deliver with each. Then you can actually
    go about coding those tiers.
  prefs: []
  type: TYPE_NORMAL
- en: Practically delivering experience tiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, Modernizr facilitates the most robust manner to enhance and fork
    experiences based upon device capabilities. While it means adding a JavaScript
    dependency to your project, I think it is worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, that when writing CSS, the code outside of media queries and without
    selectors that require classes added by Modernizr should make up our 'base' experience.
  prefs: []
  type: TYPE_NORMAL
- en: Then thanks to Modernizr, we can layer on ever more enhanced experiences based
    upon the browser capabilities. If you refer back to `example_08-07` you can see
    this mind-set and code pattern applied to an off-canvas menu pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Linking CSS breakpoints to JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, with something web-based involving any sort of interaction, JavaScript
    will be involved. When you're developing a responsive project, it's likely you
    will want to do different things at different viewport sizes. Not just in CSS
    but also in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we want to invoke a certain JavaScript function when we reach
    a certain breakpoint in the CSS (remember that 'breakpoint' is the term used to
    define the point in which a responsive design should change significantly). Let's
    suppose that breakpoint is 47.5rem (with a 16px root font size that would equate
    to 760px) and we only want to run the function at that size. The obvious solution
    would be to simply measure the screen width and invoke the function if the value
    matched the same value you had decided for your CSS breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript will always return the value of widths as pixels rather than REM
    values so that's the first complication. However, even if we set the breakpoints
    in CSS as pixel values, it would still mean two places to update and change those
    values when we are changing viewport sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, there is a better way. I first came across this technique on Jeremy
    Keith''s website: [http://adactio.com/journal/5429/](http://adactio.com/journal/5429/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full code for this at `example_10-01`. However, the basic idea
    is that in CSS we insert something that can be easily read and understood by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this in the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For each breakpoint that we want to communicate to JavaScript, we use the `after`
    pseudo element (you could use before too, either is just as good) and set the
    content of that pseudo element to be the name of our breakpoint. In our preceding
    example, I am using `Splus` for small screens and above, `Mplus` for medium screens
    and above, and `Lplus` for large screens and above. You can use whatever name
    makes sense to you and change the value whenever it makes sense to you (different
    orientations, different heights, different widths, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `::before` and `::after` pseudo elements are inserted into the DOM as shadow
    DOM elements. The `::before` pseudo element is inserted as the first child of
    its parent, and `::after` gets inserted as the last child. You can confirm this
    point in the developer tools of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: With that CSS set, we can browse the DOM tree and see our `::after` pseudo element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking CSS breakpoints to JavaScript](img/B03777_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then in our JavaScript, we can read this value. Firstly, we assign the value
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then once we have it we can do something with it. To prove this concept
    I have made a simple self-invoking function (self-invoking simply means it is
    executed as soon as the browser parses it) that alerts a different message on
    page load depending upon the viewport size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I'd hope you do something a little more interesting than alert a message in
    your projects but I think you will find great benefit in approaching the problem
    this way. You'll never be in danger of your CSS media queries and your width dependent
    JavaScript functions getting out of sync again.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid CSS frameworks in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a plethora of free frameworks available that aim to aid in the rapid
    prototyping and building of responsive websites. The two most common examples
    being Bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/)) and Foundation
    ([http://foundation.zurb.com/](http://foundation.zurb.com/)). While they are great
    projects, particularly for learning how to build responsive visual patterns, I
    think they should be avoided in production.
  prefs: []
  type: TYPE_NORMAL
- en: I've spoken to plenty of developers who start all projects with one of these
    frameworks and then amend them to fit their needs. This approach can be incredibly
    advantageous for rapid prototyping (for example, to illustrate some interaction
    to clients) but I think it's the wrong thing to do for projects you intend to
    take through to production.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, from a technical perspective, it's likely that starting with a framework
    will result in your project having more code than it actually needs. Secondly,
    from an aesthetic perspective, due to the popularity of these frameworks, it's
    likely your project will end up looking very similar to countless others.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you only copy and paste code into your project and tweak it to your
    needs, you'll be unlikely to fully appreciate what's going on 'under the hood'.
    It's only by defining and solving the problems you have that you can master the
    code you place into your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Coding pragmatic solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to front-end web development, ''ivory towered idealism'' is a
    particular bugbear of mine. While we should always endeavor try to do things ''the
    right way'', pragmatism must always win out. Let me give you an example (the finished
    code is `example_10-02`). Suppose we have a button to style that opens an off-canvas
    menu. Our natural inclination might be to mark it up something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Nice and simple. It's a button so we have used the `button` element. We have
    used two different HTML classes on the button, one will be a hook for CSS styling
    (`menu-toggle`), and the other as a JavaScript hook (`js-activate-off-canvas-menu`).
    In addition, we are using the `aria-label` attribute (ARIA is covered in more
    detail in [Chapter 4](ch04.html "Chapter 4. HTML5 for Responsive Web Designs"),
    *HTML5 for Responsive Web Designs*) to communicate to screen readers the meaning
    of the character inside the `span`. In this example, we have used the HTML entity
    `&#9776`; which is the Unicode character 'Trigram for Heaven'. It's used here
    merely because it looks like the 'Hamburger icon' often used to symbolize a menu.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''d like some solid advice on when and how to use the `aria-label` attribute
    I thoroughly recommend the following post on the Opera developer site by Heydon
    Pickering: [https://dev.opera.com/articles/ux-accessibility-aria-label/](https://dev.opera.com/articles/ux-accessibility-aria-label/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we seem to be in good shape. Semantic, highly accessible markup
    and classes to separate concerns. Great. Let''s add some styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this up in Firefox and this is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding pragmatic solutions](img/B03777_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not exactly what we were hoping for. In this case, the browser has decided we've
    gone too far; Firefox simply won't allow us to use a button element as a Flex
    container. This is a very real conflict for a developer. Do we choose the right
    element or the right aesthetic? Given that ideally, we would like to have the
    menu 'hamburger icon' on the left and the word 'menu' on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can see in the prior code we have used the `appearance` property. It''s
    used to remove the browsers default styling for form elements, and has had a potted
    history. It was specified by the W3C for some time and then later dropped, leaving
    behind vendor-prefixed versions of the property in both Mozilla and WebKit browsers.
    Thankfully, it''s now back on the standards track: [http://dev.w3.org/csswg/css-ui-4/#appearance-switching](http://dev.w3.org/csswg/css-ui-4/#appearance-switching)'
  prefs: []
  type: TYPE_NORMAL
- en: When a link becomes a button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I won''t lie. Given this conundrum, I usually opt for the latter. Then I try
    and make up for the fact I''ll be using the wrong element by choosing the next
    best element and changing the ARIA role where possible. In this case, while our
    menu button is certainly not a link (after all, it doesn''t take the user anywhere),
    it''s an `a` tag that I will be using. I''ve decided it''s the next best thing—more
    like a button than any other element. And by using a link we can achieve the desired
    aesthetic. Here''s the markup I''d go with. Note the added ARIA role on the `a`
    tag to indicate its role as a button (and not a link which is the default) to
    assistive technology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not perfect but it''s a pragmatic solution. Here''s the two (`button`
    element on the left, `a` tag on the right) next to each other in Firefox (version
    39.0a2 if you''re curious):'
  prefs: []
  type: TYPE_NORMAL
- en: '![When a link becomes a button](img/B03777_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, for this simplistic example, we could change the display from flex
    to block and play around with the padding until our desired aesthetic was achieved.
    Or, we could keep the `button` element and nest another semantically meaningless
    element (`span`) and make that a Flex container. There are trade-offs whichever
    approach you favor.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, it's up to us to markup documents as sensibly as possible. At one
    end of the scale, there are developers that only markup with divs and spans to
    ensure no unwanted styles from the browser. The cost being no inherent meaning
    from their elements and in turn, no 'free' accessibility. At the other end of
    the scale are markup purists, who will only ever markup content in what they consider
    to be the correct element, regardless of how 'off' the visuals might end up as
    a result. There is a middle ground. I feel that's the sensible and most productive
    place to be.
  prefs: []
  type: TYPE_NORMAL
- en: Use the simplest code possible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s easy to get drunk on the power that new techniques afford us. With this
    in mind, aim to solve your responsive problems in the simplest manner possible.
    For example, if you need to style the fifth item in a list of items and you have
    access to the markup, don''t use an `nth-child` selector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have access to the markup, make life easier by adding an HTML class
    to the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And then style the item with that simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this easier to understand, it gets you wider support for free (older
    versions of Internet Explorer don't support `nth-child` selectors).
  prefs: []
  type: TYPE_NORMAL
- en: Hiding, showing, and loading content across viewports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the commonly touted maxims regarding responsive web design is: if you
    don''t have something on the screen at smaller viewports, you shouldn''t have
    it there at larger ones either.'
  prefs: []
  type: TYPE_NORMAL
- en: This means users should be able to accomplish all the same goals (buy a product,
    read an article, accomplish an interface task) at every viewport size. This is
    common sense. After all, as users ourselves, we've all felt the frustration of
    going to a website to accomplish a goal and being unable to, simply because we're
    using a smaller screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also means that as screen real estate is more plentiful, we shouldn''t feel
    compelled to add extra things just to fill the space (widgets, adverts, or links
    for example). If the user could live without those extras at smaller screen sizes,
    they''ll manage just fine at bigger ones. Displaying extra content at larger viewport
    sizes also means that either the content was there at smaller viewports and was
    merely hidden (typically using `display: none;` in CSS) or it''s being loaded
    in at a particular viewport size (with the help of JavaScript). Succinctly: either
    the content is loaded but not viewable, or it''s viewable yet probably superfluous.'
  prefs: []
  type: TYPE_NORMAL
- en: In broad terms I think the above maxim is sound advice. If nothing else, it
    makes designers and developers question more thoroughly the content they display
    on screen. However, as ever in web design, there are always going to be exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: As far as possible, I resist loading in new markup for different viewports but
    occasionally it's a necessity. I've worked on complex user interfaces that rightfully
    required different markup and designs at wider viewports.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, JavaScript was used to replace one area of markup with another.
    It wasn't the ideal scenario but it was the most pragmatic. If, for whatever reason,
    the JavaScript failed, users got the smallest screen layout. They could accomplish
    all the same goals, just the layout was sub-optimal for achieving the task at
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the kind of choices you will likely face as you code more and more
    complex responsive web designs, and you''ll need to use your own judgment as to
    what the best choice is in any given scenario. However, it''s not a cardinal sin
    if you toggle the visibility of the odd bit of markup with `display: none` to
    achieve your goal.'
  prefs: []
  type: TYPE_NORMAL
- en: Let CSS do the (visual) heavy lifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a fact that JavaScript provides a level of interactivity on webpages that
    simply cannot be achieved with CSS alone. However, where possible, when it comes
    to visuals, we should still do all the heavy lifting with CSS. In practicality,
    this means not animating menus in, out, on and off, with JavaScript alone (I'm
    looking at you jQuery `show` and `hide` methods). Instead, use JavaScript to perform
    simple class changes on the relevant section of the markup. Then let that class
    change trigger the menu being shown/animated in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the best performance, when toggling classes in the HTML, ensure you add
    a class as close as possible to the item you want to effect. For example, if you
    want a pop-up box to appear over another element, add the class on the closest
    shared parent element. This will ensure that, for the sake of optimal performance,
    only that particular section of the page is made ''dirty'' and the browser shouldn''t
    have to paint vast areas of the page again. For a great, free, course on performance,
    take a look at Paul Lewis''s ''Browser Rendering Optimization'' course: [https://www.udacity.com/course/browser-rendering-optimization--ud860](https://www.udacity.com/course/browser-rendering-optimization--ud860)'
  prefs: []
  type: TYPE_NORMAL
- en: Validators and linting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally speaking, writing HTML and CSS is pretty forgiving. You can nest the
    odd thing incorrectly, miss the occasional quotation mark or self-closing tag
    and not always notice a problem. Despite this, on an almost weekly basis I manage
    to befuddle myself with incorrect markup. Sometimes it's a slip-up like accidentally
    typing an errant character. Other times it's school-boy errors like nesting a
    `div` inside a `span` (invalid markup as a `span` is an inline element and a `div`
    is a block level element—leading to unpredictable results). Thankfully, there
    are great tools to help out. At worst, if you're encountering a weird issue, head
    over to [http://validator.w3.org/](http://validator.w3.org/) and paste your markup
    in there. It will point out all errors along with line numbers, helping you to
    easily fix things up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Validators and linting tools](img/B03777_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Better still, install and configure ''linting'' tools for your HTML, CSS, and
    JavaScript. Or, choose a text editor with some degree of sanity-checking built
    in. Then problem areas are flagged up in your code as you go. Here''s an example
    of a simple spelling error in CSS flagged up by Microsoft''s ''Code'' editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validators and linting tools](img/B03777_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like a clown, I've clumsily typed `widthh` instead of `width`. The editor has
    spotted this fact and pointed out the error of my ways and offered some sensible
    alternatives. Embrace these tools where possible. There are better uses of your
    time than tracking down simple syntax errors in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering the performance of your responsive web designs is as important as
    the aesthetics. However, performance presents something of a moving target. For
    example, browsers update and improve the way they handle assets, new techniques
    are discovered that supersede existing 'best practices', technologies eventually
    get enough browser support that they become viable for widespread adoption. The
    list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are however, some basic implementation details that are pretty solid
    (well, until HTTP2 is common place, more of which shortly). These are:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize the number of assets (for example, don't load 15 JavaScript files if
    you concatenate them into one).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Minimize the page weight (if you can compress images to a fraction of their
    original size you should).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defer non-essential assets (if you can put off loading CSS and JavaScript until
    the page has rendered it can greatly increase the perceived load time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the page is usable as soon as possible (usually a by-product of doing
    all the preceding steps).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are a number of great tools available to measure and optimize performance
    too. My personal favorite being [http://webpagetest.org/](http://webpagetest.org/).
    At its simplest, you pick a URL and click on **START TEST**. It will show you
    a complete analysis of the page but even more usefully, it shows a ''filmstrip''
    view of the page as it has loaded, allowing you to concentrate on getting the
    rendered page complete sooner. Here''s an example of the filmstrip view of the
    BBC home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance](img/B03777_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever trying to optimize performance, ensure you take measurements before
    you begin (otherwise, you have no idea how effective your performance work has
    been). Then make amendments, test, and repeat.
  prefs: []
  type: TYPE_NORMAL
- en: The next big things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that make front-end web development interesting, is that things
    change rapidly. There is always something new to learn and the web community is
    always figuring out better, faster, and more effective ways of solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: For example, three years before writing this edition of the book responsive
    images (`srcset` and the `picture` element that are detailed in [Chapter 3](ch03.html
    "Chapter 3. Fluid Layouts and Responsive Images"), *Fluid Layouts and Responsive
    Images*) simply didn't exist. Back then, we had to use clever third party workarounds
    to serve up more appropriate images to different viewport sizes. Now that common
    need has been rationalized into a W3C standard we can all now use and enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, not long ago, Flexbox was just a twinkle in a specification writer's
    eyes. Even when the specification evolved it was still difficult to implement
    until Andrey Sitnik and those clever folks at Evil Martians ([https://evilmartians.com/](https://evilmartians.com/))
    created Autoprefixer and we are subsequently able to use it cross-browser with
    relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: The future holds yet more exciting capabilities for us to understand and implement.
    We've already mentioned Service Workers in [Chapter 4](ch04.html "Chapter 4. HTML5
    for Responsive Web Designs"), *HTML5 for Responsive Web Designs*, for example
    ([http://www.w3.org/TR/service-workers/](http://www.w3.org/TR/service-workers/));
    a better way to create offline capable web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: There is also 'Web Components' a collection of standards made up of Shadow DOM
    ([http://w3c.github.io/webcomponents/spec/shadow/](http://w3c.github.io/webcomponents/spec/shadow/)),
    Custom Elements ([http://w3c.github.io/webcomponents/spec/custom/](http://w3c.github.io/webcomponents/spec/custom/))
    and HTML Imports ([http://w3c.github.io/webcomponents/spec/imports/](http://w3c.github.io/webcomponents/spec/imports/))
    that will allow us to create entirely bespoke and re-usable components.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are the other forthcoming enhancements such as CSS Level 4 Selectors
    ([http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/))
    and CSS Level 4 Media Queries, which we covered in some detail in [Chapter 2](ch02.html
    "Chapter 2. Media Queries – Supporting Differing Viewports"), *Media Queries –
    Supporting Differing Viewports*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, another big change looming on the horizon is HTTP2\. It promises to
    make many of our current best practices, bad practices. For a good in-depth primer
    I'd suggest reading *http2 explained* by Daniel Stenberg (it's a free PDF). Alternatively,
    for a lighter summary, read Matt Wilcox's excellent post, *HTTP2 for front-end
    web developers* ([https://mattwilcox.net/web-development/http2-for-front-end-web-developers](https://mattwilcox.net/web-development/http2-for-front-end-web-developers)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we reach the end of our time together, your humble author hopes to have related
    all the techniques and tools you'll need to start building your next website or
    web application responsively.
  prefs: []
  type: TYPE_NORMAL
- en: It's my conviction that by approaching web projects with a little forethought
    and by making a few modifications to existing workflows, practices, and techniques,
    it's possible to create responsive web designs that provide fast, flexible, and
    maintainable websites that can look incredible regardless of the device used to
    visit them.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered a wealth of information in our time together; techniques, technologies,
    performance optimizations, specifications, workflow, tooling, and more. I wouldn't
    expect anybody to take it all in in one read. Therefore, next time you need to
    remember this or that syntax, or refresh your mind about one of the responsive
    related subjects we've covered, I hope you'll dip back in to these pages. I'll
    be right here waiting for you.
  prefs: []
  type: TYPE_NORMAL
- en: Until then, I wish you good fortunes in your responsive web design quests.
  prefs: []
  type: TYPE_NORMAL
- en: See you again sometime.
  prefs: []
  type: TYPE_NORMAL
