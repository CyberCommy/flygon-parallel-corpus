- en: Writing Clean Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we covered the theory and principles underlying software
    testing. We delved into the benefits and challenges inherent in unit, integration,
    and E2E testing. In this chapter, we will take this knowledge and apply it to
    some real-world examples.
  prefs: []
  type: TYPE_NORMAL
- en: It's not sufficient to simply understand what testing is and see its merits
    from a business perspective. The tests we write form a significant part of our
    code bases, and should hence be crafted in the same careful manner as all other
    code we write. We want to craft tests that not only give us confidence that our
    code works as intended, but are themselves reliable, efficient, maintainable,
    and usable. We must also be wary of writing overly complex tests. Doing so can
    trap us in a situation where our tests increase the burden of understanding and
    lead to more overall complexity and flakiness in the code base, reducing overall
    productivity and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: If wielded with care and caution, tests can give code bases a clarity and cleanliness
    that enables users and colleagues to carry out their work with greater speed and
    quality. In the following sections, we'll explore the best practices to stand
    by and potential pitfalls to avoid when writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the right thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing intuitive assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating clear hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing final clarity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating clean directory structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the right thing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important considerations when writing any test, whether a granular
    **unit test** or a far-reaching **E2E test**, is the question of *what* to test.
    It's entirely possible to test the wrong thing; doing so can give us false confidence
    in our code. We may write a huge test suite and walk away grinning, thinking that
    our code now fulfills all expectations and is utterly fault-tolerant. But our
    test suite may not test the things we think it does. Perhaps it only tests a few
    narrow use cases, leaving us exposed to many possibilities of breakage. Or perhaps
    it conducts tests in a way that is never emulated in reality, leading to a situation
    where our tests don't protect us from failures in production. To protect us against
    these possibilities, we must understand what we truly wish to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function that we''ve written to extract phone numbers of a specified
    format from arbitrary strings. The phone numbers can be in a variety of forms,
    but will always have between 9 and 12 digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0800-144-144`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`07792316877`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`01263 109388`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`111-222-333`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0822 888 111`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is our current implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We decide to write a test to assert the correctness of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The assertions we use are vital. It''s important that we are testing the right
    thing. With our example, this should include exemplar strings that contain a complete
    variety of input: strings that contain phone numbers, strings that contain no
    numbers, and strings that contain a mixture of phone numbers and non phone numbers.
    It''s far too easy only to test the positive cases, but it is in fact equally
    important to check for the negative cases. In our scenario, the negative cases
    include situations where there are no phone numbers to be extracted and hence
    may consist of strings such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"this string is just text..."`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"this string has some numbers (012), but no phone numbers!"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"1 2 3 4 5 6 7 8 9"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"01-239-34-32-1"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"0800 144 323 492 348"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"123"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Very quickly, when composing such exemplar cases, we see this true scope of
    complexity that our implementation will have to cater to. Incidentally, this highlights
    the tremendous advantage of employing **Test-Driven Development** *(***TDD**)
    to define expectations firmly. Now that we have a few cases of strings containing
    numbers that we *do not* wish to be extracted, we can express these as assertions,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This currently fails. The `extractPhoneNumbers(''123'')` call incorrectly returns
    `["123"]`. This is because our regular expression does not yet make any prescriptions
    about length. We can easily make this fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The added `{9,12}` part will ensure that the preceding group (`([0-9][- ]?)`)
    will only match between `9` and `12` times, meaning that our test of `extractPhoneNumbers('123')`
    will now correctly return `[]` (an empty array). If we repeat this testing-and-iteration
    process with each of our exemplar strings, we will eventually arrive at a correct
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key takeaway from this scenario is that we should seek to test the complete
    gamut of inputs that we may expect. Depending on what we''re testing, we can usually
    say there''s always a limited set of possible scenarios that any piece of code
    we write will cater to. We want to ensure that we have a set of tests that analyze
    this range of scenarios. This range of scenarios is often called the **input space **or
    **input domain** of a given function or module. We can consider something well-tested
    if we expose it to a representative variety of inputs from its *input space*,
    which, in this case, includes both strings *with* valid phone numbers and those
    *without* valid phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c2c1545-fd35-4b16-b761-856e0abf89e1.png)'
  prefs: []
  type: TYPE_IMG
- en: It's not necessary to test every possibility. What's more important is to test
    a representative sample of them. To do this, it's essential first to identify
    our *input space* and then partition it into singular representative inputs that
    we can then individually test. For example, we need to test that the phone number
    `"012 345 678"` is correctly identified and extracted, but it would be pointless
    for us to exhaustively test the variations of that same format (`"111 222 333"`,
    `"098 876 543"`, and so on). Doing so would be unlikely to reveal any additional
    errors or bugs in our code. But we should definitely test other formats with different
    punctuation or whitespace (such as `"111-222-333"` or `"111222333"`). It's additionally
    important to establish inputs that may be outside of your expected *input space*,
    such as invalid types and unsupported values.
  prefs: []
  type: TYPE_NORMAL
- en: A full understanding of your software's requirements will enable you to produce
    a correct implementation that is well tested. So, before we even begin writing
    code, we should always ensure that we know exactly what it is we're tasked with
    creating. If we find ourselves unsure what the full *input space* might be, that's
    a strong indicator that we should take a step back, talk to stakeholders and users,
    and establish an exhaustive set of requirements. Once again, this is a strong
    benefit of test-led implementation (TDD), where these deficits in requirements
    are spotted early and can hence be resolved before costs are sunk into a pointless
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: When we have our requirements in mind and have a good understanding of the entire
    *input space*, it is then time to write our tests. The most atomic part of a test
    is its assertions, so we want to ensure we can effectively craft intuitive assertions
    that communicate our expectations well. This is what we'll be covering next.
  prefs: []
  type: TYPE_NORMAL
- en: Writing intuitive assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of any test is its assertions. An assertion prescribes exactly what
    we expect to occur, and so it is vital not only that we craft it accurately but
    that we craft it in a way that our expectation is made utterly clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'A single test will usually involve several assertions. And a test will typically
    follow the form of: *given an input of X, do I receive an output of Y*? Sometimes,
    establishing *Y* is complex and may not be constrained to a singular assertion.
    We may want to introspect *Y* to confirm that it is truly the desired output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a function named `getActiveUsers(users)`, which will return only the
    active users from a set of all users. We may wish to make several assertions about
    its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have clearly expressed our expectations for the output of `getActiveUsers(...)` as
    a series of assertions. Given a more fully-featured assertion library or more
    complex code, we could easily constrain this to a singular assertion, but it's
    arguably clearer to separate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many testing libraries and utilities provide abstractions to aid us in making
    assertions. The popular testing libraries, Jasmine and Jest, for example, both
    provide a function called `expect`, which supplies an interface with many *matchers*,
    each individually allowing us to declare what characteristics a value should have,
    as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`expect(x).toBe(y)` asserts that `x` is the same as `y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(x).toEqual(y)` asserts that `x` is equal to `y` (similar to abstract
    equality)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(x).toBeTruthy()` asserts that `x` is truthy (or `Boolean(x) === true`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(x).toThrow()` asserts that `x`, when invoked as a function, will throw
    an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The exact implementation of these matchers may vary from library to library,
    and the abstraction and naming provided may also vary. Chai.js, for example, provides
    both the `expect` abstraction and a simplified `assert` abstraction, allowing
    you to assert things in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important thing when crafting an assertion is to be utterly clear.
    Just as with other code, it is unfortunately quite easy to write an assertion
    that is incomprehensible or hard to parse. Consider the following assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This statement, due to the abstractions provided by Chai.js, has the appearance
    of a human-readable and easily understandable assertion. But it is actually quite
    difficult to understand exactly what''s going on. Let''s consider which of the
    following this statement might be checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The item is not an array?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The item is not an empty array?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The item has a length greater than zero and is not an array?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is, in fact, checking that the item is both not an array and that it is non-empty—meaning
    that, if the item is an object, it'll check that it has at least one property
    of its own, and if it's a string, it'll check that its length is greater than
    zero. These true underlying mechanics of the assertion are obscured and so, when
    exposed to such things, programmers may be left in a state of either blissful
    ignorance (*thinking the assertion works as they wish it to*) or painful confusion
    (*wondering how on earth it works*).
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be the case that what we wished to assert all along was simply whether
    `someValue` was both not an array but was *array-like*, and as such, had a length
    greater than zero. As such, we can lend clarity using Chai.js''s `lengthOf` method
    in a new assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid any doubt and confusion, we could, alternatively, assert more directly
    without relying on Chai.js''s sentence-like abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is arguably far clearer as it explains to the programmer the exact check
    that is taking place, eliminating the doubt that could arise with a more abstract
    assertion style.
  prefs: []
  type: TYPE_NORMAL
- en: The crux of a good assertion is its clarity. Many libraries provide fancy and
    abstract mechanics of assertion (via the `expect()` interface, for example). These
    can create more clarity, but if over used, they can end up being less clear. Sometimes,
    we just need to **Keep it Simple, Stupid** (**KISS**). Testing code is the worst
    possible place in which to get fancy with egotistic or mis-abstracted code. Simple
    and straightforward code wins every time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've explored the challenge of crafting intuitive assertions, we can
    slightly *zoom out* and have a look at how we should craft and structure the tests
    that contain them. The next section reveals *hierarchies* as a helpful mechanism
    to communicate meaning through our test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Creating clear hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test any code base, we would likely need to write a large number of assertions.
    Theoretically, we could have a long list of assertions and nothing else. However,
    doing this may make it quite difficult to read, write, and analyze the reports
    of tests. To prevent such confusion, it is common for testing libraries to provide
    some scaffolding abstractions around assertions. For example, BDD-flavoured libraries
    such as Jasmine and Jest supply two pieces of scaffolding: the `it` block and
    the `describe` block. These are just functions to which we pass a description
    and callback, but together, they enable a hierarchical tree of tests that makes
    it far easier to comprehend what''s going on. Testing a `sum` function using this
    pattern might be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Behaviour-Driven Development** (**BDD**) is a style and methodology of testing
    that, similar to TDD, enforces a regime where we write tests first and implementation
    second. More than this, however, it focuses on the importance of *behaviors* over
    *implementation*, since behaviors are easier to communicate and are more important
    from the perspective of the user (or stakeholder). BDD-style tests will hence
    usually use language such as *Describe X » It does Y when* Z *occurs...*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-BDD libraries tend to surround groups of assertions with simpler infinitely-nestable
    `test` blocks, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the naming of the BDD-flavored `it` and `describe` terms can
    help us to craft descriptions for our test suites that read like full English
    sentences (for example *Describe an apple » It is round and sweet*). This isn''t
    enforced but gives us a useful nudge toward better descriptions. We can also infinitely
    nest `describe` blocks so that our descriptions can reflect the hierarchical nature
    of the thing we''re testing. So, for example, if we were testing a math utility
    called `myMathLib`, we may imagine the following test suite with its various sub-suites
    and specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Describe `myMathLib`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Describe `add()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can add two integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can add two fractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns `NaN` for non-numeric inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Describe `subtract()l`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can subtract two integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can subtract two fractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns `NaN` for non-numeric inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Describe `PI`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is equal to `PI` at fifteen decimal places
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This hierarchy naturally reflects the conceptual hierarchy of the abstraction
    we''re testing. The reporting provided by the testing library will usefully reflect
    this hierarchy. Here''s an example output from the **Mocha** testing library in
    which every test of `myMathLib` passes successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Individual assertions come together to form tests. Individual tests come together
    to form test suites. Every test suite provides us with clarity and confidence
    regarding specific units, integrations, or flows (within E2E tests). The composition
    of these test suites is vital to ensuring that our tests are simple and comprehensible.
    We must take the time to think about how we will express the conceptual hierarchy
    of whatever we're testing. The test suites we create also need to be intuitively
    placed within the directory structure of our code base. This is what we'll explore
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Providing final clarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be said that the goal of testing is simply to describe what you have
    done. By describing, you are forced to assert your assumed truths about how something
    operates. When these assertions are executed, we can then discern whether our
    descriptions, our *assumed truths*, correctly reflect reality.
  prefs: []
  type: TYPE_NORMAL
- en: In the act of description, we must choose our words carefully so that they express
    our meaning clearly and comprehensibly. Tests are one of our last *defenses* against
    obscurity and complexity. Some code is unavoidably complicated, and we should
    ideally craft it in a way that reduces its obscure nature, but if we can't fully
    do this, then it is the role of tests to clear up any remaining confusion and
    provide the *final* point of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to clarity while testing is to focus purely on the perspective of the
    person who must read through the tests (or their logged outputs). Here are some
    specific points of clarity to remain aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use names** of tests to accurately describe what the test does, being overly
    descriptive if necessary. For example, instead of *test that the* `Navigation`
    *component renders*, consider saying *test that the* `Navigation` *component renders
    all navigations items correctly*. Our names can also communicate the conceptual
    hierarchies of our problem domains as well. Recall what we said about it in the
    *Consistency and hierarchy *section in [Chapter 5](cf2c2cfc-6b5e-48a3-a7ef-99169bd9067d.xhtml), *Naming
    Things is Hard*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use variables** as vessels of meaning. When writing tests, it is a good idea
    to be overly explicit with variable names or even to use variables where they
    may not be necessary, to fully communicate your intent. For example, consider
    how `expect(value).toEqual(eulersNumber)` is more understandable than `expect(value).toEqual(2.7182818)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use comments** to explain odd behaviors. If the code you''re testing does
    something in an unexpected or unintuitive manner, then your tests may themselves
    appear unintuitive. As a last resort, it is important to provide additional context
    and explanation with comments. Be wary, however, of stale comments that don''t
    get updated alongside the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following test for `AnalogClockComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this test makes several assertions about the `transform` CSS
    property of specific elements. It''s possible to make an informed guess as to
    what these are, but the clarity could definitely be improved. To make this cleaner,
    we can use better names to reflect what we''re testing, separate the tests to
    represent the different concepts being tested, use variable names to provide clarity
    about what values we''re making assertions about, and use comments to explain
    any possibly unintuitive things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You'll likely observe that the *cleaner* way is far longer, but when it comes
    to testing, it is truly best to bias yourselves toward such lengthy descriptiveness.
    Being over-descriptive is better than being under-descriptive because, in the
    latter case, your colleagues are left with a deficit of information, scratching
    their heads and making a possibly incorrect guess about functionality. When we
    provide a generous amount of clarity and explanation, we are helping a wider diversity
    of colleagues and users. If we are obscure and terse, however, we are specifically
    limiting the set of people who can understand our code, and hence limiting its
    maintainability and usability.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the craft of exposing *final clarity* via a well-structured
    test suite, we can *zoom out* once more and discuss how we might communicate the
    purpose and types of tests we're writing via our directory structures and file
    naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating clean directory structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our test suites should usually be constrained to individual files, to delineate
    areas of concern for our programmer-colleagues. Organizing these test files to
    form a coherent part of a larger code base can be a challenge, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine a small JavaScript code base with the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite typical to place tests relating to particular code in sub-directories
    close to where that code resides. In our example code base, we may create the
    following `tests` sub-directories to contain unit tests for our `components` and
    `utilities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some additional notes regarding conventions, which, as we should know
    by now, are vital in increasing the familiarity and intuitiveness of a code base
    and hence its overall cleanliness:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests are sometimes called specs (*specifications*). A spec is typically no
    different to a test, although, as a name, it is slightly more favored in the BDD
    paradigm. Use whichever you're comfortable with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's common to see test files suffixed with `.test.js` or `.spec.js`. This is
    so your test-runner can easily identify which files to execute, and it is a helpful
    reminder to our colleagues as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not rare to see test directories with naming patterns involving underscores
    or other atypical characters, for example, `__tests__`. These naming patterns
    are usually used to ensure that such tests are not compiled or bundled as part
    of your main source code and are easily discernible by our colleagues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E or integration tests are more commonly placed at a higher level, which alludes
    to their dependency on multiple parts. It's quite common to see a high-level `e2e` directory
    (or some adaptation). Sometimes, integration tests are named individually and
    stored at a high level; other times, they are interspersed with unit tests throughout
    a code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, hierarchy is key here. We must ensure that the hierarchy of our
    directories helpfully mirrors the conceptual hierarchy of our code and its problem
    domain. As an equal and important part of a code base, a test should be placed
    carefully and appropriately within a code base, not as an afterthought.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have applied our theoretical knowledge of testing to the
    practical craft of constructing real, working, and clean test suites. We looked
    at some of the pitfalls that exist in doing so, and we highlighted the important
    qualities to strive for, such as clarity, intuitive naming, and following conventions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking into a variety of tools we can use to
    help us to write cleaner code, from linters to compilers, and beyond!
  prefs: []
  type: TYPE_NORMAL
