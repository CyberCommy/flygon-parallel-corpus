- en: Chapter 3. Expressing Anonymous Methods with Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered delegates in the previous chapter, as it was a pre-requisite for
    understanding anonymous methods and lambda expressions, the subject of the current
    chapter. By using an anonymous method, we can create a delegate instance with
    no need to have a separate method. By using the lambda expression, we can create
    a shorthand syntax for the anonymous method. In this chapter, we are going to
    dig up the anonymous methods as well as Lambda expressions. The topics in this
    chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying delegate to create and use anonymous methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation of anonymous methods to lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding expression trees and its relation to lambda
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing for events using lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elaborating the benefit of lambda expressions in the use of functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know anonymous methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we already discussed how to declare a delegate using
    named methods. When using named methods, we''ve have to create a method first,
    give it a name, and then associate it with the delegate. To refresh our memory,
    a simple delegate declaration associated with a named method is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we simply create a delegate data type named `DelDelegate`
    , and we also create a method named `DoSomething` . After we have a named method,
    we can associate the delegate with the method. Fortunately, anonymous methods
    were announced in C# 2.0 to ease the use of delegates. They provide us with a
    shortcut to create a simple and short method that will be used once. The syntax
    to declare an anonymous method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation for each element of the anonymous method syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Delegate** : The keyword we need in order to initialize a delegate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters** : The list of parameters that the method we assign to this delegate
    takes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementation** : The code that will be executed by the method. It can apply
    a return statement if the method needs to return a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding syntax, we can see that an anonymous method is a method that
    doesn't have a name. We just need to define the arguments and the implementation
    of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For further discussion, let''s create a simple anonymous method, which we can
    find in the `SimpleAnonymousMethods.csproj` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an anonymous method we assign to the delegate `displayMessageDelegate`
     delegate. We create the `displayMessageDelegate` delegate using the `Func` built-in
    delegate, which takes only one string argument and a return string value as well.
    If we need to run the anonymous method, we can invoke the delegate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding code, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating anonymous methods](img/Image00021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the output console window, we have successfully invoked the
    anonymous method by calling the delegate name. Now, let''s go back to the previous
    chapter to use some code from there and refactor it to an anonymous method. We
    are going to refactor the code of `SimpleDelegates.csproj` , which we''ve discussed
    in the previous chapter. The following is the declaration of anonymous methods,
    and it can be found in the `SimpleDelegatesRefactor.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two anonymous methods in our preceding code. We also use the `Func`
    delegate, the built-in delegate we discussed in the previous chapter. To invoke
    the methods, we can invoke the delegate name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the project, we will get an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating anonymous methods](img/Image00022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compared to the code in the `SimpleDelegates.csproj` project, our code in the
    preceding `SimpleDelegatesRefactor.csproj` project becomes simpler and shorter
    since we don''t need to declare the delegate. The delegate is declared simultaneously
    with the creation of an anonymous method, such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code we used in our previous chapter, named `SimpleDelegates.csproj`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using anonymous delegation , we have simplified our code compared to the code
    produced in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using an anonymous method as an argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now executed an anonymous method. However, the anonymous method can
    also be passed to a method as a parameter. Let''s look at the following code,
    which we can find in the `AnonymousMethodAsArgument.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we have a method named `FindMultipleOfSeven` in this project. The method
    will be passed to the argument of the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call the `FindMultipleOfSeven()` method from the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define the following `List` variable to be passed to the `FindMultipleOfSeven()`
    method argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke the `PrintResult()` method, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an anonymous method as an argument](img/Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The goal of the preceding program is to find a number that is multiplied by
    seven from the number list. And since `91` is the first number that meet this
    criteria, the `FindMultipleOfSeven()` method returns that number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `FindMultipleOfSeven()` method, we can find the `Find()` method
    passing the `IsMultipleOfSeven()` method as an argument, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, if we want, replace this method with the anonymous method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the `FindMultipleOfSevenLambda()` method, which invokes the `Find()`
    method and passes the anonymous method to the method argument. Since we have passed
    the anonymous method, we don''t need the `FindMultipleOfSeven()` method any longer.
    We can invoke the `FindMultipleOfSevenLambda()` method using the `PrintResultLambda()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output we after we have executed the `PrintResultLambda()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using an anonymous method as an argument](img/Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the output window, we still retrieve `91` as a result of
    a number multiplication of `7` . However, we have successfully passed the anonymous
    method as the method argument.
  prefs: []
  type: TYPE_NORMAL
- en: Writing anonymous methods - some guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing anonymous methods, here are some things that we should keep in
    mind:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An anonymous method has no return type in its declaration. Consider the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding delegate declaration, we don't find the return type, although
    we find the `return` keyword in the method implementation. This is because the
    compiler infers the return type based on the delegate signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to match the declaration of the delegate''s signature with the method''s
    argument. This will be similar to assigning a named method to a delegate. Let''s
    take a look at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code snippet, we declare a delegate that takes two int arguments
    and returns an int value. Refer to the delegate signature; we use the same signature
    when declaring the anonymous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not allowed to declare variables whose names conflict with the variables
    of the anonymous method that is declared. Take a look at the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will never be able to compile the preceding code since we declare the variable
    `i` twice both in `Conflict()` method and in `actDelegate` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the anonymous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some advantages of using anonymous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we do not attach a name to a method, they are a good solution if we want
    to invoke the method only once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write the code in place rather than writing the logic in other parts
    of a code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't need to declare the return type of the anonymous method since it will
    be inferred from the signature of the delegate that is assigned to the anonymous
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can access local variables of the outer method from the anonymous method.
    Outer variables are captured inside the anonymous method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not need to create a named method for snippets of logic that are invoked
    once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an idea that anonymous methods can help us create a simple and short
    method. However, in C# 3.0, lambda expressions were announced in order to complement
    anonymous methods in providing a shorthand notation to create anonymous methods.
    In fact, lambda expressions become the preferred way when writing new code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the simplest lambda expression syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the lambda expression syntax, we only find two elements, which are `parameters`
    and `expression` . Like any method, a lambda expression has an argument symbolized
    by parameters. The implementation of the lambda expression is symbolized by the
    expression. We can also omit the parenthesis of parameters if only one parameter
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple lambda expression, which we can find in the `SimpleLambdaExpression.csproj`
    project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declare the `displayMessageDelegate` delegate and
    assign it to the `Func` delegate using a lambda expression. Similar to the method
    in the `SimpleDelegates.csproj` project, in order to invoke the delegate, we use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `displayMessageDelegate` delegate like a method name. The output
    will be sent to the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda expressions](img/Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s compare the method declaration between an anonymous method in `SimpleAnonymousMethods.csproj`
    and a lambda expression in the `SimpleLambdaExpression.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is an anonymous method declaration that is shorter
    and simpler than a named method declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a lambda expression declaration that is shorter
    and simpler than an anonymous method. The lambda expressions are brief compared
    to anonymous methods.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming an anonymous method to a lambda expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the transformation of an anonymous method to a lambda expression.
    We have the following anonymous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And we want to transform it to a lambda expression, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we take out the `delegate` keyword since we don''t need it anymore;
    so, the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we supersede the curly braces with a `=>` lambda operator in order to
    make it the inline lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also remove the `return` keyword since it is only a single line code
    that returns a value. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the preceding syntax is now an expression instead of a complete statement,
    the semicolon can be removed from the preceding code and the code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression is a valid lambda expression. However, we can simplify
    the code more in order to take advantage of the lambda expression. The code will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have taken out `string` data type, we can now take out the parenthesis
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax is our final lambda expression. As we can see, now, our
    code becomes more readable because of its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parenthesis in the parameters list of lambda expressions can be omitted
    if it contains only one argument.
  prefs: []
  type: TYPE_NORMAL
- en: Using lambda expressions, we can actually create delegates and expression tree
    types in anonymous methods. Now, let's find out the difference between these two
    types in the upcoming topics.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a delegate type using lambda expresions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed lambda expressions in a delegate type when we created code in
    the `SimpleLambdaExpression.csproj` project. Now, let''s create another project
    name in order to discuss this by referring to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, we refactor the `SimpleDelegatesRefactor.csproj` project and replace
    the anonymous method with a lambda expression. As we can see, the lambda expression
    is assigned to a variable typed delegate. Here, we create a lambda expression
    in a delegate type. We can use the `Main()` method we had used in the `SimpleDelegatesRefactor.csproj`
    project to invoke `AreaRectangleDelegate` and `AreaSquareDelegate` . The result
    of the two projects will be completely the same.
  prefs: []
  type: TYPE_NORMAL
- en: Expression trees and lambda expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides creating a delegate, we can create expression trees, which are data
    structures which represents the expression elements (expr, term, factor) as a
    tree. By traversing the tree, one can interpret the expression trees or we can
    mutate a node in the tree for transforming the code. In compiler parlance, expressions
    trees are called **abstract syntax trees** ( **AST** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following code snippet in order to assign a
    lambda expression to the delegate that we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there are three sections in the preceding statement. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A variable typed delegate declaration** : `Func<int, int, int> AreaRectangleDelegate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An equal operator** : `=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A lambda expression** : `(a, b) => a * b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to translate the preceding code statement into data. To achieve
    this goal, we need to create an instance of the `Expression<T>` type, and `T`
    is delegate type. The `Expression<T>` type is defined in the `System.Linq.Expressions`
    namespace. After using this namespace in the project, we can translate our preceding
    code into an expression tree, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have converted our preceding delegate lambda expression into the expression
    tree declared to be of type `Expression<T>` . The variable expression in the preceding
    code is not executable code but a data structure called an expression tree. There
    are four essentials properties in the `Expression<T>` class that we will discuss
    in detail. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Body** : This contains the body of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters** : This contain the parameters of the lambda expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodeType** : This contains the `ExpressionType` type of node in the tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type** : This contains the static type of the expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add a breakpoint in the expression variable and run the debugging
    process by pressing **F5** in the `LambdaExpressionInExpressionTree.csproj` project.
    After executing the expression declaration line, we can take a peek at the variable
    window in the Visual Studio IDE, and we will get the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expression trees and lambda expressions](img/Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we have a `Body` property containing `{(a *
    b)}` , `NodeType` containing Lambda, `Type` containing the `Func` delegate with
    three templates, and are two parameters. If we expand the `Body` information in
    the variable window, we will get a result similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expression trees and lambda expressions](img/Image00027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can see that we have the `Left` property
    containing `{a}` and the `Right` property containing `{b}` . Using these properties,
    we can also explore the body of expression tree programmatically. The following
    code is the `exploreBody()` method, which will explore the properties of `Body`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `exploreBody()` method, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expression trees and lambda expressions](img/Image00028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding  code, we access the Body properties of `Expression<T>` programmatically.
    We need to create a `BinaryExpression`  data type in order to get the `Body` content,
    and `ParameterExpression` in order to get the `Left` and `Right` properties content.
    The code snippet for the `BinaryExpression` and `ParameterExpression` data is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We have successfully created a data structure from the code in the expression
    tree. We can, if we want, convert this data back into code by compiling the expression.
    The expression we have is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can compile the expression and run the code in the expression using
    the following `compilingExpr()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the `compilingExpr()` method, the following output will be displayed
    on the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expression trees and lambda expressions](img/Image00029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we have compiled the expression using the `Compile()` method
    in the expression class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `expr.Compile()` method produces a delegate of type `Func<int, int, int>`
    in accordance with the type of the expression. We give the `Compile()` method
    the arguments `a` and `b` based on its signature, then it returns the `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing for events using lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C#, an object or a class can be used to inform other objects or classes
    when something happens, which is known as an event. There are two kinds of classes
    in the event, they are publishers and subscribers. The publisher is a class or
    object that sends (or raises) the event, while the subscriber is a class or object
    that receives (or handles) the event. Fortunately, lambda expressions can also
    be used to handle events. Let''s take a look at the following code to discuss
    events further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code can be found in the `EventsInLambda.csproj` project. As
    we can see, a class named `EventClassWithoutEvent` has been created in the project.
    The class has a property named `OnChange` . This property''s role is to store
    the action that subscribes the class and will be run when the `Raise()` method
    is invoked. Now, let''s consume the `Raise()` method using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `CreateAndRaiseEvent()` method, we will retrieve the
    following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subscribing for events using lambda expressions](img/Image00030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the code, we can see that when we invoke the `CreateAndRaiseEvent()` method,
    the code instances an `EventClassWithoutEvent` class. It then subscribes to the
    event with five different methods inside the lambda expression and then raises
    the event by invoking the `Raise()` method. The following code snippet will explain
    this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code snippet, we can see that the lambda expression can
    be used to subscribe to the event since it uses a delegate to store the subscribed
    method. However, there is still a weakness in the preceding code. Take a look
    at the last `OnChange` assignment from this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that we change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will remove all four previous subscribers. Another weakness is that
    `EventClassWithoutEvent` raises the event but nothing can stop the users of the
    class from raising this event. By invoking `OnChange()` , all users of the class
    can raise the event to all subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Using the event keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of the `event` keyword can solve our preceding problem since it will
    enforce the users of the class to subscribe something only using either the `+=`
    or `-=` operator. Let''s take a look at the following code to explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we are no longer using a public property
    but a public field in the `EventClassWithEvent` class. Using the `event` keyword,
    the compiler will secure our field from unwanted access. The event keyword will
    also protect the subscription list since it cannot be assigned to any lambda expression
    using the `=` operator but has to be used with the `+=` or `-=` operator. Now,
    let''s take a look at the following code to prove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a method named `CreateAndRaiseEvent2()` , which is exactly same
    as the `CreateAndRaiseEvent()` method except that the last `OnChange` assignment
    used the `=` operator instead of the `+=` operator. However, since we have applied
    the event keyword to the `OnChange` field, the code cannot be compiled and the
    `CS0070` error code will occur, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the event keyword](img/Image00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no risk anymore since the event keyword has restricted the use of
    the `=` operator. The `event` keyword also prevents the outside user of the class
    from raising the event. Only the part of the class that defines the event can
    raise the event. Let''s take a look at the difference between the `EventClassWithoutEvent`
    and `EventClassWithEvent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The reference of the preceding `CreateAndRaiseEvent3()` method is `CreateAndRaiseEvent()`
    , but we insert `ev.OnChange()` ; in between the third event and fourth event.
    If we run the method, it will run successfully, and we will see the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the event keyword](img/Image00032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the output, `OnChange()` in the `EventClassWithoutEvent`
    class can raise the event. Compared to the `EventClassWithEvent` class, if we
    insert `OnChange()` between any subscribing event, the compiler will create a
    compile error, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we compile the preceding code, we will get the `CS0070` error code again,
    since we insert `ev.OnChange()` ; in between the third event and the fourth event.
  prefs: []
  type: TYPE_NORMAL
- en: Using EventHandler or EventHandler<T>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Actually, C# has a class named `EventHandler` or `EventHandler<T>` that we
    can use to initialize an event instead of using an `Action` class. An `EventHandler`
    class takes a sender object and event arguments. The sender is the object that
    raises the event. Using `EventHandler<T>` , we can define the type of event arguments.
    Let''s take a look at the following code, which we can find in the `EventWithEventHandler.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two classes, named `MyArgs` and `EventClassWithEventHandler` . The
    `EventClassWithEventHandler` class uses `EventHandler<MyArgs>` , which defines
    the event argument''s type. We need to pass an instance of `MyArgs` when raising
    the event. Subscribers of the event can access the arguments and use them. Now,
    let''s take a look at the following `CreateAndRaiseEvent()` method code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using EventHandler or EventHandler<T>](img/Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding code, we can see that the lambda expression plays its role
    to subscribe to an event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The advantages of using lambda expression in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions are not only a powerful way to provide a shorthand notation
    for anonymous methods, but they are also used in functional programming. In this
    section, we will go through the advantages of using the lambda expression in the
    context of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in
    C#") , *Tasting Functional Style in C#* , we discussed the idea of first-class
    functions when we were discussing functional programming. If functions are fire
    class Functions, functions obey value semantics. They can be passed as a parameter,
    returned from a function, and so on. If we go back to the earlier topic about
    lambda expressions, we have a project named `SimpleLambdaExpression.csproj` ,
    which has the following simple lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add the following `firstClassConcept()` method to the project
    in order to demonstrate the first-class function using a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have successfully assigned the `displayMessageDelegate()`
    method to the variable named `str` , as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the code, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First-class functions](img/Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also pass the lambda expression as the argument of the other function.
    Using `displayMessageDelegate` , let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a method named `firstClassConcept2` , which takes `Func` and string
    parameters. We can run the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we pass `displayMessageDelegate` , which is a lambda expression,
    to the `firstClassConcept2()` method. If we run the project, we will have the
    following output on the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First-class functions](img/Image00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we have successfully assigned a function to a variable and passed a function
    to another function parameter, we can say that the lambda expression is a power
    tool to create first-class functions in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Closure is a function that is able to be assigned to a variable (a first-class
    function) with free variables, which are bound in the lexical environment. A free
    variable is a variable that is not a parameter; or it is a local variable. In
    a closure, any variable that is not bound will be captured from the lexical environment
    where the closure is defined. To avoid getting confused about this term, let''s
    take a look at the following code, which we can find in the `Closure.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we''ve got a local variable named
    `localVar` , and it will be multiplied by 2 when the `GetFunction()` method is
    invoked. The `localVar` variable is bound inside the lambda expression when `returnValue`
    is returned. By analyzing the preceding code without running it, we might guess
    that `GetFunction()` will return `returnFunc` , which will always return the same
    value every time it''s passed to the same argument. This is because `localVar`
    will always be *1* every time `GetFunction()` is invoked, since it''s a local
    variable. As we learned in programming, the local variables are created on the
    stack and they will go away when the method has finished execution. Now, let''s
    invoke the `GetFunction()` method to prove our guess using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to invoke the `incrementFunc()` method, which is the return value
    of the `GetFunction()` method ten times, but we always pass 1 as the argument.
    From our previous guessing, we can say that the `incrementFunc(1)` method will
    always return `3` for all ten invocations. Now, let''s run the project, and we
    will see the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Closure](img/Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: According to the preceding output, we made a wrong guess. The `localVar` variable
    lives along with the `GetFunction()` method. It stores its value after being multiplied
    by 2 each time the method is called. We have successfully bound a free variable
    in the lexical environment and this is what we call closure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered that an anonymous method is a method that doesn't
    have a name. We just need to define the arguments and the implementation of the
    method. It's a shorthand notation from delegates. Then, we looked at lambda expressions,
    the powerful tool in functional programming, which can provide a shorthand notation
    from an anonymous method.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda expression can also be used to form an expression tree that will
    be useful when we need to express our code in regular C#, deconstruct it, inspect
    it, and interpret it. The expression tree is like an explanation of the code.
    If we have a `<Func<int, int, int>>`  expression, it explains how it will provide
    an `int` return if we give the code two integers.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing an event is also done by a lambda expression. There are two kinds
    of classes in the event, they are publisher and subscribers, and we can subscribe
    to the event using a lambda expression. It doesn't matter whether we use the `event`
    keyword or the `EventHandler` keyword, the lambda is always used to subscribe
    to the event.
  prefs: []
  type: TYPE_NORMAL
- en: The first-class function concept is also fulfilled by lambda expressions since
    by using it, we can assign the function into a variable or pass the function as
    an argument of other functions. Using lambda expressions, we can also apply a
    closure concept, which makes a local variable live along within the function.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it's enough to discuss lambda expressions. However, we will discuss
    lambda expressions again in more more detail when we talk about LINQ in [Chapter
    5](text00039.html#page "Chapter 5. Querying Any Collection Easily with LINQ")
    , *Querying Any Collections Easily with LINQ* . And, in the next chapter, we are
    going to talk about the extension method that can be used to extend method abilities.
  prefs: []
  type: TYPE_NORMAL
