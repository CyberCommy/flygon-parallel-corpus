- en: Chapter 2. Regular Expressions with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we've seen how generic regular expressions work. In
    this chapter, we walk you through all the operations Python provides us with to
    work with regular expressions and how Python deals with them.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we will see the quirks of the language when dealing with regular expressions,
    the different types of strings, the API it offers through the `RegexObject` and
    `MatchObject` classes, every operation that we can do with them in depth with
    many examples, as well as some problems generally faced by users. Lastly, we will
    see the small nuances and differences between Python and other regex engines and
    between Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since v1.5, Python provides a Perl-style regular expression with some subtle
    exceptions that we will see later. Both patterns and strings to be searched can
    be **Unicode** strings, as well as an 8-bit string (**ASCII**).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unicode is the universal encoding with more than 110.00 characters and 100 scripts
    to represent all the world's living characters and even historic scripts. You
    can think of it as a mapping between numbers, or code points as they are called,
    and characters. So, we can represent every character, no matter in what language,
    with one single number. For example, the character ![A brief introduction](graphics/inlinemedia1.jpg)
    is the number 26159, and it is represented as \u662f (hexadecimal) in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are supported by the `re` module. So, as with all modules
    in Python, we only need to import it to start playing with them. For that, we
    need to start the Python interactive shell using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we have imported the module, we can start trying to match a pattern. To
    do so, we need to compile a pattern, transforming it into **bytecode**, as shown
    in the following line of code. This bytecode will be executed later by an engine
    written in C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bytecode is an intermediary language. It's the output generated by languages,
    which will be later interpreted by an interpreter. The Java bytecode that is interpreted
    by JVM is probably the best known example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the compiled pattern, we can try to match it against a string,
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the preceding example, we compiled a pattern and then we
    searched whether the pattern matches the text *foo bar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with Python and regular expressions in the command line is easy enough
    to perform quick tests. You just need to start the python interpreter and import
    the `re` module as we mentioned previously. However, if you prefer a GUI to test
    your regex, you can download one written in Python at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain](http://svn.python.org/view/*checkout*/python/trunk/Tools/scripts/redemo.py?content-type=text%2Fplain)'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of online tools such as the one at [https://pythex.org/](https://pythex.org/),
    as well as desktop programs such as RegexBuddy that we will cover in [Chapter
    5](ch05.html "Chapter 5. Performance of Regular Expressions"), *Performance of
    Regular Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it's preferable to use the interpreter to gain fluency with them
    and get direct feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Backslash in string literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions aren''t part of the core Python language. Thus, there isn''t
    a special syntax for them and therefore they are handled as any other string.
    As we''ve seen in [Chapter 1](ch01.html "Chapter 1. Introducing Regular Expressions"),
    *Introducing Regular Expressions*, the backslash character `\` is used to indicate
    metacharacters or special forms in regular expressions. The backslash is also
    used in strings to escape special characters. In other words, it has a special
    meaning in Python. So, if we need to use the `\` character, we''ll have to escape
    it: `\\`. This will give the string literal meaning to the backslash. However,
    in order to match inside a regular expression, we should escape the backslashes,
    effectively writing four back slashes: `\\\\`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as an example, let''s write a regular expression to match `\`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is tedious and difficult to understand when the pattern
    is long.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides the **raw string notation** `r`, with which the backslashes
    are treated as normal characters. So, `r"\b"` is not the backspace anymore; it's
    just the character `\` and the character `b`, and the same goes for `r"\n"`.
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.x and Python 3.x treat strings differently. In Python 2, there are
    two types of Strings, 8-bit Strings and Unicode strings; while in Python 3, we
    have text and binary data. Text is always Unicode and the encoded Unicode is represented
    as binary data ([http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit](http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit)).
  prefs: []
  type: TYPE_NORMAL
- en: Strings have special notation to indicate what type we're using.
  prefs: []
  type: TYPE_NORMAL
- en: String Python 2.x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Type | Prefixed | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String |   | String literals. They''re encoded automatically by using the
    default encoding (UTF-8 in our case). The backslash is necessary to escape meaningful
    characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Raw string | `r` or `R` | They''re equal to literal strings with the exception
    of the backslashes, which are treated as normal characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unicode string | `u` or `U` | These strings use the Unicode character set
    (ISO 10646).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unicode raw string | `ur` or `UR` | They''re Unicode strings but treat backslashes
    as normal raw strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the *What's new in Python 3* section to find out how the notation is in
    Python 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Using raw string is the recommended option following the Python official documentation,
    and that''s what we will be using with Python 2.7 throughout the book. So with
    this in mind, we can rewrite the regex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building blocks for Python regex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, there are two different objects dealing with Regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegexObject`: It is also known as *Pattern Object*. It represents a compiled
    regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MatchObject`: It represents the matched pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RegexObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to start matching patterns, we'll have to compile the regex. Python
    gives us an interface to do that as we've seen previously. The result will be
    a pattern object or `RegexObject`. This object has several methods for typical
    operations on regular expressions. As we will see later, the `re` module provides
    a shorthand for every operation so that we can avoid compiling it first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation of a regular expression produces a reusable pattern object
    that provides all the operations that can be done, such as matching a pattern
    and finding all substrings that match a particular regex. So, for example, if
    we want to know if a string starts with `<HTML>`, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are two ways of matching patterns and executing the operations related
    to the regular expressions. We can compile a pattern, which gives us a `RegexObject`,
    or we can use the module operations. Let's compare the two different mechanisms
    in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to re-use the regular expression, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we can directly perform the operation on the module using
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `re` module provides a wrapper for every operation in the `RegexObject`.
    You can see them as shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, these wrappers create the `RegexObject` and then call the corresponding
    method. You might be wondering whether every time you call one of these wrappers
    it compiles the regular expression first. The answer is no. The `re` module caches
    the compiled pattern so that in future calls it doesn't have to compile it again.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of the memory needs of your program. When you're using module operations,
    you don't control the cache, and so you can end up with a lot of memory usage.
    You can always use `re.purge` to clear the cache but this is a tradeoff with performance.
    Using compiled patterns allows you to have a fine-grained control of the memory
    consumption because you can decide when to purge them.
  prefs: []
  type: TYPE_NORMAL
- en: There are some differences between both ways though. With the `RegexObject`,
    it is possible to limit the region in which the pattern will be searched, for
    example limit the search of a pattern between the characters at index 2 and 20\.
    In addition to that, you can set `flags` in every call by using the operations
    in the module. However, be careful; every time you change the flag, a new pattern
    will be compiled and cached.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into the most important operations that can be done with a pattern
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Searching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see the operations we have to look for patterns in strings. Note that
    python has two operations, match and search; where many other languages have one,
    match.
  prefs: []
  type: TYPE_NORMAL
- en: match(string[, pos[, endpos]])
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method tries to match the compiled pattern only at the beginning of the
    string. If there is a match, then it returns a `MatchObject`. So, for example,
    let''s try to match whether a string starts with `<HTML>` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, first we've compiled the pattern and then we've found
    a match in the `<HTML><head>` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when the string doesn''t start with `<HTML>`, as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is no match. Remember what we said before, `match` tries
    to match at the beginning of the string. The string starts with a whitespace unlike
    the pattern. Note the difference with `search` in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we have a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional **pos** parameter specifies where to start searching, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the highlighted code, we can see how the pattern has a match even though
    there are two whitespaces in the string. This is possible because we've set **pos**
    to `2`, so the match operation starts searching in that position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that **pos** bigger than 0 doesn''t mean that string starts at that index,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've created a pattern to match strings in which the
    first character after "start" is followed by `<HTML>`. After that, we've tried
    to match the string `<HTML>` starting at the second character, `<`. There is no
    match because the pattern is trying to match the `^` metacharacter at the `2`
    position first.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Anchor characters tip**'
  prefs: []
  type: TYPE_NORMAL
- en: The characters `^` and `$` indicate the start and end of the string respectively.
    You can neither see them in the strings nor write them, but they are always there
    and are valid characters for the regex engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the different result if we slice the string 2 positions, as in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The slice gives us a new string; therefore, there is a `^` metacharacter in
    it. On the contrary, **pos** just moves the index to the starting point for the
    search in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second argument, **endpos**, sets how far the pattern will try to match
    in the string. In the following case, it''s equivalent to slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the following case, we don''t have the problem mentioned with **pos**.
    There is a match even when the `$` metacharacter is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is no difference between slicing and **endpos**.
  prefs: []
  type: TYPE_NORMAL
- en: search(string[, pos[, endpos]])
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This operation would be like the **match** of many languages, Perl for example.
    It tries to match the pattern at any location of the string and not just at the
    beginning. If there is a match, it returns a `MatchObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The **pos** and **endpos** parameters have the same meaning as that in the `match`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note that with the `MULTILINE` flag, the `^` symbol matches at the beginning
    of the string and at the beginning of each line (we'll see more on this flag later).
    So, it changes the behavior of `search`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the first `search` matches `<HTML>` because it's at
    the beginning of the string, but the second `search` doesn't match because the
    string starts with a whitespace. And finally, in the third `search`, we have a
    match as we find `<HTML>` right after new line, thanks to `re.MULTILINE`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, as long as the **pos** parameter is less than, or equal to, the new lines,
    there will be a match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: findall(string[, pos[, endpos]])
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous operations worked with one match at a time. On the contrary, in
    this case it returns a list with all the non-overlapping occurrences of a pattern
    and not the `MatchObject` like `search` and `match` do.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we're looking for every word in a string. So, we obtain
    a list in which every item is the pattern found, in this case a word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that empty matches are a part of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I bet you're wondering what's happening here? The trick comes from the `*` quantifier,
    which allows 0 or more repetitions of the preceding regex; the same had happened
    with the `?` quantifier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, both of them match the expression even though the preceding regex
    is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![findall(string[, pos[, endpos]])](graphics/3156OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: findall matching process
  prefs: []
  type: TYPE_NORMAL
- en: First, the regex matches the character `a`, then it follows with `b`. There
    is a match due to the `*` quantifier, the empty string. After that, it matches
    another `a` and finally it tries to match `$`. As we've mentioned before, even
    though you can't see `$`, it's a valid character for the regex engine. As it happened
    with the `b`, it matches due to the `*` quantifier.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen quantifiers in depth in [Chapter 1](ch01.html "Chapter 1. Introducing
    Regular Expressions"), *Introducing Regular Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: In case there are groups in the pattern, they are returned as tuples. The string
    is scanned from left to right, so the groups are returned in the same order they
    are found.
  prefs: []
  type: TYPE_NORMAL
- en: The following example tries to match a pattern made of two words and creates
    a group for every word. That's why we have a list of tuples in which every tuple
    has two groups.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `findall` operation along with `groups` is another thing that seems to confuse
    a lot of people. In [Chapter 3](ch03.html "Chapter 3. Grouping"), *Groups*, we've
    dedicated a complete section to explain this complex subject.
  prefs: []
  type: TYPE_NORMAL
- en: finditer(string[, pos[, endpos]])
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Its working is essentially the same as `findall`, but it returns an iterator
    in which each element is a `MatchObject`, so we can use the operations provided
    by this object. So, it's quite useful when you need information for every match,
    for example the position in which the substring was matched. Several times, I've
    found myself using it to understand what's happening in `findall`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to one of our initial examples. Match every two words and capture
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see how we get an iterator with all the matches.
    For every element in the iterator, we get a `MatchObject`, so we can see the captured
    groups in the pattern, two in this case. We will also get the position of the
    match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we consume another element from the iterator and perform the same operations
    as before. So, we get the next match, its groups, and the position of the match.
    We''ve done the same as we did with the first match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we try to consume another match, but in this case a `StopIteration`
    exception is thrown. This is normal behavior to indicate that there are no more
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we're going to see the operations to modify strings, such as
    an operation to divide the string and another to replace some parts of it.
  prefs: []
  type: TYPE_NORMAL
- en: split(string, maxsplit=0)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In almost every language, you can find the `split` operation in strings. The
    big difference is that the split in the `re` module is more powerful due to which
    you can use a regex. So, in this case, the string is split based on the matches
    of the pattern. As always, the best way to understand it is with an example, so
    let''s split a string into lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the match is `\n`; so, the string is split using
    it as the separator. Let''s see a more complex example of how to get the words
    in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we''ve defined a pattern to match any non-alphanumeric
    character. So, in this case the match happens in the whitespace. That''s why the
    string is split into words. Let''s see another example to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the match is the whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **maxsplit** parameter specifies how many splits can be done at maximum
    and returns the remaining part in the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, only two words are split and the other words are a part of the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Have you realized that the pattern matched is not included? Take a look at every
    example in this section. What can we do if we want to capture the pattern too?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to use groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This happens because the split operation always returns the captured groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when a group matches the start of the string, the result will contain
    the empty string as a first result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: sub(repl, string, count=0)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This operation returns the resulting string after replacing the matched pattern
    in the original string with the replacement. If the pattern is not found, the
    original string is returned. For example, we''re going to replace the digits in
    the string with `-` (dash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Basically, the regex matches 1 and more digits and replaces the pattern matched,
    `0`, `1`, and `13` here, with `-` (dash).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it replaces the leftmost non-overlapping occurrences of the pattern.
    Let''s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we're replacing zeroes two by two. So, the first two
    are matched and then replaced, then the following two zeroes are matched and replaced
    too, and finally the last zero is left intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repl` argument can also be a function, in which case it receives a MatchObject
    as an argument and the string returned is the replacement. For example, imagine
    you have a legacy system in which there are two kinds of orders. Some start with
    a dash and the others start with a letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '-1234'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A193, B123, C124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You must change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A1234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B193, B123, B124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, the ones starting with a dash should start with an A and the rest
    should start with a B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, for each matched pattern the `normalize_orders` function
    is called. So, if the first matched group is a `–`, then we return an `A`; in
    any other case, we return `B`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the code we get the first group with the index 1; take a look at
    the `group` operation to understand why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backreferences, a powerful feature is also provided by `sub`. We''ll see them
    in depth in the next chapter. Basically, what it does is that it replaces the
    backreferences with the corresponding groups. For example, let''s say you want
    to transform markdown to HTML, for the sake of keeping the example short, just
    bold the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As always, the previous example first compiles the pattern, which matches every
    word between the two `*`, and in addition to that it captures the word. Note that
    thanks to the `?` metacharacter the pattern is non-greedy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `\g<number>` is there to avoid ambiguity with literal numbers, for
    example, imagine you need to add "1" right after a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the behavior is as expected. Let''s see what happens on using
    the notation without `<` and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the group is highlighted to remove ambiguity and help
    us see it, and that's precisely the problem the regex engine is facing. Here,
    the regex engine tries to use the group number 11 which doesn't exist. For this
    reason, there is the `\g<group>` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind with `sub` is that every backslash that escapes
    in the replacement string will be processed. As you can see in `<\\b>`, you need
    to escape them if you want to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the number of replacements with the optional **count** argument.
  prefs: []
  type: TYPE_NORMAL
- en: subn(repl, string, count=0)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is basically the same operation as `sub`, you can think of it as a utility
    above `sub`. It returns a tuple with the new string and the number of substitutions
    made. Let us see the working by using the same example as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It's been a long section. We explored the main operations we can do with `re`
    module and the `RegexObject` class along with examples. Let's continue with the
    object we get after a match.
  prefs: []
  type: TYPE_NORMAL
- en: MatchObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This object represents the matched pattern; you will get one every time you
    execute one of these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finditer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This object provides us with a set of operations for working with the captured
    groups, getting information about the position of the match, and so on. Let's
    see the most important operations.
  prefs: []
  type: TYPE_NORMAL
- en: group([group1, …])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `group` operation gives you the subgroups of the match. If it's invoked
    with no arguments or zero, it will return the entire match; while if one or more
    group identifiers are passed, the corresponding groups' matches will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see them with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern matches the whole string and captures two groups, `Hello` and `world`.
    Once we have the match, we can see the the following concrete cases:'
  prefs: []
  type: TYPE_NORMAL
- en: With no arguments or zero, it returns the entire match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With `group1` bigger than 0, it returns the corresponding group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If the group doesn't exist, an `IndexError` will be thrown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With multiple arguments, it returns the corresponding groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we want the whole pattern and the second group, that's why we
    pass `0` and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups can be named, we''ll see it in depth in the next chapter; there is a
    special notation for it. If the pattern has named groups, they can be accessed
    using the names or the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we''ve compiled a pattern to capture two groups:
    the first one is named `first` and the second one is named `second`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we can get a group by its name. Note that using named groups we
    can still get the groups by their index, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use both types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: groups([default])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `groups` operation is similar to the previous operation. However, in this
    case it returns a tuple with all the subgroups in the match instead of giving
    you one or some of the groups. Let''s see it with the example we''ve used in the
    previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As we had in the previous section, we have two groups `Hello` and `World` and
    that's exactly what `groups` gives us. In this case, you can see `groups` as `group(1,
    lastGroup)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case there are groups that don''t match, the default argument is returned.
    If the default argument is not specified then `None` is used, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The pattern in the preceding example is trying to match two groups made of one
    or more alphanumeric characters. The second one is optional; so we get only one
    group with the string `Hello`. After getting the match, we call `groups` with
    `default` set to `mundo` so that it returns `mundo` as the second group. Note
    that in the following call we don't set default, so `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: groupdict([default])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `groupdict` method is used in the cases where named groups have been used.
    It will return a dictionary with all the groups that were found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use a pattern similar to what we've seen in the
    previous sections. It captures two groups with the names `first` and `second`.
    So, `groupdict` returns them in a dictionary. Note that if there aren't named
    groups, then it returns an empty dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand quite well what is happening here. As we've
    mentioned before, we'll see everything related to groups in [Chapter 3](ch03.html
    "Chapter 3. Grouping"), *Groups*.
  prefs: []
  type: TYPE_NORMAL
- en: start([group])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to know the index where the pattern matched. As with
    all the operations related to groups, if the argument group is zero, then the
    operation works with the whole string matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are groups that don''t match, then `-1` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: end([group])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `end` operation behaves exactly the same as `start`, except that it returns
    the end of the substring matched by the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: span([group])
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s an operation that gives you a tuple with the values from `start` and
    `end`. This operation is often used in text editors to locate and highlight a
    search. The following code is an example of this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: expand(template)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operation returns the string after replacing it with backreferences in
    the template string. It's similar to `sub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the example in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Module operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see two useful operations from the module.
  prefs: []
  type: TYPE_NORMAL
- en: escape()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It escapes the literals that may appear in the expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: purge()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It purges the regular expressions cache. We've already talked about this; you
    need to use this in order to release memory when you're using the operations through
    the module. Keep in mind that there is a tradeoff with the performance; once you
    release the cache, every pattern has to be compiled and cached again.
  prefs: []
  type: TYPE_NORMAL
- en: Well done, you already know the main operations that you can do with the `re`
    module. After this, you can start using regex in your projects without many problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to see how to change the default behavior of the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Compilation flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When compiling a pattern string into a pattern object, it's possible to modify
    the standard behavior of the patterns. In order to do that, we have to use the
    compilation flags. These can be combined using the bitwise OR "`|`".
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Python | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `re.IGNORECASE` or `re.I` | 2.x3.x | The pattern will match lower case and
    upper case. |'
  prefs: []
  type: TYPE_TB
- en: '| `re.MULTILINE` or `re.M` | 2.x3.x | This flag changes the behavior of two
    metacharacters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^`: Which now matches at the beginning of the string and at the beginning
    of each new line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: In this case, it matches at the end of the string and the end of each
    line. Concretely, it matches right before the newline character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `re.DOTALL` or `re.S` | 2.x3.x | The metacharacter "`.`" will match any character
    even the newline. |'
  prefs: []
  type: TYPE_TB
- en: '| `re.LOCALE` or `re.L` | 2.x3.x | This flag makes \w, \W, \b, \B, \s, and
    \S dependent on the current locale."re.LOCALE just passes the character to the
    underlying C library. It really only works on bytestrings which have 1 byte per
    character. UTF-8 encodes code points outside the ASCII range to multiple bytes
    per code point, and the re module will treat each of those bytes as a separate
    character." (at [http://www.gossamer-threads.com/lists/python/python/850772](http://www.gossamer-threads.com/lists/python/python/850772))Note
    that when using `re.L` and `re.U` together (re.L&#124;re.U, only Locale is used).
    Also, note that in Python 3 the use of this flag is discouraged; go to the documentation
    for more info. |'
  prefs: []
  type: TYPE_TB
- en: '| `re.VERBOSE` or `re.X` | 2.x3.x | It allows writing of regular expressions
    that are easier to read and understand. For that, it treats some characters in
    a special way:'
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace is ignored except when it's in character class or preceded by a backslash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All characters to the right of the # are ignored like it was a comment, except
    when # is preceded by the backslash or it''s in a character class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `re.DEBUG` | 2.x3.x | It gives you information about the compilation pattern.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `re.UNICODE` or `re.U` | 2.x | It makes \w, \W, \b, \B, \d, \D, \s, and \S
    dependent on the Unicode character properties database. |'
  prefs: []
  type: TYPE_TB
- en: '| `re.ASCII` or `re.A` (only Python 3) | 3.x | It makes \w, \W, \b, \B, \d,
    \D, \s, and \S perform ASCII-only matching. This makes sense because in Python
    3 the matches are Unicode by default. You can find more on this in the *What''s
    new on Python 3* section. |'
  prefs: []
  type: TYPE_TB
- en: Let's see some examples of the most important flags.
  prefs: []
  type: TYPE_NORMAL
- en: re.IGNORECASE or re.I
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the following pattern matches even though the string starts
    with A and not with an a.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: re.MULTILINE or re.M
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, the pattern doesn''t match the date after newline
    because we''re not using the flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, on using the `Multiline` flag, it matches the two dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not the best way to capture a date.
  prefs: []
  type: TYPE_NORMAL
- en: re.DOTALL or re.S
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try to match anything after a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the previous example that the character class `.` with its default
    behavior doesn''t match the newline. Let''s see what happens on using the flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As expected, on using the `DOTALL` flag it matches the newline perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: re.LOCALE or re.L
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we get the first 256 characters and then we try to
    find every alphanumeric character in the string, so we obtain the expected characters
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting the locale to our system locale, we can again try to obtain every
    alphanumeric character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we get many more characters according to the new locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: re.UNICODE or re.U
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try to find all the alphanumeric characters in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'But what would happen if we want to do the same with other languages? The alphanumeric
    characters depend on the language, so we need to indicate it to the regex engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: re.VERBOSE or re.X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following pattern, we''ve used several ⇢; the first one is ignored because
    it is not in a character class or preceded by a backslash and the second one is
    part of the pattern. We''ve also used # three times, the first and the third one
    are ignored because they''re not preceded by a backslash, and the second one is
    part of the pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: re.DEBUG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Python and regex special considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review differences with other flavors, how to deal
    with Unicode, and also differences in the `re` module between Python 2.x and Python
    3.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Python and other flavors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the book, the `re` module has Perl-style
    regular expressions. However, that doesn't mean Python support every feature the
    Perl engine has.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are too many differences to cover them in a short book like this, if
    you want to know them in-depth here you have two good places to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines](http://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.regular-expressions.info/reference.html](http://www.regular-expressions.info/reference.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you''re using Python 2.x and you want to match Unicode, the regex has
    to be Unicode escape. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you use Unicode characters but the type of the string you''re
    using is not Unicode, python automatically encodes it using the default encoding.
    For example, in my case I have UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you have to be careful while mixing types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you''re not matching Unicode but the characters in the default encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you use Unicode in any of them, you''re pattern won''t match anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you can use Unicode on both sides and it would match as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `re` module doesn''t do Unicode case folding, so case insensitive doesn''t
    work on Unicode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: What's new in Python 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some changes in Python 3 that affect the regex behavior, and new features
    have been added to the `re` module. First, let's review how the string notation
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Prefixed | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| String |   | They are string literals. They''re Unicode. The backslash is
    necessary to escape meaningful characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Raw string | `r` or `R` | They''re equal to literal strings with the exception
    of the backslashes, which are treated as normal characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Byte strings | `b` or `B` | Strings represented as bytes. They can only contain
    ASCII characters; if the byte is greater than 128, it must be escaped.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert to Unicode in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The backslash is necessary to escape meaningful characters. |
  prefs: []
  type: TYPE_NORMAL
- en: '| Byte raw string | `r` or `R` | They are like byte strings, but the backslashes
    are escaped.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the backslash used to escape bytes are escaped again, which complicates
    their conversion to Unicode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unicode | `r` or `U` | The `u` prefix was removed in the early versions of
    Python 3, and recovered in version 3.3 the syntax is accepted again. They''re
    equal to strings. |'
  prefs: []
  type: TYPE_TB
- en: Literal strings are Unicode by default in Python 3, which means that there is
    no need to use the flag Unicode anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Python 3.3 ([http://docs.python.org/dev/whatsnew/3.3.html](http://docs.python.org/dev/whatsnew/3.3.html))
    adds more features related to Unicode and how it is treated in the language. For
    example, it adds support for the complete range of code points, including non-BMP
    ([http://en.wikipedia.org/wiki/Plane_(Unicode)](http://en.wikipedia.org/wiki/Plane_(Unicode))).
    So, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python 2.7:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python 3.3.2:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen in the *Compilation Flags* section, the ASCII flag has been added.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect to note when using Python 3 has to do with metacharacters.
    As the strings are Unicode by default, the metacharacters too, unless you use
    8-bit patterns or use the ASCII flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the characters that aren't ASCII are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Take into account that Unicode pattern and 8-bit patterns cannot be mixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ve tried to match an 8-bit pattern against a
    Unicode String, that''s why an exception is thrown (remember that it would work
    in Python 2.x):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long chapter! We've covered a lot of material in it. We began with
    how strings work in Python and their different notations in Python 2.x and Python
    3.x. After that, we looked at how to build regular expressions, the objects and
    interface the `re` module give us to deal with them, and the most important operations
    for searching and modifying strings. We also learned how to extract information
    from a pattern through `MatchObject`, such as the position or the groups of a
    match. We also learned how to modify the default behavior of some character classes
    and metacharacters using the compilation flags. And finally, we've seen how to
    deal with Unicode and the new features we can find in Python 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we've seen that groups are crucial part of regular
    expressions and that many operations of the `re` module are meant to be used with
    groups. That's why we cover groups in depth in the following chapter.
  prefs: []
  type: TYPE_NORMAL
