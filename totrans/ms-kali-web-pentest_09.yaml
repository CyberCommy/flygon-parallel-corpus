- en: Chapter 10. Launching Client-Side Attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web application testing rightfully focuses on the application we're testing
    and its supporting infrastructure. Most attacks we've focused onto this point
    have been interested in either knocking on the front door of that web application
    or hitchhiking on client sessions to gain illicit access. Our customers spend
    all of their security budget fortifying that infrastructure, with some of it geared
    toward the web application's own hardening. That being said, who is taking care
    of their clients?
  prefs: []
  type: TYPE_NORMAL
- en: Between the increased exposure of the client itself as well as the susceptibility
    of the user, we'll have a variety of vectors to test. The staggering number of
    software combinations and user behaviors overlap with other services and web applications,
    and modes of access (mobile versus desktop, roaming versus proxied, thick client
    versus thin clientÂ versus web client, and so on) make this an incredibly tough
    front for application developers to secure. Their best path is to harden the application
    itself, to close any holes and ensure that the application closes any reflective
    attack vectors and screens already-compromised hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Most client-side penetration testing will come in the form of a gray or white
    box testing scope, as the bulk of attack types leverage the application's own
    code or scripts. This doesn't present a significant barrier, as we'll soon see.
    In this chapter, we'll see multiple ways by which we can compromise endpoints--either
    their communications or the host itself. With this knowledge, there is a multitude
    of web application attacks that can degrade target services, and these must be
    exhaustively investigated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you learn this with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how **Domain Object Model** (**DOM**) based XSS attacks work and how
    to implement them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how JavaScript embedding can be used to compromise clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how Client-Side URL Redirect and Resource Manipulation can be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Clickjacking and Websockets offer additional ways into a client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and implementing exploits that perform Cross-Site Request Forgery
    and hijack communications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are clients so weak?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Client-focused attacks span several of the OWASP 2013 and 2017's Top 10 Threat
    categories. Client-side attacks using DOM-based **Cross Site Scripting** (**XSS**)
    are a powerful method of leveraging weaknesses in validation to embed scripts
    into web responses and inserting code into clients. The client-focused, DOM-based
    XSS can deliver code to the clients to effect compromises made on web applications,
    but there is a variety of vulnerabilities that hackers will exploit to reach and
    impact clients, such as a unvalidated redirects and forwards, websockets attacks,
    or clickjacking. A third category in both the 2013 and 2017 versions of the OWASP
    Top 10 is a vulnerability to **Cross-Site Request Forgery** (**CSRF**), which
    leverages victim clients as a pivot and takes advantage of their authenticated
    status to compromise other sites.
  prefs: []
  type: TYPE_NORMAL
- en: There are other attacks that bleed over into other areas within the OWASP Top
    10 and have been covered in earlier efforts, but we'll revisit some of them in
    this chapter to ensure that we understand how best to test and exploit them. The
    common thread in these threats is that they exploit issues on the web application's
    server-side implementation to effect the behavior or integrity of the client side.
    Because these attacks usually imply access to the code being delivered to the
    clients, most of these techniques are not applicable in black-box testing but
    are rather used in white-box or gray-box testing. Attackers, of course, will likely
    use these techniques from an insider's vantage point, so client-side attacks are
    often a stepping stone from an initial beach-head in the environment to either
    lateral movement or as one component of a privilege escalation attack.
  prefs: []
  type: TYPE_NORMAL
- en: DOM, Duh-DOM DOM DOM!!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DOM-based XSS should inspire fear and panic in ill-prepared or unprotected web
    application environments and the teams responsible. As we discussed in [Chapter
    6](000.html#), *Infiltrating Sessions via Cross-Site Scripting*, most XSS attacks
    exploit a lack of input validation to insert scripts (typically JavaScript) to
    impact how clients interpret or interact with the site. DOM-based attacks are
    a subset of those that impact the client's browser, where the DOM resides, to
    maintain its local view of what the application is doing and presenting. By embedding
    scripts, users can of course impact the behavior of the client, but the variety
    of goals and objectives is staggering, and the tool's robust (the **Browser Exploit
    Framework** (**BeEF**) is fantastic in assisting with XSS). These attacks primarily
    focus on attacking the client to hack the client and glean information or focus
    on the end user.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Â 2013 OWASP Top 10 Summary of #3: XSS Attacks'
  prefs: []
  type: TYPE_NORMAL
- en: Malicious misdirection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Unvalidated redirects** and**Â forwards** includeÂ vulnerabilities to attacks
    through o**pen redirect**, **UI redressing**, or aÂ **client-side URL redirection**.
    These attack types involve placing malicious links into the user''s path that
    force a connection to an unintended site for additional attacks, whether they
    initiate malware downloads or intercept future communications or credentials.
    Web applications themselves are complicit in this, as it means that the developers
    have not deployed adequate code validation, session management, or are reliant
    on a flawed, and thereby vulnerable, framework or module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The OWASP 2013 Top 10 ranked this threat as a #10 threat (as shown in the following
    screenshot), but the 2017 version (in its current draft) has dropped it in favor
    of **Application Program Interface** (**API**-based flaws. This does not mean
    that unvalidated redirects and forwards are no longer a threat, but that they
    have not been as prevalent and concerning of late. These attacks such as DOM-based
    XSS tend to have hacking the user as their end-goal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: '2013 OWASP Top 10 Summary of #10: Unvalidated Redirects and Forwards'
  prefs: []
  type: TYPE_NORMAL
- en: Catch me if you can!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 1980 book and subsequent 2002 movie *Catch Me If You Can* is a great caper
    about real-life forger and con-artist Frank Abagnale, who was an expert at manipulating
    people and having them cash forged checks and otherwise take actions on his behalf.
    Hackers can use similar social engineering skills and authentic-looking requests
    to turn unsuspecting clients against the server and take advantage of their trust
    relationship to deliver malicious commands. **Cross-Site Request Forgery** (**CSRF**)
    is an attack that targets a client using an application vulnerability, but it
    actually does so to turn the client against its application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: '2013 OWASP Top 10 Summary of #7: Cross-Site Request Forgery'
  prefs: []
  type: TYPE_NORMAL
- en: Picking on the little guys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what the attacks are trying to accomplish, we have the distinct
    privilege of testing and validating that these vulnerabilities exist or not. In
    this section, I'll provide some guidance on how best to achieve comprehensive
    coverage in your scans for these capabilities, but we'll also look into how we
    can exploit them for black-box attacks and systemic pen testing scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Sea-surfing on someone else's board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSRF attacks (sometimes pronounced *sea-surf*) hide the actual intent of a referred
    action and bury it in a forged request.Â  The user wants to believe the page as-rendered
    (because hey, it came from my trusted web app!) and thus has no reason to investigate
    the underlying hidden fields or requested actions buried into the body or header,
    which in fact launch a malicious action against the server. Through these attacks,
    hackers can have users unwittingly launch the attacks on the server with the benefit
    of using their authenticated session as a Trojan Horse of sorts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning for the potential existence of a CSRF vulnerability is included in
    the scanning and spidering functions of most proxy scanner--Burp Suite, OWASP
    ZAP, and Wapati included. Burp will usually flag as such (as shown in the following
    screenshot), with links and guidance on what the attack means and how to prevent
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite's scan showing CSRF vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: Simple account takeovers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conducting a CSRF attack, however, is not something typically conducted from
    these tools, but rather a browser and Notepad. If you find that CSRF might make
    sense in your testing, here is an example of how you might execute such an attack.
    For this exercise, we''ll leverage the OWASP BWA VM and the **Broken Web App**
    (**BeeBox**) again and navigate to the appropriate page (as shown in the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Accessing bWAPP CSRF Practice Link
  prefs: []
  type: TYPE_NORMAL
- en: Once we're in to the portal, we can go ahead and view the source of the portal
    (in Firefox this involves either using *Ctrl* + *U* or navigating to **`Tools`**Â |Â **`Web
    Developer`**Â |Â **`Page Source`**). This will bring up the HTML on the page (as
    shown in the following screenshot), but what we want is to modify the user input
    section to fool the poor victim into changing their password to our preferred
    one. Let's go ahead and copy this section (everything including and between `<form`
    andÂ `</form>`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Harvesting HTML for CSRF Exploit
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re aiming to do is to have the user â�� who is already authenticated,
    by the way - allow us to borrow their account and change their credentials to
    our preferred password (how nice of them!). We can do this by modifying the fields
    as shown here, where we insert our preferred password (highlighted with bold text).
    I also changed the name of the button to help obscure that a change is happening
    â�� you could make this aÂ **`Login`**Â or something else they are more likely
    to want to click on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we save this (I picked `pw.html`) and view it, we should see a populated
    set of fields, similar to what we see in the following screenshot. When a user
    clicks on these CSRF snippets, it helps if the reason is ambiguous and the fields
    are hidden; we don't want them to know we're forcing a password change (or some
    other purpose we might be architecting the CSRF attack to fulfill).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of CSRF modifications
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B03918_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Modified fields in our HTML
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, our modified HTML is complete, but how do we deliver this gift to our
    victims? You can combine this attack with a XSS attack, send it via e-mail, or
    embed it within a forged page. To test the code itself, we can just open the page
    and click Â on the **`Click Here`**Â button. With any luck (who needs it with
    these awesome hacks?) you''ll see a similar message to what we see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: CSRF Execution delivers the victim to the real page
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this is a very helpful tool in compromising clients. Hackers
    have not only used this for credential modification, but also to redirect funding
    to different accounts and to deliver other attack modifications (using authenticated
    users to deliver XSS or Injection attacks). Thankfully, there are methods to eliminate
    these sorts of vulnerability, but web applications need to have this included.
    Some **Content Management Systems** (**CMS**s) build protection into the structure
    (Joomla!, Drupal, and so on); but for some frameworks and scratch-coded PHP and
    ASP.NET pages, it may be necessary for the developers to add on protection or
    harden their interactive pages using recommendations from the folks at OWASP ([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet))
    or the provider of their CMS.
  prefs: []
  type: TYPE_NORMAL
- en: Don't you know who I am? Account creation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Taking over an account might work short-term, but often we want a persistent
    presence on the application that does not have a very angry or upset victim trying
    to wrest back control. In the event we are able to obtain access to an admin's
    account or fool an admin user into clicking on a link, we can sometimes have them
    help us create an account on our own!
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is to have located or accurately guessed the URL for the new user
    or account creation page. Once we''ve done this, we can use a similar attack to
    our first CSRF to automate the account creation and pass it the appropriate seed
    credentials we''d like to use on it. To walk through this, we can see how this
    works by using bWAPP again, and select **`Create User`** from the top menu bar.
    You''ll see fields shown in the following screenshot, which I have already prefilled
    with my desired account information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_10-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Create User fields we'll need to fill
  prefs: []
  type: TYPE_NORMAL
- en: 'When I create an account, Burp can help me capture the string, which includes
    all of the information we''d like (as shown in the following screenshot). Now,
    we''ve got two options that we can attempt to exploit: CSRF and HTMP injection,
    which were covered in [Chapter 7](000.html#), *Injection and Overflow Testing*.
    Assuming for the sake of argument that Injection isn''t viable (maybe the target''s
    developers have closed that vulnerability), we will pursue a CSRF attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the URL strings for our forgery
  prefs: []
  type: TYPE_NORMAL
- en: 'For a CSRF attack, I could start with an HTML file similar to what I have captured
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to be particularly stealthy, we need to ensure no one receiving this page
    understands what we''re making them do.Â  The trick is to hide fields and take
    advantage of hidden attributes to carry our request past their curious inspection.
    I can do this by modifying the source to eliminate all of the labels and hide
    all user inputs with the exception of a `submit`Â button while embedding my desired
    credentials without the user being aware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will result in a page that looks like the one shown in the following screenshotÂ when
    loaded by the victim. We can make that button look like anything (**`win $1M here!`**,
    **`Verify Email`**, andÂ **`Register for seminar`**Â are all viable options).
    This could even be embedded as a link within a picture if we like; our goal is
    to craft somethingÂ innocent-looking and relevant to the user's expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_12.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple Login Page, right?
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on this, we'll see that the poor, authenticated victim
    with account creation privileges has just created an account for us, as in the
    following screenshot! The key here is to know what fields are expected. OSINT
    can help, as often new-employee instructions and help portals will give this away
    with little protection. We can also make some educated guesses based on other
    trends within the organization.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_13-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Account created, thank you!
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that CSRF is an area of very active cat-and-mouse innovation
    between hackers and defenders. Anti-CSRF tokens have become a means by which to
    protect users; but, as is the case with all of the vulnerabilities, and as we
    have seen in this book, execution is often the weakest link. In the event Anti-CSRF
    tokens are in use, hackers (and us) can try to use JavaScript in our CSRF pages
    to capture any Anti-CSRF tokens the client has and slipstream those into our GET
    or POST requests to ensure we are evading this protection. Better Anti-CSRF implementations
    of will prevent this by implementing temporal and context-driven tokens, but if
    they do not do so, there is a decent probability of circumventing these controls.
  prefs: []
  type: TYPE_NORMAL
- en: Trust me, I know the way!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For such a long name, the unvalidated redirects and forwards vulnerability
    exposes sites to ridiculously small-effort hacks that allow attackers to redirect
    users to malicious or at the very least, unintended websites. We can scan through
    the sites using automated tools, such asÂ Burp or ZAP, which will pick up on the
    potential through giveaways such as pages that make use of full site paths or
    long redirection response, both of which are seen on this site (as shown in the
    following screenshot) or simply attempt to specify extensions or modifications
    to the URL in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite scan showing Unvalidated Redirects and Forwards vulnerability
  prefs: []
  type: TYPE_NORMAL
- en: Most sites will still allow visibility into the URL when you hover over the
    link on the page, with the associated link for *here*Â shown in the following
    screenshot. This is an easy way to intuitively uncover such risks during the OSINT
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Identifying candidate hyperlinks
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, some sites will hide the hyperlink, but theÂ **`Page Source`**
    should reveal this to us, as in the following screenshot.Â  For this site, we
    can see that they are using the aforementioned relative links, which generally
    offer better protection if the site validates that only relative links are returned.
    If they use explicit, full links or allow them in lieu of a site-scope relative
    link, this will often indicate some less strictly coded validation. This is also
    a great way of seeing any other associated scripts or non-obvious hyperlinks,
    which can also be potential giveaways for the previously discussed CSRF, hidden-field
    exploits, and likewise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_16.png)'
  prefs: []
  type: TYPE_IMG
- en: View Source typically reveals more
  prefs: []
  type: TYPE_NORMAL
- en: 'The part to pay attention to is the part after `?`Â in the URL. As we''ve seen
    before, the direct inclusion of commands, scripts, fields, and now another page
    link, provides hackers with plenty of inroads to insert their own tweaks, initiate
    commands, or even refer the client to the site''s **Fully Qualified Domain Name**
    (**FQDN**). For this attack, we can simply begin to tweak the URL string and attempt
    to add our own redirects. Obviously, this could be a part of a greater attempt
    to trick users into visiting our malicious portal or kick-off a malware download,
    but for now, let''s just prove it with a benign redirect by crafting the URL as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And voila! We''ve redirected the users to our malicious site, in this case,
    just our favorite practice site [www.hackthissite.org](http://www.hackthissite.org)Â (as
    shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_17.png)'
  prefs: []
  type: TYPE_IMG
- en: Redirect success!
  prefs: []
  type: TYPE_NORMAL
- en: This simple method is often overlooked, but when the URL is hidden as a hyperlink
    within an e-mail, either completely or to just show the expected portion of the
    URL, the user has a high likelihood of clicking on it. If the action after the
    URL includes having a user access a site with an authentication they can provide,
    this can provide a toehold large enough for a hacker to take advantage of. Rarely
    is this attack alone; it is usually used to assist in lateral movement or session
    hijacking early in a more comprehensive attack's lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: I don't need your validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation in web applications is an essential step in eliminating or reducing
    the risk of compromise. XSS, injection, CSRF, Unvalidated Redirects, and Forward
    attacks all take advantage of shortcomings in the application that allow the manipulation
    of fields, exposure of previously hidden features or unused components, and a
    lack of syntax enforcement. Some additional Validation-style attacks are listed
    hereÂ and are typically detected well by full-feature scans and proxy tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CSS-injection**: CSS injection looks for code inside Common Style Sheets
    (not to be confused with XSS or Cross-Site Scripting) that is susceptible to manipulation
    or injection attacks. Like XSS and CSRF, this can be used to insert scripts or
    cause traffic rerouting, which results in either the exfiltration of data or the
    capture of credentials, tokens, and other sensitive information. In extreme cases,
    persistence can be delivered in this fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-side resource manipulation**: Really a variant of XSS, these attacks
    focus on the various user-controllable elements in a request or response that
    can cause a client to execute a malicious command or process within the browser.
    CSS-Injection is a flavor of this, but other common targets are **iFrames** in
    the web page and other linked objects (images, references, scripts, objects, and
    so on). iFrames are a common means of providing multiple sources of content to
    a single page and are used in many news and e-commerce sites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web sockets**: Web sockets attacks have not been as prevalent as anticipated,
    because how many times do you see applications using `ws://` or `wss://` in the
    URL as opposed to HTTP calls? Websockets were envisioned as a means by which you
    can provide full-duplex, asynchronous communication links between a client and
    server that are able to carry more than one TCP connection. Well, they have not
    quite taken off, but should they ever come into vogue, you can use extensions
    to Google Chrome or OWASP''s ZAP tool to test for issues with them. Like HTTP,
    we want our web sockets protected by current versions of TLS, and so many common
    OpenSSL or encryption-based attacks are fair game. They should also have strict
    rules on origin tags in their headers, so they can be tested for client-side resource
    manipulation and various injection attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-site flashing**: Cross-site flashing is very similar to XSS except
    that it preys on Adobe Flash embedments, which along with PDFs, Java jar files,
    and productivity software is a popular delivery mechanism for malware. By altering
    the embedded file, hackers can implant malware or achieve more web-oriented objectives,
    such as harvesting credentials and cookies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Origin Resource Sharing** (**CORS**): This takes advantage of a lack
    of validation in many of the attacks covered in this chapter. Most applications
    will ensure that headers communicate using several parameters and it is up to
    use to test how far out of the originating domain''s scope a request can go before
    additional validation is required. If web developers allow these headers to use
    wildcards or disable these checks, then this provides the means to attack with
    impunity. Header inspection is the primary test method, but should a vulnerability
    exist, it can be exploited through code manipulation similar to CSRF.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trendy hacks come and go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Recent trends in client-focused attacks have been focused on circumventing many
    trusted protection mechanisms and heightening user awareness. While I will not
    cover these in great detail, it is worth noting their potential and thinking about
    how to both evaluate and exploit these vulnerabilities as needed in your own testing.
  prefs: []
  type: TYPE_NORMAL
- en: Clickjacking (bWAPP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Clickjacking**Â was a prevalent attack method a few years ago that was notable
    for its use across Facebook, Twitter, Amazon, and other prominent sites. In all
    of these attacks, hackers tricked users into clicking on a masqueraded or hidden
    link to launch a malicious page or script. Simple HTML was capable of providing
    an overlapping iFrame or other mechanism whose presence was not clear to the user,
    and hackers could use this to overlay a button on top of a legitimate site component
    such that, when they thought they were clicking on a control, they were instead
    clicking on a malicious action, often to facilitate capture of their credentials,
    cookie stealing, or even hooking of the browser.Â  These techniques have been
    addressed in modern browser versions for the last few years, but it is worth being
    aware that this technique existed.'
  prefs: []
  type: TYPE_NORMAL
- en: Punycode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most English-speaking web users are unaware that there are many alphabets that
    are used in the DNSÂ around the world. While English, Germanic, and Romance language
    keyboards maybe unaware of this, browsers are fully capable of rendering these
    characters to accommodate users and companies that leverage the much wider alphabets
    from Asia, Africa, and the Middle East. The compromise was to implement an encoding
    scheme so that browsers and other applications can refer to the other characters
    accurately, and this was called **Punycode**. This does cause some confusion,
    as there are letters or symbols in different languages that are distinct despite
    looking almost identical. In April of 2017, researchers released warnings ([https://www.xudongz.com/blog/2017/idn-phishing/](https://www.xudongz.com/blog/2017/idn-phishing/))
    of hackers attempting to exploit these similarities. Browser makers such as Apple
    (Safari), Mozilla (Firefox), and Google (Chrome) are working on providing additional
    protection, but this testifies to the need for greater levels of DNS-based protection.
    By the time this book is published, it is expected that most browsers will have
    mitigation in place, but, of course, we'll want to verify that these updates are
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Forged or hijacked certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certificates and **Public Key Inrastructure** (**PKI**) are the basis for trust
    on the web and within enterprises. The premise of this arrangement is that if
    both parties are mutually authenticated using a trusted third party, what could
    go wrong? Well, hackers have been trying to pass off forged certificates for some
    time, relying on misconfigured certificates, browsers, and lax server-side implementations.
    These are fairly easy to expose and defend against, but some new dynamics are
    being planned.
  prefs: []
  type: TYPE_NORMAL
- en: The **Stuxnet** malware campaign that allegedly targeted Iranian centrifuges
    ([https://www.wired.com/2014/11/countdown-to-zero-day-stuxnet/](https://www.wired.com/2014/11/countdown-to-zero-day-stuxnet/))
    did many things that were both instructive and downright unprecedented throughout
    the duration of the attack. As a worm, it made its way through target environments
    as scripts hidden in the .LNK files themselves, particularly insidious due to
    the fact that these are automatically opened and rendered to display the icons
    for a file type. Once on machines, it established kernel-level access and persistence,
    while covering for the other processes that helped to both spread and execute
    the worm. The most shocking discovery was that it used signed software, authenticated
    using a real hardware vendor's certificate and private key. That this could happen
    was a massive blow to the PKI community, and many companies set about to ensure
    it does not happen again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast forward a few years, and now malware vendors and web hackers are finding
    that free or cheap certificate authorities available now can help them obtain
    a legitimate certificate for their malware or malicious web portal. Coupled with
    punycode or some other domain name **hijinks**, we''re now seeing XSS funnel users
    to malicious portals that fool users with the now conspicuous *trusted site* icon
    seen in Firefox in the following screenshot. It should be noted that these attacks
    are still rare, but that we should expect more hackers will attempt to exploit
    them in the future as a countermeasure against the proliferation of TLS use on
    the web and browser default settings that prevent self-signed, expired, or forged
    certs from being accepted unless explicitly bypassed. As testers, we''ll want
    to ensure that our scans show proper PKI configurations, the use of recent versions
    of TLS only, and that corporate browser standards do not cave in certificate validation,
    or even decide upon explicit certificate configuration to avoid signed malware
    or redirects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_10_18.png)'
  prefs: []
  type: TYPE_IMG
- en: Certificate Trust isn't what it used to be
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side vulnerabilities and their exploits expose the blind spots that most
    web developers have; they aren't used to owning the security on a client's platform
    and can fall into the trap of looking myopically at only protecting their framework
    or application. Hackers see this as an opportunity with a tremendous plus side.
    They can compromise the end user, while pivoting from them to take advantage of
    their authenticated or cached status and thereby compromise the web server. We
    as a community need to ensure application owners understand that it is in their
    best interests to fortify their website against exposing client-side vulnerabilities,
    as improved client security dramatically reduces the attack surface of the application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't easy--there is a near infinite combination of operating systems,
    browsers, patch-levels, access modes, and other factors that can impact a client's
    exposure. Best-practice based design, patching, and attention to detail are the
    best defences against these potentially fatal flaws. We should also endeavour
    to encourage the use of well-tested frameworks rather than custom-designed components
    wherever possible. As with the Authentication and Session Management vulnerabilities
    discussed in [Chapter 9](000.html#), *Stress Testing Authentication and Session
    Management*, we'd much rather benefit from the larger footprint and extensiveÂ scrutiny
    and vetting these widely available components see than to find out that our target's
    unique implementation had a flaw that remained undetected until exploited by hackers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll finish our testing by taking a look at how we can
    put the business logic of the application through its paces. This last discipline
    really focuses on the application tier's design and error handling, and while
    we'll see some themes return (injection and fuzzing, for instance), we're really
    hoping to ensure that even authenticated users are unable to *break* the target
    and cause issues or access unintended data or functions. While this chapter focused
    on HTML and made sparing use of our toolset, [Chapter 11](000.html#),Â *Breaking
    the Application Logic,Â *will see a return to Burp and ZAP, as their ability to
    automate will be a huge help in covering all of the iterations a site can expect.
    We're almost at the end, but hopefully you're still building your arsenal and
    seeing how huge and fun the landscape ofÂ web app pen testing is!Â
  prefs: []
  type: TYPE_NORMAL
