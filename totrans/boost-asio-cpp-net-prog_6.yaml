- en: Chapter 6. Creating a Client-server Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we delved into the `Boost.Asio` libraries, which are
    important in order to develop a network application. And now, we will move to
    a deeper discussion about a **client-server** application that can communicate
    with each other over a computer network between two or more computers. One of
    them is called **client** and the other one is the **server**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to discuss the development of the server, which is able to send
    and receive data traffic from the client and also create a client-side program
    to receive data traffic. In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a connection between the client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving data between the client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping the most frequently used code to simplify the programming process by
    avoiding code reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing a connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked about two types of Internet Protocol (IP) in [Chapter 2](part0020_split_000.html#page
    "Chapter 2. Understanding the Networking Concepts"), *Understanding the Networking
    Concepts*. These are Transmission Control Protocol (TCP) and User Datagram Protocol
    (UDP). TCP is connection-oriented, which means data can be sent just after the
    connection has been established. In contrast, UDP is connectionless Internet protocol,
    which means the protocol just sends the data directly to the destination device.
    In this chapter, we will only talk about TCP; therefore, we have to establish
    the connection first. Connection can only be established if the two parties, in
    this case, the client and server, accept the connection. Here, we will try to
    establish a connection synchronously and asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start with establishing the synchronous connection to a remote host. It
    is acting as a client, which will open a connection to the Packt Publishing website
    ([www.packtpub.com](http://www.packtpub.com)). We will use TCP protocol, as we
    discussed earlier in [Chapter 2](part0020_split_000.html#page "Chapter 2. Understanding
    the Networking Concepts"), *Understanding the Networking Concepts*. Here is the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `connectsync.cpp` and run the following command
    to compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program by typing `connectsync` in the console, and we should get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A synchronous client](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The program will exit as soon as we press the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us analyze the code. As we can see in the preceding code, we use our
    previous sample code and insert a line of code in order to make it able to establish
    a connection. Let''s draw our attention to the line we have inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a global variable, which is `socket`. This variable will be used
    to provide socket functionality. It comes from the namespace `boost::asio::ip::tcp`
    because we use TCP as our protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also use the namespace `boost::asio::ip::tcp::resolver`. It is used to get
    the address of the remote host we that want to connect with. With the `query()`
    class, we pass the Internet address and port as a parameter. But because we use
    an integer type for a port number, we have to convert it to a string by using
    `lexical_cast`. The query class is used to describe the query that can be passed
    to a resolver. Then, by using the `iterator` class, we will define iterators from
    the results returned by a resolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the iterator is successfully created, we give it to the `endpoint` type
    variable. The endpoint will store the list of `ip` addresses that are generated
    by the `resolver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `connect()` member function will connect the socket to the endpoint,
    which we specified before. If everything runs properly and no error or exception
    is thrown, the connection is now established:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To release the connection, we have to disable the sending and receiving data
    process on the socket first by using the `shutdown()` member function; then, we
    invoke the `close()` member function to close the socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the program and get output like the preceding image, it will inform
    us that the connection has been established. We can change the port number, for
    example, to `110`, which is Remote TELNET Service protocol, in the `query()` class
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the program will throw an exception, and the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A synchronous client](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can conclude that the connection has been refused by the
    target machine because the port we plan to connect to is closed. This means that
    by using port `80`, which is **Hypertext Transfer Protocol** (**HTTP**), we can
    make a connection with the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already been able to establish a connection synchronously. But how
    about if we need to connect asynchronously to the target so that the program will
    not freeze while trying to make a connection? Let us take a look at the following
    code to find the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, save the preceding code as `connectasync.cpp` and run the following command
    to compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to run the program, and you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An asynchronous client](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding code, we add the `OnConnect()` function. Because
    the `socket` object is noncopyable, and we need to ensure that it is still valid
    while the handler is waiting to be called, we have to use the `boost::shared_ptr`
    namespace. We also use the `boost::bind` namespace to invoke the handler, that
    is, the `OnConnect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know how to connect to a remote host synchronously and asynchronously.
    Now, we are going to create the server program to talk with the client-side program
    that we created before. Because we will deal with the asynchronous program in
    the `boost::asio` namespace, we will discuss the client-side program in an asynchronous
    server only. Let us take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `serverasync.cpp` and run the following command
    to compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run the program, let us distinguish the code. We now have a new object,
    which is `tcp::acceptor`. This object is used for accepting new socket connections.
    Due to the use of the `accept()` function, we need to add the `mswsock` library
    to our compilation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to run the program. We need to open two command consoles here.
    The first console is for the program itself and the second is for calling `telnet`
    command to make a connection to the server. We only need to run the command `telnet
    127.0.0.1 4444` just after we run the `serverasync` program (we can refer to [Chapter
    2](part0020_split_000.html#page "Chapter 2. Understanding the Networking Concepts"),
    *Understanding the Networking Concepts*, to call the `telnet` command in the command
    prompt). The output should be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An asynchronous server](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding image, we can see that the program is listening to port `4444`
    when it starts, and after we call the `telnet` command to start a connection to
    port `4444`, the program accepts the connection. However, because we only have
    one socket object and invoke the `async_accept()` function just once, the program
    will accept one connection only.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to the socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are officially able to make a client-server connection. Now, we are going
    to write and read the socket to make the connection more useful. We will modify
    our previous code, `serverasync.cpp`, and add the `basic_stream_socket` object,
    which provides stream-oriented socket functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get more detailed information about the `basic_stream_socket` object, you
    can visit [www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket.html](http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio/reference/basic_stream_socket.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at the following code containing the read and write socket
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `readwritesocket.cpp` and compile the code using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compare the code of the `readwritesocket.cpp` file with the `serverasync.cpp`
    file, we will find that we add a new class called `ClientContext`. It contains
    five member functions: `Send()`, `OnSend()`, `Recv()`, `OnRecv()`, and `Close()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Send() and OnSend() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Send()` function, we input an array of characters and their length.
    Before the function sends the array of characters, it has to check whether or
    not the `m_send_buffer` parameter is empty. The sending process can only occur
    if the buffer is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::asio::async_write` namespace writes the socket and invokes the `OnSend()`
    function handler. Then, it erases the buffer and sends the next pending data if
    there is any. Now, every time we press any key in the `telnet` window, it will
    display what we have typed because the `readwritesocket` project sends back what
    we type to the `telnet` window.
  prefs: []
  type: TYPE_NORMAL
- en: The Recv() and OnRecv() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the `Send()` function, the `Recv()` function will call the `async_read_some()`
    function to receive the set of data, and the `OnRecv()` function handler will
    format the received data to hexadecimal formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the network code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our convenience, let us create a wrapper for a networking application. In
    using this wrapper, we do not need to reuse our code over and over again; thus,
    making our programming process simpler and more efficient. For now, just create
    two files called `wrapper.h` and `wrapper.cpp`, and we will include them in the
    compilation process in our next code. Because the source codes are quite long
    in length and will not be convenient to print in this book, I have made them into
    downloadable files that you can access in this book's repository at [www.packtpub.com/networking-and-servers/boostasio-c-network-programming-second-edition](http://www.packtpub.com/networking-and-servers/boostasio-c-network-programming-second-edition).
    Go to the **Code Files** section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a client and server program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already had the network wrapper code simplify our programming process
    in developing a network application by using the `Boost.Asio` library. Now, let
    us create a client and server program by using our wrapper code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple echo server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create a server program that will echo out all traffic it retrieves
    from the client. In this case, we will use the `telnet` as the client, as we''ve
    done previously. The file has to be saved as `echoserver.cpp`, and the content
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compile the preceding code using the following command. Here, we can
    see that we include `wrapper.cpp` in the compilation process to take advantage
    of our wrapper code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try the preceding program by typing `echoserver` in the console window;
    after which, we should get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple echo server](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first time we run the program, it will listen to port `4444` in `localhost`.
    We can see in the `main` block that the program calls the `poll()` function in
    the `Hive` class if there is no keyboard hit. This means that the program will
    close if any key is pressed because it will invoke the `Stop()` function in the
    `Hive` class, which will stop the `io_service` object. Every 1000 milliseconds,
    the timer will tick because the constructor of the `Acceptor` class initiates
    the interval of the timer for 1000 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open another console window and type the command `telnet 127.0.0.1 4444`
    to make `telnet` our client. After the `echoserver` accepts the connection, every
    time we press the alphanumeric option on the keyboard, the `echoserver` will send
    the character back to `telnet`. The following image describes the acceptance connection
    between the `echoserver` and the `telnet` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple echo server](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the server accepts the connection from the client, the `OnAccept()` function
    handler will be invoked immediately. I pressed the *A*, *B*, and *C* keys respectively
    in the `telnet` window, and then `echoserver` received the characters and sent
    them back to the client. The `telnet` window also displays `A`, `B`, and `C`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple client program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have successfully created a server-side program. Now, we will move on to
    develop the client-side program. It will receive the content of the Packt Publishing
    website through the `HTTP GET` command, and the code will be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `clienthttpget.cpp`, and compile the code using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program, the following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple client program](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just after the connection is established, the program sends an `HTTP GET` command
    to port `80` of [www.packtpub.com](http://www.packtpub.com) using the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we use the `strand` object in order to allow all events to be
    serially run. In addition, because of the `strand` object, we do not have to use
    the `lock` object every time the event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the request is sent, the program will pool the incoming data using the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Then, once the data is coming, it will be displayed in the console by the `OnRecv()`
    function handler, as we can see in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three basic steps when it comes to developing a network application.
    The first step includes establishing a connection between the source and target,
    which means the client and server. We can configure the `socket` object along
    with the `acceptor` object to establish the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we exchange data by reading and writing to the socket. For this purpose,
    we can use the `basic_stream_socket` functions collection. In our previous example,
    we used the `boost::asio::async_write()` method to send the data and the `boost::asio::async_read()`
    method to receive the data. Finally, the last step is releasing the connection.
    By using the `shutdown()` method in the `ip::tcp::socket` object, we can disable
    the sending and receiving of data on the socket. Then, invoking the `close()`
    method after the `shutdown()` function will close the socket and free up the handler.
    We also have already created a wrapper for all functions, which is most frequently
    used in network application programming by accessing the `Boost.Asio` library.
    This means we can develop a network application simply and efficiently since we
    do not need to reuse code over and over again.
  prefs: []
  type: TYPE_NORMAL
