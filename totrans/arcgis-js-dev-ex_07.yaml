- en: Chapter 7. Map Analytics and Visualization Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Performing analytics on map data will reveal a lot of spatial patterns that
    would otherwise stay hidden. The API provides a lot of methods to elicit such
    information using advanced statistical queries on the data. Combine this with
    the intuitive data visualization methods provided by the API and you''re one step
    nearer to becoming a map data scientist. We will be building a demographics analytic
    portal in this chapter by first trying to understand a few basic statistical concepts,
    and then by practically applying those in the code with the aid of the analytic
    and rendering modules provided by the API. Specifically we will be covering the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the demographics analytic portal we're going to develop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to basic statistical measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules provided by the API to calculate the feature statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to the classification methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code-backed explanation for developing renderers with visual variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing multivariate mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing automatic mapping using smart mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a demographics analytic portal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a demographic analytic portal to demonstrate the advanced
    analytics capabilities of the API. Demographics refers to the classification of
    the population living in an area based on various socio-economic factors such
    as age, educational attainment, nationality, median household income, race, gender,
    and so on. The demographic data is mostly based on Census data and other reliable
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: The demographics can be used to perform various analytics and is equally useful
    to government to make policy decisions and businesses to make marketing decisions.
    The power of demographic data lies in performing appropriate analytics such that
    we can extract useful information about the population living in an area in comparison
    to the ones surrounding it. Let's consider this URL, which provides detailed statistics
    on the median household income at block level—[http://demographics5.arcgis.com/arcgis/rest/services/USA_Demographics_and_Boundaries_2015/MapServer](http://demographics5.arcgis.com/arcgis/rest/services/USA_Demographics_and_Boundaries_2015/MapServer).
  prefs: []
  type: TYPE_NORMAL
- en: 'This map service shows the most updated 2015 demographic data for the USA.
    Among the hundreds of demographic parameters provided, we are interested in the
    median household income in the United States in 2015\. Income amounts are expressed
    in current dollars, including an adjustment for inflation or cost-of-living increases.
    The median is the value that divides the distribution of household income into
    two equal parts. For more information on this map, including the terms of use,
    visit this URL: [http://doc.arcgis.com/en/living-atlas/item/?itemId=6db428407492470b8db45edaa0de44c1&subType=demographics](http://doc.arcgis.com/en/living-atlas/item/?itemId=6db428407492470b8db45edaa0de44c1&subType=demographics)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These data are provided as a part of the Living Atlas endeavor of Esri. To
    use this data, you will require an ArcGIS Online organizational subscription or
    an ArcGIS Developer account. To access this item, you''ll need to do one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in with an account that is a member of an organizational subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign in with a developer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you don''t have an account, you can sign up for a free trial of ArcGIS or
    a free ArcGIS Developer account at this link: [https://developers.arcgis.com/en/sign-up/](https://developers.arcgis.com/en/sign-up/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic statistical measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss some basic statistics so that we can utilize some of the statistical
    functionality provided by the API to the fullest extent. The five basic statistical
    parameters we may need to understand clearly before proceeding further are:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, this implies the least value in a dataset. In our case
    of the block-level household income, the `minimum` statistic indicates the block
    with the least median household income.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the `minimum`, the `maximum` statistic defines the maximum median
    household income value among all the blocks considered.
  prefs: []
  type: TYPE_NORMAL
- en: Sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Sum` is a simple yet effective statistic that gives us the total value of
    all the data being considered.'
  prefs: []
  type: TYPE_NORMAL
- en: Average
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `Average` statistic defines the arithmetic mean value of all the values.
    An average is derived by dividing the `Sum` statistic by the count of the data
    values taken for the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Standard deviation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Standard deviation is perhaps the most important statistic that one can derive
    from any given data. Standard deviation is a measure of how spread out the data
    are or how much the data deviates from the mean or average. When we know the standard
    deviation, we can normally observe that:'
  prefs: []
  type: TYPE_NORMAL
- en: 68% of values are within plus or minus one times the standard deviation from
    the mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 95% of values are within plus or minus two times standard deviation from the
    mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 99.7% of values are within three times the standard deviation from the mean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is based on the fact that most data follows the normal distribution curve.
    When we order the data and plot the values, the histogram looks like a bell curve.
  prefs: []
  type: TYPE_NORMAL
- en: Standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing the concept of standard deviation and mean, we can normalize our data.
    This process is known as **standardization** and the statistical measure derived
    from the process is known as the **standard score** (`z-score`). When we have
    datasets with large values, standardization is an effective way to summarize the
    data and quantify it.
  prefs: []
  type: TYPE_NORMAL
- en: So to convert any value to a standard score (`z-score`), we need to first subtract
    the value from the mean, then divide by the standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Statistical functionality provided by the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's investigate what the API has to offer us in terms of these basic statistical
    measures. Later we will use these statistical measures in our application to provide
    better insight into the data. We will also use these techniques in our visualization
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: StatisticDefinition module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The API provides a module called the `StatisticalDefinition` module, which can
    be used in conjunction with the Query task and Query modules to extract the basic
    statistical measures we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module name: `esri/tasks/StatisticDefinition`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the properties used to define a statistic definition object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onStatisticField`: Used to define the field on which statistics will be calculated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outStatisticFieldName`: The name of the output field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statisticType`: Used to define the type of statistic. The accepted statistic
    types are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: to get the minimum statistic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max`: to get the maximum statistic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum`: the get the sum statistic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`avg`: to derive the average value statistic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stddev`: to derive the standard deviation statistic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to use these and derive these statistical measures on the demographics
    layer URL we just provided at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a code snippet and explains how these statistics
    are derived for the county layer in the demographics map service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![StatisticDefinition module](graphics/B04959_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The required statistics can be extracted using this simple code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The console screen should look like this after the code has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The derived statistics such as `Plus1StdDev`, `Plus2StdDev`, `Plus3StdDev`,
    `Minus1StdDev`, `Minus2StdDev`, and `Minus3StdDev` shall be used later to render
    the data better.
  prefs: []
  type: TYPE_NORMAL
- en: Classification methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have a large quantity of data, we use rendering methods to classify
    it. We need to identify an appropriate classification method to create the class
    breaks. The following classification methods are supported by the API:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural breaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard deviation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss very briefly the implications of using each classification method.
  prefs: []
  type: TYPE_NORMAL
- en: Equal interval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This classification method breaks the data into equal parts. We need to know
    the data range to use this classification method. This method should be used when
    the data is dispersed and well distributed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Equal interval](graphics/B04959_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Natural breaks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Natural breaks is a classification method based on the Jenks Break Algorithm.
    Basically, this algorithm creates more numbers of breaks at locations where data
    is more clustered. This is done by seeking to minimize each class's average deviation
    from the class mean, while maximizing each class's deviation from the means of
    the other groups. In other words, the method seeks to reduce the variance within
    classes and maximize the variance between classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Natural breaks](graphics/B04959_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Quantile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method classifies data such that there are an equal number of data points
    in each group.
  prefs: []
  type: TYPE_NORMAL
- en: Standard deviation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed previously, standard deviation is a measure of how much the data
    deviates from the mean. Using this classification methodology, we can find how
    much and also where the data is within beyond three standard deviations (outliers'
    cases), between two and three standard deviations (higher and lower end values),
    and within one standard deviation from the mean.
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard deviation](graphics/B04959_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Concept of normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normalizing a data value is useful for computing a lot of things. Consider
    the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1**: We need to symbolize how densely populated each state is. Symbolizing
    based on the population field would give a wrong measure or convey wrong information.
    All we might have to do is to divide each state''s population by its geographic
    area to get a measure of the population density.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, if we need to convey the percentage of youth population (age < 35)
    against the total population, we need to divide the field having the youth population
    by the field displaying the total population.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 2**: When trying to symbolize the income distribution of the entire
    world, we may encounter a large range of values. If we were to use a color or
    opacity renderer, some countries would be on the higher end of the spectrum, while
    some would be at the bottom with many in between, with lots of color information
    not really used up. In such scenarios, it would be more useful to display the
    income distribution using a logarithmic scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case 3**: When we need to calculate the value as a percentage of totals such
    as crime data or number of participants from each state in a marathon, we need
    to divide the value by the total.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many renderers have a `normalizationField` and `normalizationType` property
    to implement such normalization.
  prefs: []
  type: TYPE_NORMAL
- en: '`normalizationField` lets us define the field that is used for normalization.
    For example, for *Case 1*, the `Area` field and `Total Population` field is the
    `normalizationField`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`normalizationType` is the type of normalizing that needs to be performed on
    the value. The three possible values for `normalizationType` are field, log, and
    percent-of-total. For example, for *Case 1*, we need to use the `normalizationType`
    as `field`. For *Case 2*, we need to use `log`, and for *Case 3*, we need to use
    `percent-of-total` as `normalizationType`.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature layer statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In version 3.13 of the API, this plugin was introduced that could prove handy
    for calculating feature layer statistics. Using the feature layer statistics plugin,
    we can calculate the statistics for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic statistics on a field for a feature layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class break statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique values in a field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggested scale range for viewing a layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a sample feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating a histogram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin can be added to the feature layer using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, `CountyDemogrpahicsLayer` is the name of the feature
    layer to which the `FeatureLayerStatistics` plugin is being added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual parameters expected by the methods used in the plugin are `field`
    and `classificationMethod`. The `field` plugin refers to the name of the attribute
    field based on which the statistic is computed. The `classificationMethod` refers
    to one of the classification methods discussed previously based on which statistics
    are computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods on the plugins always return a promise. The following snippet calculates
    the basic statistical values on the field as defined in `featureLayerStatsParams`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The results look like this in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous result provided about the same or more information as that derived
    from the statistical definition module that we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet calculates the class break values on the field as defined
    in `featureLayerStatsParams`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The beautified result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Working with continuous and break renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous renderers refers to renderers that symbolize features on a continuous
    spectrum of values unlike unique value renderers. We need to define several `stops`
    or `breakpoints` for such renderers. These `stops` define a class and the renderer
    checks which class each value falls into. Based on the class, the data is visualized
    with the aid of visualization variables such as color, size, opacity, or even
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the statistics available, we can use the `ClassBreaksRenderer` provided
    by the API to create classed and continuous renderers easily. `ClassBreaksRenderer`
    symbolizes each graphic based on the value of some numeric attribute with different
    visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module name: `esri/renderers/ClassBreaksRenderer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The setting of color, size, or opacity is enabled on this module with the aid
    of properties such as `colorInfo`, `opacityInfo`, and `sizeInfo`. The following
    methods are available on the `ClassBreaksRenderer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setColorInfo`(`colorInfo`): Sets the `colorInfo` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setOpacityInfo`(`opacityInfo`): Sets opacity info for the renderer as defined
    by the info parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setRotationInfo`(`rotationInfo`): Modifies rotation info for the renderer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setSizeInfo`(`sizeInfo`): Sets size info of the renderer to modify the symbol
    size based on the data value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s discuss more about these in detail. The following diagram provides a
    brief guide to developing a renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with continuous and break renderers](graphics/B04959_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ColorInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ColorInfo` is an object used to define the color ramp to render the layer.
    We only need to provide discrete sets of color values at the `stops` or sometimes
    just the color values in the ramp:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `ColorInfo` object example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To create a classed color renderer, we need define a `stops` object to define
    discrete colors instead of continuous colors. A `stops` object will contain the
    color at each `stop`. When defining `stops`, we need *not* define the `minDataValue`
    or `maxDataValue`. Let's discuss a bit about where we can get an appropriate color
    scheme for our renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a color scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following website provides us with an easy way to choose a color scheme
    that can be used for constructing a `colorInfo` object or color ramps: [http://colorbrewer2.org/](http://colorbrewer2.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this website you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the number of data classes—the default is `3`. The API's default number
    of classes is `5`. So change the drop down value to `5` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the nature of your data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sequential**: Use this to show an incremental quantity such as population
    or population density.![Selecting a color scheme](graphics/B04959_07_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**diverging**: Use this to emphasize the difference in values, especially at
    the extreme ends. For example, when mapping median income, the lower end of the
    income scale may be displayed in red and the higher end in blue.![Selecting a
    color scheme](graphics/B04959_07_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**qualitative**: This color scheme is used when we need to differentiate distinct
    values or classes using different colors.![Selecting a color scheme](graphics/B04959_07_08.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick as multihued or a single-hue color scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constraint the color hues based on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Purpose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color-blind friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Photocopy safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Context:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Borders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Export the color scheme as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaScript Array object—this is the handiest function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adobe PDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Selecting a color scheme](graphics/B04959_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a classed color renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discussed earlier, to create a classed color renderer, we need to define
    a `stops` object to define discrete colors instead of continuous colors. A `stops`
    object will contain the color at each stop. A `stops` object is an array object
    that is assigned to the renderer object. A `stops` array object contains objects
    with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `stops` object mostly looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s find a way to automatically populate the `stops` object. Remember
    we can get an array of colors based on a color scheme we select from the `colorbrewer2.org`
    website. The `color` array can be used to fill the `color` property of each object
    in the `stops` object. The `value` property of each object in the `stops` object
    can be derived from the return object of the `featureLayerStatistics` computation.
    The `featureLayerStatistics` computation provides the `minimum`, `maximum`, and
    `label` values for each class. We can assign the maximum value of each class to
    the `value` property for each object in the `stops` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating a classed color renderer](graphics/B04959_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: opacityInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`opacityInfo` is an object that defines how a feature''s opacity is calculated.
    The `opacityInfo` object can be used to set the opacity levels for the classes
    in a `ClassBreaksRenderer`. The `opacityInfo` object can also be used to set a
    continuous opacity renderer.'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the `colorInfo` object, you can either specify the opacity values
    as an array along with the minimum and maximum data value, or you can define the
    `stops` object within which you can define the opacity value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `opacityInfo` to create a continuous renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using opacityInfo to create a classes opacity renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's use the `opacityInfo` to render another field representing the diversity
    Index of each county. The diversity index measures diversity on a scale from `0`
    to `100`. The diversity index, an Esri proprietary index, is defined as the likelihood
    that two persons, selected at random from the same area, would belong to a different
    race or ethnic group. The diversity index measures only the degree of diversity
    in an area, not its racial composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objective is to display the counties with a higher diversity index with
    higher opacity values, and counties with a lesser diversity index with lesser
    opacity values. The opacity values can be broken between a minimum and maximum
    value by using the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, `opacity_stat_result` is the promise result of the
    `getClassBreaks()` method of the `FeatureLayerSatistics` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Using opacityInfo to create a classes opacity renderer](graphics/B04959_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SizeInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SizeInfo` object defines the size of the symbol where feature size is proportional
    to data value.
  prefs: []
  type: TYPE_NORMAL
- en: The API help page mentions that the symbol size can represent two different
    types of data—distance and non-distance. The distance data type refers to the
    actual distance on the field, and the non-distance data type refers to the cartographic
    size of the symbols. Representing the tree canopy using the `sizeInfo` based on
    the actual diameter of the canopy is an example of distance data-type. Representing
    the size of the roads based on the traffic density or size of the states based
    on the population density or median income enhances the cartographic presentation
    of the feature.
  prefs: []
  type: TYPE_NORMAL
- en: RotationInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RotationInfo` can be used to define how marker symbols are rotated. `RotationInfo`
    can be used to depict wind direction, vehicle heading, and so on. A field specifying
    the rotation angle must be present to define the `RotationInfo`. There are two
    types of rotation angle units allowed. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**geographic**: This represents angles from the geographic north in a clockwise
    direction. Wind speeds and car directions are normally expressed in geographic
    angles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**arithmetic**: This represents angles measured in an anticlockwise direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the difference between geographic and arithmetic
    angles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RotationInfo](graphics/B04959_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multivariate mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been discussing rendering features using a single field name
    or variable. And we have also been discussing the various visual variables that
    can be used to render features such as color, opacity, size, rotation, and so
    on. What if we could combine the visual variables and render features based on
    more than one field value?
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, when mapping at county level, we may consider using color to
    represent population density, opacity to indicate median household income, and
    size to indicate the percentage of federal spending on education, which is normalized
    by the population field. The number of fields we choose to use is limited to the
    four visual variables, namely: color, opacity, size, and rotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multivariate mapping is enabled by a property known as `visualVariables` in
    `ClassBreaksRenderer`. Let''s try to use two visual variables, namely `colorInfo`
    and `opacityInfo`, which we used to demonstrate two different demographic parameters,
    namely median household income and diversity index. Our current objective would
    be to represent median house income using color, and at the same time determine
    the opacity value of the features based on the diversity index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Multivariate mapping](graphics/B04959_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Smart mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the knowledge of all these statistics, it's time to go smart with mapping
    using the smart mapping module provided by the API. Imagine a module that can
    automatically call the renderer parameters on its own given a few basic inputs,
    such as the feature layer on which the renderer needs to be generated and the
    classification method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Module name: `esri/renderers/smartMapping`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The smart mapping module provides several methods, each of which produces a
    renderer. The renderers that the smart mapping module can produce are:'
  prefs: []
  type: TYPE_NORMAL
- en: Color-based classed renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Size-based classed renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-based renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heat map renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart mapping even takes care of the rendering based on the Basemap. For example,
    a certain color or opacity renderer works well with a darker-themed Basemap such
    as satellite, and certain renderers work well with a light-themed Basemap such
    as street maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'With three simple steps, you can let the API decide the color scheme and create
    the classes color renderer for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a schemes object from the Esri styles `choropleth` module (import
    `esri/styles/choropleth`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Construct a classed color parameter object with the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basemap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`classificationMethod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`field`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheme`—choose the `primaryScheme` property from the schemes object constructed
    earlier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numClasses`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a classed color parameter object as a parameter to the `createClassedColorRenderer()`
    method belonging to the smart mapping module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the renderer property returned by the smart mapping method to the feature
    layer's `setRenderer()` method as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redraw the feature layer and refresh the legend object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code explains how smart mapping can be used to create a classed
    color renderer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshots show the classed color renderer created using the
    smart mapping module for four different classifications, namely equal interval,
    natural breaks, quantile, and standard deviation. The user's discretion is used
    to decide which would serve as the best classification method based on the purpose
    of mapping the data, and also the audience.
  prefs: []
  type: TYPE_NORMAL
- en: We can manually define the color scheme by editing the `scheme` object, which
    is a property in the parameter object for the `createClassedColorRenderer()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Smart mapping](graphics/B04959_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are one step closer to becoming a map data scientist. We covered a lot of
    ground in this chapter, starting with a brush up of a few introductory statistics
    concepts. We then saw the code in action in how a statistics definition and feature
    layer statistics module can give us invaluable statistic measures that can be
    used to render the map data meaningfully. We then evaluated how to use the visual
    variables such as `colorInfo`, `opacityInfo`, `rotationInfo`, and `sizeInfo` effectively
    in a renderer. We also tried to combine these visual variables and performed a
    multivariate rendering. And, finally, we tried our hands at automatic rendering
    using the smart mapping module. In the next chapter, we will be dealing with charts
    and other advanced visualization techniques to provide analytical information
    to the users.
  prefs: []
  type: TYPE_NORMAL
