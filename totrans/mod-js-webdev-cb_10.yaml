- en: Testing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with Jest and Enzyme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing reducers and mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing actions and thunks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing changes with snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we dealt with debugging. Now let's add some unit testing
    recipes to round out all we'll need for development. As we've seen before, having
    good unit testing helps not only with development, but also as a preventive tool
    to avoid regression bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components with Jest and Enzyme
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and
    Debugging Your Server*, we did unit testing for our `Node` code, and we used `Jest`
    for it. As we said there, an advantage of this package is that we can also use
    it with `React` (or `React Native`, which we'll be looking at in [Chapter 11](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml),
    *Creating Mobile Apps with React Native*), so everything we learned about earlier
    in this book still holds; give it a quick look over if you will, so we won't have
    to repeat ourselves here.
  prefs: []
  type: TYPE_NORMAL
- en: What shall we test? Obviously, we'll have to write unit tests for our components,
    but since we've been using `Redux`, we'll also require tests for reducers, actions,
    and thunks; we'll cover all of these topics in this section and the following
    ones. Some of these tests will be quite simple to write, and for others, some
    more work will be needed. Let's get started, then!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For `Node`, we had to install `Jest` on our own, but `create-react-app` already
    does that for us, so it's one less thing to worry about. (If you created the `React`
    application on your own, by writing your own configuration files then you should
    take a look at [https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)
    to see how to proceed.) We will, however, also use `Enzyme`, a package that will
    simplify making assertions about, or manipulating, the HTML that your components
    produce in a way that is quite similar to `jQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about these functions, or if you haven't used `jQuery`
    for a while (my own case!), read about `cheerio`, the package that's used by `Enzyme`,
    at [https://github.com/cheeriojs/cheerio](https://github.com/cheeriojs/cheerio).
    For `Enzyme` itself, including its configuration, you can visit its GitHub site
    at [https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using version 16 of `React`, the current way to install the package
    is as follows; the `enzyme-adapter-react-16` additional package is needed to link
    `Enzyme` with `React`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another nice thing is that we won''t need to do any particular configuration,
    because `create-react-app` also takes care of setting everything up. However,
    should you decide that you need something special, `react-app-rewired` will help:
    check out [https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired)
    for more on that.'
  prefs: []
  type: TYPE_NORMAL
- en: We have everything we need; let's get testing!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What components should we test? We have worked with connected and unconnected
    components already, but we'll focus on the latter here. Why? Connected components
    get their props and dispatch logic from the `mapStateToProps()` and `mapDispatchToProps()`
    functions; we can trust this is so, and therefore we don't actually have to test
    it. If you want, you could set up a store and verify that those two functions
    do their job—but those test are trivial to write, and I wouldn't suggest that
    you actually need them. Instead, we'll focus on the unconnected version of the
    components and fully test them. We'll set up all of the tests here, and then we'll
    look at how to run them, and what output to expect.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component without events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to test a component, so let's pick up a suitable one. For our first
    unit testing, let's work with the `<RegionsTable>` component, which didn't process
    any events; it was just a display component. Tests are usually named the same
    way as the component, but changing the extension from `.js` to `.test.js`—or to
    `.spec.js`, but I like `.test.js` better. Pick whatever you want, and just be
    consistent about it.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start by considering what should we test. The specification for
    our component says that it works differently depending on whether it receives
    an empty or non-empty list of countries. In the first case, we can test that the
    produced HTML text includes *No regions*, and in the second case, we should verify
    that all of the provided regions do appear in the output. Of course, you can think
    up more detailed, specific cases, but try not to make your tests too *brittle*,
    meaning that the slightest change in implementation will make your tests fail.
    The tests that I described may not cover all cases, but it's pretty certain that
    even if you were to implement the component in a different way, the tests should
    still be successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting out with the actual tests, all of them will start in a similar way:
    with us needing to import to necessary libraries, plus the component to test,
    and setting up `Enzyme` and its adapter. In the following code, I''ll highlight
    the related lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did earlier, we''ll start using `describe()` and `it()` to set up different
    test cases. To check the empty regions list case, we can just use a few lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use `Enzyme.render()` to generate the DOM for our component, and the `.text()`
    method to generate a text version of it. With the latter, we just need to verify
    that the desired text appears so that the whole test is really short.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also had a second use case, in which we provided a non-empty list of regions.
    The code is similar, but obviously longer; let''s check out the code first, and
    we''ll explain it after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is pretty similar: render the components, produce text, check that
    the right content is there. As we said, you could also verify if each region is
    within a `<li>` element, and if they have keys, and so on; keep in mind, however,
    what we wrote about brittle tests, and avoid over-specifying the tests, so that
    only one possible, specific, given implementation of the component could pass
    them!'
  prefs: []
  type: TYPE_NORMAL
- en: Testing a component with events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to test a component with events. For this, the `<CountrySelect>`
    component will come in handy, because it can process some events, and it will
    call some callbacks accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s see the initial setup, including a list of countries that
    we''ll be using for different tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what cases will we write unit tests for? Let''s start with the case in
    which no list of countries is given: according to what we wanted, in that case,
    the component would have to use a prop, such as `getCountries()`, to get the necessary
    data. We''ll use *spies* again (we saw them in the *Using spies* section of [Chapter
    5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging Your Server*)
    to simulate and test the necessary behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating two spies: one for the `onSelect` event handler, and one to
    get the list of countries. Testing that the output of the component includes the
    `"Loading countries"` text is simple; let''s focus on the spies instead. We expect
    that the component should have called the function to get the list of countries
    (but only once!) and that the event handler should not have been called: the last
    two checks take care of this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what should happen if a list had been provided? We can write a similar
    test, and just verify, for a difference, that the component didn''t call the function
    to get the (already given) countries; I have highlighted the related code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the tests we have already written, this part of the code should have
    been easy to understand: we have already seen similar tests before, so we don''t
    have anything new to explain here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to the final, more interesting, situation: how do we simulate that
    the user selected something? For this, we''ll have to detect the `<select>` element
    within our `<CountrySelect>` component, and for that I decided to provide a name
    attribute: I changed a single line in the component''s original `render()` method
    and changed it from `<select onChange={this.onSelect}>` to `<select onChange={this.onSelect}
    name="selectCountry**"**>`, so that I have a way to get at the element. Of course,
    you could object to changing the original component code in any way, and you could
    also very correctly add that this makes the test somewhat brittler than before;
    should the component be re-coded in a different way, without using a `<select>`
    element, the test would automatically fail, and you''d be right. This is a judgment
    call as to how far to go in the tests, and what extra baggage is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish our suite of tests, we want to verify that the correct event handler
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We have to use some DOM traversal to find the desired element, and then use
    `.simulate()` to fire an event. Since no actual event is really fired, we'll have
    to provide the values it would include, which in our case is `.target.value`.
    Then we can finish our test by verifying that the event handler was called once
    with the right value (`"UY"`).
  prefs: []
  type: TYPE_NORMAL
- en: We have written our component tests; let's see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the tests is simple: you just need to use `npm test`, in the same way
    that we did for `Node`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bc5d279-3ef0-42a8-a616-4c933d5cfe2c.png)'
  prefs: []
  type: TYPE_IMG
- en: The Jest output is in the same style as we saw for Node; the Snapshots total
    will be explained later
  prefs: []
  type: TYPE_NORMAL
- en: '`Jest` is set up to automatically watch for changes, so if you modify any file,
    testing will proceed again – the `q` command will stop the watch mode, and you''ll
    have to use `a` to run all tests, or `p` and `t` to filter some tests to run.'
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to test components. However, some extra work is needed,
    because in our examples, we haven't dealt with any `Redux`-related matters, such
    as dispatching actions or thunks; let's move on to other kinds of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing reducers and mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After testing the components, we are now moving on to a simpler set of tests:
    first, reducers; and then mappings such as `mapStateToProps()` and `mapDispatchToProps()`.
    Why are these tests easier to write? Because in all of these cases, we are dealing
    with pure functions, without side effects, that produce their output based only
    on their inputs. We already dealt with these sort of functions earlier in this
    book when we did testing for Node, so now we''ll make do with a short section.
    The only particular care we''ll have is to verify that no function (for example,
    a reducer) attempts to modify the state, but other than that, it''s simple to
    test all the way. In this recipe, let''s look at the different kind of tests we''ll
    need for reducers and mappings.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll have to test the reducers and mappings, so let's start by thinking about
    how you would test a reducer. There are two key things to verify: first, that
    given an input state, it produces a correct output state, and second, that the
    reducer doesn't modify the original state. The first condition is pretty obvious,
    but the second can easily be missed – and a reducer that modifies the current
    state can produce hard-to-find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we could test our countries and regions application''s reducer.
    First, since all tests are analog, we''ll just see a couple of them, for two of
    all the possible actions – but of course, you want to test *all* of the actions,
    right? We''ll also include another test to verify that for unknown actions, the
    reducer just returns the initial state, unchanged in every way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Are you wondering about `Enzyme`, and why we skipped it? We only need it when
    we are rendering components, so for testing reducers or actions (as we'll be doing
    soon), it's not required at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each test for the reducer will be the same, and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an `initialState` and use `JSON.stringify()` to save its original string
    representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the reducer and use `.toEqual()` (a `Jest` method that does deep, recursive,
    equality comparison between objects) to verify that the new state fully matches
    what you expect it to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `initialState` JSON representation still matches the original
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I used dummy values for countries and regions, but if you want to be even more
    careful, you could specify complete, correct values instead of things like `{
    something:2 }` or `"whatever"`; it's up to you.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to take a look at `redux-testkit` at [https://github.com/wix/redux-testkit](https://github.com/wix/redux-testkit);
    this package can help you write reducer tests, automatically checking whether
    the state has been modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'After writing these tests, it should be fairly obvious that writing a test
    for a mapping function is the same thing. For example, when we set up the `<ConnectedRegionsTable>`
    component, we wrote a `getProps()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We would have to export the function (we didn''t at the time, because it wasn''t
    going to be used elsewhere) and then a test could be performed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How does this work? Let's see what happens when we run these tests.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `npm test` will produce a nice *all green* output, meaning that all of
    the tests have passed, as in the previous section; no need to see that again.
    In each individual test, we apply the technique that was described earlier: set
    up state, save a string version of it, apply the reducer or the mapper function,
    check it matches what you wanted it to produce, and check that the original state
    still matches the saved version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that somebody accidentally modified the `getProps()` function that
    we tested so that instead of returning the regions, it returned the countries
    list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ebf4518-d321-4d02-8e10-d6b3d6077def.png)'
  prefs: []
  type: TYPE_IMG
- en: Any unexpected change in a mapping (or reducer) function would be detected by
    our usage of the .toEqual() method,
  prefs: []
  type: TYPE_NORMAL
- en: which does a deep comparison of the produced and expected values
  prefs: []
  type: TYPE_NORMAL
- en: So, these simple tests can help you be safe against accidental changes – including
    the addition, removal, or modification of the expected values. This is a good
    safety net!
  prefs: []
  type: TYPE_NORMAL
- en: Testing actions and thunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish our testing goals, we have to look at how we can test actions and
    thunks. Testing the former is really trivial after everything we've done so far,
    because it's just a matter of calling an action creator and checking the fields
    on the produced action, but testing thunks, which will surely involve an asynchronous
    service call and will surely dispatch several – OK, that's interesting!
  prefs: []
  type: TYPE_NORMAL
- en: We'll skip the simpler action tests (though we'll get to test them, anyway,
    as you'll see) and we'll dive in directly to writing unit tests for our thunks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good tool that we''ll need here is `redux-mock-store`, a small package that
    lets us work with a fake store, aping all its functionality, and providing with
    some calls, such as `.getActions()`, to inspect which actions were dispatched,
    in what order, with which data, and so on. The installation is simple, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering how we'll manage to mock the API service calls. Depending
    on your architecture, if you have thunks directly using things like `axios()`
    or `fetch()` to contact a service, then you will certainly need a corresponding
    mock package. However, since we spirited away those API calls in separate packages,
    we can do very well by mocking the whole call so that no AJAX calls will ever
    be done; we'll get to this soon.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the full documentation for `redux-mock-store` at its GitHub site,
    over at [https://github.com/dmitry-zaets/redux-mock-store](https://github.com/dmitry-zaets/redux-mock-store).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to test actions. Let's take a look at how we can execute those tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''ve been working with our countries-and-regions example a lot, let''s
    finish by testing (at least some of) its actions and thunks: `getCountries()`
    is a good example, and quite similar to `getRegions()`. It will be good to remember
    that particular code here, so let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To begin with, it dispatches an action to mark that a request is being done.
    Then it waits for the result of a web service call; this will require mocking!
    Finally, if the call was successful, an action is dispatched, including the received
    list of countries. On a failed call, a different action is dispatched, but showing
    the failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s consider the following—how can we deal with the API call? The `world.actions.js`
    source code directly imports `getCountriesAPI()` from a module, but `Jest` has
    a feature just for that: we can mock a full module, providing mocks or spies for
    whichever functions we desire, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the `getCountries()` function calls `getCountriesAPI()`, our mocked
    module will be used and a promise (`mockPromise`) will be returned; it's up to
    us to appropriately decide what should that promise be, and we'll make that choice
    depending on whether we want a test to fail or succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to intercept API calls and have them produce any result
    we want, we can move on to writing the actual tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deal with the *happy path* first, in which the API call for countries
    is successful, with no problems. A test can be written in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How is this code structured?
  prefs: []
  type: TYPE_NORMAL
- en: We initially define some data (`fakeCountries`) that will be returned by our
    `mockPromise`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we create a mock store, according to the `redux-mock-store` documentation;
    we are only using the `thunk` middleware in our case, but you may add more. In
    fact, in our original code, we followed `thunk` with `logger`, but that's not
    relevant for our testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we `store.dispatch()` the `getCountries()` thunk and await its results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once everything is done, we use `store.getActions()` to get the list of actions
    that were actually dispatched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We test that our `getCountriesAPI()` function was called; if it hasn't been,
    we'll be in deep trouble!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we test all of the dispatched actions, checking their `type` and other
    attributes. This is, in fact, an indirect test on the action creators themselves!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we''ve looked at a successful case, let''s simulate that the API call
    somehow failed. To simulate this, all we have to do is define a different promise
    for the `getCountriesAPI()` call to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s different in this case? Our `mockPromise` is now set to fail, so the
    tests for the second dispatched actions vary: in this case, instead of success
    and a list of countries, we just get a failure—but the rest of the test is essentially
    the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish with an extra case. When we coded our thunks, we saw that we
    could access the current state by means of a `getState()` function and act differently
    depending on its contents. We could have coded our `getCountries()` function to
    avoid doing an API call if the list of countries had already been obtained, for
    a small optimization; the key part would have been as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'How could we test this case? The difference would be in how we set up the store,
    and what actions actually get dispatched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we set up the store, we can provide it with initial values, as in this
    case, in which we make believe that some countries (fake data!) are already loaded.
    A special requirement: we must use `jest.resetAllMocks()`, because otherwise we
    won''t be able to check that `getCountriesAPI()` wasn''t called – because it *was*
    called, but by the *previous* tests. Then, after dispatching the thunk, we just
    check that the API wasn''t called and that zero actions were dispatched: everything''s
    OK!'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There isn''t much to running these tests, and `npm test` is all we need. We
    can see the results for both our tests (the original and the optimized `getCountries()`
    functions), and the passing result shows that everything is as expected. The output,
    when you run a single test, is more detailed, showing each individual test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a944b54a-a57d-4e97-970b-323c4771c36d.png)'
  prefs: []
  type: TYPE_IMG
- en: The tests for actions and thunks require a bit more setup, but run in the same
    way. We're getting a more detailed output because we're running a single test
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: Testing changes with Snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve been looking at automatic tests for components, events, and
    actions, so let''s end this chapter by considering a testing tool that isn''t
    really a part of TDD, but rather a safeguard against unwanted or unexpected changes
    after the fact: *snapshots*. (In TDD, tests would be written before coding the
    component, but you''ll see that this is impossible here.) Snapshot tests work
    like this: you render a UI component, capture what HTML was produced, and then
    that is compared to a reference capture that was previously stored. If both captures
    do not match, either somebody made an unexpected change or the change was actually
    expected. If this is the case, you''ll have to verify that the new capture is
    correct and then drop the old one.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use snapshot testing for all of our components, but it''s more interesting
    for those whose output varies in terms of their props, so different behaviors
    are to be expected. We will be using a different way of rendering: instead of
    producing HTML elements, we''ll use renderers that produce text output that can
    be stored and compared in a easy way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the simplest cases are for components with a standard, fixed kind of
    output. We have some examples of that: for our `<ClicksDisplay>` component, the
    test would be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, we import the special `TestRenderer` renderer function, use it to
    produce output for our component, and then compare that with the stored snapshot;
    we''ll see how this looks soon. Tests are pretty much always the same: for our
    `<Counter>` component, the test code would be totally analog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The differences are minimal; it's just a matter of providing the correct expected
    props, and nothing more. Let's move on to more interesting cases.
  prefs: []
  type: TYPE_NORMAL
- en: Should you have to render an object with prop values that cannot be predetermined
    (not the most likely case), you'll have to use special *Property Matchers*; you
    can read more about them at [https://jestjs.io/docs/en/snapshot-testing#property-matchers](https://jestjs.io/docs/en/snapshot-testing#property-matchers).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have components whose output varies depending on their props, snapshot
    tests become more interesting because they let you verify that different results
    are produced as expected. With our countries and regions code, we had these kind
    of cases: for example, the `<RegionsTable>` component was expected to display
    a list of regions (if any were provided) or a `"No regions"` text (if none were
    available). We should write these tests, then. Let''s proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two distinct cases, just like we described previously: one snapshot
    will match the *no regions* case, and the other will match what''s expected if
    some regions were given. For the `<CountrySelect>` component, the code would be
    similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, testing components with more than one possible output isn't hard at all,
    and only requires you to write more than one snapshot test; a simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to simplify tests, when you have components that themselves
    have more components, using shallow rendering helps concentrate on the main, high
    level aspects, and leave the details of the inner components'' rendering to other
    tests. We could whip up something like this, with an invented `<CountryAndRegions>`
    component that shows both our countries'' drop-down and regions table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the way to use the `ShallowRenderer` differs from the other renderer:
    you must create a new object, call its `.render()` method, and not use `.toJSON()`
    anymore. We''ll look at how this new test differs from the previous ones soon.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running snapshots is no different from running other tests: you run the `Jest`
    test script, and all the tests run together.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run `npm test`, like we did earlier, you''ll now get an output similar
    to the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The only visible difference is that you get a specific count of snapshots (seven,
    in this case), but there's something more.
  prefs: []
  type: TYPE_NORMAL
- en: The produced snapshot files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you check the source code directories, you''ll find some new `__snapshots__`
    directories, with some `.snap` files in it. For example, in the `/regionsApp`
    directory, you''d find this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For each `.test.js` file that includes snapshots, you''ll find a corresponding
    `.snap` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of those files show the snapshots that were taken at runtime.
    For example, the `countrySelect.test.js.snap` file includes the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the output for both our cases: one with a full list of countries,
    and another for when the countries were being loaded, waiting for the service
    response to arrive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see a shallow test in the `countryAndRegions.test.js.snap` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, note that the `<CountrySelect>` and `<RegionsTable>` components
    weren't expanded; this means that you are testing only the high level snapshot
    here, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Regenerating snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens if a component has changed? Just for the sake of it, I made a
    pretty small change to a component. Upon running the tests, I got a FAIL message,
    with a comparison, that was produced by the usual `diff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'What should you do, then? You should first verify whether the change is correct
    or not, and in the former case, you could either delete the `.snap` file (so that
    it will get regenerated next time) or you can press `u`, as shown in the test
    summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Be careful! If you just regenerate the snapshot without verifying that the output
    is correct, the tests will be worthless; a very bad result!
  prefs: []
  type: TYPE_NORMAL
- en: Measuring test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw how to get coverage for `Jest` tests back in the *Measuring your
    test coverage* section of [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml),
    *Testing and Debugging Your Server*, so in this recipe, we'll just go over some
    small changes that we'll be making to the test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to measure how thorough our testing is, so let''s look at the necessary
    steps. When working with `Node`, we directly invoked the `jest` command. Here,
    however, as the application was built by `create-react-app`, we''ll have to work
    a bit differently. We''ll have to add a new script to `package.json` that will
    invoke our tests with extra parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `--coverage` option will produce a coverage report, and also generate a
    `/coverage` directory, in the same way as with `Node`, and the `--no-cache` option
    will force Jest to regenerate all results instead of depending on previously,
    possibly no longer valid, cached values.
  prefs: []
  type: TYPE_NORMAL
- en: Our `.gitignore` file includes a line reading `/coverage`, so the generated
    files won't be pushed to the Git server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you run `npm run coverage`, you'll get both a text output and a HTML one.
    The former looks like what's shown in the following screenshot; you'll have to
    accept that in reality, lines are colored green, yellow, or red, depending on
    the achieved degree of coverage.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we got quite a lot of red since we only wrote a few tests, instead
    of going for a full test suite; you may work on completing it on your own, as
    an *exercise for the reader*!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0cb50fd-0796-45ee-8c26-ceb6372e87dc.png)'
  prefs: []
  type: TYPE_IMG
- en: The colored ASCII output shows the coverage evaluations for all of our source
    code files; green means good coverage, yellow a medium one,
  prefs: []
  type: TYPE_NORMAL
- en: and red means a poor result. Since we only wrote a few tests, we are getting
    plenty of red!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the `/coverage/lcov-report/index.html` file in a browser, you''ll
    get the same sort of result as in the `Node` chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01440be-90b8-4af6-9e6e-9b274b2b22d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The HTML output lets you browse the directories and files of your project. If
    you click on a specific file, you can even see which lines and functions were
    executed, and which were skipped by your tests.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can even use the `coverageThreshold` configuration object to
    specify coverage levels that must be reached, in order for the tests to be considered
    sufficient; see [https://jestjs.io/docs/en/configuration.html#coveragethreshold-object](https://jestjs.io/docs/en/configuration.html#coveragethreshold-object)
    for more on this.
  prefs: []
  type: TYPE_NORMAL
- en: We have now finished working with `React` and `Redux`, we've looked at how to
    build web applications, and we've used our previously developed `Node` server
    backend. Let's move on to other types of development, starting with mobile applications,
    also with JS!
  prefs: []
  type: TYPE_NORMAL
