- en: Using Python for Enterprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has been around in the world of programming for more than two decades
    now, and over the years, the language has seen a number of refinements, a growing
    community, and a lot of production-ready and well-supported libraries. But is
    Python ready to make a dent in the world of enterprise application development,
    which has been long dominated by the likes of C++, Java, and .NET, the so-called
    **enterprise-grade languages**?
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we will see how Python has evolved over the
    years and how it is ready to become a serious competitor in the world of enterprise
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Recent developments in Python to enable its growth in enterprise application
    development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special use cases where Python shines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between enterprise and general-purpose software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirements for developing an enterprise application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter01` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python.](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The instructions to run the code can be found under the `README` file in the
    individual chapter directories.
  prefs: []
  type: TYPE_NORMAL
- en: The code has been tested to run on a system that is running Fedora 28 and Python
    version 3.6.5, but it should be able to run on any system running Python 3.6.5.
  prefs: []
  type: TYPE_NORMAL
- en: Recent developments in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a dynamically typed, interpreted language that was initially well
    suited for scripting tasks that are boring and repetitive day-to-day tasks. But
    as the years progressed, the language gained a number of new features and the
    huge backing of its community, which propelled its development to make it a language
    that is now well suited to performing tasks that range from very simple applications,
    such as web scraping, to analyzing large amounts of data for training machine
    learning models that themselves are written in Python. Let's take a look at some
    of the major things that have changed over the years and see what the latest release
    of Python, Python 3, brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping backward compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python as a language has evolved a lot over the years, but despite this fact,
    a program written in Python 1.0 will still be able to run in Python 2.7, which
    is a version that was released 19 years after Python 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Though a great benefit for the developers of Python applications, this backward
    compatibility of the language is also a major hurdle in the growth and development
    of major improvements in the language specification, since a great amount of the
    older code base will break if major changes are made to the language specification.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Python 3, this chain of backward compatibility was broken.
    The language in version 3 dropped the support for programs that were written in
    earlier versions ...
  prefs: []
  type: TYPE_NORMAL
- en: It's all Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the days of Python 2, the text data type `str` was used to support ASCII
    data, and for Unicode data, the language provided a `unicode` data type. When
    someone wanted to deal with a particular encoding, they took a string and encoded
    it into the required encoding scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the language inherently supported an implicit conversion of the string
    type to the `unicode` type. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This used to work, because here, Python would implicitly decode the byte string
    `str1` into Unicode using the default encoding and then perform a concatenation.
    One thing to note here is that if this `str1` string contained any non-ASCII characters,
    then this concatenation would have failed in Python, raising a `UnicodeDecodeError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the arrival of Python 3, the data types that dealt with text changed.
    Now, the default data type `str` which was used to store text supports Unicode.
    With this, Python 3 also introduced a binary data type, called `bytes`, which
    can be used to store binary data. These two types, `str` and `bytes`, are incompatible
    and no implicit conversion between them will happen, and any attempt to do so
    will give rise to `TypeError`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, an attempt to concatenate a `unicode` type string with a `byte`
    type string failed with `TypeError`. Although an implicit conversion of a `string`
    to a `byte` or a `byte` to a `string` is not possible, we do have methods that
    allow us to encode a `string` into a `bytes` type and decode a `bytes` type to
    a `string`. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This clear distinction between a string type and binary type with restrictions
    on implicit conversion allows for more robust code and fewer errors. But these
    changes also mean that any code that used to deal with the handling of Unicode
    in Python 2 will need to be rewritten in Python 3 because of the backward incompatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you should focus on the encoding and decoding format used to convert `string`
    to `bytes` and vice versa. Choosing a different formatting for encoding and decoding
    can result in the loss of important information, and can result in corrupt data.
  prefs: []
  type: TYPE_NORMAL
- en: Support for type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language, and hence the type of a variable is
    evaluated at runtime by the interpreter once a value has been assigned to the
    variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Though dynamic interpretation of the type of a variable can be handy while
    writing small programs where the code base can be easily tracked, the feature
    of the language can also become a big problem when working with very large code
    bases, which spawn a lot of modules, and where keeping track of the type of a
    particular variable can become a challenge and silly mistakes related to the use
    of incompatible types can happen easily. Look at the following code: ...'
  prefs: []
  type: TYPE_NORMAL
- en: Where Python shines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every language has been developed to solve a certain type of problem that developers
    face while trying to build software for a specific domain. Python, being a dynamically
    typed, interpreted language, also has a set of use cases where it excels.
  prefs: []
  type: TYPE_NORMAL
- en: These use cases involve the automation of repetitive and boring tasks, quick
    prototyping of applications, and small applications focusing on accomplishing
    a specific goal, such as the installation of software, the setting up of a development
    environment, performing cleanup, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But is that all? Is Python good only for doing small tasks? The answer to this
    is no. Python as a language is much more powerful and can easily accomplish a
    large amount of increasingly complex tasks, such as running a website that scales
    to cope with millions of users using it in a very short span of time, processing
    large sets of incoming files, or training a machine learning model for an image-recognition
    system.
  prefs: []
  type: TYPE_NORMAL
- en: We are talking about achieving increasingly complex tasks using Python, but
    isn't Python slow compared to our traditional compile-time languages, such as
    C++, Java, and .NET? Well, that completely depends upon the context in which a
    person wants to use Python. If your aim is to run a Python program on an embedded
    device with only a limited amount of processing power, then yes, Python might
    be inadequate because of the sheer extra load that its interpreter will have on
    the processing environment. But if you are planning to use Python to run a web
    application on decently configured modern hardware, you might never experience
    any slowdowns while using Python. Rather, you might well feel a bit more productive
    while using it because of the sheer simplicity of its syntax and the ease of performing
    operations without writing hundreds of lines to achieve simple tasks.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's see how Python fares in the enterprise environment.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements of enterprise IT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enterprise IT is complex, and an application that needs to be built for the
    enterprise will differ a lot from one that is built for a regular consumer. There
    are several factors that need to be kept in mind before developing an application
    for enterprise users. Let''s take a look at what makes enterprise IT applications
    different from regular consumer offerings, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business oriented**: Unlike an application that is built to solve the problems
    of individual users, an enterprise application is built to meet the specific needs
    of an organization. This requires the application to conform to the business practices
    of the organization, their rules, and the workflow they use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robustness ...**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python in the enterprise ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has been present in the enterprise ecosystem in quite a few forms; be
    it the automation of boring and repetitive tasks, being used as a glue between
    two layers of a product, or being used for building quick and easy-to-use clients
    for big server backends, the language has seen an increasing amount of adoption
    for various use cases. But what makes Python ready for the development of large
    enterprise applications? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to build quick prototypes**: The syntax of Python is very simple,
    and a lot of things can be achieved with very few lines of code. This allows developers
    to quickly develop and iterate over the prototypes of an application. In addition
    to this, these prototypes do not always need to be thrown away, and if the development
    is properly planned, they can act as a good base to build the final application
    upon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the ability to quickly prototype an application, an enterprise software
    developer can see exactly how the requirements align in the application and how
    the application is performing. With this information, the stakeholders of the
    application can more accurately define the path for the application development,
    thereby avoiding midcycle architectural changes because something didn't work
    out the way it was expected to.
  prefs: []
  type: TYPE_NORMAL
- en: '**A mature ecosystem**: The mature ecosystem is one of the features of Python
    that deserve a lot of attention. The number of external libraries in Python has
    been growing at a rapid pace. For most of the tasks that need to be achieved in
    an application, such as two-factor authentication, testing code, running production
    web servers, integrating with message buses, and so on, you can easily look for
    a library with quite decent support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This proves to be of great help, since it reduces the amount of code duplication
    and increases the reusability of the components. With the help of tools such as `pip`,
    it is very easy to get the required library added to your project, and with the
    support of tools such as `virtualenv`, you can easily segregate a lot of different
    projects on the same system without creating a dependency mess.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if someone wants to build a simple web application, they can probably
    just use Flask, which is a microframework for developing web applications, and
    go ahead with the development of the web application without having to worry about
    the underlying complexities of dealing with the sockets, manipulating data on
    them. All they will require is a few lines of code to get a simple application
    up and running, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, as soon as someone calls the preceding script, they will have a `flask` HTTP
    application up and running. All that remains to be done here is to fire up a browser
    and navigate to `http://localhost:5000`. Then we will see Flask serving a web
    application without any sweat. All of this is made possible in under 10 lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: With a lot of external libraries providing support for a lot of tasks, an enterprise
    developer can easily enable support for new features in the application without
    having to write everything from scratch, thereby reducing the chance of possible
    bugs and non-standardized interfaces creeping into the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Community Support:** The Python language is not owned by any particular corporate
    entity, and is completely supported by a huge community backing that decides the
    future of the standard. This ensures that the language will continue to see support
    for quite a long time, and won''t become obsolete any time soon. This is of great
    importance to organizations, since they want long-term support for the applications
    they run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given all of the preceding benefits of Python, developer productivity will get
    a boost when using the language while also reducing the total cost of ownership
    for the software if decisions are made in a well-planned way. These decisions
    involve how the application architecture will be laid out and which external libraries
    to use or to develop in-house. So yes, Python is indeed now ready to be used in
    the mainstream world of enterprise application development.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing BugZot – a RESTful bug tracker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we progress through the chapters in this book, we will need some way to implement
    what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you work for an organization known as **Omega Corporation**, which
    is a market leader for selling software products to companies and individuals.
    Omega Corporation needs a system through which it can track the bugs in its products.
    After a lot of brainstorming, they initiate a project codenamed BugZot, which
    will be their tool to track the bugs in their products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what Omega Corporation wants to achieve with project
    BugZot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability for users to report bugs in products**: The users, be they internal
    or external, should be able to file bugs against a particular product ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering requirements before development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gathering the software requirements before starting the development of an enterprise
    application can be a tedious task, and a failure to do so adequately can have
    severe consequences, such as increased costs due to delays that are caused by
    identifying requirements later in the development cycle of the application. Applications
    that lack the important features to improve the business process workflow will
    lead users to stop using the application in the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement-gathering process is complex and tedious, and can take months
    to complete in an organization. Covering all the steps involved in the process
    is beyond the scope of this book. This section tries to give a brief description
    about some of the important steps in the process of gathering software requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for the user requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an application inside an organization, there might be various users who
    are stakeholders, and can define the requirements of the application. These users
    can be broadly split into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The workforce**: These are the users who usually use the application to achieve
    a certain set of tasks. They are not concerned with all the features provided
    by the application, but rather what they focus upon is how well the application
    fits into their individual workflows. These users can provide requirements specific
    to what they work on, but may not be able to provide ideas about what they might
    require in the future, or what the other teams may require.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The management**: The management consists of people ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorizing the requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the users have been surveyed for what they would like to have in the application,
    the next step is to categorize these requirements. Broadly, the requirements can
    be categorized into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional requirements**: These are the requirements that define the features
    and functionality of the application. For example, BugZot has the following functional
    requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing functionality for filing bugs by internal and external users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing support for roles and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing functionality for dealing with file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with the email system to send emails when a bug changes its status,
    and much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nonfunctional requirements**: These are those sets of requirements that do
    not affect the functionality of the software, but rather are implicit or explicit
    characteristics based on the functional requirements. For example, in BugZot,
    the following may be defined as some of the nonfunctional requirements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application should provide security against common web attack vectors, such
    as XSS and CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operational costs for the application should not exceed *N*% of the total
    budget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application should be able to generate backups in case a recovery is needed
    after a crash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizing the requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the requirements are identified and categorized into functional and nonfunctional
    requirements, they then need to be prioritized according to their importance in
    the application. If this prioritization is not performed, it will lead to increased
    costs of development, delayed deadlines, and reduced productivity in the organization.
    Broadly, we can classify the requirements under the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Must have**: These are those requirements that are critical to the success
    of the application and that must be present in the application when it ships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Should have**: These are those requirements that will enhance the functionality
    of the application but that need some further discussion about whether they ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the software requirement specification document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the requirements have been identified, grouped, and prioritized, a document
    known as the software requirement specification is generated. This document describes
    the intended purpose, requirements, and nature of the software that needs to be
    developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **software requirement specification** (**SRS**) will describe the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The intended purpose of the applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conventions that are used in the document that are specific to the business
    process of the organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user classes who will be using the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment in which the application will operate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional and nonfunctional requirements of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the SRS has been generated, it is sent for review and further negotiations.
    Once they are successfully completed, the application moves into the design phase,
    where an application mock-up is devised.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly covered the changing programming landscape and explored
    how the Python ecosystem has changed over the years. We looked at how Python,
    given the fact that it allows quick prototyping, and has a vast array of well-supported
    libraries and an open community, is quickly rising to become the main choice for
    the development of large-scale applications in enterprises that require long-term
    support and easy integration with existing systems.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to introduce the demo application, BugZot, that we will be building
    throughout the course of this book, and defined the functionalities that will
    be required from the application.
  prefs: []
  type: TYPE_NORMAL
- en: The last section of the chapter covered the requirement-gathering process for
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it possible to perform operations such as concatenation on a `str` type and
    a `byte` type in Python 3?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the type hinting support introduced in Python 3 enforcing or not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beyond functional and nonfunctional requirements, are there any other kinds
    of requirements that also might need to be documented into the software requirement
    specification?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the major categories in which the prioritization of requirements can
    be done?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the next steps to take once the software requirement specification
    document has been generated?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you would like to go through the basics of Python programming once again
    before diving into the world of enterprise application development, Packt has
    a very good book that you can be refer to. You can get it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/learn-python-programming-second-edition](https://www.packtpub.com/application-development/learn-python-programming-second-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
