- en: Chapter 6. Concurrent Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe lists ordered by priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe lists with delayed elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating concurrent random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data structures** are a basic element in programming. Almost every program
    uses one or more types of data structures to store and manage their data. Java
    API provides the **Java Collections framework** that contains interfaces, classes,
    and algorithms, which implement a lot of different data structures that you can
    use in your programs.'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to work with data collections in a concurrent program, you must
    be very careful with the implementation you choose. Most collection classes are
    not ready to work with concurrent applications because they don't control the
    concurrent access to its data. If some concurrent tasks share a data structure
    that is not ready to work with concurrent tasks, you can have data inconsistency
    errors that will affect the correct operation of the program. One example of this
    kind of data structures is the `ArrayList` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java provides data collections that you can use in your concurrent programs
    without any problems or inconsistency. Basically, Java provides two kinds of collections
    to use in concurrent applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blocking collections**: This kind of collection includes operations to add
    and remove data. If the operation can''t be made immediately, because the collection
    is full or empty, the thread that makes the call will be blocked until the operation
    can be made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-blocking collections**: This kind of collection also includes operations
    to add and remove data. If the operation can''t be made immediately, the operation
    returns a `null` value or throws an exception, but the thread that makes the call
    won''t be blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Through the recipes of this chapter, you will learn how to use some Java collections
    that you can use in your concurrent applications. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking lists, using the `ConcurrentLinkedDeque` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking lists, using the `LinkedBlockingDeque` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking lists to be used with producers and consumers of data, using the `LinkedTransferQueue`
    class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking lists that order their elements by priority, with the `PriorityBlockingQueue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking lists with delayed elements, using the `DelayQueue` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-blocking navigable maps, using the `ConcurrentSkipListMap` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random numbers, using the `ThreadLocalRandom` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic variables, using the `AtomicLong` and `AtomicIntegerArray` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using non-blocking thread-safe lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic collection is the **list**. A list has an undetermined number
    of elements and you can add, read, or remove the element of any position. Concurrent
    lists allow the various threads to add or remove elements in the list at a time
    without producing any data inconsistency.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use non-blocking lists in your concurrent
    programs. Non-blocking lists provide operations that, if the operation can't be
    done immediately (for example, you want to get an element of the list and the
    list is empty), they throw an exception or return a `null` value, depending on
    the operation. Java 7 has introduced the `ConcurrentLinkedDeque` class that implements
    a non-blocking concurrent list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement an example with the following two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that adds data to a list massively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that removes data from the same list massively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `AddTask` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ConcurrentLinkedDeque` attribute parameterized with the `String`
    class named `list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the class. It will store 10,000 strings in the
    list with the name of the thread that is executing the task and a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `PollTask` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ConcurrentLinkedDeque` attribute parameterized with the `String`
    class named `list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the class. It takes out 10,000 elements of the
    list in a loop with 5,000 steps, taking off two elements in each step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ConcurrentLinkedDeque` object parameterized with the `String` class
    named `list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create an array for 100 `Thread` objects named `threads`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Create 100 `AddTask` objects and a thread to run each of them. Store every thread
    in the array created earlier and start the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the completion of the threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the size of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create 100 `PollTask` objectsand a thread to run each of them. Store every thread
    in the array created earlier and start the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the size of the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have used the `ConcurrentLinkedDeque` object parameterized
    with the `String` class to work with a non-blocking concurrent list of data. The
    following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, you have executed 100 `AddTask` tasks to add elements to the list. Each
    one of those tasks inserts 10,000 elements to the list using the `add()` method.
    This method adds the new elements at the end of the list. When all those tasks
    have finished, you have written in the console the number of elements of the list.
    At this moment, the list has 1,000,000 elements.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have executed 100 `PollTask` tasks to remove elements from the list.
    Each one of those tasks removes 10,000 elements of the list using the `pollFirst()`
    and `pollLast()` methods. The `pollFirst()` method returns and removes the first
    element of the list and the `pollLast()` method returns and removes the last element
    of the list. If the list is empty, these methods return a `null` value. When all
    those tasks have finished, you have written in the console the number of elements
    of the list. At this moment, the list has zero elements.
  prefs: []
  type: TYPE_NORMAL
- en: To write the number of elements of the list, you have used the `size()` method.
    You have to take into account that this method can return a value that is not
    real, especially if you use it when there are threads adding or deleting data
    in the list. The method has to traverse the entire list to count the elements
    and the contents of the list can change for this operation. Only if you use them
    when there aren't any threads modifying the list, you will have the guarantee
    that the returned result is correct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ConcurrentLinkedDeque` class provides more methods to get elements form
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the list respectively. They don''t remove the returned element from the list.
    If the list is empty, these methods throw a `NoSuchElementExcpetion` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the list respectively. They don''t remove the returned element
    from the list. If the list is empty, these methods return a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`, `removeFirst()`, `removeLast()`: These methods return the first
    and the last element of the list respectively. They remove the returned element
    from the list. If the list is empty, these methods throw a `NoSuchElementException`
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic collection is the list. A list has an undetermined number of
    elements and you can add, read, or remove the element from any position. A concurrent
    list allows various threads to add or remove elements in the list at a time without
    producing any data inconsistency.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use blocking lists in your concurrent
    programs. The main difference between blocking lists and non-blocking lists is
    that blocking lists has methods to insert and delete elements on it that, if they
    can't do the operation immediately, because the list is full or empty, they block
    the thread that make the call until the operation can be made. Java includes the
    `LinkedBlockingDeque` class that implements a blocking list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to implement an example with the following two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: One that adds data to a list massively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that removes data from the same list massively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps described next to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Client` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `LinkedBlockingDeque` attribute parameterized with the `String`
    class named `requestList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Insert five `String` objects in the list per second
    using the `put()` method of `requestList object`. Repeat that cycle three times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create the main class of the example by creating a class named `Main` and add
    the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Declare and create `LinkedBlockingDeque` parameterized with the `String` class
    named `list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Create and start a `Thread` object to execute a client task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Get three `String` objects of the list every 300 milliseconds using the `take()`
    method of the list object. Repeat that cycle five times. Write the strings in
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to indicate the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have used `LinkedBlockingDeque` parameterized with the `String`
    class to work with a non-blocking concurrent list of data.
  prefs: []
  type: TYPE_NORMAL
- en: The `Client` class uses the `put()` method to insert strings in the list. If
    the list is full (because you have created it with a fixed capacity), the method
    blocks the execution of its thread until there is an empty space in the list.
  prefs: []
  type: TYPE_NORMAL
- en: The `Main` class uses the `take()` method to get strings from the list. If the
    list is empty, the method blocks the execution of its thread until there are elements
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Both the methods of the `LinkedBlockingDeque` class used in this example, can
    throw an `InterruptedException` exception if they are interrupted while they are
    blocked, so you have to include the necessary code to catch that exception.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LinkedBlockingDeque` class also provides the methods to put and get elements
    from the list that, instead of being block, throw an exception or return the `null`
    value. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`takeFirst()` and `takeLast()`: These methods return the first and the last
    element of the list respectively. They remove the returned element from the list.
    If the list is empty, these methods block the thread until there are elements
    in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFirst()` and `getLast()`: These methods return the first and last element
    from the list respectively. They don''t remove the returned element from the list.
    If the list is empty, these methods throw a `NoSuchElementExcpetion` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`, `peekFirst()`, and `peekLast()`: These methods return the first and
    the last element of the list respectively. They don''t remove the returned element
    from the list. If the list is empty, these methods return a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll()`, `pollFirst()`, and `pollLast()`: These methods return the first and
    the last element of the list respectively. They remove the returned element form
    the list. If the list is empty, these methods return a `null` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add()`, `addFirst()`, `addLast()`: These methods add an element in the first
    and the last position respectively. If the list is full (you have created it with
    a fixed capacity), these methods throw an `IllegalStateException` exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blocking thread-safe lists ordered by priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical need when you work with data structures is to have an ordered list.
    Java provides `PriorityBlockingQueue` that has this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the elements you want to add to `PriorityBlockingQueue` have to implement
    the `Comparable` interface. This interface has a method, `compareTo()` that receives
    an object of the same type, so you have two objects to compare: the one that is
    executing the method and the one that is received as a parameter. The method must
    return a number less than zero if the local object is less than the parameter,
    a number bigger that zero if the local object is greater than the parameter, and
    the number zero if both objects are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PriorityBlockingQueue` uses the `compareTo()` method when you insert an element
    in it to determine the position of the element inserted. The greater elements
    will be the tail of the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important characteristic of `PriorityBlockingQueue` is that it's a **blocking
    data structure** . It has methods that, if they can't do their operation immediately,
    block the thread until they can do it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `PriorityBlockingQueue` class
    implementing an example, where you are going to store a lot of events with different
    priorities in the same list, to check that the queue will be ordered as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Event` and specify that it implements the `Comparable`
    interface parameterized with the `Event` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `thread` to store the number of the
    thread that has created the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `priority` to store the priority of
    the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getThread()` method to return the value of the thread attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getPriority()` method to return the value of the priority attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compareTo()` method. It receives `Event` as a parameter and compares
    the priority of the current event and the one received as parameter. It returns
    `-1` if the priority of the current event is bigger, `0` if both priorities are
    equal, and `1` if the priority of the current event is smaller. Note that this
    is opposite of most `Comparator.compareTo()` implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `id` to store the number that identifies
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `PriorityBlockingQueue` attribute parameterized with the `Event`
    class named `queue` to store the events generated by the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It stores 1000 events in the queue, using its
    ID to identify the task that creates the event and giving to them as priority
    an increasing number. Use the `add()` method to store the events in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create a `PriorityBlockingQueue` object parameterized with the `Event` class
    named `queue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create an array of five `Thread` objects to store the threads that is going
    to execute five tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Task` objects. Store the threads in the array created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Start the five threads created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the five threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the actual size of the queue and the events stored in it.
    Use the `poll()` method to take off the events from the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console with the final size of the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, you have implemented a priority queue of `Event` objects using
    `PriorityBlockingQueue`. As we mentioned in the introduction, all the elements
    stored in `PriorityBlockingQueue` have to implement the `Comparable` interface,
    so you have implemented the `compareTo()` method in the Event class.
  prefs: []
  type: TYPE_NORMAL
- en: All the events have a priority attribute. The elements that have a higher value
    of priority will be the first elements in the queue. When you have implemented
    the `compareTo()` method, if the event executing the method has a priority higher
    than the priority of the event passed as parameter, it returns `-1` as the result.
    In the other case, if the event executing the method has a priority lower than
    the priority of the event passed as parameter, it returns `1` as the result. If
    both objects have the same priority, the `compareTo()` method returns the `0`
    value. In that case, the `PriorityBlockingQueue` class doesn't guarantee the order
    of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented the `Task` class to add the `Event` objects to the priority
    queue. Each task object adds to the queue 1,000 events, with priorities between
    0 and 999, using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method of the `Main` class creates five `Task` objects and executes
    them in the corresponding threads. When all the threads have finished their execution,
    you have written all the elements to the console. To get the elements from the
    queue, we have used the `poll()` method. That method returns and removes the first
    element from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the queue has a size of 5,000 elements and how the first elements
    have the biggest priority values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PriorityBlockingQueue` class has other interesting methods. Following
    is the description of some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method returns and removes the first element of the queue. If
    the queue is empty, the method blocks its thread until the queue has elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put(E``e)`: `E` is the class used to parameterize the `PriorityBlockingQueue`
    class. This method inserts the element passed as a parameter into the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`:This method returns the first element of the queue, but doesn''t remove
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe lists with delayed elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting data structure provided by the Java API, and that you can use
    in concurrent applications, is implemented in the `DelayedQueue` class. In this
    class, you can store elements with an activation date. The methods that return
    or extract elements of the queue will ignore those elements whose data is in the
    future. They are invisible to those methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain this behavior, the elements you want to store in the `DelayedQueue`
    class have to implement the `Delayed` interface. This interface allows you to
    work with delayed objects, so you will implement the activation date of the objects
    stored in the `DelayedQueue` class as the time remaining until the activation
    date. This interface forces to implement the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compareTo(Delayed``o)`: The `Delayed` interface extends the `Comparable` interface.
    This method will return a value less than zero if the object that is executing
    the method has a delay smaller than the object passed as a parameter, a value
    greater than zero if the object that is executing the method has a delay bigger
    than the object passed as a parameter, and the zero value if both objects have
    the same delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDelay(TimeUnit``unit)`: This method has to return the time remaining until
    the activation date in the units is specified by the unit parameter. The `TimeUnit`
    class is an enumeration with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`,
    `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, you will learn how to use the `DelayedQueue` class storing
    in it some events with different activation dates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Event` and specify that it implements the `Delayed` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Date` attribute named `startDate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `compareTo()` method. It receives a `Delayed` object as its parameter.
    Return the difference between the delay of the current object and the one passed
    as parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getDelay()` method. Return the difference between `startDate`
    of the object and the actual `Date` in `TimeUnit` received as parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `int` attribute named `id` to store a number that identifies
    this task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `DelayQueue` attribute parameterized with the `Event` class
    named `queue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. First, calculate the activation date of the events
    that this task is going to create. Add to the actual date a number of seconds
    equal to the ID of the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Store 100 events in the queue using the `add()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Create a `DelayedQueue` object parameterized with the `Event` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Create an array of five `Thread` objects to store the tasks you're going to
    execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Create five `Task` objects, with different IDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Launch all the five tasks created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the events stored in the queue. While the size of the queue
    is bigger than zero, use the `poll()` method to obtain an `Event` class. If it
    returns `null`, put the main thread for 500 milliseconds to wait for the activation
    of more events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have implemented the `Event` class. That class has a unique
    attribute, the activation date of the events, and implements the `Delayed` interface,
    so you can store `Event` objects in the `DelayedQueue` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `getDelay()` method returns the number of nanoseconds between the activation
    date and the actual date. Both dates are objects of the `Date` class. You have
    used the `getTime()` method that returns a date converted to milliseconds and
    then, you have converted that value to `TimeUnit` received as a parameter. The
    `DelayedQueue` class works in nanoseconds, but at this point, it's transparent
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: The `compareTo()` method returns a value less than zero if the delay of the
    object executing the method is smaller than the delay of the object passed as
    a parameter, a value greater than zero if the delay of the object executing the
    method is bigger than the delay of the object passes as a parameter, and the value
    `0` if both delays are equal.
  prefs: []
  type: TYPE_NORMAL
- en: You also have implemented the `Task` class. This class has an `integer` attribute
    named `id`. When a `Task` object is executed, it adds a number of seconds equal
    to the ID of the task to the actual date and that is the activation date of the
    events stored by this task in the `DelayedQueue` class. Each `Task` object stores
    100 events in the queue using the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `main()` method of the `Main` class, you have created five `Task`
    objects and executed them in the corresponding threads. When those threads finish
    their execution, you have written to the console all the events using the `poll()`
    method. That method retrieves and removes the first element of the queue. If the
    queue does not have any active element, the method returns the `null` value. You
    called the `poll()` method and if it returns an `Event` class, you increment a
    counter. When the `poll()` method returns the `null` value, you write the value
    of the counter in the console and put the thread to sleep during half a second
    to wait for more active events. When you have obtained the 500 events stored in
    the queue, the execution of the program finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the program only gets 100 events when it is activated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must be very careful with the `size()` method. It returns the total number
    of elements in the list that includes the active and non-active elements.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `DelayQueue` class has other interesting methods, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()`: This method removes all the elements of the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`offer(E``e)`: `E` represents the class used to parameterize the `DelayQueue`
    class. This method inserts the element passed as a parameter in the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method retrieves, but doesn''t remove the first element of the
    queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method retrieves and removes the first element of the queue.
    If there aren''t any active elements in the queue, the thread that is executing
    the method will be blocked until the thread has some active elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using thread-safe navigable maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting data structure provided by the Java API that you can use in
    your concurrent programs is defined by the `ConcurrentNavigableMap` interface.
    The classes that implement the `ConcurrentNavigableMap` interface stores elements
    within two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A **key** that uniquely identifies an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the data that defines the element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each part has to be implemented in different classes.
  prefs: []
  type: TYPE_NORMAL
- en: Java API also provides a class that implements that interface, which is the
    `ConcurrentSkipListMap` interface that implements a non-blocking list with the
    behavior of the `ConcurrentNavigableMap` interface. Internally, it uses a **Skip
    List** to store the data. A Skip List is a data structure based on parallel lists
    that allows us to get efficiency similar to a binary tree. With it, you can get
    a sorted data structure with a better access time to insert, search, or delete
    elements than a sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Skip List was introduced by William Pugh in 1990.
  prefs: []
  type: TYPE_NORMAL
- en: When you insert an element in the map, it uses the key to order them, so all
    the elements will be ordered. The class also provides methods to obtain a submap
    of the map, in addition to the ones that return a concrete element.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ConcurrentSkipListMap` class
    to implement a map of contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Contact`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `String` attributes named `name` and `phone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Implement the methods to return the values of the `name` and `phone` attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `ConcurrentSkipListMap` attribute parameterized with the `String`
    and `Contact` classes named `map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `id` to store the ID of the current
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to store its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. It stores in the map 1,000 different contacts
    using the ID of the task and an incremental number to create the `Contact` objects.
    Use the `put()` method to store the contacts in the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ConcurrentSkipListMap` object parameterized with the `String` and
    `Conctact` classes named `map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Create an array for 25 `Thread` objects to store all the `Task` objects that
    you're going to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch 25 task objects assigning a capital letter as the ID of each
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Get the first entry of the map using the `firstEntry()` method. Write its data
    to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Get the last entry of the map using the `lastEntry()` method. Write its data
    to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Obtain a submap of the map using the `subMap()` method. Write their data to
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have implemented a `Task` class to store `Contact` objects
    in the navigable map. Each contact has a name that is the ID of the task that
    creates it, and a phone number, that is a number between 1,000 and 2,000\. We
    have used a concatenation of those values as the key for the contacts. Each `Task`
    object creates 1,000 contacts that are stored in the navigable map using the `put()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you insert an element with a key that exists in the map, the element associated
    with that key will be replaced by the new element.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` method of the `Main` class creates 25 `Task` objects, using IDs
    as the letters between A and Z. Then, you have used some methods to obtain data
    from the map. The `firstEntry()` method returns a `Map.Entry` object with the
    first element of the map. This method doesn't remove the element from the map.
    That object contains the key and the element. To obtain the element, you have
    called the `getValue()` method. You can use the `getKey()` method to obtain the
    key of that element.
  prefs: []
  type: TYPE_NORMAL
- en: The `lastEntry()` method returns a `Map.Entry` object with the last element
    of the map and the `subMap()` method returns the `ConcurrentNavigableMap` object
    with part of the elements of the map, in this case, the elements which have the
    keys between `A1996` and `B1002`. In this case, you have used the `pollFirst()`
    method to process the elements of the `subMap()` method. That method returns and
    removes the first `Map.Entry` object of the submap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ConcurrentSkipListMap` class has other interesting methods. Following
    are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`headMap(K``toKey)`: `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the first
    elements of the map with the elements that have a key smaller than the one passed
    as parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tailMap(K``fromKey)`: `K` is the class of the key values used in the parameterization
    of the `ConcurrentSkipListMap` object. This method returns a submap of the last
    elements of the map with the elements that have a key greater than the one passed
    as parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putIfAbsent(K``key,``V``Value)`: This method inserts the value specified as
    a parameter with the key specified as parameter if the key doesn''t exist in the
    map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pollLastEntry()`: This method returns and removes a `Map.Entry` object with
    the last element of the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace(K``key,``V``Value)`: This method replaces the value associated with
    the key specified as parameter if this key exists in the map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using non-blocking thread-safe lists* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating concurrent random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a specific class to generate pseudo-random
    numbers in concurrent applications. It's the `ThreadLocalRandom` class and it's
    new in the Java 7 Version. It works as the thread local variables. Every thread
    that wants to generate random numbers has a different generator, but all of them
    are managed from the same class, in a transparent way to the programmer. With
    this mechanism, you will get a better performance than using a shared `Random`
    object to generate the random numbers of all the threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `ThreadLocalRandom` class to generate
    random numbers in a concurrent application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `TaskLocalRandom` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. Use it to initialize the random-number
    generator to the actual thread using the `current()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Get the name of the thread that is executing this
    task and write 10 random integer numbers to the console using the `nextInt()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Create an array for three `Thread` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch three `TaskLocalRandom` tasks. Store the threads in the array
    created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key of this example is in the `TaskLocalRandom` class. In the constructor
    of the class, we make a call to the `current()` method of the `ThreadLocalRandom`
    class. This is a static method that returns the `ThreadLocalRandom` object associated
    with the current thread, so you can generate random numbers using that object.
    If the thread that makes the call does not have any object associated yet, the
    class creates a new one. In this case, you use this method to initialize the random
    generator associated with this task, so it will be created in the next call to
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `run()` method of the `TaskLocalRandom` class, make a call to the `current()`
    method to get the random generator associated with this thread, also you make
    a call to the `nextInt()` method passing number 10 as parameter. This method will
    return a pseudo random number between zero and 10\. Each task generates 10 random
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ThreadLocalRandom` class also provides methods to generate `long`, `float`,
    and `double` numbers, and `Boolean` values. There are methods that allow you to
    provide a number as a parameter to generate random numbers between zero and that
    number. Other methods allow you to provide two parameters to generate random numbers
    between those numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using local thread variables* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread management*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Atomic variables** were introduced in Java Version 5 to provide atomic operations
    on single variables. When you work with a normal variable, each operation that
    you implement in Java is transformed in several instructions that is understandable
    by the machine when you compile the program. For example, when you assign a value
    to a variable, you only use one instruction in Java, but when you compile this
    program, this instruction is transformed in various instructions in the JVM language.
    This fact can provide data inconsistency errors when you work with multiple threads
    that share a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these problems, Java introduced the atomic variables. When a thread
    is doing an operation with an atomic variable, if other threads want to do an
    operation with the same variable, the implementation of the class includes a mechanism
    to check that the operation is done in one step. Basically, the operation gets
    the value of the variable, changes the value in a local variable, and then tries
    to change the old value for the new one. If the old value is still the same, it
    does the change. If not, the method begins the operation again. This operation
    is called **Compare and Set** .
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables don't use locks or other synchronization mechanisms to protect
    the access to their values. All their operations are based on the Compare and
    Set operation. It's guaranteed that several threads can work with an atomic variable
    at a time without generating data inconsistency errors and its performance is
    better than using a normal variable protected by a synchronization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use atomic variables implementing a bank
    account and two different tasks, one that adds money to the account and one that
    subtracts money from it. You will use the `AtomicLong` class in the implementation
    of the example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    are using Eclipse or other IDE such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Account` to simulate a bank account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AtomicLong` attribute named `balance` to store the balance
    of the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method named `getBalance()` to return the value of the balance attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method named `setBalance(``)` to establish the value of the balance
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method named `addAmount()` to increment the value of the `balance`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Implement a method named `substractAmount()` to decrement the value of the `balance`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Company` and specify that it implements the `Runnable`
    interface. This class will simulate the payments made by a company.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Account` attribute named `account`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the task. Use the `addAmount()` method of the
    account to make 10 increments of 1,000 in its balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Bank` and specify that it implements the `Runnable` interface.
    This class will simulate the withdrawal of money from the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `Account` attribute named `account`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method of the task. Use the `subtractAmount()` method
    of the account to make 10 decrements of 1,000 in its balance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Create an `Account` object and set its balance to `1000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Company` task and a thread to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the initial balance of the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Start the threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the threads using the `join()` method and write
    in the console the final balance of the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key of this example is in the `Account` class. In that class, we declared
    an `AtomicLong` variable named `balance` to store the balance of the account and
    then we implemented the methods to work with that balance using the methods provided
    by the `AtomicLong` class. To implement the `getBalance()` method that returns
    the value of the `balance` attribute, you have used the `get()` method of the
    `AtomicLong` class. To implement the `setBalance()` method that establish the
    value of the balance attribute, you have used the `set()` method of the `AtomicLong`
    class. To implement the `addAmount()` method that adds an import to the balance
    of the account, you have used the `getAndAdd()` method of the `AtomicLong` class
    that returns the value and increments it by the value specified as a parameter.
    Finally, to implement the `subtractAmount()` method that decrements the value
    of the `balance` attribute, you have also used the `getAndAdd()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you have implemented two different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Company` class simulates a company that increments the balance of the account.
    Each task of this class makes 10 increments of 1,000\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bank` class simulates a bank where the proprietary of the bank account
    takes out its money. Each task of this class makes 10 decrements of 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you have created an `Account` object with a balance of
    1,000\. Then, you have executed a bank task and a company task, so the final balance
    of the account must be the same as the initial one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the program, you will see how the final balance is the same
    as the initial one. The following screenshot shows the output of an execution
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in the introduction, there are other atomic classes in Java.
    `AtomicBoolean`, `AtomicInteger`, and `AtomicReference` are other examples of
    atomic classes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Synchronizing a method* recipe in [Chapter 2](ch02.html "Chapter 2. Basic
    Thread Synchronization"), *Basic thread synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using atomic arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you implement a concurrent application that has one or more objects shared
    by several threads, you have to protect the access to their attributes using a
    synchronization mechanism as locks or the `synchronized` keyword to avoid data
    inconsistency errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'These mechanisms have the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deadlock: This situation occurs when a thread is blocked waiting for a lock
    that is locked by other threads and will never free it. This situation blocks
    the program, so it will never finish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If only one thread is accessing the shared object, it has to execute the code
    necessary to get and release the lock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To provide a better performance to this situation, the **compare-and-swap operation**
    was developed. This operation implements the modification of the value of a variable
    in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You get the value of the variable, which is the old value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You change the value of the variable in a temporal variable, which is the new
    value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You substitute the old value with the new value, if the old value is equal to
    the actual value of the variable. The old value may be different from the actual
    value if another thread has changed the value of the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this mechanism, you don't need to use any synchronization mechanism, so
    you avoid deadlocks and you obtain a better performance.
  prefs: []
  type: TYPE_NORMAL
- en: Java implements this mechanism in the **atomic variables**. These variables
    provide the `compareAndSet()` method that is an implementation of the compare-and-swap
    operation and other methods based on it.
  prefs: []
  type: TYPE_NORMAL
- en: Java also introduced **atomic arrays** that provide atomic operations for arrays
    of `integer` or `long` numbers. In this recipe, you will learn how to use the
    `AtomicIntegerArray` class to work with atomic arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Incrementer` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Increment all the elements of the array using
    the `getAndIncrement()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Decrementer` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `AtomicIntegerArray` attribute named `vector` to store an
    array of `integer` numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Decrement all the elements of the array using
    the `getAndDecrement()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Declare a constant named `THREADS` and assign to it the value `100`. Create
    an `AtomicIntegerArray` object with 1,000 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Create an `Incrementer` task to work with the atomic array created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Decrementer` task to work with the atomic array created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Create two arrays to store 100 Thread objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Create and launch 100 threads to execute the `Incrementer` task and another
    100 threads to execute the `Decrementer` task. Store the threads in the arrays
    created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the threads using the `join()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Write in the console the elements of the atomic array distinct from zero. Use
    the `get()` method to obtain the elements of the atomic array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Write a message in the console to indicate the finalization of the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, you have implemented two different tasks to work with an `AtomicIntegerArray`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Incrementer` task: This class increments all the elements of the array using
    the `getAndIncrement()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decrementer` task: This class decrements all the elements of the array using
    the `getAndDecrement()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Main` class, you have created `AtomicIntegerArray` with 1,000 elements
    and then, you have executed 100 Incrementer and 100 decrementer tasks. At the
    end of those tasks, if there were no inconsistency errors, all the elements of
    the array must have the value `0`. If you execute the program, you will see how
    the program only writes to the console the final message because all the elements
    are zero.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, Java only provides another atomic array class. It's the `AtomicLongArray`
    class that provides the same methods as the `IntegerAtomicArray` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting methods provided by these classes are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(int``i)`: Returns the value of the array position specified by the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int``I,``int``newValue)`: Establishes the value of the array position
    specified by the parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using atomic variables* recipe in [Chapter 6](ch06.html "Chapter 6. Concurrent
    Collections"), *Concurrent Collections*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
