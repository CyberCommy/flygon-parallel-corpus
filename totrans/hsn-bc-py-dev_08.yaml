- en: Building a Practical Decentralized Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to write a popular application on the blockchain,
    which will be a secure voting application powered by the blockchain. You have
    all the tools to develop this application, namely, populus and `web3.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing a simple voting application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about an event in a smart contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a commercial voting application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a token-based voting application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing another type of voting application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a simple voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we are going to build the simplest voting application, simpler than
    the voting application example that comes with the Vyper software source code.
    Let''s set up our Populus project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add Vyper support to `project.json` by changing the value of the key
    compilation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The latest version of Vyper is 0.1.0b6 which, breaks Populus. The developer
    needs some time to fix this problem. If the bug has still not been fixed by the
    time you are reading this book, you can patch Populus yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check whether the bug has been fixed by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case here, the bug has not been fixed. So, let''s patch Populus to fix
    the bug. Make sure you are still in the same directory (`voting-venv/src/populus`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a simple voting smart contract inside the `contracts` directory.
    Name it `SimpleVoting.vy`*. *Refer to the following GitLab link for the full code
    – [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/SimpleVoting.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss this simple voting smart contract. It is inspired by the voting
    example in the Vyper source code, but this example is simplified even further.
    The original example has a delegation feature that would make things hard to understand.
    We start with the struct data type variable declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The data structure is a variable that has a composite data type that holds the
    name of the proposal and the amount that the proposal has. The `vote_count` in
    the `Proposal` struct has a data type of `int128`, while `name` in the `Proposal`
    struct has a data type of `bytes32`. You could also use `uint256` instead of the `int128`
    data type for `vote_count` in the `Proposal` struct. It would not make any difference,
    though. However, `bytes32` is a new data type. As you may recall from [Chapter
    3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)*, Implementing Smart Contracts
    With Vyper*, if you want to use the string (or array of bytes) data type in Vyper,
    you use `bytes[20]` if the length of that string is less than 20.
  prefs: []
  type: TYPE_NORMAL
- en: 'bytes32 is another string data type similar to `bytes[32]`, but with one peculiarity;
    if you set the `b''messi''` string to a variable with the `bytes[32]` type and retrieve
    it with `web3`, you would get `b''messi''`. However, if you set the `b''messi''`
    string to a variable with the `bytes32`type and retrieve it with `web3`, you would
    get `b''messi\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00''`.
    This string would be padded until we reach 32 bytes. By default, you should use
    `bytes[20]` or `bytes[256]` as the string data type, as opposed to using `bytes32`.
    Then why am I using `bytes32` in this smart contract? I have a good reason for
    doing so, but we need to move on to the constructor function first to understand
    the reason why I use `bytes32`  to keep the name of proposals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first time we are using an event in a smart contract. `event` is
    a keyword in Vyper that is designed to create an event. An event is something
    that happens inside smart contract that our client (the `web3` program) wants
    to subscribe to. In this statement, `Voting` is the name of the event and it has
    two parameters. The first parameter is `_from`, which has the type of `address`.
    `indexed` is used to make filtering events possible using `_from` as a filter.
    The second parameter is `_proposal`, which is of the type `int128`. Remember,
    `int128` is a 128-bit integer. This event will become clearer when we subscribe
    to it in our client program. For now, let''s move on to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable is a mapping data type variable that maps an `int128` data type
    variable to a `Proposal` struct variable. Basically, it''s a list of proposals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a helper variable to count how many proposals are in this smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to check whether an account has already voted or not. We don''t
    want an account to vote for the same proposal more than once. Remember, this is
    a mapping data type. By default, a non-existent value points to a null value.
    Null in the context of `int128` is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This constructor got an argument, which is an array of `bytes32`. Inside the
    constructor, it will iterate twice (we hardcoded the number of proposals into
    two). Each iteration will set a new member into the `proposals` mapping variable.
    `name` is set from the argument, and `vote_count` is initialized as 0\. Then,
    the `proposals_count` is increased by one for each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s why I use `bytes32` as a data type for a proposal name: If I used `bytes[128]` as
    a data type for a proposal name, I could not send it as an argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method in a smart contract in the Vyper programming language cannot accept
    nested arrays such as `bytes[128][2]` as an argument (at least at the moment in
    the latest version of Vyper):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the function to vote. It accepts an argument named `proposal`. Here,
    the user votes for a proposal with an integer. So, if the user calls the `vote`
    method with an argument of `0`, such as `vote(0)`, it means the user votes for
    the first proposal. Of course, you could use the string to vote, as in `vote(b'proposal1')`
    when you design your own voting smart contract. Here, I use an integer to make
    things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, we assert that the voter has not yet voted with this statement:
    `assert self.voters_voted[msg.sender] == 0`. After voting, we set the value of
    `voters_voted` with the voter''s address as the key to `1`: `self.voters_voted[msg.sender]
    = 1`. We also verify that the voting is valid by checking that the value of the
    voting is less than the number of proposals, which is `2`. The nitty-gritty of
    this function is the following statement: `self.proposals[proposal].vote_count
    += 1`. At the end of this function, our `Voting` event is used in this statement:
    `log.Voting(msg.sender, proposal)`. This is similar to broadcasting that something
    important has happened—Hey, world! There is a `Voting` event that has two parameters,
    `msg.sender` as the `address` parameter, and `proposal` as the `int128` parameter.
    Then, anyone who subscribes to this event will be notified. The subscription of
    the event happens on the client side, using the `web3` library, as demonstrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This private function is designed to check which proposal has the most votes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `public` function is designed to get the name of the proposal that has
    the most votes. This function uses the private function described previously.
  prefs: []
  type: TYPE_NORMAL
- en: This smart contract is simple but not perfect, as there is a bug present. For
    example, in the `vote` function, we did not handle the negative value of voting.
    On top of that, the number of proposals is hardcoded into 2\. However, it will
    get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can compile the smart contract''s code in the usual manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As a good citizen, let''s write a test for this smart contract. Create a file
    named `test_simple_voting_app.py` in the `tests` directory. Refer to the following
    GitLab link for the full code of the following code block: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_simple_voting_app.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss this test one function at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because our simple voting smart contract''s constructor requires an argument,
    we need to use a fixture in the test, as discussed in [Chapter 5](b87b0052-d66e-43ff-afc4-cf26bac23728.xhtml)
    *, Populus Development Framework*. Then, our fixture can be used as an argument
    in the test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to check the state of the smart contract after it is deployed. One
    thing is very unique here; the length of the name''s variable in the struct data
    inside the proposals variable is `32`, even if we set it with the value `b''messi''`,
    such is the peculiarity of the `bytes32` data type. This is why we slice the variable
    to get what we want. Then, for the next test method, we use the `chain` parameter
    in addition to the `voting` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to test the `vote` function. We test whether the `vote` function
    indeed changes the `vote_count` property of the `proposals` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that we cannot vote more than once using the same account. As
    we learned in `Chapter 5`, *Populus Development Framework*, you wrap the fail
    case with the `pytest.raises with` statement. The last test case is to check the
    winning proposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this test, you use three accounts with the `t.get_accounts` helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a smart contract that has arguments in its constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's deploy this smart contract to the Ethereum blockchain. However, we must
    first be aware that there are some things that complicate the situation. First,
    the `event` does not work in Ganache, so we have to deploy it to the Rinkeby network
    or the private Ethereum blockchain. Second, our smart contract has an argument
    in the constructor. To deploy a smart contract with arguments, we need to use
    a different method; we cannot use the normal method as demonstrated in `Chapter
    5`*, Populus Development Framework*. In [Chapter 5](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/_wp_link_placeholder)*,
    Populus Development Framework*, we deployed a smart contract using Populus this
    way[: ](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)[`populus
    deploy --chain localblock Donation`.](https://cdp.packtpub.com/hands_on_blockchain_for_python_developers/wp-admin/post.php?post=29&action=edit#post_28)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Populus method can only deploy a smart contract with a constructor without
    arguments. Let''s overcome these obstacles one by one. The first thing we need
    to do is deploy it to the private Ethereum blockchain, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `voting_project` directory, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize the private chain using the `init_chain.sh` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit `chains/localblock/run_chain.sh`and change the value of the `--ipcpath`
    flag to `/tmp/geth.ipc`. Then, run the blockchain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `project.json` file. The `chains` key has one object that has
    4 keys: `tester`, `temp`, `ropsten`, and `mainnet`. Add one key named `localblock`
    with its value to this object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a blockchain requires a dedicated terminal. So open a new terminal,
    execute a virtual environment script, and then go inside the `voting_project`
    directory. Create this file and name it `deploy_SmartVoting.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s discuss what this program does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We import tools from the `populus` library, and `Project` represents the `project.json`
    configuration file. `wait_for_transaction_receipt` is a function that waits until
    our transaction has been confirmed in the Ethereum blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `main` function, we initialize a `Project` instance and then we
    get the `localblock` chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `chain` object is now representing this `json` object in the `project.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the `SimpleVoting` smart contract factory from `build/contracts.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we deploy our smart contract to the private Ethereum blockchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It receives two keyword arguments, `transaction` and `args`. The transaction
    argument is a dictionary of transactions. Here, we set the `from` parameter. `chain.web3.eth.coinbase`
    is our default account, which is common in a `testing/development` scenario. Here,
    we use the default account without the private key. In this transaction object,
    we can also set `gas`, gasPrice, and other transaction parameters. The `args`
    keyword argument allows us to send an argument to the constructor of a smart contract.
    It is a nested array, `[[b'Messi', b'Ronaldo']]`, because the inner array is the
    `_proposalNames` argument in the constructor of the smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer array is designed to encapsulate other parameters in the constructor,
    but we only have one argument in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We wait for the transaction to be confirmed. Then, we get the address of the
    smart contract from the deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `receipt` object is an object from the blockchain that describes the confirmation
    of the transaction. What we are concerned with in this context is the address,
    that is, the `contractAddress` key in the receipt object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is designed to execute the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Ganache, where you are given 10 accounts (each equipped with 100 ethers),
    in this private Ethereum blockchain with default settings from Populus, you only have one
    account equipped with 1 trillion ethers! The following script allows you to find
    out how many ethers the default account has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this smart contract, we want to play with our smart contract with more than
    1 account. So let''s create 10 accounts in this Ethereum private blockchain. Creating
    a new account is possibly not the appropriate term here because all accounts are
    already created in the Ethereum blockchain, so perhaps **finding new accounts**
    is more appropriate. Create a new file inside the `voting_project` directory and
    name it `create_10_accounts_on_private_chain.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We will write our new accounts' addresses in the file so we can reuse them later.
    The function that you need to notice is `w3.personal.newAccount('password123')`.
    This will give you the public address. The private key will be encrypted with
    `password123`. This will be saved in the `chains/localblock/chain_data/keystore`
    directory. The name of the encrypted file is something like this—`UTC—2018-10-26T13-13-25.731124692Z—36461a003a03f857d60f5bd0b8e8a64aab4e4535`.
    The end part of the name of the file is the `public` address. In that filename
    example, the `public` address is `36461a003a03f857d60f5bd0b8e8a64aab4e4535`. Execute
    this script. The `public` address of the 10 accounts will be written in the `10_accounts.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the `chains/localblock/chain_data/keystore` directory,
    you will see at least 11 files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these new 10 accounts are equipped with 0 ethers. To vote in our smart
    contract, you should not have an empty balance. So, why don''t we distribute our
    money from the default account to these 10 accounts? Create a file inside `voting_project`,
    and name it `distribute_money.py`*.* Refer to the code file in the following GitLab
    link for the full code – [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/distribute_money.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s discuss this script line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You already know about `Web3`, `IPCProvider`*, *and `wait``_for_transaction_receipt`.
    `glob` is from the Python standard library. Its purpose is to filter files from
    the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We connect to the Ethereum node using a socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our default account''s address. How do you know? You can find it with
    `w3.eth.coinbase` in a script connecting to this private Ethereum blockchain,
    or you can take a look at the filename inside the `chains/localblock/chain_data/keystore`
    directory. There is only one filename after you initialize and run the private
    Ethereum blockchain. Now, after you initialize another 10 accounts, naturally,
    the number of files will be 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The password to unlock the default account is stored in a plain text file in
    `chains/localblock/password`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After finding this, we decrypt the encrypted file using the `w3.eth.account.decrypt`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to avoid the obligation of providing the `from` parameter to a method
    when creating a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We opened `10_accounts.txt`, containing all the new accounts that we have,
    and then we iterated these one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We check the latest nonce value with `w3.eth.getTransactionCount` before feeding
    it to transaction object. The transaction object has `to`, `value`, `gas`, and `gasPrice`,
    as well as the `nonce` key. Here, we want to send 10 ethers to each account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We sign the transaction with our private key, and then we broadcast the transaction
    to the miners using the `w3.eth.sendRawTransaction` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is very important. If you only send money to one account, you could skip
    it. However, since we broadcast 10 transactions in a sequential manner, you must
    wait for each transaction to be confirmed first before broadcasting the next transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it this way: you broadcast a transaction of sending 10 ethers with
    nonce 3, and then miners will need time to confirm this transaction. But, in a
    short space of time, you broadcast a new transaction with nonce 4\. Miners who
    get this transaction will complain to you because you tried to skip from nonce
    2 to nonce 4\. Remember, the transaction with nonce 3 takes time to be confirmed.'
  prefs: []
  type: TYPE_NORMAL
- en: After executing the file, you can check that your 10 accounts have 10 ethers
    each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our simple decentralized voting application based on the smart
    contract. Go outside `voting_project` and create a new directory to contain our
    application. After creating the directory, enter the following inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a program to subscribe to a `Voting` event. Name this file `watch_simple_voting.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s discuss this program line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We need `abi` to connect to a smart contract. You can get this from the smart
    contract''s complication. Since `abi` is a `json` object that has a Boolean set
    as `true` and `false`, while Python''s Boolean values are `True` and `False` (notice
    the capitalization), we need to adjust it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect to a smart contract, you need an address. This is the address from
    the deployment script. You can also set the address to the one hardcoded in the
    code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, I prefer to put it in an external file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is designed to create a subscription to the `Voting` event of the `SimpleVoting`
    smart contract. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`fromBlock` is the historical pointer. The lower the block, the earlier the
    history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we subscribe to the voting event. You would get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let this script run. Don''t exit the application. Open a new Terminal, execute
    our virtual environment script, and go inside the `voting_dapp` project. After
    doing so, create a new script and name it `simple_voting_client.py`. Refer to
    the code file in the following GitLab link for the full cod: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_dapp/simple_voting_client.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s discuss this line by line. We start from the top part of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic here is the same as the previous script. You started by opening the
    encrypted file using `password123`. You then set the voter''s account address
    in the `client_address.txt` file to make this script flexible. You are welcome
    to hardcode the voter''s account address in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you set the `abi` from the smart contract compilation in the usual manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, in this script, there are two addresses. The first is the address
    of the voter or the client. The second is the address of the smart contract. Then,
    you need to get the nonce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You use this nonce when building a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `vote` function. Here, we vote for the proposal with the index
    `0`, which is `b''messi''`. You submit `gas`, `gasPrice`, and `nonce`, and you
    omit `from` because you already set `w3.eth.defaultAccount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The last lines are dedicated to signing and broadcasting transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the script, and then go to the Terminal in which you ran the `watch_simple_voting.py`
    script. You would then get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There you have it. In a real-world application, this event can be used to give
    a notification in a decentralized application. Then, you could update the standings
    of the voting or whatever you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get all events from the beginning. Remember the code to get the
    event? This is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `get_new_entries`, you could use `get_all_entries` to retrieve
    all events from the beginning, demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Developing a commercial voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's upgrade our smart contract to a commercial one. To vote, the voter needs
    to pay a small amount of money. This is similar to American Idol, in which people
    vote for who they want to win by text-messaging their choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the `voting_project` directory and open a new file in the `contracts`
    directory and name this `CommercialVoting.vy`. Refer to the code file in the following
    GitLab link for the full code of this code block: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/CommercialVoting.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This smart contract is similar to `SimpleVoting.vy`, but with an additional
    payment feature. We won''t discuss it line by line, but we will look at the differences
    between the previous smart contract and this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In this constructor function, we save the address of the account that launched
    the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `vote` function, we added the `@payable` decorator so people can send
    money when they want to vote. As well as that, we require the minimum payment
    to be `0.01` ether using this statement: `assert msg.value >= as_wei_value(0.01,
    "ether")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, we have to create a function to withdraw ethers from the smart contract.
    Here, we send ethers to the manager account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to testing the smart contract. Create the test file inside
    the `tests` directory and name it `test_commercial_voting.py`. Refer to the code
    file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_commercial_voting.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the test functions one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is designed to test the manager variable points to the account that launched
    the smart contract. Remember that `web3.eth.coinbase` is the default account.
    Testing whether to vote requires a number of ethers and accounts, which we can
    get from `t.get_accounts()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to test that you can send ethers in the `vote` function. You also test
    the balance of the ethers that are accumulated in the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to test that you need to send a minimum of `0.01` ether when you want
    to vote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is one of the most important tests in this smart contract. It is designed
    to test whether or not you can correctly withdraw ethers from the smart contract.
    You can check the balance before and after withdrawal, and make sure that the
    difference is roughly around 1 ether (because you have to pay for gas).
  prefs: []
  type: TYPE_NORMAL
- en: Developing a token-based voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s develop a token-based voting application on the blockchain. What
    I mean by token-based voting is that in order to vote, you must have a token that
    is created in the smart contract. If you vote with this token, then the token
    is burnt, meaning that you cannot vote twice. In this smart contract, the number
    of tokens are also limited, unlike previous voting applications where unlimited
    accounts can vote. Let''s write a smart contract in the `contracts` directory
    and name the file `TokenBasedVoting.vy`. Refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/contracts/TokenBasedVoting.vy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss this script line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You have familiarized yourself with the `proposals` variable, which has the
    same purpose as the previous voting application. `token` is a new variable that
    is intended to track the token''s owner. `index` and `maximum_token` are variables
    to count how many tokens we have assigned. Remember, we want to limit the number
    of tokens. The manager is the one who launched the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, after setting up the `proposals` variable, we initialize
    the `index` to be `0`, and `maximum_token` to be `8`. Only `8` tokens are available
    in this smart contract, meaning that only `8` vote attempts can be attempted.
    The `manager` variable is initialized to the one that launched the smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, the owner can assign the token to any account. To indicate
    the owner of the token, we set the `true` value to the `token` variable, with
    its key points to `target`. The `index` is increasing by one, so later, we cannot
    create more than the `maximum_token` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `vote` function, we burn the token by setting the `token` mapping variable
    with the voter''s address key to `false`. But first, we must ensure that the voter
    is the valid owner of the token using this statement: `assert self.token[msg.sender]`.
    We must also ensure that people can vote after all tokens have been assigned.
    Of course, just like the previous voting application, we increase the vote count
    of the proposal that the voter votes for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a test for the token-based voting application. To do this, create
    a file named `test_token_based_voting.py` in the `tests` directory. Refer to the
    code file in the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_06/voting_project/tests/test_token_based_voting.py). Add
    the following code into the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss this script line by line. We start from the `fixture` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we create a `fixture` of this smart contract by deploying the smart
    contract manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a `helper` function for assigning `8` tokens to different accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This `test` function is designed to check that the `assign_token` function
    can assign a token to the target''s address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This `test` function is designed to ensure that only the owner of the token
    can vote in this smart contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This `test` function is intended to ensure that the owner of the token can vote
    for the proposal successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain why this token-based voting is quite amazing. There are only
    `8` tokens that are available, and these can be used to vote in this smart contract.
    The programmer who wrote and deployed this smart contract cannot even change the
    rule after this smart contract goes live. The voter can verify that the rule is
    fair by demanding the source code of the smart contract from the programmer, and
    verifying that the bytecode from the compilation is indeed the same as the bytecode
    in the smart contract''s address. To get the bytecode from the smart contract''s
    address, you could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Then, you compile the smart contract's source code from the author and compare
    them. Are they the same? If they are, then you can audit the smart contract to
    make sure there is no cheating. If not, then you can complain to the author or
    decide not to participate in their smart contract.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving this transparency in traditional web applications is no small feat.
    Verifying code in GitHub/GitLab does not mean much, because the developer could
    deploy different code in their server. You could be granted a guest session on
    their server to verify the transparency of the code but, again, the developer
    could deploy a sophisticated way to trick you. You could monitor the web application
    from the frontend every second and deploy a surveillance strategy either manually,
    or with the help of MLto detect suspicious activity. For example, you suddenly
    notice that a comment has been suddenly modified, but there is no indication of
    it being edited afterward, so you can be certain that the cheating happened inside
    the application. However, accusing the developer is not easy, because it's your
    word against theirs. You could be accused of creating false evidence.
  prefs: []
  type: TYPE_NORMAL
- en: What works is a credible and competent auditor being hired to do the job. The
    auditor gains access to their web application and has sufficient permission to
    read database logs and server logs to make sure there is no cheating taking place.
    This only works if the auditor cannot be bribed and is competent enough to avoid
    being tricked by the developer. Alternatively, you could use blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: Voting is a vast subject. We haven't implemented the delegation feature in this
    voting application. What I mean by delegation is similar to democracy in many
    countries. In some democratic countries, people don't choose their prime minister
    or president directly. They choose the members of the House of Representatives.
    After these are elected, the members will choose the prime minister. You can create
    a voting smart contract that implements a delegation system. Refer to the *Further
    reading* section if you want to study this further.
  prefs: []
  type: TYPE_NORMAL
- en: On a final note, our voting smart contract is pretty transparent. This can be
    good or bad depending on the situation. Transparency is good, especially in financial
    transactions, because you can audit logs to find money laundering cases. However,
    when it comes to voting, especially in politics, secrecy is a desirable property.
    If voters don't have secrecy, they may fear being persecuted by others. Secrecy
    in voting on a smart contract is still at the research stage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to create a real-world application where
    blockchain technology can shine. This real-world application is a voting application.
    From a simple voting smart contract where every account can vote, we gradually
    created a voting application in which only certain accounts can vote using a token
    system. When building this voting smart contract, we also learned about how to
    write a script to deploy a smart contract with constructors. After deploying a
    smart contract, we also learned a feature from smart contracts, which is an event.
    In a `web3` script, we subscribe to this event to learn about things that interest
    us. Finally, we created helper scripts to create many accounts and send money
    to other accounts for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to create a frontend for your `web3` script.
    You are going to build a proper decentralized application in the form of a desktop
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.ethereum.org/dao](https://www.ethereum.org/dao)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
