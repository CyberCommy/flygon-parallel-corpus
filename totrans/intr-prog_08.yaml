- en: Packages and Accessibility (Visibility)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you are already quite familiar with packages. In this chapter, we will
    complete its description and then discuss different levels of accessibility (also
    called visibility) of classes and class members – methods and fields. It all will
    come down to the key concept of object-oriented programming – the encapsulation –
    and lay the foundation for our discussion of object-oriented design principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is importing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static importing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface access modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class access modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method access modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property access modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Shadowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is importing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Importing allows us to specify a fully qualified class or interface name only
    once at the beginning of the `.java` file, before the class or interface declaration.
    The format of an import statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import <package>.<class or interface name>;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch04demo.MyApplication;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, this class can be referred to in the code by its name, `MyApplication`,
    only. It is also possible to import all the classes or interfaces of a package
    using the wildcard character (`*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch04demo.*;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the preceding import statement imports classes and interfaces of
    the subpackages of the `com.packt.javapath.ch04demo` package. If needed, each
    subpackage has to be imported separately.
  prefs: []
  type: TYPE_NORMAL
- en: But, before we continue, let's talk about the `.java` file structure and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the .java file and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, the package name reflects the directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the public class defined in it. The first
    line of the `.java` file is the package statement that starts with the `package` keyword,
    followed by the actual package name—the directory path to this file, in which
    slashes are replaced with dots. Let's look at some examples. We will look primarily
    at the `.java` file that contains a class definition, but we will also look at
    files with interfaces and the `enum` class definition because there is a particular
    type of importing (called static importing) that is primarily used with interfaces
    and `enum`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that the `src/main/java` (for Linux) or `src\main\java` (for Windows) project
    directory contains all the `.java` files, and the definition of the `MyClass` and
    `MyEnum` classes and the `MyInterface` interface from the package `com.packt.javapath` are
    stored in the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyClass.java (for Linux)
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyEnum.java
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyInterface.java
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: or (for Windows)
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyClass.java (for Windows)
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyEnum.java
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyInterface.java
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of each of these files is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If we do not import anything, then the next line in each file is a class or
    interface declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the `MyClass` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass extends SomeClass
  prefs: []
  type: TYPE_NORMAL
- en: implements Interface1, Interface2, ... {...}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; one of the classes in the file has to be `public`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `class` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name (identifier) that starts with a capital letter by convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class is a child of another class, the `extends` keyword and the name
    of the parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the class (where the fields and methods are defined) surrounded
    by braces, `{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The declaration of the `MyEnum` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public enum MyEnum implements Interface1, Interface2, ... {...}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; it has to be `public` if it is the only class defined in
    the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enum` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name (identifier) that starts with a capital letter by convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No `extends` keyword because the enum type extends the `java.lang.Enum` class implicitly
    and, in Java, a class can have only one parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the class (where the constants and methods are defined) surrounded
    by braces, `{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The declaration of the `MyInterface` interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface MyInterface extends Interface1, Interface2, ... {...}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; one of the interfaces in the file has to be `public`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `interface` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface name (identifier) that starts with a capital letter by convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the interface is a child of one or more interfaces, the `extends` keyword followed
    by the comma-separated list of the parent interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the interface (where the fields and methods are defined) surrounded
    by braces, `{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without importing, we would need to refer to each class or interface we are
    using by its fully qualified name, which includes the package name and class,
    or interface name. For example, the `MyClass` class declaration would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass
  prefs: []
  type: TYPE_NORMAL
- en: extends com.packt.javapath.something.AnotherMyClass
  prefs: []
  type: TYPE_NORMAL
- en: implements com.packt.javapath.something2.Interface1,
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.something3.Interface2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, let''s say we would like to instantiate the `SomeClass` class from the `com.packt.javapath.something` package.
    The fully qualified name of that class would be `com.packt.javapath.something.SomeClass` and
    its object creation statement would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.something.SomeClass someClass =
  prefs: []
  type: TYPE_NORMAL
- en: new com.packt.javapath.something.SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is too verbose, isn't it? This is where package importing comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Single class import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid using the fully qualified class or interface name in the code, we
    can add an import statement in the space between the package declaration and class
    or interface declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.something.SomeClass;
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the import statement allows avoiding usage of the fully qualified
    class name, which makes the code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple classes import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If several classes or interfaces from the same package are imported, it is possible
    to import all the package members using the asterisk (`*`) wildcard character.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `SomeClass` and `SomeOtherClass` belong to the same package, then the import
    statement may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.something.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  prefs: []
  type: TYPE_NORMAL
- en: SomeOtherClass someClass1 = new SomeOtherClass();
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using the asterisk is a shorter list of import statements,
    but such a style hides the names of the imported classes and interfaces. So, the
    programmer may not know exactly where they come from. Besides, when two or more
    packages contain members with the same name, you just have to import them explicitly
    as a single class import. Otherwise, the compiler will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the programmers who prefer wildcard importing, argue that
    it helps to prevent accidentally creating a class with a name that exists already
    in one of the imported packages. So, you have to make your own choice when it
    comes to style and configuring your IDE to use or not use the wildcard importing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In IntelliJ IDEA, the default style of import is using a wildcard. If you would
    like to switch to a single class import, click on File | Other Settings | Default
    Settings, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the screen that opens, select Editor | Java and check the Use single class
    import checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
  prefs: []
  type: TYPE_IMG
- en: There are other settings on this page that you might find useful, so try to
    remember how to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Static import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static import allows importing not just a class or an interface but its public
    members—fields and methods—individually. If you look in one of our test classes,
    you will see the following static import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import static org.junit.jupiter.api.Assertions.*;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This statement allowed us to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p = new Person("Joe", "Blow", dob);
  prefs: []
  type: TYPE_NORMAL
- en: assertTrue(p.equals(p));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is instead of writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person p = new Person("Joe", "Blow", dob);
  prefs: []
  type: TYPE_NORMAL
- en: Assertions.assertTrue(p.equals(p));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is one widespread case of static import usage. Another popular case is
    static importing of constants of an interface or `enum`. For example, if we have
    an interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath.api;
  prefs: []
  type: TYPE_NORMAL
- en: public interface Constants {
  prefs: []
  type: TYPE_NORMAL
- en: String NAME = "name";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to use its constants, one can import them statically:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  prefs: []
  type: TYPE_NORMAL
- en: import static com.packt.javapath.api.Constants.*;
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: String s = "My " + NAME + " is Joe";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);        //Prints: My name is Joe'
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, the same effect could be achieved by importing that `Constants` interface
    non-statically and having the class implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.api.Constants;
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass implements Constants {
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: String s = "My " + NAME + " is Joe";
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(s);        //Prints: My name is Joe'
  prefs: []
  type: TYPE_NORMAL
- en: //...
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This style of implementing an interface in order to use their constants is quite
    popular among Java programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using static import in order to use the `enum` constants looks
    similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import static java.time.DayOfWeek.*;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the code to use `DayOfWeek` constants as `MONDAY`, instead of `DayOfWeek.MONDAY`.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three explicit access modifiers—public, private, and protected—and
    one implicit (default) access modifier that is implied when no access modifier
    is set. They can be applied to the top-level class or interface, their members,
    and constructors. A *top-level* class or interface can include a *member* class
    or interface. Other *members* of a class or interface are fields and methods.
    Classes also have *constructors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the accessibility, let''s create a `com.packt.javapath.Ch07demo.pack01` package that
    contains two classes and two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass01 {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  prefs: []
  type: TYPE_NORMAL
- en: //We will write code here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class DefaultAccessClass01 {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public interface PublicInterface01 {
  prefs: []
  type: TYPE_NORMAL
- en: String name = "PublicInterface01";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface DefaultAccessInterface01 {
  prefs: []
  type: TYPE_NORMAL
- en: String name = "DefaultAccessInterface01";
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create another `com.packt.javapath.Ch07demo.pack02` package with
    one class in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass02 {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  prefs: []
  type: TYPE_NORMAL
- en: //We will write code here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the preceding classes and interfaces is in its own file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we are ready to explore the accessibility of classes, interfaces, their
    members, and constructors.
  prefs: []
  type: TYPE_NORMAL
- en: The accessibility of a top-level class or interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The public class or interface is accessible from anywhere. We can import them
    and access them from another package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.Ch07demo.pack01.PublicClass01;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.Ch07demo.pack01.PublicInterface01;
  prefs: []
  type: TYPE_NORMAL
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;
  prefs: []
  type: TYPE_NORMAL
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessInterface01;
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass02 {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(PublicInterface01.name);
  prefs: []
  type: TYPE_NORMAL
- en: PublicClass01 o = new PublicClass01();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the two import statements are commented out because they
    generate an error. That is because in the `DefaultAccessClass01` class and the `DefaultAccessClass01` interface,
    we did not use the access modifier, which made them accessible only to the members
    of the same package.
  prefs: []
  type: TYPE_NORMAL
- en: Without an access modifier, a top-level class or interface can be accessed only
    by the members of the same package.
  prefs: []
  type: TYPE_NORMAL
- en: Making an access modifier `private` in the declaration of a top-level class
    or interface make them inaccessible, so using a `private` access modifier for
    a top-level class or interface does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: The `protected` keyword cannot be applied to a top level. This limitation is
    not as obvious. We will see in the next section that `protected` means it is accessible
    to the package members and the children. So, one could argue that `protected`
    access can be applicable to a top-level class or interface too. Yet, the Java
    authors decided not to do it, and the compiler will generate an exception if you
    try to make a top-level class or interface `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `private` and `protected` access modifiers can be applied to inner
    classes or interfaces—the members of the top-level class or interface.
  prefs: []
  type: TYPE_NORMAL
- en: Access to class or interface members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when class or interface members are declared public, they cannot be accessed
    if the enclosing class or interface is inaccessible. So, all of the following
    discussion will be done under the assumption that the class or interface is accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Members of a class or interface can access other members of the same class or
    interface no matter what access modifiers they have. Which makes sense, doesn't
    it? It all happens inside the same enclosing class or interface.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the interface members are public. So, if an interface itself can
    be accessed, its members without access modifier can be accessed too. And, just
    to remind you, the interface fields are static and final (constants) by default.
  prefs: []
  type: TYPE_NORMAL
- en: The class members, on the other hand, without an access modifier, are accessible
    only to the package members. So, the class or interface may be public, but their
    members are less accessible, if not made public explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Private class or interface members are accessible only to the other members
    of the same class or interface. That is the most restricted access possible. Even
    children of the class cannot access their parents' private members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected package members are accessible to other members of the same package
    and to the children of the class or interface, which means that protected members
    can be overridden. And that is often used by programmers as an expression of the
    intent: they make those members protected that they expect to be overridden. Otherwise,
    they make them either private or public. Default—no access modifiers—access is
    rarely used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Allows access from the same class (or interface) only'
  prefs: []
  type: TYPE_NORMAL
- en: '**No modifier (default)**: Allows access from the same class (or interface)
    and the same package'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected**: Allows access from the same class (or interface), the same package,
    and any child'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Allows access from anywhere'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same accessibility rules apply to inner classes and interfaces too. Here
    is an example of a class that contains inner classes and interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass01 {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(DefaultAccessInterface01.name);
  prefs: []
  type: TYPE_NORMAL
- en: DefaultAccessClass01 o = new DefaultAccessClass01();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class DefaultAccessClass{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected class ProtectedClass{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private class PrivateClass{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface DefaultAccessInterface {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected class ProtectedInterface{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private class PrivateInterface{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is an interface with an inner class and interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public interface PublicInterface01 {
  prefs: []
  type: TYPE_NORMAL
- en: String name = "PublicInterface01";
  prefs: []
  type: TYPE_NORMAL
- en: class DefaultAccessClass{
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface DefaultAccessInterface {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, only default (public) access is allowed for the inner classes
    and interfaces of an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'And, just to repeat what we have already discussed, we will briefly mention
    some other related aspects of members accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: A static nested class (it is an inner class, but is called nested in the case
    of the static class by convention) cannot access non-static members of the same
    class, while they can access it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being a member of some top-level class, a static nested class can be public, protected,
    package-accessible (default), or private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public, protected, and package-accessible members of a class are inherited by
    the child
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor's accessibility is the same as any class member
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the title of this section has stated, that is all we can say about the accessibility
    of a constructor. Naturally, when we talk about constructors, we talk only about
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing about constructors is their ability to have private access
    only. It means that a class can provide its own factory method (see [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*), control how each object is constructed,
    and even control how many of them can be put into the circulation. The last feature
    is especially valuable in the case where each object requires access to a certain
    resource (a file or another database) that has limited support for concurrent
    access. Here is how the simplest version of such a factory method with a limited number
    of objects created may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private String field;
  prefs: []
  type: TYPE_NORMAL
- en: private static int count;
  prefs: []
  type: TYPE_NORMAL
- en: private PublicClass02(String s){
  prefs: []
  type: TYPE_NORMAL
- en: this.field = s;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public static PublicClass02 getInstance(String s){
  prefs: []
  type: TYPE_NORMAL
- en: if(count > 5){
  prefs: []
  type: TYPE_NORMAL
- en: return null;
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: count++;
  prefs: []
  type: TYPE_NORMAL
- en: return new PublicClass02(s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The usefulness of this code is not great and we show it only to demonstrate
    how a privately accessible constructor can be used. It is possible because each
    class members can access all other class members no matter their access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: All the accessibility-related features would be not needed unless they brought
    some advantages. And that is what we are going to talk about in the next section –
    about the central concept of object-oriented programming, called encapsulation,
    which would be impossible without accessibility control.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of OOP was born in an effort to manage the increasing complexity
    of software systems. The concept of data and procedures bundled in an object with
    controlled access to them (called encapsulation) allows better-organized data
    and procedures in layers, some of them hidden, others exposed to an access from
    outside. The accessibility control described in the previous sections was a significant
    part of it. Together with inheritance, interface (also called abstraction), and
    polymorphism, encapsulation became one of the central concepts of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: There is often no clear-cut separation of one OOP concept from another. Interfaces
    help to hide (encapsulate) the implementation details too. Inheritance, with its
    ability to override and hide methods of the parent classes, adds a dynamic aspect
    to the accessibility. All these three concepts make it possible to add the concept
    of polymorphism—the ability of the same object to present itself as a different
    type, depending on the context (based on inheritance or an implemented interface),
    or change its behavior based on the data availability (using composition—we will
    talk about it in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles—*or method overloading, hiding, and overriding).
  prefs: []
  type: TYPE_NORMAL
- en: 'But none of the concepts would be possible without encapsulation. That is why
    it is the most fundamental among the four concepts of OOP. Chances are, you will
    hear it mentioned a lot, so we have decided to dedicate this section to the terms
    often used in the context of an encapsulation based on the advantages it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Data hiding and decoupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility, maintainability, refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data hiding and decoupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we make object states (values of its fields) and some methods private or
    impose some other measure of restricted access to the internal object data, we
    participate in *data hiding*. The user of the object's functionality can call
    only certain methods based on their accessibility and cannot manipulate the object's
    internal state directly. The object's users may have no idea how exactly the functionality
    is implemented and the data is stored. They pass the required input data to the
    accessible methods and get back the results. This way we *decouple* the internal
    state from its usage and the implementation details from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping related methods and data in the same class also increases *decoupling*,
    this time between different areas of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: You may hear the term *tightly coupled* as something that should be allowed
    only when there is no way to avoid it because it usually means that any change
    of one part would require a corresponding change of another part. Even in everyday
    life, we prefer to deal with modularized systems that allow replacing one module
    only without changing any other component of the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: That is why *loose coupling* is usually something programmers prefer although
    it often comes at the price of not being sure that there will be no unexpected
    surprises until the system is tested in all possible execution paths. A well-thought-out
    system of tests that cover the essential use cases usually helps to reduce the
    chance of a defect propagation in production.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility, maintainability, and refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talked about decoupling in the previous section, the idea of flexibility
    and maintainability probably came to mind by association. Loosely coupled systems
    are more flexible and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, we demonstrated a flexible solution when implementing
    an object factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  prefs: []
  type: TYPE_NORMAL
- en: return new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another problem."+
  prefs: []
  type: TYPE_NORMAL
- en: '" We do not have implementation for the key " +'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is tightly coupled with its `Calculator` interface (its API) only, but that
    is inevitable because it is the contract the implementation must honor. As for
    the implementation inside the factory, it is much freer from any restrictions
    as long as it adheres to the contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create an instance of each of the implementations only once and return
    only that one instance (making each class a singleton). Here is an example of
    `CalculatorImpl` as a singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private static Calculator calculator = null;
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  prefs: []
  type: TYPE_NORMAL
- en: if(calculator == null){
  prefs: []
  type: TYPE_NORMAL
- en: calculator = new CalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return calculator;
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another problem."+
  prefs: []
  type: TYPE_NORMAL
- en: '" We do not have implementation for the key " +'
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we could add another `Calculator` implementation to the factory as a nested
    class and use it instead of `CalculatorImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl = Utils.getStringValueFromConfig(CalculatorFactory.class,
  prefs: []
  type: TYPE_NORMAL
- en: '"calculator.conf", "which.impl");'
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals("multiplies")){
  prefs: []
  type: TYPE_NORMAL
- en: return new Whatever();
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (whichImpl.equals("adds")){'
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have a problem. " +
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key which.impl value " + whichImpl +'
  prefs: []
  type: TYPE_NORMAL
- en: '" is in config.");'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static class Whatever implements Calculator {
  prefs: []
  type: TYPE_NORMAL
- en: public static String addOneAndConvertToString(double d){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Whatever.class.getName());
  prefs: []
  type: TYPE_NORMAL
- en: return Double.toString(d + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Whatever.class.getName());
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: And the client code of this factory would never know the difference unless it
    prints out information about the class using the `getClass()` method on the object
    returned from the factory. But that is another story. Functionally, our new implementation
    of `Whatever` would work as an old one.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is actually a common practice—to change internal implementation from
    one release to another. There are bug fixes, of course, and new functionality
    added. And as the code of the implementation is evolving, its programmers are
    constantly watching for the possibility of refactoring. In computer science, factoring
    is a synonym of decomposition, which is breaking a complex code into simpler parts
    with the purpose of making the code more readable and maintainable. For example,
    let''s assume we were asked to write a method that accepts two parameters of the `String`
    type (each represents an integer) and returns their sum as an integer too. After
    thinking for a moment, we decided to do it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = Integer.parseInt(s1);
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = Integer.parseInt(s1);
  prefs: []
  type: TYPE_NORMAL
- en: return i1 + i2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But then we have asked for a sample of possible input values, so we can test
    our code in the condition close to production. It turned out that some of the
    values can be up to 10,000,000,000, which exceeds 2,147,483,647 (the maximum `Integer.MAX_VALUE` int
    value Java allows). So we have changed our code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = Long.parseLong(s1);
  prefs: []
  type: TYPE_NORMAL
- en: long l2 = Long.parseLong(s2);
  prefs: []
  type: TYPE_NORMAL
- en: return l1 + l2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our code can handle values up to 9,223,372,036,854,775,807 (which is `Long.MAX_VALUE`).
    We deployed the code to production and it worked just fine for several months,
    used by a big software system that processes statistics. Then the system switched
    to a new source of data and the code started breaking. We investigated and found
    out that a new source of data yields values that can include letters and some
    other characters. We have tested our code for such cases and discovered that the
    following line throws `NumberFormatException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = Long.parseLong(s1);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed the situation with the domain experts and they suggested we record
    the values that are not integer, skip them, and continue the sum calculations.
    So, we have fixed our code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = 0;
  prefs: []
  type: TYPE_NORMAL
- en: try{
  prefs: []
  type: TYPE_NORMAL
- en: l1 = Long.parseLong(s1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: long l2 = 0;
  prefs: []
  type: TYPE_NORMAL
- en: try{
  prefs: []
  type: TYPE_NORMAL
- en: l2 = Long.parseLong(s2);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return l1 + l2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have quickly released the code to production, but for the next release got
    new requirements: the input `String` values can contain decimal numbers. So, we
    have changed the way we process the input `String` values by assuming they carry
    decimal values (which cover integer values too) and refactored the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private long getLong(String s){
  prefs: []
  type: TYPE_NORMAL
- en: double d = 0;
  prefs: []
  type: TYPE_NORMAL
- en: try{
  prefs: []
  type: TYPE_NORMAL
- en: d = Double.parseDouble(s);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(d);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  prefs: []
  type: TYPE_NORMAL
- en: return getLong(s1) + getLong(s2);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: That is what refactoring does. It restructures the code without changing its
    API. As new requirements keep coming in, we can change the `getLong()` method
    without even touching the `sum()` method. We also can reuse the `getLong()` method
    in other places, and that is going to be the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encapsulation definitely makes it easier to achieve reusability because it
    hides the implementation details. For example, the `getLong()` method we wrote
    in the previous section can be reused by another method of the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(int i, String s2){
  prefs: []
  type: TYPE_NORMAL
- en: return i + getLong(s2);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can even be made public and used by other classes, like in the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = new Ch07DemoApp().getLong("23", "45.6");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'That would be an example of a composition when some functionality is built
    (composed) using methods of different classes not related by inheritance. And,
    since it does not depend on the object state (such a method is called stateless),
    it can be made static:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: int i = Ch07DemoApp.getLong("23", "45.6");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Well, if the method is used concurrently by several other methods at runtime,
    even such a simple code may need to be protected (synchronized) against parallel
    usage. But such considerations are outside of the scope of this book. For now,
    if in doubt, do not make the method static.
  prefs: []
  type: TYPE_NORMAL
- en: If you read about the history of object-oriented programming, you will find
    that inheritance was originally tasked, among other things, to be the primary
    mechanism of code reuse. And it does the job. A child inherits (reuses) all the
    methods of its parent and overrides only those that need to be overridden for
    the child's specialization.
  prefs: []
  type: TYPE_NORMAL
- en: But in practice, it seems that other reusability techniques, similar to those
    demonstrated earlier, are more popular, especially for cases when the reused method
    is stateless. We will talk more about the reasons for that in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code testability is another area where encapsulation helps. If the implementation
    details were not hidden, we would need to test every single line of code and change
    the test every time we change any line of the implementation. But hiding the details
    behind the facade of the API allows us to focus only on the test cases that are
    required and limited by the set of possible input data (parameter values).
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are frameworks that allow us to create an object that returns a
    certain result based on the certain value of the input parameters. Mockito is
    a popular framework that does it ([http://site.mockito.org](http://site.mockito.org)).
    Such objects are called mock objects. They are especially helpful when you need
    to get certain results from methods of one object to test other methods, but you
    cannot run the actual implementation of the methods you use as the source of data
    because you do not have the necessary data in the database, for example, or it
    requires some complicated setup. To get around the problem, you can replace the
    actual implementation of certain methods—mock them—with one that returns the data
    you need unconditionally or in response to certain input data. Without the encapsulation,
    such simulation of a method behavior may be impossible because the client code
    would be tied to the specific implementation and you would not be able to change
    it without changing the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write the code that demonstrates variable shadowing. We have not talked about
    it, so you will need to do some research.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is one possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ShadowingDemo {
  prefs: []
  type: TYPE_NORMAL
- en: private String x = "x";
  prefs: []
  type: TYPE_NORMAL
- en: public void printX(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(x);
  prefs: []
  type: TYPE_NORMAL
- en: String x = "y";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(x);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `new ShadowingDemo().printX();`, it will print `x` first, then `y` because
    the local variable `x` in the following line shadows the `x` instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String x = "y";
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that shadowing can be a source of a defect or can be used for the
    benefit of the program. Without it, you would be not able to use a local variable
    identifier that is already used by an instance variable. And here is another example
    of a case where variable shadowing helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private String x = "x";
  prefs: []
  type: TYPE_NORMAL
- en: public void setX(String x) {
  prefs: []
  type: TYPE_NORMAL
- en: this.x = x;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `x` local variable (parameter) shadows the `x` instance variable. It allows
    using the same identificator for a local variable name that has been already used
    for an instance variable name. To avoid possible confusion, it is recommended
    to refer to an instance variable using the keyword `this` as we did in the example
    above.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about one of the fundamental features of an object-oriented
    language – the rules of accessibility of classes, interfaces, their members, and
    constructors. You now can import classes and interfaces from other packages and
    avoid using their fully qualified names. All that discussion allowed us to introduce
    the central concept of OOP—encapsulation. With that, we can start an informed
    discussion of **object-oriented design** (**OOD**) principles.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter presents a higher-level view of Java programming. It discusses
    the criteria of a good design and provides a guide to the well-proven OOD principles.
    Each of the design principles is described in detail and illustrated using a corresponding
    code example.
  prefs: []
  type: TYPE_NORMAL
