- en: Packages and Accessibility (Visibility)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you are already quite familiar with packages. In this chapter, we will
    complete its description and then discuss different levels of accessibility (also
    called visibility) of classes and class members – methods and fields. It all will
    come down to the key concept of object-oriented programming – the encapsulation –
    and lay the foundation for our discussion of object-oriented design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What is importing?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static importing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface access modifiers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class access modifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method access modifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property access modifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Shadowing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is importing?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Importing allows us to specify a fully qualified class or interface name only
    once at the beginning of the `.java` file, before the class or interface declaration.
    The format of an import statement is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: import <package>.<class or interface name>;
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch04demo.MyApplication;
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, this class can be referred to in the code by its name, `MyApplication`,
    only. It is also possible to import all the classes or interfaces of a package
    using the wildcard character (`*`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch04demo.*;
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the preceding import statement imports classes and interfaces of
    the subpackages of the `com.packt.javapath.ch04demo` package. If needed, each
    subpackage has to be imported separately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: But, before we continue, let's talk about the `.java` file structure and packages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the .java file and packages
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, the package name reflects the directory structure, starting
    with the project directory that contains the `.java` files. The name of each `.java`
    file has to be the same as the name of the public class defined in it. The first
    line of the `.java` file is the package statement that starts with the `package` keyword,
    followed by the actual package name—the directory path to this file, in which
    slashes are replaced with dots. Let's look at some examples. We will look primarily
    at the `.java` file that contains a class definition, but we will also look at
    files with interfaces and the `enum` class definition because there is a particular
    type of importing (called static importing) that is primarily used with interfaces
    and `enum`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that the `src/main/java` (for Linux) or `src\main\java` (for Windows) project
    directory contains all the `.java` files, and the definition of the `MyClass` and
    `MyEnum` classes and the `MyInterface` interface from the package `com.packt.javapath` are
    stored in the files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyClass.java (for Linux)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyEnum.java
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/MyInterface.java
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: or (for Windows)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyClass.java (for Windows)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyEnum.java
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\MyInterface.java
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of each of these files is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: If we do not import anything, then the next line in each file is a class or
    interface declaration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the `MyClass` class looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass extends SomeClass
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: implements Interface1, Interface2, ... {...}
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; one of the classes in the file has to be `public`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `class` keyword
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class is a child of another class, the `extends` keyword and the name
    of the parent class
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the class (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The declaration of the `MyEnum` class looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: public enum MyEnum implements Interface1, Interface2, ... {...}
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; it has to be `public` if it is the only class defined in
    the file
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `enum` keyword
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name (identifier) that starts with a capital letter by convention
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No `extends` keyword because the enum type extends the `java.lang.Enum` class implicitly
    and, in Java, a class can have only one parent
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class implements one or more interfaces, the `implements` keyword followed
    by the comma-separated list of interfaces it implements
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the class (where the constants and methods are defined) surrounded
    by braces, `{}`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The declaration of the `MyInterface` interface looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: public interface MyInterface extends Interface1, Interface2, ... {...}
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'It consists of the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: An access modifier; one of the interfaces in the file has to be `public`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `interface` keyword
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface name (identifier) that starts with a capital letter by convention
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the interface is a child of one or more interfaces, the `extends` keyword followed
    by the comma-separated list of the parent interfaces
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the interface (where the fields and methods are defined) surrounded
    by braces, `{}`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without importing, we would need to refer to each class or interface we are
    using by its fully qualified name, which includes the package name and class,
    or interface name. For example, the `MyClass` class declaration would look like
    this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: extends com.packt.javapath.something.AnotherMyClass
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: implements com.packt.javapath.something2.Interface1,
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.something3.Interface2
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, let''s say we would like to instantiate the `SomeClass` class from the `com.packt.javapath.something` package.
    The fully qualified name of that class would be `com.packt.javapath.something.SomeClass` and
    its object creation statement would look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.something.SomeClass someClass =
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: new com.packt.javapath.something.SomeClass();
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: It is too verbose, isn't it? This is where package importing comes to the rescue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Single class import
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid using the fully qualified class or interface name in the code, we
    can add an import statement in the space between the package declaration and class
    or interface declaration:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.something.SomeClass;
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the import statement allows avoiding usage of the fully qualified
    class name, which makes the code easier to read.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Multiple classes import
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If several classes or interfaces from the same package are imported, it is possible
    to import all the package members using the asterisk (`*`) wildcard character.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'If `SomeClass` and `SomeOtherClass` belong to the same package, then the import
    statement may look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.something.*;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: public class MyClass {
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: SomeClass someClass = new SomeClass();
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: SomeOtherClass someClass1 = new SomeOtherClass();
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: //...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using the asterisk is a shorter list of import statements,
    but such a style hides the names of the imported classes and interfaces. So, the
    programmer may not know exactly where they come from. Besides, when two or more
    packages contain members with the same name, you just have to import them explicitly
    as a single class import. Otherwise, the compiler will generate an error.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the programmers who prefer wildcard importing, argue that
    it helps to prevent accidentally creating a class with a name that exists already
    in one of the imported packages. So, you have to make your own choice when it
    comes to style and configuring your IDE to use or not use the wildcard importing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In IntelliJ IDEA, the default style of import is using a wildcard. If you would
    like to switch to a single class import, click on File | Other Settings | Default
    Settings, as in the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ IDEA中，默认的导入样式是使用通配符。如果你想切换到单个类导入，点击文件|其他设置|默认设置，如下截图所示：
- en: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15e4c441-99b0-4266-b669-26820d240037.png)'
- en: 'On the screen that opens, select Editor | Java and check the Use single class
    import checkbox:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的屏幕上，选择编辑器|Java，并选中使用单个类导入复选框：
- en: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dbd6160-11da-4075-afe8-394c3b78582c.png)'
- en: There are other settings on this page that you might find useful, so try to
    remember how to access it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面上还有其他一些你可能会发现有用的设置，所以试着记住如何访问它。
- en: Static import
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态导入
- en: 'Static import allows importing not just a class or an interface but its public
    members—fields and methods—individually. If you look in one of our test classes,
    you will see the following static import statement:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入允许单独导入一个类或接口，以及它的公共成员——字段和方法。如果你查看我们的一个测试类，你会看到以下静态导入语句：
- en: '```java'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import static org.junit.jupiter.api.Assertions.*;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: import static org.junit.jupiter.api.Assertions.*;
- en: '```'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This statement allowed us to write the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句允许我们编写以下内容：
- en: '```java'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p = new Person("Joe", "Blow", dob);
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = new Person("Joe", "Blow", dob);
- en: assertTrue(p.equals(p));
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: assertTrue(p.equals(p));
- en: '```'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is instead of writing this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样写：
- en: '```java'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p = new Person("Joe", "Blow", dob);
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Person p = new Person("Joe", "Blow", dob);
- en: Assertions.assertTrue(p.equals(p));
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Assertions.assertTrue(p.equals(p));
- en: '```'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is one widespread case of static import usage. Another popular case is
    static importing of constants of an interface or `enum`. For example, if we have
    an interface as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是静态导入用法的一个普遍情况。另一个常见情况是静态导入接口或`enum`的常量。例如，如果我们有一个如下的接口：
- en: '```java'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath.api;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath.api;
- en: public interface Constants {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: public interface Constants {
- en: String NAME = "name";
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: String NAME = "name";
- en: '}'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'Then, to use its constants, one can import them statically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用它的常量，可以静态导入它们：
- en: '```java'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import static com.packt.javapath.api.Constants.*;
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: import static com.packt.javapath.api.Constants.*;
- en: public class MyClass {
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass {
- en: //...
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = "My " + NAME + " is Joe";
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: String s = "My " + NAME + " is Joe";
- en: 'System.out.println(s);        //Prints: My name is Joe'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);        //打印：My name is Joe
- en: //...
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'By the way, the same effect could be achieved by importing that `Constants` interface
    non-statically and having the class implement it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，通过非静态导入`Constants`接口并让类实现它也可以达到同样的效果：
- en: '```java'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: package com.packt.javapath;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: package com.packt.javapath;
- en: import com.packt.javapath.api.Constants;
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.api.Constants;
- en: public class MyClass implements Constants {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: public class MyClass implements Constants {
- en: //...
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: String s = "My " + NAME + " is Joe";
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: String s = "My " + NAME + " is Joe";
- en: 'System.out.println(s);        //Prints: My name is Joe'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(s);        //打印：My name is Joe
- en: //...
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: //...
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This style of implementing an interface in order to use their constants is quite
    popular among Java programmers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现接口以使用它们的常量的方式在Java程序员中相当流行。
- en: 'An example of using static import in order to use the `enum` constants looks
    similar:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入来使用`enum`常量的示例看起来很相似：
- en: '```java'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import static java.time.DayOfWeek.*;
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: import static java.time.DayOfWeek.*;
- en: '```'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It allows the code to use `DayOfWeek` constants as `MONDAY`, instead of `DayOfWeek.MONDAY`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许代码将`DayOfWeek`常量用作`MONDAY`，而不是`DayOfWeek.MONDAY`。
- en: Access modifiers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: There are three explicit access modifiers—public, private, and protected—and
    one implicit (default) access modifier that is implied when no access modifier
    is set. They can be applied to the top-level class or interface, their members,
    and constructors. A *top-level* class or interface can include a *member* class
    or interface. Other *members* of a class or interface are fields and methods.
    Classes also have *constructors*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种显式访问修饰符——public、private和protected——以及一种隐式（默认）访问修饰符，当没有设置访问修饰符时会被隐含。它们可以应用于顶级类或接口、它们的成员和构造函数。*顶级*类或接口可以包括*成员*类或接口。类或接口的其他*成员*是字段和方法。类还有*构造函数*。
- en: 'To demonstrate the accessibility, let''s create a `com.packt.javapath.Ch07demo.pack01` package that
    contains two classes and two interfaces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示可访问性，让我们创建一个`com.packt.javapath.Ch07demo.pack01`包，其中包含两个类和两个接口：
- en: '```java'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PublicClass01 {
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass01 {
- en: public static void main(String[] args){
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: //We will write code here
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: //我们将在这里编写代码
- en: '}'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class DefaultAccessClass01 {
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类 DefaultAccessClass01 {
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public interface PublicInterface01 {
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: public interface PublicInterface01 {
- en: String name = "PublicInterface01";
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "PublicInterface01";
- en: '}'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DefaultAccessInterface01 {
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 DefaultAccessInterface01 {
- en: String name = "DefaultAccessInterface01";
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "DefaultAccessInterface01";
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We will also create another `com.packt.javapath.Ch07demo.pack02` package with
    one class in it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建另一个`com.packt.javapath.Ch07demo.pack02`包，并在其中创建一个类：
- en: '```java'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class PublicClass02 {
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: public class PublicClass02 {
- en: public static void main(String[] args){
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args){
- en: //We will write code here
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: //我们将在这里编写代码
- en: '}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Each of the preceding classes and interfaces is in its own file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个类和接口都在自己的文件中：
- en: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eac9098f-e718-4bd2-ab43-b02aac7aa66e.png)'
- en: Now we are ready to explore the accessibility of classes, interfaces, their
    members, and constructors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备探索类、接口、它们的成员和构造函数的可访问性。
- en: The accessibility of a top-level class or interface
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶级类或接口的可访问性
- en: 'The public class or interface is accessible from anywhere. We can import them
    and access them from another package:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类或接口可以从任何地方访问。我们可以导入它们并从另一个包中访问它们：
- en: '```java'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: import com.packt.javapath.Ch07demo.pack01.PublicClass01;
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.Ch07demo.pack01.PublicClass01;
- en: import com.packt.javapath.Ch07demo.pack01.PublicInterface01;
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: import com.packt.javapath.Ch07demo.pack01.PublicInterface01;
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessClass01;
- en: //import com.packt.javapath.Ch07demo.pack01.DefaultAccessInterface01;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass02 {
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(PublicInterface01.name);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: PublicClass01 o = new PublicClass01();
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the two import statements are commented out because they
    generate an error. That is because in the `DefaultAccessClass01` class and the `DefaultAccessClass01` interface,
    we did not use the access modifier, which made them accessible only to the members
    of the same package.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Without an access modifier, a top-level class or interface can be accessed only
    by the members of the same package.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Making an access modifier `private` in the declaration of a top-level class
    or interface make them inaccessible, so using a `private` access modifier for
    a top-level class or interface does not make sense.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The `protected` keyword cannot be applied to a top level. This limitation is
    not as obvious. We will see in the next section that `protected` means it is accessible
    to the package members and the children. So, one could argue that `protected`
    access can be applicable to a top-level class or interface too. Yet, the Java
    authors decided not to do it, and the compiler will generate an exception if you
    try to make a top-level class or interface `protected`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: However, `private` and `protected` access modifiers can be applied to inner
    classes or interfaces—the members of the top-level class or interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Access to class or interface members
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even when class or interface members are declared public, they cannot be accessed
    if the enclosing class or interface is inaccessible. So, all of the following
    discussion will be done under the assumption that the class or interface is accessible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Members of a class or interface can access other members of the same class or
    interface no matter what access modifiers they have. Which makes sense, doesn't
    it? It all happens inside the same enclosing class or interface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: By default, the interface members are public. So, if an interface itself can
    be accessed, its members without access modifier can be accessed too. And, just
    to remind you, the interface fields are static and final (constants) by default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The class members, on the other hand, without an access modifier, are accessible
    only to the package members. So, the class or interface may be public, but their
    members are less accessible, if not made public explicitly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Private class or interface members are accessible only to the other members
    of the same class or interface. That is the most restricted access possible. Even
    children of the class cannot access their parents' private members.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected package members are accessible to other members of the same package
    and to the children of the class or interface, which means that protected members
    can be overridden. And that is often used by programmers as an expression of the
    intent: they make those members protected that they expect to be overridden. Otherwise,
    they make them either private or public. Default—no access modifiers—access is
    rarely used.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Allows access from the same class (or interface) only'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**No modifier (default)**: Allows access from the same class (or interface)
    and the same package'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected**: Allows access from the same class (or interface), the same package,
    and any child'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: Allows access from anywhere'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The same accessibility rules apply to inner classes and interfaces too. Here
    is an example of a class that contains inner classes and interfaces:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: public class PublicClass01 {
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args){
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(DefaultAccessInterface01.name);
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: DefaultAccessClass01 o = new DefaultAccessClass01();
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: class DefaultAccessClass{
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: protected class ProtectedClass{
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: private class PrivateClass{
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: interface DefaultAccessInterface {
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: protected class ProtectedInterface{
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: private class PrivateInterface{
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is an interface with an inner class and interface:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: public interface PublicInterface01 {
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: public interface PublicInterface01 {
- en: String name = "PublicInterface01";
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: String name = "PublicInterface01";
- en: class DefaultAccessClass{
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类DefaultAccessClass{
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: interface DefaultAccessInterface {
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接口DefaultAccessInterface {
- en: '}'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, only default (public) access is allowed for the inner classes
    and interfaces of an interface.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，接口的内部类和接口只允许默认（公共）访问。
- en: 'And, just to repeat what we have already discussed, we will briefly mention
    some other related aspects of members accessibility:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，为了重复我们已经讨论过的内容，我们将简要提及一些与成员可访问性相关的其他方面：
- en: A static nested class (it is an inner class, but is called nested in the case
    of the static class by convention) cannot access non-static members of the same
    class, while they can access it
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态嵌套类（在静态类的情况下被称为嵌套类，但按照惯例）不能访问同一类的非静态成员，而它们可以访问它
- en: Being a member of some top-level class, a static nested class can be public, protected,
    package-accessible (default), or private
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为某个顶级类的成员，静态嵌套类可以是公共的、受保护的、包访问（默认）的或私有的
- en: Public, protected, and package-accessible members of a class are inherited by
    the child
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的公共、受保护和包访问成员都会被子类继承
- en: The constructor's accessibility is the same as any class member
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的可访问性与任何类成员相同
- en: As the title of this section has stated, that is all we can say about the accessibility
    of a constructor. Naturally, when we talk about constructors, we talk only about
    classes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节标题所述，这就是我们对构造函数可访问性能说的一切。当然，当我们谈论构造函数时，我们只谈论类。
- en: 'The interesting thing about constructors is their ability to have private access
    only. It means that a class can provide its own factory method (see [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*), control how each object is constructed,
    and even control how many of them can be put into the circulation. The last feature
    is especially valuable in the case where each object requires access to a certain
    resource (a file or another database) that has limited support for concurrent
    access. Here is how the simplest version of such a factory method with a limited number
    of objects created may look:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的有趣之处在于它们只能具有私有访问权限。这意味着一个类可以提供自己的工厂方法（参见[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)，*接口、类和对象构造*），控制每个对象的构造方式，甚至控制可以将多少个对象放入流通中。在每个对象都需要访问某个资源（文件或另一个数据库）的情况下，最后一个特性尤为有价值，因为这些资源对并发访问的支持有限。以下是一个具有有限创建对象数量的最简单版本的工厂方法的样子：
- en: '```java'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private String field;
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 私有String field;
- en: private static int count;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 私有静态int count;
- en: private PublicClass02(String s){
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 私有PublicClass02(String s){
- en: this.field = s;
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: this.field = s;
- en: '}'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static PublicClass02 getInstance(String s){
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: public static PublicClass02 getInstance(String s){
- en: if(count > 5){
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: if(count > 5){
- en: return null;
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 返回null;
- en: '} else {'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: count++;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: count++;
- en: return new PublicClass02(s);
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 返回新的PublicClass02(s);
- en: '}'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The usefulness of this code is not great and we show it only to demonstrate
    how a privately accessible constructor can be used. It is possible because each
    class members can access all other class members no matter their access modifiers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的用处并不大，我们只是为了演示私有可访问的构造函数如何被使用。这是可能的，因为每个类成员都可以访问所有其他类成员，无论它们的访问修饰符是什么。
- en: All the accessibility-related features would be not needed unless they brought
    some advantages. And that is what we are going to talk about in the next section –
    about the central concept of object-oriented programming, called encapsulation,
    which would be impossible without accessibility control.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除非可访问性相关的特性带来了一些优势，否则它们是不需要的。这就是我们将在下一节讨论的内容——面向对象编程的中心概念封装的优势。
- en: Encapsulation
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: The concept of OOP was born in an effort to manage the increasing complexity
    of software systems. The concept of data and procedures bundled in an object with
    controlled access to them (called encapsulation) allows better-organized data
    and procedures in layers, some of them hidden, others exposed to an access from
    outside. The accessibility control described in the previous sections was a significant
    part of it. Together with inheritance, interface (also called abstraction), and
    polymorphism, encapsulation became one of the central concepts of OOP.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的概念诞生于管理软件系统日益增长的复杂性的努力中。将数据和程序捆绑在一个对象中，并对它们进行受控访问（称为封装）的概念允许更好地组织数据和程序在层中，其中一些被隐藏，其他则暴露给外部访问。前面章节中描述的可访问性控制是其中的重要部分。连同继承、接口（也称为抽象）和多态性，封装成为面向对象编程的中心概念之一。
- en: There is often no clear-cut separation of one OOP concept from another. Interfaces
    help to hide (encapsulate) the implementation details too. Inheritance, with its
    ability to override and hide methods of the parent classes, adds a dynamic aspect
    to the accessibility. All these three concepts make it possible to add the concept
    of polymorphism—the ability of the same object to present itself as a different
    type, depending on the context (based on inheritance or an implemented interface),
    or change its behavior based on the data availability (using composition—we will
    talk about it in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles—*or method overloading, hiding, and overriding).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很难清晰地将一个面向对象的概念与另一个分开。接口也有助于隐藏（封装）实现细节。继承具有覆盖和隐藏父类方法的能力，为可访问性增加了动态方面。所有这三个概念使得多态的概念成为可能——同一个对象可以根据上下文（基于继承或实现的接口）呈现为不同类型，或者根据数据可用性改变其行为（使用组合——我们将在[第8章](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml)中讨论，*面向对象设计（OOD）原则*，或者方法重载、隐藏和覆盖）。
- en: 'But none of the concepts would be possible without encapsulation. That is why
    it is the most fundamental among the four concepts of OOP. Chances are, you will
    hear it mentioned a lot, so we have decided to dedicate this section to the terms
    often used in the context of an encapsulation based on the advantages it provides:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Data hiding and decoupling
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility, maintainability, refactoring
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusability
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data hiding and decoupling
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we make object states (values of its fields) and some methods private or
    impose some other measure of restricted access to the internal object data, we
    participate in *data hiding*. The user of the object's functionality can call
    only certain methods based on their accessibility and cannot manipulate the object's
    internal state directly. The object's users may have no idea how exactly the functionality
    is implemented and the data is stored. They pass the required input data to the
    accessible methods and get back the results. This way we *decouple* the internal
    state from its usage and the implementation details from the API.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Grouping related methods and data in the same class also increases *decoupling*,
    this time between different areas of functionality.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: You may hear the term *tightly coupled* as something that should be allowed
    only when there is no way to avoid it because it usually means that any change
    of one part would require a corresponding change of another part. Even in everyday
    life, we prefer to deal with modularized systems that allow replacing one module
    only without changing any other component of the rest of the system.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: That is why *loose coupling* is usually something programmers prefer although
    it often comes at the price of not being sure that there will be no unexpected
    surprises until the system is tested in all possible execution paths. A well-thought-out
    system of tests that cover the essential use cases usually helps to reduce the
    chance of a defect propagation in production.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility, maintainability, and refactoring
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talked about decoupling in the previous section, the idea of flexibility
    and maintainability probably came to mind by association. Loosely coupled systems
    are more flexible and easier to maintain.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, we demonstrated a flexible solution when implementing
    an object factory:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: return new CalculatorImpl();
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another problem."+
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '" We do not have implementation for the key " +'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: It is tightly coupled with its `Calculator` interface (its API) only, but that
    is inevitable because it is the contract the implementation must honor. As for
    the implementation inside the factory, it is much freer from any restrictions
    as long as it adheres to the contract.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'We could create an instance of each of the implementations only once and return
    only that one instance (making each class a singleton). Here is an example of
    `CalculatorImpl` as a singleton:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: private static Calculator calculator = null;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: WhichImpl whichImpl =
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Utils.getWhichImplValueFromConfig(Utils.class,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_NAME, Calculator.CONF_WHICH_IMPL);
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: switch (whichImpl){
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'case multiplies:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: if(calculator == null){
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: calculator = new CalculatorImpl();
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: return calculator;
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'case adds:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'default:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have another problem."+
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '" We do not have implementation for the key " +'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Calculator.CONF_WHICH_IMPL + " value " + whichImpl);
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we could add another `Calculator` implementation to the factory as a nested
    class and use it instead of `CalculatorImpl`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: public static Calculator createInstance(){
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: String whichImpl = Utils.getStringValueFromConfig(CalculatorFactory.class,
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '"calculator.conf", "which.impl");'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: if(whichImpl.equals("multiplies")){
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: return new Whatever();
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (whichImpl.equals("adds")){'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: return new AnotherCalculatorImpl();
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Houston, we have a problem. " +
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '"Unknown key which.impl value " + whichImpl +'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '" is in config.");'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: static class Whatever implements Calculator {
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: public static String addOneAndConvertToString(double d){
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Whatever.class.getName());
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: return Double.toString(d + 1);
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(Whatever.class.getName());
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: And the client code of this factory would never know the difference unless it
    prints out information about the class using the `getClass()` method on the object
    returned from the factory. But that is another story. Functionally, our new implementation
    of `Whatever` would work as an old one.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is actually a common practice—to change internal implementation from
    one release to another. There are bug fixes, of course, and new functionality
    added. And as the code of the implementation is evolving, its programmers are
    constantly watching for the possibility of refactoring. In computer science, factoring
    is a synonym of decomposition, which is breaking a complex code into simpler parts
    with the purpose of making the code more readable and maintainable. For example,
    let''s assume we were asked to write a method that accepts two parameters of the `String`
    type (each represents an integer) and returns their sum as an integer too. After
    thinking for a moment, we decided to do it this way:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: int i1 = Integer.parseInt(s1);
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: int i2 = Integer.parseInt(s1);
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: return i1 + i2;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'But then we have asked for a sample of possible input values, so we can test
    our code in the condition close to production. It turned out that some of the
    values can be up to 10,000,000,000, which exceeds 2,147,483,647 (the maximum `Integer.MAX_VALUE` int
    value Java allows). So we have changed our code to the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = Long.parseLong(s1);
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: long l2 = Long.parseLong(s2);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: return l1 + l2;
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our code can handle values up to 9,223,372,036,854,775,807 (which is `Long.MAX_VALUE`).
    We deployed the code to production and it worked just fine for several months,
    used by a big software system that processes statistics. Then the system switched
    to a new source of data and the code started breaking. We investigated and found
    out that a new source of data yields values that can include letters and some
    other characters. We have tested our code for such cases and discovered that the
    following line throws `NumberFormatException`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = Long.parseLong(s1);
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed the situation with the domain experts and they suggested we record
    the values that are not integer, skip them, and continue the sum calculations.
    So, we have fixed our code, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: long l1 = 0;
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: try{
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: l1 = Long.parseLong(s1);
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: long l2 = 0;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: try{
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: l2 = Long.parseLong(s2);
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: return l1 + l2;
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'We have quickly released the code to production, but for the next release got
    new requirements: the input `String` values can contain decimal numbers. So, we
    have changed the way we process the input `String` values by assuming they carry
    decimal values (which cover integer values too) and refactored the code, as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: private long getLong(String s){
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: double d = 0;
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: try{
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: d = Double.parseDouble(s);
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (NumberFormatException ex){'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: //make a record to a log
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: return Math.round(d);
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(String s1, String s2){
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: return getLong(s1) + getLong(s2);
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: That is what refactoring does. It restructures the code without changing its
    API. As new requirements keep coming in, we can change the `getLong()` method
    without even touching the `sum()` method. We also can reuse the `getLong()` method
    in other places, and that is going to be the topic of the next section.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encapsulation definitely makes it easier to achieve reusability because it
    hides the implementation details. For example, the `getLong()` method we wrote
    in the previous section can be reused by another method of the same class:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: public long sum(int i, String s2){
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: return i + getLong(s2);
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'It can even be made public and used by other classes, like in the following
    line:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: int i = new Ch07DemoApp().getLong("23", "45.6");
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'That would be an example of a composition when some functionality is built
    (composed) using methods of different classes not related by inheritance. And,
    since it does not depend on the object state (such a method is called stateless),
    it can be made static:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: int i = Ch07DemoApp.getLong("23", "45.6");
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Well, if the method is used concurrently by several other methods at runtime,
    even such a simple code may need to be protected (synchronized) against parallel
    usage. But such considerations are outside of the scope of this book. For now,
    if in doubt, do not make the method static.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: If you read about the history of object-oriented programming, you will find
    that inheritance was originally tasked, among other things, to be the primary
    mechanism of code reuse. And it does the job. A child inherits (reuses) all the
    methods of its parent and overrides only those that need to be overridden for
    the child's specialization.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: But in practice, it seems that other reusability techniques, similar to those
    demonstrated earlier, are more popular, especially for cases when the reused method
    is stateless. We will talk more about the reasons for that in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml), *Object-Oriented
    Design (OOD) Principles*.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code testability is another area where encapsulation helps. If the implementation
    details were not hidden, we would need to test every single line of code and change
    the test every time we change any line of the implementation. But hiding the details
    behind the facade of the API allows us to focus only on the test cases that are
    required and limited by the set of possible input data (parameter values).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are frameworks that allow us to create an object that returns a
    certain result based on the certain value of the input parameters. Mockito is
    a popular framework that does it ([http://site.mockito.org](http://site.mockito.org)).
    Such objects are called mock objects. They are especially helpful when you need
    to get certain results from methods of one object to test other methods, but you
    cannot run the actual implementation of the methods you use as the source of data
    because you do not have the necessary data in the database, for example, or it
    requires some complicated setup. To get around the problem, you can replace the
    actual implementation of certain methods—mock them—with one that returns the data
    you need unconditionally or in response to certain input data. Without the encapsulation,
    such simulation of a method behavior may be impossible because the client code
    would be tied to the specific implementation and you would not be able to change
    it without changing the client code.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Shadowing
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write the code that demonstrates variable shadowing. We have not talked about
    it, so you will need to do some research.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is one possible solution:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: public class ShadowingDemo {
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: private String x = "x";
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: public void printX(){
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(x);
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: String x = "y";
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(x);
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `new ShadowingDemo().printX();`, it will print `x` first, then `y` because
    the local variable `x` in the following line shadows the `x` instance variable:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: String x = "y";
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that shadowing can be a source of a defect or can be used for the
    benefit of the program. Without it, you would be not able to use a local variable
    identifier that is already used by an instance variable. And here is another example
    of a case where variable shadowing helps:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: private String x = "x";
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: public void setX(String x) {
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: this.x = x;
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: The `x` local variable (parameter) shadows the `x` instance variable. It allows
    using the same identificator for a local variable name that has been already used
    for an instance variable name. To avoid possible confusion, it is recommended
    to refer to an instance variable using the keyword `this` as we did in the example
    above.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about one of the fundamental features of an object-oriented
    language – the rules of accessibility of classes, interfaces, their members, and
    constructors. You now can import classes and interfaces from other packages and
    avoid using their fully qualified names. All that discussion allowed us to introduce
    the central concept of OOP—encapsulation. With that, we can start an informed
    discussion of **object-oriented design** (**OOD**) principles.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter presents a higher-level view of Java programming. It discusses
    the criteria of a good design and provides a guide to the well-proven OOD principles.
    Each of the design principles is described in detail and illustrated using a corresponding
    code example.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
