- en: Building Forms with QtWidgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first steps in application development is prototyping your app's
    GUI. With a wide range of ready-to-use widgets, PyQt makes this very easy. Best
    of all, we can move our prototype code directly into an actual application when
    we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to get familiar with basic form design over the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic QtWidgets widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing and arranging widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a calendar application GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you'll need everything from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, plus the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M2R26r](http://bit.ly/2M2R26r)
  prefs: []
  type: TYPE_NORMAL
- en: Creating basic QtWidgets widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QtWidgets` module contains dozens of widgets, some simple and standard,
    others complex and unique. In this section, we're going to go through eight of
    the most common widgets and their basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting this section, make a copy of your application template from
    [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started with
    PyQt*, and save it to a file called `widget_demo.py`. As we go through the examples,
    you can add them into your `MainWindow.__init__()` method to see how the objects
    work.
  prefs: []
  type: TYPE_NORMAL
- en: QWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QWidget` is the parent class of all other widgets, so any properties and methods
    it has will also be available in any other widget. By itself, a `QWidget` object
    can be useful as a container for other widgets, a filler to fill blank areas,
    or as a base class for top-level windows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a widget is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice we've passed `self` as an argument. If we're creating a widget to be
    placed on or used inside another widget class, as we are here, it's a good idea
    to pass a reference to the parent widget as the first argument. Specifying a parent
    widget will ensure that the child widget is destroyed and cleaned up when the
    parent is, and limit its visibility to inside the parent widget.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, PyQt also allows us to specify values for any of the widget's
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the `toolTip` property to set the tooltip text (which
    will pop up when the widget has hovered with the mouse) for this widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Read the C++ documentation for `QWidget` (found at [https://doc.qt.io/qt-5/qwidget.html](https://doc.qt.io/qt-5/qwidget.html))
    and note the class's properties. Note that each property has a specified data
    type. In this case, `toolTip` requires `QString`. We can use a regular Unicode
    string whenever `QString` is required because PyQt translates it for us. For more
    esoteric data types, such as `QSize` or `QColor`, we would need to create the
    appropriate object. Be aware that these conversions are happening in the background,
    however, as Qt is not forgiving about data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This would result in `TypeError` because PyQt won't convert a `bytes` object
    into `QString`. Because of this, make sure you check the data type required by
    a widget's properties or method calls and use a compatible type.
  prefs: []
  type: TYPE_NORMAL
- en: QWidget as a top-level window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a `QWidget` is created without a parent and its `show()` method is called,
    it becomes a top-level window. When we use it as a top-level window, such as we
    do with our `MainWindow` instance, there are some window-specific properties we
    can set. Some of these are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Argument type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `windowTitle` | string | The title of the window. |'
  prefs: []
  type: TYPE_TB
- en: '| `windowIcon` | `QIcon` | The icon for the window. |'
  prefs: []
  type: TYPE_TB
- en: '| `modal` | Boolean | Whether the window is modal. |'
  prefs: []
  type: TYPE_TB
- en: '| `cursor` | `Qt.CursorShape` | The cursor used when this widget has hovered.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `windowFlags` | `Qt.WindowFlags` | How the OS should treat the window (dialog,
    tooltip, popup). |'
  prefs: []
  type: TYPE_TB
- en: The argument type for `cursor` is an example of an enum. An enum is simply a
    list of named values, and Qt defines enum anywhere that a property is limited
    to a set of descriptive values. The argument for `windowFlags` is an example of
    a flag. Flags are like enums, except that they can be combined (using the pipe
    operator, `|`) so that multiple flags can be passed.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, both the enum and flag are part of the `Qt` namespace, found in
    the `QtCore` module. So, for example, to set the cursor to an arrow cursor when
    the widget is hovered over, you'd need to find the right constant in `Qt` that
    refers to the arrow cursor and set the widget's `cursor` property to that value.
    To set flags on the window indicating to the OS that it's a `sheet` and `popup` window,
    you'd need to find the constants in `Qt` that represent those window flags, combine
    them with the pipe, and pass it as the value for `windowFlags`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating such a `QWidget` window might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We'll encounter many more flags and enums as we learn to configure Qt widgets
    throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: QLabel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QLabel` is a `QWidget` object configured to display simple text and images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating one looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice this time that the parent widget is specified as the second argument,
    while the first argument is the text of the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used `QLabel` properties are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | string | Text to display on the label. |'
  prefs: []
  type: TYPE_TB
- en: '| `margin` | integer | Space (in pixels) around the text. |'
  prefs: []
  type: TYPE_TB
- en: '| `indent` | integer | Space (in pixels) to indent the text. |'
  prefs: []
  type: TYPE_TB
- en: '| `wordWrap` | Boolean | Whether to wrap long lines. |'
  prefs: []
  type: TYPE_TB
- en: '| `textFormat` | `Qt.TextFormat` | Force plaintext or rich text, or auto-detect.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pixmap` | `QPixmap` | An image to display instead of the text. |'
  prefs: []
  type: TYPE_TB
- en: 'The label''s text is stored in its `text` property so it can be accessed or
    changed using the related accessor methods, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`QLabel` can display plaintext, rich text, or an image. Rich text in Qt uses
    an HTML-like syntax; by default, the label will automatically detect whether your
    string contains any formatting tags and display the appropriate type of text accordingly.
    For example, if we wanted to make our label boldface and add a margin around the
    text, we could do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will learn more about using images, rich text, and fonts in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* and [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml),
    *Creating Rich Text with QTextDocument*.
  prefs: []
  type: TYPE_NORMAL
- en: QLineEdit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `QLineEdit` class is a single-line text-entry widget that you might commonly
    use in a data-entry or login form. `QLineEdit` can be called with no arguments,
    with only a parent widget, or with a default string value as the first argument,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a number of properties we can pass in:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | string | The contents of the box. |'
  prefs: []
  type: TYPE_TB
- en: '| `readOnly` | Boolean | Whether the field can be edited. |'
  prefs: []
  type: TYPE_TB
- en: '| `clearButtonEnabled` | Boolean | Whether a clear button is added. |'
  prefs: []
  type: TYPE_TB
- en: '| `placeholderText` | string | Text that will appear when the field is empty.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `maxLength` | integer | The maximum number of characters that can be entered.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `echoMode` | `QLineEdit.EchoMode` | Switches the way text is displayed as
    its entered (such as for password entry). |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s add some properties to our line edit widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will populate the widget with a default text of `'default value'`. It will
    display a placeholder string of `'Type here'` when the field is empty or a small
    `X` button that clears the field when it has text in it. It also limits the number
    of characters that can be typed to `20`.
  prefs: []
  type: TYPE_NORMAL
- en: QPushButton and other buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QPushButton` is a simple, clickable button widget. Like `QLabel` and `QLineEdit`,
    it can be called with a first argument that specifies the text on the button,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the more useful properties we can set on `QPushButton` include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `checkable` | Boolean | Whether the button stays on when pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `checked` | Boolean | For `checkable` buttons, whether the button is checked.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `icon` | `QIcon` | An icon image to display on the button. |'
  prefs: []
  type: TYPE_TB
- en: '| `shortcut` | `QKeySequence` | A keyboard shortcut that will activate the
    button. |'
  prefs: []
  type: TYPE_TB
- en: 'The `checkable` and `checked` properties allow us to use this button as a toggle
    button that reflects an on/off state, rather than just a click button that performs
    an action. All of these properties come from the `QPushButton` class''s parent
    class, `QAbstractButton`. This is also the parent class of several other button
    classes, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `QCheckBox` | A checkbox can be Boolean for on/off or tristate for on/partially
    on/off. |'
  prefs: []
  type: TYPE_TB
- en: '| `QRadioButton` | Like checkbox, but only one button among those with the
    same parent can be checked. |'
  prefs: []
  type: TYPE_TB
- en: '| `QToolButton` | Special button for use on toolbar widgets. |'
  prefs: []
  type: TYPE_TB
- en: Though each has some unique features, for the core functionality, these buttons
    are the same in terms of how we create and configure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make our button checkable, check it by default, and give it a shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `shortcut` option requires us to pass in a `QKeySequence`, which
    is part of the `QtGui` module. This is a good example of how property arguments
    often need to be wrapped in some kind of utility class. `QKeySequence` encapsulates
    a key combination, in this case, the *Ctrl* key (or *command* key, on macOS) and
    *P*.
  prefs: []
  type: TYPE_NORMAL
- en: Key sequences can be specified as a string, such as the preceding example, or
    by using enum values from the `QtCOre.Qt` module. For example, we could write
    the preceding as `QKeySequence(qtc.Qt.CTRL + qtc.Qt.Key_P)`.
  prefs: []
  type: TYPE_NORMAL
- en: QComboBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **combobox**, also known as a dropdown or select widget, is a widget that
    presents a list of options when clicked on, one of which must be selected. `QCombobox`
    can optionally allow text input for custom answers by setting its `editable` property
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `QCombobox` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, our `combobox` has no items in its menu. `QCombobox` doesn''t provide
    a way to initialize the widget with options in the constructor; instead, we have
    to create the widget, then use the `addItem()` or `insertItem()` method to populate
    its menu with options, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `addItem()` method takes a string for the label and a data value. As you
    can see, this value can be anything—an integer, a string, a Python class. This
    value can be retrieved for the currently selected item using the `QCombobox` object's
    `currentData()` method. It's typically a good idea—though not required—to make
    all the item values be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: '`addItem()` will always append items to the end of the menu; to insert them
    earlier, use the `insertItem()` method. It works exactly the same, except that
    it takes an index (integer value) for the first argument. The item will be inserted
    at that index in the list. If we want to save time and don''t need a `data` property
    for our items, we can also use `addItems()` or `insertItems()` to pass in a list
    of options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other important properties for `QComboBox` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `currentData` | (anything) | The data object of the currently selected item.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `currentIndex` | integer | The index of the currently selected item. |'
  prefs: []
  type: TYPE_TB
- en: '| `currentText` | string | The text of the currently selected item. |'
  prefs: []
  type: TYPE_TB
- en: '| `editable` | Boolean | Whether `combobox` allows text entry. |'
  prefs: []
  type: TYPE_TB
- en: '| `insertPolicy` | `QComboBox.InsertPolicy` | Where entered items should be
    inserted in the list. |'
  prefs: []
  type: TYPE_TB
- en: The data type for `currentData` is `QVariant`, a special Qt class that acts
    as a container for any kind of data. These are more useful in C++, as they provide
    a workaround for static typing in situations where multiple data types might be
    useful. PyQt automatically converts `QVariant` objects to the most appropriate
    Python type, so we rarely need to work directly with this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `combobox` so that we can add items to the top of the dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now this `combobox` will allow any text to be typed in; the text will be added
    to the top of the list box. The `data` property for the new items will be `None`,
    so this is really only appropriate if we are working with the visible strings
    only.
  prefs: []
  type: TYPE_NORMAL
- en: QSpinBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, a spinbox is a text entry with arrow buttons designed to *spin*
    through a set of incremental values. `QSpinbox` is built specifically to handle
    either integers or discrete values (such as a combobox).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful `QSpinBox` properties include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `value` | integer | The current spinbox value, as an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `cleanText` | string | The current spinbox value, as a string (excludes the
    prefix and suffix). |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum` | integer | The maximum integer value of the box. |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum` | integer | The minimum value of the box. |'
  prefs: []
  type: TYPE_TB
- en: '| `prefix` | string | A string to prepend to the displayed value. |'
  prefs: []
  type: TYPE_TB
- en: '| `suffix` | string | A string to append to the displayed value. |'
  prefs: []
  type: TYPE_TB
- en: '| `singleStep` | integer | How much to increment or decrement the value when
    the arrows are used. |'
  prefs: []
  type: TYPE_TB
- en: '| `wrapping` | Boolean | Whether to wrap from one end of the range to the other
    when the arrows are used. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s create a `QSpinBox` object in our script, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This spinbox starts with a value of `12` and will allow entry of integers from
    `10` to `100`, displayed in the `$<value> + Tax` format. Note that the non-integer
    portion of the box is not editable. Also note that, while the increment and decrement
    arrows move by `5`, nothing prevents us from entering a value that is not a multiple
    of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QSpinBox` will automatically ignore keystrokes that are not numeric, or that
    would put the value outside the acceptable range. If a value is typed that is
    too low, it will be auto-corrected to a valid value when the focus moves from
    the `spinbox`; for example, if you typed `9` into the preceding box and clicked
    out of it, it would be auto-corrected to `90`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QDoubleSpinBox` is identical to `QSpinBox`, but designed for a decimal or
    floating-point numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: To use `QSpinBox` for discrete text values instead of integers, you need to
    subclass it and override its validation methods. We'll do that later in the *Validating
    widgets* section.
  prefs: []
  type: TYPE_NORMAL
- en: QDateTimeEdit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A close relative of the spinbox is `QDateTimeEdit`, designed for entering date-time
    values. By default, it appears as a spinbox that allows the user to tab through
    each field in the date-time value and increment/decrement it using the arrows.
    The widget can also be configured to use a calendar popup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more useful properties include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | `QDate` or `datetime.date` | The date value. |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | `QTime` or `datetime.time` | The time value. |'
  prefs: []
  type: TYPE_TB
- en: '| `dateTime` | `QDateTime` or `datetime.datetime` | The combined date-time
    value. |'
  prefs: []
  type: TYPE_TB
- en: '| `maximumDate`, `minimumDate` | `QDate` or `datetime.date` | The maximum and
    minimum date enterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `maximumTime`, `minimumTime` | `QTime` or `datetime.time` | The maximum and
    minimum time enterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `maximumDateTime`, `minimumDateTime` | `QDateTime` or `datetime.datetime`
    | The maximum and minimum date-time enterable. |'
  prefs: []
  type: TYPE_TB
- en: '| `calendarPopup` | Boolean | Whether to display the calendar popup or behave
    like a spinbox. |'
  prefs: []
  type: TYPE_TB
- en: '| `displayFormat` | string | How the date-time should be formatted. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s create our date-time box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This date-time widget will be created with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: It will be set to 12:30 on the current date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will show the calendar popup when focused
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will disallow dates after January 1st, 2030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will disallow times after 17:00 (5 PM) on the maximum date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will display date-times in the year-month-day hour-minutes format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `maximumTime` and `minimumTime` only impact the `maximumDate` and
    `minimumDate` values, respectively. So, even though we've specified a maximum
    time of 17:00, nothing prevents you from entering 18:00 as long as it's before
    January 1st, 2030\. The same concept applies to minimum dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The display format for the date-time is set using a string that contains specific
    substitution codes for each item. Some of the more common codes are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Day of the month. |'
  prefs: []
  type: TYPE_TB
- en: '| `M` | Month number. |'
  prefs: []
  type: TYPE_TB
- en: '| `yy` | Two-digit year. |'
  prefs: []
  type: TYPE_TB
- en: '| `yyyy` | Four-digit year. |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Hour. |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | Minute. |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Second. |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | AM/PM, if used, hour will switch to 12-hour time. |'
  prefs: []
  type: TYPE_TB
- en: Day, month, hour, minute, and second all default to omitting the leading zero.
    To get a leading zero, just double up the letter (for example, `dd` for a day
    with a leading zero). A complete list of the codes can be found at [https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all times, dates, and date-times can accept objects from the Python
    standard library''s `datetime` module as well as the Qt types. So, our box could
    just as well have been created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Which one you choose to use is a matter of personal preference or situational
    requirements. For instance, if you are working with other Python modules, the `datetime` standard
    library objects are going to be more compatible. If you just need to set a default
    value for a widget, `QDateTime` may be more convenient, since you likely already
    have `QtCore` imported.
  prefs: []
  type: TYPE_NORMAL
- en: If you need more control over the date and time entry, or just want to split
    these up, Qt has the `QTimeEdit` and `QDateEdit` widgets. They're just like this
    widget, except they only handle time and date, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: QTextEdit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `QLineEdit` exists for single-line strings, `QTextEdit` provides us with
    the capability to enter multi-line text. `QTextEdit` is much more than just a
    simple plaintext entry, though; it's a full-blown WYSIWYG editor that can be configured
    to support rich text and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more useful properties of `QTextEdit` are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `plainText` | string | The contents of the box, in plaintext. |'
  prefs: []
  type: TYPE_TB
- en: '| `html` | string | The contents of the box, as rich text. |'
  prefs: []
  type: TYPE_TB
- en: '| `acceptRichText` | Boolean | Whether the box allows rich text. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineWrapColumnOrWidth` | integer | The pixel or column at which the text
    will be wrapped. |'
  prefs: []
  type: TYPE_TB
- en: '| `lineWrapMode` | `QTextEdit.LineWrapMode` | Whether the line wrap uses columns
    or pixels. |'
  prefs: []
  type: TYPE_TB
- en: '| `overwriteMode` | Boolean | Whether overwrite is activated; `False` means
    insert mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `placeholderText` | string | Text to display when the field is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `readOnly` | Boolean | Whether the field is read-only. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s create a text edit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create a plaintext editor that only allows `25` characters to be typed
    per line, with the phrase `'Enter your text here'` displayed when it's empty.
  prefs: []
  type: TYPE_NORMAL
- en: We'll dig in deeper to the `QTextEdit` and rich text documents in [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml),
    *Creating Rich Text with QTextDocument*.
  prefs: []
  type: TYPE_NORMAL
- en: Placing and arranging widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've created a lot of widgets, but if you run the program you won't
    see any of them. Although our widgets all belong to the parent window, they haven't
    been placed on it yet. In this section, we'll learn how to arrange our widgets
    in the application window and set them to an appropriate size.
  prefs: []
  type: TYPE_NORMAL
- en: Layout classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A layout object defines how child widgets are arranged on a parent widget. Qt
    offers a variety of layout classes, each of which has a layout strategy appropriate
    for different situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow for using layout classes goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a layout object from an appropriate layout class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the layout object to the parent widget's `layout` property using the
    `setLayout()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add widgets to the layout using the layout's `addWidget()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also add layouts to a layout using the `addLayout()` method to create
    more complex arrangements of widgets. Let's take a tour of a few of the basic
    layout classes offered by Qt.
  prefs: []
  type: TYPE_NORMAL
- en: QHBoxLayout and QVBoxLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QHBoxLayout` and `QVBoxLayout` are both derived from `QBoxLayout`, a very
    basic layout engine that simply divides the parent into horizontal or vertical
    boxes and places widgets sequentially as they''re added. `QHBoxLayout` is oriented
    horizontally, and widgets are placed from left to right as added. `QVBoxLayout`
    is oriented vertically, and widgets are placed from top to bottom as added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try `QVBoxLayout` on our `MainWindow` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the layout object exists, we can start adding our widgets to it using
    the `addWidget()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if you run the program, the widgets are added one per line.
    If we wanted to add several widgets to a single line, we could nest a layout inside
    our layout, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a horizontal layout to the next cell of our main vertical
    layout and then inserted three more widgets to the sub-layout. These three widgets
    display side by side in a single line of the main layout. Most application layouts
    can be accomplished by simply nesting box layouts in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: QGridLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nested box layouts cover a lot of ground, but in some situations, you might
    like to arrange widgets in uniform rows and columns. This is where `QGridLayout`
    comes in handy. As the name suggests, it allows you to place widgets in a table-like
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a grid layout object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding widgets to `QGridLayout` is similar to the method for the `QBoxLayout`
    classes, but also requires passing coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the arguments for `QGridLayout.addWidget()`, in order:'
  prefs: []
  type: TYPE_NORMAL
- en: The widget to add
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The row number (vertical coordinate), starting from `0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The column number (horizontal coordinate), starting from `0`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The row span, or how many rows the widget will encompass (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The column span, or how many columns the widget will encompass (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, our `spinbox` widget is placed at row `0`, column `0`, which is the top
    left; our `datetimebox` at row `0`, column `1`, which is the top right; and our
    `textedit` at row `1`, column `0`, and it spans two rows and two columns.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the grid layout keeps consistent widths on all columns and
    consistent heights on all rows. Thus, if you place a very wide widget in row `2`,
    column `1`, all widgets in all rows that happen to be in column `1` will be stretched
    accordingly. If you want each cell to stretch independently, use nested box layouts
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: QFormLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating data-entry forms, it's common to have labels next to the input
    widgets they label. Qt provides a convenient two-column grid layout for this situation
    called `QFormLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a form layout to our GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding widgets can be easily done with the `addRow()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This convenience method takes a string and a widget and automatically creates
    the `QLabel` widget for the string. If passed only a single widget (such as a
    `QLabel`), the widget spans both columns. This can be useful for headings or section
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: '`QFormLayout` is not just a mere convenience over `QGridLayout`, it also automatically
    provides idiomatic behavior when used across different platforms. For example,
    when used on Windows, the labels are left-justified; when used on macOS, the labels
    are right-justified, keeping with the design guidelines of the platform. Additionally,
    when viewed on a narrow screen (such as a mobile device), the layout automatically
    collapses to a single column with the labels above the input. It''s definitely
    worthwhile to use this layout any time you have a two-column form.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling widget size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run our demo as it currently is and expand it to fill your screen, you''ll
    notice that each cell of the main layout gets evenly stretched to fill the screen,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b113c24-8f5f-4608-a786-8a0e4d6b40bd.png)'
  prefs: []
  type: TYPE_IMG
- en: This isn't ideal. The label at the top really doesn't need to be expanded, and
    there is a lot of wasted space at the bottom. Presumably, if a user were to expand
    this window, they'd do so to get more space in input widgets like our `QTextEdit`.
    We need to give the GUI some guidance on how to size our widgets, and how to resize
    them in the event that the window is expanded or shrunk from its default size.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the size of widgets can be a bit perplexing in any toolkit, but
    Qt's approach can be especially confusing, so let's take it one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply set a fixed size for any widget using its `setFixedSize()` method,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`setFixedSize` accepts only pixel values, and a widget set to a fixed size
    cannot be altered from those pixel sizes under any circumstances. The problem
    with sizing a widget this way is that it doesn''t account for the possibility
    of different fonts, different text sizes, or changes to the size or layout of
    the application window, which might result in the widget being too small for its
    contents, or needlessly large. We can make it slightly more flexible by setting `minimumSize`
    and `maximumSize`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code and resize the window, you'll notice `line_edit` has a
    bit more flexibility as the window expands and contracts. Note, however, that
    the widget won't shrink below its `minimumSize`, but it won't necessarily use
    its `maximumSize`, even if the room is available.
  prefs: []
  type: TYPE_NORMAL
- en: So, this is still far from ideal. Rather than concern ourselves with how many
    pixels each widget consumes, we'd prefer it be sized sensibly and fluidly with
    respect to its contents and role within the interface. Qt does just this using
    the concepts of *size hints* and *size polices*.
  prefs: []
  type: TYPE_NORMAL
- en: A size hint is a suggested size for a widget and is returned by the widget's
    `sizeHint()` method. This size may be based on a variety of dynamic factors; for
    example, the `QLabel` widget's `sizeHint()` value depends on the length and wrap
    of the text it contains. Because it's a method and not a property, setting a custom
    `sizeHint()` for a widget requires you to subclass the widget and reimplement
    the method. Fortunately, this isn't something we often need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'A size policy defines how the widget responds to a resizing request with respect
    to its size hint. This is set as the `sizePolicy` property of a widget. Size policies
    are defined in the `QtWidgets.QSizePolicy.Policy` enum, and set separately for
    the horizontal and vertical dimensions of a widget using the `setSizePolicy` accessor
    method. The available policies are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Policy | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fixed | Never grow or shrink. |'
  prefs: []
  type: TYPE_TB
- en: '| Minimum | Don''t get smaller than `sizeHint`. Expanding isn''t useful. |'
  prefs: []
  type: TYPE_TB
- en: '| Maximum | Don''t get larger than `sizeHint`, shrink if necessary. |'
  prefs: []
  type: TYPE_TB
- en: '| Preferred | Try to be `sizeHint`, but shrink if necessary. Expanding isn''t
    useful. This is the default. |'
  prefs: []
  type: TYPE_TB
- en: '| Expanding | Try to be `sizeHint`, shrink if necessary, but expand if at all
    possible. |'
  prefs: []
  type: TYPE_TB
- en: '| MinimumExpanding | Don''t get smaller than `sizeHint`, but expand if at all
    possible. |'
  prefs: []
  type: TYPE_TB
- en: '| Ignored | Forget `sizeHint` altogether, just take up as much space as possible.
    |'
  prefs: []
  type: TYPE_TB
- en: 'So, for example, if we''d like the spinbox to stay at a fixed width so the
    widget next to it can expand, we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we''d like our `textedit` widget to fill as much of the screen as possible,
    but never shrink below its `sizeHint()` value, we should set its policies like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Sizing widgets can be somewhat unpredictable when you have deeply-nested layouts;
    sometimes it''s handy to be able to override `sizeHint()`. In Python, a quick
    way to do this is with Lambda functions, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that `sizeHint()` must return a `QtCore.QSize` object, not just an integer
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: A final way to control the size of widgets when using a box layout is to set
    a `stretch` factor when adding the widget to the layout. Stretch is an optional
    second parameter of `addWidget()` that defines the comparative stretch of each
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows the use of the `stretch` factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`stretch` only works with the `QHBoxLayout` and `QVBoxLayout` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've added a line edit with a stretch factor of `1`, and a
    second with a stretch factor of `2`. When you run this, you'll find that the second
    line edit is about twice the length of the first.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that stretch doesn't override the size hint or size policies, so
    depending on those factors the stretch ratios may not be exactly as specified.
  prefs: []
  type: TYPE_NORMAL
- en: Container widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that we can use `QWidget` as a container for other widgets. Qt
    also provides us with some special widgets that are specifically designed to contain
    other widgets. We'll look at two of these: `QTabWidget` and `QGroupBox`.
  prefs: []
  type: TYPE_NORMAL
- en: QTabWidget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTabWidget`, sometimes known as a **notebook widget** in other toolkits, allows
    us to have multiple *pages* selectable by tabs. They''re very useful for breaking
    complex interfaces into smaller chunks that are easier for users to take in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow for using `QTabWidget` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `QTabWidget` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a UI page on a `QWidget` or other widget class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the page to the tab widget using the `QTabWidget.addTab()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try that; first, create the tab widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s move the `grid_layout` we built under the *Placing and arranging
    widgets* section to a container widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add our `container` widget to a new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to `addTab()` is the title text that will appear on the
    tab. Subsequent tabs can be added with more calls to `addTab()`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `insertTab()` method can also be used to add new tabs somewhere other than
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: '`QTabWidget` has a few properties we can customize, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Arguments | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `movable` | Boolean | Whether the tabs can be reordered. The default is `False`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tabBarAutoHide` | Boolean | Whether the tab bar is hidden or shown when
    there is only one tab. |'
  prefs: []
  type: TYPE_TB
- en: '| `tabPosition` | `QTabWidget.TabPosition` | Which side of the widget the tabs
    appear on. The default is North (top). |'
  prefs: []
  type: TYPE_TB
- en: '| `tabShape` | `QTabWidget.TabShape` | The shape of the tabs. It can be rounded
    or triangular. |'
  prefs: []
  type: TYPE_TB
- en: '| `tabsClosable` | Boolean | Whether to display a close button on the tabs.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `useScrollButtons` | Boolean | Whether to use scroll buttons when there are
    many tabs or to expand. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s amend our `QTabWidget` to have movable, triangular tabs on the left
    side of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`QStackedWidget` is similar to the tab widget, except that it contains no built-in
    mechanism for switching pages. You may find it useful if you want to build your
    own tab-switching mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: QGroupBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QGroupBox` provides a panel that is labeled and (depending on the platform
    style) bordered. It''s useful for grouping related input together on a form. We
    create the `QGroupBox` just as we would create a `QWidget` container, except that
    it can have a border and a title for the box, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a group box with the `Buttons` title. We gave it a horizontal
    layout and added two button widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in this example, instead of giving the layout a handle of its own as
    we've been doing, we create an anonymous `QHBoxLayout` and then use the widget's
    `layout()` accessor method to retrieve a reference to it for adding widgets. You
    may prefer this approach in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The group box is fairly simple, but it does have a few interesting properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Argument | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `title` | string | The title text. |'
  prefs: []
  type: TYPE_TB
- en: '| `checkable` | Boolean | Whether the groupbox has a checkbox to enable/disable
    its contents. |'
  prefs: []
  type: TYPE_TB
- en: '| `checked` | Boolean | Whether a checkable groupbox is checked (enabled).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `alignment` | `QtCore.Qt.Alignment` | The alignment of the title text. |'
  prefs: []
  type: TYPE_TB
- en: '| `flat` | Boolean | Whether the box is flat or has a frame. |'
  prefs: []
  type: TYPE_TB
- en: The `checkable` and `checked` properties are very useful for situations where
    you want a user to be able to disable entire sections of a form (for example,
    to disable the billing address part of an order form if it's the same as shipping
    address).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reconfigure our `groupbox`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice that now the buttons can be disabled with a simple checkbox toggle, and
    the frame has a different look.
  prefs: []
  type: TYPE_NORMAL
- en: If you just want a bordered widget without a label or checkbox capabilities,
    the `QFrame` class might be a better alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Validating widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Qt provides a wide range of ready-made input widgets for things such
    as dates and numbers, we may find sometimes that we need a widget with very specific
    constraints on its input values. Such input constraints can be created using the
    `QValidator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom validator class by subclassing `QtGui.QValidator`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `validate()` method with our validation logic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign an instance of our custom class to a widget's `validator` property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once assigned to an editable widget, the `validate()` method will be called
    every time the user updates the value of the widget (for example, every keystroke
    in `QLineEdit`) and will determine whether the input is accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IPv4 entry widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate widget validation, let's create a widget that validates **Internet
    Protocol version 4** (**IPv4**) addresses. An IPv4 address must be in the format
    of 4 integers, each between `0` and `255`, with a dot between each number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating our validator class. Add this class just before the
    `MainWindow` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to override this class''s `validate()` method. `validate()` receives
    two pieces of information: a string that contains the proposed input and the index
    at which the input occurred. It will have to return a value that indicates whether
    the input is `Acceptable`, `Intermediate`, or `Invalid`. If the input is acceptable
    or intermediate, it will be accepted. If it''s invalid, it will be rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: The value used to indicate the input state is either `QtValidator.Acceptable`,
    `QtValidator.Intermediate`, or `QtValidator.Invalid`.
  prefs: []
  type: TYPE_NORMAL
- en: In the Qt documentation, we're told that the validator class should only return
    the state constant. In PyQt, however, you actually need to return a tuple that
    contains the state, the string, and the position. This doesn't seem to be well-documented,
    unfortunately, and the error if you should forget this is not intuitive at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start building our IPv4 validation logic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Split the string on the dot character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are more than `4` segments, the value is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If any populated segment is not a digit string, the value is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If not every populated segment can be converted into an integer between 0 and
    255, the value is invalid:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''ve made it this far into the checks, the value is either intermediate
    or valid. If there are fewer than four segments, it''s intermediate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are any empty segments, the value is intermediate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value has passed all these tests, it''s acceptable. We can return our
    tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this validator, we just need to create an instance of it and assign
    it to a widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you run the demo now, you'll see that the line edit now constrains you to
    a valid IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: Using QSpinBox for discrete values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned earlier under the *Creating basic QtWidgets widgets* section,
    `QSpinBox` can be used for discrete lists of string values, much like a combobox.
    `QSpinBox` has a built-in `validate()` method that works just like the `QValidator`
    class' method to constrain input to the widget. To make a spinbox use discrete
    string lists, we need to subclass `QSpinBox` and override `validate()` and two
    other methods, `valueFromText()` and `textFromValue()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a custom spinbox class that can be used to choose items from
    a list; just before the `MainWindow` class, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We're subclassing `qtw.QSpinBox` and overriding the constructor so that we can
    pass in a list or tuple of choices, storing it as `self.choices`. Then we call
    the `QSpinBox` constructor; note that we set the `maximum` and `minimum` so that
    they can't be set outside the bounds of our choices. We're also passing along
    any extra positional or keyword arguments so that we can take advantage of all
    the other `QSpinBox` property settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s reimplement `valueFromText()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this method is to be able to return an integer index value given
    a string that matches one of the displayed choices. We're simply returning the
    list index of whatever string is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to reimplement the complimentary method, `textFromValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this method is to translate an integer index value into the text
    of the matching choice. In this case, we're just returning the string at the given
    index. If somehow the widget gets passed a value out of range, we're returning
    `!Error!` as a string. Since this method is used to determine what is displayed
    in the box when a particular value is set, this would clearly show an error condition
    if somehow the value were out of range.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to take care of `validate()`. Just as we did with our `QValidator`
    class, we need to create a method that takes the proposed input and edit index
    and returns a tuple that contains the validation state, string value, and index.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll code it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In our method, we're returning `Acceptable` if the input string is found in
    `self.choices`, `Intermediate` if any choice starts with the input string (this
    includes a blank string), or `Invalid` in any other case.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this class created, we can create one of our widgets in our `MainWindow`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: An important difference between a `QComboBox` object and a `QSpinBox` object
    with text options is that the spinbox items lack a `data` property. Only the text
    or index can be returned. It's best used for things such as months, days of the
    week, or other sequential lists that translate meaningfully into integer values.
  prefs: []
  type: TYPE_NORMAL
- en: Building a calendar application GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to put what we''ve learned into action and actually build a simple,
    functional GUI. Our goal is to build a simple calendar application that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e7ff923c-5442-4c41-ba36-c81f7435b740.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our interface won''t be functional yet; for now, we''ll just focus on getting
    the components created and laid out as shown in the screenshot. We''ll do this
    two ways: once using code only, and a second time using Qt Designer.'
  prefs: []
  type: TYPE_NORMAL
- en: Either of these methods is valid and work fine, though as you'll see, each has
    advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file called `calendar_form.py` by copying the application template
    from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we''ll configure our main window; in the `MainWindow` constructor, begin
    with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This code will set our window title to something appropriate and set a fixed
    size for our window of 800 x 600\. Note that this is just the initial size, and
    the user will be able to resize the form if they wish to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create all of our widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all of the widgets we will be using in our GUI. Most of these we
    have covered already, but there are two new ones: `QCalendarWidget` and `QListWidget`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QCalendarWidget` is exactly what you''d expect it to be: a fully interactive
    calendar that can be used to view and select dates. Although it has a number of
    properties that can be configured, for our needs the default configuration is
    fine. We''ll be using it to allow the user to select the date to be viewed and
    edited.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QListWidget` is for displaying, selecting, and editing items in a list. We''re
    going to use it to show a list of events saved on a particular day.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, we need to configure our `event_category` combo box with
    some items to select. Here''s the plan for this box:'
  prefs: []
  type: TYPE_NORMAL
- en: Have it read `Select category…` as a placeholder when nothing is selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include an option called `New…` which might perhaps allow the user to enter
    a new category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include some common categories by default, such as `Work`, `Meeting`, and `Doctor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`QComboBox` doesn''t really have placeholder text, so we''re using a trick
    here to simulate it. We''ve added our combo box items using the `addItems()` method
    as usual. Next, we retrieve its data model using the `model()` method, which returns
    a `QStandardItemModel` instance. The data model holds a list of all the items
    in the combo box. We can use the model''s `item()` method to access the actual
    data item at a given index (in this case `0`) and use its `setEnabled()` method
    to disable it.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, we've simulated placeholder text by disabling the first entry in the
    combo box.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn more about widget data models in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Creating Data Interfaces with Model-View Classes.*
  prefs: []
  type: TYPE_NORMAL
- en: Building the layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our form is going to require some nested layouts to get everything into position.
    Let''s break down our proposed design and determine how to create this layout:'
  prefs: []
  type: TYPE_NORMAL
- en: The application is divided into a calendar on the left and a form on the right.
    This suggests using `QHBoxLayout` for the main layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form on the right is a vertical stack of components, suggesting we use `QVBoxLayout`
    to arrange things on the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event form at the bottom right can be laid out roughly in a grid so we could
    use `QGridLayout` there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll begin by creating the main layout and adding in the calendar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the calendar widget to fill any extra space in the layout, so we''ll
    set its size policy accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the vertical layout on the right, and add the label and
    event list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that there''s more vertical space, we''d like the event list to
    fill all the available space. So, let''s set its size policy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The next part of our GUI is the event form and its label. We could use another
    label here, but the design suggests that these form fields are grouped together
    under this heading so `QGroupBox` would be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a group box with `QGridLayout` to hold our event form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add in our remaining widgets into the grid layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We're dividing our grid into three columns, and using the optional column-span
    argument to put our title and detail fields across all three columns.
  prefs: []
  type: TYPE_NORMAL
- en: And now we're done! At this point, you can run the script and see your completed
    form. It doesn't do anything yet, of course, but that is a topic for our [Chapter
    3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with Signals
    and Slots*.
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI in Qt Designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try building the same GUI, but this time we'll build it using Qt Designer.
  prefs: []
  type: TYPE_NORMAL
- en: First steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, launch Qt Designer as described in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, then create a new form based on a widget, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eda1e482-5f33-4176-a699-f3da3c3f43a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the Widget and we''ll configure its properties using the Properties
    panel on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the object name to `MainWindow`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Geometry**, change the Width to `800` and Height to `600`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the window title to `My Calendar App`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we''ll start adding in the widgets. Scroll through the widget box on
    the left to find the **Calendar Widget**, then drag it onto the main window. Select
    the calendar and edit its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the name to `calendar`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the horizontal and vertical size policies to `Expanding`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To set up our main layout, right-click the main window (not on the calendar)
    and select Layout | **Lay Out Horizontally**. This will add a `QHBoxLayout` to
    the main window widget. Note that you can't do this until at least one widget
    is on the main window, which is why we added the calendar widget first.
  prefs: []
  type: TYPE_NORMAL
- en: Building the right panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we''ll add the vertical layout for the right side of the form. Drag a
    Vertical Layout to the right of the calendar widget. Then drag a Label Widget
    into the vertical layout. Make sure the label is listed hierarchically as a child
    of the vertical layout, not a sibling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba44242d-5956-4cd8-9e1a-492662eec464.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are having trouble dragging the widget onto the unexpanded layout, you
    can also drag it into the hierarchy in the **Object Inspector** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the text on the label and change it to say Events on Date.
  prefs: []
  type: TYPE_NORMAL
- en: Next, drag a List Widget onto the vertical layout so that it appears under the
    label. Rename it `event_list` and check its properties to make sure its size policies
    are set to `Expanding`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the event form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find the Group Box in the widget box and drag it under the list widget. Double-click
    the text and change it to `Event`.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a Line Edit onto the group box, making sure it shows up as a child of the
    group box in the Object Inspector. Change the object name to `event_title`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, right-click the group box and select Lay out, then select **Lay out in
    a Grid**. This will create a grid layout in the group box.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a Combo Box onto the next line. Drag a Time Edit to the right of it, then
    a Check Box to the right of that. Name them `event_category`, `event_time`, and
    `allday_check`, respectively. Double-click the checkbox text and change it to
    `All Day`.
  prefs: []
  type: TYPE_NORMAL
- en: To add options to the combo box, right-click the box and select **Edit Items**.
    This will open a dialog where we can type in our items, so click the + button
    to add `Select Category…` like the first one, then `New…`, then a few random categories
    (such as `Work`, `Doctor`, `Meeting`).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can't disable the first item using Qt Designer. We'll have
    to handle that when we use our form in an application, which we'll discuss in
    [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling Events with
    Signals and Slots*.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that adding those three widgets pushed the line edit over to the right.
    We need to fix the column span on that widget. Click the line edit, grab the handle
    on the right edge, and drag it right until it expands to the width of the group
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Now, grab a Text Edit and drag it under the other widgets. Notice that it's
    squashed into the first column, so just as with the line edit, drag it right until
    it fills the whole width. Rename the text edit to `event_detail`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, drag two Push Button widgets to the bottom of the form. Make sure to
    drag them to the second and third columns, leaving the first column empty. Rename
    them `add_button` and `del_button`, changing the text to `Add/Update` and `Delete`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Previewing the form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Save the form as `calendar_form.ui`, then press *Ctrl* + *R* to preview it.
    You should see a fully functional form, just as shown in the original screenshot.
    To actually use this file, we'll have to transpile it to Python code and import
    it into an actual script. We'll cover this in [Chapter 3](dbb86a9b-0050-490e-94da-1f4661d8bc66.xhtml), *Handling
    Events with Signals and Slots*, after we've made some additional modifications
    to the form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a selection of the most popular widget classes in
    Qt. You learned how to create them, customize them, and add them to a form. We
    discussed various ways to control widget sizes and practiced building a simple
    application form in both Python code and the Qt Designer WYSIWYG application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to make this form actually do something
    as we explore Qt's core communication and event-handling system. Keep your calendar
    form handy, as we'll modify it some more and make a functional application from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a `QWidget` that is fullscreen, has no window frame, and
    uses the hourglass cursor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''re asked to design a data-entry form for a computer inventory database.
    Choose the best widget to use for each of the following fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Computer make**: One of eight brands that your company purchases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processor Speed**: The CPU speed in GHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory amount**: The amount of RAM, in whole MB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host Name**: The computer''s hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Video make**: Whether the video hardware is Nvidia, AMD, or Intel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OEM License**: Whether the computer uses an **Original Equipment Manufacturer**
    (**OEM**) license'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data entry form includes an `inventory number` field that requires the `XX-999-9999X` format
    where `X` is an uppercase letter from `A` to `Z`, excluding `O` and `I`, and `9`
    is a number from `0` to `9`. Can you create a validator class to validate this
    input?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the following calculator form—what layouts may have been used to create
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1b7c100d-6694-48e8-8bc0-e15dc8c0aba7.png)'
  prefs: []
  type: TYPE_IMG
- en: Referring to the preceding calculator form, how would you make the button grid
    take up any extra space when the form is resized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The topmost widget in the calculator form is a `QLCDNumber` widget. Can you
    find the Qt documentation on this widget? What unique properties does it have?
    When might you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting with your template code, build the calculator form in code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the calculator form in Qt Designer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following resources for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QWidget` properties documentation lists all the properties for `QWidget`,
    which are inherited by all its child classes, at [https://doc.qt.io/qt-5/qwidget.html#properties](https://doc.qt.io/qt-5/qwidget.html#properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Qt` namespace documentation lists many of the global enums used in Qt at [https://doc.qt.io/qt-5/qt.html#WindowState-enum](https://doc.qt.io/qt-5/qt.html#WindowState-enum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt layout management tutorial provides detailed information on layouts and
    sizing at [https://doc.qt.io/qt-5/layout.html](https://doc.qt.io/qt-5/layout.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QDateTime` documentation provides more information about working with dates
    and times in Qt at [https://doc.qt.io/qt-5/qdatetime.html](https://doc.qt.io/qt-5/qdatetime.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about `QCalendarWidget` can be found at [https://doc.qt.io/qt-5/qcalendarwidget.html](https://doc.qt.io/qt-5/qcalendarwidget.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
