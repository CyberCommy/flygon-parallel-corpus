- en: Working with Application Logic and Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from a remote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a remote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing real-time communication with WebSockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating persistent database functionality with Realm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking the application upon network connection loss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing locally persisted data with a remote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important aspects of developing any application is handling
    data. This data may come locally from the user, may be served by a remote server
    that exposes an API, or, as with most business applications, may be some combination
    of both. You may be wondering what strategies are best for dealing with data,
    or how to even accomplish simple tasks such as making an HTTP request. Luckily,
    React Native makes your life that much simpler by providing mechanisms for easily
    dealing with data from all different sources.
  prefs: []
  type: TYPE_NORMAL
- en: The open source community has taken things a step further and provided some
    excellent modules that can be used with React Native. In this chapter, we will
    discuss how to work with data in all aspects, and how it integrates into our React
    Native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving data locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a mobile app, we need to consider the network challenges that
    need to be overcome. A well-designed app should allow the user to continue using
    the app when there is no internet connection. This requires the app to save data
    locally on the device when there's no internet connection, and to also sync that
    data with the server when the network is available again.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge to overcome is network connectivity, which might be slow or
    limited. To improve the performance of our app, we should save critical data on
    the local device to avoid putting stress on our server API.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn about a basic and effective strategy for saving
    and retrieving data locally from the device. We will create a simple app with
    a text input and two buttons, one to save the content of the field and one to
    load the existing content. We will use the `AsyncStorage` class to achieve our
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app named `local-data-storage`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin with the `App` component. Let''s start by importing all of the
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `App` class. We are going to create a `key` constant
    so that we can set the name of the key we will use to save the content. On the
    `state`, we''ll have two properties: one to keep the value from the text input
    component, and another to load and display the currently stored value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component mounts, we want to load the existing stored value if it
    exists. We''ll display the content once the app loads, so we''ll need to read
    the local value in the `componentWillMount` life cycle method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLoad` function loads the current content from the local storage. Like
    `localStorage` in the browser, it''s as easy as using the key we defined when
    saving the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving the data is straightforward as well. We''ll declare a key to save any
    data we want to associate with that key, via the `setItem` method of `AsyncStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a function for saving the value from the input text to the `state`.
    When the value of the input changes, we will get the new value and save it to
    the `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our UI will be simple: just a `Text` element to render the saved content, a
    `TextInput` component to allow the user to enter a new value, and two buttons.
    One button will call the `onLoad` function to load the current saved value, and
    the other will save the value from the text input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add some styles. This will be simple colors, paddings, margins,
    and a layout, as covered in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml),
    *Creating a Simple React Native App*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1e7aa953-2b8d-4c6c-be09-463c40c90198.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AsyncStorage` class allows us to easily save data on the local device.
    On iOS, this is accomplished by using dictionaries on text files. On Android,
    it will use RocksDB or SQLite, depending on what's available.
  prefs: []
  type: TYPE_NORMAL
- en: It's not recommended to save sensitive information using this method, as the
    data is not encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we loaded the current saved data. The `AsyncStorage` API contains
    a `getItem` method. This method receives the key we want to retrieve as a parameter.
    We are using the `await`/`async` syntax here since this call is asynchronous.
    After we get the value, we just set it to `state`; this way, we will be able to
    render the data on the view.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 7*, we saved the text from the `state`. Using the `setItem` method,
    we can set a new `key` with any value we want. This call is asynchronous, therefore
    we used the `await`/`async` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great article on how `async`/`await` in JavaScript works, available at [https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await).
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from a remote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters we used data from a JSON file or directly defined in
    the source code. While that worked for our previous recipes, it's rarely very
    helpful in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to request data from an API. We will make
    a `GET` request from an API to get a JSON response. For now, however, we are only
    going to display the JSON in a text element. We'll be using the Fake Online REST
    API for Testing and Prototyping, hosted at [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com) and
    powered by the excellent development test API software, JSON Server ([https://github.com/typicode/json-server](https://github.com/typicode/json-server)).
  prefs: []
  type: TYPE_NORMAL
- en: We will keep this app simple so that we can focus on data management. We will
    have a text component that will display the response from the API and also add
    a button that requests the data when pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app. Let's name this one `remote-api`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by importing our dependencies into the `App.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to define a `results` property on the `state`. This property will
    hold the response from the API. We''ll need to update the view once we get the
    response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll send the request when the button is pressed. Next, let''s create a method
    to handle that request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` method, we''ll display the response, which will be read from
    the `state`. We will use a `TextInput` to display the API data. Via properties,
    we''ll declare editing as disabled and support multiline functionality. The button
    will call the `onLoad` function that we created in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add some styles. Again, this will just be the layout, colors,
    margins, and padding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9374a894-a2e5-4de5-89a2-84ab98ecfb23.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we sent the request to the API. We use the `fetch` method to make
    the request. The first parameter is a string with the URL of the endpoint, while
    the second parameter is a configuration object. For this request, the only option
    we need to define is the `request` method to `GET`, but we can also use this object
    to define headers, cookies, parameters, and many other things.
  prefs: []
  type: TYPE_NORMAL
- en: We are also using `async`/`await` syntax to wait on the response and finally
    set it on the `state`. If you prefer, you could, of course, use promises for this
    purpose instead.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note how we are using an arrow function here to properly handle the scope.
    This will automatically set the correct scope when this method is assigned to
    the `onPress` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to a remote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we covered how to get data from an API using `fetch`.
    In this recipe, we will learn how to `POST` data to the same API. This app will
    emulate creating a forum post, and the request for the post will have `title`,
    `body`, and `user` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going through this recipe, we need to create a new empty app named `remote-api-post`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will also be using the very popular `axios` package for
    handling our API requests. You can install it via the Terminal with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll need to open the `App.js` file and import the dependencies we''ll
    be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll define the `App` class with a `state` object that has three properties.
    The `title` and `body` properties will be used for making the request, and `results`
    will hold the API''s response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving a new post, we will request all of the posts from the API. We
    are going to define an `onLoad` method to fetch the new data. This code works
    just the same as the `onLoad` method in the previous recipe, but this time, we''ll
    be using the `axios` package to create the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s work on saving the new data. First, we need to get the values from the
    `state`. We could also run some validations here to make sure that the `title`
    and `body` are not empty. On the `POST` request, we need to define the content
    type of the request, which, in this case, will be JSON. We will hard code the
    `userId` property to `1`. In a real app, we would have probably gotten this value
    from a previous API request. After the request has completed, we get the JSON
    response, which, if successful, will fire the `onLoad` method that we defined
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The save functionality is complete. Next, we need methods for saving the `title`
    and `body` to the `state`. These methods will be executed as the user types in
    the input text, keeping track of the values on the `state` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have everything we need for the functionality, so let''s add the UI. The
    `render` method will display a toolbar, two input texts, and a Save button for
    calling the `onSave` method that we defined in *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the styles to define the layout, color, padding, and margins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/52d9a6cb-2df6-4112-be62-3f1e3431970b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we defined three properties on the `state`. The `results` property
    will contain the response from the server API, which we later use to display the
    value in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `title` and `body` properties to hold the values from the input
    text components so that the user can create a new post. Those values will then
    be sent to the API when pressing the Save button.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we declared the elements on the UI. We used two inputs for post
    data and the Save button, which calls the `onSave` method when pressed. Finally,
    we used input text to display the result.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing real-time communication with WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will integrate WebSockets in a React Native application.
    We are going to use the *Hello World* of WebSockets applications, that is, a simple
    chat app. This app will allow users to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To support WebSockets on React Native, we will need to run a server to handle
    all connected clients. The server should be able to broadcast a message when it
    receives a message from any of the connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a new, empty React Native app. We'll name it `web-sockets`. In
    the root of the project, let's add a `server` folder with an `index.js` file inside
    of it. If you don't already have it, you'll need Node to run the server. You can
    get Node.js from [https://nodejs.org/](https://nodejs.org/) or by using the Node
    Version Manager ([https://github.com/creationix/nvm](https://github.com/creationix/nvm)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using the excellent WebSocket package, `ws`. You can add the package
    via the Terminal with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve got the package installed, add the following code to the `/server/index.js`
    file. Once this server is running, it will listen for incoming connections via
    `server.on(''connection'')` and incoming messages via `socket.on(''message'')`.
    For more information on how `ws` works, you can check out the documentation at [https://github.com/websockets/ws](https://github.com/websockets/ws):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server code is in place, you can start up the server using Node by
    running the following command in the Terminal at the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Leave the server running so that, once we've built the React Native app, we
    can use the server to communicate between clients.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create the `App.js` file and import all the dependencies we''ll
    be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `state` object, we''ll declare a `history` property. This property will
    be an array for holding all of the messages that have been sent back and forth
    between users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to integrate WebSockets into our app by connecting to the server
    and setting up the callback functions for receiving messages, errors, and when
    the connection is opened or closed. We will do this when the component has been
    created, by using the `componentWillMount` life cycle hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the callbacks for opened/closed connections and for handling
    received errors. We are just going to log the actions, but this is where we could
    show an alert message when the connection is closed, or display an error message
    when an error is thrown by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When receiving a new message from the server, we need to add it to the `history` property
    on the `state` so that we can render the new content as soon as it arrives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on to sending the message. We need to define a method that will get executed
    when the user presses the *Return* key on the keyboard. We need to do two things
    at this point: add the new message to `history`, and then send the message through
    the socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous step, we got the `text` property from the `state`. We need
    to keep track of the value whenever the user types something into the input, so
    we''ll need a function for listening to keystrokes and saving the value to `state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have all of the functionality in place, so let''s work on the UI. In the
    `render` method, we''ll add a toolbar, a scroll view to render all of the messages
    in `history`, and a text input to allow the user to send a new message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the messages from `history`, we''ll loop through the `history` array
    and render each message via the `renderMessage` method. We''ll need to check whether
    the current message belongs to the user on this device so that we can apply the
    appropriate styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s work on the styles! Let''s add styles to the toolbar, the `history`
    component, and the text input. We need to set the `history` container as flexible,
    since we want it to take up all of the available vertical space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on to the styles for each message. We are going to create a common styles
    object called `msg` for all messages, then styles for messages from the user on
    the device, and finally, styles for messages from others, changing the color and
    alignment accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The final app should look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/71f2d573-5ccf-46f4-828f-89463af001bb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 2*, we declared the `state` object with a `history` array for keeping
    track of messages. The `history` property will hold objects representing all of
    the messages being exchanged between clients. Each object will have two properties:
    a string with the message text, and a Boolean flag to determine the sender. We
    could add more data here, such as the name of the user, a URL of the avatar image,
    or anything else we might need.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we connected to the socket provided by the WebSocket server and
    set up callbacks for handling socket events. We specified the server address as
    well as the port.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined the callback to execute when a new message is received
    from the server. Here, we add a new object to the `history` array on the `state` every
    time a new message is received. Each message object has the properties `isSentByMe` and
  prefs: []
  type: TYPE_NORMAL
- en: '`messageText`.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we sent the message to the server. We need to add the message to
    the history because the server will broadcast the message to all other clients,
    but not the author of the message. To keep track of this message, we need to manually
    add it to the history.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating persistent database functionality with Realm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application becomes more complex, you will likely reach a point where
    you need to store data on the device. This could be business data, such as user
    lists, to avoid having to make expensive network connections to a Remote API.
    Maybe you don't have an API at all and your application works as a self-sufficient
    entity. Regardless of the situation, you may benefit from leveraging a database
    to store your data. There are multiple options for React Native applications.
    The first option is `AsyncStorage`, which we covered in the *Storing and retrieving
    data locally* recipe in this chapter. You could also consider SQLite, or you could
    write an adapter to an OS-specific data provider, such as Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: Another excellent option is using a mobile database, such as Realm. Realm is
    an extremely fast, thread-safe, transactional, object-based database. It is primarily
    designed for use by mobile devices, with a straightforward JavaScript API. It
    supports other features, such as encryption, complex querying, UI bindings, and
    more. You can read all about it at [https://realm.io/products/realm-mobile-database/](https://realm.io/products/realm-mobile-database/).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will walk through using Realm in React Native. We will create
    a simple database and perform basic operations, such as inserting, updating, and
    deleting records. We will then display these records in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a new empty React Native app named `realm-db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Realm requires running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of this, we will be working on an app that is ejected from Expo. This
    means that you could create this app with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could create a new Expo app with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can eject the app that was created with Expo via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve created a React Native app, be sure to install the CocoaPods dependencies
    via the `ios` directory by using `cd` inside the new app and running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Refer to Chapter 10, *App Workflow and Third-party Plugins*, for a in-depth
    explanation of how CocoaPods works, and how ejected (or pure React Native) applications
    differ from Expo React Native applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Sending data to a remote API* recipe, we handled our AJAX calls with
    the `axios` package. In this recipe, we will be using the native JavaScript `fetch`
    method for AJAX calls. Either method works just as well, and having exposure to
    both will hopefully allow you to decide which you prefer for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve taken care of creating an ejected app, install Realm with `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With the package installed, you can link the native packages with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s open `App.js` and import the dependencies we''ll be using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to instantiate our Realm database, which we''ll do in the `componentWillMount`
    method. We''ll keep a reference to it by using the `realm` class variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `User` entries, we will use the random user generator API provided
    by [randomuser.me](http://randomuser.me). Let''s create a method with the `getRandomUser`
    function. This will `fetch` this data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a method for creating users in our app. The `createUser` method
    will use the function we defined previously to get a random user, before saving
    it to our realm database with the `realm.write` method and the `realm.create`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re interacting with a database, we should also add a function for
    updating a `User` in the database. `updateUser` will, for simplicity, take the
    first record in the collection and change its information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add a way to delete our users. We''ll add a `deleteUsers` method
    for removing all users. This is achieved by calling `realm.write` with a callback
    function that executes `realm.deleteAll`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build our UI. We will render a list of `User` objects and a button for
    each of our `create`, `update`, and `delete` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run the app on either platform, our three buttons for interacting with
    the database should display over the live data that''s saved in our Realm database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/8b14a014-e823-46b5-bf7d-34ba1de2733d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Realm database is built in C++ and its core is known as the **Realm Object
    Store**. There are products that encapsulate this object store for each major
    platform (Java, Objective-C, Swift, Xamarin, and React Native). The React Native
    implementation is a JavaScript adapter for Realm. From the React Native side,
    we do not need to worry about the implementation details. Instead, we get a clean
    API for persisting and retrieving data. The *step 4* to* step 6* demonstrate using
    some basic Realm methods. If you want to see more of what you can do with the
    API, check out the documentation for this, which can be found at [https://realm.io/docs/react-native/latest/api/](https://realm.io/docs/react-native/latest/api/).
  prefs: []
  type: TYPE_NORMAL
- en: Masking the application upon network connection loss
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An internet connection is not always available, especially when people are moving
    around a city, on the train, or hiking in the mountains. A good user experience
    will inform the user when their connection to the internet has been lost.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create an app that shows a message when network connection
    is lost.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app. Let's name it `network-loss`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by importing the necessary dependencies into `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define the `App` class and a `state` object for storing the connectivity
    status. The `online` Boolean will be `true` if connected, and the `offline` Boolean
    will be `true` if it isn''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After the component has been created, we need to get the initial network status.
    We are going to use the `NetInfo` class''s `getConnectionInfo` method to get the
    current status, and we''ll also set up a callback that''s going to be executed
    when the status changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When the component is about to be destroyed, we need to remove the listener
    via the `componentWillUnmount` life cycle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the callback that gets executed when the network status changes.
    It just checks whether the current network type is `none`, and sets the `state` accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know when the network is on or off, but we still need a UI for displaying
    information. Let''s render a toolbar with some dummy text as the content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the previous step, there''s a `renderMask` function. This
    function will return a modal when the network is offline, and nothing if it''s
    online:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add the styles for our app. We''ll start with the toolbar and
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For the disconnection message, we will render a dark mask on top of all content,
    and a container with the text at the center of the screen. For the `mask`, we
    need to set the position to `absolute`, and then set the `top`, `bottom`, `right`,
    and `left` to `0`. We''ll also add opacity to the mask''s background color, and
    justify and align the content to the center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the mask displayed in the emulators, the emulated device must be disconnected
    from the internet. For the iOS simulator, simply disconnect your Mac''s Wi-Fi
    or unplug the Ethernet to disconnect the simulator from the internet. On the Android
    emulator, you can disable the Wi-Fi connection of the phone via the toolbar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0f528871-6c98-4795-95cf-0d10f0aef02b.png)![](assets/0e357b80-81b3-4a0c-8ba1-1f4e00d9fa9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the device has been disconnected from the internet, the mask should display
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/23f4c602-c56c-4ad1-9507-825302567b9b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2*, we created the initial `state` object with two properties: `online`
    will be `true` when a network connection is available, and `offline` will be `true`
    when it's not available.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we retrieved the initial network status and set up a listener to
    check when the status changes. The network type returned by `NetInfo` will be
    either `wifi`, `cellular`, `unknown`, or `none`. Android also has the extra options
    of `bluetooth`, `ethernet`, and `WiMAX` (for WiMAX connections). You can read
    the documentation to see all of the available values: [https://facebook.github.io/react-native/docs/netinfo.html](https://facebook.github.io/react-native/docs/netinfo.html).
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we defined the method that will execute whenever the network status
    changes, and set the `state` values of `online` and `offline` accordingly. Updating
    the state re-renders the DOM, and the mask is displayed if there is no connection.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing locally persisted data with a remote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using a mobile app, network connectivity is something that is often taken
    for granted. But what happens when your app needs to make an API call, and the
    user has just lost connectivity? Fortunately for us, React Native has a module
    that reacts to the network connectivity status. We can architect our application
    in a way that supports the loss of connectivity by synchronizing our data automatically
    as soon as the network connection is restored.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show a simple implementation of using the `NetInfo` module
    to control whether or not our application will make an API call. If connectivity
    is lost, we will keep a reference of the pending request and complete it when
    the network access is restored. We will be using [http://jsonplaceholder.typicode.com](http://jsonplaceholder.typicode.com) again
    to make a `POST` request to a live server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use an empty React Native application named `syncing-data`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start this recipe by importing our dependencies into `App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to add the `pendingSync` class variable, which we''ll use for storing
    a pending request when there is no network connection available. We''ll also create
    the `state` object with properties for tracking whether the app is connected (`isConnected`),
    the status of a sync (`syncStatus`), and the response from the server after our
    `POST` request is made (`serverResponse`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `componentWillMount` life cycle hook, we''ll get the status of the network
    connection via the `NetInfo.isConnected.fetch` method, setting the state''s `isConnected` property
    with the response. We''ll also add an event listener to the `connectionChange`
    event for keeping track of changes to the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s implement the callback that will be executed by the event listener
    we defined in the previous step. In this method, we update the `isConnected` property
    of `state`. Then, if the `pendingSync` class variable is defined, it means we''ve
    got a cached `POST` request, so we''ll submit that request and update the state
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement a function that will actually make the API call
    when there is an active network connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do before we can work on our UI is add a function
    for handling the `onPress` event on the Submit Data button we will be rendering.
    This will either perform the call immediately or be saved in `this.pendingSync`
    if there is no network connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build out our UI, which will render the Submit Data button and
    show the current connection status, sync status, and most recent response from
    the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable the network connection in the simulator in the same way as
    described in *step 10* of the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/faa23de2-9bd7-4bc8-b2ed-c963e6cd7677.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe leverages the `NetInfo` module to control when an AJAX request should
    be made.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we defined the method that's executed when the Submit Data button
    is pressed. If there is no connectivity, we save the request body into the `pendingSync` class
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3*, we defined the `componentWillMount` life cycle hook. Here, two `NetInfo`
    method calls retrieve the current network connection status and attach an event
    listener to the change event.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we defined the function that will be executed whenever the network
    connection has changed, which informs the state's `isConnected` Boolean property
    appropriately. If the device is connected, we also check to see whether there
    is a pending API call, and complete the request if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe could also be expanded on to support a queue system of pending calls,
    which would allow multiple AJAX requests to be delayed until an internet connection
    was re-established.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in with Facebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook is the largest social media platform in existence, with well over 1
    billion users worldwide. This means that there's a good chance that your users
    will have a Facebook account. Your app can register and link with their account,
    allowing you to use their Facebook credentials as a login for your app. Depending
    on the requested permissions, this will also allow you to access data such as
    user information, and pictures, and even give you the ability to access shared
    content. You can read more about the available permission options from the Facebook
    docs at [https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile](https://developers.facebook.com/docs/facebook-login/permissions#reference-public_profile).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover a basic method for logging into Facebook via an
    app to get a session token. We'll then use that token to access the basic `/me`
    endpoint provided by Facebook's Graph API, which will give us the user's name
    and ID. For more complex interactions with the Facebook Graph API, you can look
    at the documentation, which can be found at [https://developers.facebook.com/docs/graph-api/using-graph-api](https://developers.facebook.com/docs/graph-api/using-graph-api).
  prefs: []
  type: TYPE_NORMAL
- en: To keep this recipe simple, we will be building an Expo app that uses the `Expo.Facebook.logInWithReadPermissionsAsync`
    method to do the heavy lifting of logging into Facebook, which will also allow
    us to bypass much of the setup that's otherwise necessary for such an app. If
    you wish to interact with Facebook without using Expo, you will likely want to
    use the React Native Facebook SDK, which requires a lot more steps. You can find
    the SDK at [https://github.com/facebook/react-native-fbsdk](https://github.com/facebook/react-native-fbsdk).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll create a new app called `facebook-login`. You will need
    to have an active Facebook account to test its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: A Facebook Developer account is also necessary for this recipe. Head over to [https://developers.facebook.com](https://developers.facebook.com)
    to sign up if you don't have one. Once you are logged in, you can use the dashboard
    to create a new app. Make note of the app ID once it's been created, as we'll
    need it for the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening the `App.js` file and adding our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll declare the `App` class and add the `state` object. The `state`
    will keep track of whether the user is logged in with the `loggedIn` Boolean,
    and will save the retrieved user data from Facebook in an object called `facebookUserInfo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the `logIn` method of our class. This will be the method
    that''s called when the Login button is pressed. This method uses the `logInWithReadPermissionsAsync` Expo
    helper class of the `Facebook` method to prompt the user with a Facebook login
    screen. Replace the first parameter, labeled `APP_ID` in the following code, with
    your App''s ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second half of the `logIn` method, if the request is successful, we''ll
    make a call to the Facebook Graph API using the token that was received from logging
    in to request the logged-in user''s information. Once the response resolves, we
    set the state accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a simple `render` function. We''ll display a Login button
    for logging in, as well as `Text` elements that will display user information
    once the login has completed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding `render` function, we''re calling `this.renderFacebookUserInfo`
    to render user information. This method simply checks whether the user in logged
    in via `this.state.loggedIn`. If they are, we''ll display the user''s information.
    If not, we''ll return `null` to display nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add styles to complete the layout, setting padding, margins,
    color, and font sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the app, we''ll see our Login button, a login modal when the
    Login button is pressed, and the user''s information, which will be displayed
    once the user has successfully logged in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/dae0c64f-f443-4740-a2c5-ccc23680be55.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with Facebook in our React Native app is made much easier than it
    otherwise would be, via Expo's `Facebook` helper library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we created the `logIn` function, which uses `Facebook.logInWithReadPermissionsAsync` to
    make the login request to Facebook. It takes two parameters: an `appID` and an
    options object. In our case, we''re only setting the permissions option. The permissions
    option takes an array of strings for each type of permission requested, but for
    our purpose, we only use the most basic permission, `''public_profile''`.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6*, we completed the `logIn` function. It makes a call to Facebook's
    Graph API endpoint, `/me`, upon successful login, using the token provided by
    the data that's returned from `logInWithReadPermissionsAsync`. The user's information
    and the login status are saved to state, which will trigger a re-render and display
    the user's data on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe intentionally only makes a call to one simple API endpoint. You
    could use the return data from this endpoint to populate user data in your app.
    Alternatively, you could use the same token that was received from logging in
    to perform any actions provided by the Graph API. To see what kind of data is
    at your disposal via the API, you can view the reference docs at [https://developers.facebook.com/docs/graph-api/reference](https://developers.facebook.com/docs/graph-api/reference).
  prefs: []
  type: TYPE_NORMAL
