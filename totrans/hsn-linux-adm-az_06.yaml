- en: 'Chapter 6: Managing Linux Security and Identities'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed handling storage, along with network
    and process management. However, as a system administrator, your primary goal
    is to secure your Linux machine to deny any unauthorized access or limit access
    to users. In an enterprise environment, security breaches are a massive concern.
    In this chapter, we''ll be covering security—the protection of your workload at
    the operating system level; for example, if your organization is a financial institution
    where you will be dealing with workloads that deal with monetary commitments and
    even the **personally identifiable information** (**PII**) of customers, it''s
    critical that you secure the workload to avoid any breaches. Of course, Azure
    already provides you with services to protect your VMs in many ways and at many
    levels. The following are a few of these services:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Resource Manager, which provides security, auditing, and tagging features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Application Firewall, which protects against many attacks, such as SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stateful packet filtering feature of network security groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Firewall, which provides a stateful firewall tightly integrated with the
    monitoring functions of Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also subscribe to the Azure Security Center service for unified security
    management with a number of attractive features, such as continuous security assessment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these possibilities, do we still need protection at the operating
    system level? In our opinion, multi-level protection is a good idea. It will cost
    a hacker more effort and time, and this will make it easier to detect the hacker.
    There is no such thing as bug-free software: if an application is vulnerable,
    at least the operating system should be protected.'
  prefs: []
  type: TYPE_NORMAL
- en: Identity management is a topic that is certainly related to security. You can
    integrate Linux with **Azure Active Directory** (**Azure AD**) to centralize your
    login accounts, make access fine-grained by using role-based access control, revoke
    access, and enable multi-factor authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a **mandatory access control** (**MAC**) system, such as SELinux or
    AppArmor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the basics of **discretionary access control** (**DAC**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the identity management systems available in Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance Linux security with the firewall daemon and systemd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux Security Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we deep dive into all the great security measures you can take, here
    are some tips regarding security.
  prefs: []
  type: TYPE_NORMAL
- en: Security implementation on multiple levels is, in general, a good idea. This
    way, a hacker requires different approaches to gain access, and this costs them
    time. Because of this time, and hopefully also because of logging and monitoring,
    you have a greater chance of detecting unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: For files and directories, `suid/sgid` bit as much as possible. Are there users
    who need to change their own password? No? Then remove that bit from the `passwd`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use partitioning, especially for directories such as `/tmp`, `/var`, `/var/tmp`,
    and `/home`, and mount them with the `noexec`, `nodev`, and `nosuid` flags:'
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's not a good idea for a user to be able to execute programs from
    these locations. Luckily, if you can't set the owner to root, you can copy a program
    with the `suid` bit to your own directory as a normal user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `suid` and `sgid` permissions on files in these directories are very, very
    dangerous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not allow the creation or existence of characters or special devices on this
    partition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access the VM, use SSH key–based authentication, not passwords. Limit access
    to certain IPs, using ACLs or a firewall. Limit users and allow no remote access
    for root (use the `PermitRootLogin no` parameter and `AllowUsers` to only allow
    one or two accounts access). Use `sudo` to execute commands as root. Perhaps create
    special users, or groups of users, for special tasks in the `sudo` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Do not install too much software on a VM, especially when it comes to network
    services, such as web servers and email servers. Use the `ss` command from time
    to time to review the open ports and compare them with the ACLs and/or firewall
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Another tip is not to disable SELinux on your system, which is a security module
    in the Linux kernel. Don't worry about this now, as we have a dedicated section
    on SElinux.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your system up to date; there is a reason why Linux vendors provide you
    with updates. Do it manually or with an automation/orchestration tool. Just do
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purposes of this chapter, you'll need to deploy RedHat/CentOS 7 and
    an Ubuntu 18.04 VM. Another option is to use SUSE SLE 12 or openSUSE LEAP instead
    of the CentOS and Ubuntu VMs. SUSE supports all options discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: DAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DAC** is also known as user-dictated access control. You may already be familiar
    with the classic permissions in Linux and ACLs. These combine to form DAC. Classic
    permissions check the **user ID** (**UID**) and **group ID** (**GID**) of the
    current process. Classic permissions match the UID and GID of the user trying
    to access the file with the UID and GID set to the file. Let''s see how DAC was
    introduced and what level of permission you have in Linux. However, we will not
    be discussing this in detail as the main intention is to get you familiarized
    with permissions in Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to DAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The majority of operating systems, such as Linux, macOS, flavors of Unix, and
    even Windows, are based on DAC. MAC and DAC were defined in the **Trusted Computer
    System Evaluation Criteria** (**TCSEC**), also known as the Orange Book, published
    by the US **DoD** (**Department of Defense**). We'll be discussing MAC in the
    next section. As the name suggests, DAC allows the owners or creators of files
    to decide what level of access they need to give to other users for the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Although we see DAC implemented in all systems, it is also regarded as weak.
    For example, if we grant read access to a user, it will be transitive in nature.
    So, there is nothing that will stop the user from copying the content of someone
    else's file to an object that the user has access to. In other words, the distribution
    of information is not administered in DAC. In the next section, we will take a
    quick look at file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: File Permissions in Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every file and directory in Linux is treated as an object and has three types
    of owner: user, group, and other. Going forward, we will generally refer to files
    and directories as objects. First, let''s understand the three different types
    of owners:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: The user is the person who creates the object. By default, this person
    will become the owner of the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: A group is a collection of users. All users who are part of the
    same group will have the same access levels in relation to the object. The concept
    of a group makes it easier for you to assign permissions to multiple users at
    the same time. Think of a scenario where you will be creating a file and you want
    your team members to access the file as well. If you are part of a large team
    and assigning permissions to each user, this will be hectic. Instead, you can
    add the users to a group and define the permission for the group, meaning that
    all the users in the group inherit access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other**: This refers to any other user who is not the owner (creator) of
    the object or who is not part of the user group who could own the object. In other
    words, think of a set containing the creator and all users in the group that has
    permission; ''''other'''' refers to a user who is not an element of this set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As stated earlier, each object has three types of owner. Each owner (user,
    group, owner) will have three permissions on an object. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read**: Read permission will give permission to read or open a file. Read
    permission on a directory means that the user will be able to list the content
    of the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: If applied to a file, this will give permission to alter the content
    of the file. Adding this permission to a directory will grant the authority to
    add, remove, and rename files in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute**: This permission is mandatory for running an executable program
    or script. For example, if you have a bash script and you have read/write permission,
    this means you will be able to read and alter the code. To execute the code, however,
    you need this permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a pictorial representation of owners and the associated permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A flowchart representing three types of owners (user, group, and others)
    and their associated permissions on an object, namely read, write, and execute](img/B15455_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Owner types and access permissions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's move on and understand how we can figure out the permissions from the
    Linux Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: To list the contents of a directory, execute `ls -lah`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be different based on the content you have in the directory
    you''re listing from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An output listing the contents of a directory](img/B15455_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Listing the contents of a directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you observe the `data` line, the first letter is `d`, which implies that
    it is a directory. As regards `external.png`, it's showing `-`, which stands for
    a file, and there is `l` for `home`, which means a link (more like a shortcut).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A glance at the data line of the directory output](img/B15455_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Data line of the directory output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: First, `rwx` denotes that the user/owner has read, write, and execute permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Second, `r-x` denotes that the group has read and execute permissions. However,
    write permission is not there.
  prefs: []
  type: TYPE_NORMAL
- en: Third, `r-x` denotes that all others have read and execute access, but no write
    access.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can understand the permissions assigned to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'These will already be written in the order `read(r)`, `write(w)`, and `execute`.
    If a letter is missing, that means that the permission is not there. Here is a
    table explaining what these letters signify:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List of access permissions and their corresponding symbols](img/B15455_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Symbols for access permissions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You might be wondering who the owner of this file is and which group is getting
    access. This is answered in the output itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output containing information regarding owners and groups](img/B15455_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Owner and group details'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this case:'
  prefs: []
  type: TYPE_NORMAL
- en: The user has read and write permission, but no execute permission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group has read permission only, and no write and execute permission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All others have read permission only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram will help you to understand how to differentiate between
    permissions for each owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the difference between various permissions for different owners](img/B15455_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Differentiating between permissions for each owner'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can change the permissions of a file or folder using the `chmod` command.
    The general syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, applying a permission to the directory doesn't inherit the same to
    the sub-folders and files therein. If you would like the permissions to be inherited,
    you can use the `-R` parameter, which stands for *recursive*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this command doesn't give any output; that is, it doesn't return any output
    irrespective of whether it applied the permissions or not. You can use the `-v`
    parameter to get verbose output.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways in which you can pass permissions to the `chmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolute method/numeric model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbolic Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the symbolic method, we will use the operator and user denotations. The
    following is a list of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A list of operators for setting, adding, and removing permissions](img/B15455_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Operators in symbolic method'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And here is a list of user denotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List of user denotations](img/B15455_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: User denotations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's now examine how we can combine the operator and denotation to change permission.
    We will be using the `-v` parameter to understand what's changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recall the permissions we had for the `external.png` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the permissions for external.png file](img/B15455_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Permissions for external.png file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of now, the user doesn''t have execute permissions. To add these, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you can see that the value changed from `rw-r--r--` to `rwxr--r--`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding execute permissions to a user](img/B15455_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Adding execute permissions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You will see some numbers here. We will discuss what these are when we discuss
    the absolute method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s try to write and execute permissions for the group by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, adding `wx(write, execute)` to `g(group)` will give you an output similar
    to the following. You can clearly understand the change from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding write and execute permissions to a group](img/B15455_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Adding write and execute permissions to a group'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Until now, we have been adding permissions. Now, let's see how to remove the
    existing read permissions of others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove the read permission, which is evident from the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An output showing change in read permissions](img/B15455_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Removing the read permission'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let's set read, write, and execute permissions for everyone (user, group, and
    other).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the permissions changed to `rwxrwxrwx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting read, write, and execute permissions to all owners (user, group,
    and others)](img/B15455_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Setting read, write and execute permissions to everyone'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another example involves combining the permissions for each owner and passing
    these in a single shot, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, user permission is set to read and write, group permission to read-only,
    and other permission to execute-only. Likewise, you can separate the permissions
    using commas and use the necessary operators to grant permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Absolute (Numeric) Node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this method, we will be using a three-digit octal number to set the permission.
    The following is a table of values and their corresponding permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List of numeric values and their corresponding permissions](img/B15455_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Numeric values and their corresponding permissions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s take an example. Check the permissions of the `new-file` file, which
    is located in our current directory. Execute `ls -lah`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing ls -lah to check permissions of new-file](img/B15455_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Checking permissions of new-file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, let's use numeric mode and assign permissions. We will change the user
    permission to `rwx`, so 4 + 2 + 1 = 7, and then change the group permission to
    `rw`, so 4 + 2 + 0 = 6, and only execute for others, so 0 + 0 + 1 = 1.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these three numbers, we get 761, so that is the value we need to pass
    to `chmod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assigning permissions using 3-digit octal code](img/B15455_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Assigning permissions using the 3-digit octal code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we can relate the numbers we got in previous outputs when we were testing
    using the symbolic method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a pictorial representation of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pictorial representation of the 3-digit octal code](img/B15455_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: Pictorial representation of the 3-digit octal code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have noticed that there is an extra digit before the permission we assigned
    (for example, 0761). This `0` is for advanced file permissions. If you recall
    the tips, we had ''*The suid and sgid permissions on files in these directories
    are very, very dangerous*'' and ''*Try to avoid using the suid/sgid bit as much
    as possible*''. These `suid/sgid` values are passed via an additional digit. It's
    better not to use this and stick to the basic permission as these are very dangerous
    and can be complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how to change permission, but how will we change the owning user
    and group? For this, we will be using the `chown` command. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will change the owner and group of the file. If you want to change the
    owner only, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to change just the group, use the `chgrp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As explained in the case of the `chown` command, this command is also not recursive.
    If you want to make the change inherited to the subfolder and files of a directory,
    use the `-R` (recursive) parameter. You also have a verbose (`-v`) option as we
    saw in `chmod`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about handling permissions, let's go to the next section about
    MAC. DAC was all about permission checks using the UID and GID. On the other hand,
    MAC is policy-based access control. Let's now take a closer look at MAC.
  prefs: []
  type: TYPE_NORMAL
- en: MAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In MAC, a system limits access to specific resources depending on the authorization
    and sensitivity of the specific resource. It's more policy-based and is implemented
    using **Linux Security Modules** (**LSM**).
  prefs: []
  type: TYPE_NORMAL
- en: Security labels are at the heart of MAC. Every subject is given a level of security
    clearance (for example, secret or confidential) and each data object gets a security
    classification. For instance, a user with a security clearance level of confidential
    who is trying to retrieve a data object with a security classification of top
    secret is denied access, because their clearance is lower than the classification
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it is quite obvious that you can use the MAC model mostly in those environments
    where confidentiality is of the utmost importance (government institutions, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: SELinux and AppArmor are examples of MAC-based commercial systems.
  prefs: []
  type: TYPE_NORMAL
- en: LSM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LSM is a framework for providing an interface for adding MAC on top of DAC.
    This extra layer of security can be added with SELinux (Red Hat–based distributions
    and SUSE), AppArmor (Ubuntu and SUSE), or the lesser-known Tomoyo (SUSE). In this
    section, we'll cover SELinux and AppArmor.
  prefs: []
  type: TYPE_NORMAL
- en: 'DAC is a model that provides access control based on users who are a member
    of a group and permissions on files and devices. MAC restricts access to resource
    objects such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/UDP ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users and their roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC, as implemented by SELinux, works by assigning a classification label, also
    known as a context label, to every resource object, whereas AppArmor is path-based.
    In either case, if one resource object requires access to another object, it needs
    clearance. So, even if a hacker makes it into your web application, for instance,
    the other resources are still protected!
  prefs: []
  type: TYPE_NORMAL
- en: SELinux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned earlier, SELinux is a security module in Linux and, by way of
    a security tip, it's recommended that it not be disabled. SELinux was developed
    by the NSA and Red Hat. The initial release was on December 22, 2000, and, at
    the time of writing this book, the stable release available is 2.9, released in
    2019\. It can be used on every Red Hat–based distribution and SUSE. This book
    will cover implementation on Red Hat. If you want to use it on SUSE, visit the
    SUSE documentation at [https://doc.opensuse.org/documentation/leap/security/html/book.security/cha-selinux.html](https://doc.opensuse.org/documentation/leap/security/html/book.security/cha-selinux.html)
    to install and enable SELinux. After that, the procedures are the same. In the
    past, some effort was made to make it work on Ubuntu but, at the moment, there
    is no active development and the packages are broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'All access must be explicitly granted but, on the distributions that utilize
    SELinux, many policies are already in place. This covers almost every resource
    object. On top of the list already mentioned in the documentation, it covers the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The complete network stack, including IPsec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter-process communication** (**IPC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptor (communication channels) inheritance and transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For container virtualization solutions such as Docker, SELinux can protect the
    host and offers protection between containers.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SELinux is configured via the `/etc/selinux/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The status should be in `enforcing` mode in a production environment. Policies
    are enforced and, if access is restricted, auditing can be done to be able to
    fix the problems caused by SELinux. The `permissive` mode can become handy if
    you are a software developer or packager and you need to create SELinux policies
    for your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s possible to switch between the `enforcing` and `permissive` modes using
    the `setenforce` command. Use `setenforce 0` to switch to the permissive mode
    and `setenforce 1` to go back to the enforcing mode. The `getenforce` command
    is available to view the current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The default policy—`targeted`, protects all resources and provides enough protection
    for most workloads. **Multi-level security** (**MLS**) offers additional security
    by using levels of clearance provided by categories and sensitivities (such as
    confidential, secret, and top secret) together with SELinux users and roles. This
    can be very useful for file servers that offer file shares.
  prefs: []
  type: TYPE_NORMAL
- en: If the `minimum` type is selected, then only the bare minimum is protected;
    you need to configure everything else yourself if you want more protection. This
    type can be useful if there are difficulties in protecting a multi-process application
    (typically, very old applications) and a generated policy removes too many restrictions.
    In this scenario, it's better to leave the specific application unprotected, and
    protect the rest of the system. In this section, I'll only discuss `SELINUXTYPE=targeted`,
    which is the most widely used option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the state of SELinux, you can use the `sestatus` command. The output
    should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the sestatus command to view the state of SELinux](img/B15455_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: SELinux state'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before we explore SELinux, you''ll need to add the necessary packages to your
    system to be able to audit SELinux. Please execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you''ll need to reboot the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the reboot, we''re ready to use and troubleshoot SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with an easy example involving the SSH service. As stated earlier,
    all processes are labeled with a context label. To make this label visible, many
    utilities, such as `ls`, `ps`, and `lsof`, have the `-Z` parameter. First, you
    have to find the main process ID of this service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this process ID, we can ask for the context label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The context label is `system_u`, `system_r`, `sshd_t`, and `s0-s0, c0.c1023`.
    Because we''re using the targeted SELinux type, we only take care of the SELinux
    type part: `sshd_t`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH is running on port 22\. Let''s now investigate the label on the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will establish that the context label is `system_u`, `system_r`, `sshd_t`,
    `s0-s0`, and `c0.c1023`, in other words, exactly the same. It''s not difficult
    to understand that the `sshd` process does indeed have permission to run on this
    port with the same label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context label for sshd process](img/B15455_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Context label for sshd process'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It''s not always that simple, but before going into a more complex scenario,
    let''s modify the port that the SSH server is listening on to port 44\. To do
    so, edit the `/etc/ssh/sshd_config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the SSH server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute the `journalctl -xe` command, you will see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple methods for troubleshooting SELinux. You can use the log
    file, `/var/log/audit/audit.log`, directly, or with the `sealert -a /var/log/audit/audit.log`
    command, or use the `journalctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The logging entry also states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this command (and maybe redirect the output to a file or pipe it through
    `less` or `more`), and it will not only show you the same SELinux message again,
    but it will also come with a suggestion for how to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Before going into this solution, SELinux works with multiple databases that
    contain the resource object, and the context label, that is, `/`, should be applied
    to the resource object. The `semanage` tool is available to modify the database
    and add entries to it; in our scenario, the database port. The output of the logging
    suggests adding a context label for TCP port 44 to the database. There are three
    possible contexts; all of them will fix your problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect is the fact that there are sometimes other possible
    solutions. There is a confidence rating to make the choice easier for you. But
    even then, you still have to read carefully. Especially with files, sometimes,
    you want to add a regular expression instead of doing it for every file over and
    over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take a pragmatic approach and state "I am not using `vnc` and `xserver`,
    so I choose `ssh_port_t`" or you can use the `sepolicy` utility, part of the `policycoreutils-devel`
    package. If you''re getting an error message, install `policycoreutils-devel`
    using `sudo yum install –y policycoreutils-devel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Search in the output for the TCP `name_bind`, because SELinux access is preventing
    `/usr/sbin/sshd` from having `name_bind` access to `tcp_socket port 44`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know where the suggestion comes from, look into the current label
    of port 22:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The label is `ssh_port_t`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use `semanage port -l` and `grep` on port 22\.
  prefs: []
  type: TYPE_NORMAL
- en: 'It really makes sense to use the same label. Not convinced? Let''s generate
    man pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `ssh_selinux` man page tells you in the `ssh_port_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s fix the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t have to restart the `sshd` service; `systemd` will restart this
    service automatically within 42 seconds. By the way, the `sshd_config` file already
    has a comment that describes this fix. It is explicitly stated in the line before
    `#Port 22`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's a good idea to undo the configuration change and configure it back to port
    22; otherwise, you might be locked out of the test system.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux Context on Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After our first meeting with SELinux and investigating context labels on ports,
    it''s time to investigate context labels on files. As an example, we''re going
    to use an `vsftpd` and an FTP client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a directory called `/srv/ftp/pub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then create a file in `/srv/ftp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the configuration file, `/etc/vsftpd/vsftpd.conf`, and add the following
    beneath the `local_enable=YES` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `/srv/ftp` the default root directory for the `vsftpd` service for
    anonymous users. Now you are ready to start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `ftp` utility, try to log into the FTP server as the user `anonymous`,
    without a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And it works! Why is this possible? Because there is already an entry in the
    database for `/srv/ftp/README` with the correct label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command shows the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s applied while creating a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Both commands tell you that the type is `public_content_t`. The man page of
    `ftpd_selinux` has two sections that are important here: `public_content_t` type
    only allows you to read (download) files, but that you are not allowed to write
    (upload) files with this type. You need another type, `public_content_rw_t`, to
    be able to upload files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an upload directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'View the current label and change it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, you have to add the policy to the `fcontext` database; after that, you
    can apply the policy to the already existing directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Read the man page of `selinux-fcontext`. In addition to describing all the options,
    there are also some nice examples.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using a single string, you can change the behavior of SELinux. This string
    is called `SELinux Boolean`. You can get a list of Booleans and their values using
    `getsebool -a`. Using `boolean allow_ftpd_anon_write`, we are going to change
    the way in which SELinux reacts. Connect anonymously to the FTP server again and
    try to upload a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `journalctl --identifier setroubleshoot` command makes it very clear to
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sealert` command will provide you with the information necessary to fix
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what''s happening here? Sometimes, simple rules for a port or file are
    not enough, for instance, if an NFS share has to be exported with Samba as well.
    In this scenario, it is possible to create your own complex SELinux policy or
    use the Boolean database with easy-to-use on/off switches. To do so, you can use
    the older `setsebool` utility or `semanage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using `setsebool` without `-P` makes the change, but it is not persistent. The
    `semanage` utility doesn't have the option to change it non-permanently.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Debian, Ubuntu, and SUSE distributions, AppArmor is available to implement
    MAC. Please be aware that there are some minor differences between the distributions,
    but, in general, a distribution can add fewer or more profiles and some extra
    tooling. In this section, we use Ubuntu 18.04 as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you must make sure that you keep your distribution up to date, especially
    with AppArmor; the packages in Debian and Ubuntu were plagued by bugs, which sometimes
    led to unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the necessary packages are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some fundamental differences compared with SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the bare minimum is protected. You have to apply security for
    each application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can mix enforcing and complaining modes; you can decide in relation to each
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When AppArmor development started, the scope was quite limited: processes and
    files. Nowadays, you can use it for **role-based access control** (**RBAC**),
    MLS, login policies, and other aspects besides.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the initial scope: processes that need access
    to files.'
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing to do is to check whether the AppArmor service is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And after that, view the status in greater detail with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an alternative to the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the status of AppArmor, derived using the `apparmor_status`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the status of AppArmor using the apparmor_status command](img/B15455_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: AppArmor status'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generating AppArmor Profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each application you want to protect requires a profile, provided by the `apparmor-profiles`
    or `apparmor-profiles-extra` packages, the application package, or you. The profiles
    are stored in `/etc/apparmor.d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the nginx web server as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you browse through the `/etc/apparmor.d` directory, there is no profile
    for nginx. Create a default one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A profile is created: `/etc/apparmor.d/usr.sbin.nginx`. This file is almost
    empty, and only includes some basic rules and variables, called abstractions,
    and the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mr` value defines the access mode: `r` means read mode, and `m` allows
    a file to be mapped into memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enforce the mode for nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'nginx will not start. The output of the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This points very clearly in the direction of AppArmor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the problem, set the complain mode for this profile. This way, it doesn''t
    enforce the policy, but complains about every violation of the security policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Make an `http` request, using a browser or a utility, for instance, `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to scan the `logfile` and approve or reject every action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Read very carefully and select the correct option with the arrow keys (if needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the profile for nginx](img/B15455_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: Configuring the profile for nginx'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**LXC** (**Linux Containers**) is a container technology, and we are just configuring
    the profile for a web server. Something to fix with DAC seems to be a good choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the profile for a web server with DAC](img/B15455_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Fixing DAC for nginx'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The audit suggests a new mode: `w` means write access to the `/var/log/nginx/error.log`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, you can block access to the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: Read access to `/etc/ssl/openssl.conf`. This is a difficult one, but the abstraction
    for `ssl` sounds right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read access to `/etc/nginx/nginx.conf`. Again, not a container, so the owner
    of the file must be OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the owner of the file is a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, it is time to save the changes and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems to work now, at least for a request to a simple website. As
    you can see, it's all largely based on educated guesses. The alternative is a
    deep dive into all the suggested abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The created file, `/etc/apparmor.d/usr.sbin.nginx`, is relatively easy to read.
    It starts with all the tunable variables that should be available for every profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is then followed by other abstractions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To know what they are doing, just view the file. For instance, the `/etc/apparmor.d/abstractions/nameservice`
    file states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many programs wish to perform name service–like operations, such as looking
    up users by name or ID, groups by name or ID, and hosts by name or IP. These operations
    may be performed through DNS, NIS, NIS+, LDAP, hesiod, and wins files. Allow all
    of these options here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section is about Posix capabilities; refer to `man 7 capabilities`
    for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The final section is the permissions; for a complete list, refer to the `man
    5 apparmor.d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`aa-logprof`, in particular, can be a little bit overwhelming when you start
    using it. But the profile is not that difficult to read; every option is in the
    two man pages, and the abstractions included are documented by comments.'
  prefs: []
  type: TYPE_NORMAL
- en: firewalld and systemd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Advanced Linux Administration*, systemd was covered as a system
    and service manager. In systemd, there are several options to add an extra layer
    of protection to your daemons and filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, in our opinion, it really makes sense to use Azure Firewall on
    top of Azure network security groups. It is easy to set up, provides central administration,
    and requires almost no maintenance. It provides security between VMs, virtual
    networks, and even different Azure subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is an additional cost if you want to use this firewall. However, a Linux
    firewall doesn't incur any charges as it is a security measure installed on your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice between Azure Firewall and a Linux firewall depends on many things:'
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment and orchestration of your VMs and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Different roles: is there one administrator for everything?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope that after covering one of the Linux firewall implementations, it becomes
    clear that a Linux firewall is in no way a complete replacement for Azure Firewall.
    It can only provide security for incoming traffic to the VM, and yes, it is possible
    to configure this firewall to block outgoing traffic as well, but that's quite
    complex. On the other hand, if it's configured on top of Azure network security
    groups, in many cases, that is more than enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of firewall solutions available for Linux, including
    firewalld and iptables. In this book, we''ll be following firewalld on account
    of the configuration options available and its popularity. Please make sure that
    the firewalld software is installed and that other firewall software is removed
    from the system to avoid conflicts. In RHEL/CentOS-based distributions, this is
    already the case. In Ubuntu, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In SUSE-based distributions, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There are multiple firewall implementations for Linux; some of them are even
    developed for a specific distribution, such as SuSEfirewall2\. In this chapter,
    we'll cover firewalld, which is available on every distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'firewalld consists of a daemon that manages all the components of the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: Zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct rules for iptables and ebtables (not covered in this book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'firewalld utilizes kernel modules: iptables/IP6 tables for IPv4 and IPv6 traffic,
    and ebtables for the filtering of network traffic passing through a Linux bridge.
    In more recent distributions, such as RHEL 8, the `nftables` module is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the firewalld rules, there is a command-line utility available:
    `firewall-cmd`. Rules can be runtime-only or persistent. There are two important
    reasons for this behavior: this way, it''s not necessary to reload all the rules,
    implying a temporary security risk. You can dynamically add and remove rules.
    If you make a mistake, and you are not able to log in again because of this; just
    reboot as a quick solution. We can also use the `systemd-run --oncalendar` command
    to create a scheduled task that executes `firewall-cmd --reload`, which is an
    even better solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to stop and disable the timer if the firewall rules were correct
    (and you did not lock yourself out).
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure the daemon with orchestration tools that talk to the
    daemon or push XML files to the host.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ports are only open for the VMs connected to the virtual machine network,
    unless you open the ports in the network security group!
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to know that Azure Service Fabric (the infrastructure) will
    add, if necessary, extra rules to your firewall configuration. It''s recommended
    not to remove these rules as they are important, given that they are used by the
    Azure platform. You can see this if you search in the logging database with the
    `journalctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `iptables-save` command to view all the active firewall rules, or if
    your distribution is using `nftables`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: firewalld Zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important concepts of firewalld is the zone. A zone consists
    of a default rule, called a target, a network interface or network source, and
    additional services, ports, protocols, and rich rules.
  prefs: []
  type: TYPE_NORMAL
- en: A zone is only active if a network interface is attached to the interface or
    a network source.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the zones available, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: These zones are configured in `/usr/lib/firewalld/zones`. You should not make
    changes to these files. New zones or changes to a zone are written into the `/etc/firewalld/zones`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default zone is the public zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the zone configuration of the public zone, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The zone configuration will be as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The public zone has the target policy `default`, which means that everything
    incoming is blocked by default, except the configured services, ports, and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding `/usr/lib/firewalld/zones/public.xml` file of this zone is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: There are also options for configuring masquerading and port forwarding. Rich
    rules are advanced firewall rules, as described in the `firewalld.richlanguage`
    man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `man firewalld.richlanguages` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Output of man firewalld.richlanguages command](img/B15455_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: Output of `man firewalld.richlanguages command`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Depending on the distribution that you're using, you may have additional service
    names. For example, if you are using RHEL 8, you might see `cockpit` listed as
    a service. `cockpit` is a web-based interface used to administer RHEL machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that in the public zone, it says `target: default`. The
    target is the default behavior. The possible values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default`: Don''t do anything, accept every ICMP packet, and reject everything
    else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%%REJECT%%`: This sends a reject response to the client via the ICMP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DROP`: This sends a TCP SYN/ACK, as on an open port, but all other traffic
    is dropped. There is no ICMP message to inform the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACCEPT`: Accept everything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Ubuntu, by default, there is no network interface attached. Please don''t
    reboot the VM before an interface is attached! Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If you modify a zone, the file is copied from `/usr/lib/firewalld/zones` to
    `/etc/firewalld/zones`. The next modification will create a backup of the zone
    with the file extension `.old` and create a new file with the modifications in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: firewalld Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A service is an application-centric configuration to allow one or more ports.
    To receive a list of the services available, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add a service, for instance, MySQL, execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If you want to remove a service from a zone, use the `--remove-service` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The services are configured in the `/usr/lib/firewalld/services` directory.
    Again, you shouldn't modify these files. You can change them or create your own
    by copying them to the `/etc/firewalld/services` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to add single ports as well, but, in general, that''s not a
    good idea: can you still remember after a while which ports are in use by which
    application? Instead, if the service is not already defined, create your own service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a service file for the Microsoft PPTP firewall protocol,
    `/etc/firewalld/services/pptp.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding file, you can see that TCP port `1723` is allowed. You can
    add as many port rules as you want. For example, if you want to add TCP port `1724`,
    then the line item will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'After reloading the firewall with `firewalld-cmd --reload`, the service is
    available. This is not enough: the **GRE** (**Generic Routing Encapsulation**)
    protocol is not allowed. To allow this protocol, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This will add the following line to the service file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You can remove the protocol using the `--remove-protocol` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: firewalld Network Sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A zone is only active when a network interface is attached to it, or a network
    source. It doesn't make sense to add a network interface to the drop zone. The
    drop zone is where all the incoming packets are dropped with no reply; however,
    outgoing connections are allowed. So, as I mentioned, if you add the network interface
    to the drop zone, all incoming packets will be dropped by firewalld, which doesn't
    make any sense at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it does make sense to add a network source. A source consists of one
    or more entries: a media access control address, IP addresses, or IP ranges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, for whatever reason, say you want to block all traffic from Bermuda.
    The website [http://ipdeny.com](http://ipdeny.com) can provide you with a list
    of IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several types of `ipset`. To view the list of supported `ipset` types,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In our scenario, we want the type for `hash:net` IP ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add entries to `ipset` using the downloaded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step involves adding `ipset` as a source to the zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of the drop zone is to drop all traffic without letting the client
    know that the traffic is dropped. Adding `ipset` to this zone makes it active,
    and all the traffic coming from Bermuda will be dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how firewalld works, and how we can secure our machine using
    zones, let's jump to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: systemd Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, systemd is responsible for starting all
    processes in parallel during the boot process, except those processes that are
    created by their kernel. After that, it's a question of activating services, among
    other things, on demand. systemd units can also provide an extra layer of security.
    You can add several options to your unit file to make your unit more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just edit the unit file using `systemctl edit` and add the security measures.
    For example, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file, re-read the `systemctl` configuration, and restart `sshd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, log in again with your SSH client and try to save a file in your home
    directory. This will fail because it''s a read-only filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unable to save file in home directory as permission has been changed to read-only](img/B15455_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: Log in failed as unit file changed to read-only'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Restricting Access to the Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ProtectHome` parameter is a very interesting one. The following values
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`: The directories `/home`, `/root`, and `/run/user` are not accessible
    by the unit, and show empty for processes starting within the unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read-only`: These directories are read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another very similar parameter is `ProtectSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`: `/usr` and `/boot` are mounted as read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`full`: `/etc` is mounted as read-only, along with `/usr` and `/boot`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strict`: The full filesystem is read-only, except `/proc`, `/dev`, and `/sys`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of `ProtectHome` and `ProtectSystem`, additionally, you can use the
    following parameters: `ReadWritePaths` to whitelist directories, `ReadOnlyPaths`,
    and `InaccessiblePaths`.'
  prefs: []
  type: TYPE_NORMAL
- en: Some daemons use the `/tmp` directory for temporary storage. The problem with
    this directory is that it's world-readable. The `PrivateTmp=true` parameter sets
    up a new temporary filesystem for the process, which is only accessible by the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also kernel-related parameters: the `ProtectKernelModules=true` parameter
    makes it impossible to load modules, and the `ProtectKernelTunables=true` parameter
    makes it impossible to change kernel parameters with the `sysctl` command or manually
    in the `/proc` and `/sys` directory structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, the `SELinuxContext` and `AppArmorProfile` parameters force
    the context for the unit.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting Network Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: systemd can also be used to restrict network access, as in you can list those
    IP addresses that can be allowed or denied. Newer versions of systemd, after version
    235, such as those used by Ubuntu 18.04, SLE 15 SP1, and RHEL 8, also support
    IP accounting and access lists to restrict network access.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPAccounting=yes` allows a unit to collect and analyze network data. To view
    the results, you can use the `systemctl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'As with every parameter, you can use this with `systemd-run` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the systemd-run and systemctl commands to collect and analyze network
    data](img/B15455_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: Using systemd-run and systemctl to collect and analyze network
    data'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can use `IPAddressDeny` to deny an IP address or an IP range. An exception
    can be made with `IPAddressAllow`. It''s even possible to deny everything system-wide
    and whitelist on a per-service basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are using Ubuntu, the service name is `walinuxagent`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes are saved in the `/etc/systemd/system.control` directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changes saved in the system.control directory](img/B15455_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: Saving the changes in system.control directory'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are some remarks:'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you have to change the IP range to your virtual subnet, and you have
    to allow access to the first IP address of your subnet for the Azure agent and
    network service, such as **DHCP** (**Dynamic Host Configuration Protocol**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also a very good idea to restrict SSH access to the IP address of your
    own network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the systemd journal very carefully, to find out whether you need more ports
    to open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The systemd access list feature is perhaps not as advanced as firewalld, but
    it is a very good alternative for restrictions on the application level (hosts
    allow directives in the configuration files of the daemon, or `/etc/hosts.allow`
    and `/etc/hosts.deny` for applications that are compiled with `libwrap` support).
    And, in our opinion, in Azure, you don't need more than this. If only all distributions
    had a recent version of systemd.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We won't cover the `libwrap` library in this book, because more and more applications
    are no longer using this option, and some vendors, such as SUSE, are busy removing
    the complete support for this library.
  prefs: []
  type: TYPE_NORMAL
- en: Identity and Access Management in Azure – IAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we have been discussing how to manage security in Linux. Since we
    are deploying in Azure, Azure also provides some added security to our Linux VMs.
    For example, earlier, we discussed Azure Firewall and network security groups,
    which help in controlling traffic, limiting access to unwanted ports, and filtering
    traffic originating from unknown locations. On top of this, there are other services
    in Azure, such as Azure AD Domain Services, which will let you join a Linux VM
    to a domain. Recently, Microsoft launched an option by which Azure AD users can
    sign in to the Linux VM. The advantage of this is that you don't have to use other
    usernames; instead, you can use Azure AD credentials. Let's take a closer look
    at these services and understand how we can make use of them to increase the security
    of our Linux VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Azure AD Domain Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have been discussing what can be done inside the Linux VM. Since
    we are on Azure, we should take advantage of **Azure AD Domain Services**, by
    which you can domain join your Linux machines and enforce your organization's
    policies. Azure AD Domain Services is a domain controller as a service that provides
    you with a DNS service and identity management. Central identity management is
    always an important part of security solutions. It enables the user to access
    resources. On top of that, you can enforce policies and enable multi-factor authentication.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on how to set up a service and how to join a
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Azure AD Domain Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to set up Azure AD Domain Services is via the Azure portal.
    In the left-hand bar, select **Create a resource** and search for *Domain Services*.
    Select **Azure AD Domain Services** and click on the **Create** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the wizard, you will be asked for some settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.onmicrosoft.com`. For the purposes of this book, that is sufficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual network**: It''s a good idea to create a new virtual network and
    a new subnet. Labeling doesn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AAD DC Administrators`. To be able to join a domain with a user, the user
    must be a member of this group, using the **Active Directory** section in the
    left-hand bar in the Azure portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you are ready to deploy the service. This will take a while; in my personal
    experience, it can take 20 to 30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: When you are finished, go to the **Virtual Networks** section in the left-hand
    bar and enter the newly created virtual network. You will find two newly created
    network interfaces and their IP addresses. You'll need this information, so make
    a note of it.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to create a new subnet in this virtual network, but it's not
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Linux Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to deploy the Linux VM in the same virtual network or on a peered network
    where Azure AD Directory Services is deployed. As stated, it is a good idea to
    attach it to another subnet. Here, we are not following the secure LDAP.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Change the hostname with the `hostnamectl` utility to the correct `fqdn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit the `/etc/hosts` file. Add an entry such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: DNS Servers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the left-hand bar of the Azure portal, go to **Virtual Networks** and navigate
    to the subnet where the Azure AD Domain Services network interfaces are located.
    Select **DNS servers** and use the custom options to set the IP addresses of the
    Azure AD Domain Services network interfaces. By doing so, whenever DNS resolution
    of the hostname is required, it will be pointed to Azure AD Domain Services.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if your Azure AD Domain Services is a new deployment, in the
    **Overview** pane of the Azure portal, it will ask you to change the DNS servers.
    Just clicking the **Configure** button would change the DNS servers in the virtual
    network to point to Azure AD Domain Services.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, restarting the network in the VM should suffice, but it's a better
    idea to reboot now. From time to time, the old and new settings both survive.
  prefs: []
  type: TYPE_NORMAL
- en: In RHEL, Ubuntu, and SUSE, view the content of the `/etc/resolv.conf` file to
    verify the result. Then, look into the settings for `eth0`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some important components and dependencies that are required in order
    to be able to use Azure AD Domain Services:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kerberos client, for authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSSD, a backend that is responsible for the configuration and utilization of
    features such as using and caching credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Samba libraries, to be compatible with Windows features/options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some utilities to join and manage the domain, such as `realm`, `adcli`, and
    the `net` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the necessary software to be able to join the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For RHEL/CentOS-based distributions, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ubuntu, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In SLE/OpenSUSE LEAP, dependencies will be handled by YaST.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the Domain – Ubuntu and RHEL/CentOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ubuntu- and RHEL/CentOS-based distributions, the `realm` utility is available
    to join the domain. First, discover the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discovering the domain in Ubuntu- and RHEL/CentOS-based distributions](img/B15455_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: Discovering the domain'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, you are ready to join the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Use the username you added earlier on as a member of the Azure AD Domain Services
    administrator group. If you get a message saying `Necessary packages are not installed`,
    but you are certain that they are installed, add the `--install=/` parameter to
    the `realm` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the result, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using realm utility to join the domain](img/B15455_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: Joining the domain'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should be able to do things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Log in remotely with `ssh` with this user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If this doesn't work, and the join was successful, reboot the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the Domain – SUSE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In SUSE SLE and LEAP, the best way to join the domain is by using YaST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the YaST utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: From the YaST main window, start the **User Logon Management** module and click
    on **Change Settings**. Click on **Join Domain** and fill in the domain name.
    After that, you will be able to enroll in the domain successfully. If necessary,
    dependencies will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new window will appear to manage the domain user logons. You need at least
    the following: **Allow Domain User Logon** and **Create Home Directory**. All
    the other options are not yet possible in Azure AD Domain Services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'YaST will give you a colorful GUI-like interface on the shell, the use of which
    means you can join the machine to the domain. Once you run `sudo yast`, you will
    get a screen as shown here. From the list, use the arrow keys to select **Network
    Services** and then **Windows Domain Membership**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the YaST interface by running the run sudo yast command](img/B15455_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: YaST interface on the Shell'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The best part is that if any dependencies are missing, YaST will prompt you
    to install them, so please go ahead and complete the dependency installation.
    Right after installation, you can enter your domain name and, once you save, you
    will be prompted to enter the username and password, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Providing credentials in YaST to register the machine to Azure AD Domain
    Services](img/B15455_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: Providing credentials to register the machine'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Enter your credentials in the format `user@domain` and then your password.
    Once you complete the process, the SUSE machine will reach out to Azure AD Domain
    Services and register your machine. If joining is successful, you will get a message
    on your screen as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A message prompt indicating successful domain join](img/B15455_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.31: Domain join successful'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can verify by switching the current user to your AD username using the
    `su` command, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using su command to verify the domain join](img/B15455_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.32: Verifying the domain join'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, we have completed joining our Linux machine to Azure AD Domain Services.
    Recently, Microsoft added support for Azure AD sign-in to Linux VMs without the
    need to join the machines to the domain. An agent will be installed on the machine
    to complete the authorization. This will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in with Azure AD Credentials to the Linux VM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another form of identity management is possible with Azure AD. This is a completely
    different identity management system, without LDAP and Kerberos, as discussed
    in the preceding section. In Linux, Azure AD will allow you to use your Azure
    credentials to log into your VM, but has no support at an application level. At
    the time of writing this book, this feature is still in preview. Also, this feature
    is not available in SUSE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use Azure AD, you have to deploy a VM extension, for instance,
    using the Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you have to assign a role, either the `Virtual Machine Administrator
    Login` (with root privileges) or `Virtual Machine User Login` (unprivileged user)
    role, to your Azure AD account, with the scope limited to this VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can set the scope at the subscription level, `--scope /subscriptions/<subcription
    ID>`. By doing so, the role will be inherited by all resources in the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want granular-level access only to a particular VM, you can execute
    the following command (in PowerShell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '`$vm.Id` will give you the scope of the VM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In bash, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This command will query the ID of the VM and is the scope for role assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can log in using your AD credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will be able to see that you are logged into the Linux VM using
    your Azure AD credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Other Security Solutions in Azure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we have discussed how to increase the Linux security level
    and incorporate certain Azure services to improve security. Having said that,
    the list of Azure services that can be used to increase security is very long.
    Some of them are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure AD Managed Identity: Using this, you can create managed identities for
    VMs, which can be used to authenticate any service that supports Azure AD authentication
    ([https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview)).
    Formerly, this service was known as **Managed Service Identity** (**MSI**) which
    is now called as **managed identities for Azure resources**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Key Vault: This can be used to store your keys securely. For example, in Azure
    Disk Encryption, the key will be stored in a key vault and accessed whenever required
    ([https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts](https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Disk Encryption: Disk encryption will help you encrypt the operating
    system disk, as well as the data disk, so as to have additional security for the
    data stored ([https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disk-encryption-overview](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/disk-encryption-overview)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RBAC: RBAC in Azure gives you the ability to assign granular permission to
    your VMs. There are lots of in-built roles available in Azure and you can assign
    one depending upon your security requirements. Also, you can create custom RBAC
    roles to give more granular permissions ([https://docs.microsoft.com/en-us/azure/role-based-access-control/overview](https://docs.microsoft.com/en-us/azure/role-based-access-control/overview)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Security Center** (**ASC**): ASC is a unified infrastructure security
    management system designed to consolidate your security ([https://docs.microsoft.com/en-us/azure/security-center/security-center-intro](https://docs.microsoft.com/en-us/azure/security-center/security-center-intro)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Policy Guest Configuration: This can be used to audit settings inside
    your Linux VM. It has been discussed in detail in *Chapter 8*, *Exploring Continuous
    Configuration Automation*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would recommend that you go through the Microsoft documentation pertaining
    to these services in order to have a better insight into how these can be used
    in your environment to strengthen the overall security aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is a very important topic nowadays. Many reports, books, and so on
    have been written on this subject. In this chapter, we covered several options
    in Linux to increase security levels. All of them come on top of the basic security
    already provided by Azure through network security groups. They are relatively
    easy to implement and will make a big difference!
  prefs: []
  type: TYPE_NORMAL
- en: Central identity management is not only a way of providing users with access
    to the VM, but it's also a part of reducing the security risks. Azure AD Domain
    Services provides, via LDAP and Kerberos, an identity management solution for
    all operating systems and applications that have support for these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8, Exploring Continuous Configuration Automation*, will cover automation
    and orchestration. Please note that all the security measures covered in this
    chapter can be easily orchestrated. Orchestration makes central configuration
    management possible. One of its big advantages is the prevention of mistakes and
    unmanageable configurations. This way, even orchestration is a part of your security
    plan!'
  prefs: []
  type: TYPE_NORMAL
- en: And it would be nice if you are going to create your own VMs, especially if
    you're going to build your own images. We will discuss in the next chapter how
    to build your own images. Also, we will consider the security aspects of pushing
    these images and deploying them in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are going to implement firewalld, what are the methods for configuring
    this firewall?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the reason for using the `--permanent` parameter of `firewall-cmd`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other options are available to restrict network access?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the difference between DAC and MAC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to utilize Linux security modules in a VM running on Azure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which MAC system is available for which distribution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between AppArmor and SELinux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the requirements to be able to join Azure AD Domain Services in regards
    to dependencies and Linux configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the previous chapter, I strongly suggest you visit *Chapter 11*,
    *Troubleshooting and Monitoring Your Workloads*, to read about logging in Linux,
    because often, the `systemctl status` command doesn't provide you with enough
    information. I have also already pointed to the blog by Lennart Poettering, and
    the systemd website.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux security in general, you can start reading the book *Mastering Linux
    Security and Hardening*, by Donald A. Tevault. Many of the topics covered in this
    chapter, and many more besides, are explained in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The firewalld daemon has a project website, [https://firewalld.org](https://firewalld.org),
    with a blog and excellent documentation. For older distributions, the wiki of
    Arch Linux is a good place to start to learn more: [https://wiki.archlinux.org/index.php/iptables](https://wiki.archlinux.org/index.php/iptables).
    And since iptables is utilized by firewalld, it''s a good start before diving
    into the man page of `firewalld.richlanguage`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the details regarding SELinux are covered in guides provided by Red Hat:
    [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/selinux_users_and_administrators_guide/)
    And although it''s slightly out of date, it''s a very good idea to watch this
    video of a Red Hat Summit on YouTube relating to SELinux: [https://www.youtube.com/watch?v=MxjenQ31b70](https://www.youtube.com/watch?v=MxjenQ31b70).'
  prefs: []
  type: TYPE_NORMAL
- en: However, it's more difficult to find good information about AppArmor. There
    is project documentation available at [https://gitlab.com/apparmor/apparmor/wikis/Documentation](https://gitlab.com/apparmor/apparmor/wikis/Documentation),
    and the Ubuntu server guide is a good start. This is available at [https://help.ubuntu.com/lts/serverguide/apparmor.html.en](https://help.ubuntu.com/lts/serverguide/apparmor.html.en).
  prefs: []
  type: TYPE_NORMAL
