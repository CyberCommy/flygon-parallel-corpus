- en: Analyzing Network Traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to some of the basics of analyzing network traffic
    using the pcapy and scapy modules in Python. These modules provide an investigator
    with the ability to write small Python scripts that can investigate network traffic.
    An investigator can write scapy scripts to investigate either realtime traffic
    by sniffing a promiscuous network interface, or load previously-captured pcap
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and injecting packets on the network with the pcapy package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing, analyzing, manipulating, and injecting network packets with the scapy
    package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port-scanning and traceroute in a network with the scapy package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a pcap file with the scapy package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 5` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install a Python distribution on your local machine and have
    some basic knowledge about packets, capturing, and sniffing networks with tools
    such as Wireshark. It is also recommended to use a Unix distribution to facilitate
    the installation and use of scapy and the execution of commands.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and injecting packets with pcapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics of pcapy and how to capture and read
    headers from packets.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to pcapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pcapy is a Python extension module that interfaces with the `libpcap` packet
    capture library. Pcapy enables Python scripts to capture packets on the network.
    Pcapy is highly effective when used in conjunction with other collections of Python
    classes for constructing and packet-handling.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the source code and the latest stable and development version
    at [https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `python-pcapy` on the Ubuntu linux distribution, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Capturing packets with pcapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `open_live` method in the pcapy interface to capture packets
    in a specific device and we can specify the number of bytes per capture and other
    parameters such as promiscuous mode and timeout.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we'll count the packets that are capturing the eht0
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`capturing_packets.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reading headers from packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we are capturing packets in a specific device(`eth0`),
    and for each packet we obtain the header and payload for extracting information
    about Mac addresses, IP headers, and protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`reading_headers.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Capturing and injecting packets with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The analysis of network traffic is the process by which intercept packets can
    be intercepted that are exchanged between two hosts, knowing the details of the
    systems that intervene in the communication. The message and the duration of the
    communication are some of the valuable information that an attacker who is listening
    in the network medium can obtain.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do with scapy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scapy is a Swiss-army knife for network manipulation. For this reason, it can
    be used in many tasks and areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Research in communications networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security tests and ethical hacking to manipulate the traffic generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package-capture, processing, and handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating packages with a specific protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing detailed information about a certain package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet-capturing, crafting, and manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network Traffic Analysis Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing protocols and IDS/IPS testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireless discovery tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scapy advantages and disadvantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are some of the advantages of Scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: Supports multiple network protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its API provides the classes needed to capture packets across a network segment
    and execute a function each time a packet is captured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be executed in the command interpreter mode or it can also be used from
    scripts in Python programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to manipulate network traffic at a very low level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to use protocol stacks and combine them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows us to configure all the parameters of each protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, Scapy has some weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Can't handle a large number of packets simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial support for certain complex protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Scapy` is a module written in Python to manipulate data packages with support
    for multiple network protocols. It allows the creation and modification of network
    packets of various types, implements functions to passively capture and sniff
    packets, and then executes actions on these packets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scapy` is a software specialized in the manipulation of network packets and
    frames. Scapy is written in the Python programming language and can be used interactively,
    with its **CLI (Command-Line Interpreter)**, or as a library in our programs written
    in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scapy installation:** I recommend using Scapy on a Linux system, as it was
    designed with Linux in mind.The newest version of Scapy does support Windows,
    but for the purpose of this chapter, I assume you are using a linux distribution
    that has a fully-functioning Scapy installation. To install Scapy, go to [http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy).
    The installation instructions are perfectly detailed in the official installation
    guide: [https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: Scapy commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scapy provides us with many commands to investigate a network. We can use scapy
    in two ways: interactively within a terminal window or programmatically from a
    Python script by importing it as a library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the commands that may be useful to show in detail the operation of
    scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**ls()**`: Displays all the protocols supported by scapy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**lsc()**`: Displays the list of commands and functions supported by scapy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**conf**`: Displays all configuration options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**help()**`: Displays help on a specific command, for example, help(sniff)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**show()**`: Displays the details of a specific packet, for example, Newpacket.show()'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scapy supports about 300 network protocols. We can have an idea with the **ls()**
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The screenshot shows an execution of the ls() command where we can see some
    of the protocols supported by scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/edfaf3de-5216-4501-a3f3-0028e4b2e7dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the parameters that can be sent in a certain layer if we execute
    the **ls()** command, in parentheses we indicate the layer on which we want more
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows an execution of the **ls(TCP)** command, where we
    can see fields supported by the TCP protocol in scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1804705b-5e6a-46f0-ae6d-4a4521af6678.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `lsc()` command, we can see the functions available in scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b545bf7-fec8-4173-921b-7ac83b913c65.png)'
  prefs: []
  type: TYPE_IMG
- en: Scapy helps us to create custom packets in any of the layers of the TCP/IP protocol.
    In the following example, we create ICMP/IP packets in an interactive Scapy shell.
    The packages are created by layers starting from the lowest layer at the physical
    level (Ethernet) until reaching the data layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the structure scapy manages by layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8b6047ac-e6a8-4c20-ab8f-b688e9039617.png)'
  prefs: []
  type: TYPE_IMG
- en: In Scapy, a layer usually represents a protocol. Network protocols are structured
    in stacks, where each step consists of a layer or protocol. A network pack consists
    of multiple layers, where each layer is responsible for a part of the communication.
  prefs: []
  type: TYPE_NORMAL
- en: A packet in Scapy is a set of structured data ready to be sent to the network.
    Packets must follow a logical structure, according to the type of communication
    you want to simulate. If you want to send a TCP/IP packet, you must follow it
    the protocol rules defined in the TCP/IP standard.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `IP layer()` is configured as a destination IP of 127.0.0.1, which
    refers to the local machine where Scapy is running. If we want the packet to be
    sent to another IP or domain, we will have to configure the IP layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will create a packet in the IP and ICMP layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can create a packet over other layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `show()` methods, we can see information of the detail of a certain
    package. The difference between `show()` and `show2()` is that the `show2()` function
    shows the package as it is sent by the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the structure of a particular package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Scapy creates and analyzes packages layer by layer. The packages in scapy are
    Python dictionaries, so each package is a set of nested dictionaries, and each
    layer is a child dictionary of the main layer. The **summary()** method will provide
    the details of the layers of each package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions, we see the package received in a more friendly and simplified
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sending packets with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To send a package in scapy, we have two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**send():** Sends layer-3 packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sendp():** Sends layer-2 packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `send()` if we do it from layer 3 or IP and trust the routes of
    the operating system itself to send it. We will use `sendp()` if we need control
    at layer 2 (for example, Ethernet).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main arguments for the send commands are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iface:** The interface to send packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inter:** The time, in seconds, that we want to pass between package and package
    sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**loop**: To keep sending packets endlessly, set this to 1\. If it is different
    from 0, send the packet, or list of packages, in an infinite loop until we stop
    it by pressing *Ctrl* + *C*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**packet**: Packet or a list of packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**verbose**: It allows us to change the log level or even deactivate it completely
    (with the value of 0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we send the previous packet in **layer-3** with the send method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To send a **layer-2** packet, we have to add an Ethernet layer and provide
    the correct interface to send the packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `sendp()` function, we send the packet to its corresponding destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the inter and loop options, we can send the packet indefinitely every
    N seconds in the form of a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `sendp (...)` function works exactly like `send (...)` ,the difference is
    that it works in layer 2\. This means that  system routes are not necessary, the
    information will be sent directly through the network adapter indicated as a parameter
    of the function. The information will be sent although there is apparently no
    communication through any system route.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function also allows us to specify the physical or MAC addresses of the
    destination network card. If we indicate the addresses, scapy will try to resolve
    them automatically with both local and remote addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8229382d-c9e7-423e-a855-1fb4eadbb0e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The send and `sendp` functions allow us to send the information we need to the
    network, but it does not allow us to receive the answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to receive responses from the packages we generate, but
    the most useful for the interactive mode is the `sr` family of functions (from
    the English acronym: Send and Receive).'
  prefs: []
  type: TYPE_NORMAL
- en: We can do the same operation with a Python script. First we need import the
    `scapy` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `**scapy_icmp_google.py**` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The family of functions for the send and receive packets include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sr (...):** Send and receive a packet, or list of packages to the network.
    Wait until a response has been received for all sent packets. It is important
    to note that this function works in layer 3\. In other words, to know how to send
    the packages, use the system''s routes. If there is no route to send the package(s)
    to the desired destination, it cannot be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sr1 (...)**: It works the same as the `sr (...)` function except that it
    only captures the first response received and ignores others, if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**srp (...)**: It works the same as the `sr (...)` function but in layer 2\.
    That is to say, it allows us to send the information through a specific network
    card. The information will always be sent, even if there is no route for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**srp1 (...):** Its operation is identical to the `sr1 (...)` function but
    in layer 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**srbt (...)**: Sends information through a Bluetooth connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**srloop (...)**: Allow us to send and receive information `N` times. That
    is, we can tell you to send one package three times and, therefore, we will receive
    the response to the three packages, in consecutive order. It also allows us to
    specify the actions to be taken when a package is received and when no response
    is received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**srploop (...)**: Same as `srloop` but works in layer 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to send and receive packages with the possibility to see the response
    package, the srp1 function can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we build an ICMP packet and send with `sr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3c98aff-84ce-498f-a79d-550ff872e03b.png)'
  prefs: []
  type: TYPE_IMG
- en: This package is the answer to a TCP connection to Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that it has three layers (Ethernet, IP, and TCP):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e4cd29a-9d7d-4782-b8f2-c21fb5f1e509.png)'
  prefs: []
  type: TYPE_IMG
- en: Packet-sniffing with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most networks use broadcasting technology (view info), which means that each
    packet that a device transmits over the network can be read by any other device
    connected to the network.
  prefs: []
  type: TYPE_NORMAL
- en: WiFi networks and networks with a HUB device use this approach, however smarted
    devices such as routers and switches will only route and pass packets to the machines
    available in their route table. More information about broadcast networks can
    be found at [https://en.wikipedia.org/wiki/Broadcasting_(networking)](https://en.wikipedia.org/wiki/Broadcasting_(networking)).
  prefs: []
  type: TYPE_NORMAL
- en: In practice, all computers except the recipient of the message will realize
    that the message is not intended for them and ignore it. However, many computers
    can be programmed to see each message that crosses the network.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features offered by scapy is to sniff the network packets passing
    through a interface. Let's create a simple Python script to sniff traffic on your
    local machine network interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scapy provides a method for sniffing packets and dissecting their contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With the sniff function, we can capture packets in the same way as tools such
    as tcpdump or Wireshark do, indicating the network interface from which we want
    to collect the traffic it generates and a counter that indicates the number of
    packets we want to capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to see each parameter of the sniff function in detail. The
    arguments for the **sniff()** method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**count**: Number of packets to capture, but 0 means infinity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iface**: Interface to sniff; sniff for packets only on this interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**prn**: Function to run on each packet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**store**: Whether to store or discard the sniffed packets; set to 0 when we
    only need to monitor them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**timeout**: Stops sniffing after a given time; the default value is none'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**filter**: Takes BPF syntax filters to filter sniffing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can highlight the `prn` parameter that provides the function to apply to
    each packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/412d3fa6-d502-4715-9680-bdc7a1dc9549.png)'
  prefs: []
  type: TYPE_IMG
- en: This parameter will be present in other many functions and, as can be seen in
    the documentation, refers to a function as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `sniff()` function, this function will be applied to each
    captured packet. In this way, each time the `sniff()` function intercepts a packet,
    it will call this function with the intercepted packet as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality gives us great power, imagine that we want to build a script
    that intercepts all communications and stores all detected hosts in the network.
    Using this feature would be very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we can see the result of executing the `lambda` function
    after capturing packets in the eth0 interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6b4b64e9-85fd-4437-b4ef-3ad8a1fd5a7e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following example, we use the sniff method within the `scapy` module.
    We are using this method for capturing packets at the `eth0` interface. Inside
    the `print_packet` function, we are obtaining the IP layer of the packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`sniff_main_thread.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the following example, we use the sniff method within the `scapy` module.
    This method takes as parameters the interface on which you want to capture the
    packets, and the filter parameter is used to specify which packets you want to
    filter. The prn parameter specifies which function to call and sends the packet
    as a parameter to the function. In this case, our custom function is `sniffPackets`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `sniffPackets` function, we are checking whether the sniffed packet
    has an IP layer, if it has an IP layer then we store the source, destination,
    and TTL values of the sniffed packet and print them out.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`sniff_packets.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using Lamda functions with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another interesting feature of the `sniff` function is that it has the "`prn`"
    attribute, which allows us to execute a function each time a packet is captured.
    It is very useful if we want to manipulate and re-inject data packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want capture n packets for the TCP protocol,we can do that
    with the sniff method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instruction, we are capturing 100 packets for the TCP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the following example, we see how we can apply custom actions on captured
    packets.We define a `customAction` method that takes a packet as a parameter.
    For each packet captured by the `sniff` function, we call this method and increment `packetCount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the** `sniff_packets_customAction.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Also, we can monitor ARP packets with the `sniff` function and **ARP filter.**
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`sniff_packets_arp.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Filtering UDP packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we see how we define a function that will be executed
    every time a packet of type UDP is obtained when making a **DNS request**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be defined from the command line in this way. First we define
    a global variable called `DNS_QUERIES`, and when scapy finds a packet with the
    UDP protocol and port 53, it will call this function to increment this variable,
    which indicates there has been a DNS request in the communications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Port-scanning and traceroute with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we will see a port scanner on a certain network segment. In the
    same way we do port-scanning with nmap, with scapy we could also perform a simple
    port-scanner that tells us for a specific host and a list of ports, whether they
    are open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: Port-scanning with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following example, we see that we have defined a `analyze_port()` function
    that has as parameters the host and port to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`port_scan_scapy.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Traceroute command with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traceroute is a network tool, available in Linux and Windows, that allows you
    to follow the route that a data packet (IP packet) will take to go from computer
    A to computer B.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the packet is sent over the internet, but the route followed by
    the packet may vary, in the event of a link failure or in the case of changing
    the provider connections.
  prefs: []
  type: TYPE_NORMAL
- en: Once the packets have been sent to the access provider, the packet will be sent
    to the intermediate routers that will transport it to its destination. The packet
    may undergo changes during its journey. It is also possible that it never reaches
    its destination if the number of intermediate nodes or machines is too big and
    the package lifetime expires.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we are going to study the possibilities of making
    a traceroute using scapy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using scapy, IP and UDP packets can be built in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To send the package, the `send` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: IP packets include an attribute (TTL) where you indicate the lifetime of the
    packet. In this way, each time a device receives an IP packet, it decrements the
    TTL (package lifetime) by 1 and passes it to the next machine. Basically, it is
    a smart way to make sure that packets do not get into infinite loops.
  prefs: []
  type: TYPE_NORMAL
- en: To implement traceroute, we send a UDP packet with TTL = i for i = 1,2,3, n
    and check the response packet to see whether we have reached the destination and
    we need to continue doing jumps for each host that we reach.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`traceroute_scapy.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see the result of executing the traceroute
    script. Our target is the IP address of 216.58.210.142 and we can see the hops
    until we reach our target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7e8ec4d6-7168-408c-8928-3a733b319b68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, we can see all the machines for each hop until we arrive at our target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02dfb561-eff6-43b3-9ca4-d5b1730eb5c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading pcap files with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics for reading pcap files. PCAP (Packet
    CAPture) refers to the API that allows you to capture network packets for processing.
    The PCAP format is a standard and is used by practically all network-analysis
    tools, such as TCPDump, WinDump, Wireshark, TShark, and Ettercap.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the PCAP format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By analogy, the information captured using this technique is stored in a file
    with the .pcap extension. This file contains frames and network packets and is
    very useful if we need to save the result of a network analysis for later processing.
  prefs: []
  type: TYPE_NORMAL
- en: These files are very useful if we need to save the result of a network analysis
    for later processing or as evidence of the work done.The information stored in
    a .pcap file can be analyzed as many times as we need without the original file
    being altered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scapy incorporates two functions to work with PCAP file, which will allow us
    to read and write about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rdcap ()`**:** Reads and loads a .pcap file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wdcap ()`**:** Writes the contents of a list of packages in a .pcap file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading pcap files with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `rdpcap()` function, we can read a `pcap` file and get a list of packages
    that can be handled directly from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Writing a pcap file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `wrpcap()` function, we can store the captured packets in a pcap file.
    Also, it is possible to write the packets to a pcap file with Scapy. To write
    the packets to a pcap file, we can use the `wrpcap()` method. In the following
    example, we are capturing tcp packets for FTP transmissions and saving this packets
    in a pcap file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sniffing from a pcap file with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `rdpcap()` function, we can read a pcap file and get a list of packages
    that can be handled directly from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the possibility of similar packet capture from the reading of
    a pcap file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Scapy supports the B**PF (Beerkeley Packet Filters)** format, it is a standard
    format for applying filters over network packets. These filters can be applied
    on a set of specific packages or directly on an active capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can format the output of sniff() in such a way that it adapts just to the
    data we want to see and sorts them as we want. We are going to capture traffic
    HTTP and HTTPS with the **"tcp and (port 443 or port 80)"** activated filter and
    using **prn = lamba x: x.sprintf**. We want to show the following data and in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Source IP and origin port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination IP and destination port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flags TCP or Flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload of the TCP segment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see the parameters for the `sniff` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we can see the result of executing the sniff function
    after capturing packets and applying filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a04b900f-9919-4596-a73b-d048281311c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The protocol output is not now TCP, UDP, etc. its hexadecimal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**006 refers to the IP PROTOCOL field**; it refers to the next-level protocol
    that is used in the data part. Length 8 bits. In this case hex (06) (00000110)
    = TCP in decimal would be 6.'
  prefs: []
  type: TYPE_NORMAL
- en: 2, 16, 18, 24, ... are the flags of the TCP header that are expressed, in this
    case in hexadecimal format. For example, 18 would be in binary 11000 which, as
    we already know, would be for activated ACK + PSH.
  prefs: []
  type: TYPE_NORMAL
- en: Network Forensic with scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy is also useful for performing network forensic from SQL injection attacks
    or extracting ftp credentials from a server. By using the Python scapy library,
    we can identify when/where/how the attacker performs the SQL injection. With the
    help of the Python scapy library, we can analyze the network packet's pcap files.
  prefs: []
  type: TYPE_NORMAL
- en: With scapy, we can analyze networks packets and detect whether an attacker is
    performing a SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: We will be able to analyze, intercept, and dissect network packets, as well
    as reuse their content. We have the capacity to manipulate PCAP files with the
    information captured or produced by us.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could develop a simple script for an ARP MITM attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`arp_attack_mitm.py` **file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at  the basics of packet-crafting and sniffing with
    various Python modules, and saw that scapy is very powerful and easy to use. By
    now, we have learned the basics of socket programming and scapy. During our security
    assessments, we may need the raw output and access to basic levels of packet topology
    so that we can analyze the information and make decisions ourselves. The most
    attractive part of scapy is that it can be imported and used to create networking
    tools without going to create packets from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter](f294d743-c9f1-40f5-a9b7-9904d7f634b2.xhtml), we will explore
    programming packages in Python to extract public information from servers with
    services such as shodan.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the scapy function that can capture packets in the same way tools such
    as tcpdump or Wireshark do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to send a packet with scapy indefinitely every five seconds
    in the form of a loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the method that must be invoked with scapy to check whether a certain
    port (port) is open or closed on a certain machine (host), and also show detailed
    information about how the packets are being sent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functions are necessary to implement the traceroute command in scapy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Python extension module interfaces with the libpcap packet capture library?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method in the pcapy interface allows us to capture packets on a specific
    device?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the methods to send a package in Scapy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which parameter of the sniff function allows us to define a function that will
    be applied to each captured packet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which format supports scapy for applying filters over network packets?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the command that allows you to follow the route that a data packet (IP
    packet) will take to go from computer A to computer B?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the mentioned tools and
    the official Python documentation for some of the commented modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.secdev.org/projects/scapy/build_your_own_tools.html](http://www.secdev.org/projects/scapy/build_your_own_tools.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://scapy.readthedocs.io/en/latest/usage.html](http://scapy.readthedocs.io/en/latest/usage.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tools based in scapy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/nottinghamprisateam/pyersinia](https://github.com/nottinghamprisateam/pyersinia)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/adon90/sneaky_arpspoofing](https://github.com/adon90/sneaky_arpspoofing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/tetrillard/pynetdiscover](https://github.com/tetrillard/pynetdiscover)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pyNetdiscover is an active/passive address-reconnaissance tool and ARP Scanner,
    which has as requirements python2.7, and the `scapy`, `argparse`, and `netaddr`
    modules.
  prefs: []
  type: TYPE_NORMAL
