- en: Chapter 11. Networking in Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the appropriate protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing the packets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using socket programming in games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with lag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using synchronized simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using area of interest filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local perception filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern era of video gaming, networking plays a huge role in the overall
    playability of a game. A single player game offers an average of about 15-20 hours
    of gameplay. However, with the multiplayer (networked) feature, the gameplay time
    increases exponentially, as now the users have to play against other human opponents
    and improve their tactics. Whether it is a PC game, console or mobile, having
    multiplayer capabilities has become a common feature these days. From a freemium
    model for games, where the monetization and revenue model is based around in-app
    purchases and ads, it is necessary for the game to have thousands or millions
    or active users per day. That is the only way the game will make money. When we
    speak about multiplayer, we should not fool ourselves by thinking that this is
    restricted to **PvP** (**player versus player**) in real time. It can also be
    asynchronous multiplayer, where the player competes with the *data* from an active
    player's deck but not with the player themselves. It gives the illusion that the
    player is competing against a real player. Also, with the advent of social media,
    networking also plays a role in helping you compete against your friends. For
    example, in *Candy Crush*, after you finish a level, you are shown how your friends
    fared in the same level and who the next friend to beat is. All this adds to the
    hype around the game and compels you to keep playing it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a technical point of view, the entire networking model is divided into
    multiple layers. This model is also referred to as the **OSI** (**Open Systems
    Interconnection**) model. Each layer has a special significance and must be understood
    properly to be able to interact with other layers of the topology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to understand the different layers
    of the networking topology. Look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/4929_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the OSI model, we have to look at the model from the bottom of
    the stack to the top. The layers of the OSI model are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical layer**: This establishes the actual physical connection to the
    network. This is defined by whether we are using copper wire or fiber optics.
    It defines the network topology that is used, ring or bus, and so on. It also
    defines the transmission mode: whether it is simplex, half duplex, or full duplex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data link layer**: This provides the actual link between two connected nodes.
    The data link layer has two sublayers: the **MAC** layer (**Media** **Access Control**)
    and the **LLC** layer (**Logical Link Control**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network layer**: This layers provides the functional means of transfer of
    variable length data called **datagrams**. The transfer happens from one connected
    node to another on the same network. This forms the IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport layer**: This layer also provides the functional means of transferring
    data. The data is transferred from a source to a destination, travelling via one
    or more networks. Some of the protocols used here are TCP and UDP. **TCP** is
    the **transfer control protocol** and is a secured connection. **UDP** is the
    **user datagram protocol** and is the less secure one. In video games, we use
    both TCP and UDP protocols. When there is a situation where the user has to log
    in to the server, we use TCP as it is more secure, because the next information
    from the client is not sent unless there is an acknowledgement from the server
    concerning the previous data. It can be slow, however, so if security is more
    important than speed, we use TCP. After the user logs in, the game starts after
    other players have joined. Now we use UDP for the majority of situations, as speed
    is more important than security and a few dropped packets could have a huge impact.
    UDP packets are not always received as there is no acknowledgement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session layer**: This layer controls the connections between the network
    and the remote computer. This layer is responsible for establishing, managing,
    and terminating a connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Presentation layer**: This layer controls the different semantics that need
    to be established between the connections. All the encryption logic is written
    in this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: This layer deals with the communication with the software
    application itself. This is the closest layer from the end user''s point of view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the appropriate protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In games, most of the time there is an important decision that must be made:
    whether to use TCP or UDP. The decision often ends up in favor of UDP, but still
    it is important to understand the difference between the two.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how easy it is to make a decision on whether
    to use TCP or UDP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the system require guaranteed delivery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a requirement for retransmission?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the system require any handshaking mechanism?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of congestion control does it need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is speed a consideration in the system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP and UDP are built on top of the IP layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A TCP connection is considered reliable because there is a two-way handshake
    system enabled. Once the message is delivered to the endpoint, an acknowledgement
    message is sent out. It supports various other services as well, such as congestion
    control and multiplexing. The fact that TCP is also full duplex makes it quite
    a potent connection to use. The way it handles the reliable transfer of data is
    through byte sequence numbers. It sets a timeout function and, based on timeouts,
    it can decide whether a package has been delivered or not. The following diagram
    shows how the handshaking protocol is established:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another mechanism for TCP is the sliding window mechanism, which guarantees
    the reliable delivery of data. It ensures that the data packets are delivered
    in a sequential manner and a flow control between the sender and receiver is established.
  prefs: []
  type: TYPE_NORMAL
- en: UDP is used when we are not too concerned about the data packets being delivered
    out of order. The main concern is how fast the packets are delivered. There is
    no reliability and no guarantee that the packets will be delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Applications that require ordered delivery must restore datagram ordering themselves.
    Datagrams can be written to a target address without knowing if it exists or is
    listening. Messages can also be broadcast to all hosts on a particular subnet.
    *DOOM* did this. Sometimes, if we require minimal reliability, UDP is open to
    adding that functionality. At that point it is also referred to as reliable UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing the packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serialization is a key feature to have in a networking system. The process of
    serialization involves converting a message or data to a format that can be transmitted
    over the network, and then decoding it. There are a variety of ways to serialize
    and deserialize data, and it comes down to a matter of personal choice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine and Visual Studio. No other requirements
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to serialize data. Create a source
    file and derive it from the serializer class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, to serialize is to convert the data to a format that can
    be transferred. We can do this by using the Google API, or using the JSON format
    or YAML. In this example, we have used an XML serializer originally written by
    Lothar Perr. The original source can be found at [http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus](http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus).
    The whole idea behind the program is that we convert the data to an XML format.
    In the class serializable data, we publicly derive it from the serializable class.
    We create a constructor to register all the data elements and we create the different
    data elements that we want to be serialized. The data elements are of the type
    `xString` class. In the constructor, we register each of the data elements. Finally,
    from the client side, we assign the correct data to be sent and, using the XML
    serializer class and tinyxml, we generate the required XML. Finally, this XML
    will be sent across the network and on receipt, it will be decoded using the same
    logic. XML can sometimes be considered quite heavy and cumbersome for games.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, it is advisable to use JSON. Some modern engines, such
    as Unity3D and Unreal Engine, already have an inbuilt JSON parser which could
    be used to serialize the data. However, XML still continues to be an important
    format. An example of a possible output from our code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using socket programming in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Socket programming is one of the earliest mechanisms for transferring data between
    end-to-end connections. Even now, if you are comfortable writing socket programming,
    it is a much better option for a relatively small game than using third party
    solutions, as they add a lot of extra space.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to write sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When two applications are communicating with each other on different machines,
    one end of that communication channel is often described as the socket. It is
    a combination of an IP address and a port. As we use signals or pipes to communicate
    in an inter-process communication environment on different machines, there is
    a need for sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '**Berkley Sockets** (**BSD**) was the first internet socket API developed.
    Developed at the University of Berkley, California, and given freely to all Berkley
    System distributions of UNIX, it is present on all modern operating systems, which
    are UNIX variants, including OS X and Linux. Windows Sockets is based on BSD sockets
    and provides additional functionality to comply with the regular Windows programming
    model. Winsock2 is the newest API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common domains are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AF UNIX**: This address format is UNIX pathname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AF INET**: This address format is host and port number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The various protocols can be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP/IP (virtual circuits): SOCK_STREAM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'UDP (datagram): SOCK_DGRAM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the steps to set up a simple socket connection:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind the socket to an address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for input/output to be ready on the socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read and write to/from the socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from step 3 until you are done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are explained here with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int socket(domain, type, protocol)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter `domain` should be set to `PF_INET` (protocol family) and the
    `type` is the connection type that it should be using. Use `SOCK_STREAM` for a
    byte stream socket, whereas `SOCK_DGRAM` is used for a datagram (packet) socket.
    `protocol` is the Internet protocol that is in use. `SOCK_STREAM` would normally
    give `IPPROTO_TCP`, and `SOCK_DGRAM` would normally give `IPPROTO_UDP`.
  prefs: []
  type: TYPE_NORMAL
- en: '`int sockfd;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `socket()` function returns a socket descriptor for use in later system
    calls or `-1`. When the protocol is set to `0`, the socket chooses the correct
    protocol based on the type specified.
  prefs: []
  type: TYPE_NORMAL
- en: '`int bind(int Socket, struct sockaddr *myAddress, int AddressLen )`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function `bind()` ties the socket to a local address. Socket is the socket
    descriptor. `myAddress` is the local IP address and port. The `AddressSize` parameter
    gives the size (in bytes) of the address and `bind()` returns `-1` on error.
  prefs: []
  type: TYPE_NORMAL
- en: '`struct sockaddr_in {`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`struct sockaddr_in` is a parallel structure which makes it easy to reference
    elements of the socket address. `sin_port` and `sin_addr` must be in Network Byte
    Order.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have correctly set up the sockets, the next step is to create the correct
    server and client architecture. Sending data is pretty simple and just involves
    a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows with Visual
    Studio installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to send data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function that is used to communicate over the network is called `sendto`.
    This is declared as `int sendto (int sockfd, const void *msg, int len, int flags);`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sockfd` is the socket descriptor you want to send data to (returned by `socket()`
    or got from `accept()`), whereas `msg` is a pointer to the data you want to send.
    `len` is the length of that data in bytes. For simplicity, we can set that `flag`
    to `0` for now. `sendto()` returns the number of bytes actually sent (it may be
    less than the number you told it to send) or -`1` on error. By using just this
    function, you are able to send messages or data from one connection point to the
    other. This function can be used to send data across the network using the inbuilt
    Winsock functionality. The `send` function is used for streams of data and hence
    used for TCP. If we are to use datagrams and connectionless protocols, then we
    need to use the `sendto` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have correctly set up the sockets and sent the data, the next step
    is to receive the data. Receiving data is pretty simple and just involves a few
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to receive data over the network.
    There are two ways to do it, either by using the `recv` function or by using the
    `recvfrom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like the `send` function, only one function is used to receive the data
    over the network, which can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`sockfd` is the socket descriptor to read from. The next parameter, `buf`,
    is the buffer to read the information into, whereas `len` is the maximum length
    of the buffer. The next parameter, `recv()`, returns the number of bytes actually
    read into the buffer or `-1` on error. If `recv()` returns `0`, the remote side
    has closed the connection on you.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this line of code, we can receive data over the network. If the data is
    serialized while sending, we have to then take the data and deserialize the data
    at this point. This process will vary based on the method used to serialize the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with lag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major problems that occurs in a networked game is latency or lag.
    When two players are playing against each other, and one is on a high-speed network
    and the other is on a very low-speed network, how do we update the data? We need
    to update it in such a way that it looks normal to both players. No player should
    get an undue advantage because of this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you will see a few techniques for countering lag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a networked game will have the following update loop. We need to
    figure out, from the loop structure, what is the best way to counter lag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most computer games, when networking is implemented, a specific type of
    client-server architecture is chosen. Often, an authoritative server is chosen.
    This means the server dictates the time, results, and other factors. The client
    is basically *dumb* and all it does is a simulation based on data from the server.
    Now let us consider that two players are playing a multiplayer FPS game. One of
    them is on a high-speed connection and the other connection is very slow. So,
    if the client is dependent on the server for its updates, it will be very difficult
    to accurately render the positions of the players on the client side. Let''s say
    `UserA` is on a high-speed connection whereas `UserB` is on a low-speed one. `UserA`
    fires a bullet at `UserB`. Note `UserA` and `UserB` are also moving in the world
    space. How do we calculate the position of the bullet and the position of each
    individual player? If we render exactly the information that is coming from the
    server, it will not be accurate as `UserA` would have already moved to a new position
    by the time `UserB` gets an update. To counter this, there are two commonly used
    solution. One is called client-side prediction. The other method is further divided
    into two more techniques: interpolation and extrapolation. Note that the round-trip
    time will be quite acceptable if the computers are connected over LAN. All the
    problems that are being discussed focus on networking over the Internet.'
  prefs: []
  type: TYPE_NORMAL
- en: In client-side prediction, the *dumb* factor is taken out of the client and
    the client starts predicting, based on previous movement inputs, what the next
    position and animation states will be. Finally, when it gets an update from the
    server, the server will correct the mistakes and the position will be transformed
    to the currently received one. There are loads of problems with this system. If
    the prediction is wrong, there will be a big jitter as the position is changed
    to the right one. Also, let us consider sound and VFX effects. If the client at
    `UserA` predicted that `UserB` was walking and the footsteps sound was played,
    and later the server informed it that `UserB` was actually in water, how do we
    suddenly rectify that mistake? The same goes for VFX effects and states. This
    system was used in a lot of the *Quake* worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second system has two parts: extrapolation and interpolation. In extrapolation,
    we render ahead of time. This is in some way similar to prediction. It takes the
    last known update from the server and then simulates forward in time. Thus, if
    you are lagging 500 milliseconds behind, and the last update you received was
    that the other player was running 300 units per second perpendicular to your view,
    then the client could assume that in *real time* the player has moved 150 units
    straight ahead from their last known position. The client could then just draw
    the player at that extrapolated position and the local player could still more
    or less aim right at the other player. However, the problem with this system is
    that it will rarely happen like that. The movement of the player may change, the
    state may change and hence this system should be avoided in most cases.'
  prefs: []
  type: TYPE_NORMAL
- en: In interpolation, we always render objects in the past. For instance, if the
    server is sending 25 updates per second (exactly) of the world state, then we
    might impose 40 milliseconds of interpolation delay in our rendering. Then, as
    we render frames, we interpolate the position of the object between the last updated
    position and the position one update over that 40 milliseconds. Interpolation
    can be done by using the inbuilt lerp function in C++. As the object gets to the
    last updated position, we receive a new update from the server (since 25 updates
    per second means that the updates come in every 40 milliseconds) and we can start
    moving toward this new position over the next 40 milliseconds. The following picture
    shows the difference in positions of the hitbox from the server and the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the packet does not arrive after 40 milliseconds, that is, there is a packet
    drop, then we have two options. The first option is to extrapolate using the method
    described above. The other option is to make the player go to an idle state till
    the next packet is received from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using synchronized simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a multiplayer game, there may be hundreds or thousands of computers connected
    at the same time. All of the computers will have different configurations. Speed
    will vary on all these computers. So the questions is, how do we synchronize the
    clock over all these systems so that they are all in sync?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will look at, from a theoretical perspective, the two ways
    to synchronize clocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: Method 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a message to `UserA`. Note the time till he receives the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a message to `UserB`. Note the time again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the median based on the values to decide an update time for updating
    the clock for both computers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let the server do most of the calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let the client do some local calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the client receives the update from the server, then either correct its
    mistakes or interpolate based on the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are trying to synchronize the clock, there are two methods. One method
    is that the server tries to find a median time to synchronize all the clocks.
    To do this, we can include the mechanics in the game design itself. The server
    needs to find out the response time of each client machine, so it has to send
    out messages. These messages can be to press *R* when ready, or a map is loaded
    on the client machine and the server takes a note of the time. Finally, when it
    has got a time from all the machines, it calculates a median and then updates
    the clock for all the machines at that time. The more messages the server sends
    out to the machines to calculate this median, the more accurate it will be. However,
    this in no way guarantees synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a better method is that the server does all the calculations and
    the client does some local calculations as well, using techniques described in
    previous recipes. Finally, when the server sends an update to the client, the
    client can correct itself or interpolate to get the desired result. This is a
    much better result and a much better system to have.
  prefs: []
  type: TYPE_NORMAL
- en: Using area of interest filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are writing a networking algorithm, we need to decide on the various
    objects or states that need updating to or from the server. The higher the number
    of objects, the more time it will take to serialize and send the data across.
    Therefore, there is a need to prioritize what needs to be updated every frame
    and which objects can wait for a few more cycles to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create area of interest filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a list of all objects in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a parameter to each object denoting their priority.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on that priority number, pass it on to the update logic of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a game, we need to define the objects in a certain priority order. The priority
    order determines whether they should be updated now or at a later time. The objects
    that require prioritization depend a lot on the game design and a bit of research.
    For example, in an FPS game, the objects with high priority would be the person
    that the user is currently shooting at, the ammunition lying nearby, and of course
    the enemies in close proximity and their positions. This may be different in the
    case of an RPG or an RTS, so it definitely varies from one game to another.
  prefs: []
  type: TYPE_NORMAL
- en: After we have tagged each object with a priority number, we can tell the update
    loop to just use the objects that are priority level 1 and 2 for per-frame updates,
    and use objects that are priority level 3 and 4 for late updates. This structure
    can also be modified by creating some sort of priority queue. From the queue,
    objects are popped out based on different update logic. The lower priority objects
    are also synced but at a later time, not in the current frame.
  prefs: []
  type: TYPE_NORMAL
- en: Using local perception filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is yet another method to combat lag in networked games. This entire concept
    is mathematically based on the concept of perception. The basis of it is that
    if objects update and render correctly locally to a player, then we can create
    an illusion of realism, hence the name local perception filter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will understand the theoretical concept of how easy it is
    to implement bullet time. Take a look at the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the velocity local to the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accelerate the bullet when it starts and slow it down as it reaches the remote
    player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the remote player's point of view, the bullet should appear to have been
    shot at a higher speed than normal speed and then slow down to normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Local perception filters are also called bullet time, and were used for the
    first time in the movie *The Matrix*. Since then, they have been used in a wide
    range of games. It is quite easy to do in single player mode; however, in multiplayer
    it gets a bit more complex as it involves slowing down the rendering. Essentially,
    the process is to increase and reduce the speed of passive entities when they
    are near local and remote players. It is a method used to hide communication delays
    in networked virtual environments and was introduced in *A local perception filter
    for distributed virtual environments*, *P.M. Sharkey*, (page 242-249). For simplicity,
    we will call local players *p*, remote players *r*, and passive entities, such
    as bullets, *e*. Let us say that *d(i,j)* is delay, *delta(i,j)* is distance,
    and we get the following equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a graphical format, this can be explained by looking at the following graph.
    So with respect to *p*, it goes slow uphill and then fast downhill. With respect
    to *r*, it is faster at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One major limitation of the method is that this cannot be used for *insta-hit*
    weapons.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that when *e* reaches r, *p*'s view of e is not there yet, but
    *e* will speed up anyway in *p*'s view. To tackle this, we introduce a shadow
    *r*, which buffers *p*'s view of the speedup process.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the buffer, we will get the following revised graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So at the top, won''t speed up until *r* is reached, and at the bottom it starts
    to show *e* at postion *p*. This can also be viewed as a demo at the following
    URL: [http://mikolalysenko.github.io/local-perception-filter-demo/](http://mikolalysenko.github.io/local-perception-filter-demo/).'
  prefs: []
  type: TYPE_NORMAL
