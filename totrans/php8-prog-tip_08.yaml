- en: '*Chapter 6*: Understanding PHP 8 Functional Differences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about potential backward-compatible breaks at
    the PHP 8 command, or functional, level. This chapter presents important information
    that highlights potential pitfalls when migrating existing code to PHP 8\. The
    information presented in this chapter is critical to know so that you can produce
    reliable PHP code. After working through the concepts in this chapter, you'll
    be in a better position to write code that produces precise results and avoids
    inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning key advanced string handling differences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding PHP 8 string-to-numeric comparison improvements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling differences in arithmetic, bitwise, and concatenation operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking advantage of locale independence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling arrays in PHP 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering changes in security functions and settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An x86_64-based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 gigabyte (GB) of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 500 kilobits per second (Kbps) or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section in [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you restored the sample code for this book as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices.
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin our discussion by examining the differences in string handling
    introduced in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Learning key advanced string handling differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String functions in general have been tightened and normalized in PHP 8\. You
    will find that usage is more heavily restricted in PHP 8, which ultimately forces
    you to produce better code. We can say that the nature and order of string function
    arguments is much more uniform in PHP 8, which is why we say that the PHP core
    team has normalized usage.
  prefs: []
  type: TYPE_NORMAL
- en: These improvements are especially evident when dealing with numeric strings.
    Other changes in PHP 8 string handling involve minor changes to arguments. In
    this section, we introduce you to the key changes in how PHP 8 handles strings.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand not only the handling improvements introduced in
    PHP 8 but also to understand the deficiencies in string handling prior to PHP
    8.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first have a look at an aspect of PHP 8 string handling in functions that
    search for embedded strings.
  prefs: []
  type: TYPE_NORMAL
- en: Handling changes to the needle argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A number of PHP string functions search for the presence of a substring within
    a larger string. These functions include `strpos()`, `strrpos()`, `stripos()`,
    `strripos()`, `strstr()`, `strchr()`, `strrchr()`, and `stristr()`. All of these
    functions have these two parameters in common: the **needle** and the **haystack**.'
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between the needle and the haystack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To illustrate the difference between the needle and the haystack, have a look
    at the function signature for `strpos()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`$haystack` is the target of the search. `$needle` is the substring to be sought.
    The `strpos()` function returns the position of the substring within the search
    target. If the substring is not found, the Boolean `FALSE` is returned. The other
    `str*()` functions produce different types of output that we will not detail here.'
  prefs: []
  type: TYPE_NORMAL
- en: Two key changes in how PHP 8 handles the needle argument have the potential
    to break an application migrated to PHP 8\. These changes apply to situations
    where the needle argument is not a string or where the needle argument is empty.
    Let's have a look at non-string needle argument handling first.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with non-string needle arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your PHP application might not be taking the proper precautions to ensure that
    the needle argument to the `str*()` functions mentioned here is always a string.
    If that is the case, in PHP 8, the needle argument will now *always be interpreted*
    as a string rather than an ASCII code point.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to supply an ASCII value, you must use the `chr()` function to convert
    it to a string. In the following example, the ASCII value for `LF` (`"\n"`) is
    used instead of a string. In PHP 7 or below, `strpos()` performs an internal conversion
    before running the search. In PHP 8, the number is simply typecast into a string,
    yielding unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that searches for the presence of `LF` within a string.
    However, note that instead of providing a string as an argument, an integer with
    a value of `10` is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the code sample running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the results of the same code block running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, comparing the output in PHP 7 with the output in PHP 8, the
    same code block yields radically different results. This is an extremely difficult
    potential code break to spot as no `Warnings` or `Errors` are generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice is to apply a `string` type hint to the needle argument of
    any function or method that incorporates one of the PHP `str*()` functions. If
    we rewrite the previous example, the output is consistent in both PHP 7 and PHP
    8\. Here is the same example rewritten using a type hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in either version of PHP, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By declaring `strict_types=1`, and by adding a type hint of `string` before
    the `$needle` argument, any developer who misuses your code receives a clear indication
    that this practice is not acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at what happens in PHP 8 when the needle argument is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Handling empty needle arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another major change in the `str*()` function is that the needle argument can
    now be empty (for example, anything that would make the `empty()` function return
    `TRUE`). This presents *significant* potential for backward compatibility breaks.
    In PHP 7, if the needle argument is empty, the return value from `strpos()` would
    be the Boolean `FALSE`, whereas, in PHP 8, the empty value is first converted
    to a string, thereby producing entirely different results.
  prefs: []
  type: TYPE_NORMAL
- en: It's extremely important to be aware of this potential code break if you plan
    to update your PHP version to 8\. An empty needle argument is difficult to spot
    when reviewing code manually. This is a situation where a solid set of unit tests
    is needed to ensure a smooth PHP migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the potential problem, consider the following example. Assume
    that the needle argument is empty. In this situation, a traditional `if()` check
    to see whether the `strpos()` result is not identical to `FALSE` produces different
    results between PHP 7 and 8\. Here is the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a function that reports whether or not the needle value is
    found in the haystack using `strpos()`. Note the strict type check against the
    Boolean `FALSE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the haystack as a string with letters and numbers. The needle
    argument is provided in the form of an array of values that are all considered
    empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in PHP 7 appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After a set of `Warnings`, the final output appears. As you can see from the
    output, the return value from `strpos($haystack, $search)` is consistently the
    Boolean `FALSE` in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output running the same code in PHP 8, however, is radically different.
    Here is the output from PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 8, the empty needle argument is first silently converted to a string.
    None of the needle values return the Boolean `FALSE`. This causes the function
    to report that the needle has been found. This is certainly not the desired result.
    In the case of the number `0`, however, it is contained in the haystack, resulting
    in a value of `19` being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how this problem might be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the problem using str_contains()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The intent of the code block shown in the previous section is to determine
    whether or not the haystack contains the needle. `strpos()` is not the right tool
    to accomplish this task! Have a look at the same function using `str_contains()`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then run the modified code in PHP 8, we get results similar to those
    received from PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You might ask why is it that the number `0` is not found in the string? The
    answer is that `str_contains()` does a stricter search. Integer `0` is not the
    same as the string `"0"`! Let's now have a look at the `v*printf()` family; another
    family of string functions that exerts stricter control over its arguments in
    PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with v*printf() changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `v*printf()` family of functions is a subset of the `printf()` family of
    functions that include `vprintf()`, `vfprintf()`, and `vsprintf()`. The difference
    between this subset and the main family is that the `v*printf()` functions are
    designed to accept an array as an argument rather than an unlimited series of
    arguments. Here is a simple example that illustrates the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a set of arguments that will be inserted into a pattern, `$patt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then execute a `printf()` statement using a series of arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the arguments as an array, `$arr`, and use `vprintf()` to produce
    the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the program running in PHP 8\. The output is the same
    running in PHP 7 (not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output of both functions is identical. The only usage difference
    is that `vprintf()` accepts the parameters in the form of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Prior versions of PHP allowed a developer to play *fast and loose* with arguments
    presented to the `v*printf()` family of functions. In PHP 8, the data type of
    the arguments is now strictly enforced. This only presents a problem where code
    controls do not exist to ensure that an array is presented. Another even more
    important difference is that PHP 7 will allow `ArrayObject` with `v*printf()`,
    whereas PHP 8 will not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown here, PHP 7 issues a `Warning`, whereas PHP 8 throws an
    `Error`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the pattern and the source array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a test data array in order to test which arguments are accepted
    by `vsprintf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `foreach()` loop that goes through the test data and exercises
    `vsprintf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, both the array and `ArrayObject` arguments
    are accepted in PHP 7\. Here is the same code example running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the PHP 8 output is much more consistent. In PHP 8, the `v*printf()`
    functions are strictly typed to accept only an array as an argument. Unfortunately,
    there's a real possibility you may have been using `ArrayObject`. This is easily
    addressed by simply using the `getArrayCopy()` method on the `ArrayObject` instance,
    which returns an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rewritten code that works in both PHP 7 and PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea where to look for a potential code break when using
    the `v*printf()` functions, let's turn our attention to differences in how string
    functions with a null length argument work in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Working with null length arguments in PHP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP 7 and earlier, a `NULL` length argument resulted in an empty string.
    In PHP 8, a `NULL` length argument is now treated the same as if the length argument
    is omitted. Functions affected include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`substr()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substr_count()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substr_compare()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iconv_substr()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the example shown next, PHP 7 returns an empty string whereas PHP 8 returns
    the remainder of the string. This has a high potential for a code break if the
    result of the operation is used to confirm or deny the existence of the substring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a haystack and needle. We then run `strpos()` to get the position
    of the needle in the haystack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we pull out the substring, deliberately leaving the length argument undefined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, PHP 7 issues a `Notice`. However, as an empty string is returned
    due to the `NULL` length argument, the search result is incorrect. Here is the
    same code running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: PHP 8 issues a `Warning` and returns the remainder of the string. This is consistent
    with the behavior where the length argument is entirely omitted. If your code
    relies upon an empty string being returned, a potential code break exists after
    a PHP 8 update.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at another situation where PHP 8 has made string handling
    more uniform in the `implode()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Examining changes to implode()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two widely used PHP functions perform array to string conversion and the reverse:
    `explode()` converts a string to an array, and `implode()` converts an array to
    a string. However, there lurks a deep dark secret with the `implode()` function:
    its two parameters can be expressed in any order!'
  prefs: []
  type: TYPE_NORMAL
- en: Please bear in mind that when PHP was first introduced in 1994, the initial
    goal was to make it as easy to use as possible. This approach succeeded, to the
    point where PHP is the language of choice on over 78% of all web servers today
    according to a recent survey of server-side programming languages conducted by
    w3techs. (https://w3techs.com/technologies/overview/programming_language)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the interests of consistency, it makes sense to align the parameters
    of the `implode()` function with its mirror twin, `explode()`. Accordingly, arguments
    supplied to `implode()` must now be in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`implode(<GLUE STRING>, <ARRAY>);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code example that calls the `implode()` function with arguments
    in either order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the PHP 7 output below, both echo statements produce results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, only the first statement succeeds, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It will be extremely difficult to spot where `implode()` is receiving parameters
    in the wrong order. The best way to be forewarned prior to a PHP 8 migration would
    be to make a note of all classes of PHP files that use `implode()`. Another suggestion
    would be to take advantage of the PHP 8 *named arguments* feature (covered in
    [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing New
    PHP 8 OOP Features*).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about constants usage in PHP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the truly outrageous capabilities of PHP prior to version 8 was the ability
    to define *case-insensitive* constants. In the beginning, when PHP was first introduced,
    many developers were writing lots of PHP code with a notable absence of any sort
    of coding standard. The objective at the time was just to *make it work*.
  prefs: []
  type: TYPE_NORMAL
- en: In line with the general trend toward enforcing good coding standards, this
    ability was deprecated in PHP 7.3 and removed in PHP 8\. A backward-compatible
    break might appear if you are using `define()` with the third parameter set to
    `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example shown here works in PHP 7, but not entirely in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, all lines of code work as written. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the third argument of `define()` was deprecated in PHP 7.3\.
    Accordingly, if you run this code example in PHP 7.3 or 7.4, the output is identical
    with the addition of a `Deprecation` notice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, however, quite a different result is produced, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, lines 7, 8, and 9 produce the expected result. The last
    line, however, throws a fatal `Error`, because constants in PHP 8 are now case-sensitive.
    Also, a `Warning` is issued for the third `define()` statement as the third parameter
    is ignored in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea about key string handling differences introduced in PHP
    8\. We next turn our attention to changes in how numeric strings are compared
    with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP 8 string-to-numeric comparison improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing two numeric values has never been an issue in PHP. A comparison between
    two strings is also not an issue. A problem arises in non-strict comparisons between
    strings and numeric data (hardcoded numbers, or variables containing data of the
    `float` or `int` type). In such cases, PHP will *always* convert the string to
    a numeric value if a non-strict comparison is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The *only* time a string-to-numeric conversion is 100% successful is when the
    string only contains numbers (or numeric values such as plus, minus, or the decimal
    separator). In this section, you learn how to protect against inaccurate non-strict
    comparisons involving strings and numeric data. Mastering the concepts presented
    in this chapter is critical if you wish to produce code with consistent and predictable
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the details of string-to-numeric comparisons, we need to
    first gain an understanding of what is meant by a non-strict comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about strict and non-strict comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of **type juggling** is an essential part of the PHP language. This
    capability was built into the language literally from its first day. Type juggling
    involves performing an internal data type conversion before performing an operation.
    This ability is critical to the success of the language.
  prefs: []
  type: TYPE_NORMAL
- en: PHP was originally devised to perform in a web environment and needed a way
    to handle data transmitted as part of an HTTP packet. HTTP headers and bodies
    are transmitted as text and are received by PHP as strings stored in a set of
    **super-globals**, including `$_SERVER`, `$_GET`, `$_POST,` and so forth. Accordingly,
    the PHP language needs a quick way to deal with string values when performing
    operations that involve numbers. This is the job of the type-juggling process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **strict comparison** is one that first checks the data type. If the data
    types match, the comparison proceeds. Operators that invoke a strict comparison
    include `===` and `!==`, among others. Certain functions have an option to enforce
    a strict data type. One example is `in_array()`. If the third argument is set
    to `TRUE`, a strict-type search ensues. Here is the method signature for `in_array()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`in_array(mixed $needle, array $haystack, bool $strict = false)`'
  prefs: []
  type: TYPE_NORMAL
- en: A **non-strict comparison** is where no data type check is made prior to comparison.
    Operators that perform non-strict comparisons include `==`, `!=`, `<`, and `>`,
    among others. It's worth noting that the `switch {}` language construct performs
    non-strict comparisons in its `case` statements. Type juggling is performed if
    a non-strict comparison is made that involves operands of different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a detailed look at numeric strings.
  prefs: []
  type: TYPE_NORMAL
- en: Examining numeric strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **numeric string** is a string that contains only numbers or numeric characters,
    such as the plus sign (`+`), minus sign (`-`), and decimal separator.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that PHP 8 internally uses the period character (`.`) as
    the decimal separator. If you need to render numbers in locales that do not use
    the period as a decimal separator (for example, in France, the comma (`,`) is
    used as the decimal separator), use the `number_format()` function (see https://www.php.net/number_format).
    Please have a look at the *Taking advantage of locale independence* section in
    this chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric strings can also be composed using **engineering notation** (also called
    **scientific notation**). A **non-well-formed** numeric string is a numeric string
    containing values other than digits, the plus sign, minus sign, or decimal separator.
    A **leading-numeric** string starts with a numeric string but is followed by non-numeric
    characters. Any string that is neither *numeric* nor *leading-numeric* is considered
    **non-numeric** by the PHP engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous versions of PHP, type juggling inconsistently parsed strings containing
    numbers. In PHP 8, only numeric strings can be cleanly converted to a number:
    no leading or trailing whitespace or other non-numeric characters can be present.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, have a look at the difference in how PHP 7 and 8 handle numeric
    strings in this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, PHP 7 considers a string with a trailing space
    to be non-well-formed. However, a string with a *leading* space is considered
    well-formed and passes through without generating a `Notice`. A string with non-whitespace
    characters is still processed but merits a `Notice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same code example running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: PHP 8 is much more consistent in that numeric strings that contain either leading
    or trailing spaces are treated equally, and no `Notices` or `Warnings` are generated.
    However, the last string, formerly a `Notice` in PHP 7, now generates a `Warning`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read about numeric strings in the PHP documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.php.net/manual/en/language.types.numeric-strings.php
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on type juggling, have a look at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.php.net/manual/en/language.types.type-juggling.php
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what is considered a well-formed and non-well-formed
    numeric string, let's turn our attention to the more serious issue of potential
    backward-compatible breaks when dealing with numeric strings in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting backward-compatible breaks involving numeric strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must understand where there is potential for your code to break following
    a PHP 8 upgrade. In this subsection, we show you a number of extremely subtle
    differences that can have large consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Potential code breaks could surface any time a non-well-formed numeric string
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: With `is_numeric()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a string offset (for example, `$str['4x']`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With bitwise operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When incrementing or decrementing a variable whose value is a non-well-formed
    numeric string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some suggestions to fix your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider using `trim()` on numeric strings that might include leading or trailing
    white space (for example, numeric strings embedded within posted form data).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code relies upon strings that start with a number, use an explicit typecast
    to ensure that the number is correctly interpolated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not rely upon an empty string (for example, `$str = ''`) to cleanly convert
    to 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this following code example, a non-well-formed string with a trailing space
    is assigned to `$age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this code in PHP 7, `is_numeric()` returns `TRUE`. Here is the
    PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when we run this code in PHP 8, `is_numeric()` returns `FALSE`
    as the string is not considered numeric. Here is the PHP 8 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, string handling differences between PHP 7 and PHP 8 can cause
    applications to behave differently, with potentially disastrous results. Let's
    now have a look at inconsistent results involving well-formed strings.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with inconsistent string-to-numeric comparison results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete a non-strict comparison involving string and numeric data, the PHP
    engine first performs a type-juggling operation that internally converts the string
    to a number before performing the comparison. Even a well-formed numeric string,
    however, can yield results that would be viewed as nonsensical from a human perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, have a look at this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we perform a non-strict comparison between a variable, `$zero`, with
    a value of zero and a variable, `$string`, with a value of ABC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following non-strict comparison uses `in_array()` to locate a value of
    zero in the `$array` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we perform a non-strict comparison between a leading-numeric string,
    `42abc88`, and a hardcoded number, `42`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The results running in PHP 7 defy human comprehension! Here are the PHP 7 results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: From a human perspective, none of these results make any sense! From the computer's
    perspective, on the other hand, it makes perfect sense. The string `ABC`, when
    converted to a number, ends up with a value of zero. Likewise, when the array
    search is made, each array element, having only a string value, ends up being
    interpolated as zero.
  prefs: []
  type: TYPE_NORMAL
- en: The case of the leading-numeric string is a bit trickier. In PHP 7, the interpolation
    algorithm converts numeric characters until the first non-numeric character is
    encountered. Once that happens, the interpolation stops. Accordingly, the string
    `42abc88` becomes an integer, `42`, for comparison purposes. Now let's have a
    look at how PHP 8 handles string-to-numeric comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding comparison changes made in PHP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PHP 8, if a string is compared with a number, only numeric strings are considered
    valid for comparison. Strings in exponential notation are also considered valid
    for comparison, as well as numeric strings with leading or trailing whitespace.
    It's extremely important to note that PHP 8 makes this determination *before*
    converting the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the output of the same code example described in the previous
    subsection (*Dealing with inconsistent string-to-numeric comparison results*),
    running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So, as you can see from the output, there is a massive potential for your application
    to change its behavior following a PHP 8 upgrade. As a final note in PHP 8 string
    handling, let's look at how you can avoid upgrade issues.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding problems during a PHP 8 upgrade
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main issue you face is the difference in how PHP 8 handles non-strict comparisons
    that involve operands with different data types. If one operand is either `int`
    or `float`, and the other operand is `string`, you have a potential problem post-upgrade.
    If the string is a valid numeric string, the non-strict comparison will proceed
    without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operators are affected: `<=>`, `==`, `!=`, `>`, `>=`, `<`, and
    `<=`. The following functions are affected if the option flags are set to default:'
  prefs: []
  type: TYPE_NORMAL
- en: '`in_array()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array_search()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array_keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rsort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arsort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array_multisort()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on improved numeric string handling in PHP 8, refer to
    the following link: https://wiki.php.net/rfc/saner-numeric-strings. A related
    PHP 8 change is documented here: [https://wiki.php.net/rfc/string_to_number_comparison](https://wiki.php.net/rfc/string_to_number_comparison).'
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to minimize PHP type juggling by providing type hints for
    functions or methods. You can also force the data type before the comparison.
    Finally, consider making use of strict comparisons, although this might not be
    suitable in all situations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how to properly handle comparisons involving
    numeric strings in PHP 8, let's now have a look at PHP 8 changes involving arithmetic,
    bitwise, and concatenation operations.
  prefs: []
  type: TYPE_NORMAL
- en: Handling differences in arithmetic, bitwise, and concatenation operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arithmetic, bitwise, and concatenation operations are at the heart of any PHP
    application. In this section, you learn about hidden dangers that might arise
    in these simple operations following a PHP 8 migration. You must learn about the
    changes made in PHP 8 so that you can avoid a potential code break in your application.
    Because these operations are so ordinary, without this knowledge, you will be
    hard pressed to discover post-migration errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first have a look at how PHP handles non-scalar data types in arithmetic
    and bitwise operations.
  prefs: []
  type: TYPE_NORMAL
- en: Handling non-scalar data types in arithmetic and bitwise operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, the PHP engine has been very *forgiving* about using mixed data
    types in an arithmetic or bitwise operation. We've already had a look at comparison
    operations that involve *numeric*, *leading-numeric*, and *non-numeric* strings
    and numbers. As you learned, when a non-strict comparison is used, PHP invokes
    type juggling to convert the string to a number before performing the comparison.
    A similar action takes place when PHP performs an arithmetic operation that involves
    numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to PHP 8, **non-scalar data types** (data types other than `string`, `int`,
    `float`, or `boolean`) were allowed in an arithmetic operation. PHP 8 has clamped
    down on this bad practice, and no longer allows operands of the `array`, `resource`,
    or `object` type. PHP 8 consistently throws a `TypeError` when the non-scalar
    operands are used in an arithmetic operation. The only exception to this general
    change is that you can still perform arithmetic operations where all operands
    are of the `array` type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For further information on the vital change in arithmetic and bitwise operations,
    have a look here: https://wiki.php.net/rfc/arithmetic_operator_type_checks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example to illustrate arithmetic operator handling differences
    in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define sample non-scalar data to test in an arithmetic operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We then attempt to add the integer `99` to a resource, object, and to perform
    a modulus operation on an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add two arrays together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the code example, note how PHP 7 performs silent conversions and
    allows the operations to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What is particularly astonishing is how we can perform a modulus operation against
    an array! When adding a value to an object, a `Notice` is generated in PHP 7\.
    However, PHP type juggles the object to an integer with a value of `1`, giving
    a result of `100` to the arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output running the same code sample in PHP 8 is quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, PHP 8 consistently throws a `TypeError`, except
    when adding two arrays. In both outputs, you may observe that when adding two
    arrays, the second operand is ignored. If the objective is to combine the two
    arrays, you must use `array_merge()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to a potentially significant change in PHP 8 string
    handling pertaining to the order of precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Examining changes in the order of precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **order of precedence**, also known as the *order of operations*, or *operator
    precedence*, is a mathematical concept established in the late 18th and early
    19th centuries. PHP also adopted the mathematical operator precedence rules, with
    a unique addition: the concatenate operator. An assumption was made by the founders
    of the PHP language that the concatenate operator had equal precedence over the
    arithmetic operators. This assumption was never challenged until the arrival of
    PHP 8.'
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 8, arithmetic operations are given precedence over concatenation. The
    concatenate operator demotion now places it below the bit shift operators (`<<`
    and `>>`). There is a potential backward-compatible break in any place where you
    don't use parentheses to clearly define mixed arithmetic and concatenate operations.
  prefs: []
  type: TYPE_NORMAL
- en: This change, in itself, will not throw an `Error` or generate `Warnings` or
    `Notices`, and thereby presents the potential for a hidden code break.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the reasoning for this change, refer to the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: https://wiki.php.net/rfc/concatenation_precedence
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example most clearly shows the effect of this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of this simple statement in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 7, because the concatenate operator has equal precedence over the addition
    operator, the string `The sum of 2 + 2 is:` is first concatenated with the integer
    value `2`. The new string is then type juggled to an integer, generating a `Warning`.
    The value of the new string is evaluated at `0`, which is then added to integer
    `2`, producing the output of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, however, the addition takes place first, after which the result is
    concatenated with the initial string. Here is the result running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the result is much closer to human expectations!
  prefs: []
  type: TYPE_NORMAL
- en: 'One more illustration should drive home the differences demoting the concatenate
    operator can make. Have a look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 7 performs the concatenation first, producing a string, `111`. This is
    type juggled and added to integer `222`, resulting in a final value integer, `333`.
    Here is the result running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 8, the second string, `11`, is type juggled and added to integer `222`,
    producing an interim value, `233`. This is type juggled to a string and prepended
    with `1`, resulting in a final string value of `1233`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you are aware of changes to arithmetic, bitwise, and concatenation
    operations in PHP 8, let''s have a look at a new trend introduced in PHP 8: locale
    independence.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of locale independence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In versions of PHP prior to PHP 8, several string functions and operations were
    tied to the **locale**. The net effect was that numbers were internally stored
    differently depending on the locale. This practice introduced subtle inconsistencies
    that were extremely difficult to detect. After reviewing the material presented
    in this chapter, you will be in a better position to detect potential application
    code changes following a PHP 8 upgrade, thereby avoiding application failure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problems associated with locale dependence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The unfortunate side effect of locale dependence in earlier PHP versions was
    inconsistent results when typecasting from `float` to `string` and then back again.
    Inconsistencies were also seen when a `float` value was concatenated to a `string`.
    Certain optimizing operations performed by *OpCache* resulted in the concatenation
    operation occurring before the locale had been set, yet another way in which inconsistent
    results might be produced.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 8, vulnerable operations and functions are now locale-independent. What
    this means is that all float values are now stored using a period as the decimal
    separator. The default locale is no longer inherited from the environment by default.
    If you need the default locale to be set, you must now explicitly call `setlocale()`.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing functions and operations affected by locale independence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most PHP functions are not affected by the switch to locale independence for
    the simple reason that locale is irrelevant to that function or extension. Furthermore,
    most PHP functions and extensions are already locale-independent. Examples include
    the `PDO` extension, along with functions such as `var_export()` and `json_encode()`,
    and the `printf()` family.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions and operations affected by locale independence include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string) $float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strval($float)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_r($float)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var_dump($float)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug_zval_dump($float)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`settype($float, "string")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`implode([$float])`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xmlrpc_encode($float)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a code example that illustrates handling differences due to locale
    independence:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an array of locales to test. The locales chosen use different
    ways to represent the decimal portion of a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We then loop through the locales, set the locale, and perform a float-to-string
    followed by a string-to-float conversion, echoing the results at each step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this example in PHP 7, note the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the number is stored internally using a period
    for a decimal separator for `en_GB`, whereas the comma is used for locales `fr_FR`
    and `de_DE`. However, when the string is converted back to a number, the string
    is treated as a leading-numeric string if the decimal separator is not a period.
    In two of the locales, the presence of the comma stops the conversion process.
    The net effect is that the decimal portion is dropped and precision is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results when running the same code sample in PHP 8 are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 8, no precision is lost and the number is consistently represented using
    a period for the decimal separator, regardless of the locale.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can still represent a number according to its locale by
    using the `number_format()` function, or by using the `NumberFormatter` class
    (from the `Intl` extension). It's interesting to note that the `NumberFormatter`
    class stores numbers internally in a locale-independent manner!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, have a look at this article: https://wiki.php.net/rfc/locale_independent_float_to_string.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on international number formatting, refer to the following
    link:https://www.php.net/manual/en/class.numberformatter.php
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are aware of the locale-independent aspects present in PHP 8, we
    need to have a look at changes in array handling.
  prefs: []
  type: TYPE_NORMAL
- en: Handling arrays in PHP 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from improvements in performance, the two main changes in PHP 8 array
    handling pertain to the handling of negative offsets and curly brace (`{}`) usage.
    Since both of these changes could result in application code breaks following
    a PHP 8 migration, it's important to cover them here. Awareness of the issues
    presented here gives you a better chance to get broken code working again in short
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at negative array offset handling first.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with negative offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When assigning a value to an array in PHP, if you do not specify an index, PHP
    will automatically assign one for you. The index chosen in this manner is an integer
    that represents a value one higher than the highest currently assigned integer
    key. If no integer index key has yet been assigned, the automatic index assignment
    algorithm starts at zero.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 7 and below, however, this algorithm is not applied consistently in the
    case of a negative integer index. If a numeric array started with a negative number
    for its index, auto-indexing jumps to zero (`0`) regardless of what the next number
    would ordinarily be. In PHP 8, on the other hand, automatic indexing consistently
    increments by a value of `+1` regardless of whether the index is a negative or
    positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: A possible backward-compatible code break is present if your code relies upon
    auto-indexing, and any of the starting indices are negative numbers. Detection
    of this issue is difficult as auto-indexing occurs silently, without any `Warnings`
    or `Notices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates the difference in behavior between PHP
    7 and PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an array with only negative integers as indexes. We use `var_dump()`
    to reveal this array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a second array and initialize the first index to `-3`. We then
    add additional array elements, but without specifying an index. This causes auto-indexing
    to occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then run the program in PHP 7, note that the first array is rendered
    correctly. It''s entirely possible to have negative array indexes in PHP 7 and
    earlier as long as they''re directly assigned. Here is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: However, as you can see from the second `var_dump()` output, automatic array
    indexing skips to zero regardless of the previous high value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In PHP 8, on the other hand, you can see that the output is consistent. Here''s
    the PHP 8 output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, the array indexes are automatically assigned,
    incremented by a value of `1`, making the two arrays identical.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on this enhancement, have a look at this article: https://wiki.php.net/rfc/negative_array_index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you are aware of the potential code break regarding auto-assignment
    of indexes involving negative values, let''s turn our attention to the other area
    of interest: the use of curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling curly brace usage changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Curly braces (`{}`) are a familiar sight for any developer creating PHP code.
    The PHP language, written in C, makes extensive use of C syntax, including curly
    braces. It is well known that curly braces are used to delineate blocks of code
    in control structures (for example, `if {}`), in loops (for example, `for () {}`),
    in functions (for example, `function xyz() {}`), and classes.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, however, we will restrict our examination of curly brace
    usage to that associated with variables. One potentially significant change in
    PHP 8 is the use of curly braces to identify an array element. The use of curly
    braces to designate array offsets is now deprecated as of PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The old usage has been highly contentious given the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Its use can easily be confused with the use of curly braces inside doubly quoted
    strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curly braces cannot be used to make array assignments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accordingly, the PHP core team needed to either make the use of curly braces
    consistent with square brackets (`[ ]`) ... or just get rid of this curly brace
    usage. The final decision was to remove support for curly braces with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the background behind the change, refer to the following
    link: https://wiki.php.net/rfc/deprecate_curly_braces_array_access.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that illustrates the point:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an array of callbacks that illustrate removed or illegal curly
    brace usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then loop through the callbacks using a `try`/`catch` block to capture errors
    that are thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the example in PHP 7, the first callback works. The second and third
    cause a `ParseError` to be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the same example in PHP 8, however, none of the examples work.
    Here is the PHP 8 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This potential code break is easy to detect. However, because your code has
    many curly braces, you might have to wait for the fatal `Error` to be thrown to
    capture the code break.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of changes in array handling in PHP 8, let's have
    a look at changes in security-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering changes in security functions and settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any changes to PHP security features are worth noting. Unfortunately, given
    the state of the world today, attacks on any web-facing code are a given. Accordingly,
    in this section, we address several changes to security-related PHP functions
    in PHP 8\. The changed functions affected include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password_hash()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crypt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there was a change in how PHP 8 treats any functions defined in
    the `php.ini` file using the `disable_functions` directive. Let's have a look
    at this directive to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding changes in disabled functions handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web hosting companies often offer heavily discounted **shared hosting** packages.
    Once a customer signs up, the IT staff at the hosting company creates an account
    on the shared server, assigns a disk quota to control disk space usage, and creates
    a **virtual host** definition on the web service. The problem such hosting companies
    face, however, is that allowing unrestricted access to PHP poses a security risk
    to both the shared hosting company as well as other users on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, IT staff often assign a comma-separated list of functions
    to the `php.ini` directive, **disable_functions**. In so doing, any function on
    this list cannot be used in PHP code running on that server. Functions that typically
    end up on this list are those that allow operating system access, such as `system()`
    or `shell_exec()`.
  prefs: []
  type: TYPE_NORMAL
- en: Only internal PHP functions can end up on this list. Internal functions are
    those included in the PHP core as well as functions provided via extensions. User-defined
    functions are not affected by this directive.
  prefs: []
  type: TYPE_NORMAL
- en: Examining disabled functions' handling differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP 7 and earlier, disabled functions could not be re-defined. In PHP 8,
    disabled functions are treated as if they never existed, which means re-definition
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Just because you can redefine the disabled function in PHP 8 *does not* mean
    that the original functionality has been restored!
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, we first add this line to the `php.ini` file:`disable_functions=system.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we need to add this to *both* Docker containers (both PHP 7 and PHP
    8) in order to complete the illustration. The commands to update the `php.ini`
    files are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then attempt to use the `system()` function, the attempt fails in both
    PHP 7 and PHP 8\. Here, we show the output from PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define some program code that redefines the banned function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the code example, we''ve created a function that mimics
    the behavior of an `ls -l` Linux system call, but only uses safe PHP functions
    and classes. If we try to run this in PHP 7, however, a fatal `Error` is thrown.
    Here is the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, our function redefinition succeeds, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You now have an idea of how to work with disabled functions. Next, let's have
    a look at changes to the vital `crypt()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about changes to the crypt() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **crypt()** function has been a staple of PHP hash generation since PHP
    version 4\. One of the reasons for its resilience is because it has so many options.
    If your code uses `crypt()` directly, you'll be pleased to note that if an unusable
    **salt** value is provided, Defense Encryption Standard (**DES**), long considered
    broken, is *no longer* the fallback in PHP 8! The salt is also sometimes referred
    to as the **initialization vector** (**IV**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important change involves the **rounds** value. A *round* is like shuffling
    a deck of cards: the more times you shuffle, the higher the degree of randomization
    (unless you''re dealing with a Las Vegas card shark!). In cryptography, blocks
    are analogous to cards. During each round, a cryptographic function is applied
    to each block. If the cryptographic function is simple, the hash can be generated
    more quickly; however, a larger number of rounds are required to fully randomize
    the blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: The **SHA-1** (**Secure Hash Algorithm**) family uses a fast but simple algorithm,
    and thus requires more rounds. The SHA-2 family, on the other hand, uses a more
    complex hashing function, which takes more resources, but fewer rounds.
  prefs: []
  type: TYPE_NORMAL
- en: When using the PHP `crypt()` function in conjunction with `CRYPT_SHA256`, (SHA-2
    family), PHP 8 will no longer silently resolve the `rounds` parameter to the closest
    limit. Instead, `crypt()` will fail with a `*0` return, matching `glibc` behavior.
    In addition, in PHP 8, the second argument (the salt), is now mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates the differences between PHP 7 and PHP 8 when
    using the `crypt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define variables representing an unusable salt value, and an illegal
    number of rounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create two hashes using the `crypt()` function. In the first usage,
    `$default` is the result after supplying an invalid salt argument. The second
    usage, `$sha256`, provides a valid salt value, but an invalid number of rounds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code example running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Notice how PHP 7 silently modifies the original request. In the first case,
    `crypt()` falls back to `DES` (!). In the second case, PHP 7 silently alters the
    `rounds` value from `1` to the nearest limit of `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same code running in PHP 8, on the other hand, fails and returns `*0`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As we have stressed repeatedly in this book, when PHP makes assumptions for
    you, ultimately you end up with bad code that produces inconsistent results. In
    the code example just shown, the best practice would be to define a class method
    or function that exerts greater control over its parameters. In this manner, you
    can validate the parameters and avoid having to rely upon PHP assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take a look at changes to the `password_hash()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with changes to password_hash()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the years, so many developers had misused `crypt()` that the PHP core
    team decided to add a wrapper function, `password_hash()`. This proved to be a
    smashing success and is now one of the most widely used security functions. Here
    is the function signature for `password_hash()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Algorithms currently supported include **bcrypt**, **Argon2i**, and **Argon2id**.
    It''s recommended that you use the predefined constants for algorithms: `PASSWORD_BCRYPT`,
    `PASSWORD_ARGON2I`, and `PASSWORD_ARGON2ID`. The `PASSWORD_DEFAULT` algorithm
    is currently set to `bcrypt`. Options vary according to the algorithm. If you
    use either `PASSWORD_BCRYPT` or the `PASSWORD_DEFAULT` algorithms, the options
    include `cost` and `salt`.'
  prefs: []
  type: TYPE_NORMAL
- en: Conventional wisdom suggests that it's better to use the randomly generated
    `salt` created by the `password_hash()` function. In PHP 7, the `salt` option
    was deprecated and is now ignored in PHP 8\. This won't cause a backward-compatible
    break unless you're relying on `salt` for some other reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code example, a non-random salt value is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In the PHP 7 output, a deprecation `Notice` is issued:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You'll also note from the PHP 7 output that the non-random `salt` value is clearly
    visible. One other thing to note is that when `password_get_info()` is executed,
    the `algo` key shows an integer value that corresponds to one of the predefined
    algorithm constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP 8 output is somewhat different, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `salt` value was ignored, and a random `salt` used instead.
    Instead of a `Notice`, PHP 8 issues a `Warning` regarding the use of the `salt`
    option. Another point to note from the output is that when `password_get_info()`
    is called, the `algorithm` key returns a string rather than an integer in PHP
    8\. This is because the predefined algorithm constants are now string values that
    correspond to their signature when used in the `crypt()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The last function we will examine, in the next subsection, is `assert()`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about changes to assert()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `assert()` function is normally associated with testing and diagnostics.
    We include it in this subsection, as it often has security implications. Developers
    sometimes use this function when attempting to trace potential security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: To use the `assert()` function, you must first enable it by adding a `php.ini`
    file setting `zend.assertions=1`. Once enabled, you can place one or more `assert()`
    function calls at any place within your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding changes to assert() usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of PHP 8, it''s no longer possible to present `assert()` with string arguments
    to be evaluated: instead, you must provide an expression. This presents a potential
    code break because in PHP 8, the string is treated as an expression, and therefore
    always resolves to the Boolean `TRUE`. Also, both the `assert.quiet_eval` `php.ini`
    directive, and the `ASSERT_QUIET_EVAL` pre-defined constant used with `assert_options()`,
    have been removed in PHP 8 as they now have no effect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the potential problem, we first activate assertions by setting
    the `php.ini` directive, `zend.assertions=1`. We then define an example program
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `ini_set()` to cause `assert()` to throw an exception. We also define
    a variable, `$pi`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We then attempt an assertion as an expression, `$pi === M_PI`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last `try`/`catch` block, we attempt an assertion as a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program in PHP 7, everything works as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `M_PI` comes from the math extension, and is far more accurate
    than simply dividing 22 by 7! Accordingly, both assertions throw an exception.
    In PHP 8, however, the output is significantly different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The assertion as a string is interpreted as an expression. Because the string
    is not empty, the Boolean result is `TRUE`, returning a false positive. If your
    code relies upon the result of an assertion as a string, it is bound to fail.
    As you can see from the PHP 8 output, however, an assertion as an expression works
    the same in PHP 8 as in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice: Do not use `assert()` in production code. If you do use `assert()`,
    always provide an expression, not a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of changes to security-related functions, we bring
    this chapter to a close.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about differences in string handling between PHP
    8 and earlier versions, and how to develop workarounds that address differences
    in string handling. As you learned, PHP 8 exerts greater control over the data
    types of string function arguments, as well as introducing consistency in what
    happens if an argument is missing or null. As you learned, a big problem with
    earlier versions of PHP is that several assumptions were silently made on your
    behalf, resulting in a huge potential for unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also highlighted issues involving comparisons between numeric
    strings and numeric data. You learned not only about numeric strings, type-juggling,
    and non-strict comparisons, but also how PHP 8 corrects flaws inherent in numeric
    string handling that were present in earlier versions. Another topic covered in
    this chapter demonstrated potential issues having to do with how several operators
    behave differently in PHP 8\. You learned how to spot potential problems and were
    given best practices to improve the resilience of your code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also addressed how a number of PHP functions retained dependence
    upon the locale setting, and how this problem has been addressed in PHP 8\. You
    learned that in PHP 8, floating-point representations are now uniform and no longer
    dependent upon the locale. You also learned about changes in how PHP 8 addresses
    array elements as well as changes in several security-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: The tips, tricks, and techniques covered in this chapter raise awareness of
    inconsistent behavior in earlier versions of PHP. With this new awareness, you
    are in a better position to gain greater control over the use of PHP code. You
    are also now in a better position to detect situations that could lead to potential
    code breaks following a PHP 8 migration, giving you an advantage over other developers,
    and ultimately leading you to write PHP code that performs reliably and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter shows you how to avoid potential code breaks involving changes
    to PHP extensions.
  prefs: []
  type: TYPE_NORMAL
