- en: A Serverless Email Validation Azure Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will take us into the realm of serverless computing. Just what
    is serverless computing, I hear you ask? Well, the answer is really simple once
    you grasp the idea that the term *serverless computing* has nothing to do with
    the lack of a server. It is quite the opposite, in fact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will have a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your Azure Function in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an Azure Function from an ASP.NET Core MVC application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be creating a simple Azure Function that uses regular expressions to
    validate an email address. You need to keep in mind that Azure Functions are small
    pieces of code in the cloud. Do not think of them as large sections of complicated
    code. The smaller the better.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with serverless computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, companies spend time and money managing a server's computing
    resources. These represent a fixed and recurring cost to the company. It doesn't
    matter if the server is idle or if it is performing some form of computing task.
    The bottom line is that it costs money just by being there.
  prefs: []
  type: TYPE_NORMAL
- en: With serverless computing, the computing resources are scalable cloud services.
    This means that it is an event-driven application design. Basically, with serverless
    computing, you only pay for what you use. This is true of Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Functions** are small bits of code that reside in the cloud. Your applications
    can simply just use these functions as needed, and you only pay for the computing
    power used. It does not matter if one or one million people access your application.
    Azure Functions will automatically scale to handle the additional load. When the
    usage of your application drops, the Azure Function scales back down.'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of serverless computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you saw frequent (but not constant) spikes in your application
    usage. Because the server that handles the requests from your application is not
    serverless, it needs to be upgraded (as a cost to you or your company) to be able
    to handle the additional load. In times of low usage, the server does not have
    less resources. You upgraded it to be able to handle a specific load of users.
    It will always be running at this level of performance, and as you know, performance
    comes at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: With serverless computing, the resources are automatically scaled up and down
    as demand increases and decreases. This is a much more efficient way of using
    a server, because you are not paying for underutilized computing power.
  prefs: []
  type: TYPE_NORMAL
- en: Features of Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Functions offer developers a rich set of features. Refer to the Microsoft
    documentation to read up more on Azure Functions—[https://docs.microsoft.com/en-us/azure/azure-functions/](https://docs.microsoft.com/en-us/azure/azure-functions/).
    For now, we will have a look at a few of those features.
  prefs: []
  type: TYPE_NORMAL
- en: Choice of languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The great thing about Azure Functions is that you can create them in a language
    of your choice. For a list of supported languages, browse to the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages](https://docs.microsoft.com/en-us/azure/azure-functions/supported-languages).'
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will be using C# to write the Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Pay-per-use pricing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, you will only pay for the actual time spent that your
    Azure Function runs. The consumption plan is billed per second. Microsoft have
    a great document on Azure Functions pricing at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/pricing/details/functions/](https://azure.microsoft.com/en-us/pricing/details/functions/).'
  prefs: []
  type: TYPE_NORMAL
- en: Flexible development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create your Azure Functions directly in the Azure portal. You can also
    set up continuous integration with Visual Studio Team Services and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: What types of Azure Functions can I create?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use Azure Functions as a solution to integrate with your application,
    processing data, working with IoT, APIs, and microservices. Azure Functions also
    work well on a trigger, so you can even schedule tasks. These are some of the
    Azure Function templates available to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTPTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimerTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GitHub webhook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Generic webhook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlobTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CosmosDBTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QueueTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventHubTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceBusQueueTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceBusTopicTrigger`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To read up more on these templates and Azure Functions in general, go through
    the Microsoft document, *An introduction to Azure Functions*, at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without further delay, let''s create our own Azure Function. The function we
    are going to create is going to validate an email address using regular expressions.
    This is a very standard development task to code. It is also a function that will
    be widely used across many applications:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to have an Azure account. If you do not have one, you can set
    up a free trial account at—[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Point your browser at—[https://portal.azure.com](https://portal.azure.com) and
    log on to your Azure portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once logged in, look for the Create a resource link. Click on the link and
    then look for the Compute link under the Azure Marketplace section. Refer to the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5cd2ce05-5cd4-4a7d-aa69-6a21f641e064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A little way down under the Featured section, you will see Function App as
    an option. Click on that link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/731176f3-ffb0-466b-ac39-26699a5ad811.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now be presented with the Function App settings screen. The following
    options need to be entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'App name: This is the globally unique name of your Azure Function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscription: This is the subscription under which your function will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resource group: Create a new resource group for your function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS: You have a choice of Windows or Linux. I chose Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hosting plan: This will define how resources are allocated to your function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Location: It is a good idea to choose a location geographically closest to
    you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storage: Keep this as default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also have the option to switch Application Insights to On or Off. You can
    also select the Pin to dashboard option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have called our Azure Function core-mail-validation.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added all the required settings, click on the Create button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/31b46271-09a2-4101-a3fb-6805ce937eba.png)'
  prefs: []
  type: TYPE_IMG
- en: After you click on the Create button, you will see a Validating... message.
    This could take several seconds:![](img/1fd053a8-3d11-4da8-91d9-322c9c6f613e.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep your eye on the notifications section (the little bell icon) in the top
    right hand corner of the Azure portal. New notifications are displayed there and
    are indicated by a number representing the number of unread notifications:![](img/7e1a442c-69fc-47d7-a800-af7f81c07dfd.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click on the notifications, you will see that Azure is in the progress
    of deploying the Azure Function you created:![](img/5e90e6a5-74d6-4f1c-9b4e-586758a3c53a.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your Azure Function is deployed, you will see a Deployment succeeded message
    appear in the Notifications section. From there, you can click on the Pin to dashboard to Go
    to resource buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pinning your function to the dashboard just makes it easier for you to access
    it again later on. It's a good idea to pin frequently used services to your dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access your Azure Function, click on the Go to resource button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5e0d3c8-8b12-496d-b7e9-89505ec5449a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will then be taken to the Function Apps section of your Azure portal. You
    will see the core-mail-validation function listed under the Function Apps section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17187b97-ab49-437b-9b62-15f25a4ac3c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the core-email-validation, click on the Functions option. Then, click
    on the New function option in the panel on the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a84a8210-4e1b-4dca-bfcd-629181f2ff9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You are now presented with a series of templates that can get you started.
    Scroll down to see all the templates available (there are more than just the four
    shown in the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ed48aacc-bc68-4219-b965-b0b861c9acd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not going to go through all the templates available. We are going to
    keep things simple and just select the go to the quickstart option, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f3f0d31e-69ea-4060-a551-c4e199120464.png)'
  prefs: []
  type: TYPE_IMG
- en: For our purposes, we will simply select Webhook + API and choose C# as our language.
    There are other languages available to choose from, so select the language you
    are most comfortable with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create the function, click on the Create this function button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5cee9e17-9d25-4e14-854e-4312609e06f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Azure Function is created and some boilerplate code is automatically added
    for you so that you can get a feel for how the code needs to look inside the function.
    All  this code does is it looks for a variable called `name` in the query string
    and displays that in the browser, if found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the top-right corner of the screen. You will see a </> Get function
    URL link. Click on the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb682bf7-6e37-405c-95f6-d44084e10faf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will display a pop-up screen with the URL to access the Azure Function
    you just created. Click on the Copy button to copy the URL to your clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd77a3b9-9a19-4a39-9004-ce7f22906713.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL that you copy will look something as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run our function, we need to add a `name` parameter in the query string
    of the URL. Go ahead and add `&name==[YOUR_NAME]` where `[YOUR_NAME]` is your
    own name into the URL. In my case, I added `&name=Dirk` to the end of my URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Paste this URL into the browser address bar and hit the return button. A message
    saying (in my case) "Hello Dirk" is displayed in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/db969b84-aeed-4fe2-8a1d-64b576f77d53.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that in Chrome and Firefox, you might see the message This XML file does
    not appear to have any style information associated with it. To see the output,
    use Microsoft Edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Azure portal, you will see the Logs window at the bottom of the
    Azure Function screen. If it isn''t displayed, click on the Λ arrow to expand
    the panel. Here, you will see that the Azure Trigger was run successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ebdcb87-5b5a-4b4f-a6eb-d43967c36eeb.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, you have just run your new Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Azure Function code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this is all quite exciting (it should be, this is really cool tech),
    we need to make a few changes to the Azure Function to meet our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the `return` statement in your Azure Function. It will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s simplify the code a bit and just return `true` if the email address
    is not empty. Replace the `return` statement with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code in your Azure Function should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to click on the Save button to save the changes to your Azure Function.
    You will then see that the function is compiled and a Compilation succeeded message
    is displayed in the Logs window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65abe5ba-1d6e-4653-ae83-8165173dbf1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As previous, copy the URL by clicking on the </> Get function URL link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This time though, we want to pass it as an email address. You can see that
    the parameter name has changed to `email` and the value can be any email address
    you choose to enter. I therefore appended `&email=dirk@email.com` to the end of
    the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Paste the URL into your browser and hit the return button to see the result
    displayed in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cad93eb1-ffef-46c7-86ae-39823faf11ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are now confident that the Azure Function is performing a rudimentary validation
    of our email address (even if it is just checking to see if it exists). However,
    we need the function to do so much more. To validate the email address, we will
    be using regular expressions. To do this, add the following namespace to the Azure
    Function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the section of code that does the validation, enter the code to match the
    email to the regex pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There are a million different regular expression patterns on the internet. Regular
    expressions are a whole different topic altogether and beyond the scope of this
    book. If matching a pattern of text is required by your application, Google to
    see if there isn't a regex pattern available for it. If you are really brave,
    you can write your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions have been baked into the .NET Framework, and the code is
    quite straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have added all the code, your Azure Function will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the same URL you copied earlier and paste it into the browser window and
    hit the *Return* or *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The email address `dirk@email.com` is validated and the message "Email status:
    True" is displayed in the browser. What has happened here is that the email address
    was passed to the Azure Function. The function then read the value of the `email`
    parameter from the query string and passed that to the regular expression.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The email address is matched against the regular expression pattern, and if
    a match is found, then the email address is considered a valid email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb0be1a7-8065-4be3-8882-bdbff4461acf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s enter the same URL into the browser, only this time enter an email address
    you know will be invalid. For example, an email address can only contain a single
    `@` sign. The parameter I then added to the URL is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then see that when we hit the *Return* or *Enter* key, the invalid
    email address `dirk@@email.com` is validated and found not to match the regular
    expression. The text "Email status: False" is therefore displayed in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efb296c4-25e9-4bdb-984f-b0bc11690251.png)'
  prefs: []
  type: TYPE_IMG
- en: This is fantastic! We have seen that the Azure Function we created uses the
    regular expression we added to validate the email address it receives. Based on
    the result of the regex validation, the function returns either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, before we carry on, we want the Azure Function to return a single `True`
    or `False` value to the calling application. Modify the `return` statement of
    your function to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have seen how this function works, by modifying the code step-by-step and
    running it directly from the browser window. However, this does not do us any
    good unless we can call this Azure Function from an application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how to create an ASP.NET Core MVC application that calls
    our Azure Function to validate an email address entered on a login screen.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an Azure Function from an ASP.NET Core MVC application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we had a look at how our Azure Function worked. Now,
    we want to create an ASP.NET Core MVC application that will call our Azure Function
    to validate an email address entered into a login screen of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: This application does no authentication at all. All it is doing is validating
    the email address entered. ASP.NET Core MVC authentication is a totally different
    topic and not the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio 2017, create a new project and select ASP.NET Core Web Application
    from the project templates. Click on the OK button to create the project. This
    is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2a98857-ae4f-42f6-8514-b2f3ac97b1ce.png)'
  prefs: []
  type: TYPE_IMG
- en: On the next screen, ensure that .NET Core and ASP.NET Core 2.0 is selected from
    the drop-down options on the form. Select Web Application (Model-View-Controller)
    as the type of application to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Don''t bother with any kind of authentication or enabling Docker support. Just
    click on the OK button to create your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22c47a80-9256-4d49-a5bd-77031ad83531.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After your project is created, you will see the familiar project structure
    in the Solution Explorer of Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99c956fc-b4b7-4133-b05f-4193e4922ce3.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this next part, we can create a plain and simple vanilla login form. For
    a little bit of fun, let''s spice things up a bit. Have a look on the internet
    for some free login form templates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I decided to use a site called **colorlib** that provided 50 free HTML5 and
    CSS3 login forms in one of their recent blog posts. The URL to the article is:
    [https://colorlib.com/wp/html5-and-css3-login-forms/](https://colorlib.com/wp/html5-and-css3-login-forms/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I decided to use **Login Form 1 by Colorlib** from their site. Download the
    template to your computer and extract the ZIP file. Inside the extracted ZIP file,
    you will see that we have several folders. Copy all the folders in this extracted
    ZIP file (leave the `index.html` file as we will use this in a minute):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/930634ba-19aa-40c0-9d18-ac53cbd80b55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, go to the solution for your Visual Studio application. In the `wwwroot`
    folder, move or delete the contents and paste the folders from the extracted ZIP
    file into the `wwwroot` folder of your ASP.NET Core MVC application. Your `wwwroot`
    folder should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a7da7042-7001-4296-9b7f-40ea9a4c06d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Back in Visual Studio, you will see the folders when you expand the wwwroot
    node in the CoreMailValidation project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I also want to focus your attention to the `Index.cshtml` and `_Layout.cshtml`
    files. We will be modifying these files next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65f2d69e-e6da-4e23-9e45-12cc7aa2868b.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `Index.cshtml` file and remove all the markup (except the section in
    the curly brackets) from this file. Paste the HTML markup from the `index.html`
    file from the ZIP file we extracted earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do not copy the all the markup from the `index.html` file. Only copy the markup
    inside the `<body></body>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Index.cshtml` file should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for this chapter is available on GitHub at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/Serverless).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `Layout.cshtml` file and add all the links to the folders and
    files we copied into the `wwwroot` folder earlier. Use the `index.html` file for
    reference. You will notice that the `_Layout.cshtml` file contains the following
    piece of code—`@RenderBody()`. This is a placeholder that specifies where the
    `Index.cshtml` file content should be injected. If you are coming from ASP.NET
    Web Forms, think of the `_Layout.cshtml` page as a master page. Your `Layout.cshtml`
    markup should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked out right, you will see the following page when you run
    your ASP.NET Core MVC application. The login form is obviously totally non-functional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3ce9788c-496a-42f5-89a9-4ba813bb7053.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the login form is totally responsive. If you had to reduce the size
    of your browser window, you will see the form scale as your browser size reduces.
    This is what you want. If you want to explore the responsive design offered by
    Bootstrap, head on over to [https://getbootstrap.com/](https://getbootstrap.com/)
    and go through the examples in the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c66e960-5633-4e52-b698-14eed1d81cc5.png)'
  prefs: []
  type: TYPE_IMG
- en: The next thing we want to do is hook this login form up to our controller and
    call the Azure Function we created to validate the email address we entered.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at doing that next.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking it all up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify things, we will be creating a model to pass to our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class in the `Models` folder of your application called `LoginModel`
    and click on the Add button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73408275-7afa-4639-979e-4007aa418f89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your project should now look as follows. You will see the `model` added to
    the `Models` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c04fef2-90eb-4453-ad15-c2f8490ee76d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next thing we want to do is add some code to our `model` to represent the
    fields on our login form. Add two properties called `Email` and `Password`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `Index.cshtml` view, add the `model` declaration to the top of
    the page. This makes the `model` available for use in our view. Take care to specify
    the correct namespace where the `model` exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The next portion of code needs to be written in the `HomeController.cs` file.
    Currently, it should only have an action called `Index()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `async` function called `ValidateEmail` that will use the base URL
    and parameter string of the Azure Function URL we copied earlier and call it using
    an HTTP request. I will not go into much detail here, as I believe the code to
    be pretty straightforward. All we are doing is calling the Azure Function using
    the URL we copied earlier and reading the return data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Create another `public async` action called `ValidateLogin`. Inside the action,
    check to see if the `ModelState` is valid before continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a nice explanation of what `ModelState` is, have a look at the following
    article—[https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/](https://www.exceptionnotfound.net/asp-net-mvc-demystified-modelstate/).
  prefs: []
  type: TYPE_NORMAL
- en: We then do an `await` on the `ValidateEmail` function, and if the return data
    contains the word `false`, we know that the email validation failed. A failure
    message is then passed to the `TempData` property on the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `TempData` property is a place to store data until it is read. It is exposed
    on the controller by ASP.NET Core MVC. The `TempData` property uses a cookie-based
    provider by default in ASP.NET Core 2.0 to store the data. To examine data inside
    the `TempData` property without deleting it, you can use the `Keep` and `Peek`
    methods. To read more on `TempData`, see the Microsoft documentation here: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?tabs=aspnetcore2x).'
  prefs: []
  type: TYPE_NORMAL
- en: If the email validation passed, then we know that the email address is valid
    and we can do something else. Here, we are simply just saying that the user is
    logged in. In reality, we will perform some sort of authentication here and then
    route to the correct controller.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing to note is the inclusion of the `ValidateAntiForgeryToken`
    attribute on the `ValidateLogin` action on the controller. This ensures that the
    form has been posted from our site and prevents our site from being fooled by
    a cross site request forgery attack.
  prefs: []
  type: TYPE_NORMAL
- en: If we had to inspect the rendered markup of our page when we run the application,
    we will see that ASP.NET Core has automatically generated the anti-forgery token
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the markup via the browser's developer tools. Access it in Chrome by
    pressing *Ctrl *+ *Shift *+ *I* or *F12* if you are using Edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the __RequestVerificationToken and the generated value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44aea025-3fe9-495e-9050-2d7ef231ef83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The complete `ValidateLogin` action on the `HomeController` should look as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Swing back to our `Index.cshtml` view and have a closer look at the `form`
    tag. We have explicitly defined which controller and action to call using `asp-action`
    (that specifies the action to call) and `asp-controller` (that specifies in which
    controller to go and look for the specified action):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This maps the action `ValidateLogin` on the `HomeController` class that the
    `Index.cshtml` form will post back to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/284058f0-d4c6-497d-87a6-6d0493a1b7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, a little further down, ensure that your button has the `type` specified
    to `submit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done with our `Index.cshtml` view. We want some sort of notification
    when the email entered is invalid. This is where Bootstrap comes in handy. Add
    the following markup for a `modal` dialog that will be displayed, notifying the
    user that the entered email address is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice the inclusion of the `@section Scripts` block at the end of
    the page. What we are basically saying is that if the `TempData` property is not
    null, then we want to display the modal dialog via the jQuery script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your application and enter an invalid email address on the login page.
    In my example, I simply added an email address containing two `@` signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca7ec133-c219-4f00-9d70-7beef1236e38.png)'
  prefs: []
  type: TYPE_IMG
- en: When the LOGIN button is pressed, the form posts back to the controller that
    in turn calls the Azure Function, which performs validation on the entered email
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a rather bland looking modal dialog notification popping up,
    notifying the user that the email address is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76e6cf59-c83b-4986-b635-549c1882bc33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Entering a valid email address and clicking on the LOGIN button results in
    a successful validation on the entered email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3479fd2-d5b7-4a57-a160-eca11940d5d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned previously, the email validation is not the same as authentication.
    If the email is validated, then the authentication process can take place. If
    this authentication process successfully authenticates the user logging in, only
    then will they be redirected to the logged in page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b083bf-c5be-42d6-a8fa-4a396598ad85.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to create an Azure Function on the Azure portal.
    We learned that Azure Functions are small bits of code in the cloud that are used
    by applications when needed. Because they are priced on a pay-as-you-use model,
    you only pay for the actual computing power user. When the user load is high on
    your web application, the function automatically scales as required to meet the
    demands of the application accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: We took a look at the process of getting to know the code in our Azure Function
    by posting the URL into the browser manually. Then, we created an ASP.NET Core
    MVC application that consisted of a single login page. We then had a look at how
    to use the Azure Function to validate the email address entered on the login screen.
    Azure Functions are an exciting technology to start using. There is still a lot
    to learn, and not enough left of the chapter to discuss this serverless technology.
    If this technology interests you, explore some of the other Azure Service templates
    available.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at creating a Twitter clone using an
    ASP.NET Core MVC application and a C# library called `Tweetinvi`. Stick around,
    there is still a lot of exciting content for you.
  prefs: []
  type: TYPE_NORMAL
