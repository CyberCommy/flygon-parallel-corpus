- en: Chapter 6. Advanced PDO Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the basic features of PDO and used
    them to build a data-driven web applications, let’s see some advanced functionality.
    In this chapter, we will look at getting and setting connection attributes (such
    as column names, case conversion, and the name of the underlying PDO driver) as
    well as connecting to a database by specifying a connection configuration filename
    or an option in the `php.ini` file. We will also discuss transactions.
  prefs: []
  type: TYPE_NORMAL
- en: We will modify our library application to display the name of the database driver
    in the footer of every page. In addition to this simple change, we will extend
    the application to keep track of how many copies of a single book we have and
    to keep track of those people who have borrowed a book. We will use transactions
    for this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and Getting Connection Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have briefly covered setting connection attributes in [Chapter 3](ch03.html
    "Chapter 3. Error Handling") when we saw how to use exceptions as a means of error
    reporting. Connection attributes allow us to control certain aspects of the connection
    as well as to query such things as the driver name and version.
  prefs: []
  type: TYPE_NORMAL
- en: One way is to specify an array of attribute name/value pairs in the PDO constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way is to call the `PDO::setAttribute()` method, which accepts two
    parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute's value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In PDO, attributes and their values are defined as constants in the `PDO` class
    as in the following call in the `common.inc.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It includes two such constants—`PDO::ATTR_ERRMODE` and `PDO::ERRMODE_EXCEPTION`.
  prefs: []
  type: TYPE_NORMAL
- en: To get the value of an attribute, there is the `PDO::getAttribute()` method.
    It accepts a single parameter, the attribute name, and returns the value of the
    attribute. For example, the following code would print `Exception:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's see what connection attributes there are in PDO.
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ATTR_CASE`. This attribute controls the case of column names that are
    returned by the `PDOStatement::fetch()` method. It is useful if the fetch mode
    is `PDO::FETCH_ASSOC` or `PDO::FETCH_BOTH` (as when the row is returned as an
    array that contains columns indexed by their name). This attribute can have one
    of the following three values: `PDO::CASE_LOWER, PDO::CASE_NATURAL`, and `PDO::CASE_UPPER`.
    Depending on this value, the column names will be lowercase, left without changes,
    or uppercase, respectively as in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'would print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default behavior is not to change the column name case, that is `PDO::CASE_NATURAL.`
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ATTR_ORACLE_NULLS:` This attribute, despite its name, works for all databases,
    not just Oracle. It controls how the `NULL` values and empty strings are passed
    in PHP. The possible values are `PDO::NULL_NATURAL` (for no transformation to
    happen), `PDO::NULL_EMPTY_STRING` (for empty strings to be replaced by PHP''s
    null value), and `PDO::NULL_TO_STRING` (for the SQL NULL value is converted to
    an empty string in PHP).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see how this attribute works in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Would result with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the highlighted fields are reported as strings, not NULLs (which
    would be the case if we didn't set the `PDO::ATTR_ORACLE_NULLS` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ATTR_ERRMODE`. This attribute sets the error reporting mode for the connection.
    It accepts three values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_SILENT:` No action is taken, and the error codes are available
    via `PDO::errorCode()` and `PDO::errorInfo()` methods (or their equivalents in
    the `PDOStatement` class). This is the default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_WARNING:` As before, no action is taken, but an error will be
    raised with `E_WARNING` level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ERRMODE_EXCEPTION` will set the error codes (as with `PDO::ERRMODE_SILENT)`,
    and an exception of class `PDOException` will be thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also driver-specific attributes, which we will not cover here. Refer
    to [http://www.php.net/pdo](http://www.php.net/pdo) for more information. However,
    there is one driver-specific attribute worth our attention: `PDO::ATTR_PERSISTENT`.
    You can use it to specify that the MySQL driver should use persistent connections,
    which gives better performance (You can think of this as a counterpart for `mysql_pconnect()`
    function.) This attribute should be set in the PDO constructor rather than via
    a PDO::setAttribute() call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The above three attributes are read/write attributes, which means that they
    can be read and written. There are also read-only attributes, available only via
    the `PDO::getAttribute()` method. These attributes may return string values (rather
    than constants defined in the PDO class).
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ATTR_DRIVER_NAME:` This returns the name of the underlying database driver:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will print either MySQL or SQLite depending on the driver you use.
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::ATTR_CLIENT_VERSION:` This returns the name of the underlying database
    client library version. For example, for MySQL this may be something like 5.0.37.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::ATTR_SERVER_VERSION:` This returns the version of the database server
    you are connecting to. For MySQL, this can be a string such as`"4.1.8-nt"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now get back to our application and modify it to show the database driver
    in the footer of every page. To achieve this, we will modify the `showFooter()`
    function in `common.inc.php:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we are importing the `$conn` variable from the global namespace.
    If this variable is an object of the `PDO` class, then we will call the `getAttribute()`
    method as discussed above. We have to do this check because in some situations
    the `$conn` variable may not be set. For example, if the `PDO` constructor fails
    and throws an exception, we will not be able to call any methods on the `$conn`
    variable (this will lead to a fatal error—calling member functions on non-objects
    are fatal errors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all pages in our application call the `showFooter()` method function,
    this change will be visible everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting and Getting Connection Attributes](graphics/2660_06_01.jpg)![Setting
    and Getting Connection Attributes](graphics/2660_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MySQL Buffered Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are working with a MySQL database only, then you may want to employ
    MySQL''s PDO driver buffered query mode. When the connection is set to the buffered
    query mode, the whole result set for every SELECT query is pre-fetched into memory
    before it is returned to the application. This gives us one benefit—we can use
    the `PDOStatement::rowCount()` method to inspect how many rows the result set
    contains. In [Chapter 2](ch02.html "Chapter 2. Using PHP Data Objects: First Steps"),
    we discussed this method and showed that it returns 0 for MySQL and SQLite databases.
    Now, when PDO is instructed to use buffered queries, this method will return meaningful
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To force PDO into MySQL buffered query mode, you have to specify the `PDO::MYSQL_ATTR_USE_BUFFERED_QUERY`
    connection attribute. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will print the number of rows returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that this attribute works for MySQL only and is not portable across
    databases. You should use it if your application will be working with MySQL only.
    Also, remember that buffered queries that return large result sets are very expensive
    with respect to resource and should be avoided. If you are going to use buffered
    queries, make sure you disable them before issuing such expensive queries. This
    can be done by turning this attribute off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can query whether MySQL buffered queries are currently enabled by calling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I have switched databases for every screenshot (and in the first screenshot
    the page is scrolled down to the bottom to save space).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting Using the Connection Configuration File and php.ini Setting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we discussed the connection strings (or the data source names for PDO),
    we saw that the connection string starts with the driver name followed by a semicolon.
    PDO also supports configuration files—a file that contains the connection string.
    For example, we can create a file called `pdo.dsn` in the directory where we can
    keep the application files and put the connection string there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can create two files, `mysql.dsn` and `sqlite.dsn`, containing
    the first and the second connection strings respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in the PDO constructor, we can specify the configuration file path or
    URL, not just the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: PDO will read the file and use the connection string specified there. The advantage
    of using this method is that you can specify not just a local file, but any URL
    so that a remote file can be included (provided a suitable stream handler is registered
    in the system for a protocol such as HTTP or FTP). On the other hand, if the file
    is not properly protected from web access by all users, then it can potentially
    leak secure information to a third party, so care should be taken when this method
    is being used to specify the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way of specifying the connection string: in the `php.ini`
    file. For example, you can define the following directives in the `php.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'then it is possible to pass ''mysql'' or ''sqlite'' strings to the `PDO` constructor
    instead of the whole connection strings for mysql and sqlite, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the connection string in this case should match the corresponding
    option in the `php.ini` file with the `'pdo.dsn'` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the List of Available Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PDO allows you to programmatically get the list of all installed drivers. The
    `PDO::getAvailableDrivers()` method can be called to return an array containing
    the names of the database drivers that can be used. For example, this code will
    print something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The names of drivers, contained in this array, are the prefixes for the connection
    strings. Also, the same name is returned as the value of the `PDO::ATTR_DRIVER_NAME`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PDO::getAvailableDrivers()` method returns the names of drivers that are
    registered with the PDO system in the `php.ini` file. You may not be able to use
    all of these drivers on the local machine—for example, if the MySQL server is
    not running then the presence of a MySQL item in the returned array does not mean
    that you can connect to the local MySQL server, and if a certain database server
    is running on the local machine but its driver is not registered with PDO, then
    you will not be able to connect to that database server.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PDO API also standardises the transaction handling methods. By default, after
    the successful creation of the PDO connection, it is set to `autocommit` mode.
    This means that for every database that supports transactions, every query is
    wrapped in an implicit transaction. For those database that do not support transactions,
    every query is executed as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the transaction handling strategy is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the database-related code in a *try...catch* block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The database-related code (within the *try* block) should commit the changes
    after all the updates have been done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *catch* block should rollback the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, only the code that updates the database and the code that can break
    data integrity should be handled in a transaction. A classic example of a transaction
    is a money transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there is enough money on the payer''s account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Subtract the amount from the payer's account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the amount to the beneficiary's account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If anything bad happens in the middle of a transaction, the database does not
    get updated and the data integrity is preserved. Also, by wrapping the account
    balance check into the transaction, we ensure that a concurrent update does not
    corrupt data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO offers just three methods for transactions handling: `PDO::beginTransaction()`
    which initiates the transaction, `PDO::commit()` which commits the changes made
    since the call to `PDO::beginTransaction()`, and `PDO::rollBack()`, which rolls
    back any changes since the transaction has been initiated.'
  prefs: []
  type: TYPE_NORMAL
- en: The `PDO::beginTransaction()` method does not accept any parameters and returns
    a Boolean value depending on the success of the transaction initiation. If the
    call to this method fails, then PDO will throw an exception (for example, if you
    are already in the middle of a transaction, PDO will tell you so). Likewise, the
    `PDO::rollBack()` method will throw an exception if there is no active transaction,
    and the same will happen if you call the `PDO::commit()` method before calling
    `PDO::beginTransaction()`. (Of course, your error handling mode must be set to
    `PDO::ERRMODE_EXCEPTION` for the exceptions to be thrown.)
  prefs: []
  type: TYPE_NORMAL
- en: You should also be noted that you should not use direct queries to control transactions
    if you are using PDO for that task. By this, we mean that you should not issue
    queries such as `BEGIN TRANSATION, COMMIT`, or `ROLLBACK` with the `PDO::query()`
    method. Otherwise, the behaviour of these three methods will be inconsistent.
    Also, PDO does not currently support savepoints.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now get back to our library application. To see how transactions work
    in practice, we will modify it by allowing it to track how many copies of a certain
    book we have, and we will implement a function to keep track of people to whom
    we have lent books.
  prefs: []
  type: TYPE_NORMAL
- en: 'This modification will encompass the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We will have to alter the books table by adding a new column to keep the number
    of copies of every book. The `editBook.php` page will need to be modified in order
    to change this value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a table to keep track of all borrowers, but to keep the example
    simple, we will not create a table of borrowers (as we for a real-life library
    application). We will just associate a borrowers name with the book ID of the
    book that we have lent them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a page that will be used when we lend a book. This page, will
    ask for the borrowers name and then insert a record into the borrowers table and
    decrease the number of copies in the books table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also need a page, which will list all borrowers and another script,
    which will allow them to return a book. This script will delete a record from
    the borrowers table and increase the number of copies in the books table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use transactions only when we update two tables at once (as in the last
    two points in the above list).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do the coding, we will alter the books table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The same command should be executed for SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify `books.php` a bit to show how many copies of each book we
    have and to provide a link. Here are the line of code that will need to be changed
    (lines 20 to 58):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for both MySQL and SQLite you should see a page like the following screenshot
    (where we have scrolled downwards and to the right so that it will fit onto the
    page):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transactionsdriver listgetting, getAvailableDrivers() method used](graphics/2660_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create the borrowers table. As we have previously discussed, the
    table will contain an ID field, the book''s ID field, borrower''s name, and a
    timestamp column. We will need an ID (primary key) on this table to prevent possible
    data corruption; for example, if the same borrower takes the same book twice.
    If we were tracking borrowers by name and book ID only, then we could have duplicate
    records in that table and the return of a single book could delete several rows
    in this table, which would lead to data corruption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQLite, the syntax will be a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The page to *lend* the book (`lendBook.php`) is probably the most difficult
    part. This page will consist of a form where you can enter the borrower's name.
    Upon successful submission, the script will initiate the transaction, check that
    there is at least one copy of the book available, insert a record into the borrowers
    table and decrease the copies column in the books table, commit the transaction,
    and redirect to the `books.php` page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's run through the code now. We begin by checking that the book's ID has
    been passed to the script either via the URL or via the form. (We keep the ID
    in the hidden field of the form.) Then, if there is a form submission (with the
    submit button pressed), we check that the name field was correctly filled. If
    the test succeeds, we proceed to the transaction, where we count how many copies
    are left and check that this number is greater than zero, we decrease the copies
    column and use a prepared statement to insert a record into the `borrowers` table.
    If there is less than one copy, we add a message to the `$warnings` array so that
    a warning is displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: If there is some failure within the transaction, the `catch` block will be executed.
    The transaction will be rolled back and the exception will be thrown again. We
    do this in order to let our default error handler do its job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you save the above code listing in `lendBook.php` and click on one
    of the **Lend** links on the books listing page, you should arrive at the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transactionsdriver listgetting, getAvailableDrivers() method used](graphics/2660_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, you should switch between databases to see that the code works with
    MySQL and SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enhance the page, we should also show the title and the author of the book,
    but we will leave that to you. Also, if you are wondering why we are alerting
    users that there are no more copies only after the form submission, this is because
    we can decide on that within the transaction only. If we detect that there are
    copies available within the transaction, only then we may be assured that no concurrent
    update will change that. Of course, from the user's perspective, another addition
    might be a warning displayed along with the book's details. However, a check within
    the transaction is required too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you *lend* a book you will see that the **Copies** column on the books
    listing page has decreased. Let''s now create the page where all the borrowers
    and the books lent to them will be listed. Let''s call it `borrowers.php`. While
    this page does not process any user input, it contains a query that joins three
    tables (borrowers, books, and authors):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code is easy to follow; it follows the same logic as `books.php` or `authors.php`.
    However, since this page isn't linked from anywhere, we should add a link to it
    in the site header (the `showHeader()` function in `common.inc.php):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you navigate to `borrowers.php`, you should see something like this
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transactionsdriver listgetting, getAvailableDrivers() method used](graphics/2660_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, this page contains links to the `returnBook.php` page, which
    does not exist as yet. This script will delete the relevant record from the borrowers
    table and increment the copies column in the books table. This operation will
    be wrapped in a transaction, too. Also, `returnBook.php` accepts the borrower''s
    table ID field, (as opposed to `lendBook.php`, which accepted the book''s ID).
    So we should also get the book''s ID from the borrowers table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code should be fairly self-descriptive. In the first place we check that
    the request contains the borrower's ID and then update both tables. Upon successful
    completion we get redirected to the books listing page, otherwise, the error handler
    will display a relevant message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the final touch: the `editBook.php` page, which can be used to edit how
    many copies of the book we have. We will leave this to you, but here are some
    considerations. The suggested way of keeping track of books that have been lent
    is not very good for a real life library application. Instead of keeping the number
    of copies available, we should keep the total number of copies in the library
    in one column and the number of copies that have been lent in another column.
    This should be done, because editing the number of books available may lead to
    data corruption. Returning a book will increment the copies column in the books
    table. If someone else is editing the number of copies available at the same time,
    they may not know that a borrower is returning a book and hence may enter an incorrect
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if there were two separate columns, then updating the total
    number of copies would be completely independent from the updates caused by the
    books being lent and returned. In this scenario, however, the script that lends
    a book should check that the number of copies that have been lent is less than
    the total number of copies. The transaction should continue only if this condition
    is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a look at some of the extended functionality
    offered by PDO, especially transactions. Our application example was modified
    to provide additional functionality that relies on transactions. We also looked
    at the organization of the transaction-aware code.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you might have noticed, we were mixing code that updates databases,
    processes user input, and renders pages in one file. While we tried to keep the
    input processing and presentation in different parts of one file (first data processing,
    then page rendering), we could not separate data processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to separate the data model and the application
    logic so that the data can be accessed and manipulated from elsewhere, not just
    from our application. We will develop a data model class that will encapsulate
    our library application data handling methods. This class can then be used from
    other applications.
  prefs: []
  type: TYPE_NORMAL
