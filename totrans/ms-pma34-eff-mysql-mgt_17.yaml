- en: Chapter 17. Supporting Features Added in MySQL 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 5.0 introduced a number of new features that calmed down a number of developers
    and industry observers who were claiming that MySQL was inferior to competitors'
    products. Views, stored procedures, triggers, a standard `information_schema`,
    and (more recently) a profiling mechanism are now present in the MySQL spectrum.
    These features are covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Among the new features of MySQL 5.1, the ones that relate to a web interface
    (for example, partitioning and events) are supported in phpMyAdmin and are covered
    in this chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 5.0 introduced support for named and updatable views (more details are
    available at [http://dev.mysql.com/doc/refman/5.5/en/views.html)](http://dev.mysql.com/doc/refman/5.5/en/views.html)).
    A view is a derived table (consider it a virtual table) whose definition is stored
    in the database. A `SELECT` statement done on one or more tables (or even on views),
    can be stored as a view and can also be queried.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views can be used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the visibility of columns (for example, do not show salary information)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the visibility of rows (for example, do not show data for specific world
    regions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide a changed table structure (so that legacy applications can continue to
    work)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of defining cumbersome column-specific privileges on many tables, it's
    easier to prepare a view containing a limited set of columns from these tables.
    We can then grant permissions on the view as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: To activate support for views on a server after an upgrade from a pre-5.0 version,
    the administrator has to execute the `mysql_upgrade` program, as described in
    the MySQL manual ([http://dev.mysql.com/doc/refman/5.0/en/upgrading-from-previous-series.html](http://dev.mysql.com/doc/refman/5.0/en/upgrading-from-previous-series.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each user must have the appropriate `SHOW_VIEW` or `CREATE_VIEW` privilege to
    be able to see or manipulate views. These privileges exist at the global (server),
    database, and table levels.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view implies that the user has privileges on the tables involved,
    or at least a privilege such as `SELECT` or `UPDATE` on all the columns mentioned
    in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view from results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can take advantage of phpMyAdmin's **Search** (at the table level) or **Query**
    (at the database level) features to build a rather complex query, execute it,
    and then easily create a view from the results. We will see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that a view can be used to limit the visibility of columns (and,
    in fact, of tables). Let us say that the number of pages in a book is highly classified
    information. We open the `book` table, click on **Search**, and choose a subset
    of the columns that does not include the **page_count** column (we might have
    to open the **Options** slider).
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a view from results](img/7782_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on **Go** produces a results page, where we see a **CREATE VIEW**
    link in the **Query results operations** section. We use this link to access the
    view creation panel, which already has the underlying query in the **AS** box.
    We need to choose a name for this view (here, we use **book_public_info)**, and
    we can optionally set different column names for it (here, we use **number, title)**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a view from results](img/7782_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other options can influence the view's behavior, and have been explained
    in the MySQL manual ([http://dev.mysql.com/doc/refman/5.5/en/create-view.html](http://dev.mysql.com/doc/refman/5.5/en/create-view.html)).
    The `LOCAL CHECK OPTION` clause influences the behavior of the updateable views
    (this is explained in the MySQL manual at the page cited previously).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Go** generates the view we asked for. At this point, the view
    has been created. If we refresh our browser''s page and then access the `marc_book`
    database, we will see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a view from results](img/7782_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the main panel, we see the information on the newly-created view. The number
    of rows for the view currently indicates **~0** (more on this in the *Controlling
    row counting for improved performance* section, later in this chapter), and **View**
    is indicated in the **Type** column. There is no collation or size associated
    with a view.
  prefs: []
  type: TYPE_NORMAL
- en: Main panel and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a view has similarities with a table, its name is available along with the
    names of the ordinary tables. On clicking the view name, a panel similar to the
    one seen for tables is displayed, but with fewer menu tabs than seen in a normal
    table. Indeed, some operations do not make sense on a view, for example, **Import**.
    This is because a view does not actually contain data. However, other actions,
    such as **Browse**, are perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us browse the view shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Main panel and views](img/7782_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We notice that, in the generated SQL query, we do not see our original `CREATE
    VIEW` statement. The reason is that we are selecting from the view using a `SELECT`
    statement, hiding the fact that we are pulling data from a view. However, exporting
    the view''s structure would show how MySQL internally stored our view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main panel's menu may look similar to that of a table. However, when necessary,
    phpMyAdmin generates the appropriate syntax for handling views.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To perform actions on existing views, a user needs to have the appropriate privilege
    at the view level, but not necessarily any privilege on the tables involved in
    this view. This is how we can achieve column and table hiding.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling row counting for improved performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'phpMyAdmin has a configuration parameter, `$cfg[''MaxExactCountViews'']`, that
    controls the row-counting phase of phpMyAdmin. Sometimes, a view comprises many
    huge tables, and browsing it would make a large number of virtual rows appear.
    Therefore, the default value of 0 for this parameter ensures that no row counting
    happens for views. In this case, we will see rather strange results when browsing
    a view: **Showing rows 0 - -1 (0 total, Query took 0.0006 sec)**. This is more
    acceptable than slowing down a server.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, if we prefer to see a more exact row count for views, we can put
    a larger value in this parameter, which acts as an upper limit for the row counting
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting routines—stored procedures and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It took a while before phpMyAdmin started to include support for stored procedures
    and functions. The reason is that these are blocks of code (like a sub-program)
    that are kept as a part of the database. phpMyAdmin, being a web interface, is
    more oriented towards operations that are performed quickly using a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, phpMyAdmin has a few features that permit a developer to create
    such routines, save them, recall them to make some modifications, and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures are accessed by a `CALL` statement to which we can pass parameters
    (more details at [http://dev.mysql.com/doc/refman/5.5/en/call.html)](http://dev.mysql.com/doc/refman/5.5/en/call.html)).
    On the other hand, functions are accessed from SQL statements (for example, `SELECT)`,
    and are similar to other MySQL internal functions, thus returning a value.
  prefs: []
  type: TYPE_NORMAL
- en: The `CREATE ROUTINE` and `ALTER ROUTINE` privileges are needed to be able to
    create, see, and delete a stored procedure or function. The `EXECUTE` privilege
    is needed to run the routine, although the privilege is normally granted automatically
    to the routine's creator.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stored procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a procedure to change the page count for a specific book, by
    adding a specific number of pages. The book's ISBN and the number of pages to
    be added will be the input parameters to this procedure. We are using the SQL
    query box (refer to [Chapter 11)](ch11.html "Chapter 11. Entering SQL Statements")
    to enter this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the delimiter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard SQL delimiter is the semicolon, and this character will be used
    inside our procedure to delimit SQL statements. However, the `CREATE PROCEDURE`
    statement is by itself a SQL statement; hence, we must come up with a way to indicate
    to the MySQL parser where this statement ends. The query box has a **Delimiter**
    input box, which contains a semicolon by default. Therefore, we change it to another
    string, which, by convention, is a double slash `"//"`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the delimiter](img/7782_17_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entering the procedure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We then enter the procedure''s code in the main query box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On clicking **Go**, we get a success message if the syntax is correct. If it
    is not, well it's time to revise our typing abilities or debug our syntax. Unfortunately,
    MySQL does not come with a procedure debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, in the query box, we test our procedure by entering the following statements.
    Here, we are using a SQL variable, `@message`, which will receive the contents
    of the `OUT` parameter `param_message:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If all went well, we should see that the **@message** variable contains **success**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then verify whether the page count for this book has increased. We also
    need to test the problematic case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This procedure is now available for calling (for example) from your PHP scripts
    using the `mysqli` extension, which is the one recommended to access all the functionalities
    provided by MySQL 4.1 and above.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating procedures and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A procedure is stored inside a database, and is not tied to a specific table.
    Therefore, the interface for manipulating procedures and functions can be found
    at the database level, on the **Structure** page under the **Routines** slider,
    which appears if at least one routine is already defined.
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating procedures and functions](img/7782_17_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first icon brings this procedure's text into a query box for editing. The
    second icon would be used to delete this procedure. When editing the procedure,
    we notice that the text has been somewhat modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, a `DROP PROCEDURE` statement appears. This is normal because MySQL does
    not offer a statement that would permit changing the body of a procedure. Therefore,
    we have to delete a procedure every time we want to change it. It's true that
    the `ALTER PROCEDURE` statement exists, but it can only change the procedure's
    characteristics, for example, by adding a comment. Then, a `DEFINER` clause is
    shown. It was generated at creation time, and indicates who created this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we make any changes we need to the code, and click on **Go**
    to save this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It might be tempting to open the `book` table on its **Structure** page and
    look for a list of procedures that manipulate this table, such as our `add_page()`
    procedure. However, all procedures are stored at the database level, and there
    is no direct link between the code itself `(UPDATE book)` and the place where
    the procedure is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Manually creating a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are similar to stored procedures. However, a function may return just
    one value, whereas a stored procedure can have more than one `OUT` parameter.
    On the other hand, using a stored function from within a `SELECT` statement may
    seem more natural as it avoids the need for an intermediate SQL variable to hold
    the value of an `OUT` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: What is the goal of functions? As an example, a function can be used to calculate
    the total cost of an order, including tax and shipping. Putting this logic inside
    the database instead of at the application level helps to document the application-database
    interface. It also avoids duplicating business logic in every application that
    needs to deal with this logic.
  prefs: []
  type: TYPE_NORMAL
- en: We should not confuse MySQL 5.0 functions with **UDF** **(User-Defined Functions)**,
    which existed prior to MySQL 5.0\. A UDF consists of code written in C or C++,
    compiled into a shared object, and referenced with a `CREATE FUNCTION` statement
    and the `SONAME` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'phpMyAdmin''s treatment of functions is, in many ways, similar to what we have
    covered in procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: A query box in which to enter a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a delimiter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mechanism to manipulate a function that is already defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us define a function that retrieves the country name, based on its code.
    I prefer to use a `param_` prefix to clearly identify the parameters inside the
    function's definition and a `var_` prefix for local variables. We will use our
    trusty SQL query box to enter the function's code, again indicating to this box
    to use `//` as the delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We should note that our newly-created function can be seen on the database''s
    **Structure** page, along with its friend, the `add_page` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manually creating a function](img/7782_17_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test the function we just created, enter the following query in a query box
    (refer to [Chapter 11):](ch11.html "Chapter 11. Entering SQL Statements")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exporting stored procedures and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When exporting a database, procedures and functions appear in an SQL export.
    This is because the **Add CREATE PROCEDURE / FUNCTION / EVENT** checkbox is selected
    by default in the **Object creation options** dialog of the **Export** page (it
    can be seen in the **Custom** export mode). Here is the part of the export file
    related to procedures and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Executing code with triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Triggers** are code that we associate with a table to be executed when certain
    actions occur, for example, after a new `INSERT` statement in the `book` table.
    The action does not need to happen within phpMyAdmin.'
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to routines that are related to an entire database and are visible
    on the database's **Structure** page, triggers for each table are accessed from
    this specific table's **Structure** page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to MySQL 5.1.6, we needed the `SUPER` privilege to create and delete triggers.
    In version 5.1.6, a `TRIGGER` table-level privilege was added to the privilege
    system. Hence, a user no longer needs the powerful `SUPER` privilege for these
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform the following exercise, we will need a new `INT` column—`total_page_count`—in
    our `author` table.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is that every time a book is created, its page count will be added
    to the total page count of the books from this author. Some people may advocate
    that it would be better not to keep a separate column for the total here, and
    instead compute the total every time we need it. In fact, a design decision must
    be made when dealing with this situation in the real world. Do we need to retrieve
    the total page count very quickly, for example, for web purposes? what is the
    response time to compute this value from a production table with thousands of
    rows? Anyway, since I need it as an example, the design decision is easy to make
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Let us not forget that following its addition to the table's structure, the
    `total_page_count` column should initially be seeded with the correct total. (However,
    this is not the purpose of our trigger.)
  prefs: []
  type: TYPE_NORMAL
- en: Manually creating a trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current phpMyAdmin version does not have an interface for trigger creation.
    Therefore, we enter the trigger definition in a query box taking special care
    to enter `//` in the delimiter box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, the **Structure** page for our `book` table reveals a new **Triggers**
    section that can be used the same way as routines, to edit or delete a trigger,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manually creating a trigger](img/7782_17_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to testing stored procedures or functions, there is neither a `CALL`
    sequence nor a function inside a `SELECT` statement to execute the trigger. Any
    time the defined operation (a book `INSERT)` happens, the code will execute (in
    our case, after the insertion). Therefore, we simply have to insert a new book
    to see that the `author.total_page_count` column is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a completely automatic management of this column would involve creating
    `AFTER UPDATE` and `AFTER DELETE` triggers on the `book` table.
  prefs: []
  type: TYPE_NORMAL
- en: Using information_schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the SQL:2003 Standard, access to the data dictionary (or database metadata)
    is provided by a structure called `information_schema`. As this is part of the
    Standard, and already exists in other database systems, the decision to implement
    this feature into MySQL was a very good one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL has added some information that is not part of the standard, for example,
    `INFORMATION_SCHEMA.COLUMNS.COLUMN_TYPE`. Be aware of the fact that if you use
    this information in a software project, it might not be portable to other SQL
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: A phpMyAdmin user sees the `information_schema` as a normal database containing
    views. These views describe many aspects of the structure of the databases hosted
    on this server. The following screenshot shows a subset of what can be seen (and
    in fact, the only possible operation on this database is `SELECT):`
  prefs: []
  type: TYPE_NORMAL
- en: '![Using information_schema](img/7782_17_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Internally, phpMyAdmin can call the `information_schema`, instead of the corresponding
    `SHOW` statements to retrieve metadata. This behavior is controlled by the `$cfg['Servers'][$i]['DisableIS']`
    directive. Some `SELECT` operations involving a `WHERE` clause on `information_schema`
    are really slow (many minutes of wait time) when the server hosts hundreds of
    databases or tables, and this is yet to be fixed by the MySQL team; this is why
    this directive is set to `true` by default, thus avoiding the use of `information_schema`.
  prefs: []
  type: TYPE_NORMAL
- en: The `$cfg['Servers'][$i]['hide_db']` parameter can be used to hide this "database"
    to users who might be confused by the sudden appearance of a database that they
    know nothing about. It will probably depend on their level of expertise in MySQL.
    On a multi-user installation of phpMyAdmin, we cannot please everyone about this
    parameter's value.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User-defined partitioning (refer to [http://dev.mysql.com/doc/refman/5.1/en/partitioning.html](http://dev.mysql.com/doc/refman/5.1/en/partitioning.html))
    is offered in MySQL 5.1\. It allows us to "distribute portions of individual tables
    across a file system according to rules which you can set largely as needed".
    Using this feature in phpMyAdmin requires knowledge of its syntax as there are
    many partition types. Also, for each partition type, the number of partitions
    and the values associated with each partition are too random to be easily represented
    on a web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table with partitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us try it by creating a table named `test` with one column **id**. On the
    table creation panel, if connected to a MySQL 5.1 server, phpMyAdmin shows a **PARTITION
    definition** dialog, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a table with partitions](img/7782_17_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we enter a `PARTITION BY RANGE` clause, which will create partitions
    on the **id** column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Maintaining partitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a table on which a partition has been defined, the **Operations** page
    displays a **Partition maintenance** dialog where we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose a partition and then request an action, such as **Rebuild**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the partitioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Maintaining partitions](img/7782_17_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exporting a partition definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, exporting this `test` table in SQL mode produces statements with embedded
    comments that a MySQL 5.1 server would recognize and interpret in order to recreate
    the same partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the event scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Event Scheduler** ([http://dev.mysql.com/doc/refman/5.1/en/events.html](http://dev.mysql.com/doc/refman/5.1/en/events.html)),
    another new feature of MySQL 5.1, permits the creation of tasks that will run
    automatically according to a schedule. The schedule is quite flexible and permits,
    for example, a statement to be run every ten seconds, starting from midnight of
    May 18, 2011\. These can be one-time events or recurring ones.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should first verify whether the scheduler is active on our server. If not,
    we need to activate it. Otherwise, nothing will happen! We will start by entering
    the following statement in the query box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look in the results for a variable named `event_scheduler`. If this
    variable is set to `OFF`, we need to ask the system administrator (or someone
    with the `SUPER` privilege) to execute the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Granting EVENT permission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every user who wants to create or drop an event needs the `EVENT` privilege,
    either globally or on the database on which he or she plans to add the event.
    Please refer to [Chapter 19](ch19.html "Chapter 19. Administrating the MySQL Server")
    for details about granting such privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current phpMyAdmin version does not have an interface on which we could
    choose the various parts of the `CREATE EVENT` statement. Therefore, the only
    method left is to use the SQL query box to enter the statement and to understand
    its syntax! Here, we will use a totally fictitious example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can now get some amusement by browsing the `author` table once in a while,
    and see the counter incrementing for author 1.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are related to a single database, which is why you see an **Events**
    slider on the **Structure** page for the `marc_book` database. Activating it reveals
    the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating events](img/7782_17_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Indeed, this is a recurring event. We can use the first icon to edit the event
    (which will have the effect of deleting and recreating the event), and the second
    icon to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible to generate event-related statements at the end of an SQL database
    export file by selecting the **Add CREATE PROCEDURE / FUNCTION / EVENT** option.
    Please remember that some events may have an expiration time. Hence, they may
    have vanished between the time you create them and the time you attempt to export
    them, unless the `ON COMPLETION PRESERVE` clause was used when creating the event.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL 5.0's new features helped the product to comply with standards. Even though
    phpMyAdmin has limited support for these features (especially lacking a syntax-oriented
    editor), it has a basic set of features to work with views, routines, triggers,
    and `information_schema`. phpMyAdmin also supports MySQL 5.1 partitions and events.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the use of the tracking feature that permits the recording
    of changes made to a MySQL database via phpMyAdmin.
  prefs: []
  type: TYPE_NORMAL
