- en: Chapter 9. Modular Programming as a Foundation for Good Programming Technique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way in this book. From learning how modules and packages
    work in Python, and how to use them to better organize your code, we have discovered
    many of the common practices used to apply modular patterns to solve a range of
    programming problems. We have seen how modular programming allows us to deal with
    changing requirements in a real-world system in the best possible way, and learned
    what makes a module or package a suitable candidate for reuse in new projects.
    We have seen many of the more advanced techniques for working with modules and
    packages in Python, as well as ways of avoiding the pitfalls that you may encounter
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at ways of testing your code, how to use a source code management
    system to keep track of the changes you make to your code over time, and how to
    submit your module or package to the Python Package Index (PyPI) so that others
    can find and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using what we have learned thus far, you will be able to competently apply modular
    techniques to your Python programming efforts, creating robust and well-written
    code that can be reused in a variety of programs. You can also share your code
    with others, both inside your organization and within the wider Python developer
    community.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter, we will use a practical example to show how modules
    and packages do far more than just organize your code: they help to deal with
    the *process* of programming more effectively. We will see how modules are vital
    to the design and development of any large system, and demonstrate how the use
    of modular techniques to create robust, useful and well-written modules is an
    essential part of being a good programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: The process of programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All too often as programmers, we focus on the technical details of a program.
    That is, we focus on the *product* rather than the *process* of programming. The
    difficulties of solving a particular programming problem are so great that we
    forget that the problem itself will change over time. No matter how much we try
    to avoid it, change is inevitable: changing markets, changing requirements, and
    changing technologies. As programmers, we need to be able to effectively cope
    with this change just as much as we need to be able to implement, test, and debug
    our code.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 4](ch04.html "Chapter 4. Using Modules for Real-World Programming"),
    *Using Modules for Real-World Programming*, we looked at an example program that
    faced the challenge of changing requirements. We saw how a modular design allowed
    us to minimize the amount of code that had to be rewritten when the scope of the
    program increased well beyond what was first envisaged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned more about modular programming and the related technologies
    that can help to make it more effective, let''s work through this exercise again.
    This time, we''ll choose a simple package for counting the number of occurrences
    of some event or object. For example, imagine that you need to keep a count of
    the number of animals of each type you see while walking across a farm. As you
    see each type of animal, you record its presence by passing it to the counter,
    and at the end, the counter will tell you how many animals of each type you have
    seen. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple package, but it gives us a good target for applying some of
    the more useful techniques we have learned in the previous chapters. In particular,
    we will make use of **docstrings** to document what each function in our package
    does, and we will write a series of **unit tests** to ensure that our package
    is working the way we expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a directory to hold our new project, which we will
    call Counter. Create a directory named `counter` somewhere convenient, and then
    add a new file named `README.rst` to this directory. Since we expect to eventually
    upload this package to the Python Package Index, we will use reStructuredText
    format for our README file. Enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at how this package might be used. Imagine that you
    wanted to keep a count of the number of cars of each color which were observed
    in a given timeframe. You would start by making the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then when you identify a car of a given color, you would make the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once the time period is over, you would obtain the various colors
    and how often they occurred in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The counter can then be reset to start counting another set of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now implement this package. Inside our `counter` directory, create another
    directory named `counter` to hold our package''s source code, and create a package
    initialization file (`__init__.py`) inside this innermost `counter` directory.
    We''ll follow the pattern we used earlier and define our package''s public functions
    in a module named `interface.py`, which we will then import into the `__init__.py`
    file to make the various functions available at the package level. To do this,
    edit the `__init__.py` file and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next task is to implement the `interface` module. Create the `interface.py`
    file inside the `counter` package directory, and enter the following into this
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These are just placeholders for our `counter` package's public functions; we'll
    implement these one at a time, starting with the `reset()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the recommended practice of documenting each function using a docstring,
    let''s start by describing what this function does. Edit the existing definition
    for your `reset()` function so that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember that a docstring is a triple-quoted string (a string that spans multiple
    lines) which is "attached" to a function. A docstring typically starts with a
    one line description of what the function does. If more information is required,
    this will be followed by a single blank line, followed by one or more lines describing
    the function in more detail. As you can see, our docstring consists of a one-line
    description and one additional line providing more information about our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement this function. Since our counter package needs to
    keep track of the number of times each unique value has occurred, it makes sense
    to store this information in a dictionary mapping unique values to the number
    of occurrences. We can store this dictionary as a private global variable which
    is initialized by our `reset()` function. Knowing this, we can go ahead and implement
    the remainder of our `reset()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the private `_counts` global defined, we can now implement the `add()`
    function. This function records the occurrence of a given value, storing the results
    into the `_counts` dictionary. Replace your placeholder implementation of the
    `add()` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There shouldn''t be any surprises here. Our final function, `totals()`, returns
    the values which were added to the `_counts` dictionary, along with how often
    each value occurred. Here is the necessary code, which should replace your existing
    placeholder for the `totals()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes our first implementation of the `counter` package. We''ll try
    it out using the ad hoc testing techniques we learned about in the previous chapter:
    open a terminal or command-line window and use the `cd` command to set the current
    directory to the outermost `counter` directory. Then, type `python` to start the
    Python interactive interpreter, and try entering the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This tells you that the value `1` occurred twice and the value `2` occurred
    once—which is exactly what your calls to the `add()` function indicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our package appears to be working, let''s create some unit tests so
    that we can test our package more systematically. Create a new file named `tests.py`
    in the outermost `counter` directory and enter the following code into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have written two unit tests: one to check that the values
    we added are reflected in the counter''s totals, and a second test to ensure that
    the `reset()` function is correctly resetting the counter, discarding any values
    that were added before `reset()` was called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run these tests, exit the Python interactive interpreter by pressing *Control*
    + *D*, and then type the following into the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, you should see the following output, indicating that both of
    your unit tests ran without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The inevitable changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this stage, we now have a properly working `counter` package with good documentation
    and unit tests. Imagine, however, that the requirements for your package now changes,
    causing major problems for your design: instead of keeping a simple count of the
    number of unique values, you now need to support *ranges* of values. For example,
    the user of your package might define ranges of values from 0 to 5, 5 to 10, and
    10 to 15; values within each range are grouped together for the purposes of counting.
    The following illustration shows how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The inevitable changes](graphics/B05012_9_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To allow your package to support ranges, you will need to change the interface
    to the `reset()` function to accept an optional list of range values. For example,
    to count values between 0 and 5, 5 and 10, and 10 and 15, the `reset()` function
    can be called with the following parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If no parameter is passed to `counter.reset()`, then the entire package should
    continue to work as it does at present, recording unique values rather than ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this new feature. First off, edit the `reset()` function so
    that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here, other than changing the documentation, is that we
    now accept an optional `ranges` parameter and store this into the private `_ranges`
    global.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now update the `add()` function to support ranges. Change your source
    code so that this function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's no change to the interface for this function; the only difference is
    behind the scenes, where we now check to see whether we are calculating totals
    for the ranges of values, and if so, we set the key into the `_counts` dictionary
    to be a `(min_value, max_value)` tuple identifying the range. This code is a little
    messy, but it works, nicely hiding this complexity from the code using this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final function we need to update is the `totals()` function. The behavior
    of this function will change if we are using ranges. Edit your copy of the interface
    module so that the `totals()` function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is a bit complicated, but we have updated our function''s docstring
    to describe the new behavior. Let''s now test our code; fire up the Python interpreter
    and try entering the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All going well, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This corresponds to the three ranges you have defined, and shows that there
    are three values falling into the first range, two falling into the second range,
    and just one value falling into the third range.
  prefs: []
  type: TYPE_NORMAL
- en: Change management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, it seems that your updated package is a success. Just like the
    example we saw in [Chapter 6](ch06.html "Chapter 6. Creating Reusable Modules"),
    *Creating Reusable Modules*, we were able to use modular programming techniques
    to limit the number of changes that were needed to support a major new feature
    within our package. We have performed some tests, and the updated package seems
    to be working as it should.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we won''t stop there. Since we added a major new feature to our package,
    we should add some unit tests to ensure that this feature is working as it should.
    Edit your `tests.py` script and add the following new test case to this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the code we used for our ad hoc testing. After saving
    the updated `tests.py` script, run it. This should reveal something very interesting:
    your new package suddenly crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `test_range_totals()` unit test is failing because our package crashes
    with an `UnboundLocalError` when we try to add the value `19.1` to our ranged
    counter. A moment''s reflection will show what is wrong here: we have defined
    three ranges, `0-5`, `5-10`, and `10-15`, but we are now trying to add the value
    `19.1` to our counter. Since `19.1` is outside of the ranges we have set up, our
    package can''t assign a range to this value, so our `add()` function is crashing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy enough to fix this problem; add the following highlighted lines
    to your `add()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This causes our package to return a `RuntimeError` if the user attempts to add
    a value that falls outside of the ranges that we have set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, our unit test is still crashing, only now it fails with a `RuntimeError`.
    To fix this, remove the `counter.add(19.1)` line from the `test_range_totals()`
    unit test. We still want to test for this error condition, but we''ll do so in
    a separate unit test. Add the following to the end of your `RangeCounterTestCase`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This unit test checks specifically for the error condition we found earlier,
    and ensures that the package is correctly returning a `RuntimeError` if the supplied
    value is outside of the requested ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we now have four separate unit tests defined for our package. We
    are still testing the package to make sure it runs without ranges, as well as
    testing all our range-based code. Because we have implemented (and are starting
    to flesh out) a range of unit tests for our package, we can be confident that
    any changes we made to support ranges won't break any existing code that doesn't
    use the new range-based features.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the modular programming techniques we have used help us minimize
    the changes required to our code, and the unit tests we have written help to ensure
    that the updated code continues to work as we expect it to. In this way, the use
    of modular programming techniques allow us to deal with changing requirements
    and the ongoing process of programming in the most effective way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no escaping the fact that computer programs are complicated. In fact,
    as the requirements for a package changes, this complexity only seems to increase
    over time—programs rarely become simpler as you go along. Modular programming
    techniques are an excellent way of dealing with this complexity. Through the application
    of modular techniques and technologies, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Use modules and packages to keep your code well organized no matter how complicated
    it becomes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the standard patterns for modular design, including the divide-and-conquer
    technique, abstraction, and encapsulation, to keep this complexity to a minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply unit testing techniques to ensure that your code continues to work as
    it should as you change and expand the scope of your module or package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write module- and function-level docstrings to clearly describe what each part
    of your code does so that you can keep track of everything as your program grows
    and changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a sense of just how vital these modular techniques and technologies are,
    just think for a moment how much of a mess you would end up with if you do not
    use them while developing a large, complex, and changing system. Without modular
    design techniques and the application of standard patterns such as divide-and-conquer,
    abstraction, and encapsulation, you would find yourself writing disorganized spaghetti
    code with many unexpected side-effects and with new features and changes spread
    throughout your source code. Without unit testing, you would have no way of ensuring
    that your code continues to work as it should as you make changes to it. Finally,
    the lack of embedded documentation would make it very hard to keep track of all
    the various pieces of your system, leading to bugs and poorly-thought-out changes
    as you continue to develop and expand your code.
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons, it is clear that modular programming techniques are vital
    to the design and development of any large system, because they help you to deal
    with complexity in the best way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Being an effective programmer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have seen just how useful modular programming techniques are, you
    might wonder why anyone would not want to use them. Other than a lack of understanding,
    why would a programmer eschew modular principles and techniques?
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python language has been designed from the ground up to support good modular
    programming techniques, and with the addition of excellent tools such as the Python
    Standard Library, unit tests, and docstrings, it encourages you to apply these
    techniques to your everyday programming practice. Similarly, the use of indentation
    to define the structure of your code automatically encourages you to write well-formatted
    source code where the indentation of your code reflects the logical organization
    of your program. These are not random choices: Python encourages good programming
    practices every step of the way.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, just like you can write poorly structured and incomprehensible spaghetti
    code using Python, it is possible to avoid using modular techniques and practices
    while developing your programs. But why would you want to?
  prefs: []
  type: TYPE_NORMAL
- en: Programmers sometimes take shortcuts when writing programs that they consider
    to be "throwaway" code. For example, perhaps you're writing a tiny program that
    you expect to only use once, and then never need to use again. Why take the extra
    time to apply the recommended modular programming practices to this throwaway
    program?
  prefs: []
  type: TYPE_NORMAL
- en: The thing is, throwaway code has a funny habit of becoming permanent and growing
    into something much larger. Often, what begins as throwaway code becomes the basis
    for a large and complex system. Code you wrote six months ago can be found and
    reused in a new program. In the end, you never know what is throwaway code and
    what isn't.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, it is a good idea to *always* apply modular programming practices
    to your code, no matter how large or small it might be. While you won't want to
    spend a lot of time writing extensive docstrings and unit tests for a simple throwaway
    script, you can still apply basic modular techniques to help keep your code organized.
    Don't just save modular programming techniques for your "big" projects.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the way Python has implemented modular programming makes it extremely
    easy to use, and after a while, you begin to *think* in modular terms before you
    even start writing a single line of code. I believe this is a good thing, because
    modular programming techniques are an essential part of being a good programmer,
    and you should practice these techniques whenever you sit down to program.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, and indeed in this entire book, we have looked at how the application
    of modular programming techniques help you deal with the *process* of programming
    in the most effective way possible. Rather than avoiding change, you are able
    to manage it so that your code continues to work and is improved over time by
    the new requirements that are thrown at it.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at another example of a program that needed to be changed to
    meet an expanding set of requirements, and have seen how modular techniques, including
    the use of docstrings and unit tests, help to write robust and easy to understand
    code that improves as it continues to be developed and changed.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how the application of modular techniques is a vital part of dealing
    with the complexity of a program, and that this complexity only increases over
    time. We have learned that, because of this, the use of modular programming techniques
    is an essential part of what it means to be a good programmer. Finally, we have
    seen that modular techniques are something that can be used every time you sit
    down to program, even for simple throwaway scripts, and not something to be saved
    for your "big" projects.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have found this introduction to the world of modular programming
    useful, and are now starting to apply modular techniques and patterns to your
    own programming. I encourage you to continue to learn as much as you can about
    the various tools that surround good modular programming practice, such as the
    use of docstrings and the Sphinx library to auto-generate documentation for your
    packages, and the use of `virtualenv` to set up and use virtual environments to
    manage your program's package dependencies. The more you continue to use modular
    practices and techniques, the easier it will become—and the more effective you
    will be as a programmer. Happy coding!
  prefs: []
  type: TYPE_NORMAL
