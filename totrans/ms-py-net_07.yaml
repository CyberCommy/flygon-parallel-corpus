- en: Network Monitoring with Python – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you get a call at 2:00 a.m. in the morning. The person on the other
    end says: "Hi, we are facing a difficult issue that is impacting production services*.*
    We suspect it might be network-related. Can you check this for us? For this type
    of urgent, open-ended question, what would be the first thing you do?" Most of
    the time, the thing that comes to mind would be: What changed between the time
    when the network was working until something went wrong? Chances are you would
    check your monitoring tool and see if any of the key metrics changed in the last
    few hours. Better yet is if you have received any monitoring alerts from any metric
    baseline deviation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, we have been discussing various ways to systematically
    make predictable changes to our network, with the goal of keeping the network
    running as smoothly as possible. However, networks are not static – far from it –
    they are probably one of the most fluid parts of the entire infrastructure. By
    definition, a network connects different parts of the infrastructure together,
    constantly passing traffic back and forth. There are lots of moving parts that
    can cause your network to stop working as expected: hardware failures, software
    with bugs, human mistakes despite their best intentions, and many more. It is
    not a question of whether things would go wrong, but rather a question of when
    and what went wrong when it happens. We need ways to monitor our network to make
    sure it works as expected and hopefully be notified when it does not.'
  prefs: []
  type: TYPE_NORMAL
- en: In upcoming two chapters, we will look at various ways to perform network monitoring
    tasks. Many of the tools we have looked at thus far can be tied together or directly
    managed by Python. Like many tools we have looked at, network monitoring has to
    do with two parts. First, we need to know what information the equipment is capable
    of transmitting. Second, we need to identify what useful information we can interpret
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at a few tools that allow us to monitor the network effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Simple Network Management Protocol** (**SNMP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matplotlib and Pygal visualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MRTG and Cacti
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not exhaustive, and there is certainly no lack of commercial vendors
    in the network monitoring space. The basics of network monitoring that we will
    look at, however, carry well for both open source and commercial tools.
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The lab for this chapter is similar to the one in [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml),
    *Network Security with Python*, but with this difference: both of the network
    devices are IOSv devices. Here''s an illustration of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5e51171c-d3e7-46ad-b1bc-1d0afade785a.png)'
  prefs: []
  type: TYPE_IMG
- en: The two Ubuntu hosts will be used to generate traffic across the network so
    that we can look at some non-zero counters.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SNMP is a standardized protocol used to collect and manage devices. Although
    the standard allows you to use SNMP for device management, in my experience, most
    network administrators prefer to keep SNMP as an information collection mechanism
    only. Since SNMP operates on UDP, which is connectionless, and considering the
    relatively weak security mechanism in versions 1 and 2, making device changes
    via SNMP tends to make network operators a bit uneasy. SNMP version 3 has added
    cryptographic security and new concepts and terminologies to the protocol, but
    the way the technology is adapted varies among network device vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'SNMP is widely used in network monitoring and has been around since 1988 as
    part of RFC 1065\. The operations are straightforward, with the network manager
    sending `GET` and `SET` requests toward the device and the device with the SNMP
    agent responding with the information per request. The most widely adopted standard
    is SNMPv2c, which is defined in RFC 1901 – RFC 1908\. It uses a simple community-based
    security scheme for security. It has also introduced new features, such as the
    ability to get bulk information. The following diagram displays the high-level
    operation for SNMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3503470-34a9-43fc-8986-07ffaa47eb09.png)SNMP operations'
  prefs: []
  type: TYPE_NORMAL
- en: The information residing in the device is structured in the **Management Information
    Base** (**MIB**). The MIB uses a hierarchical namespace containing an **Object
    Identifier** (**OID**), which represents the information that can be read and
    fed back to the requester. When we talk about using SNMP to query device information,
    we are really talking about using the management station to query the specific
    OID that represents the information we are after. There is a common OID structure,
    such as systems and interfaces OID, that is shared among vendors. Besides common
    OID, each vendor can also supply an enterprise-level OID that is specific to them.
  prefs: []
  type: TYPE_NORMAL
- en: As an operator, you are required to put some effort into consolidating information
    into an OID structure in your environment to retrieve useful information. This
    can sometimes be a tedious process of finding one OID at a time. For example,
    you might be making a request to a device OID and receive a value of 10,000\.
    What is that value? Is that interface traffic? Is it in bytes or bits? Or maybe
    it is a number of packets? How do we know? We will need to consult either the
    standard or the vendor documentation to find out. There are tools that help with
    this process, such as a MIB browser that can provide more metadata to the value.
    But, at least in my experience, constructing an SNMP-based monitoring tool for
    your network can sometimes feel like a cat-and-mouse game of trying to find that
    one missing value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the main points to take away from the operation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation relies heavily on the amount of information the device agent
    can provide. This, in turn, relies on how the vendor treats SNMP: as a core feature
    or an added feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP agents generally require CPU cycles from the control plane to return a
    value. Not only is this inefficient for devices with, say, large BGP tables, it
    is also not feasible to use SNMP to query the data at small intervals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user needs to know the OID in order to query the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since SNMP has been around for a while, my assumption is that you have some
    experience with it already. Let's jump directly into package installation and
    our first SNMP example.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's make sure that we have the SNMP managing device and agent work in
    our setup. The SNMP bundle can be installed on either the hosts (client or server)
    in our lab or the managing device on the management network. As long as the SNMP
    manager has IP reachability to the device and the managed device allows the inbound
    connection, SNMP should work. In production, you should only install the software on
    the management host and only allow SNMP traffic in the control plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this lab, we have installed SNMP on both the Ubuntu host on the management
    network and the client host in the lab to test security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step would be to turn on and configure the SNMP options on the network
    devices, `iosv-1` and `iosv-2`. There are many optional parameters you can configure
    on the network device, such as contact, location, chassis ID, and SNMP packet
    size. The options are device-specific and you should check the documentation on
    your device. For IOSv devices, we will configure an access list to limit only
    the desired host for querying the device as well as tying the access list with
    the SNMP community string. In our case, we will use the word `secret` as the read-only
    community string and `permit_snmp` as the access list name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The SNMP community string is acting as a shared password between the manager
    and the agent; therefore, it needs to be included any time you want to query the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this chapter, finding the right OID is oftentimes half
    of the battle when working with SNMP. We can use tools such as the Cisco IOS MIB
    locator ([http://tools.cisco.com/ITDIT/MIBS/servlet/index](http://tools.cisco.com/ITDIT/MIBS/servlet/index))
    for finding specific OIDs to query. Alternatively, we can just start walking through
    the SNMP tree, starting from the top of Cisco''s enterprise tree at `.1.3.6.1.4.1.9`.
    We will perform the walk to make sure that the SNMP agent and the access-list
    are working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can be more specific about the OID we need to query as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a matter of demonstration, what if we type in the wrong value by `1` digit
    from `0` to `1` at the end of the last OID? This is what we would see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unlike API calls, there are no useful error codes nor messages; it simply stated
    that the OID does not exist. This can be pretty frustrating at times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to check would be the access list we configured will deny unwanted
    SNMP queries. Because we had the `log` keyword for both the permit and deny entries
    in the access-list, only `172.16.1.173` is permitted to query the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the biggest challenge in setting up SNMP is to find the right
    OID. Some of the OIDs are defined in standardized MIB-2; others are under the
    enterprise portion of the tree. Vendor documentation is the best bet, though.
    There are a number of tools that can help, such as a MIB browser; you can add
    MIBs (again, provided by the vendors) to the browser and see the description of
    the enterprise-based OIDs. A tool such as Cisco's SNMP Object Navigator ([http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en))
    proves to be very valuable when you need to find the correct OID of the object
    you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: PySNMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PySNMP is a cross-platform, pure Python SNMP engine implementation developed
    by Ilya Etingof ([https://github.com/etingof](https://github.com/etingof)). It
    abstracts a lot of SNMP details for you, as great libraries do, and supports both
    Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'PySNMP requires the PyASN1 package. The following is taken from to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: <q>"ASN.1 is a standard and notation that describes rules and structures for
    representing, encoding, transmitting, and decoding data in telecommunication and
    computer networking."</q>
  prefs: []
  type: TYPE_NORMAL
- en: 'PyASN1 conveniently provides a Python wrapper around ASN.1\. Let''s install
    the package first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the PySNMP package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are using an older version of PySNMP due to the fact that `pysnmp.entity.rfc3413.oneliner`
    was removed starting with version 5.0.0 ([https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt](https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt)).
    If you use `pip` to install the packages, the examples will likely break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to use PySNMP to query the same Cisco contact information
    we used in the previous example. The steps we will take are slightly modified
    versions from the PySNMP example at [http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html](http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html).
    We will import the necessary module and create a `CommandGenerator` object first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform SNMP using the `getCmd` method. The result is unpacked into
    various variables; of these, we care most about `varBinds`, which contains the
    query result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the response values are PyASN1 objects. The `prettyPrint()` method
    will convert some of these values into a human-readable format, but since the
    result in our case was not converted, we will convert it into a string manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write a script based on the preceding interactive example. We will name
    it `pysnmp_1.py` with error checking. We can also include multiple OIDs in the
    `getCmd()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be unpacked and list out the values of the two OIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we will persist the values we received from the queries
    so that we can perform other functions, such as visualization, with the data.
    For our example, we will use `ifEntry` within the MIB-2 tree for interface-related
    values to be graphed. You can find a number of resources that map out the `ifEntry`
    tree; here is a screenshot of the Cisco SNMP Object Navigator site that we accessed
    previously for `ifEntry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc9b8d4c-afc3-4aa7-8865-02b7faa9572d.png)SNMP ifEntry OID tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick test will illustrate the OID mapping of the interfaces on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the documentation, we can map the values of `ifInOctets(10)`, `ifInUcastPkts(11)`,
    `ifOutOctets(16)`, and `ifOutUcastPkts(17)` into their respective OID values.
    From a quick check on the CLI and MIB documentation, we can see that the value
    of the `GigabitEthernet0/0` packets output maps to OID `1.3.6.1.2.1.2.2.1.17.1`.
    We will follow the rest of the same process to map out the rest of the OIDs for
    the interface statistics. When checking between CLI and SNMP, keep in mind that
    the values should be close but not exactly the same since there might be some
    traffic on the wire between the time of CLI output and the SNMP query time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are in a production environment, we will likely write the results into
    a database. But since this is just an example, we will write the query values
    to a flat file. We will write the `pysnmp_3.py` script for information query and
    write the results to the file. In the script, we have defined various OIDs that
    we need to query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The values were consumed in the `snmp_query()` function, with the `host`, `community`,
    and `oid` as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the values are put in a dictionary with various keys and written to
    a file called `results.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome will be a file with results showing the interface packets represented
    at the time of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this script executable and schedule a `cron` job to be executed
    every five minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, in a production environment, we would put the information
    in a database. For a SQL database, you can use a unique ID as the primary key.
    In a NoSQL database, we might use time as the primary index (or key) because it
    is always unique, followed by various key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: We will wait for the script to be executed a few times for the values to be
    populated. If you are the impatient type, you can shorten the `cron` job interval
    to be one minute. After you see enough values in the `results.txt` file to make
    an interesting graph, we can move on to the next section to see how we can use
    Python to visualize the data.
  prefs: []
  type: TYPE_NORMAL
- en: Python for data visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We gather network data for the purpose of gaining insight into our network.
    One of the best ways to know what the data means is to visualize it with graphs.
    This is true for almost all data, but especially true for time series data in
    the context of network monitoring. How much data was transmitted over the network
    in the last week? What is the percentage of the TCP protocol among all of the
    traffic? These are values we can glean from using data-gathering mechanisms, such
    as SNMP, and we can produce visualization graphs with some of the popular Python
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the data we collected from the last section using
    SNMP and use two popular Python libraries, Matplotlib and Pygal, to graph them.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)) is a Python
    2D plotting library for the Python language and its NumPy mathematical extension.
    It can produce publication-quality figures, such as plots, histograms, and bar
    graphs, with a few lines of code.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is an extension of the Python programming language. It is open source
    and widely used in various data science projects. You can learn more about it
    at [https://en.wikipedia.org/wiki/NumPy](https://en.wikipedia.org/wiki/NumPy).
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation can be done using the Linux package management system, depending
    on your distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Matplotlib – the first example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the following examples, the output figures are displayed as the standard
    output by default. During development, it is often easier to try out the code
    initially and produce the graph on the standard output first before finalizing
    the code with a script. If you have been following along with this book via a
    virtual machine, it is recommended that you use the VM window instead of SSH so
    that you can see the graphs. If you do not have access to the standard output,
    you can save the figure and view it after you download it (as you will see soon).
    Note that you will need to set the `$DISPLAY` variable in some of the graphs that
    we will produce in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the Ubuntu desktop used in this chapter''s
    visualization example. As soon as the `plt.show()` command is issued in the Terminal
    window, `Figure 1` will appear on the screen. When you close the figure, you will
    return to the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e2ca222-f974-43d2-aa0c-5cbbe61e2165.png)Matplotlib visualization
    with the Ubuntu desktop'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the line graph first. A line graph simply gives two lists of
    numbers that correspond to the *x *axis and *y *axis values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The graph will show up as a line graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a829928b-284f-4292-ab0b-62b334bcba6f.png)Matplotlib line graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you do not have access to standard output or have saved the
    figure first, you can use the `savefig()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this basic knowledge of graphing plots, we can now graph the results we
    receive from SNMP queries.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib for SNMP results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our first Matplotlib example, namely `matplotlib_1.py`, we will import the
    *dates* module besides `pyplot`. We will use the `matplotlib.dates` module instead
    of the Python standard library `dates` module. Unlike the Python `dates` module,
    the `mapplotlib.dates` library will convert the date value internally into the
    float type, which is required by Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Matplotlib provides sophisticated date plotting capabilities; you can find more
    information on this at [http://matplotlib.org/api/dates_api.html](http://matplotlib.org/api/dates_api.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, we will create two empty lists, each representing the *x-*axis
    and *y-*axis values. Note that, on line 12, we used the built-in `eval()` Python
    function to read the input as a dictionary instead of a default string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to read the *x-*axis value back in a human-readable date format, we
    will need to use the `plot_date()` function instead of `plot()`. We will also
    tweak the size of the figure a bit as well as rotate the value on the *x-*axis
    so that we can read the value in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result will display the Router1 Gig0/0 and Output Unicast Packet,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ece57d54-836d-4b3e-86ef-ec605416081c.png)Router1 Matplotlib graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you prefer a straight line instead of dots, you can use the third
    optional parameter in the `plot_date()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can repeat the steps for the rest of the values for output octets, input
    unicast packets, and input as individual graphs. However, in our coming example,
    that is, `matplotlib_2.py`, we will show you how to graph multiple values against
    the same time range, as well as additional Matplotlib options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will create additional lists and populate the values accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have identical *x-*axis values, we can just add the different *y-*axis
    values to the same graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add grid and legend to the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result will combine all of the values in a single graph. Note that
    some of the values in the upper-left corner are blocked by the legend. You can
    resize the figure and/or use the pan/zoom option to move around the graph in order
    to see the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5c6c3d57-899b-402b-b554-c85e94fe3b24.png)Router 1 – Matplotlib multiline
    graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more graphing options available in Matplotlib; we are certainly
    not limited to plot graphs. For example, we can use the following mock data to
    graph the percentage of different traffic types that we can see on the wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code leads to this pie chart from `plt.show()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6a9328fe-b860-4287-98e2-a56c469da3aa.png)Matplotlib pie chart'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Matplotlib resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib is one of the best Python plotting libraries that is able to produce publication-quality
    figures. Like Python, its aim is to make complex tasks simple. With over 7,550
    stars (and counting) on GitHub, it is also one of the most popular open source
    projects. Its popularity directly translates into faster bug fixes, a friendly
    user community, and general usability. It takes a bit of time to learn the package,
    but it is well worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we barely scratched the surface of Matplotlib. You'll find
    additional resources at [http://matplotlib.org/2.0.0/index.html](http://matplotlib.org/2.0.0/index.html)
    (the Matplotlib project page) and [https://github.com/matplotlib/matplotlib](https://github.com/matplotlib/matplotlib)
    (the Matplotlib GitHub repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the coming section, we will take a look at another popular Python graph
    library: **Pygal**.'
  prefs: []
  type: TYPE_NORMAL
- en: Pygal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pygal ([http://www.pygal.org/](http://www.pygal.org/)) is a dynamic SVG charting
    library written in Python. The biggest advantage of Pygal, in my opinion, is that
    it produces **Scalable Vector Graphics** (**SVG**) format graphs easily and natively.
    There are many advantages of SVG over other graph formats, but two of the main
    advantages are that it is web browser-friendly and it provides scalability without
    sacrificing image quality. In other words, you can display the resulting image
    in any modern web browser and zoom in and out of the image without losing the
    details of the graph. Did I mention that we can do this in a few lines of Python
    code? How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The installation is done via `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Pygal – the first example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the line chart example demonstrated on Pygal''s documentation,
    available at [http://pygal.org/en/stable/documentation/types/line.html](http://pygal.org/en/stable/documentation/types/line.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a line object with the `x_labels` automatically
    rendered as strings for 11 units. Each of the objects can be added with the label
    and the value in a list format, such as Firefox, Chrome, and IE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the resulting graph, as viewed in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/29abfeb0-b81b-4751-b7d3-ba3dc6bd8cb5.png)Pygal sample graph'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can see the general usage of Pygal, we can use the same method to
    graph the SNMP results we have in hand. We will do this in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Pygal for SNMP results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the Pygal line graph, we can largely follow the same pattern as our Matplotlib
    example, where we create lists of values by reading the file. We no longer need
    to convert the *x-*axis value into an internal float, as we did for Matplotlib;
    however, we do need to convert the numbers in each of the values we would have
    received in the float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the same mechanism that we saw to construct the line graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome is similar to what we have already seen, but the graph is now in
    an SVG format that can be easily displayed on a web page. It can be viewed from
    a modern web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e383a39-e3b8-48c9-a6be-6fc05fcf4cb1.png)Router 1—Pygal multiline
    graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like Matplotlib, Pygal provides many more options for graphs. For example,
    to graph the pie chart we saw previously in Pygal, we can use the `pygal.Pie()`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting SVG file would be similar to the PNG generated by Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd33b69f-99ec-45bb-bc0a-386ee0c65bcf.png)Pygal pie chart'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Pygal resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pygal provides many more customizable features and graphing capabilities for
    the data you collect from basic network monitoring tools such as SNMP. We demonstrated
    a simple line graph and pie graphs in this section. You can find more information
    about the project here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pygal documentation**: [http://www.pygal.org/en/stable/index.html](http://www.pygal.org/en/stable/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pygal GitHub project page**: [https://github.com/Kozea/pygal](https://github.com/Kozea/pygal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming section, we will continue with the SNMP theme of network monitoring
    but with a fully featured network monitoring system called **Cacti**.
  prefs: []
  type: TYPE_NORMAL
- en: Python for Cacti
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my early days working as a junior network engineer at a regional ISP, we
    used the open source cross-platform **Multi Router Traffic Grapher** (**MRTG**),
    ([https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher](https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher))
    tool to check the traffic load on network links. We relied on the tool almost
    exclusively for traffic monitoring. I was really amazed at how good and useful
    an open source project could be. It was one of the first open source high-level
    network monitoring systems that abstracted the details of SNMP, the database,
    and HTML for network engineers. Then came the **Round-Robin Database Tool** (**RRDtool**),
    ([https://en.wikipedia.org/wiki/RRDtool](https://en.wikipedia.org/wiki/RRDtool)).
    In its first release in 1999, it was referred to as "MRTG Done Right". It had
    greatly improved the database and poller performance in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Released in 2001, Cacti ([https://en.wikipedia.org/wiki/Cacti_(software)](https://en.wikipedia.org/wiki/Cacti_(software)))
    is an open source web-based network monitoring and graphing tool designed as an
    improved frontend for RRDtool. Because of the heritage of MRTG and RRDtool, you
    will notice a familiar graph layout, templates, and SNMP poller. As a packaged
    tool, the installation and usage will need to stay within the boundary of the
    tool itself. However, Cacti offers the custom data query feature that we can use
    Python for. In this section, we will see how we can use Python as an input method
    for Cacti.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installation on Ubuntu is straightforward when using APT on the Ubuntu management
    VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It will trigger a series of installation and setup steps, including the MySQL
    database, web server (Apache or lighttpd), and various configuration tasks. Once
    installed, navigate to `http://<ip>/cacti` to get started. The last step is to
    log in with the default username and password (`admin`/`admin`); you will be prompted
    to change the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are logged in, you can follow the documentation to add a device and
    associate it with a template. There is a Cisco router premade template that you
    can go with. Cacti has good documentation on [http://docs.cacti.net/](http://docs.cacti.net/)
    for adding a device and creating your first graph, so we will quickly look at
    some screenshots that you can expect to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30d73b73-895c-472d-8723-22a9be73d6f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A sign indicating the SNMP communication is working is when you can see the
    device uptime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fdf75bec-2cb7-4e51-a6c8-87e9cf54ca4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can add graphs to the device for interface traffic and other statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d02f3ac0-6883-4358-a3ae-deeebff30af9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After some time, you will start seeing traffic, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4e894e42-b8ca-4140-bf0c-e19f83ebef34.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to look at how to use Python scripts to extend Cacti's data
    gathering functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Python script as an input source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two documents that we should read before we try to use our Python
    script as an input source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data input methods: [http://www.cacti.net/downloads/docs/html/data_input_methods.html](http://www.cacti.net/downloads/docs/html/data_input_methods.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Making your scripts work with Cacti: [http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html](http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One might wonder what the use cases for using Python script are as an extension
    for data inputs. One of the use cases would be to provide monitoring to resources
    that do not have a corresponding OID, for example, if we would like to know how
    to graph how many times the access list `permit_snmp` has allowed the host `172.16.1.173`
    for conducting an SNMP query. We know we can see the number of matches via the
    CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, chances are that there are no OIDs associated with this value (or we
    can just pretend that there are none). This is where we can use an external script
    to produce an output that can be consumed by the Cacti host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the Pexpect script we discussed in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions,* `chapter1_1.py`. We will rename it to
    `cacti_1.py`. Everything should be familiar to the original script, except that
    we will execute the CLI command and save the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in its raw form will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `split()` function for the string to only leave the number
    of matches and print them out on standard output in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, we can see the number of increments by executing the script a
    number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make the script executable and put it into the default Cacti script
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The Cacti documentation, available at [http://www.cacti.net/downloads/docs/html/how_to.html](http://www.cacti.net/downloads/docs/html/how_to.html),
    provides detailed steps on how to add the script result to the output graph. These steps
    include adding the script as a data input method, adding the input method to a
    data source, and then creating a graph to be viewed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76e0529b-8252-41c3-b8c3-ab9f9cd550f3.png)'
  prefs: []
  type: TYPE_IMG
- en: SNMP is a common way to provide network monitoring services to the devices.
    RRDtool with Cacti as the frontend provides a good platform to be used for all
    the network devices via SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored ways to perform network monitoring via SNMP. We
    configured SNMP-related commands on network devices and used our network management
    VM with SNMP poller to query the devices. We used the PySNMP module to simplify
    and automate our SNMP queries. We also learned how to save the query results in
    a flat file or database to be used for future examples.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we used two different Python visualization packages,
    namely Matplotlib and Pygal, to graph SNMP results. Each package has its distinct
    advantages. Matplotlib is a mature, feature-rich library that is widely used in
    data science projects. Pygal can natively generate SVG format graphs that are
    flexible and web-friendly. We saw how we can generate line and pie graphs that
    are relevant for network monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of this chapter, we looked at an all-inclusive network monitoring
    tool named Cacti. It uses primarily SNMP for network monitoring, but we saw how
    we can use Python scripts as an input source to extend the platform's monitoring
    capabilities when SNMP OID is not available on the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml), *Network Monitoring
    with Python – Part 2*, we will continue to discuss the tools we can use to monitor
    our networks and gain insight into whether the network is behaving as expected.
    We will look at flow-based monitoring using NetFlow, sFlow, and IPFIX. We will
    also use tools such as Graphviz to visualize our network topology and detect any
    topological changes. Finally, we will use Elasticsearch, Logstash, and Kibana,
    commonly referred to as the ELK stack, to monitor network log data as well as
    other network-related input.
  prefs: []
  type: TYPE_NORMAL
