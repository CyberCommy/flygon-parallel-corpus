- en: Appendix A. C++11 Language Features Emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will review some concepts from C++ programming that will
    be conceptually important in understanding several topics covered in this book.
    Many of these concepts have been introduced relatively recently as part of C++11\.
    We will look at: RAII, copy- and move-semantics, `auto`, range-based for-loops,
    and C++11 exception handling enhancements. We will look at how these features
    can be emulated under a pre-C++11 compiler using parts of the Boost libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: RAII
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ programs frequently deal with system resources like memory, file and socket
    handles, shared memory segments, mutexes, and so on. There are well-defined primitives,
    some from the C Standard Library and many more from the native systems programming
    interfaces, which are used to request and relinquish these resources. Failing
    to guarantee the release of acquired resources can cause grave problems to an
    application's performance and correctness.
  prefs: []
  type: TYPE_NORMAL
- en: The destructor of a C++ object *on the stack* is automatically invoked during
    stack unwinding. The unwinding happens when a scope is exited due to control reaching
    the end of the scope, or by executing `return`, `goto`, `break`, or `continue`.
    A scope is also exited as a result of an exception being thrown. In either case,
    the destructor is guaranteed to be called. This guarantee is limited to C++ objects
    on the stack. It does not apply to C++ objects on the heap because they are not
    associated with a lexical scope. Furthermore, it does not apply to the aforementioned
    resources like memory and file descriptors, which are objects of Plain Old Data
    types (POD-types) and therefore do not have a destructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C++ code using the `new[]` and `delete[]` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The programmer was careful to release the buffer allocated. However, if another
    programmer came and flippantly wrote code to exit the scope somewhere between
    the calls to `new` and `delete`, then `buffer` would never be released and you
    would leak memory. Exceptions could arise in the intervening code too with the
    same result. This is true not just of memory but of any resource which requires
    a manual step to release, like `delete[]` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: This is where we can utilize the guaranteed invocation of a destructor when
    exiting a scope to guarantee the clean-up of resources. We can create a wrapper
    class whose constructor acquires ownership of the resource and whose destructor
    releases the resource. A few lines of code can explain this technique that usually
    goes by the name **Resource Acquisition is Initialization** or **RAII**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.1: RAII in action**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `String` class encapsulates a C-style string. We pass it a C-style string
    during construction, and it creates a copy of the passed string on the free store
    if it is not null. The helper function `dupstr` allocates memory for the `String`
    object on the free store using the the `new[]` operator (line 24). If allocation
    fails, `operator new[]` throws `std::bad_alloc`, and the `String` object never
    comes into being. In other words, resource acquisition must succeed for initialization
    to succeed. This is the other key aspect of RAII.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `String` class in code as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of `String` called `favBand`, which internally allocates
    a character buffer dynamically. When `favBand` goes out of scope normally or due
    to an exception, its destructor is called and it releases this buffer. You can
    apply this technique to all forms of resources that require manual release, and
    it will never let a resource leak creep in. The `String` class is said to own
    the buffer resource, that is, it has *unique ownership semantics*.
  prefs: []
  type: TYPE_NORMAL
- en: Copy semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object keeps state information in its data members, which can themselves
    be of POD-types or class types. If you do not define a copy constructor for your
    class, then the compiler implicitly defines one for you. This implicitly-defined
    copy constructor copies each member in turn, invoking the copy constructor of
    members of class type and performing a bitwise copy of POD-type members. The same
    is true of the assignment operator. The compiler generates one if you do not define
    your own, and it performs member-wise assignment, invoking the assignment operators
    of member objects of class-type, and performing bitwise copies of POD-type members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.2: Implicit destructor, copy constructor, and assignment operator**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Class `Bar` contains an instance of class `Foo` as a member (line 25). Class
    `Foo` defines a destructor (line 11), a copy constructor (line 7), and an assignment
    operator, (line 15) each of which prints some message. Class `Bar` does not define
    any of these special functions. We create an instance of `Bar` called `b1` (line
    30) and a copy of `b1` called `b2` (line 33). We then assign `b1` to `b2` (line
    36). Here is the output when the program is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Through the messages printed, we can trace the calls made to `Foo`'s special
    functions from `Bar`'s implicitly generated special functions.
  prefs: []
  type: TYPE_NORMAL
- en: This works adequately for all cases except when you encapsulate a pointer or
    non-class type handle to some resource in your class. The implicitly-defined copy
    constructor or assignment operator will copy the pointer or handle but not the
    underlying resources, generating an object which is a **shallow copy** of another.
    This is rarely what is needed and this is where a user-defined copy constructor
    and assignment operator are needed to define the correct copy semantics. If such
    copy semantics do not make sense for the class, the copy constructor and assignment
    operator ought to be disabled. In addition, you would also need to manage resource
    lifetimes using RAII, and therefore define a destructor rather than relying on
    the compiler-generated one.
  prefs: []
  type: TYPE_NORMAL
- en: There is a well-known rule called the **Rule of Three** that regularizes this
    common idiom. It says that if you need to define your own destructor for a class,
    you should also define your own copy constructor and assignment operator or disable
    them. The `String` class we defined in listing A.1 is such a candidate and we
    will add the remaining two of the three canonical methods shortly. As we noted,
    not all classes need to define these functions, only those that encapsulate resources.
    In fact, it is recommended that a class using these resources should be different
    from the class managing the lifetime of these resources. Thus, we should create
    a wrapper around each resource for managing that resource using specialized types
    like smart pointers ([Chapter 3](ch03.html "Chapter 3. Memory Management and Exception
    Safety"), *Memory Management and Exception Safety*), `boost::ptr_container` ([Chapter
    5](ch05.html "Chapter 5. Effective Data Structures beyond STL"), *Effective Data
    Structures beyond STL*), `std::vector`, and so on. The class using the resources
    should have the wrappers rather than the raw resources as members. This way, the
    class using the resource does not have to also bother about managing the resource
    life cycles, and the implicitly-defined destructor, copy constructor, and assignment
    operator would be adequate for its purposes. This has come to be called the **Rule
    of Zero**.
  prefs: []
  type: TYPE_NORMAL
- en: The nothrow swap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to Rule of Zero, you should rarely need to bother about the Rule of
    Three. But when you do have to use the Rule of Three, there are a few nitty-gritties
    to take care of. Let us first understand how you would define a copy operation
    for the `String` class in listing A.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.1a: Copy constructor**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of copy constructor is no different than that of the constructor
    in listing A.1\. The assignment operator requires more care. Consider how `String`
    objects are assigned to in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On line 3, we assign `band2` to `band1`. As part of this, `band1`''s old state
    should be deallocated and then overwritten with a copy of `band2`''s internal
    state. The problem is that copying `band2`''s internal state might fail, and so
    `band1`''s old state should not be destroyed until `band2`''s state has been copied
    successfully. Here is a succinct way to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.1b: Assignment operator**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We create `tmp` as a copy of `rhs` (line 3) and if this copying fails, it should
    throw an exception and the assignment operation would fail. The internal state
    of the assignee, `this`, should not change. The call to `swap` (line 4) executes
    only if the copying succeeded (line 3). The call to `swap` exchanges the internal
    states of `this` and the `tmp` object. As a result, `this` now contains the copy
    of `rhs` and `tmp` contains the older state of `this`. At the end of this function,
    `tmp` goes out of scope and releases the old state of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to optimize this implementation further by considering special
    cases. If the assignee (left-hand side) already has storage that is at least as
    large as needed to contain the contents of `rhs`, then we can simply copy the
    contents of `rhs` into the assignee, without the need for extra allocation and
    deallocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `swap` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.1c: nothrow swap**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exchanging variables of primitive types (integers, pointers, and so on) should
    not cause any exceptions to be thrown, a fact we advertise using the C++11 keyword
    `noexcept`. We could have written `throw()` instead of `noexcept`, but exception
    specifications are deprecated in C++11 and `noexcept` is more efficient than a
    `throw()` clause. This swap function, written entirely in terms of exchanging
    primitive data types, is guaranteed to succeed and would never leave the assignee
    in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Move semantics and rvalue references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Copy semantics are for creating clones of objects. It is useful sometimes,
    but not always needed or even meaningful. Consider the following class that encapsulates
    a TCP client socket. A TCP socket is an integer that represents one endpoint of
    a TCP connection and through which data can be sent or received to the other endpoint.
    The TCP socket class can have the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor opens a connection to a host on a specified port and initializes
    the `socket_fd_` member variable. The destructor closes the connection. TCP does
    not define a way to make clones of open sockets (unlike file descriptors with
    `dup`/`dup2`) and therefore cloning `TCPSocket` would not be meaningful either.
    Therefore, we disable copy semantics by declaring the copy constructor and copy
    assignment operators private. In C++11, the preferred way to do this is to declare
    these members as deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although not copyable, it would make perfect sense to create a `TCPSocket`
    object in one function and then return it to a calling function. Consider a factory
    function that creates connections to some remote TCP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a function would encapsulate the details about which host and port to
    connect to, and would create an object of `TCPSocket` to be returned to the caller.
    This would not really call for copy semantics at all, but move semantics, in which
    the contents of the `TCPSocket` object created in the `connectToService` function
    would be transferred to another `TCPSocket` object at the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++03, this would not be possible to write without enabling the copy constructor.
    We could subvert the copy constructor to provide move semantics, but there are
    many problems with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this version of the "copy" constructor actually moves the contents
    out of its argument, which is why the argument is non-const. With this definition,
    we can actually implement the `connectToService` function, and use it as shown
    earlier. But nothing would prevent situations like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We obtain an instance of `TCPSocket` called `socket` by calling `connectToService`
    (line 8) and pass this instance to `performIO` (line 9). But the copy constructor
    used to pass `socket` by value to `performIO` moves its contents out, and when
    `performIO` returns, `socket` no longer encapsulates a valid TCP socket. By disguising
    a move as a copy, we have created an unintuitive and error-prone interface; if
    you are familiar with `std::auto_ptr`, you would have seen this before.
  prefs: []
  type: TYPE_NORMAL
- en: rvalue references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to support move semantics better, we must first answer the question:
    which objects can be moved from? Consider the `TCPSocket` example again. In the
    function `connectToService`, the expression `TCPSocket(get_service_host(), get_service_port())`
    is an *unnamed temporary* object of `TCPSocket` whose sole purpose is to be transferred
    to the caller''s context. There is no way for anyone to refer to this object beyond
    the statement where it gets created. It makes perfect sense to move the contents
    out of such an object. But in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It would be dangerous to move out the contents of `socket` object because in
    the calling context, the object is still bound to the name `socket` and can be
    used in further operations. The expression `socket` is called an **lvalue expression**—one
    that has an identity and whose address can be taken by prefixing the &-operator
    to the expression. Non-lvalue expressions are referred to as **rvalue expressions**.
    These are unnamed expressions whose address cannot be computed using the &-operator
    on the expression. An expression, such as `TCPSocket(get_service_host(), get_service_port())`
    is an rvalue expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can say that, in general, it is dangerous to move contents from an lvalue
    expression but safe to move contents from rvalue expressions. Thus, the following
    is dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But the following is alright:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note here that the expression `connectToService()` is not an lvalue expression
    and therefore qualifies as an rvalue expression. In order to distinguish between
    lvalue and rvalue expressions, C++11 introduced a new class of references called
    **rvalue references** that can refer to rvalue-expressions but not lvalue-expressions.
    Such references are declared using a new syntax involving double ampersands as
    shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The other class of references that were earlier simply called *references*
    are now called **lvalue references**. A non-const lvalue reference can only refer
    to an lvalue expression, while a const lvalue reference can also refer to an rvalue
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'An rvalue reference can be, and usually is, non-const:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the expression `socketref` itself is an lvalue-expression
    because you can compute its address using &-operator. But it is bound to an rvalue-expression,
    and object referred to by the non-const rvalue reference can be modified through
    it.
  prefs: []
  type: TYPE_NORMAL
- en: rvalue-reference overloads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create overloads of a function based on whether they take lvalue expressions
    or rvalue expressions. In particular, we can overload the copy constructor to
    take rvalue expressions. For the `TCPSocket` class, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While the lvalue overload is the deleted copy constructor, rvalue overload is
    called the move constructor because this is implemented to usurp or "steal" the
    contents of the rvalue expression passed to it. It moves the contents of the source
    to the target, leaving the source (`rvref`) in some unspecified state that is
    safe to destruct. In this case, this amounts to setting the `socket_fd_` member
    of the `rvref` to -1.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition of the move constructor, `TCPSocket` becomes movable but
    not copyable. The `connectToService` implementation would work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This would move the temporary object back to the caller. But the following
    call to `performIO` would be ill-formed because `socket` is an lvalue expression
    and `TCPSocket` only defines move semantics for which an rvalue expression was
    necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good thing because you cannot move contents out of an object like
    `socket` that you could potentially use later. An rvalue-expression of a movable
    type can be passed by value and thus the following will be well-formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the expression `connectToService()`is an rvalue expression because
    it is not bound to a name and its address cannot be taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type can be both copyable and movable. For example, we could implement a
    move constructor for the `String` class in addition to its copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The nothrow `swap` plays a central role in the implementation of move semantics.
    The contents of the source and target objects are exchanged. So when the source
    object goes out of scope in the calling scope, it releases its new contents (the
    target object's old state). The target object lives on with its new state (the
    source object's original state). The move is implemented in terms of the nothrow
    `swap,` which just swaps pointers and values of primitive types, and it is guaranteed
    to succeed; hence, the `noexcept` specification. In fact, moving objects usually
    requires less work involving swapping pointers and other data bits, while copying
    often requires new allocations that could potentially fail.
  prefs: []
  type: TYPE_NORMAL
- en: Move assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as we can construct an object by stealing the contents of another object,
    we can also move the contents of one object to another after both have been constructed.
    To do this, we can define a **move assignment operator**, an rvalue-overload of
    the copy assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can define a **universal assignment operator** that works
    for both lvalue and rvalue expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the universal assignment operator cannot coexist with either the lvalue
    or the rvalue overload, else there would be ambiguity in overload resolution.
  prefs: []
  type: TYPE_NORMAL
- en: xvalues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you call a function with an rvalue expression, the compiler resolves function
    calls to an rvalue-overload of the function if one is available. But if you call
    the function with a named variable, it gets resolved to an lvalue overload if
    one is available or the program is ill-formed. Now you might have a named variable
    that you can move from because you have no use for it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will fail to compile because `performIO` takes its sole
    parameter by value and `socket` is of a move-only type but it is not an rvalue
    expression. By using `std::move`, you can cast an lvalue expression to an rvalue
    expression, and pass it to a function that expects an rvalue expression. The `std::move`
    function template is defined in the standard header `utility`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The call to `std::move(socket)` gives us an rvalue reference to `socket`; it
    does not cause any data to be moved out of `socket`. When we pass this expression
    of rvalue-reference type to the function `performIO`, which takes its parameter
    by value, a new `TCPSocket` object is created in the `performIO` function, corresponding
    to its by-value parameter. It is **move initialized** from `socket`, that is,
    its move constructor steals the contents of `socket`. Following the call to `performIO`,
    the variable `socket` loses its contents and therefore should not be used in further
    operations. If the move constructor of `TCPSocket` is correctly implemented, then
    `socket` should still be safe to destruct.
  prefs: []
  type: TYPE_NORMAL
- en: The expression `std::move(socket)` shares the identity of `socket`, but it would
    *potentially* be moved from within the function it is passed to. Such expressions
    are called **xvalues**, the *x* standing for *expired*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**xvalues** have a well-defined identity like lvalues, but can be moved from
    like rvalues. **xvalues** bind to rvalue reference parameters of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `performIO` did not take its parameter by value but as an rvalue-reference
    then one thing would change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The call to `performIO(std::move(socket))` would still be well-formed, but would
    not automatically move out the contents of `socket`. This is because we pass a
    reference to an existing object here, whereas we create a new object that is move
    initialized from `socket` when we pass by value. In this case, unless the `performIO`
    function implementation explicitly moves out the contents of `socket`, it would
    still remain valid in the calling context after the call to `performIO`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, if you have cast your object to an rvalue-expression and passed
    it to a function that expects an rvalue-reference, you should just assume that
    it has been moved from and not use it beyond the call.
  prefs: []
  type: TYPE_NORMAL
- en: An object of type T that is *local to a function* can be returned by value from
    that function if T has an accessible move or copy constructor. If a move constructor
    is available, the returned value will be move-initialized, else it would be copy-initialized.
    If however, the object is not local to the function, then it must have an accessible
    copy constructor to be returned by value. Additionally, compilers, whenever they
    can, optimize away copies and moves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the implementation of `connectToService` and how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the compiler will actually construct the temporary (line 3) directly
    in the storage for the `socket` object (line 6) where the return value of `connectToService`
    was meant to be moved to. This way, it would simply optimize away the move initialization
    of `socket` (line 6). This optimization is effected even if the move constructor
    has side effects, which means that those side effects may not take effect as a
    result of this optimization. In the same way, the compiler can optimize away copy
    initialization and directly construct the returned object at the target site.
    This is referred to as **Return Value Optimization** (**RVO**) and has been the
    norm for all major compilers since C++03, when it optimized away only copies.
    Although the copy or move constructors are not invoked when RVO takes effect,
    they must nevertheless be defined and accessible for RVO to work.
  prefs: []
  type: TYPE_NORMAL
- en: While RVO applies when rvalue expressions are returned, the compiler can sometimes
    optimize away a copy or move, even when a named *local* object on the stack is
    returned from a function. This is known as **Named Return Value Optimization**
    (**NRVO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Return Value Optimization is a specific case of **Copy Elision**, in which
    the compiler optimizes away a move or copy of an rvalue expression to construct
    it directly in the target storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the expression `a + b` is an rvalue expression that
    generates a temporary object of type `std::string`. This object will not be copied
    into the function `reverse` instead the copy would be *elided*, and the object
    resulting from the expression `a + b` would be constructed directly in the storage
    for `reverse`'s parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passing and returning an object of type T by value requires either move or copy
    semantics to be defined for T. If a move constructor is available, it is used,
    otherwise the copy constructor is used. Whenever possible, the compiler optimizes
    away copy or move operations and constructs the object directly at the target
    site in the calling or called function.
  prefs: []
  type: TYPE_NORMAL
- en: Move emulation using Boost.Move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we look at how, with relative ease, you can actually retrofit
    much of the move semantics for your own legacy classes using the Boost.Move library.
    First, consider the interface of the `String` class in C++ 11 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now see how you would define an equivalent interface using Boost''s
    facilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.2a: Move emulation with Boost.Move**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The key changes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 6: The macro `BOOST_COPYABLE_AND_MOVABLE(String)` defines some internal
    infrastructure to support copy and move semantics, and distinguish between lvalues
    and rvalues of type `String`. This is declared as private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 19: A copy assignment operator that takes the type `BOOST_COPY_ASSIGN_REF(String)`.
    This is a wrapper type for `String` to which `String` lvalues can be implicitly
    converted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 22 and 25: A move constructor and a move-assignment operator that take
    the wrapper type `BOOST_RV_REF(String)`. String rvalues implicitly convert to
    this type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that on line 16, the copy constructor does not change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under a C++ 03 compiler, the emulation of move-semantics is provided without
    any special support from the language or the compiler. With a C++ 11 compiler,
    the macros automatically use C++ 11 native constructs for supporting move-semantics.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is pretty much the same as the C++ 11 version except for
    the parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.2b: Move emulation with Boost Move**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to make our class only support move semantics but not copy semantics,
    then we should have used the macro `BOOST_MOVABLE_NOT_COPYABLE` in place of `BOOST_COPYABLE_AND_MOVABLE`
    and should not have defined the copy constructor and copy assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the copy/move assignment operators, we could check for self-assignment if
    we wanted by putting the code that does the swapping/copying inside an if-block
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will not change the correctness of the code as long the implementation
    of copy/move is exception-safe. But it would help to improve the performance by
    avoiding further operations in case of assignment to the self.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in summary, the following macros help us emulate move-semantics in C++ 03:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `BOOST_RV_REF(…)` encapsulated types for parameters of other
    member methods, besides the move constructors and assignment operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to move from an lvalue, you would naturally have to cast it to
    an "rvalue-emulating" expression. You do this using `boost::move`, which corresponds
    to `std::move` in C++ 11\. Here are some examples of invoking different copy and
    move operations on `String` objects using the Boost move emulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: C++11 auto and Boost.Auto
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider how you declare an iterator to a vector of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The declared type of `iter` is big and unwieldy and it is a pain to write it
    explicitly every time. Given that the compiler knows the type of the initializing
    expression on the right-hand side, that is, `vec.begin()`, this is also superfluous.
    Starting with C++11, you can use the `auto` keyword to ask the compiler to deduce
    the type of a declared variable using the type of the expression it is initialized
    with. Thus, the preceding tedium is replaced by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The deduced type of `var` is the same as the deduced type `T`, when the following
    function template is called with the argument `expr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Type deduction rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few rules to keep in mind. First, if the initializing expression
    is a reference, the reference is stripped in the deduced type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to declare an lvalue-reference, you must explicitly adorn the `auto`
    keyword with an ampersand (&), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If the initializing expression is not copyable, you must make the assignee a
    reference in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule is that `const` and `volatile` qualifiers of the initializing
    expression are stripped in the deduced type, unless the variable declared with
    `auto` is explicitly declared as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if you want to add a `const` or `volatile` qualifier, you must do so
    explicitly, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Common uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `auto` keyword is very convenient to use in a lot of situations. It lets
    you get away from having to type long template IDs, in particular when the initializing
    expression is a function call. Here are a couple of examples to illustrate the
    advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note the savings in the type names achieved through the use of `auto`. Also,
    note that while creating the `tuple` called `coords` using `boost::make_tuple`,
    we do not use the assignment syntax for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Auto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are on a pre-C++11 compiler, you can emulate this effect using the `BOOST_AUTO`
    and `BOOST_AUTO_TPL` macros. Thus, you can write the last snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note the header file `boost/typeof/typeof.hpp` that needs to be included to
    use the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to declare a reference type, you can adorn the variable with a
    leading ampersand (&). Likewise, to qualify your variable with `const` or `volatile`,
    you should add the `const` or `volatile` qualifier before the variable name. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Range-based for-loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Range-based for-loops are another syntactic convenience introduced in C++11\.
    Range-based for-loops allow you to iterate through a sequence of values like arrays,
    containers, iterator ranges, and so on, without having to explicitly specify boundary
    conditions. It makes iterating less error-prone by obviating the need to specify
    boundary conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for range-based for-loop is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The **sequence expression** identifies a sequence of values like an array or
    a container, that is to be iterated through. The **range declaration** identifies
    a variable that would represent each element from the sequence in successive iterations
    of the loop. Range-based for-loops automatically recognize arrays, brace-enclosed
    sequences of expressions, and containers with `begin` and `end` member functions
    that return forward iterators. To iterate through all elements in an array, you
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also iterate through a sequence of expressions enclosed in braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating through elements in a container that exposes forward iterators through
    `begin` and `end` member functions is not all that different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The range expression declares a loop variable called `elem` using `auto` to
    deduce its type. This use of `auto` in range-based for-loops is idiomatic and
    common. To traverse sequences encapsulated within other kinds of objects, range-based
    for-loops require that two namespace-level methods, `begin` and `end`, be available
    and be resolved via *Argument Dependent Lookup* (see [Chapter 2](ch02.html "Chapter 2. The
    First Brush with Boost's Utilities"), *The First Brush with Boost's Utilities*).
    Range-based for-loops are great for traversing sequences whose lengths remain
    fixed during traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Boost.Foreach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `BOOST_FOREACH` macro to emulate the basic uses of C++11''s
    range-based for-loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `BOOST_FOREACH` macro to iterate through
    the elements of a vector of strings called `names`, using a loop variable called
    `name` of type `string`. Using `BOOST_FOREACH`, you can iterate over arrays, containers
    with member functions `begin` and `end` that return forward iterators, iterator
    pairs, and null-terminated character arrays. Note that C++11 range-based for-loops
    do not readily support the last two types of sequences. On the other hand, with
    `BOOST_FOREACH`, you cannot deduce the type of the loop variable using the `auto`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 exception-handling improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++11 introduced the ability to capture and store an exception that can be passed
    around and rethrown later. This is particularly useful for propagating exceptions
    across threads.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and rethrowing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To store an exception, the type `std::exception_ptr` is used. `std::exception_ptr`
    is a smart pointer type with shared ownership semantics, not unlike `std::shared_ptr`
    (see [Chapter 3](ch03.html "Chapter 3. Memory Management and Exception Safety"),
    *Memory Management and Exception Safety*). An instance of `std::exception_ptr`
    is copyable and movable and can be passed to other functions potentially across
    threads. A default-constructed `std::exception_ptr` is a null object that does
    not point to any exception. Copying a `std::exception_ptr` object creates two
    instances that manage the same underlying exception object. The underlying exception
    object continues to exist as long as the last `exception_ptr` instance containing
    it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The function `std::current_exception`, when called inside a catch-block, returns
    the active exception for which the catch-block was executed, wrapped in an instance
    of `std::exception_ptr`. When called outside a catch-block, it returns a null
    `std::exception_ptr` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The function `std::rethrow_exception` is passed an instance of `std::exception_ptr`
    (which must not be null) and throws the exception contained in the `std::exception_ptr`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.3: Using std::exception_ptr**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding example prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function calls `do_more_work` (line 30), which in turn calls `do_work`
    (line 18), which simply throws a `runtime_error` exception (line 8) that finds
    its way down to a catch-block in `do_more_work` (line 19). We declare an object
    `eptr` of type `std::exception_ptr` in `do_more_work` (line 15) and inside the
    catch-block, we call `std::current_exception` and assign the result to `eptr`.
    Later, we create a copy of `eptr` (line 23), and push both instances into a global
    vector of `exception_ptr`s (lines 24-25).
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we run through the `exception_ptr` instances in the
    global vector, throw each using `std::rethrow_exception` (line 33), catch it and
    print its message. Note that in the process, we print the message from the same
    exception twice because we have two instances of `exception_ptr` containing the
    same exception.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and rethrowing exception using Boost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In pre-C++11 environments, you can use the `boost::exception_ptr` type to store
    exceptions and `boost::rethrow_exception` to throw the exception stored in `boost::exception_ptr`.
    There is also the `boost::current_exception` function which works akin to `std::current_exception`.
    But without underlying language support, it requires help from the programmer
    to function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for `boost::current_exception` to return the currently active exception
    wrapped in `boost::exception_ptr`, we must modify the exception before throwing
    it to make it amenable to be handled using this mechanism. To do this, we call
    `boost::enable_current_exception` on the exception to be thrown. The following
    snippet illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing A.4: Using boost::exception_ptr**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Self-test questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rule of Three states that if you define your own destructor for a class,
    you should also define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Your own copy constructor
  prefs: []
  type: TYPE_NORMAL
- en: b. Your own assignment operator
  prefs: []
  type: TYPE_NORMAL
- en: c. Both a and b
  prefs: []
  type: TYPE_NORMAL
- en: d. Either a or b
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the class `String` has both copy and move constructors, which of the
    following does not invoke a move constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `String s1(getName());`
  prefs: []
  type: TYPE_NORMAL
- en: b. `String s2(s1);`
  prefs: []
  type: TYPE_NORMAL
- en: c. `String s2(std::move(s1));`
  prefs: []
  type: TYPE_NORMAL
- en: d. `String s3("Hello");`
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of `std::move` function is to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Move contents of its argument out
  prefs: []
  type: TYPE_NORMAL
- en: b. Create an lvalue reference from an rvalue reference
  prefs: []
  type: TYPE_NORMAL
- en: c. Create an xvalue from an lvalue expression
  prefs: []
  type: TYPE_NORMAL
- en: d. Swap contents of its argument with another object
  prefs: []
  type: TYPE_NORMAL
- en: 'In which of the following cases does Return Value Optimization apply?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `return std::string("Hello");`
  prefs: []
  type: TYPE_NORMAL
- en: b. `string reverse(string);string a, b;reverse(a + b);`
  prefs: []
  type: TYPE_NORMAL
- en: c. `std::string s("Hello");return s;`
  prefs: []
  type: TYPE_NORMAL
- en: d. `std::string a, b;return a + b.`
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14*,
    *Scott Meyers*, *O''Reilly Media*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Tour of C++*, *Bjarne Stroustrup*, *Addison Wesley Professional*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The C++ Programming Language (4/e)*, *Bjarne Stroustrup*, *Addison Wesley
    Professional*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
