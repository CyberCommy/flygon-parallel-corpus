- en: Handling Navigation with Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every web application requires **routing**: the process of responding
    to a URL, based on a set of route handler declarations. In other words, a mapping
    from the URL to rendered content. However, this task is more involved than it
    seems at first. This is why you're going to leverage the `react-router` package
    in this chapter, the *de facto* routing tool for React.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll learn the basics of declaring routes using JSX syntax. Then, you'll
    learn about the dynamic aspects of routing, such as dynamic path segments and
    query parameters. Next, you'll implement links using components from `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `react-router`, you can collocate routes with the content that they render.
    In this section, you'll see that this is done using JSX syntax to define routes.
  prefs: []
  type: TYPE_NORMAL
- en: You'll create a basic **hello world** example route so that you can see what
    routes look like in React applications. Then, you'll learn how you can organize
    your route declarations by feature instead of in a monolithic module. Finally,
    you'll implement a common parent-child routing pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Hello route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple route that renders a simple component. First, you have
    a small React component that you want to render when the route is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s look at the route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Router` component is the top-level component of the application. Let's
    break it down to know what's happening within the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have the actual routes declared as `<Route>` elements. There are two key
    properties of any route: `path` and `component`. When the `path` is matched against
    the active URL, the `component` is rendered. But where is it rendered, exactly?
    The `Router` component doesn''t actually render anything itself; it''s responsible
    for managing how other components are rendered based on the current URL. Sure
    enough, when you look at this example in a browser, `<MyComponent>` is rendered
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/706173fb-153d-40f6-8b14-cfbf733b4ede.png)'
  prefs: []
  type: TYPE_IMG
- en: When the `path` property matches the current URL, the `<Route>` is replaced
    by the `component` property value. In this example, the route is replaced with
    `<MyComponent>`. If a given route doesn't match, nothing is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling route declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difficulty with routing happens when your application has dozens of routes
    declared within a single module, because it's more difficult to mentally map routes
    to features.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, each top-level feature of the application can define its
    own routes. This way, it''s clear which routes belong to which feature. So, let''s
    start with the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the application has two features: `one` and `two`. These are
    imported as components and rendered inside `<Router>`. You have to include the
    `<Fragment>` element because `<Router>` doesn''t like having multiple children.
    By using a fragment, you''re passing one child without having to use an unnecessary
    DOM element. The first child in this router is actually a redirect. This means
    that when the app first loads the URL `/`, the `<Redirect>` component will send
    the user to `/one`. The `render` property is an alternative to the `component`
    property when you need to call a function to render content. You''re using it
    here because you need to pass the property to `<Redirect>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This module will only get as big as the number of application features, instead
    of the number of routes, which could be substantially larger. Let''s take a look
    at one of the feature routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This module, `one/index.js`, exports a component that renders a fragment with
    three routes:'
  prefs: []
  type: TYPE_NORMAL
- en: When the path `/one` is matched, redirect to `/one/1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the path `/one/1` is matched, render the `First` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the path `/one/2` is matched, render the `Second` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This follows the same pattern as the `App` component for the path `/`. Often,
    your application doesn''t actually have content to render at the root of a feature
    or at the root of the application itself. This pattern allows you to send the
    user to the appropriate route and the appropriate content. Here''s what you''ll
    see when you first load the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bfcc12ba-2e40-47f0-a7c0-a83b8b16b798.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second feature follows the exact same pattern as the first. Here''s what
    the component first looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each feature in this example uses the same minimal rendered content. These components
    are ultimately what the user needs to see when they navigate to a given route.
    By organizing routes this way, you've made your features self-contained with regard
    to routing.
  prefs: []
  type: TYPE_NORMAL
- en: Parent and child routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `App` component in the preceding example was the main component of the
    application. This is because it defined the root URL: `/`. However, once the user
    navigated to a specific feature URL, the `App` component was no longer relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: In versions of `react-router` prior to version 4, you could nest your `<Route>`
    elements so that as the path continues to match the current URL, the relevant
    component is rendered. For example, the path `/users/8462` would have nested `<Route>`
    elements. In version 4 and above, `react-router` no longer uses nested routes
    for handling child content. Instead, you have your `App` component as you normally
    would. Then, `<Route>` elements are used to then match paths against the current
    URL in order to render specific content in `App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a parent `App` component that uses `<Route>` elements
    to render child components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, the `App` component renders some navigation links. These will always
    be visible. Since these links point to pages in your app, you can use the `NavLink`
    component instead of the `Link` component. The only difference is that you can
    use the `activeStyle` property to change the look of the link when its URL matches
    the current URL.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you have the header and main sections. This is where you use the `Route`
    component to determine what is rendered in this part of the `App` component. For
    example, the first route in `<header>` uses the `render` property to render the
    title when the user is at the root of the app. The next two `Route` components
    use the component property to render other header content. The same pattern is
    used in `<main>`.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes can get messy fast. With this flat structure of declaring routes,
    it's easier to scan the routes in your code to figure out what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: This application has two features—`users` and `groups`. Each of them has its
    own `App` components defined. For example, `UsersHeader` is used in `<header>` and
    `UsersMain` is used in `<main>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `UsersHeader` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s what the `UsersMain` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The components used in the groups feature look almost exactly the same as these.
    If you run this example and navigate to `/users`, here''s what you can expect
    to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f491f3ff-e3d4-4a58-9651-4fdc27098853.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The URLs that you've seen so far in this chapter have all been static. Most
    applications will use both static and dynamic routes. In this section, you'll
    learn how to pass dynamic URL segments into your components, how to make these
    segments optional, and how to get query string parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Resource IDs in routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common use case is to make the ID of a resource part of the URL. This makes
    it easy for your code to get the ID, then make an API call that fetches the relevant
    resource data. Let's implement a route that renders a user detail page. This will
    require a route that includes the user ID, which then needs to somehow be passed
    to the component so that it can fetch the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `App` component that declares the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:` syntax marks the beginning of a URL variable. The `id` variable will
    be passed to the `UserContainer` component—here''s how it''s implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `match.params` property contains any dynamic parts of the URL. In this case,
    you're interested in the `id` parameter. Then, you pass the number version of
    this value to the `fetchUser()` API call. If the URL is missing the segment completely,
    then this code won't run at all; the router will revert back to the `/` route.
    However, there's no type-checking done at the route level, which means it's up
    to you to handle non-numbers being passed where numbers are expected, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the type cast operation will result in a 500 error if the
    user navigates to, for example, `/users/one`. You could write a function that
    type-checks parameters and, instead of failing with an exception, responds with
    a 404: Not found error. In any case, it''s up to the application, not the `react-router` library,
    to provide a meaningful failure mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the API functions used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchUsers()` function is used by the `UsersContainer` component to populate
    the list of user links. The `fetchUser()` function will find and resolve a value
    from the `users` array of mock data or the promise is rejected. If rejected, the
    error-handling behavior of the `UserContainer` component is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `User` component, responsible for rendering the user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this app and navigate to `/`, you should see a list of users that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b9cb8d10-3f29-43c5-936d-ab00b77d9acf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the first link should take you to `/users/0`, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bba66852-755f-4517-9f29-030d67c821ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if you navigate to a user that doesn''t exist, `/users/2`, here''s what
    you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a4c67402-c41b-4884-9113-603701e443b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason that you see this error message instead of a 500 error is because
    the API endpoint knows how to deal with missing resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the `UserContainer` setting its error state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This then results in the `User` component rendering the error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need optional URL path values and query parameters. URLs work
    best for simple options, and query parameters work best if there are many values
    that the component can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a user list component that renders a list of users. Optionally,
    you want to be able to sort the list in descending order. Let''s make this an
    optional path segment in the route definition for this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The`:` syntax marks a variable which the `?` suffix marks the variable as optional.
    This means that the user can provide anything they want after `/users/`. This
    also means that the component needs to make sure that the string `desc` is provided,
    and that everything else is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also up to the component to handle any query strings provided to it.
    So while the route declaration doesn''t provide any mechanism to define accepted
    query strings, the router will still pass the raw query string to the component.
    Let''s take a look at the user list container component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the `componentDidMount()` method, this component looks for either `params.desc`
    or `search.desc`. It uses this as an argument to the `fetchUsers()` API, to determine
    the sort order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `Users` component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s rendered when you navigate to `/users`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c2449b0a-5b34-44d4-9a7f-56e6f6ac5024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And if you include the descending parameter by navigating to `/users/desc`,
    here''s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d144b061-68fd-40c4-b239-cd96d7bc559b.png)'
  prefs: []
  type: TYPE_IMG
- en: Using link components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to create links. You might be tempted to use
    the standard `<a>` elements to link to pages controlled by `react-router`. The
    problem with this approach is that these links will try to locate the page on
    the backend by sending a GET request. This isn't what you want, because the route
    configuration is already in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll see an example that illustrates how `<Link>` elements are just
    like `<a>` elements in most ways. Then, you'll see how to build links that use
    URL parameters and query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Basic linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea with links in React apps is that they point to routes that point to
    components that render new content. The `Link` component also takes care of the
    browser history API and looking up route/component mappings. Here''s an application
    component that renders two links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `to` property specifies the route to activate when clicked. In this case,
    the application has two routes—`/first` and `/second`. Here is what the rendered
    links look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7be082c0-38af-4ec5-9d89-70222dfddc86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click the first link, the page content changes to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0bffaa0a-9854-4fd7-9d5b-d271d4d311b3.png)'
  prefs: []
  type: TYPE_IMG
- en: URL and query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructing the dynamic segments of a path that is passed to `<Link>` involves
    string manipulation. Everything that's part of the path goes in the `to` property.
    This means that you have to write more code to construct the string, but it also
    means less behind-the-scenes magic happening in the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple component that will echo back whatever is passed to
    the echo URL segment or the `echo` query parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `withRouter()` utility function is a higher-order function that returns
    a new component. This new component will have router-related properties passed
    to it, which you need if you want to work with path segment variables or the query
    string. The two properties used by your `Echo` component are `match.params` for
    the URL path variables and `location.search` for the query string.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to `react-router` version 4, the query string was parsed and passed in
    as an object. Now that has to be handled in your code. In this example, `URLSearchParams`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `App` component that renders two links. The
    first will build a string that uses a dynamic value as a URL parameter. The second
    will use `URLSearchParams` to build the query string portion of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the two links look like when they''re rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d894d61b-c4b7-4eea-a6b9-65611090e2aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The param link takes you to `/echo/From Param`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e8affd79-21f3-46a3-80d3-49488b8855dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The query link takes you to `/echo?echo=From+Query`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/da41a9cd-d7d5-4a6b-96ca-9d7fcefa58f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about routing in React applications. The job of
    a router is to render content that corresponds to a URL. The `react-router` package
    is the standard tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how routes are JSX elements, just like the components they render.
    Sometimes, you need to split routes into feature-based modules. A common pattern
    for structuring page content is to have a parent component that renders the dynamic
    parts as the URL changes.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to handle the dynamic parts of URL segments and query strings.
    You also learned how to build links throughout your application using the `<Link>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to render React components in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `react-router` package is the official package used for routing in React
    apps and therefore, the only option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, `react-router` is the official React routing solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, `react-router` is one of several routing options and you should spend time
    looking at each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, **`react-router`** is the de facto routing solution for React and you should
    use it unless you have a strong reason not to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between `Route` and `Router` components?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **`Route`** is used to render components based on URL matches and a **`Router`**
    is used to declare route-component mappings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Router` should be declared by every component, to declare the routes used
    by the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you change only certain parts of the UI as the route changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't change only certain parts, you have to re-render the entire component
    tree, starting at the root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use **`Route`** components to render content that is specific to any given
    section, based on the provided **`path`** property. You can have more than one
    **`Route`** with the same **`path`** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You pass section names as property values to `Route` components, along with
    the component to render for that section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use the `NavLink` component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you want `react-router` to automatically style active links for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To show the user which links are navigation links versus regular links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you want to use the **`activeStyle`** or **`activeClassName`** properties
    to style active links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you get values from URL paths?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can get the value of any URL path segment by passing the index of the segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to parse the URL yourself and find the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use the** `:`** syntax to specify that this is a variable and **`react-router`**
    will pass this value into your component as a property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
