- en: Introducing Nuxt
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍Nuxt
- en: Welcome to your journey of *Hands-on Nuxt.js Web Development*. In this chapter,
    we will peer inside Nuxt to see what constitutes this framework. We will walk
    you through Nuxt's features and you will get to know the pros and cons of the
    different types of applications that Nuxt falls in line with. Last but not least,
    you will discover the great potential of using Nuxt as a universal SSR app, a
    static site generator, and a single-page app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到您的*Nuxt.js Web开发实践*之旅。在本章中，我们将深入了解Nuxt，看看构成这个框架的是什么。我们将带您了解Nuxt的特性，您将了解Nuxt所属的不同类型应用程序的优缺点。最后但同样重要的是，您将发现使用Nuxt作为通用SSR应用程序、静态站点生成器和单页面应用程序的巨大潜力。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: From Vue to Nuxt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Vue到Nuxt
- en: Why Use Nuxt?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Nuxt？
- en: Types of applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类型
- en: Nuxt as a universal SSR app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为通用SSR应用程序
- en: Nuxt as a static site generator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为静态站点生成器
- en: Nuxt as a single-page app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nuxt作为单页面应用程序
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: From Vue to Nuxt
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Vue到Nuxt
- en: 'Nuxt is a higher-level Node.js web development framework for creating Vue apps
    that can be developed and deployed in two different modes: universal (SSR) or
    **single-page application** (**SPA**). Furthermore, you can deploy SSR and SPA
    in Nuxt as static-generated apps. Even though you can choose the SPA mode, the
    full power of Nuxt lies in its universal mode or **server-side rendering** (**SSR**)
    for building universal apps. A universal app is used to describe JavaScript code
    that can execute both on the client and the server-side. But if you wish to develop
    a classic (or standard/traditional) SPA, which executes on the client-side only,
    you may want to consider using vanilla Vue.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt是一个更高级的Node.js Web开发框架，用于创建可以以两种不同模式开发和部署的Vue应用程序：通用（SSR）或单页面应用程序（SPA）。此外，您可以在Nuxt中部署SSR和SPA作为静态生成的应用程序。尽管您可以选择SPA模式，但Nuxt的全部潜力在于其通用模式或用于构建通用应用程序的服务器端渲染（SSR）。通用应用程序用于描述可以在客户端和服务器端都执行的JavaScript代码。但是，如果您希望开发经典（或标准/传统）的SPA，仅在客户端执行的SPA，您可能希望考虑使用纯Vue。
- en: Note that an SPA mode Nuxt app is slightly different from a classic SPA. You
    will find out more about it later in this book and briefly in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，SPA模式的Nuxt应用程序与经典SPA略有不同。您将在本书的后面和本章中简要了解更多信息。
- en: Nuxt is created on top of Vue, supercharged with some extra features such as
    asynchronous data, middleware, layouts, modules, and plugins that execute your
    app on the server-side first, and then on the client-side. This means the app
    generally renders quicker than the traditional server-side (or multiple-page)
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt是建立在Vue之上的，具有一些额外功能，如异步数据、中间件、布局、模块和插件，可以先在服务器端执行您的应用程序，然后再在客户端执行。这意味着应用程序通常比传统的服务器端（或多页面）应用程序渲染更快。
- en: 'Nuxt is pre-installed with the following packages so that you don''t have to
    install them, which you would do in a standard Vue app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt预装了以下软件包，因此您无需像在标准Vue应用程序中那样安装它们：
- en: Vue ([https://vuejs.org/](https://vuejs.org/))
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue（[https://vuejs.org/](https://vuejs.org/)）
- en: Vue Router ([https://router.vuejs.org/](https://router.vuejs.org/))
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue路由器（[https://router.vuejs.org/](https://router.vuejs.org/)）
- en: Vuex ([https://vuex.vuejs.org/](https://vuex.vuejs.org/))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vuex（[https://vuex.vuejs.org/](https://vuex.vuejs.org/)）
- en: Vue Server Renderer ([https://ssr.vuejs.org/](https://ssr.vuejs.org/))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue服务器渲染器（[https://ssr.vuejs.org/](https://ssr.vuejs.org/)）
- en: Vue Meta ([https://vue-meta.nuxtjs.org/](https://vue-meta.nuxtjs.org/))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue元（[https://vue-meta.nuxtjs.org/](https://vue-meta.nuxtjs.org/)）
- en: 'On top of that, Nuxt uses webpack and Babel to compile and bundle your code
    with the following webpack loaders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Nuxt使用webpack和Babel来编译和捆绑您的代码，使用以下webpack加载器：
- en: Vue Loader ([https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue加载器（[https://vue-loader.vuejs.org/](https://vue-loader.vuejs.org/)）
- en: Babel Loader ([https://webpack.js.org/loaders/babel-loader/](https://webpack.js.org/loaders/babel-loader/))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel Loader ([https://webpack.js.org/loaders/babel-loader/](https://webpack.js.org/loaders/babel-loader/))
- en: In a nutshell, webpack is a module bundler that bundles all the scripts, styles,
    assets, and images in your JavaScript app, while Babel is a JavaScript compiler
    that compiles or transpiles the next-generation JavaScript (ES2015+) to browser-compatible
    JavaScript (ES5) so that you can run your code on current browsers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，webpack是一个模块打包工具，它将JavaScript应用程序中的所有脚本、样式、资产和图像捆绑在一起，而Babel是一个JavaScript编译器，它将下一代JavaScript（ES2015+）编译或转译为浏览器兼容的JavaScript（ES5），以便您可以在当前浏览器上运行您的代码。
- en: For more information about webpack and Babel, please visit [https://webpack.js.org/](https://webpack.js.org/) and [https://babeljs.io/](https://babeljs.io/),
    respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关webpack和Babel的更多信息，请分别访问[https://webpack.js.org/](https://webpack.js.org/)和[https://babeljs.io/](https://babeljs.io/)。
- en: webpack uses what they call loaders to preprocess your files when you import
    them via the JavaScript `import` statement or `require` method. You can write
    your loaders but you don't have to do so when compiling your code in Vue files
    since they have been created for you by the Babel community and Vue team. We'll
    discover the great features that come with Nuxt and those contributed by these
    loaders in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: webpack使用他们称之为加载器的东西来预处理您通过JavaScript `import`语句或`require`方法导入的文件。您可以编写自己的加载器，但在编译Vue文件时，您无需这样做，因为它们已经由Babel社区和Vue团队为您创建。我们将在下一节中发现Nuxt带来的伟大功能以及这些加载器贡献的功能。
- en: Why use Nuxt?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Nuxt？
- en: Frameworks such as Nuxt exist because of the shortcomings of the traditional SPA
    and the server-side rendering of **multi-page applications** (**MPAs**). We can
    regard Nuxt as a hybrid of server-side rendering MPA and traditional SPA. Hence,
    it is dubbed "universal" or "isomorphic". So, being able to do server-side rendering
    is the defining feature of Nuxt. In this section, we will walk you through other
    prominent features of Nuxt that will make your app development easy and fun. The
    first feature we'll look at allows you to write single-file Vue components by
    using a `.vue` extension in your files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传统SPA和**多页面应用**（**MPA**）的缺点，存在诸如Nuxt之类的框架。我们可以将Nuxt视为服务器端渲染MPA和传统SPA的混合体。因此，它被称为“通用”或“同构”。因此，能够进行服务器端渲染是Nuxt的定义特性。在本节中，我们将为您介绍Nuxt的其他突出特性，这将使您的应用开发变得简单而有趣。我们将首先介绍的功能允许您通过在文件中使用`.vue`扩展名来编写单文件Vue组件。
- en: Writing single-file components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单文件组件
- en: 'There are a few methods we can use to create a Vue component. A global Vue
    component is created by using `Vue.component`, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种方法来创建Vue组件。全局Vue组件是通过使用`Vue.component`创建的，如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, a local Vue component can be created using a plain JavaScript
    object, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可以使用普通JavaScript对象创建本地Vue组件，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two methods are manageable and maintainable if you're using Vue for a
    small project, but it becomes difficult to manage for a big project when you have
    tons of components with different templates, styles, and JavaScript methods all
    at once.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在小型项目中使用Vue是可管理和可维护的，但是当你一次拥有大量具有不同模板、样式和JavaScript方法的组件时，对于大型项目来说，管理变得困难。
- en: 'Hence, single-file components come to the rescue, in which we only use one
    `.vue` file for each Vue component. If you need more than one component in your
    app, then just separate them into multiple `.vue` files. In each of them, you
    can write the template, script, and style that relate to that particular component
    only, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单文件组件来拯救，我们只使用一个`.vue`文件来创建每个Vue组件。如果您的应用程序需要多个组件，只需将它们分开成多个`.vue`文件。在每个文件中，您可以只编写与该特定组件相关的模板、脚本和样式，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, you can see how we have an HTML template that prints the message from
    the JavaScript script and the CSS style that describes the presentation of the
    template, all in one single `.vue` file. This makes your code more structured,
    readable, and organizable. Sweet, isn't it? This is only made possible by `vue-loader`
    and webpack. In Nuxt, we only write components in `.vue` files, regardless of
    whether they are components in the `/components/`, `/pages/`, or `/layouts/` directory.
    We will explore this in more detail in [Chapter 2](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml),
    *Getting Started with Nuxt*. Now, we'll look at the Nuxt feature that allows you
    to write ES6 JavaScript out of the box.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们有一个HTML模板，它从JavaScript脚本中打印消息，并且描述模板的CSS样式，全部在一个`.vue`文件中。这使得您的代码更加结构化、可读和可组织。很棒，不是吗？这只能通过`vue-loader`和webpack实现。在Nuxt中，我们只在`.vue`文件中编写组件，无论它们是`/components/`、`/pages/`还是`/layouts/`目录中的组件。我们将在[第2章](f3ae7ce4-4ed5-4252-8318-3afb431415e2.xhtml)中更详细地探讨这一点，*开始使用Nuxt*。现在，我们将看一下Nuxt功能，它允许您直接编写ES6
    JavaScript。
- en: Writing ES2015+
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写ES2015+
- en: 'Nuxt compiles your ES6+ code out of the box without you having to worry about
    configuring and installing Babel in webpack. This means you can write ES6+ code
    straight away and your code will be compiled into JavaScript that can be run on
    older browsers. For example, you will see the following destructuring assignment
    syntax often when using an `asyncData` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Nuxt在不需要您担心配置和安装Babel在webpack的情况下，即可编译您的ES6+代码。这意味着您可以立即编写ES6+代码，并且您的代码将被编译为可以在旧版浏览器上运行的JavaScript。例如，当使用`asyncData`方法时，您经常会看到以下解构赋值语法：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The destructuring assignment syntax is used in the preceding code to unpack
    the properties from the Nuxt context into distinct variables that we can use for
    the logic inside the `asyncData` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用解构赋值语法将Nuxt上下文中的属性解包到不同的变量中，以便我们可以在`asyncData`方法中使用这些变量进行逻辑处理。
- en: For more information about the Nuxt context and ECMAScript 2015 features, please
    visit [https://nuxtjs.org/api/context](https://nuxtjs.org/api/context) and [https://babeljs.io/docs/en/learn/](https://babeljs.io/docs/en/learn/),
    respectively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Nuxt上下文和ECMAScript 2015功能的更多信息，请分别访问[https://nuxtjs.org/api/context](https://nuxtjs.org/api/context)和[https://babeljs.io/docs/en/learn/](https://babeljs.io/docs/en/learn)。
- en: Writing ES6 in Nuxt is only made possible by `babel-loader` and webpack. There's
    more than just the destructuring assignment syntax that you can write in Nuxt,
    including the `async` function, the `await` operator, the `arrow` function, the
    `import` statement, and many more. What about the CSS preprocessor? If you write
    CSS styles with a popular CSS preprocessor such as Sass, Less, or Stylus, but if
    you are a Sass person and not a Less person, nor a Stylus person, can Nuxt support
    any of them? The short answer is yes. We'll find out the long answer to this question
    in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nuxt中编写ES6只能通过`babel-loader`和webpack实现。在Nuxt中，您可以编写更多内容，包括`async`函数、`await`运算符、`箭头`函数、`import`语句等。那么CSS预处理器呢？如果您使用Sass、Less或Stylus等流行的CSS预处理器编写CSS样式，但如果您是Sass用户而不是Less用户或Stylus用户，Nuxt是否支持它们中的任何一个？简短的答案是是。我们将在下一节中找出这个问题的长答案。
- en: Writing CSS with a preprocessor
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预处理器编写CSS
- en: 'In Nuxt, you can choose your favorite CSS preprocessor to write the styles
    for your app, whether it is Sass, Less, or Stylus. They are already pre-configured
    for you in Nuxt. You can check out their configurations at [https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js](https://github.com/nuxt/nuxt.js/blob/dev/packages/webpack/src/config/base.js).
    So, you just need to install the preprocessor and its webpack loader in your Nuxt
    project. For example, if you want to use Less as your CSS preprocessor, just install
    the following dependencies in your Nuxt project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, you can start writing your Less code by setting the `lang` attribute
    to "less" in the `<style>` block, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From this example, you can see that writing modern CSS styles is as easy as
    writing modern JavaScript in Nuxt. All you are required to do is install your
    favorite CSS preprocessor and its webpack loader. We will use Less in this book
    in the upcoming chapters, but for now, let's find out what other features Nuxt
    offers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about these preprocessors and their webpack loaders, please
    visit the following links:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[http://lesscss.org/](http://lesscss.org) for Less'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/loaders/less-loader/](https://webpack.js.org/loaders/less-loader/) for less-loader'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sass-lang.com/](https://sass-lang.com/) for Sass'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/loaders/sass-loader/](https://webpack.js.org/loaders/sass-loader/) for sass-loader'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://stylus-lang.com/](https://stylus-lang.com/) for Stylus'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/shama/stylus-loader](https://github.com/shama/stylus-loader) for stylus-loader'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though PostCSS is not a preprocessor, if you want to use it in a Nuxt project,
    please visit the guide provided at [https://nuxtjs.org/faq/postcss-plugins](https://nuxtjs.org/faq/postcss-plugins).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Extending Nuxt with modules and plugins
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nuxt was created on top of a modular architecture. This means you can extend it
    with endless modules and plugins for your app or Nuxt community. This also means you
    can choose tons of modules and plugins from the Nuxt and Vue communities so that
    you don''t have to reinvent them for your app. The links to these are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Awesome Nuxt.js at [https://github.com/nuxt-community/awesome-nuxt#official](https://github.com/nuxt-community/awesome-nuxt#official) for
    Nuxt modules
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome Vue.js at [https://github.com/vuejs/awesome-vue#components--libraries](https://github.com/vuejs/awesome-vue#components--libraries)[ ](https://github.com/vuejs/awesome-vue#components--libraries)for
    Vue components, libraries, and plugins
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and plugins are simply JavaScript functions. Don't worry about the distinction
    between them for now; we will get to this in [Chapter 6](2102475f-1a6b-42c0-abaa-ec018f8fa25a.xhtml),
    *Writing Plugins and Modules*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Adding transitions between routes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike traditional Vue apps, in Nuxt, you don''t have to use the wrapper `<transition>`
    element to handle JavaScript animations, CSS animations, and CSS transitions on
    your elements or components. For example, if you want to apply a `fade` transition
    to the specific page when navigating to it, you can just add the transition name (for
    example, `fade`) to the `transition` property of that page:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you can just create the transition style in a `.css` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The "fade" transition will apply to the `about` page automatically when navigating
    to the `/about` route. Cool, isn't it? Don't worry if the code or the class names
    look a bit overwhelming to you at this point; we will look at this transition
    feature and explore it in more detail in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Managing the <head> element
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also, unlike traditional Vue apps, you can manage the `<head>` block of your
    app out of the box without installing the additional Vue package that handles
    it – `vue-meta`. You just add the data you need for `<title>`, `<meta>`, and `<link>`
    via the `head` property to any page. For example, you can manage the global `<head>`
    element via the Nuxt config file of your app:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Nuxt will convert this data into the HTML tags for you. Again, we will learn
    about this feature and explore it in more detail in [Chapter 4](aa55a711-4ba3-45e1-bad6-96067701bba7.xhtml),
    *Adding Views, Routes, and Transitions*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Bundling and splitting code with webpack
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nuxt uses webpack to bundle, minify, and split your code into chunks that can
    speed up the load time of your app. For example, in a simple Nuxt app with two
    pages, index/home and about, you will get similar chunks for the client-side:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The chunks that you would get for the server-side will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These chunks and the build information are generated when you use Nuxt `npm
    run build` command to build your app for deployment. We will look at this in more
    detail in [Chapter 14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters,
    Formatters, and Deployment Commands*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'This aside, there are other great features and plugins from webpack that are
    used by Nuxt, such as static files and asset serving (asset management), hot module
    replacement, CSS extraction (`extract-css-chunks-webpack-plugin`), a progress
    bar while you''re building and watching (webpackbar), and so on. For more information,
    please visit the following links:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)
    for code splitting'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/concepts/manifest/](https://webpack.js.org/concepts/manifest/)
    for the manifest'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/guides/asset-management/](https://webpack.js.org/guides/asset-management/)
    for asset management'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/concepts/hot-module-replacement/](https://webpack.js.org/concepts/hot-module-replacement/)
    for hot module replacement'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://webpack.js.org/plugins/mini-css-extract-plugin/](https://webpack.js.org/plugins/mini-css-extract-plugin/)
    for CSS extraction'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/nuxt/webpackbar](https://github.com/nuxt/webpackbar) for `webpackbar`
    (a plugin developed by Nuxt core team)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These great features from webpack, Babel, and Nuxt itself will make your modern
    project development fun and easy. Now, let's take a look at the various application
    types to see why you should or shouldn't use Nuxt when you're building your next
    web app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Types of applications
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web applications of today are very different from the ones from decades
    ago. We had fewer options and solutions in those days. Today, they are blooming.
    Whether we call them "applications" or "apps", they are the same. We will call
    them "apps" in this book. So, we can categorize our current web apps as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Traditional server-side rendered app
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional SPA
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal SSR app
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static-generated app
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through each of them and understand the pros and cons. We will first
    look at the oldest type of app – the traditional server-side rendered app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Traditional server-side rendered app
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Server-side rendering is the most common approach for delivering the data and
    HTML to the client side on the browser on your screen. It was the only way to
    do things when the web industry just started. In traditional server-rendered apps
    or dynamic websites, every request requires a new page re-rendered from the server
    to the browser. This means you will reload all the scripts, styles, and template(s)
    once more with every request you send to the server. The idea of reloading and
    re-rendering does not sound compelling and elegant at all. Even though some of
    the reloading and re-rendering burdens can be lifted by using AJAX these days,
    this adds more complexity to the app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through the advantages and disadvantages of these types of apps.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Better SEO performance:** Because the client (browser) gets the finished
    page with all the data and HTML tags, especially the meta tags that belong to
    the page, search engines can crawl the page and index it.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster initial load time:** Because the pages and content are rendered on
    the server side by a server-side scripting language such as PHP before sending
    it to the client browser, we get the rendered page fast on the client side. Also,
    there is no need to compile the web pages and content in JavaScript files like
    we do in traditional SPAs, so the app is loaded quicker on the browser.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Poorer user experience:** Because every page has to be re-rendered and this
    process takes time on the server, the user has to wait until everything is reloaded
    on the browser and that may affect the user experience. Most of the time, we want
    the new data only when provided with the new request; we don''t need the HTML
    base to be regenerated, for example, the navigation bar and the footer, but still,
    we get these base elements re-rendered, regardless. We can make use of AJAX to
    render just a particular component, but this makes development more difficult
    and complex.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tight coupling of the backend and frontend logic:** The view and data are
    usually handled together within the same app. For example, in a typical PHP framework
    app such as Laravel, you may render the view ([https://laravel.com/docs/7.x/views](https://laravel.com/docs/7.x/views))
    with a template engine such as Laravel Pug ([https://github.com/BKWLD/laravel-pug](https://github.com/BKWLD/laravel-pug))
    in a route. Or, if you are using Express for a traditional server-side rendered
    app, you may use a template engine such as Pug ([https://pugjs.org/api/getting-started.html](https://pugjs.org/api/getting-started.html))
    or vuexpress ([https://github.com/vuexpress/vuexpress](https://github.com/vuexpress/vuexpress))
    for rending the view ([https://expressjs.com/en/guide/using-template-engines.html](https://expressjs.com/en/guide/using-template-engines.html)).
    In these two frameworks for a typical, traditional server-side rendered app, the
    view is coupled with the backend logic, even though we can extract the view layer
    with a template engine. The backend developer has to know what view (for example,
    `home.pug`) to use for each specific route or controller. On the other hand, the
    frontend developer has to work on the view within the same framework as the backend
    developer. This adds more complexity to the project.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional single-page app (SPA)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As opposed to server-side rendered apps, SPAs are client-side rendered (CSR)
    apps that render content in the browser using JavaScript without requiring new
    pages to be reloaded during use. So, instead of getting the content rendered to
    the HTML document, you get barebones HTML from the server, and the content will
    be loaded using JavaScript in the browser, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very simple Vue app in which you have a container, `<div>`, with
    `app` as its ID only and nothing else inside it, followed by two `<script>` elements.
    The first `<script>` element will load the Vue.js library, while the second one
    will load the Vue instance that renders the content of your app, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's go through the advantages and disadvantages of this type of app.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages:**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Better user experience:** SPA is fast when rendering content after the initial
    load. Most resources, such as CSS styles, JavaScript code, and HTML templates,
    are only loaded once throughout the lifespan of the app. Only data is sent back
    and forth afterward; the base HTML and layout stay unchanged, thus offering a
    smooth and better user experience.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier development and deployment:** SPA development is comparatively easier
    to get started without the need for a server and a server-side scripting language.
    You can simply kick off the development from your local machine with `file://URI`.
    It is easier to deploy as well because it consists of HTML, JavaScript, and CSS
    files; you can just drop them to the remote server and go live right away.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages:**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Poor performance on the search engine:** SPAs are bare-bone single HTML pages,
    mostly with no headings and paragraph tags for search engine crawlers to crawl.
    The SPA content is loaded via JavaScript that the crawlers mostly cannot execute,
    so SPAs usually perform poorly in SEO.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slow initial load time:** Most resources such as CSS styles, JavaScript code,
    and HTML templates are only loaded once throughout the lifespan of the app, so
    we need to load tons of these resource files all at once at the beginning. By
    doing this, the app usually slows down regarding its initial loading time, especially
    in a large SPA.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal server-side rendered app (SSR)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we learned in the previous section, there are advantages and disadvantages
    to both traditional server-side rendered apps and SPAs. There are benefits in
    writing SPAs, but there are things that you lose: the ability for web crawlers
    to traverse your app and slower performance while the app is initially loaded.
    This is the opposite of writing traditional server-side rendered apps, also there
    are things you do not have, such as better user experience and the fun of client-side
    development in SPAs. Ideally, client-side and server-side rendering can be balanced
    for user experience and performance. Here is where universal server-side rendering
    (SSR) comes to bridge the gap.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has become an isomorphic language since the release of Node.js in
    2009\. By isomorphic, we mean that codes can run both on the client side and the
    server side. Isomorphic (universal) JavaScript can be defined as a hybrid of client-side
    and server-side applications. It is a new approach for web apps to compensate
    for the shortcomings of both traditional SSR apps and traditional SPAs. This is
    the category that Nuxt falls into.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In universal SSR, your app will first pre-load on the server side, pre-render
    the pages, and send the rendered HTML to the browser before switching to the client-side
    operation for the rest of its lifespan. Building universal SSR apps from scratch
    can be tedious as it requires lots of configuration before the actual development
    process begins. This is what Nuxt aims to achieve by presetting all the configuration
    needed for you to create SSR Vue apps easily.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Even though universal SSR apps are a great solution in our modern web development,
    there are still advantages and disadvantages to these types of apps. Let's go
    through them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster initial load time: **In universal SSR, JavaScript and CSS are split
    into chunks, assets are optimized, and pages are rendered on the server-side before
    being served to the client browser. All of these options help make the initial
    loading time faster.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better SEO support:** Since all pages are rendered on the server side with
    the appropriate meta content, headings, and paragraphs before being served on
    the client side, the search engine crawlers can traverse the page to increase
    the SEO performance of your app.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better user experience:** Universal SSR apps work like traditional SPAs after
    the initial load in that the transition between pages and routes is seamless.
    Only data is transmitted back and forth without re-rendering the HTML content
    holders. All these features have helped to provide a better user experience overall.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js server required: **Running JavaScript on the server side requires
    a Node.js server, so the server must be set up before you can use Nuxt and write
    your app.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex development:** Running JavaScript code in universal SSR apps can
    be confusing because some JavaScript plugins and libraries are meant to run on
    the client side only, such as Bootstrap and Zurb Foundation for styling and DOM
    manipulation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static-generated app
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static-generated apps are pre-generated with the help of a static site generator
    and stored as static HTML pages on the hosting server. Nuxt comes with a `nuxt
    generate` command that generates **static pages** out of the box for you from
    the universal SSR or SPA app that you''ve developed in Nuxt. It pre-renders HTML
    pages for each of your routes into a generated `/dist/` folder during the build
    step, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can deploy these static files to a static hosting server without the need
    for Node.js or any server-side support. So, when the app is initially loaded on
    the browser – no matter what route you are requesting – you will always get the
    full content (if it's been exported from the universal SSR app) immediately, and
    the app will perform like a traditional SPA afterward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through the advantages and disadvantages of these types of apps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Advantages**:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast initial load time:** Since each route is pre-generated as a static HTML
    page that has its own content, it is fast to load on the browser.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good for SEO:** Static-generated web apps allow your JavaScript app to be
    crawled perfectly by search engines, just like traditional server-side rendered
    apps.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier deployment:** Because static-generated web apps are just static files,
    this makes them easy to deploy to static hosting servers such as GitHub Pages.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disadvantages**:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**No server-side support:** Because static-generated web apps are just static
    HTML pages and run on the client side only, this means there''s no runtime support
    for Nuxt''s `nuxtServerInit` action method and Node.js HTTP request and response objects,
    which are only available on the server side. All data will be pre-rendered during
    the build step.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No real-time rendering: **Static-generated web apps are suitable for apps
    that only serve **static pages** that are pre-rendered at **build time**. If you
    are developing a complex app that requires real-time rendering from the server,
    then you should probably use universal SSR instead to utilize the full power of
    Nuxt.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From these categories, you have probably figured out that Nuxt falls in line
    with universal SSR apps and static-generated apps. Apart from this, it also falls
    in line with single-page apps, but not the same as traditional SPAs, which you
    will find out more about in [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a better look at Nuxt regarding the types of applications that
    you will be creating in this book. We'll start with Nuxt as a universal SSR app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt as a universal SSR app
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many years ago, we had server-side scripting languages such as ASP, Java, server-side
    JavaScript, PHP, and Python to create traditional server-side apps with template
    engines to render the view of our apps. This resulted in the tight coupling disadvantage
    that we went through in the previous section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with the rise of universal SSR frameworks such as Nuxt, Next ([https://nextjs.org/](https://nextjs.org/)),
    and Angular Universal ([https://angular.io/guide/universal](https://angular.io/guide/universal)),
    we can utilize their full power to decouple the view from the server-side scripting
    app for good by replacing the template engine, such as Pug ([https://pugjs.org/](https://pugjs.org/)),
    Handlebars ([https://handlebarsjs.com/](https://handlebarsjs.com/)), Twig ([https://twig.symfony.com/](https://twig.symfony.com/)),
    and many more that we have been deeply replying on. If we consider Nuxt a **frontend
    server-side** app and Express (or others) a **backend server-side** app, we can
    see how they complement each other perfectly. For example, we can use Express
    to create a backend server-side app for serving data in JSON format on an API
    route (for example, `/`) at `localhost:4000`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, on the frontend server side, we can use Nuxt as a universal SSR app running
    on `localhost:3000` to consume the aforementioned data by sending an HTTP request
    from a page in our Nuxt app, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have Nuxt as both a server and a client that handles our app's view
    and templates, while Express just handles our server-side logic. We no longer
    need a template engine to present our content. So, for once, perhaps we don't
    need to learn so many template engines and we don't need to worry about the battle
    between them because we now have the universal one – Nuxt.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We will show you how to create cross-domain apps with Nuxt and Koa (another
    Node.js server-side framework similar to Express) in [Chapter 12](8e574c51-68dc-45e2-8a1d-4c04d9c38df5.xhtml),
    *Creating User Logins and API Authentication*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the preceding code, we used the Nuxt HTTP module to make the HTTP
    request. However, we will mostly use vanilla Axios or theNuxt Axios modulethroughout
    this book for HTTP requests. For more information about the Nuxt HTTP module,
    please visit [https://http.nuxtjs.org/](https://http.nuxtjs.org/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: You also can use the Nuxt Content module to act as headless CMS so that you
    can serve your app content from Markdown, JSON, YAML, XML, and CSV files that
    can be stored "locally" in your Nuxt project. However, in this book, we will be
    using and creating external APIs to serve our content in order to avoid the tightly
    coupled issue that we found in the traditional server-side apps in the first place.
    For more information about the Nuxt Content module, please visit [https://content.nuxtjs.org/](https://content.nuxtjs.org/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt as a static site generator
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though server-side rendering is the main feature of Nuxt, it is also a
    static site generator that pre-renders your Nuxt app in a static site, as shown
    in the example provided for the static-generated app category. It is perhaps the
    best of both worlds between a traditional single-page application and a server-side-rendered
    app. While benefiting from the static HTML content for a better SEO, you no longer
    need the runtime support from Node.js and Nuxt. However, your app will still behave
    like an SPA.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: What's more is that during static generation, Nuxt has a crawler that crawls
    the links in your app to generate dynamic routes and save their data from the
    remote API as `payload.js` files in a `/static/` folder inside the `/dist/` folder.
    These payloads are then used to serve the data that was originally requested from
    the API. This means you are not calling the API anymore. This can secure your
    API from the public, and possibly from attackers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn how to generate static sites from Nuxt with a remote API in [Chapter
    14](34aaa294-2c3b-464e-8e96-5eb6d1eaff48.xhtml), *Using Linters, Formatters, and
    Deployment Commands*, and in the final chapter of this book, [Chapter 18](a2720301-9e1c-4c28-8af8-39bd5c093fb9.xhtml), *Creating
    a Nuxt App with CMS and GraphQL*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Nuxt as a single-page app
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nuxt is well-suited for developing single-page apps if you have any reason that
    prevents you from using Nuxt as a server-side rendering app. As we mentioned at
    the beginning of this chapter, Nuxt comes with two modes for developing your app: 
    `universal` and `spa`.  This means you just have to specify `spa` in the `mode`
    property in your project configuration, which we'll explore in more detail in
    the next chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you might be thinking that if we can use Nuxt for developing a SPA, then
    why bother with Vue anymore? In fact, the SPA you can develop from Nuxt is slightly
    different from the SPA from Vue. The SPA you build from Vue is a traditional SPA,
    while the SPA from Nuxt is a "static" SPA (let''s refer to it as Nuxt SPA) – your
    app pages are pre-rendered at build time. This means deploying a Nuxt SPA is technically
    the same as statically generating a Nuxt universal SSR app – both require the
    same Nuxt command: `nuxt generate`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This can be confusing and you may want to ask what is the difference between
    the static-generated SSR app and the static-generated SPA? The difference is very
    obvious – the static-generated SPA has no page content compared to the static-generated
    SSR app. The static-generated SPA is pre-rendered with your app pages and "empty"
    HTML, just like the traditional SPA – devoid of page content. This is confusing,
    but rest assured, we will figure all this out in the upcoming chapters of this
    book. In particular, you learn about the trade-offs of developing SPAs in Nuxt
    and how to overcome them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn how to develop a Nuxt SPA and generate a static Nuxt SPA with a
    remote API in [Chapter 15](450e252f-a94b-4f7f-9762-533a150f5d19.xhtml), *Creating
    an SPA with Nuxt*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! You have made it through the first chapter of your journey into Nuxt.
    In this chapter, you learned what makes up the Nuxt framework; that is, Vue (the
    origin of Nuxt), webpack, and Babel. You learned about the various features Nuxt
    provides, such as the ability for you to write Vue single-file components (`.vue` files),
    ES2015+ JavaScript (ES6), CSS with a preprocessor (Sass, Less, Stylus). You are
    also able to extend your app with modules and plugins, to add transitions between
    the routes of your app, to manage the `<head>` element and the meta content of
    each route or page in your app.  Apart from this you also covered tons of great
    features that are imported from webpack and Babel, such as bundling, minifying,
    and splitting code. You also learned that you can access tons of plugins and modules
    from the Nuxt community for your Nuxt projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these great features, you learned about the pros and cons of each
    type of available application: traditional server-side rendered apps, traditional
    single-page apps (SPAs), universal server-side rendered apps (SSRs), and static-generated
    apps. You also learned that Nuxt apps actually fall in line with the categories
    of universal SSR apps and static-generated apps. And then, you learned that Nuxt
    also falls in line with single-page apps, but not the same as traditional SPAs.
    Lastly, you looked into using Nuxt for universal SSR apps, static-generated apps,
    and single-page apps, all of which you''ll learn more about throughout this book.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to install Nuxt and create a simple
    Nuxt app and understand the default directory structure that comes with the Nuxt
    scaffolding tool. You will also learn how to customize your Nuxt app and understand
    the assets that are served in Nuxt. So, stay tuned!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
