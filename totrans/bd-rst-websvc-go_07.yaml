- en: Working with PostgreSQL, JSON, and Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at SQL in the big picture. In previous
    chapters, we discussed SQLite3, which is a small database for quick prototyping.
    But when it comes to a production grade application, people prefer MySQL or PostgreSQL.
    Both are well proven in the web application space. First, we will discuss the
    internals of PostgreSQL and then move on to writing database models in Go. We
    will then try to realize the URL shortening service with a solid example.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the PostgreSQL database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PostgreSQL and creating users and databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about `pq`, a database driver in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a URL shortening service with PostgreSQL and a Base62 algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the JSON store in PostgreSQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `gorm`, a powerful ORM for Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of an e-commerce REST API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7).
    In the previous chapter, we discussed protocol buffers and GRPC. But here, we
    come back to the REST API with JSON and see how PostgreSQL supplements JSON.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PostgreSQL database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL is an open-source database that can be installed on multiple platforms.
    On Ubuntu, it can be installed using the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the repo to the package list:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To update the package list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This installs the database on an Ubuntu machine and starts a server on port
    `5432`.Now, in order to enter the database shell, use these commands. PostgreSQL
    creates a default user called `postgres` to log in. Take a look at the following
    command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the user has access to the database. Launch the PostgreSQL shell using
    the `psql` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This shows that PostgreSQL follows a different approach for entering into the
    shell compared to other similar databases such as MySQL or SQLite3\. On Windows,
    the installation is done by clicking the binary installer file. It is a GUI-based
    installation where the port and password for superuser should be supplied. Once
    the database is installed, we can check that using the **pgAdmin3** tool. The
    macOS X setup is similar to Ubuntu, except the installation is done through Homebrew.
    Take a look at the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then make the database server run even when the system is rebooted by using
    the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, the PostgreSQL server starts running and is available to store and retrieve
    data on macOS X.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Adding users and databases in PostgreSQL
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we should know how to create a new user and database. For this, we are
    going to use Ubuntu/Mac as the general example. We do this in a shell called the `psql` shell.
    We can see all available commands in `psql` using the `\?`  command. In order
    to enter into `psql`, first change to the `postgres` user. On Ubuntu, you can
    do that using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, it turns us into a user called `postgres`. Then, launch the `psql` shell
    using the `psql` command. If you type `\?` in there, you see the output of all
    available commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a59458f4-5721-4fac-906b-ce4696b696f1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'To list all available users and their privileges, you will find a command in
    the `Informational` section of shell help, that is:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A role is an access permission given to a user. The default role in that list
    is `postgres`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command lists roles (users) with their attributes (what a role
    is allowed to do) and other options. For adding a new user, we just type this `psql` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This creates a new user with the name `naren` and the password `passme123.`Now,
    give the permission to the user to create databases and further roles, using the
    following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to delete a user, just use the `DROP` command in the same context:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Don't try to change the password for the default `postgres` user.It is intended
    to be a sudo account, and should not be kept as a normal user. Instead, create
    a role and give require permissions for it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how to create a role. Let us see a few more CRUD commands, which
    are really SQL commands that we see in other relational databases too. Take a
    look at the following table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **SQL command** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| Create database |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| Create table |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '| Insert into table |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| Update table |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '| Delete from table |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see from Go how we can talk to PostgreSQL and try to do the preceding
    operations using a simple example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: pq, a pure PostgreSQL database driver for Go
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters when we dealt with SQLite3, we used an external library
    called `go-sqlite3`.In the same way, a database driver library is available to
    bridge both Go and PostgreSQL. That library is called `pq`.We can install that
    library using the command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After getting this library, we need to use it in a similar way to SQLite3\.
    The API will be in line to the `database/sql`package of Go. In order to create
    a new table, we should initialize the DB. To create a new database, just type
    this command from the `psql` shell, as shown in the following command; it is a
    one-time thing:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will write a small code illustration that explains the usage of the `pq`
    driver. Create a directory called `models` in your `$GOPATH`. Here, my `GOPATH`
    is `/home/naren/workspace/`.Similar to all the previous examples in the former
    chapters, we will create our packages and application sources in the `src/` directory:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, add a file called `web_urls.go`.This file is going to have the table creation
    logic:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are importing the `pq` library here. We are using the `sql.Open`function
    to start a new database connection pool. If you observe the connection string,
    it consists of multiple parts. Take a look at the following diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5cf7c9a-a38f-4642-a72b-54de1f5c7c41.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'The connection string should consist of the database type, the `username:password`
    pair, the database server IP, and the sslmode settings. We are then creating a
    table called `web_url`. All the error handlers are there to specify if something
    goes wrong. The `InitDB` function returns the database connection object to whatever
    program imports the function. Let us write the main program to use this package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This program imports the `models` package and uses the `InitDB`function from
    it. We are just printing that database connection, which will be an address. If
    you run the program, you will see the address of the object got printed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This creates a `web_url` tablein the `mydb` database.We can crosscheck that
    by entering into the `psql` shell and typing:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It connects the user to `mydb` database and lists all available tables, as
    shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In PostgreSQL, the AUTO INCREMENT type needs to be replaced by SERIAL while
    providing a schema for a table creation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a URL shortening service using Postgres and pq
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us write the URL shortening service to explain all the concepts we discussed
    in the preceding section. Before that, let us design a package that implements
    the Base62 algorithm with encoding/decoding functions. The URL shortening technique
    needs the Base62 algorithm to convert a long URL to short, and vice versa. We
    then write a solid example to show how this encoding works. Create a directory
    called `base62`in the `GOPATH`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, add a file called `encodeutils.go`, which houses our encode and decode
    functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Base62 algorithm
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw how the Base62 algorithm works in the previous chapters. Here is the
    solid implementation of that algorithm. The logic is purely mathematical and can
    be found everywhere on the web. Take a look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding program, we defined two functions called `ToBase62` and `ToBase10`.The
    first one takes an integer and generates a `base62` string, and the latter one
    reverses the effect; that is, it takes a `base62` string and gives the original
    number. In order to illustrate this, let us create a simple program that uses
    both the functions to show encoding/decoding:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following content to it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we are using the functions from the `base62` packageand trying to see
    the output. If we run this program (from `$GOPATH/src/github.com/narenaryan`)
    using the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It prints:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`base62` encoding of `100` is `1C`. This is because the index 100 shrunk to
    `1C` in our `base62` logic:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The original number will be used to map the character in this base string.
    Then, the number is divided by 62 to find out the next characters. The beauty
    of this algorithm is creating a unique, shorter string for every given number.
    We use this technique to pass a database ID into the `ToBase62` algorithm and
    get a shorter string out. Whenever a URL shortening request comes to our server,
    it should perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Store the URL in the database and get the ID of that record inserted.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass this ID to the client as the API response.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever a client loads the shortened URL, it hits our API server.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API server then converts the short URL back to the database ID and fetches
    the record from the original URL.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the client can use this URL to redirect to the original site.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to write a Go project here that implements the preceding steps.
    Let us compose the program. I am creating a directory structure for our project.
    We take files from the preceding illustrations for handling encoding/decoding
    `base62` and also for database logic. The directory structure looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Copy this directory to `$GOPATH/src/github.com/narenaryan`. Once again, a small
    caution. Replace `narenaryan` with your username. Copy `encodeutils.go`and `models.go`from
    the preceding examples. Then, start writing the main program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, we imported the `postgres` library and other necessary libraries. We
    imported our database session from the models. Next, we imported our encode/decode
    base62 algorithms to implement our logic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `DBClient` is needed in order to pass the database driver between various
    functions. The record is the structure that resembles the record that gets inserted
    into the database. We defined two functions in our code called  **`GenerateShortURL`**
    and `GetOriginalURL` for adding the URL to the database and then fetching it back
    from DB respectively. As we already explained the internal technique of URL shortening,
    the client that is using this service will get the necessary response back. Let
    us run the program and see the output before jumping into further details:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If your `$GOPATH/bin` is already in the system `PATH` variable, we can first
    install the binary and run it like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then just the program name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is a best practice to install the binary because it is available systemwide.
    But for smaller programs, we can run `main.go` by visiting the directory of the
    program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it runs the HTTP server and starts collecting requests for the URL shortening
    service. Open the console and type these CURL commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It returns the shortened string:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The encoded string is just `"1"`. Base62 algorithms start allocating shorter
    strings starting from one to a combination of alphanumeric letters. Now, if we
    need to retrieve the original URL we can perform a `GET` request:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It returns the following JSON:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, the service can use this result to redirect the user to the original URL
    (site). Here, the generated string doesn't depend on the length of the URL because
    only the database ID is the criteria for encoding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The `RETURNING` keyword needs to be added to the `INSERT` SQL command in PostgreSQL
    to fetch the last inserted database ID. This is not the case with MySQL or SQLite3
    `INSERT INTO web_url( ) VALUES($1) RETURNING id, record.URL`. This DB query returns
    the last inserted record's ID. If we drop that `RETURNING` keyword, the query
    returns nothing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the JSON store in PostgreSQL
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PostgreSQL >9.2** has a prominent feature 9.2" dbid="254735" called the JSON
    store. PostgreSQL introduced a new data type for storing the JSON data. PostgreSQL
    allows users to insert a `jsonb` field type,which holds the JSON string. It is
    quite useful in modeling the real-world data that has to be more flexible with
    the structure. PostgreSQL draws the best of both worlds by allowing us to store
    JSON strings as well as relational types.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will try to realize a few of the JSON models that we defined
    for e-commerce websites in the previous chapters. But here, we will use the JSON
    field to store and retrieve items in PostgreSQL. For accessing PostgreSQL's JSON
    store, the normal `pq` library is very tedious. So, in order to handle that better,
    we can use an **Object Relational Mapper** (**ORM**) called **GORM**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: GORM, a powerful ORM for Go
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This ORM has the API for all operations that can be done in the `database/sql`package.
    We can install GORM using this command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For full documentation about this ORM, visit, [http://jinzhu.me/gorm/](http://jinzhu.me/gorm/).
    Let us write a program that implements user and order type JSON models. A user
    can place an order. We will use the models that we defined in the previous chapter.
    We can create a new directory called `jsonstore` in `$GOPATH/src/github.com/narenaryan` and
    create a new directory for our model in it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, edit the `models.go` file to this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This looks similar to the model we defined earlier in this chapter. Here, a
    lot of things are new for us. Every model (table) we create should be represented
    as a struct in GORM. That is the reason we created two structs, `User` and `Order`.
    The first line should be `gorm.Model`.The other fields are the fields of the table.
    By default, an incrementing ID will be created. In the previous model for the
    URL shortener, we manually checked the existence of table before operating on
    it. But here, there is a function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function creates the tables for structs passed as parameters. It makes
    sure that if tables exist already, it skips creation. If you observe carefully,
    we added a function for those structs, `TableName`.By default, all the table names
    that GORM creates are plural names (`users`is created for `User`).In order to
    force it to create the given names, we need to override that function. One more
    interesting thing is, in the structs, we used a field called `Data`. That is of
    type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Yes, it is a `jsonb` type string. We, for now, add its type as `string.PostgreSQL`
    and GORM takes care of handling it. We are then returning the database connection
    to whoever imports the `models` package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the e-commerce REST API
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before jumping in, let us design the API specification table, which shows the
    REST API signatures for various URL endpoints. Refer to the following table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **Method** | **Description** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user/id` | `GET` | Get a user using ID |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user` | `POST` | Create a new user |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user?first_name=NAME` | `GET` | Get all users by the given first name
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `/v1/order/id` | `GET` | Get an order with the given ID |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `/v1/order` | `POST` | Create a new order |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: 'Now we come to the main program; let us add one more file to our `jsonstore`project.
    In this program, we will try to implement the first three endpoints. We suggest
    the implementation of the remaining two endpoints as an assignment for the reader.
    Take a look at the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The program structure follows the same style as all the programs we have seen
    until now. We use Gorilla Mux as our HTTP router and import the database driver
    into our program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are three important aspects here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We replaced the traditional driver with the GORM driver
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used GORM functions for CRUD operations
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We inserted JSON into PostgreSQL and retrieved results in the JSON field
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us explain all the elements in detail. First, we imported all the necessary
    packages. The interesting ones are:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'GORM internally uses the `database/sql`package to some extent. We imported
    models from the package we created in the preceding code. Next, we created three
    functions, implementing the first three API specifications. They are `GetUsersByFirstName`,60;`GetUser`,
    and `PostUser`. Each function is inheriting the database driver and passed as
    the handler functions for the URL endpoints in the `main` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, if we enter the first function, which is simple, these statements will
    grab our attention:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding statement tells the DB to fetch the first record from the database
    with the given second parameter `ID`. It fills the data returned to the `user`
    struct. We are using `UserResponse` instead of the `User` struct in `GetUser`because
    `User` consists of the data field, which is a string. But, in order to return
    complete and proper JSON to the client, we need to convert the data into a proper
    struct and then marshal it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we are creating an empty interface that can hold any JSON data. When
    we call the firstfunction using the driver, the user struct has a data field,
    which is a string. We need to convert that string to a struct and then send it
    along with other details in `UserResponse`. Now let us see this in action. Run
    the program using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And make a few CURL commands to see the API response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Create user:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It returns the inserted record in the DB:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, if we `GET` the details of the inserted record:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It returns all the details about the user:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Insert one more record for checking the first name API:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This inserts our second record. Let us test our third API, `GetUsersByFirstName`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This returns all the users with the given first name:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The core motto of this project is to show how JSON can be stored and retrieved
    out of PostgreSQL. The special thing here is that we queried on the JSON field
    instead of the normal fields in the `User` table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, PostgreSQL stores its users in a table called user. If you want to
    create a new user table, create it using `"user"` (double quotes). Even while
    retrieving use double quotes. Otherwise, the DB will fetch internal user details:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM "user"; // Correct way`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM user; // Wrong way. It fetches database users `'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our journey through PostgreSQL. There is a lot more to explore
    in Postgres. It brings the best of both worlds by allowing us to store relational
    as well as JSON data in the same table.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by installing PostgreSQL. We introduced
    PostgreSQL formally and tried to see all possible SQL queries for CRUD operations.
    We then saw how to add users and databases in PostgreSQL. We then installed and
    explained `pq`, a Postgres driver for the Go language. We explained how the driver
    API performs raw SQL queries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Then came the implementation part of the URL shortening service; that REST service
    takes the original URL and returns a shortened string. It also takes the shortened
    URL and returns the original URL. We wrote a sample program to illustrate the
    Base62 algorithm that powers our service. We leveraged this algorithm in our service
    next and created a REST API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: GORM is a well-known object-relational mapper for Go. Using an ORM, one can
    easily manage the database operations. GORM provides a few useful functions, such
    as `AutoMigrate` (create a table if one doesn't exist), for writing intuitive
    Go code over the traditional `database/sql` driver.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL also allows JSON storage (called the JSON store) past version 9.2\.
    It allows developers to get the benefits of relational databases with the JSON
    format. We can create indexes on JSON fields, query on JSON fields, and so on.
    We implemented a REST API for the e-commerce model we defined in the previous
    chapters using GORM. PostgreSQL is a well established, open-source relational
    database that can suffice our enterprise needs. The driver support for Go is exceptional
    with `pq`and `gorm`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL还允许在9.2版本之后存储JSON（称为JSON存储）。它允许开发人员以JSON格式获得关系数据库的好处。我们可以在JSON字段上创建索引，对JSON字段进行查询等。我们使用GORM为我们在前几章中定义的电子商务模型实现了REST
    API。PostgreSQL是一个成熟的、开源的关系数据库，可以满足我们的企业需求。Go语言的驱动程序支持非常出色，包括`pq`和`gorm`。
