- en: Working with PostgreSQL, JSON, and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at SQL in the big picture. In previous
    chapters, we discussed SQLite3, which is a small database for quick prototyping.
    But when it comes to a production grade application, people prefer MySQL or PostgreSQL.
    Both are well proven in the web application space. First, we will discuss the
    internals of PostgreSQL and then move on to writing database models in Go. We
    will then try to realize the URL shortening service with a solid example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the PostgreSQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PostgreSQL and creating users and databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about `pq`, a database driver in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a URL shortening service with PostgreSQL and a Base62 algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the JSON store in PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `gorm`, a powerful ORM for Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of an e-commerce REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7).
    In the previous chapter, we discussed protocol buffers and GRPC. But here, we
    come back to the REST API with JSON and see how PostgreSQL supplements JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PostgreSQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL is an open-source database that can be installed on multiple platforms.
    On Ubuntu, it can be installed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the repo to the package list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the package list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the database on an Ubuntu machine and starts a server on port
    `5432`.Now, in order to enter the database shell, use these commands. PostgreSQL
    creates a default user called `postgres` to log in. Take a look at the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the user has access to the database. Launch the PostgreSQL shell using
    the `psql` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that PostgreSQL follows a different approach for entering into the
    shell compared to other similar databases such as MySQL or SQLite3\. On Windows,
    the installation is done by clicking the binary installer file. It is a GUI-based
    installation where the port and password for superuser should be supplied. Once
    the database is installed, we can check that using the **pgAdmin3** tool. The
    macOS X setup is similar to Ubuntu, except the installation is done through Homebrew.
    Take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And then make the database server run even when the system is rebooted by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, the PostgreSQL server starts running and is available to store and retrieve
    data on macOS X.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users and databases in PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we should know how to create a new user and database. For this, we are
    going to use Ubuntu/Mac as the general example. We do this in a shell called the `psql` shell.
    We can see all available commands in `psql` using the `\?`  command. In order
    to enter into `psql`, first change to the `postgres` user. On Ubuntu, you can
    do that using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it turns us into a user called `postgres`. Then, launch the `psql` shell
    using the `psql` command. If you type `\?` in there, you see the output of all
    available commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a59458f4-5721-4fac-906b-ce4696b696f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To list all available users and their privileges, you will find a command in
    the `Informational` section of shell help, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A role is an access permission given to a user. The default role in that list
    is `postgres`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command lists roles (users) with their attributes (what a role
    is allowed to do) and other options. For adding a new user, we just type this `psql` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new user with the name `naren` and the password `passme123.`Now,
    give the permission to the user to create databases and further roles, using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to delete a user, just use the `DROP` command in the same context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Don't try to change the password for the default `postgres` user.It is intended
    to be a sudo account, and should not be kept as a normal user. Instead, create
    a role and give require permissions for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know how to create a role. Let us see a few more CRUD commands, which
    are really SQL commands that we see in other relational databases too. Take a
    look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **SQL command** |'
  prefs: []
  type: TYPE_TB
- en: '| Create database |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Create table |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Insert into table |'
  prefs: []
  type: TYPE_TB
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Update table |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Delete from table |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see from Go how we can talk to PostgreSQL and try to do the preceding
    operations using a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: pq, a pure PostgreSQL database driver for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters when we dealt with SQLite3, we used an external library
    called `go-sqlite3`.In the same way, a database driver library is available to
    bridge both Go and PostgreSQL. That library is called `pq`.We can install that
    library using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting this library, we need to use it in a similar way to SQLite3\.
    The API will be in line to the `database/sql`package of Go. In order to create
    a new table, we should initialize the DB. To create a new database, just type
    this command from the `psql` shell, as shown in the following command; it is a
    one-time thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write a small code illustration that explains the usage of the `pq`
    driver. Create a directory called `models` in your `$GOPATH`. Here, my `GOPATH`
    is `/home/naren/workspace/`.Similar to all the previous examples in the former
    chapters, we will create our packages and application sources in the `src/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a file called `web_urls.go`.This file is going to have the table creation
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing the `pq` library here. We are using the `sql.Open`function
    to start a new database connection pool. If you observe the connection string,
    it consists of multiple parts. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5cf7c9a-a38f-4642-a72b-54de1f5c7c41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The connection string should consist of the database type, the `username:password`
    pair, the database server IP, and the sslmode settings. We are then creating a
    table called `web_url`. All the error handlers are there to specify if something
    goes wrong. The `InitDB` function returns the database connection object to whatever
    program imports the function. Let us write the main program to use this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This program imports the `models` package and uses the `InitDB`function from
    it. We are just printing that database connection, which will be an address. If
    you run the program, you will see the address of the object got printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a `web_url` tablein the `mydb` database.We can crosscheck that
    by entering into the `psql` shell and typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It connects the user to `mydb` database and lists all available tables, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In PostgreSQL, the AUTO INCREMENT type needs to be replaced by SERIAL while
    providing a schema for a table creation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a URL shortening service using Postgres and pq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us write the URL shortening service to explain all the concepts we discussed
    in the preceding section. Before that, let us design a package that implements
    the Base62 algorithm with encoding/decoding functions. The URL shortening technique
    needs the Base62 algorithm to convert a long URL to short, and vice versa. We
    then write a solid example to show how this encoding works. Create a directory
    called `base62`in the `GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, add a file called `encodeutils.go`, which houses our encode and decode
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Base62 algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw how the Base62 algorithm works in the previous chapters. Here is the
    solid implementation of that algorithm. The logic is purely mathematical and can
    be found everywhere on the web. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, we defined two functions called `ToBase62` and `ToBase10`.The
    first one takes an integer and generates a `base62` string, and the latter one
    reverses the effect; that is, it takes a `base62` string and gives the original
    number. In order to illustrate this, let us create a simple program that uses
    both the functions to show encoding/decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the functions from the `base62` packageand trying to see
    the output. If we run this program (from `$GOPATH/src/github.com/narenaryan`)
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`base62` encoding of `100` is `1C`. This is because the index 100 shrunk to
    `1C` in our `base62` logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The original number will be used to map the character in this base string.
    Then, the number is divided by 62 to find out the next characters. The beauty
    of this algorithm is creating a unique, shorter string for every given number.
    We use this technique to pass a database ID into the `ToBase62` algorithm and
    get a shorter string out. Whenever a URL shortening request comes to our server,
    it should perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Store the URL in the database and get the ID of that record inserted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass this ID to the client as the API response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever a client loads the shortened URL, it hits our API server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API server then converts the short URL back to the database ID and fetches
    the record from the original URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the client can use this URL to redirect to the original site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to write a Go project here that implements the preceding steps.
    Let us compose the program. I am creating a directory structure for our project.
    We take files from the preceding illustrations for handling encoding/decoding
    `base62` and also for database logic. The directory structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy this directory to `$GOPATH/src/github.com/narenaryan`. Once again, a small
    caution. Replace `narenaryan` with your username. Copy `encodeutils.go`and `models.go`from
    the preceding examples. Then, start writing the main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we imported the `postgres` library and other necessary libraries. We
    imported our database session from the models. Next, we imported our encode/decode
    base62 algorithms to implement our logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DBClient` is needed in order to pass the database driver between various
    functions. The record is the structure that resembles the record that gets inserted
    into the database. We defined two functions in our code called  **`GenerateShortURL`**
    and `GetOriginalURL` for adding the URL to the database and then fetching it back
    from DB respectively. As we already explained the internal technique of URL shortening,
    the client that is using this service will get the necessary response back. Let
    us run the program and see the output before jumping into further details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If your `$GOPATH/bin` is already in the system `PATH` variable, we can first
    install the binary and run it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And then just the program name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is a best practice to install the binary because it is available systemwide.
    But for smaller programs, we can run `main.go` by visiting the directory of the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it runs the HTTP server and starts collecting requests for the URL shortening
    service. Open the console and type these CURL commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the shortened string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The encoded string is just `"1"`. Base62 algorithms start allocating shorter
    strings starting from one to a combination of alphanumeric letters. Now, if we
    need to retrieve the original URL we can perform a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, the service can use this result to redirect the user to the original URL
    (site). Here, the generated string doesn't depend on the length of the URL because
    only the database ID is the criteria for encoding.
  prefs: []
  type: TYPE_NORMAL
- en: The `RETURNING` keyword needs to be added to the `INSERT` SQL command in PostgreSQL
    to fetch the last inserted database ID. This is not the case with MySQL or SQLite3
    `INSERT INTO web_url( ) VALUES($1) RETURNING id, record.URL`. This DB query returns
    the last inserted record's ID. If we drop that `RETURNING` keyword, the query
    returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the JSON store in PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PostgreSQL >9.2** has a prominent feature 9.2" dbid="254735" called the JSON
    store. PostgreSQL introduced a new data type for storing the JSON data. PostgreSQL
    allows users to insert a `jsonb` field type,which holds the JSON string. It is
    quite useful in modeling the real-world data that has to be more flexible with
    the structure. PostgreSQL draws the best of both worlds by allowing us to store
    JSON strings as well as relational types.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will try to realize a few of the JSON models that we defined
    for e-commerce websites in the previous chapters. But here, we will use the JSON
    field to store and retrieve items in PostgreSQL. For accessing PostgreSQL's JSON
    store, the normal `pq` library is very tedious. So, in order to handle that better,
    we can use an **Object Relational Mapper** (**ORM**) called **GORM**.
  prefs: []
  type: TYPE_NORMAL
- en: GORM, a powerful ORM for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This ORM has the API for all operations that can be done in the `database/sql`package.
    We can install GORM using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For full documentation about this ORM, visit, [http://jinzhu.me/gorm/](http://jinzhu.me/gorm/).
    Let us write a program that implements user and order type JSON models. A user
    can place an order. We will use the models that we defined in the previous chapter.
    We can create a new directory called `jsonstore` in `$GOPATH/src/github.com/narenaryan` and
    create a new directory for our model in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `models.go` file to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks similar to the model we defined earlier in this chapter. Here, a
    lot of things are new for us. Every model (table) we create should be represented
    as a struct in GORM. That is the reason we created two structs, `User` and `Order`.
    The first line should be `gorm.Model`.The other fields are the fields of the table.
    By default, an incrementing ID will be created. In the previous model for the
    URL shortener, we manually checked the existence of table before operating on
    it. But here, there is a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates the tables for structs passed as parameters. It makes
    sure that if tables exist already, it skips creation. If you observe carefully,
    we added a function for those structs, `TableName`.By default, all the table names
    that GORM creates are plural names (`users`is created for `User`).In order to
    force it to create the given names, we need to override that function. One more
    interesting thing is, in the structs, we used a field called `Data`. That is of
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it is a `jsonb` type string. We, for now, add its type as `string.PostgreSQL`
    and GORM takes care of handling it. We are then returning the database connection
    to whoever imports the `models` package.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the e-commerce REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before jumping in, let us design the API specification table, which shows the
    REST API signatures for various URL endpoints. Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoint** | **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user/id` | `GET` | Get a user using ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user` | `POST` | Create a new user |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/user?first_name=NAME` | `GET` | Get all users by the given first name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/order/id` | `GET` | Get an order with the given ID |'
  prefs: []
  type: TYPE_TB
- en: '| `/v1/order` | `POST` | Create a new order |'
  prefs: []
  type: TYPE_TB
- en: 'Now we come to the main program; let us add one more file to our `jsonstore`project.
    In this program, we will try to implement the first three endpoints. We suggest
    the implementation of the remaining two endpoints as an assignment for the reader.
    Take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The program structure follows the same style as all the programs we have seen
    until now. We use Gorilla Mux as our HTTP router and import the database driver
    into our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important aspects here:'
  prefs: []
  type: TYPE_NORMAL
- en: We replaced the traditional driver with the GORM driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used GORM functions for CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We inserted JSON into PostgreSQL and retrieved results in the JSON field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us explain all the elements in detail. First, we imported all the necessary
    packages. The interesting ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'GORM internally uses the `database/sql`package to some extent. We imported
    models from the package we created in the preceding code. Next, we created three
    functions, implementing the first three API specifications. They are `GetUsersByFirstName`,60;`GetUser`,
    and `PostUser`. Each function is inheriting the database driver and passed as
    the handler functions for the URL endpoints in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we enter the first function, which is simple, these statements will
    grab our attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement tells the DB to fetch the first record from the database
    with the given second parameter `ID`. It fills the data returned to the `user`
    struct. We are using `UserResponse` instead of the `User` struct in `GetUser`because
    `User` consists of the data field, which is a string. But, in order to return
    complete and proper JSON to the client, we need to convert the data into a proper
    struct and then marshal it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating an empty interface that can hold any JSON data. When
    we call the firstfunction using the driver, the user struct has a data field,
    which is a string. We need to convert that string to a struct and then send it
    along with other details in `UserResponse`. Now let us see this in action. Run
    the program using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And make a few CURL commands to see the API response:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the inserted record in the DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we `GET` the details of the inserted record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns all the details about the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert one more record for checking the first name API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This inserts our second record. Let us test our third API, `GetUsersByFirstName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns all the users with the given first name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The core motto of this project is to show how JSON can be stored and retrieved
    out of PostgreSQL. The special thing here is that we queried on the JSON field
    instead of the normal fields in the `User` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, PostgreSQL stores its users in a table called user. If you want to
    create a new user table, create it using `"user"` (double quotes). Even while
    retrieving use double quotes. Otherwise, the DB will fetch internal user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM "user"; // Correct way`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM user; // Wrong way. It fetches database users `'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our journey through PostgreSQL. There is a lot more to explore
    in Postgres. It brings the best of both worlds by allowing us to store relational
    as well as JSON data in the same table.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by installing PostgreSQL. We introduced
    PostgreSQL formally and tried to see all possible SQL queries for CRUD operations.
    We then saw how to add users and databases in PostgreSQL. We then installed and
    explained `pq`, a Postgres driver for the Go language. We explained how the driver
    API performs raw SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Then came the implementation part of the URL shortening service; that REST service
    takes the original URL and returns a shortened string. It also takes the shortened
    URL and returns the original URL. We wrote a sample program to illustrate the
    Base62 algorithm that powers our service. We leveraged this algorithm in our service
    next and created a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: GORM is a well-known object-relational mapper for Go. Using an ORM, one can
    easily manage the database operations. GORM provides a few useful functions, such
    as `AutoMigrate` (create a table if one doesn't exist), for writing intuitive
    Go code over the traditional `database/sql` driver.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL also allows JSON storage (called the JSON store) past version 9.2\.
    It allows developers to get the benefits of relational databases with the JSON
    format. We can create indexes on JSON fields, query on JSON fields, and so on.
    We implemented a REST API for the e-commerce model we defined in the previous
    chapters using GORM. PostgreSQL is a well established, open-source relational
    database that can suffice our enterprise needs. The driver support for Go is exceptional
    with `pq`and `gorm`.
  prefs: []
  type: TYPE_NORMAL
