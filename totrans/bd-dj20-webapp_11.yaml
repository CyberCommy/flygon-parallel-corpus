- en: The Task of Sending Emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our models and views, we will need to make Mail Ape send emails.
    We'll have Mail Ape send two kinds of emails, subscriber confirmation emails and
    mailing list messages. We'll track mailing list message success by creating a
    new model called `SubscriberMessage` to track whether a message was successfully
    sent to an address stored in a `Subscriber` model instance. Since sending emails
    to a lot of `Subscriber` model instances can take a lot of time, we'll use Celery
    to send emails as tasks outside the regular Django request/response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Django's template system to generate the HTML body of our emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send emails that include both HTML and plain text using Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Celery to execute asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent our code from sending actual emails during testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by creating some common resources that we'll use to send dynamic
    emails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating common resources for emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a base HTML email template and a `Context` object
    for rendering email templates. We want to create a base HTML template for our
    emails so that we can avoid repeating boilerplate HTML. We also want to make sure
    that every email we send includes an unsubscribe link to be good email citizens.
    Our `EmailTemplateContext` class will consistently provide the common variables
    that our templates need.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a base HTML email template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the base HTML email template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create our base email HTML template in `django/mailinglist/templates/mailinglist/email/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding template looks like a much simpler version of `base.html`, except
    it has only one block. Email templates can extend `email/base.html` and override
    the body block to avoid the boilerplate HTML. Despite the filenames being the
    same (`base.html`), Django won't confuse the two. Templates are identified by
    their template paths, not just filenames.
  prefs: []
  type: TYPE_NORMAL
- en: Our base template also expects the `unsubscription_link` variable to always
    exist. This will let users unsubscribe if they don't want to continue receiving
    emails.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that our templates always have the `unsubscription_link` variable,
    we'll create a `Context` that makes sure to always provide it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating EmailTemplateContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've discussed before (refer to [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*), to render a template, we will need to provide Django with a
    `Context` object that has the variables the template references. When writing
    class-based views, we only have to provide a dict in the `get_context_data()` method
    and Django takes care of everything for us. However, when we want to render a
    template ourselves, we'll have to instantiate the `Context` class ourselves. To
    ensure that all our email template-rendering code provides the same minimum information,
    we'll create a custom template `Context`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our `EmailTemplateContext` class in `django/mailinglist/emails.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `EmailTemplateContext` is made up of the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make_link()`: This joins a URL''s path with our project''s `MAILING_LIST_LINK_DOMAIN`
    setting. The `make_link` is necessary because Django''s `reverse()` function doesn''t
    include a domain. A Django project can be hosted on multiple different domains.
    We''ll discuss the `MAILING_LIST_LINK_DOMAIN` value more in the *Configuring email
    settings* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__init__()`: This overrides the `Context.__init__(...)` method to give us
    a chance to add the results of the `common_context()` method to the value of the `dict_` parameter.
    We''re careful to let the data received by the argument overwrite the data we
    generate in `common_context`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`common_context()`: This returns a dictionary that provides the variables we
    want available to all `EmailTemplateContext` objects. We always want to have `subscriber`,
    `mailing_list`, and `unsubscribtion_link` available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use both these resources in our next section, where we'll send confirmation
    emails to new `Subscriber` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Sending confirmation emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll send emails to new `Subscriber`s to let them confirm
    their subscription to a `MailingList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Django's email configuration settings to our `settings.py`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function to send emails using Django's `send_mail()` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and render HTML and text templates for the body of our emails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `Subscriber.save()` to send the emails when a new `Subscriber` is created
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by updating configuration with our mail server's settings.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring email settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to send emails, we need to configure Django to talk to a
    **Simple Mail Transfer Protocol** (**SMTP**) server. In development and while
    learning, you can probably use the same SMTP server that your email client uses.
    Using such a server for sending large amounts of production email is likely a
    violation of your email provider's Terms of Service and can lead to account suspension.
    Be careful of which accounts you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our settings in `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code sample, I''ve used a lot of instances of `example.com`,
    which you should replace with the correct domain for your SMTP host and your domain.
    Let''s take a closer look at the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EMAIL_HOST`: This is the address of the SMTP sever we''re using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_USER`: The username used to authenticate to the SMTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_PORT`: The port to connect to the SMTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_USE_TLS`: This is optional and defaults to `False`. Use it if you''re
    connecting over TLS to the SMTP server. If you''re using SSL, then use the `EMAIL_USE_SSL`
    setting. The SSL and TLS settings are mutually exclusive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_PASSWORD`: The password for the host. In our case, we will expect
    the password in an environment variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAILING_LIST_FROM_EMAIL`: This is a custom setting we''re using to set who
    set the `FROM` header on the emails we send.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAILING_LIST_LINK_DOMAIN`: This is the domain to prefix all email template
    links with. We saw this setting used in our `EmailTemplateContext` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's write our create function to send the confirmation emails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the send email confirmation function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a function that will actually create and send confirmation
    emails to our `Subscriber`s. The `email` module will contain all our email-related
    code (we've already created the `EmailTemplateContext` class there).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `send_confirmation_email()` function will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Context` for rendering the email bodies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the subject for the email
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the HTML and text email body
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the email using the `send_mail()` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create that function in `django/mailinglist/emails.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmailTemplateContext()`: This instantiates the `Context` class we created
    earlier. We provide it with a `Subscriber` instance and a `dict`, which contains
    the confirmation link. The `confirmation_link` variable will be used by our templates,
    which we''ll create in the next two sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`engines[''django''].engine`: This references the Django Template engine. The
    engine knows how to find `Template`s using the configuration settings in the `TEMPLATES`
    setting of `settings.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dt_engine.get_template()`: This returns a template object. We provide the
    name of the template as an argument to the `get_template()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text_body_template.render()`: This renders the template (using the context
    we created previously) into a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we send the email using the `send_email()` function. The `send_email()` function takes
    the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subject=subject`: The subject of the email message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message=text_body`: The text version of the email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_email=settings.MAILING_LIST_FROM_EMAIL`: The sender''s email address.
    If we don''t provide a `from_email` argument, then Django will use the `DEFAULT_FROM_EMAIL`
    setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recipient_list=(subscriber.email,)`: A list (or tuple) of recipient email
    addresses. This must be a collection, even if you''re only sending to one recipient.
    If you include multiple recipients, they will be able to see each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html_message=html_body`: The HTML version of the email. This argument is optional,
    as we don''t have to provide an HTML body. If we provide an HTML body, then Django
    will send an email that includes both the HTML and text body. Email clients will
    choose to display the HTML or the plain text version of the email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our code for sending the emails, let's make our email body
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HTML confirmation email template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make the HTML subscription email confirmation template. We''ll create
    the template in `django/mailinglist/templates/mailinglist/email_templates/confirmation.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our template looks just like an HTML web page template, but it will be used
    in an email. Just like a normal Django template, we're extending a base template
    and filling out a block. In our case, the template we're extending is the `email/base.html`
    template we created at the start of this chapter. Also, note how we're using variables
    that we provided in our `send_confirmation_email()` function (for example, `confirmation_link`)
    and our `EmailTemplateContext` (for example, `mailing_list`).
  prefs: []
  type: TYPE_NORMAL
- en: Emails can include HTML but are not always rendered by web browsers. Notably,
    some versions of Microsoft Outlook use the Microsoft Word HTML renderer to render
    emails. Even Gmail, which runs in a browser, manipulates the HTML it receives
    before rendering it. Be careful to test complicated layouts in real email clients.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the plain text version of this template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the text confirmation email template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will create the plain text version of our confirmation email template;
    let''s create it in `django/mailinglist/templates/mailinglist/email_templates/confirm_subscription.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, we're not using any HTML nor extending any base template.
  prefs: []
  type: TYPE_NORMAL
- en: However, we're still referencing variables that we provided in our `send_confirmation_email()`
    (for example, `confirmation_link`) function and our `EmailTemplateContext` class
    (for example, `mailing_list`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the code necessary for sending emails, let's send them
    out when we create a new `Subscriber` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: Sending on new Subscriber creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the final step, we'll take sending confirmation emails to users; we need
    to call our `send_confirmation_email` function. Based on the philosophy of fat
    models, we will call our `send_confirmation_email` function from our `Subscriber`
    model rather than a view. In our case, we will send the email when a new `Subscriber` model
    instance is saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `Subscriber` model to send a confirmation email when a new
    `Subscriber` has been saved. To add this new behavior, we will need to edit `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to add a new behavior when a model is created is to override the
    model''s `save()` method. When overriding `save()`, it is vital that we still
    call the super class''s `save()` method to make sure that the model does save.
    Our new save method does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the current model is a new model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the super class's `save()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends the confirmation email if the model is new
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check if the current model instance is new, we check the `_state` attribute.
    The `_state` attribute is an instance of the `ModelState` class. Generally, attributes
    that begin with an underscore (`_`) are considered private and may change across
    Django releases. However, the `ModelState` class is described in Django's official
    documentation so we can feel more comfortable using it (though we should keep
    an eye on future release notes for changes). If the `self._state.adding` is `True`,
    then the `save()` method is going to insert this model instance as a new row.
    If `self._state.adding` is `True`, then the `save()` method is going to update
    an existing row.
  prefs: []
  type: TYPE_NORMAL
- en: We've also wrapped the call to `emails.send_confirmation_email()` in a `Subscriber`
    method. This will be useful if we ever want to resend a confirmation email. Any
    code that wants to resend a confirmation email will not have to know about the
    `emails` module. The model is the expert on all its operations. This is the heart
    of the fat model philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we've learned more about Django's template system and how to
    send emails. We've learned how to render a template without using one of Django's
    built-in views to render it for us using the Django template engine directly.
    We've used the Django best practice of creating a service module to isolate all
    our email code. Finally, we've also used `send_email()` to send an email with
    a text and HTML body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's use Celery to send these emails after we return a response to our
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Using Celery to send emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we build increasingly complicated applications, we often want to perform
    operations without forcing the user to wait on us to return them an HTTP response.
    Django works well with Celery, a popular Python distributed task queue, to accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Celery is a library to *queue* *tasks* in *brokers* to be processed by Celery
    *workers*. Let''s take a closer look at some of these terms:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Celery task** encapsulates a callable we want executed asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Celery** **queue** is a list of tasks in a first in, first out order stored
    in a broker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Celery broker** is a server that provides fast and efficient storage of
    queues. Popular brokers include RabbitMQ, Redis, and AWS SQS. Celery has different
    levels of support for different brokers. We will use Redis as our broker in development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Celery workers** are separate processes that check queues for tasks to execute
    and execute them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we will be doing the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Celery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Celery to work with Django
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Celery queue a send confirmation email task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a Celery worker to send our emails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's start by installing Celery.
  prefs: []
  type: TYPE_NORMAL
- en: Installing celery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Celery, we''ll update our `requirements.txt` file with these new
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will install three new packages and their dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`celery`: Installs the main Celery package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`celery[redis]`: Installs the dependencies we need to use Redis as our broker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-celery-results`: Lets us store the results of executed tasks in our
    Django database; this is just one way of storing and logging Celery''s results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s install our new packages using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have Celery installed, let's configure Mail Ape to use Celery.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Celery settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure Celery, we will need to make two sets of changes. First, we'll
    update the Django config to use Celery. Second, we'll create a celery configuration
    file that our worker will use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by updating `django/config/settings.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at these new settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`django_celery_results`: This is a Celery extension that we installed as a
    Django app to let us store the results of our Celery tasks in the Django DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CELERY_BROKER_URL`: This is the URL to our Celery broker. In our case, we
    will use a local Redis server in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CELERY_RESULT_BACKEND`: This indicates where to store the results. In our
    case, we will use the Django database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the `django_celery_results` app lets us save results in the database,
    it includes new Django models. For those models to exist in the database, we will
    need to migrate our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's create a configuration file for our Celery worker. The worker will
    need an access to Django and our Celery broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the Celery worker configuration in `django/config/celery.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Celery knows how to work with a Django project out of the box. Here, we configure
    an instance of the Celery library based on our Django configuration. Let''s review
    these settings in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setdefault(''DJANGO_SETTINGS_MODULE'', ...)`: This ensures that our Celery
    worker knows which Django settings module to use if the `DJANGO_SETTINGS_MODULE`
    environment variable is not set for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Celery(''mailape'')`: This instantiates the Celery library for Mail Ape. Most
    Django apps use only one Celery instance, so the `mailape` string is not significant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.config_from_object(''django.conf:settings'', namespace=''CELERY'')`: This
    tells our Celery library to configure itself from the object at `django.conf.settings`.
    The `namespace` argument tells Celery that its settings are prefixed with `CELERY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.autodiscover_tasks()`: This lets us avoid registering tasks by hand. When
    Celery is working with Django, it will check each installed app for a `tasks`
    module. Any tasks in that module will be automatically discovered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's learn more about tasks by creating a task to send confirmation emails.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task to send confirmation emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Celery is configured, let's create a task to send a confirmation email
    to a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: A Celery task is a subclass of `Celery.app.task.Task`. However, most of the
    time when we create Celery tasks, we use Celery's decorators to mark a function
    as a task. In a Django project, it's often simplest to use the `shared_task` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a task, it's useful to think of it like a view. The Django community's
    best practices recommend *thin views*, which means that views should be simple.
    They should not be responsible for complicated tasks, but should delegate that
    work to the model or a service module (for example, our `mailinglist.emails` module).
  prefs: []
  type: TYPE_NORMAL
- en: Keep task functions simple and put all the logic in models or service modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a task to send our confirmation emails in `django/mailinglist/tasks.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few unique things about our `send_confirmation_email_to_subscriber`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@shared_task`: This is a Celery decorator that turns a function into a `Task`.
    A `shared_task` is available to all Celery instances (in most Django cases, there''s
    only one anyway).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def send_confirmation_email_to_subscriber(subscriber_id):`: This is a regular
    function that takes a subscriber ID as an argument. A Celery task can receive
    any pickle-able object (including a Django model). However, if you''re passing
    around something that may be viewed as confidential (for example, an email address),
    you may wish to limit the number of systems that store the data (for example,
    not store it on the broker). In this case, we''re passing our task function an
    ID of the `Subscriber` instead of the full `Subscriber`. The task function then
    queries the database for the related `Subscriber` instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final item of note in this function is that we import the `Subscriber` model
    inside the function instead of at the top of the file. In our case, we will have
    our `Subscriber` model call this task. If we import the `models` module at the
    top of `tasks.py` and import the `tasks` module at the top of `model.py`, then
    we'll have a cyclic import error. In order to prevent that, we import `Subscriber`
    inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's call our task from `Subscriber.send_confirmation_email()`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails to new subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our task, let's update our `Subscriber` to send confirmation
    emails using the task instead of using the `emails` module directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our updated `send_confirmation_email()` method, we will take a look at how
    to call a task asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: A Celery task can be called either synchronously or asynchronously. Using the
    regular `()` operator, we'll call the task synchronously (for example, `tasks.send_confirmation_email_to_subscriber(self.id)`).
    A task that executes synchronously executes like a regular function call.
  prefs: []
  type: TYPE_NORMAL
- en: A Celery task also has the `delay()` method to execute a task asynchronously.
    When a task is told to execute asynchronously, it will queue a message in Celery's
    message broker. The Celery workers will then (eventually) pull the message from
    the broker's queue and execute the task. The result of the task is stored in the
    storage backend (in our case, the Django database).
  prefs: []
  type: TYPE_NORMAL
- en: Calling a task asynchronously returns a `result` object that offers a `get()`
    method. Calling `result.get()` blocks the current thread until the task has finished.
    `result.get()` then returns the result of the task. In our case, our tasks will
    not return anything, so we won't use the `result` function..
  prefs: []
  type: TYPE_NORMAL
- en: '`task.delay(1, a=''b'')` is actually a shortcut for `task.apply_async((1,),
    kwargs={''a'':''b''})`. Most of the time, the shortcut method is what we want.
    If you need a greater degree of control over your tasks execution, `apply_async()`
    is documented in the Celery documentation ([http://docs.celeryproject.org/en/latest/userguide/calling.html](http://docs.celeryproject.org/en/latest/userguide/calling.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can call tasks, let's start a worker to process our queued tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Celery worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting a Celery worker does not require us to write any new code. We can
    start one from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at all the arguments we gave `celery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`worker`: This indicates that we want to start a new worker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-A config.celery`: This is the app, or configuration, we want to use. In our
    case, the app we want is configured in `config.celery`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l info`: This is the log level to output. In this case, we''re using `info`.
    By default, the level is `WARNING`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our worker is now able to process tasks queued by our code in Django. If we
    find we're queueing a lot of tasks, we can just start more `celery worker` processes.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you learned how to use Celery to process tasks asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to set the broker and backend using the `CELERY_BROKER_URL` and
    `CELERY_RESULT_BACKEND` settings in our `settings.py`. We also created a `celery.py`
    file for our celery worker. Then, we used the `@shared_task` decorator to make
    a function a Celery task. With the task available, we learned how to call a Celery
    task with the `.delay()` shortcut method. Finally, we started a Celery worker
    to execute queued tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics, let's use this approach to send messages to our
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to create the `Message` model instances that represent
    messages that our users want to send to their mailing lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send these messages, we will need to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `SubscriberMessage` model to track which messages got sent and when
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `SubscriberMessage` model instance for each confirmed `Subscriber` model
    instance associated with the new `Message` model instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have `SubscriberMessage` model instances send an email to their associated `Subscriber` model
    instance's email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure that even a `MailingList` model instance with lots of related `Subscriber` model
    instances doesn't slow down our website, we will use Celery to build our list
    of `SubscriberMessage` model instances *and* send the emails.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a `SubscriberManager` to help us get a list of confirmed
    `Subscriber` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Getting confirmed subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Django projects use custom model managers to centralize and document `QuerySet` objects
    related to their models. We need a `QuerySet` object to retrieve all the confirmed
    `Subscriber` model instances that belong to a given `MailingList` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/mailinglist/models.py` to add a new `SubscriberManager` class
    that knows how to get confirmed `Subscriber` model instances for a `MailingList` model
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our new `SubscriberManager` object replaces the default manager in `Subscriber.objects`. The
    `SubscriberManager` class offers the `confirmed_subscribers_for_mailing_list()` method
    as well as all the methods of the default manager.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the `SubscriberMessage` model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SubscriberMessage model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will create a `SubscriberMessage` model and manager. The `SubscriberMessage`
    model will let us track whether we successfully sent an email to a `Subscriber` model
    instance. The custom manager will have a method of creating all the `SubscriberMessage` model
    instances that a `Message` model instance needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating our `SubscriberMessage` in `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `SubscriberMessage` model is pretty heavily customized compared to most
    of our other models:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SubsriberMessage` fields connect it to a `Message` and a `Subscriber` let
    it track when it was created, last tried to send an email, and succeeded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberMessage.objects` is a custom manager that we''ll create in the following
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberMessage.save()` works similar to `Subscriber.save()`. It checks
    whether the `SubscriberMessage` is new and whether it calls the `send()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberMessage.send()` queues a task to send the message. We''ll create
    that task later in the *Sending emails to Subscribers* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create a `SubscriberMessageManager` in `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our new manager offers a method of creating `SubscriberMessages` from a `Message`.
    The `create_from_message()` method returns a list of `SubscriberMessage`s each
    created using the `Manager.create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to have a new model available, we will need to create a migration
    and apply it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `SubscriberMessage` model and table, let's update our project
    to automatically create `SubscriberMessage` model instances when a new `Message`
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SubscriberMessages when a message is created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mail Ape is meant to send a message as soon as it is created. For a `Message` model
    instance to become an email in a subscriber's inbox, we will need to build a set
    of `SubscriberMessage` model instances. The best time to build that set of `SubscriberMessage` model
    instances is just after a new `Message` model instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s override `Message.save()` in `django/mailinglist/models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Our new `Message.save()` method follows a similar pattern as before. `Message.save()`
    checks whether the current `Message` is new and whether it then queues the `build_subscriber_messages_for_message` task
    for execution.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Celery to build the set of `SubscriberMessage` model instances asynchronously
    because we don't know how many `Subscriber` model instances are related to our `MailingList`
    model instance. If there are very many related `Subscriber` model instances, then
    it might make our web server unresponsive. Using Celery, our web server will return
    a response as soon as the `Message` model instance is saved. The `SubscriberMessage` model
    instances will be created by an entirely separate process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `build_subscriber_messages_for_message` task in `django/mailinglist/tasks.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed previously, our task doesn't contain much logic in itself. `build_subscriber_messages_for_message`
    lets the `SubscriberMessage` manager encapsulate all the logic of creating the
    `SubscriberMessage` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's write the code for sending emails that contain the `Message` our
    users create.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails to subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final step in this section will be to send an email based on a `SubscriberMessage`.
    Earlier, we had our `SubscriberMessage.save()` method queue a task to send a `Subscriber`
    a `Message`. Now, we'll create that task and update the `emails.py` code to send
    the emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets''s start by updating `django/mailinglist/tasks.py` with a new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This new task follows the same pattern as the previous tasks we''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `shared_task` decorator to turn a regular function into a Celery
    task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We import our model inside our task function to prevent a cyclical import error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We let the `emails` module do the actual work of sending the email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s update the `django/mailinglist/emails.py` file to send emails
    based on a `SubscriberMessage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new function takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the context for the templates using the `EmailTemplateContext` class
    we created earlier
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders the text and HTML versions of the email using the Django Template engine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Records the time of the current sending attempt
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sends the email using Django's `send_mail()` function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `send_mail()` returned that it sent an email, it records the time the message
    was sent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `send_subscriber_message()` function requires us to create HTML and text
    templates to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our HTML email body template in `django/mailinglist/templates/mailinglist/email_templates/subscriber_message.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This template renders the markdown body of the `Message` into HTML. We've used
    the `markdownify` tag library to render markdown into HTML before. We don't need
    HTML boilerplate or to include an unsubscribe link footer because the `email_base.html`
    already does that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must create the text version of the message template in `mailinglist/templates/mailinglist/email_templates/subscriber_message.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This template looks very similar. In this case, we simply output the body as
    un-rendered markdown. Also, we don't have a base template for our text emails,
    so we have to write out the footer with an unsubscribe link manually.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've now updated Mail Ape to send emails to mailing list
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you restart your `celery worker` process(es) any time you change
    your code. `celery worker` does not include an automatic restart like the Django
    `runserver`. If we don't restart the `worker`, then it won't get any updated code
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's make sure that we can run our tests without triggering Celery or
    sending an actual email.
  prefs: []
  type: TYPE_NORMAL
- en: Testing code that uses Celery tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, two of our models will automatically queue Celery tasks when
    they are created. This can create a problem for us when testing our code since
    we may not want to have a Celery broker running when we run our tests. Instead,
    we should use Python's `mock` library to prevent the need for an outside system
    to be running when we run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: One approach we could use is to decorate each test method that uses the `Subscriber`
    or `Message` models with Python's `@patch()` decorator. However, this manual process
    is likely to be error-prone. Let's look at some alternatives instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at two approaches to make mocking out
    Celery tasks easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a mixin to prevent the `send_confirmation_email_to_subscriber` task from
    being queued in any test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Factory to prevent the `send_confirmation_email_to_subscriber` task
    from being queued
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By fixing the same problem in two different ways, you'll get insight into which
    solution works better in which situation. You may find that having both options
    available in a project is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the exact same approaches for patching references to `send_mail`
    to prevent emails being sent out during testing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by using a mixin to apply a patch.
  prefs: []
  type: TYPE_NORMAL
- en: Using a TestCase mixin to patch tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this approach, we will create a mixin that `TestCase` authors can optionally
    use when writing `TestCase`s. We've used mixins in a lot of our Django code to
    override the behavior of class-based views. Now, we'll create a mixin that will
    override the default behavior of `TestCase`s. We will take advantage of each test
    method being preceded by a call to `setUp()` and followed by `tearDown()` to set
    up our patch and mock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our mixin `django/mailinglist/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our mixin''s `setUp()` method does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a patch and saves it as an attribute of our object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the patch and saves the resulting mock object as an attribute of our
    object Access to the mock is important so that we can later assert what it was
    called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the parent class's `setUp()` method so that the `TestCase` is properly
    set up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our mixin''s `tearDown` method also does the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Stops the patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removes a reference to the mock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the parent class's `tearDown` method to complete any other cleanup that
    needs to happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a `TestCase` to test `SubscriberCreation` and take a look at our
    new `MockSendEmailToSubscriberTask` in action. We'll create a test that creates
    a `Subscriber` model instance using its manager's `create()` method. The `create()` call
    will in turn call `save()` on the new `Subscriber` instances. The `Subscriber.save()` method
    should then queue a `send_confirmation_email` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add our test to `django/mailinglist/tests.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our test asserts that the mock we created in our mixin has been called once.
    This gives us confidence that when we create a new `Subscriber`, we will queue
    the correct task.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at how we can solve this problem using Factory Boy factories.
  prefs: []
  type: TYPE_NORMAL
- en: Using patch with factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed using Factory Boy factories in [Chapter 8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml),
    *Testing Answerly*. Factories make it easier to create complicated objects. We
    will now take a look at how to use Factories and Python's `patch()` together to
    prevent tasks from being queued.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `SubscriberFactory` in `django/mailinglist/factories.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our factory overrides the default `_create()` method to apply the task patch
    before the default `_create()` method is called. When the default `_create()`
    method executes, it will call `Subscriber.save()`, which will try to queue the
    `send_confirmation_email` task. However, the task will be replaced with a mock.
    Once the model is created and the `_create()` method returns, the patch will be
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use our `SubscriberFactory` in a test. Let''s write a test in `django/mailinglist/tests.py`
    to verify that `SubscriberManager.confirmed_subscribers_for_mailing_list()` works
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've seen both approaches, let's look at some of the trade-offs between
    the two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between patching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Factory Boy factories and `TestCase` mixins help us solve the problem of
    how to test code that queues a Celery task without queuing a Celery task. Let's
    take a closer look at some of the trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the trade-offs when using a mixin are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The patch stays in place during the entire test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have access to the resulting mock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The patch will be applied even on tests that don't need it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mixins in our `TestCase` are dictated by the models we reference in our
    code, which can be a confusing level of indirection for test authors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the trade-offs when using a Factory are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can still access the underlying function in a test if we need to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have access to the resulting mock to assert (we often don't need it).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't connect the parent class of `TestCase` to the models we're referring
    to in our test methods. It's simpler for test authors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ultimate decision for which approach to use is dictated by the test we're
    writing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave Mail Ape the ability to send emails to our users' `MailingList`'s
    confirmed `Subscribers`. We also learned how to use Celery to process tasks outside
    of Django's request/response cycle. This lets us process tasks that may take a
    long time or require other resources (for example, SMTP servers and more memory)
    without slowing down our Django web servers.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a variety of email and Celery-related topics in this chapter. We
    saw how to configure Django to use an SMTP server. We used Django's `send_email()` function
    to send emails. We created a Celery task with the `@shared_task` decorator. We
    queued a Celery task using its `delay()` method. Finally, we explored some useful
    approaches for testing code that relies on external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's build an API for our Mail Ape so that our users can integrate into
    their own websites and apps.
  prefs: []
  type: TYPE_NORMAL
