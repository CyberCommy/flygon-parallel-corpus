- en: 'Additional Information: Using the Device Tree'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device tree internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A device tree is a tree data structure with nodes that tell you which devices
    are currently present in a system along with their configuration settings. Every
    node has property/value pairs that describe the attributes of the device being
    represented. Every node has exactly one parent but the root node has no parent.
  prefs: []
  type: TYPE_NORMAL
- en: The next code shows an example representation of a simple device tree that is
    nearly complete enough to boot a simple operating system, with the platform type,
    CPU, memory, and a single **universal synchronous and asynchronous receiver-transmitter**
    (**UART**) described with its clocks and interrupt lines. Device nodes are shown
    with properties and values inside each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The device tree syntax is quasi self-explanatory; however, we''re going to
    explain it in detail in this paragraph by taking a look at the `simple_platform.dts` file from
    the GitHub repository related to Chapter 4\. So, let''s start by taking a look
    at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we should notice that property definitions are name/value pairs
    in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true except for properties with an empty (zero length) value, which
    have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[label:] property-name;`'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the preceeding example, we have the `compatible` properties of `serial@11100` node (labeled
    as `serial0`) set to a list composed by two strings `"fsl,mpc5125-psc-uart"` and `"fsl,mpc5125-psc"`,
    while the `fsl,rx-fifo-size` property is set to the number `16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property values may be defined as an array of 8, 16, 32, or 64-bit integer
    elements, as NULL-terminated strings, as byte strings, or a combination of these.
    The storage size of an element can be changed using the `/bits/` prefix as follows,
    which defines property `interrupts` as an array of bytes and `clock-frequency`
    as a 64-bit number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `/bits/` prefix allows for the creation of 8, 16, 32, and 64-bit elements.
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the device tree is named according to the following `node-name@unit-address` convention, where
    the `node-name` component specifies the name of the node (usually it describes
    the general class of device), while the `unit-address` component of the name is
    specific to the bus type on which the node sits. For instance, in the preceding
    example, we have `serial@11100`, which means we have a serial port at address
    with offset `0x11100` from the `soc` node's base address, which is `0x80000000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding example, it is quite clear that each node is then
    defined by a node name and unit address, with braces marking the start and end
    of the node definition (they may be preceded by a label) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each node in the device tree has properties that describe the characteristics
    of the node; there exist standard properties that have a well-defined and standardized
    functionality, but we can also use our own properties to specify custom values.
    Properties consist of a name and a value, and for the example of our serial port,
    we set the `interrupts` property to the `<40 0x8>`array, while the `compatible` property is
    set to a list of strings and `fsl,rx-fifo-size` is set to a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'A node in the device tree can be uniquely identified by clearly stating the
    full path from the root node, through all descendant nodes, to the desired node.
    The convention for specifying a device path is similar to the path names we usually
    use for a file in the filesystem; for example, in the preceding definition, the
    device path to our serial port is `/soc@80000000/serial@11100`, while the path
    to the root node is, obviously, `/`. This scenario is where labels come to play;
    in fact, they can be used in place of the full path to a node, that is, the clock
    used by serial port can be easily addressed using the `clks` labels as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also notice that `serial0` is defined as an alias of `tty0`. This syntax
    gives the developer another way to reference a node using a label instead of using
    its full pathname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding definition is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It's quite clear now that a label can be used in a device tree source file as
    either a property handle (the label usually named as phandle) value or a path,
    depending on the context. In fact, the `&` character only refers to a phandle
    if it is inside an array; otherwise (if outside an array), it refers to a path!
  prefs: []
  type: TYPE_NORMAL
- en: Aliases are not used directly in the device tree source, but they are, instead,
    dereferenced by the Linux kernel. In fact, when we ask the kernel to find a node
    by its path (we will see soon, in this chapter, the usage of such functions such
    as `of_find_node_by_path()`) if the path does not begin with the `/` character then
    the first element of the path must be a property name in the `/aliases` node.
    That element is replaced with the full path from the alias.
  prefs: []
  type: TYPE_NORMAL
- en: Another device tree's important entity to understand among nodes, labels, and
    aliases are phandles. The official definition tells us that the phandle property
    specifies a numerical identifier for a node that is unique within the device tree.
    In fact, this property value is used by other nodes that need to refer to the
    node associated with the property, so it's really just a hack to get around the
    fact that a device tree does not have a pointer data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, the `serial@11100` node is a way to specify which
    node is the interrupt controller and which one is the node with clock definitions
    used by phandles. However, in that example, they are not explicitly defined because
    the `dtc` compiler kindly creates phandles from labels. So, in the preceding example,
    we have the following syntax (where information that is not needed has been removed
    for better readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `dtc` compiler is the device tree compiler, which will be introduced in
    [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using the Device Tree*,
    using the device tree compiler and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to the next syntax in which phandles are made explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Simply speaking, the `&` character tells `dtc` that the following string is
    a phandle referencing the label matching the string; it will then create a unique `u32` value
    for each label that is used for a phandle reference.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can define your own phandle property in one node and specify
    a label on a different node's name. Then, `dtc` will be aware of any phandle values
    explicitly stated and will not use those values when creating phandle values for
    labeled nodes.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot to say about device tree syntax. However, we've covered what
    is sufficient to understand how to use a device tree during the device drivers
    development.
  prefs: []
  type: TYPE_NORMAL
- en: For complete documentation about this topic, you can read the device tree specifications
    at [https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the device tree compiler and utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some notes about some interesting usages of the `dtc` and its utilities
    which can be really useful during device drivers development and kernel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a source form of a running device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dtc` can also be used to convert a running device tree into a human-readable
    form too! Let''s suppose we wish to know how our ESPRESSObin has been configured;
    the first thing to do is to take a look at ESPRESSObin''s DTS file in the kernel
    sources. However, suppose we don''t have it. In this situation, we can ask `dtc` to
    revert to the corresponding DTB file, as seen in the preceding section, but suppose
    we still don''t have it. What we can do? Well, `dtc` can help us again by reverting
    data stored in the `/proc/device-tree` directory, which holds a filesystem representation
    of the running device tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can inspect the `/proc/device-tree` directory by using the `tree` command, as
    seen in the following (this output is just a snippet of the whole directory content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If not present, the `tree` command can be installed as usual with the `apt install
    tree` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can read string data inside each file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last `echo` commands have just been used to add a new line character after
    the `cat` output to have more readable output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Numbers must be read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, by using `dtc`, we can achieve better results. In fact, if we use
    the next command line, we ask `dtc` to convert all the DTB data into human-readable
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we must also install the `dtc` program into our ESPRESSObin with
    the `apt install device-tree-compiler` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the `espressobin-reverted.dts` file, we can easily read the device
    tree data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notes on the device tree utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we take a look at programs in the `device-tree-compiler` package that we
    installed previously, we can see that there are more programs than `dtc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These other programs are usually called **device tree utilities** and can be
    used to inspect or manipulate a device tree in its binary form (DTB).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily dump a DTB file using the `fdtdump` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A careful reader will notice that the `fdtdump` utility itself tells us that
    it's only a low-level debugging tool and then to use `dtc` instead of decompiling,
    (or revert to DTS) a DTB file!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another two useful commands are `fdtget` and `fdtput`, which can be used to
    read and write data into our DTB file. The following are commands we can use to
    read the `bootargs` entry for the preceding DTB file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can change it with the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have had to use the `-ts` option argument to tell `fdtput` which
    type of data ours is, otherwise, the wrong values can be written!
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, we can also ask `fdtget` to list all the subnodes for each supplied
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can ask it to list all the properties for each node too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Getting application-specific data from a device tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By using the functions from the `linux/drivers/of` directory, we''ll be able
    to extract all the information we need for our driver from a device tree. For
    instance, by using the  `of_find_node_by_path()` function, we can get a node pointer
    by its pathname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once we have a pointer to a device tree node, we can use it to extract
    the needed information by using the `of_property_read_*()` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are a lot of other functions we can use to extract information
    from a device tree, so you may take a look at the `linux/include/linux/of.h` file for
    a complete list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we wish to parse each property of a node, we can iterate them using
    the `for_each_property_of_node()` macro, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if our node has more than one child (or subnode), we can iterate them
    by using the `for_each_child_of_node()` macro, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using a device tree to describe a character driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that by using a device tree, we can specify different driver settings
    and then modify the driver's functionalities. However, our possibilities do not
    finish here! In fact, we can use the same code for different driver's releases
    or a different types of the same device.
  prefs: []
  type: TYPE_NORMAL
- en: How to manage different device types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose our `chrdev` has two other implementations (plus the current one)
    in which the hardware is done in such a way that most parameters are fixed (and
    well known) and not selectable by the developer; in this case, we can still use
    node properties to specify them, but doing this is error prone and it forces the
    user to know these constraints. For example, if in these two implementations,
    the hardware can work in read-only or read/write modes only (that is, the user
    is not free to specify the `read-only` property), we can call these special cases `"chrdev-fixed"` for
    the read/write version and `"chrdev-fixed_read-only"` for the read-only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can specify that the driver is now compatible with two other
    devices by modifying the `of_chrdev_req_match` array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply added two items with proper `compatible` strings and two special
    data entries, as defined in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this manner, we tell the driver that these devices can have one instance
    only and that they can work in read/write or read-only mode. By doing this, the
    user can use our devices by simply specifying a device tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Again, as before, you must modify the ESPRESSObin's DTS file and then recompile
    and reinstall the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: By using this solution, the user doesn't need to know hardware internals since
    they are encapsulated into the driver by the driver developers (which are us,
    in this situation).
  prefs: []
  type: TYPE_NORMAL
- en: 'This compatible attribute can be evaluated for the driver by using `of_device_is_compatible()`
    function, as shown in the following example, where we''ve modified the `chrdev_req_probe()`
    function to support our `chrdev` special versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, before scanning the node's children, we simply verify which is
    the currently installed `chrdev` device version for our system; in this case,
    we have one of the two new devices so we register a new `chrdev` device accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these modifications can be done using the  `add_fixed_chrdev_devices.``patch` file with
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p3 < add_fixed_chrdev_devices.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try the code by recompiling our `chrdev` driver and reinserting
    it (actually two modules) into ESPRESSObin as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the driver has correctly recognized that a special version of
    the `chrdev` device (the read-only one) has been defined in the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: How to add sysfs properties to devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous section, we briefly talked about the `/sys/class/chrdev` directory.
    We said that it''s related to the device classes (which can be defined in the
    system) and to kernel devices. In fact, when we call the `device_create()` function,
    we must specify the first argument that the device class pointer we allocated
    for the `chrdev_init()`, function and this action creates the  `/sys/class/chrdev` directory
    for which each `chrdev` device is reported as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, a device class groups all devices with common characteristics, but which
    characteristics are we talking about? Well, simply speaking, these characteristics
    or attributes (shortly we'll see what they are exactly called) are a set of common
    information regarding our devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we add a new device to the system, the kernel creates default attributes
    that can be seen from the user space as files under the sysfs, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, in the preceding list, something is a file and something else is a directory
    or a symbolic link; however, here, the important thing is that, for each device,
    we have some attributes describing it. For instance, if we take a look at the `dev` attribute,
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Which is exactly the major and minor number pair for our device? Now the question
    is, can we have more (and custom) attributes? Of course, the answer is yes, so
    let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to modify the `chrdev.c`  file, adding a line to `chrdev_init()` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This modification just set the `dev_groups` field of the struct pointed by `chrdev_class` equal
    to the `chrdev_groups` structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All the modifications in this paragraph can be done by using patch file `add_sysfs_attrs_chrdev.patch`,
    with the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`$ patch -p3 < add_sysfs_attrs_chrdev.patch`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is a complicated way of adding a group of attributes to
    our chrdev devices. To be more specific, the code just adds a single group of
    attributes named `id`, `reset_to`, and `read_only`. All of these attribute names
    are still defined in the modified `chrdev.c` file, as in the following snippet.
    Here is the read-only attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the write-only attribute is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the read/write attribute is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By using `DEVICE_ATTR_RW()`, `DEVICE_ATTR_WO()`, and `DEVICE_ATTR_RO()`, we
    declare read/write, write-only, and read-only attributes, which are connected
    to entries in the array named `chrdev_attrs`, which is defined as the `struct
    attribute` type.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `DEVICE_ATTR_RW(read_only)`, then we must define two functions named `read_only_show()` and `read_only_store()` (the
    variable's name is `read_only` with the postfixes, `_show` and `_store`), so that
    the kernel invokes each time a user space process executes a `read()` or `write()` system
    call on the attribute file. Of course, the `DEVICE_ATTR_RO()` and `DEVICE_ATTR_WO()` variants
    require only the `_show` and `_store` functions, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how data is exchanged, let's take a closer look at these
    functions. By looking at the `read_only_show()` function, we can see that the
    data to be written is pointed by `buf`, while by using `dev_get_drvdata()`, we
    can obtain a pointer to our `struct chrdev_device` holding all the necessary information
    related to our custom implementation. For example, function `read_only_show()` function will
    return the value stored into the  `read_only` variable, which states the read-only
    property of our device. Note that `read_only_show()` must return a positive value
    representing how many bytes are returned, or a negative value if there is any
    error.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, the  `read_only_store()` function gives us data to be written
    into the `buf` buffer and `count` while we can use the same technique to get a
    pointer to the `struct chrdev_device`. The `read_only_store()` function reads
    a number in human-readable form (that is, ASCII representation) and then sets
    the `read_only` properties to 0 if we read value 0 or 1 otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Other attributes, `id` and `reset_to`, are used respectively to show the device's `id` or
    to force the internal buffer to the desired status independently of the fact the
    device itself was defined as read-only or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the code, we have to modify the `chrdev.c` file as described earlier,
    and then we have to recompile the code and move the resulting kernel modules to
    the ESPRESSObin. Now, if we insert the modules, we should get almost the same
    kernel messages as before, but now the content of the `/sys/class/chrdev` subdirectories
    should have changed. In fact, now we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we have three new attributes, as defined in our code. Then, we
    can try to read from them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All answers are as expected; in fact, the `cdev-eeprom` device has `id` equal
    to 2, and is not read-only, while the  `reset_to` attributes are write-only, and
    not readable. A similar output can be obtained from `cdev-rom`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'These attributes are useful to inspect current device status but they can also
    be used to modify its behavior. In fact, we can set an initial value of the read-only
     `cdev-rom` device by using the  `reset_to` attributes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `/dev/cdev-rom@4` device is still read-only, but it''s not filled by
    all zeros any more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can remove the read-only property from the `/dev/cdev-rom@4` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we retry writing data into it, we succeed (the kernel messages below
    the `echo` command are reported from the serial console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this works, but with an unexpected side effect of reading; we can
    write into the device, but the new TEST STRING is overwritten onto the new (longer) `reset_to` string
    we just set up (that is, THIS IS A READ-ONLY DEVICE) so that a subsequent read
    will give:'
  prefs: []
  type: TYPE_NORMAL
- en: '`# cat /dev/cdev-rom\@4`'
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST STRING`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AD ONLY DEVICE!`'
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an example and we can safely accept this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CPU pins for specific peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if the ESPRESSObin is the reference platform of this book, in this paragraph,
    we'll explain how a kernel developer can modify the pins settings for different
    platforms due to the fact this task may vary across different implementations.
    In fact, even if all of these implementations are device tree-based, they have
    some differences among each other that must be outlined.
  prefs: []
  type: TYPE_NORMAL
- en: Current CPUs are very complex systems — so complex that most of them are given
    the acronym **SoC**, which means **System-On-Chip**; in fact, in a single chip,
    we may find not only the **Central Processing Unit** (**CPU**) but also a lot
    of peripherals, which the CPU can use to communicate with the external environment.
    So, we can have the display controller, the keyboard controller, a USB host or
    device controller, disks, and network controllers all together inside one chip.
    Not only that, but modern SoCs have several copies of them! All these peripherals
    have their own signals and each of them are routed over a dedicated physical line
    and each of these lines needs a pin to communicate with the external environment;
    however, it may happen that CPU pins are not enough to route all these lines to
    the outside, which is why most of them are multiplexed. This means that, for instance,
    a CPU may have six serial ports and two Ethernet ports but they cannot be used
    at the same time. Here is where the **pinctrl subsystem** comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux''s pinctrl subsystem deals with enumerating, naming, and multiplexing
    controllable pins, such as software-controlled biasing and driving-mode-specific
    pins, such as pull-up/down, open-drain, load-capacitance, and more. All these
    settings can be done thanks to a **pin controller**, which is a piece of hardware
    (usually a set of registers) that can control CPU pins and it may be able to multiplex,
    bias, set load capacitance, or set drive strength for individual pins or groups
    of pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d784abe-8a03-493a-b9e2-2f8e780c1db8.png)'
  prefs: []
  type: TYPE_IMG
- en: Unsigned integers ranging from 0 to maximum pin number are used to denote the
    packaging input or output lines we want to control.
  prefs: []
  type: TYPE_NORMAL
- en: This number space is local to each pin controller, so there may be several such
    number spaces in a system; each time a pin controller is instantiated it will
    register a descriptor containing an array of pin descriptors describing the pins
    handled by this specific pin controller.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we're not going to explain how we can define a pin controller
    within the kernel, since it's out of the scope of this book (and it's also quite
    a complex task), but we'll try to give to the reader the ability to configure
    each CPU pin in order for it to be used with the driver they are developing by
    using, for example, three of the most used CPUs in the industry of embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: The Armada 3720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ESPRESSObin's CPU is the Armada 3720 from Marvell and we can have an idea about
    its internal peripherals by taking a look at the `linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi `file.
    This file defines the memory map of internal peripherals (which is how and where
    each peripheral is mapped within the CPU's memory) and all the CPU pins grouped
    by pin controllers and pin functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following snippet defines a pin controller named `pinctrl@13800`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We should remember that this notation means that it's mapped at offset `0x13800` from
    the beginning of the parent node named `internal-regs@d0000000` and mapped at `0xd0000000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties of the `compatible` states, which is the driver of this pin controller
    (stored into the `linux/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c `file), while
    each sub-node describes the functionality of a pin. We can see a GPIO controller
    with a clock device and a set of pin definitions (starting from `spi_quad_pins`),
    which the pins controller are defined in the following reported code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PIN_GRP_GPIO()` and `PIN_GRP_GPIO_2()` macros are used to specify the
    fact that a pin''s group can be used by an internal peripheral or just as normal
    GPIO lines. So, when we use the following code in the ESPRESSObin''s DTS file
    (code from `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts` file)
    we ask the pin''s controller to reserve the `uart1_pins` group for the `uart0` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that the line, `status = "okay"`, is needed because each device is normally
    disabled and if it is not specified, the device won't work.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, this time, we have used the `pinctrl-0` property to declare peripheral's
    pins.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of the  `pinctrl-0` and `pinctrl-names` properties is strictly related
    to multiple pin's configuration states, which are not reported in this book due
    to limited space. However, curious readers can take a look at `https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt` for
    further information.
  prefs: []
  type: TYPE_NORMAL
- en: The i.MX7Dual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another quite famous CPU is the **i.MX7Dual from Freescale**, which is described
    in the  `linux/arch/arm/boot/dts/imx7s.dtsi` device tree file. Inside this file,
    we can see a definition of its two pin controllers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `compatiblle` properties, we can discover that the pin controller''s
    driver is stored in the `linux/drivers/pinctrl/freescale/pinctrl-imx7d.c` file, where
    we can find the list of all CPU''s pin pads as follows (for space reasons only
    pin pads of second pin;s controller have been reported):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all peripherals that need pins just have to declare them, as in the following
    example below taken from the DTS file of the **i.MX 7Dual SABRE board** again
    from Freescale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `panel` node asks for the `pinctrl_backlight` pins
    groups, while `wdog1` asks for the `pinctrl_wdog` pins group; all these groups
    require pins from the `lpsr` pad.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pins defines in the DTS can be found into file `linux/arch/arm/boot/dts/imx7d-pinfunc.h`.
    Also, the following numbers are specific pin settings, which are explained in
    the CPU's user manual, so refer to it for further information about these magic
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the  `pinctrl-0` property has been used to address default pins configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The SAMA5D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last example is about the CPU named `SAMA5D3 from Microchip`, which is
    described in the `linux/arch/arm/boot/dts/sama5d3.dtsi` file. The pins definitions
    schema is quite similar to the preceding one, in which we have a pins controller
    driver stored in the `linux/drivers/pinctrl/pinctrl-at91.c` file, and where all
    pins features are managed according to definitions in the device tree, as reported
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, when a peripheral needs one more group of pins, it simply declares them,
    as in the following code taken from the DTS file of the **SAMA5D3 Xplained board** from
    the Microchip Technology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `adc0` node asks for several pins groups to be
    able to manage its internal ADC peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: The DTS schema of SAMA5D3 CPU still uses the `pinctrl-0` property to address
    the default pins configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Using a device tree to describe a character driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the code presented in the recipe in the chapter and to show how everything works,
    we have to compile it before any further steps are taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have to move the `chrdev.ko` and `chrdev-req.ko` files to the ESPRESSObin.
    Now, if we insert the first module, we get exactly the same output we have seen
    before on the serial console (or in the kernel messages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences will appear when we insert the second module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now two new devices have been created. By doing this, the following
    two character files have been automatically created into the `/dev` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In reality, there is nothing magic here, but it's the `udev` program that does
    it for us and this will be explained a bit more in depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The new devices have been named according to the labels specified in the device
    tree (as discussed previously) with minor numbers corresponding to the values
    used for each `reg` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the  `cdev-eeprom@2` and `cdev-rom@4` names are created by the  `device_create()` function when
    we specified the printf-like format as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`device_create(... , "%s@%d", label, id);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try to read and write data into our newly created devices. According
    to our definition in the device tree, the device labeled `cdev-eeprom` should
    be a read/write device, while the one labeled `cdev-rom` is a read-only device.
    So, let''s try some simple read/write commands on the `/dev/cdev-eeprom@2` character
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note the backslash (`\`) character before `@ ` otherwise, BASH will generate
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that everything works as before, the related kernel messages are
    reported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can see that, by the first command, we call an `open()` system call and that
    the driver recognizes the device `id` equal to 2 then, we write 12 bytes (that
    is, the `TEST STRING` plus the termination character); after that, we close the
    device. Using the `cat` command instead, we still open the device, but after that,
    we do the first read of 131,072 bytes (and the driver correctly returns 300 bytes
    only) followed by another read of the same number of bytes, which achieves the
    answer 0, meaning an end-of-file condition; so, the `cat` command closes the device
    and prints the received data (or, at least, all the printable bytes) before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try the same commands on the other `/dev/cdev-rom@4` device. The
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command failed as expected, while the second seemed to return nothing;
    however, this is because all the read data is 0 and to verify this, we can use
    the `od` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that no data has been written into the `/dev/cdev-rom@4` device, which
    has been defined as read-only in the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the preceding code, we can take another look at the kernel messages to
    verify that everything works well (the following are reported kernel messages
    relative to the `od` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that we first open the device (this time,
    the device with `id` equal to four) and then we use the `write()` system call,
    which obviously fails so the device is simply closed. The two following readings
    then work in exactly the same way as the preceding ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now we should try to modify the device tree to define different chrdev devices
    or, better still, should try to modify the driver to add more functionalities.
  prefs: []
  type: TYPE_NORMAL
