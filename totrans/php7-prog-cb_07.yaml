- en: Chapter 7. Accessing Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting between PHP and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple REST client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple REST server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple SOAP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple SOAP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making background queries to external web services is becoming an ever-increasing
    part of any PHP web practice. The ability to provide appropriate, timely, and
    plentiful data means more business for your customers and the websites you develop.
    We start with a couple of recipes aimed at data conversion between **eXtensible
    Markup Language** (**XML**) and native PHP. Next, we show you how to implement
    a simple **Representational State Transfer** (**REST**) client and server. After
    that, we turn our attention to **SOAP** clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between PHP and XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When considering a conversion between PHP native data types and XML, we would
    normally consider an array as the primary target. With this in mind, the process
    of converting from a PHP array to XML differs radically from the approach needed
    to do the reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects could also be considered for conversion; however, it is difficult to
    render object methods in XML. Properties can be represented, however, by using
    the `get_object_vars()` function, which reads object properties into an array.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we define an `Application\Parse\ConvertXml` class. This class will holdthe
    methods that will convert from XML to a PHP array, and vice versa. We will need
    both the `SimpleXMLElement` and `SimpleXMLIterator` classes from the SPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `xmlToArray()` method that will accept a `SimpleXMLIterator`
    instance as an argument. It will be called recursively and will produce a PHP
    array from an XML document. We take advantage of the `SimpleXMLIterator` ability
    to advance through the XML document, using the `key()`, `current()`, `next()`,
    and `rewind()` methods to navigate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the reverse process, also called recursively, we define two methods. The
    first method, `arrayToXml()`, sets up an initial `SimpleXMLElement` instance,
    and then calls the second method, `phpToXml()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the second method, we use `get_object_vars()` in case one of the
    array elements is an object. You''ll also note that numbers alone are not allowed
    as XML tags, which means adding some text in front of the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a sample XML document, you can use the **Web Services Definition Language**
    (**WSDL**) for the United States National Weather Service. This is an XML document
    that describes a SOAP service, and can be found at [http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl](http://graphical.weather.gov/xml/SOAP_server/ndfdXMLserver.php?wsdl).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `SimpleXMLIterator` class to provide an iteration mechanism.
    You can then configure autoloading, and get an instance of `Application\Parse\ConvertXml`,
    using `xmlToArray()` to convert the WSDL to a PHP array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting array is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To do the reverse, use the `arrayToXml()` method described in this recipe.
    As a source document, you can use a `source/data/mongo.db.global.php` file that
    contains an outline for a training video on MongoDB available through O''Reilly
    Media (disclaimer: by this author!). Using the same autoloader configuration and
    instance of `Application\Parse\ConvertXml`, here is the sample code you could
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a simple REST client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST clients use **HyperText Transfer Protocol** (**HTTP**) to generate requests
    to external web services. By changing the HTTP method, we can cause the external
    service to perform different operations. Although there are quite a few methods
    (or verbs) available, we will only focus on `GET` and `POST`. In this recipe,
    we will use the **Adapter** software design pattern to present two different ways
    of implementing a REST client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can define REST client adapters, we need to define common classes
    to represent request and response information. First, we will start with an abstract
    class that has methods and properties needed for either a request or response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define class constants that represent HTTP information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define properties that are needed for either a request or a response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It logically follows to define getters and setters for these properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some properties require access by key. For this purpose, we define `getXxxByKey()`
    and `setXxxByKey()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, the request will require parameters. We will assume that the
    parameters will be in the form of a PHP array stored in the `$data` property.
    We can then build the request URL using the `http_build_query()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set `$transport` based on the original request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will define a `Application\Web\Request` class that can accept
    parameters when we wish to generate a request, or, alternatively, populate properties
    with incoming request information when implementing a server that accepts requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can turn our attention to a response class. In this case, we will define
    an `Application\Web\Received` class. The name reflects the fact that we are re-packaging
    data received from the external web service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a streams-based REST client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are now ready to consider two different ways to implement a REST client.
    The first approach is to use an underlying PHP I/O layer referred to as **Streams**.
    This layer provides a series of wrappers that provide access to external streaming
    resources. By default, any of the PHP file commands will use the file wrapper,
    which gives access to the local filesystem. We will use the `http://` or `https://`
    wrappers to implement the `Application\Web\Client\Streams` adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a `Application\Web\Client\Streams` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a method to send the request to the external web service. In
    the case of `GET`, we add the parameters to the URI. In the case of `POST`, we
    create a stream context that contains metadata instructing the remote service
    that we are supplying data. Using PHP Streams, making a request is just a matter
    of composing the URI, and, in the case of `POST`, setting the stream context.
    We then use a simple `fopen()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a look at retrieving and packaging results into a `Received`
    object. You will notice that we added a provision to decode data received in JSON
    format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Defining a cURL-based REST client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now have a look at our second approach for a REST client, one of which
    is based on the cURL extension:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this approach, we will assume the same request and response classes. The
    initial class definition is much the same as for the Streams client discussed
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `send()` method is quite a bit simpler than when using Streams. All we
    need to do is to define an array of options, and let cURL do the rest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`POST` requires slightly different cURL parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then execute a series of cURL functions and run the results through `getResults()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getResults()` method packages results into a `Received` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Be sure to copy all the preceding code into these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application\Web\AbstractHttp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Received`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Client\Streams`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Client\Curl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this illustration, you can make a REST request to the Google Maps API to
    obtain driving directions between two points. You also need to create an API key
    for this purpose by following the directions given at [https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then define a `chap_07_simple_rest_client_google_maps_curl.php` calling
    script that issues a request using the `Curl` client. You might also consider
    define a `chap_07_simple_rest_client_google_maps_streams.php` calling script that
    issues a request using the `Streams` client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then get the origin and destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now in a position to populate the `Request` object, and use it to generate
    the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of illustration, you could also define a template that represents
    view logic to display the results of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the request as seen in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PHP Standards Recommendations** (**PSR-7**) precisely defines request and
    response objects to be used when making requests between PHP applications. This
    is covered extensively in [Appendix](apa.html "Appendix A. Defining PSR-7 Classes"),
    *Defining PSR-7 Classes* .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on `Streams`, see this PHP documentation page [http://php.net/manual/en/book.stream.php](http://php.net/manual/en/book.stream.php).
    An often asked question is "what is the difference between HTTP PUT and POST?"
    for an excellent discussion on this topic please refer to [http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request](http://stackoverflow.com/questions/107390/whats-the-difference-between-a-post-and-a-put-http-request).
    For more information on obtaining an API key from Google, please refer to these
    web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/maps/documentation/directions/get-api-key](https://developers.google.com/maps/documentation/directions/get-api-key)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/maps/documentation/directions/intro#Introduction](https://developers.google.com/maps/documentation/directions/intro#Introduction)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple REST server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several considerations when implementing a REST server. The answers
    to these three questions will then let you define your REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: How is the raw request captured?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **Application Programming Interface** (**API**) do you want to publish?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you plan to map HTTP verbs (for example, `GET`, `PUT`, `POST`, and `DELETE`)
    to API methods?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will implement our REST server by building onto the request and response
    classes defined in the previous recipe, *Creating a simple REST client*. Review
    the classes discussed in the previous recipe, including the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Application\Web\AbstractHttp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Received`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also need to define a formal `Application\Web\Response` response class,
    based on `AbstractHttp`. The primary difference between this class and the others
    is that it accepts an instance of `Application\Web\Request` as an argument. The
    primary work is accomplished in the `__construct()` method. It''s also important
    to set the `Content-Type` header and status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now in a position to define the `Application\Web\Rest\Server` class.
    You may be surprised at how simple it is. The real work is done in the associated
    API class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note the use of the PHP 7 group use syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `listen()` method that serves as a target for the request.
    The heart of the server implementation is this line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This captures raw input, which is assumed to be in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have also added a provision for authentication. Otherwise, anybody could
    make requests and obtain potentially sensitive data. You will note that we do
    not have the server class performing authentication; rather, we leave it to the
    API class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then map API methods to the primary HTTP methods `GET`, `PUT`, `POST`,and
    `DELETE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we package the response and send it out, JSON-encoded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `processResponse()` method sets headers and makes sure the result is packaged
    as an `Application\Web\Response` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the real work is done by the API class. We start by defining
    an abstract class that ensures the primary methods `get()`, `put()`, and so on
    are represented, and that all such methods accept request and response objects
    as arguments. You might notice that we have added a `generateToken()` method that
    uses the PHP 7 `random_bytes()` function to generate a truly random series of
    16 bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define a corresponding interface that can be used for architectural
    and design purposes, as well as code development control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we present a sample API based on `AbstractApi`. This class leverages
    database classes defined in [Chapter 5](ch05.html "Chapter 5. Interacting with
    a Database"), *Interacting with a Database*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All methods receive request and response as arguments. You will notice the
    use of `getDataByKey()` to retrieve data items. The actual database interaction
    is performed by the service class. You might also notice that in all cases, we
    set an HTTP status code to inform the client of success or failure. In the case
    of `get()`, we look for an ID parameter. If received, we deliver information on
    a single customer only. Otherwise, we deliver a list of all customers using limit
    and offset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `put()` method is used to insert customer data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `post()` method is used to update existing customer entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, `delete()` removes a customer entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define `authenticate()` to provide, in this example, a low-level
    mechanism to protect API usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the following classes, which were discussed in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application\Web\AbstractHttp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Request`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Web\Received`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can then define the following classes, described in this recipe, summarized
    in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class Application\Web\* | Discussed in these steps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Response` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Rest\Server` | 3 - 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `Rest\AbstractApi` | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| `Rest\ApiInterface` | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| `Rest\CustomerApi` | 11 - 16 |'
  prefs: []
  type: TYPE_TB
- en: 'You are now free to develop your own API class. If you choose to follow the
    illustration `Application\Web\Rest\CustomerApi`, however, you will need to also
    be sure to implement these classes, covered in [Chapter 5](ch05.html "Chapter 5. Interacting
    with a Database"), *Interacting with a Database*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application\Entity\Customer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Database\Connection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Application\Database\CustomerService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now define a `chap_07_simple_rest_server.php` script that invokes the
    REST server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the built-in PHP 7 development server to listen on port `8080`
    for REST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To test your API, use the `Application\Web\Rest\AbstractApi::generateToken()`
    method to generate an authentication token that you can place in an `api_key.php`
    file, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can then use a generic API client (such as the one described in the previous
    recipe), or a browser plugin such as RESTClient by Chao Zhou (see [http://restclient.net/](http://restclient.net/)
    for more information) to generate sample requests. Make sure you include the token
    for your request, otherwise the API as defined will reject the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `POST` request for `ID` `1`, which sets the `balance`
    field to a value of `888888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of libraries that help you implement a REST server. One
    of my favorites is an example implementing a REST server in a single file: [https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/](https://www.leaseweb.com/labs/2015/10/creating-a-simple-rest-api-in-php/)'
  prefs: []
  type: TYPE_NORMAL
- en: Various frameworks, such as CodeIgniter and Zend Framework, also have REST server
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple SOAP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using SOAP, in contrast to the process of implementing a REST client or server,
    is quite easy as there is a PHP SOAP extension that provides both capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A frequently asked question is "what is the difference between SOAP and REST?"
    SOAP uses XML internally as its data format. SOAP uses HTTP but only for transport,
    and otherwise has no awareness of other HTTP methods. REST directly operates HTTP,
    and can use anything for data formats, but JSON is preferred. Another key difference
    is that SOAP can operate in conjunction with a WSDL, which makes the service self-describing,
    thus more publicly available. Thus, SOAP services are often offered by public
    institutions such as national health organizations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we will make a SOAP request for an existing SOAP service
    offered by the United States National Weather service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first consideration is to identify the **WSDL** document. The WSDL is an
    XML document that describes the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `soap client` instance using the WSDL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then free to initialize some variables in anticipation of a weather
    forecast request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then make a `LatLonListCityNames()` SOAP request, identified as an operation
    in the WSDL, for a list of cities supported by the service. The request is returned
    in XML format, which suggests creating a `SimpleXLMElement` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the list of cities and their corresponding latitude and longitude
    are in separate XML nodes. Accordingly, we use the `array_combine()` PHP function
    to create an associative array where latitude/longitude is the key, and the city
    name is the value. We can then later use this to present an HTML `SELECT` drop-down
    list, using `asort()` to alphabetize the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then get city data from a web request as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The SOAP call we wish to make is `NDFDgenByDay()`. We can determine the nature
    of the parameters supplied to the SOAP server by examining the WSDL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value of `$currentLatLon` is set, we can process the request. We wrap
    the request in a `try {} catch {}` block in case any exceptions are thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy all the preceding code into a `chap_07_simple_soap_client_weather_service.php`
    file. You can then add view logic that displays a form with the list of cities,
    as well as the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result, in a browser, of requesting the weather forecast for Cleveland,
    Ohio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a good discussion on the difference between SOAP and REST, refer to the
    article present at [http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1](http://stackoverflow.com/questions/209905/representational-state-transfer-rest-and-simple-object-access-protocol-soap?lq=1).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple SOAP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the SOAP client, we can use the PHP SOAP extension to implement a SOAP
    server. The most difficult part of the implementation will be generating the WSDL
    from the API class. We do not cover that process here as there are a number of
    good WSDL generators available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you need an API that will be handled by the SOAP server. For this example,
    we define an `Application\Web\Soap\ProspectsApi` class that allows us to create,
    read, update, and delete the `prospects` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define methods that correspond to create, read, update, and delete.
    In this example, the methods are named `put()`, `get()`, `post()`, and `delete()`.
    These, in turn, call methods that generate SQL requests that are executed from
    a PDO instance. An example for `get()` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then generate a WSDL from your API. There are quite a few PHP-based
    WSDL generators available (see the *There''s more...* section). Most require that
    you add `phpDocumentor` tags before the methods that will be published. In our
    example, the two arguments are both arrays. Here is the full WSDL for the API
    discussed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `chap_07_simple_soap_server.php` file, which will execute the
    SOAP server. Start by defining the location of the WSDL and any other necessary
    files (in this case, one for database configuration). If the `wsdl` parameter
    is set, deliver the WSDL rather than attempting to process the request. In this
    example, we use a simple API key to authenticate requests. We then create a SOAP
    server instance, assign an instance of our API class, and run `handle()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Depending on the settings for your `php.ini` file, you may need to disable
    the WSDL cache, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have problems with incoming `POST` data, you can adjust this parameter
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can easily test this recipe by first creating your target API class, and
    then generating a WSDL. You can then use the built-in PHP webserver to deliver
    the SOAP service with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the SOAP client discussed in the previous recipe to make a
    call to test the SOAP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here is the output for email address `test5393@unlikelysource.com:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/B05314_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple Google search for WSDL generators for PHP came back with easily a dozen
    results. The one used to generate the WSDL for the `ProspectsApi` class was based
    on [https://code.google.com/archive/p/php-wsdl-creator/](https://code.google.com/archive/p/php-wsdl-creator/).
    For more information on `phpDocumentor`, refer to the page at [https://www.phpdoc.org/](https://www.phpdoc.org/).
  prefs: []
  type: TYPE_NORMAL
