- en: Hardware and Disks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件和磁盘
- en: 'The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Determining hardware
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定硬件
- en: Testing hardware
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试硬件
- en: The role of the kernel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核的作用
- en: Disk configuration on Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux上的磁盘配置
- en: The filesystem hierarchy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统层次结构
- en: Configuring a blank disk and mounting it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置空白磁盘并挂载它
- en: Re-configuring a disk using LVM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LVM重新配置磁盘
- en: Using `systemd-mount` and `fstab`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`systemd-mount`和`fstab`
- en: Disk encryption and working with encryption at rest
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘加密和处理静态加密
- en: Current filesystem formats
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的文件系统格式
- en: Upcoming filesystem formats
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即将推出的文件系统格式
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Your hardware doesn't care for you, like you might care for it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您的硬件并不像您可能对它的关心那样对您关心。
- en: Hardware is fickle, temperamental, unpredictable, and moody; disks, the rebellious
    teenager of the hardware family, take this to the next level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件是善变的、喜怒无常的、不可预测的，磁盘，硬件家族中叛逆的青少年，将这一切推向了一个新的境界。
- en: You will find yourself confused at some point in your career, baffled as to
    why seemingly unrelated errors are occurring in disparate parts of your system.
    Your SSH daemon might be randomly dying at odd points in a transfer, NTP might
    be drifting, your database might be locking up, and all the while you're tearing
    your hair out trying to find the cause.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的职业生涯中，您会发现自己在某个时刻感到困惑，对看似无关的错误在系统不同部分的发生感到困惑。您的SSH守护程序可能会在传输的奇怪时刻随机死机，NTP可能会漂移，您的数据库可能会锁死，而与此同时，您正在拼命寻找原因。
- en: Hardware is usually the answer to these random issues (when it's not time, as
    we discussed previously). A bad stick of memory can fail in weird and wonderful
    ways, while a disk occasionally going read-only can mean sporadic and nighttime-disrupting
    events that can be tempting to resolve with a particularly heavy hammer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，硬件是这些随机问题的答案（当不是时间时，正如我们之前讨论的）。一根坏内存条可能会以奇怪而奇妙的方式失败，而偶尔只读的磁盘可能意味着零星和夜间干扰的事件，这些事件可能会诱使您用特别沉重的锤子来解决。
- en: If you don't want to use the phrase "hit it with a hammer" in front of your
    boss, the accepted nomenclature is "percussive maintenance."
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想在老板面前使用短语“用锤子敲一下”，则被接受的命名法是“冲击性维护”。
- en: When hardware goes bad, there's no recourse other than to replace it. Gone are
    the days when we'd solder and fix components ourselves, as it's simply not a viable
    solution, nor is it cost-effective.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬件出现问题时，除了更换它之外别无选择。过去我们会自己焊接和修理组件的日子已经一去不复返，因为这不是一个可行的解决方案，也不具有成本效益。
- en: At some point, you'll discover yourself crouched over an open server in a data
    center, scratching your head at the rows of `DIMMs` and a `RAID10` array of disks,
    trying to determine which one is faulty so that you can swap it out and place
    the old one in a grinder, for your own peace of mind.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您会发现自己蹲在数据中心的一台开放服务器前，对着一排`DIMM`和一个`RAID10`磁盘阵列，摸不着头脑，试图确定哪一个是有故障的，以便您可以将其更换并将旧的放入研磨机，以安心。
- en: We spell storage disks such as hard drives with a k, and optical-type discs
    with a c.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用k来拼写硬盘等存储磁盘，用c来拼写光盘类型的光盘。
- en: In this chapter, we'll look at ways of identifying specific hardware, as well
    as some simple troubleshooting steps for finding bad memory. Coupled with this,
    we'll work through adding new disks to systems and how you might configure them
    once installed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨确定特定硬件的方法，以及一些用于查找坏内存的简单故障排除步骤。除此之外，我们还将介绍如何向系统添加新磁盘以及安装后如何配置它们。
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we''re going to use the following `Vagrantfile`, featuring
    two additional disks:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用以下`Vagrantfile`，其中包含两个额外的磁盘：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The extra disks defined here will be created in the local directory you're running
    Vagrant from, make sure you have enough space.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的额外磁盘将在您从Vagrant运行的本地目录中创建，确保您有足够的空间。
- en: Determining hardware
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定硬件
- en: In the first chapter, we used `dmidecode` and other tooling to work out if we
    were in a VM or not; here, we're going to go a bit further and try to determine
    what hardware we might be running in a system, from the disk IDs to the type of
    graphics card in use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们使用`dmidecode`和其他工具来确定我们是否在虚拟机中；在这里，我们将进一步尝试确定系统中可能运行的硬件，从磁盘ID到正在使用的图形卡类型。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Connect to your Vagrant VM and install some of the extra tools we''re going
    to use:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到您的Vagrant VM并安装一些我们将要使用的额外工具：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We're going to pick through a few different methods for determining the hardware
    a system is running; even if you don't have access to the internet, you should
    be able to determine some basic information using default tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几种不同的方法来确定系统正在运行的硬件；即使您无法访问互联网，您也应该能够使用默认工具确定一些基本信息。
- en: lspci
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lspci
- en: The tool we installed from the `pciutils` suite, `lspci`, is a good way to list
    your collective PCI devices, without a lot of extra noise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`pciutils`套件安装的工具`lspci`是列出您的集体PCI设备的好方法，而不会有太多额外的噪音。
- en: 'If we just run `lspci`, we get a list of devices and their IDs:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只运行`lspci`，我们会得到一个设备列表及其ID：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we can see in the previous list are the devices in our system. They've
    actually had their numeric IDs translated into a human-readable format.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的列表中，我们可以看到系统中的设备。它们的数字ID实际上已经被翻译成了人类可读的格式。
- en: 'If you want to list the IDs alone, you can use the `-n` flag:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想列出ID，可以使用`-n`标志：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or if you want both, use `-nn`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果您两者都想要，可以使用`-nn`：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this list, we can see a few friendly descriptions to help us—things such
    as `Ethernet controller`, `VGA compatible controller`, and `IDE interface`, to
    name a few.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们可以看到一些友好的描述，以帮助我们——例如`以太网控制器`、`VGA兼容控制器`和`IDE接口`等。
- en: At a glance, you should get a good understanding of which device does what,
    thanks to the hard work of the people who keep the `PCI ID` repository up to date: [http://pci-ids.ucw.cz/](http://pci-ids.ucw.cz/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，由于那些不断更新`PCI ID`存储库的人们的辛勤工作，您应该对每个设备的功能有一个很好的理解：[http://pci-ids.ucw.cz/](http://pci-ids.ucw.cz/)。
- en: Even better than listing the devices in our system, we can also list the kernel
    drive that's handling the device with `-k`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 比起列出系统中的设备，我们还可以使用-k列出处理设备的内核驱动程序。
- en: 'In the following snippet, we can see that the Ethernet controller is being
    managed by the kernel driver, `e1000`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，我们可以看到以太网控制器由内核驱动程序“e1000”管理：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The name of the kernel driver and the actual hardware won't always be obvious,
    which is what makes tools such as `lspci` so handy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内核驱动程序的名称和实际硬件并不总是显而易见，这就是像lspci这样的工具如此方便的原因。
- en: In modern machines, you might see more than one PCI bus, with devices connected
    to it; it just so happens that our VM only utilizes one bus for all of its devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代机器上，您可能会看到多个PCI总线，设备连接到它；碰巧我们的虚拟机只利用一个总线来连接所有设备。
- en: 'This means that the tree view is very flat:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着树视图非常扁平：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, when we run `lspci` against a physical machine (in this case, my laptop),
    the tree view can have more branches:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们对物理机器运行lspci（在这种情况下是我的笔记本电脑）时，树视图可能会有更多的分支：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you can''t see a device you know to be there (a graphics card say), it could
    be a few things: maybe the device is disabled in the BIOS or the card itself is
    dead. Try some basic troubleshooting such as checking the BIOS/UEFI configuration
    or flipping the card to a different slot.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到您知道存在的设备（比如显卡），可能有几种情况：也许设备在BIOS中被禁用，或者卡本身已经损坏。尝试一些基本的故障排除，比如检查BIOS/UEFI配置或将卡插入不同的插槽。
- en: 'There''s also `lsusb` for USB devices. This can be handy if you''re using something
    like a USB Ethernet device. In the following example, you can see that the box
    I''m connected to (a Raspberry Pi) has its network port on the USB bus:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有lsusb用于USB设备。如果您使用类似USB以太网设备的东西，这可能很方便。在下面的示例中，您可以看到我连接的盒子（树莓派）的网络端口位于USB总线上：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: lshw
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lshw
- en: A particularly useful program, `lshw` has the built-in ability to output your
    hardware tree as JSON, XML, HTML, and presumably more as they're developed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的程序lshw具有内置的能力，可以将您的硬件树输出为JSON、XML、HTML，可能还有更多，因为它们正在开发中。
- en: 'By default, the output of `lshw` is very verbose, but should look something
    like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，lshw的输出非常冗长，但应该看起来像下面这样：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I tend to find that at-a-glance solutions can work better a lot of the time.
    So, with that in mind, let''s take a look at the `-short` option''s output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于发现一目了然的解决方案在很多时候更有效。因此，考虑到这一点，让我们来看看-short选项的输出：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is much easier to read and means that, at a glance, you can see that the
    system has three disks, one network device, and `512MiB` of system memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更容易阅读，一目了然，您可以看到系统有三个磁盘、一个网络设备和512MiB的系统内存。
- en: 'As we saw in [Chapter 1](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml)*, Introduction
    and Environment Setup*, you can also select a `class` output with `-c`, shown
    again here with our network device:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml)*中看到的，介绍和环境设置*，您还可以使用-c选择“class”输出，再次显示我们的网络设备：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From this output, we can see a lot of pertinent information, such as the capacity
    of the network device (`1Gbit/s`), as well as the capabilities of the device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到很多相关信息，比如网络设备的容量（1Gbit/s），以及设备的功能。
- en: We can even see its specific configuration, which is useful for potential changes
    you might want to make.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以看到它的具体配置，这对您可能想要进行的潜在更改很有用。
- en: 'If you want to see the actual numeric IDs, you can add `-numeric` to your command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查看实际的数字ID，可以在命令中添加-numeric：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: /proc
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /proc
- en: '`/proc` is the **process information pseudo-filesystem** found on most Linux
    systems (but not the BSDs).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: /proc是大多数Linux系统上找到的**进程信息伪文件系统**（但不适用于BSD）。
- en: It is the readable interface-to-kernel data structure, with some files that
    are writable, allowing for on-the-fly changes to be made to your running kernel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它是可读的接口到内核数据结构，其中一些文件是可写的，允许对正在运行的内核进行即时更改。
- en: 'Some useful files within this directory are the likes of `/proc/cpuinfo`, which,
    when queried, gives you all of the information the kernel knows about your CPU:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录中的一些有用文件包括/proc/cpuinfo等，当查询时，它会提供内核了解的有关CPU的所有信息：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It also gives you a processor number, meaning that if you want a quick count
    of processors in your system (being used), you can list them with a short command
    and some piping.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它还会给出处理器编号，这意味着如果您想快速计算系统中（正在使用的）处理器的数量，可以用简短的命令和一些管道列出它们。
- en: 'Here, we''re dumping the file, looking for the word `processor`, and then counting
    the lines. It''s not the most foolproof system, but it''s handy in a pinch:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在转储文件，寻找单词“processor”，然后计算行数。这不是最可靠的系统，但在紧要关头很方便：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another handy file to be aware of is `/proc/meminfo` for a complete dump of
    everything the system knows about your memory:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的有用文件是/proc/meminfo，它可以完全转储系统了解的有关内存的所有信息：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `/proc` filesystem is pretty sprawling and vast; check out the manual page
    for `proc` if you get a spare moment—you won't regret it in a hurry (you might
    regret it later).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: /proc文件系统非常庞大和广泛；如果您有空闲时间，请查看proc的手册页面——您不会立刻后悔（但以后可能会后悔）。
- en: /sys
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /sys
- en: '`/sys` or `sysfs` is a filesystem for exporting kernel objects (according to
    its manual page), which means it''s another filesystem for accessing kernel information
    (like `/proc`).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: /sys或sysfs是用于导出内核对象的文件系统（根据其手册页面），这意味着它是用于访问内核信息的另一个文件系统（如/proc）。
- en: 'It can be very useful in scripts for doing things such as listing discovered
    block devices:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中非常有用，可以列出发现的块设备等：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It can also be useful for finding the device IDs of an individual component
    (if you don't have `lshw` or `lspci` handy, for example).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查找单个组件的设备ID（例如，如果您没有lshw或lspci方便的话），这也可能很有用。
- en: 'In the following example, I''ve listed the vendor and device IDs of the `eth0` device:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我列出了eth0设备的供应商和设备ID：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this information, I can check the details against a list of devices. I
    chose to check out the `PCI ID` repository, where I learned that the vendor ID
    belongs to the Intel Corporation and the device ID translates to 82540EM Gigabit
    Ethernet Controller.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我可以将详细信息与设备列表进行对比。我选择查看`PCI ID`存储库，在那里我了解到供应商ID属于英特尔公司，设备ID转换为82540EM千兆以太网控制器。
- en: There's a lot more to `/sys` outside the hardware realm, and it can be a good
    idea to research the filesystem in more depth. The manual page (`5`) for `sysfs`
    is a debatable must.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys`在硬件领域之外还有很多内容，深入研究文件系统可能是个好主意。`sysfs`的手册页（`5`）是一个有争议的必备品。'
- en: dmesg (and the kernel logs)
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dmesg（和内核日志）
- en: '`dmesg` is a way to print or control the kernel ring buffer according to its
    manual but, to you and me, it''s a great way to quickly see if your hardware was
    detected by the kernel as it''s initialized.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg`是一种根据其手册打印或控制内核环形缓冲区的方法，但对你和我来说，它是一个快速查看内核是否检测到硬件的好方法，因为它在初始化时被检测到。'
- en: 'Running `dmesg` will print to `stdout`, so it''s handy to pipe it into `less`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`dmesg`将打印到`stdout`，所以将其导入`less`很方便：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once done, you should be able to search for specific strings. Continuing with
    our theme, we''re going to look for `Intel` and see what''s loaded:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该能够搜索特定的字符串。继续我们的主题，我们将搜索`Intel`并查看加载了什么：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we look for `ATA`, we can also see our disks being detected:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索`ATA`，我们还可以看到我们的磁盘被检测到：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There''s even a `-T` option, to give you human-readable timestamps, which can
    be especially useful, as shown in the following against our IDE (`PATA`) controllers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一个`-T`选项，可以给你人类可读的时间戳，这可能特别有用，如下所示，与我们的IDE（`PATA`）控制器相比：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: dmidecode
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dmidecode
- en: Another noisy-but-favorite tool from [Chapter 1](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml), I*ntroduction
    and Environment setup*, `dmidecode` decodes the DMI table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个喧闹但最喜欢的工具来自[第1章](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml)，*介绍和环境设置*，`dmidecode`解码DMI表。
- en: We used it to check for virtual hardware initially, but on a non-virtual machine,
    it can be more useful.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初用它来检查虚拟硬件，但在非虚拟机上，它可能更有用。
- en: 'Compare the following `-t processor` dumps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 比较以下`-t processor`转储：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the stark emptiness on our virtual machine, compared with the example
    from my laptop:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的虚拟机上的明显空旷，与我笔记本电脑上的示例相比：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What this serves to show is that, in some scenarios, more information might
    be gleaned from a physical machine than a virtual one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，在某些情况下，从物理机器中可能获得的信息比从虚拟机器中获得的信息更多。
- en: 'The same can be said in reverse: if someone is doing everything in their power
    to obfuscate what hardware is running from you, firstly you should suspect you''re
    running on a VM, and then secondly you should wonder why they''re going to such
    great lengths to hide that fact.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也可以这样说：如果有人竭尽全力地掩盖你的硬件信息，首先你应该怀疑自己是否在虚拟机上运行，然后你应该想知道他们为什么要如此努力地隐藏这个事实。
- en: /dev
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev
- en: If I had to choose a favorite `pseudo-filesystems`, I would be one odd individual,
    but if you forced me, it would probably be `/dev`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果非要我选择一个最喜欢的`伪文件系统`，我可能会成为一个奇怪的人，但如果你逼我选择，那可能会是`/dev`。
- en: This isn't because of some love for the word `dev` or some affinity for its
    overuse, but rather because I find myself inside it so often.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是因为对`dev`这个词的喜爱或者对它的过度使用的偏爱，而是因为我经常发现自己在其中。
- en: 'As with all of the `pseudo-filesystems`, they''re transient and temporary (`tmpfs`).
    Don''t do as I once saw a colleague do and store things in them, because the moment
    you reboot your box: poof, your files are gone.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有的`伪文件系统`一样，它们都是瞬态和临时的（`tmpfs`）。不要像我曾经看到的一位同事那样，在其中存储东西，因为一旦重新启动你的机器：噗，你的文件就没了。
- en: 'On the surface, `/dev` looks messy:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面上，`/dev`看起来很混乱：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, when you know the know, you'll find it invaluable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你知道这些知识时，你会发现它是无价的。
- en: 'Let''s `ls` the `/dev/disk/` directory:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们`ls`一下`/dev/disk/`目录：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Intriguing options—I do like those!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的选项——我喜欢那些！
- en: 'Choosing the `by-id` option shows us all our disk devices, `by-id`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`by-id`选项会显示所有我们的磁盘设备，`by-id`：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is my absolute favorite, `by-uuid`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我绝对最喜欢的`by-uuid`：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The main reason I like these is because these entries are actually symlinks
    to the device they''re named for:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢这些的主要原因是因为这些条目实际上是指向以它们命名的设备的符号链接：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Because of this, I now know that my `sda2` partition has a UUID of `570897ca-e759-4c81-90cf-389da6eee4cc`
    that can be used for various tasks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我现在知道我的`sda2`分区具有`570897ca-e759-4c81-90cf-389da6eee4cc`的UUID，可以用于各种任务。
- en: 'The most obvious use of the UUID is in most systems'' `fstab` files:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: UUID最明显的用途是在大多数系统的`fstab`文件中：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, marrying the two pieces of information up, we now have the actual device
    designation (`sda2`) of our `fstab` UUID entry!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将这两个信息配对起来，我们现在有了我们`fstab` UUID条目的实际设备标识（`sda2`）！
- en: The reason UUIDs are used is because device designation can change, historically
    more so than now. On one boot, your `/boot` filesystem might be denoted as `sda2`,
    then on another a different device might be found first, and suddenly `/boot`
    is `sdb2,` breaking `fstab`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UUID的原因是因为设备标识可能会发生变化，历史上更是如此。在一次启动中，你的`/boot`文件系统可能被标识为`sda2`，然后在另一次启动中可能首先找到不同的设备，突然之间`/boot`就变成了`sdb2`，破坏了`fstab`。
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we're mostly doing here is checking what the kernel is aware of in terms
    of devices connected to your system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里主要做的是检查内核对连接到系统的设备的了解。
- en: PCI devices, as well as USB devices, have denotions that are the same across
    all operating systems (you'll see the same Hex values on Windows, Mac, and BSD).
    This allows for the kernel to choose and load the appropriate bit of code, written
    to interact with that same device.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: PCI设备以及USB设备在所有操作系统中都具有相同的标识（在Windows、Mac和BSD上都会看到相同的十六进制值）。这使得内核可以选择并加载适当的代码，以与相同的设备进行交互。
- en: It's rare, but it can happen that one module supersedes an older one or two
    drivers can both be used with the same hardware; in this case, it's useful to
    know your hardware device IDs and the bit of kernel code that's running against
    them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: If you use Linux on the desktop, and use an Nvidia or AMD GPU, there's a high
    chance you'll be interacting with drivers and what the kernel loads, as there's
    both closed source and open source versions to pick from.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Testing hardware
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss methods for testing potentially faulty hardware
    by looking at SMART and disk-testing software, as well as physically troubleshooting
    RAM issues.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Working with disks can be exceptionally risky, and you should always make sure
    that you have working backups before you start anything that might be hazardous
    to your data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're mostly going to be using the Vagrant box we've created, but you
    may also want to take a look at Memtest86+ from [http://www.memtest.org/](http://www.memtest.org/),
    which I mention for memory testing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to your VM and install `smartmontools`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You might also want to download the latest Memtest86+ ISO.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by looking at disk health.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Self-monitoring, analysis, and reporting technology (SMART)
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, it''s a good idea to make sure that `smartd` is running on whichever
    system you want to query:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`smartd` is the monitoring daemon for SMART; the daemon attempts to enable
    monitoring on compatibly `ATA` devices when it starts and, by default, polls the
    `ATA` devices every 30 minutes.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: By default, errors detected by `smartd` as part of its periodic work are logged
    using the `SYSLOG` interface. It can also email out to an administrator if configured
    to do so.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Once enabled, disks can then be queried with the `smartctl` tool:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note the use of `sudo` and the denoting of a disk device.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, because we''re in a VirtualBox VM, this won''t give us anything useful:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: However, if you tried this on a physical machine, results differ and more information
    can be gleaned.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: hdparm
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible that your disks are reporting back fine to your SMART commands,
    but you're still seeing some form of slowdown or other issues.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: You can benchmark a disk's read with the `hdparm` tool (available in the default
    repositories).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the speeds of our disk using the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The manual page for `hdparm` suggests doing these tests two or three times for
    average results and running them on otherwise inactive systems.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Your mileage may vary, but the results from my system look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Partly, we have a problem here, because what we''re actually doing is reading
    from the kernel''s page cache. We can bypass this using the `--direct` option,
    which reads directly from the drive into buffers of `hdparm`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These results are more raw disk read performance:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Memory testing
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory is a little easier to test, though the most thorough way of checking
    every inch of your DIMMs is to take the box offline for a few hours while you
    run Memtest86+.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Programs such as **memtester** also exist, which can be executed on a running
    system. The problem with these types of test is that they won't test memory already
    in use by the system, and they can end up fighting processes such as the **Out
    Of Memory** (**OOM**) killer.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: If you have the ISO image from the Memtest86+ website, you can attach it to
    your VM and boot into the program (completely independently of CentOS).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d3d476a-10bb-4225-98b7-004988bbf141.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Any errors will show up in the bottom half of the screen, and you'll know you
    have bad memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: I used to let Memtest86+ do five passes over the memory I was testing when I
    used it every night during my data center days.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If you find that your system won't boot at all, but you suspect memory problems,
    it can be a good idea to test in a binary fashion. By this, I mean that if your
    server has 128 sticks of memory (not uncommon), you should remove 64 of them and
    test the remaining batch. If your server boots, you know your faulty stick is
    somewhere in the 64 you removed. If your server doesn't boot, your faulty stick
    is somewhere in the batch that you left inside.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现您的系统根本无法启动，但怀疑是内存问题，那么以二进制方式进行测试可能是个好主意。我的意思是，如果您的服务器有128根内存条（这并不罕见），您应该移除64根并测试剩下的一批。如果您的服务器启动了，那么您就知道有问题的内存条在您移除的64根中的某一根。如果您的服务器无法启动，那么有问题的内存条就在您留在内部的一批内存条中。
- en: Repeat this technique, halving the memory you check each time, until you're
    down to two DIMMs, one of which you know to be faulty, and then test each in turn.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重复这种技术，每次检查的内存减半，直到您只剩下两个DIMM，其中一个您知道是有问题的，然后依次测试每个内存条。
- en: Testing in the previous fashion may sound obvious, but at two o'clock in the
    morning, when you can't think straight, having read these words might save your
    sanity.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的测试可能听起来很明显，但在凌晨两点，当您无法清晰地思考时，阅读这些文字可能会挽救您的理智。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SMART reads information by querying the `/dev/` device you target and displaying
    what it's learned about a SMART-compatible device.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SMART通过查询您选择的`/dev/`设备来读取信息，并显示它对兼容SMART设备所学到的内容。
- en: When we're using `hdparm`, we're actually running tests regardless of our filesystem,
    because the program reads from the disk directly—because of this, real-world speed
    may be different.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`hdparm`时，实际上是在运行测试，而不管我们的文件系统，因为该程序直接从磁盘读取数据——因此，实际速度可能会有所不同。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I didn't include testing graphics cards and things of that nature in this section
    because it's usually quite easy to tell when a graphics card is on the way out
    (graphical glitches, random lines, and occasional beeps).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在本节中包括测试显卡等内容，因为通常很容易判断显卡是否出问题（图形故障、随机出现的线条和偶尔的蜂鸣声）。
- en: I also didn't mention physical RAID cards, because there's such an abundance
    that it would be impossible to list a coherent method for all of them. The best
    advice I can give for physical RAID cards is to check out the manufacturer's details
    on testing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我也没有提到物理RAID卡，因为种类繁多，不可能为所有RAID卡列出一个连贯的测试方法。对于物理RAID卡，我能给出的最好建议就是查看制造商关于测试的详细信息。
- en: We didn't cover write tests for disks, partly because it's usually pretty obvious
    to tell disk issues from read tests alone, and partly because a lot of the methods
    of testing writes can be destructive if done incorrectly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖磁盘的写入测试，部分原因是通常很容易通过读取测试来判断磁盘问题，另一部分原因是如果错误进行写入测试，很多测试方法可能会具有破坏性。
- en: The role of the kernel
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核的作用
- en: We're going to watch the kernel running through its startup process, as well
    as look at which modules have been loaded by the time we get to the OS.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将观察内核在启动过程中的运行情况，以及在我们到达操作系统时加载了哪些模块。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'For this section, ensure your VM is up and running, as we''re going to talk
    about hardware initialization:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，请确保您的VM正在运行，因为我们将讨论硬件初始化：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Connect to your VM. If you've just come off the previous section, you may want
    to destroy and recreate your VM to ensure a vanilla experience.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到您的VM。如果您刚刚完成上一节，您可能希望销毁并重新创建您的VM，以确保获得原始体验。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到的...
- en: First, we're going to watch our system boot.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要观察我们的系统启动。
- en: 'Start by disabling the `quiet` option in our boot configuration so that we
    can actually see information on our VM display:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的引导配置中禁用`quiet`选项，这样我们就可以在VM显示器上实际看到信息：
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to generate a new `grub` configuration file, as we''ve made a
    change:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要生成一个新的`grub`配置文件，因为我们已经做出了更改：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous code is a good example of what you would do if someone asked you
    to make a `grub` configuration change, a surprisingly common action.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是一个很好的例子，如果有人要求您进行`grub`配置更改，这是一个令人惊讶地常见的操作。
- en: 'Now, bring up the VirtualBox main window, and double-click your VM so, you
    can see the black console:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开VirtualBox主窗口，双击您的VM，这样您就可以看到黑色控制台：
- en: '![](img/08f1ae2c-f11c-49ac-aaf9-f0c661ad950b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08f1ae2c-f11c-49ac-aaf9-f0c661ad950b.png)'
- en: 'Bring up your Terminal connection so that you can see both and reboot your
    VM with the `reboot` command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的终端连接，这样您就可以同时看到并使用`reboot`命令重新启动您的VM：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Keep your eyes on the VirtualBox window; you should see something like the
    following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 保持眼睛盯着VirtualBox窗口；您应该会看到类似以下截图的内容：
- en: '![](img/ae417e9b-2ac0-46dc-b333-34abc9562b23.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae417e9b-2ac0-46dc-b333-34abc9562b23.png)'
- en: Did you note that scrolling information? It probably flew by too fast for you
    to read, but it's your system working through initializing itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您有注意到滚动信息吗？它可能飞得太快了，以至于您无法阅读，但这是您的系统在初始化自身。
- en: You can close your VirtualBox window now and continue in the Terminal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以关闭VirtualBox窗口，并在终端中继续操作。
- en: If you're interested in reading back through what you just saw, you might remember
    the `dmesg` command we used previously; everything you've just seen is available
    to view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣回顾刚才看到的内容，您可能会记得我们之前使用过的`dmesg`命令；您刚刚看到的所有内容都可以查看。
- en: 'Now that we''re in a running system again, we can see which modules the kernel
    has loaded to deal with our hardware:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在运行的系统中查看内核加载了哪些模块来处理我们的硬件：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That's a lot of modules!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多模块！
- en: As I mentioned previously, some of these modules will be obvious, and more still
    won't be.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，其中一些模块是显而易见的，还有更多的则不是。
- en: An obvious one from that list might be `e1000` because we already know that's
    our network module from an earlier section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，一个很明显的是`e1000`，因为我们已经知道这是我们在前面一节中讨论过的网络模块。
- en: 'We can get specific information about a module using `modinfo`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`modinfo`获取有关模块的具体信息：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code not only gives us the version of the module and the license,
    but the author and their information for contacting purposes (usually bug reports).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码不仅给出了模块的版本和许可证，还给出了作者和他们的联系信息（通常是bug报告）。
- en: 'If you try to remove a module that''s in use, you won''t be allowed, as seen
    in the following `modprobe` example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图移除一个正在使用的模块，你将不被允许，就像下面的`modprobe`示例中所示的那样：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Similarly, if you want to load a new module (maybe because you want to test
    it), you can again use `modprobe`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你想加载一个新的模块（也许是因为你想测试它），你可以再次使用`modprobe`：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then see our loaded module:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以看到我们加载的模块：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Loading a module on boot is a different matter, as it requires a configuration
    file if not built in to the kernel (and kernel options are usually generic so
    that vendors can cover as many bases as possible without causing problems).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时加载模块是另一回事，因为如果没有内置到内核中（并且内核选项通常是通用的，以便供应商可以尽可能涵盖多种情况而不会引起问题），它需要一个配置文件。
- en: 'To ensure `nf_tables` starts with the rest of our kernel, run the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`nf_tables`与我们的内核一起启动，请运行以下命令：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Reboot and use `lsmod` to see whether your module has loaded.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动并使用`lsmod`来查看你的模块是否已加载。
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When your system boots, several things happen in sequence, and these vary slightly
    depending on trivial differences (such as which bootloader you're using, though
    mostly it's Grub these days).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动时，会按顺序发生几件事情，这些事情会略有不同（比如你使用的引导加载程序是哪个，尽管现在大多数情况下都是Grub）。
- en: One of these things is that the kernel extracts itself and loads, before handing
    over control to the `init` system (`systemd`).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一件事是内核会自行提取并加载，然后将控制权交给`init`系统（`systemd`）。
- en: While the kernel is loading, it also detects hardware in the system and adds
    the appropriate module to its running state so that hardware can be correctly
    interacted with and managed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核加载时，它还会检测系统中的硬件，并将适当的模块添加到其运行状态，以便可以正确地与硬件进行交互和管理。
- en: When we list modules with `lsmod`, we're actually just printing `/proc/modules` in
    a more readable format.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`lsmod`列出模块时，实际上只是以更易读的格式打印`/proc/modules`。
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can dynamically load and unload modules, as well as manually blacklist certain
    ones from loading at all.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以动态加载和卸载模块，也可以手动将某些模块列入黑名单，以防止加载。
- en: This can come in handy if you have a particular piece of hardware that's faulty,
    and/or causes a Kernel Panic (the kernel ceasing to function entirely and crashing).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个特定的硬件故障，和/或导致内核崩溃（内核完全停止运行并崩溃），这可能会有所帮助。
- en: 'To blacklist a module, it''s simply a case of adding it to a blacklist in `/etc/modprobe.d/`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要列入黑名单一个模块，只需将其添加到`/etc/modprobe.d/`中的黑名单中：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the previous example, I blacklisted `e1000`. Clearly, this is going to cause
    me problems as it means my network card won't have appropriate drivers at boot,
    but it made the system more secure!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我将`e1000`列入黑名单。显然，这会给我带来问题，因为这意味着我的网络卡在启动时将没有适当的驱动程序，但这样可以使系统更安全！
- en: Disk configuration on Linux
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux上的磁盘配置
- en: In this section, we're going to look at the out-of-the-box configuration of
    the disks in our VM and discuss the differences between `vda`, `sda`, `hda`, and
    `nvme`. We're also going to investigate the difference between disks, virtual
    disks, partitions, and filesystems.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看我们的虚拟机中磁盘的开箱即用配置，并讨论`vda`、`sda`、`hda`和`nvme`之间的区别。我们还将调查磁盘、虚拟磁盘、分区和文件系统之间的区别。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here, we're going to be using the Vagrant box we created at the beginning of
    this chapter.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用我们在本章开头创建的Vagrant box。
- en: 'Ensure your `centos1` VM is up and connect to it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的`centos1`虚拟机已经启动并连接到它：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Check that your VM has the appropriate packages for this section installed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的虚拟机是否安装了本节所需的适当软件包。
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll start by looking at the physical disks in our system and work out how
    they relate to what we can see with the `df` command.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看系统中的物理磁盘，并弄清它们与我们可以通过`df`命令看到的内容之间的关系。
- en: Listing disks with lsblk
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lsblk列出磁盘
- en: As part of your base system, a program called `lsblk` should be installed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基本系统的一部分，应该安装一个名为`lsblk`的程序。
- en: 'Running this program gives you a human-readable tree view of our system''s
    block devices, their logical separations, and their mount points:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序会为您提供一个人类可读的树状视图，显示我们系统的块设备、它们的逻辑分离和它们的挂载点：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A block device is basically a layer of abstraction atop a storage medium; character
    (raw) devices allow direct access to the storage medium, but may have restrictions
    applied that are abstracted away by using a block device instead.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备基本上是在存储介质之上的一层抽象；字符（原始）设备允许直接访问存储介质，但可能会施加一些抽象掉的限制，而使用块设备可以解除这些限制。
- en: 'In the previous example, we have our physical disks:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们有我们的物理磁盘：
- en: '`sda`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sda`'
- en: '`sdb`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdb`'
- en: '`sdc`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdc`'
- en: 'We then have our partitions:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有我们的分区：
- en: '`sda1`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sda1`'
- en: '`sda2`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sda2`'
- en: '`sda3`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sda3`'
- en: 'We have our volume group:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的卷组：
- en: '`VolGroup00`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VolGroup00`'
- en: 'We have logical volumes atop our singular volume group:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的单一卷组上有逻辑卷：
- en: '`LogVol00`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogVol00`'
- en: '`LogVol01`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogVol01`'
- en: 'Finally, we have our mount points:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有我们的挂载点：
- en: '`/boot`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`'
- en: '`/`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`'
- en: '`[SWAP]`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[SWAP]`'
- en: Listing mount points with df
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用df列出挂载点
- en: 'Now that we know the rough disk layout of our system, we might want to know
    all of the other mount points, too. This is easily achieved with a program called
    `df`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了系统的大致磁盘布局，我们可能也想知道所有其他的挂载点。这可以很容易地通过一个名为`df`的程序来实现：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For better, human-readable output, we can use `-h`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阅读输出，我们可以使用`-h`：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we can see the mount points we already know about from the previous section,
    those being `/` and `/boot`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经从上一节知道的挂载点，即`/`和`/boot`。
- en: We can also see other mount points, specifically those tagged with the `devtmpfs`
    and `tmpfs` filesystems.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到其他挂载点，特别是那些标记有`devtmpfs`和`tmpfs`文件系统的挂载点。
- en: These mount points are mounted atop RAM disks—a concept that's been around for
    years, but which we still use because RAM is just so damn quick (considerably
    faster than SSDs at the moment).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Temporary directories are those that contain files we don't care about preserving
    across reboots (for the most part).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, the mount points you will be concerned with day-to-day are those that
    contain non-transient files.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Listing filesystems with df
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as knowing which of your disks is mounted where, you might also want
    to know which filesystem is being used atop the chunk of space; this is done with
    the `-T` flag:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we can easily see that our slash-root mount point (`/`) and boot mount
    point are formatted as XFS.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: CentOS and Red Hat prefer to use XFS at present, but it's not uncommon to come
    across systems using `ext4`, `ext3`, `ext2`, `btrfs`, and `zfs`, to name a few.
    Functionally, there are differences, but for day-to-day activities, they all handle
    writing and reading files, which is the important bit.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Listing logical volume manager disks, volume groups, and logical volumes
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using LVM (which we are by default, and which a lot of systems do),
    you may want to know the layout of your disks that are being handled by LVM.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Physical disks
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we need to know which physical volumes LVM is aware of; this is accomplished
    with `pvs` or `pvdisplay`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note how `sudo pvs` is a more traditional, `unix-y` output, whereas the second
    is more intended for human parsing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the only physical device LVM is aware of is the `sda3`
    partition atop the `sda` device.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: A physical volume in LVM land can be either an entire device (`sda`) or a partition
    on that device (`sda3`). Generally, which one is used is down to the system administrator's
    personal preference, as there are both pros and cons to both methods. Personally,
    I prefer to give the whole device to LVM and let it do all of the work, removing
    a layer of abstraction, but I've known people who swear by carving up the disk
    into partitions before LVM even gets a say.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Volume groups
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can have more than one physical volume grouped together in a volume group;
    later, this allows for flexibility in terms of the logical volumes that sit on
    top.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a printout when using `pvs` and `pvdisplay` that tells you the
    volume group that the disk is a part of, but if you want to only list the volume
    group information, `vgs` and `vgdisplay` can be used:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we can see that there are two logical volumes atop this volume group.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Logical volumes
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, in the LVM stack, we have the logical volumes. These are the logical
    devices that the filesystems get applied to, and which can then be mounted at
    a point on your system.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Have you worked out the logic behind the command naming?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, we will use `lvs` and `lvdisplay`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There are two logical volumes!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We know that one of them is sitting under our slash-root and, thanks to `lsblk`
    earlier, we know that the second is providing our swap space.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Listing swap
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swap is special, and it's more like extended, slow, and somewhat annoying memory
    than it is disk space.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Swap is used when your system's RAM is full, and the kernel starts to offload
    infrequently accessed memory onto the disk, where it can be read back at a much
    slower rate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Is it time for another holy war? I think it is! Some systems administrators
    swear by swap and will always make sure their system has at least a few megabytes
    of space to swap into, even if they've got 256 GB of RAM; other systems administrators
    say that, if you're using that much RAM and still swapping, you need more RAM.
    Smile and nod if you're not the person making the decision about whether or not
    to even have swap—it's not worth it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list what swap our system is using with `swapon`, like so:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we can see our one swap device is `/dev/dm-1`, but we think it's an LVM
    device? That can't be right.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: But it can!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical volumes are actually mapped; `dm-1` is a low-level representation of
    our logical volume. Running `ls -l` on our logical volume device proves the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑卷实际上是映射的；`dm-1`是我们逻辑卷的低级表示。在我们的逻辑卷设备上运行`ls -l`可以证明以下事实：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Our device is actually linked and mapped to `dm-1`, which is why it's listed
    as it is in our `swapon` command.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设备实际上是链接和映射到`dm-1`，这就是为什么它在我们的`swapon`命令中列出的方式。
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Physically, you have a disk.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 物理上，你有一个磁盘。
- en: This disk can be a hard disk drive (the old-school spinning platter type) or
    a solid state drive of some sort, be it `NVMe` on an M.2 connector or generic
    SATA.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个磁盘可以是硬盘驱动器（老式的旋转式碟片类型）或某种固态硬盘，比如M.2连接器上的`NVMe`或通用的SATA。
- en: Whatever the type of disk, you want to use it for storage.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 无论磁盘的类型如何，你都想要用它来存储。
- en: To store data on the disk, it needs to have some things. First, it needs to
    be readable by the OS; this bit is handled by the kernel. If the kernel determines
    the disk to be an IDE drive (uncommon), it'll probably show as an `hda` device.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要在磁盘上存储数据，它需要一些东西。首先，它需要被操作系统读取；这一部分由内核处理。如果内核确定磁盘是IDE驱动器（不常见），它可能会显示为`hda`设备。
- en: If the disk is SATA or SCSI, it might show up as an `sda` device. If it's a
    virtio virtual disk, and shows as such to the virtual machine, it will be listed
    as `vda`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果磁盘是SATA或SCSI，它可能显示为一个`sda`设备。如果它是一个virtio虚拟磁盘，并且在虚拟机中显示为这样，它将被列为`vda`。
- en: The disk lettering is sequential, which is why our three disks show up as `sda`,
    `sdb`, and `sdc`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的标识是顺序的，这就是为什么我们的三个磁盘显示为`sda`、`sdb`和`sdc`。
- en: This lettering doesn't have to be consistent; the disks are assigned their denotion
    at boot-time, meaning your computer can come up with its first disk as `sdb` one
    day and `sda` another, because of various factors. The way around this is to use
    disk UUIDs (seen in `fstab` earlier) or labels.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种标识不一定要一致；磁盘在启动时被分配它们的标识，这意味着你的计算机可能一天以`sdb`的方式启动，另一天以`sda`的方式启动，这是由于各种因素。解决这个问题的方法是使用磁盘UUID（在之前的`fstab`中看到）或标签。
- en: Secondly, after the operating system recognizes that a disk exists, it has to
    check for partitions and filesystems. Partitions are a segment of a disk, and
    filesystems are the recipe for how files are read and written to the drive.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在操作系统识别到磁盘存在后，它必须检查分区和文件系统。分区是磁盘的一个部分，文件系统是文件如何读取和写入到驱动器的配方。
- en: In this section, we started out with `lsblk`,  which we used to query the `sysfs`
    filesystem and the `udev` database, before displaying it in a human-readable way.
    Generally, this is my first stop when trying to determine what a system looks
    like.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们首先使用了`lsblk`，用它来查询`sysfs`文件系统和`udev`数据库，然后以人类可读的方式显示出来。通常，这是我在尝试确定系统外观时的第一站。
- en: After that, we had a look at mount points and filesystems.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看了挂载点和文件系统。
- en: Mount points are the area of the Linux hierarchy to which disks are assigned.
    Unlike Windows, where the structure starts at the disk, on Linux, the structure
    is set and the disks fit in (flipping the Windows model on its head).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载点是Linux层次结构中分配磁盘的区域。与Windows不同，Windows的结构从磁盘开始，而Linux的结构是固定的，磁盘适应其中。
- en: It's a little hard to visualize the Linux hierarchy of mount points and filesystems,
    but the important thing to remember is that everything starts at root (that is,
    slash-root or `/`) and builds from there. You could have one disk, with one partition,
    and put slash-root on that partition, hence making the simplest system possible.
    Or, you could put your home directories (`/home`) on a physical disk of its own,
    but it would still exist as `/home`, one step above slash-root.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Linux层次结构的挂载点和文件系统有点难以想象，但重要的是要记住的是一切都从根目录开始（即斜杠根目录或`/`），然后从那里构建。你可以有一个磁盘，有一个分区，并将斜杠根目录放在该分区上，从而使得最简单的系统成为可能。或者，你可以将你的主目录（`/home`）放在一个独立的物理磁盘上，但它仍然存在于斜杠根目录的上一级。
- en: Imagine the logical layout of the Linux hierarchy as the absolute, with the
    disks almost an irrelevant piece of the puzzle. If you really felt like it, you
    could mount a bit of the filesystem at `/home/me/favourite_things/pokemon/absol`,
    entirely on one disk.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下Linux层次结构的逻辑布局是绝对的，而磁盘几乎是谜题中不重要的一部分。如果你真的想这样做，你可以将文件系统的一部分挂载到`/home/me/favourite_things/pokemon/absol`，完全在一个磁盘上。
- en: Filesystems are a bit more obvious and generally static (unless you're a system
    administrator who really wants to live on the wild side). Once you've carved out
    a section of disk that you want to use (say to mount `/home` on), you decide on
    a filesystem.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统有点更明显，通常是静态的（除非你是一个真的想要冒险的系统管理员）。一旦你划分出你想要使用的磁盘部分（比如挂载`/home`），你就要决定文件系统。
- en: It's best to go with a typical one in a work environment, something like XFS
    or `ext4`, rather than an experimental one, like `btrfs`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最好选择在工作环境中使用的典型文件系统，比如XFS或`ext4`，而不是像`btrfs`这样的实验性文件系统。
- en: At the end of your storage-creating adventure, you've got a disk, with a `partition`,
    which has the `ext4` filesystem atop, and which you've mounted at `/home`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的存储创建冒险结束时，你有一个磁盘，上面有一个`分区`，上面有一个`ext4`文件系统，你已经挂载到`/home`。
- en: There's more...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '...There''s so much more!'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '...还有更多！'
- en: The world of filesystems is an ever-evolving and ever-changing one. You'd have
    thought that, by now, we'd have data storage licked, but you would be wrong.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的世界是一个不断发展和变化的世界。你可能会认为，到现在为止，我们已经解决了数据存储的问题，但你会错。
- en: There are some filesystems that are better suited for thousands of small files
    (for example, databases) and some that are better suited for massive blocks of
    files (such as VM disks). Which one you choose to use is up to you.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些文件系统更适合于成千上万的小文件（例如数据库），有一些更适合于大块的文件（比如虚拟机磁盘）。你选择使用哪种取决于你。
- en: There are de-duplicating, snapshotting, and even self-healing (apparently) filesystems.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有去重、快照，甚至自愈（显然）的文件系统。
- en: FreeBSD swears by ZFS, which is also shipped in Ubuntu in the Linux world. OpenSUSE
    favors `btrfs` for a lot of its new installations, and some distributions keep
    with the classics, shipping the `ext` family for familiarity reasons.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Whichever you decide to use, be sure to keep backups—backups are important.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem hierarchy
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss `hier` and `man hier` as a way of determining
    what your filesystem's different names mean.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at your system, you might question why certain folders are named
    in the way they are:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What's `sbin` or `opt`?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also be curious as to know why there''s a folder called `root` when
    we''re supposed to be in the root of the system, `/`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The filesystem hierarchy has the answers you want!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to use our lone VM.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: If not already connected, connect to your VM.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to directly reference a man page, so ensure that your man
    pages are installed with the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To discern how your distribution maintainer thinks the distribution filesystem
    should look, run `man hier`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The manual page should open in your default pager (usually `less`) and can be
    navigated as such.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'What you should see is something akin to the following—a list of paths, with
    a description next to each of them:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb37f69-8cd3-4a23-b2a2-78af79e5b2cc.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
- en: Linux Manual Hier Page
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This manual page is important, and there's no guarantee that it'll be consistent
    across the systems that you manage (that is, Debian and CentOS might look distinctly
    unfamiliar).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'What it should be is the distribution maintainer''s understanding of where
    specific files go on this distribution. So, according to this manual page, that
    is the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '"/bin  This directory contains executable programs which are needed in single
    user mode and to bring the system up or repair it."'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'That one is fairly obvious, but what if we want a directory for add-on packages?
    `hier` for CentOS has you covered:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '"/opt   This directory should contain add-on packages that contain static files."'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'How about if you see a path, and you''re not sure what it''s for, such as `/usr/games`?
    See the following:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '"  /usr/games Binaries for games and educational programs (optional)."'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, one directory that's omitted from the CentOS-supplied `hier` manual
    is `/srv`, and it's one I use quite frequently.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken from the Ubuntu `hier` manual, we can see its definition:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '"/srv   This directory contains site-specific data that is served by this system."'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good example of how different systems might put files in different
    places, and it''s a good place to clear up confusion:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '"       /      This is the root directory. This is where the whole tree starts.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: <SNIP>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: /root  This directory is usually the home directory for the root user (optional)."
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the bottom of your system''s `hier` manual, you might see a reference to
    The Filesystem Hierarchy Standard, available at [http://www.pathname.com/fhs/](http://www.pathname.com/fhs/).
    This standard is, according to the manual, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '"The filesystem standard has been designed to be used by Unix distribution
    developers, package developers, and system implementors. However, it is primarily
    intended to be a reference and is not a tutorial on how to manage a Unix filesystem
    or directory hierarchy."'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: This in itself isn't very helpful because it effectively says "*these are more
    guidelines than rules*", a la *Pirates of the Caribbean*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Basically, use `man hier` as a good rule of thumb for working out how a system
    is laid out, but don't assume some narcissistic system administrator hasn't come
    along and put Terraform in `/usr/local/sbin` just to be awkward.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a blank disk and mounting it
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use CLI tools to partition and format one of our disks
    (without LVM), talking about GPT and MBR while we do so. We'll then mount our
    disk at `/home` on our system.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using the supplied `Vagrantfile` for this chapter, you'll have a system
    with two blank disks connected. If you're using your own solution, now would be
    the time to add a couple of blank disks.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to your VM and ensure you can see `/dev/sdb`; if you can''t, double
    check your Vagrant setup:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to partition our disk. Here, we're going to create two partitions
    of half the disk each.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by using `fdisk` against `/dev/sdb`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You'll be dropped into a different shell, that of `fdisk`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create `GPT disklabel` by typing `g`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Next, we will create a new partition, with a partition number of `1`, a first
    sector of `2048`, and of the size 1 GB.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by pressing `n` and *Enter*, accepting the defaults of the first
    two prompts (by pressing *Enter* without input) and typing `+1G` when prompted
    for `Last sector`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we use `n` again to create a second partition although this time we''re
    going to accept the defaults each time (hit *Enter* thrice) because we want to
    use the rest of the disk:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we''ve got our partitions laid out as we want, we need to write the table
    to the disk and exist `fdisk`. Do this with `w`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: These days, systems are pretty good about automatically re-reading the partition
    table changes of a device, though occasionally you might still need to run `partprobe`
    to inform your kernel of any changes manually.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `lsblk` should now show our new partitions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now that we have two partitions, we're going to format them with a filesystem.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this tutorial, we''re going to format one as `ext4`, and one
    as XFS:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You will be presented with various bits of information, but hopefully the format
    should be done quickly.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'For partition two, we''re going to use just the `mkfs` command, which lacks
    the implied type of using `mkfs.ext4`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can use a new tool here (`blkid`) to print the UUID and `TYPE` of these
    partitions:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It looks good!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's a good practice to copy over files from the location you're hoping
    to mount atop, prior to replacing it with your new filesystem.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at `/home` at the moment, it looks like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If we mount one of our filesystems at `/home` and `ls` again, it looks like
    this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Our Vagrant user's home folder has vanished!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The `lost+found` folder is a function of `fsck` (the filesystem repair utility)
    and is the dumping ground for pieces of files that it can't make head nor tail
    of.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we mounted a system over the top of the old location; if we
    unmount this new filesystem and `ls` the directory again, it looks like this:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So, what we really need to do is copy over all existing data (preserving ownership
    and rights) before writing atop it.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder in `/mnt` (a standard place to do such things),
    mounting our new filesystem, and copying the data over:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the previous, we used `-r` to recursively copy and `--preserve=all` to preserve
    things such as the SELinux context of the files, alongside the ownership and timestamps.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Check your results by confirming the Vagrant user''s SSH `authorized_keys`
    file still has the permissions, `-rw-------`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, `umount` the filesystem from our temporary location and mount it over
    the top of the previous `/home`, making sure we''re not in `/home` first (by moving
    to a different directory):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We move to the root of the filesystem (`/`) on purpose, to avoid the device
    being busy and causing complications, though this is more of an issue when trying
    to unmount a filesystem that you're still sitting in.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `df` should now show your newly mounted partition:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: On a reboot, this change will not be preserved. Later, we'll look at making
    this change permanent with `fstab` and `systemd-mountd`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we carved our physical device (`sdb`) into two partitions, we created them
    using `fdisk`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: First, though, we had to give the disk a partition table, where it could store
    the information about the partitions we're creating.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The classic partition table is called **Master Boot Record** (**MBR**) and the
    new-school one is called **GUID Partition Table** (**GPT**).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: You may still see MBR systems floating around, but GPT is objectively better
    to use these days, allowing for things such as more than four primary partitions
    (which MBR is limited to).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the partitions on a disk by again loading `fdisk` and passing
    `p` on the command line:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These logical spaces can then have a filesystem applied atop them, so that when
    your OS tries to write files to the disk, the disk knows a way to store the data.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Once done, the disk can then be mounted anywhere in the Linux filesystem hierarchy,
    replacing any path you care to.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: This works because Linux doesn't care how many disks are attached to your system,
    or what type of disk they are; all it cares about are the mount points.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing to be aware of is that there are different partition system IDs available
    for different partition types.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of Linux ones that are available on CentOS is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: These IDs are more informative than anything else these days, though historically,
    they might be used for informing a system of specific methods required for reading
    and writing data.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a partition is labelled correctly on an OpenBSD system and then
    the drive it's on is plugged into a Linux system, the Linux system should read
    the ID and realize what it is, preferably not touching the data inside.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Re-configuring a disk using LVM
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to format the second disk in our system, and this time we'll use
    LVM to do so. We'll use the various LVM tools (`lvs`, `pvs`, and `vgs`) to accomplish
    this, before giving the new logical volume we create a filesystem and mounting
    it somewhere on our system.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to use the second disk in our system (it will
    probably be `sdc` on yours).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your `centos1` VM and check that another disk is available to work
    with.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve come straight from the last section, your `lsblk` might look like
    the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We're going to use `sdc` here.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned previously, some people like to first create a partition on their
    drive before introducing it to the LVM lifestyle.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: We'll do that here, but only because I'll end up having a fight with one of
    my technical authors if I don't.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'For an added bit of novelty, we''re going to use `fdisk` without dropping into
    the command''s shell to hammer home the fact that there are several ways of doing
    the same thing in Linux:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We also set our partition's system ID to be 31—that is, Linux LVM.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'To take it one step further, we''re going to apply a partition label to our
    partition, giving it a friendly name:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: PartLabels are insanely useful, though next to no-one uses them! They're also
    only available for GPT disks. They basically mean you can reference a partition
    by name, instead of number or partition UUID. If you ever find yourself using
    ZFS on a USB hard drive, I might have just saved you an aneurysm.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a partition, let''s present it to LVM. First, we have to make
    LVM aware of it, using `pvcreate`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Once done, a `pvs` command will list our new physical device:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Adding it to a volume group is step two, which involves creating the volume
    group too (or we could add it to `VolGroup00`, but for now we''ll make a new one):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Finally, we''re going to create a logical volume within this group, though
    for novelty we''re not going to use all of the available space in the volume group:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Note that now listing our logical volumes with `lvs` shows our new one, which
    is using 50% of the `VolGroup01` space:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Logical volumes can be many things and have various uses. What we have created
    here is a simple linear volume, suitable for day-to-day tasks, but lacking things
    such as redundancy.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: We now have a disk that we can place a filesystem atop, before mounting it somewhere
    on our VM.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a filesystem, we again use `mkfs`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And again, we can `mount` it (creating a mount point first):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`lsblk` can confirm our new setup:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works...
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have created are layers:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: We have our physical disk (`sdc`)
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a partition atop our physical disk (`sdc1`)
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our volume group, with our physical volume inside (`VolGroup01`)
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our logical volume, atop our volume group (`Home3`)
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our filesystem, atop our logical volume, which we then mounted at `/mnt/home3`
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we have complexity, but we also have flexibility.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: What we have done is create a virtual block device, in the form of our logical
    volume. This logical volume will have data written to it and, in turn, will apply
    that data to a physical volume in the volume group, based on decisions by the
    kernel.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created the logical volume, we simply specified that the new device
    should use 50% of the available space, but we could have also suggested a specific
    size in absolute values (for example, 1G).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking why you would use LVM, if we effectively got to the same
    position we were in when we simply placed a filesystem atop a disk partition.
    The answer is: flexibility.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: In LVM-land, you can grow volume groups by adding more physical disks to them,
    you can move data from one physical disk to another (in a running system), and
    you can even shift all data off a drive, before removing that drive in a hotplug
    (or hot unplug) fashion. This relies on your filesystem supporting such changes,
    but modern ones will (allowing you to grow and shrink them on the fly).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the previous, let''s extend our logical volume to use all
    of the available space of the volume group:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note the `+` symbol in front of the `100%` section. This suggests to `lvextend`
    that you want to add the new size onto the old; it's necessary to use all 2G of
    the disk to do so.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: 'Once extended, we still have to grow our filesystem to fit the available space:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To do this, we need to use a `btrfs` command:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And now, we should have our space:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is just one example of the flexibility in LVM, and it offers a boatload
    more functionality on top. It even enables easier migration of data, as you can
    easily import pools onto other systems.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: It does have its trade-offs, though. For example, I was recently trying to get
    a VM booting as quickly as I could (for testing purposes) and ended up disregarding
    LVM as it was quicker to directly access the disks at boot time (in OS, it's not
    different, but for my environment, it was booting speed that mattered).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Using systemd-mount and fstab
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about making sure that our newly configured disks
    appear on boot and how to run a test to see if it'll come up at boot time.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: For this, we'll use the traditional method of adding a disk to the `fstab` file,
    and we'll also use `systemd-mount`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use the following to directly reconfigure `/dev/sdb` as a single
    partition, formatted to `ext4`:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Getting ready
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use both our `sdb` and `sdc` drives.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: If you have rebuilt your VM, have a go at the previous sections to end up with
    a drive that has a simple filesystem atop a partition and one atop a LVM logical
    volume.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Reboot your VM so that you're at a point where you have partitioned drives,
    but they're unmounted.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look something like the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: (Note the lack of mount points by `sdb1` and `VolGroup01-Home3`).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to start with the traditional `fstab` approach.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: fstab
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `fstab` currently looks like this:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We''re going to add another line to the bottom, prompting our `/dev/sdb1` partition
    to mount as `/home`. First, we''re going to get the partition''s UUID, because
    we do not want our `sdb` device to suddenly come up as `sdc` and break our boot:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Cool—now that we have that (`10572fe4-5f65-4df0-9e69-dcd885e9f01e`), we can
    add it:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: What we're doing here is telling `fstab` where our partition is (`UUID`), we're
    telling it where to mount the partition (`/opt`), and we're giving it the filesystem
    format so that it knows how to mount it (`ext4`). Then, we're telling it to use
    the default mount options (`defaults`), which are good enough for most use cases;
    we're specifying that the filesystem doesn't need to be dumped (`0`), and that
    we do not want to run any checks on it at boot (`0`) though in the real world,
    you might want to enable this.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can mount `fstab` immediately with `mount`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Any errors will be immediately obvious, as `mount` will refuse to work.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Running `mount -a` prior to rebooting is preferable to having your system stall
    and become unable to boot—take it from experience.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: systemd-mount
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to be new and trendy, you might want to use `systemd-mount` instead
    of the decrepit (emphasis mine) `fstab`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create our `local` unit directory if it doesn''t already exist from
    our previous chapters:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, populate a new file with the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, we can start and `enable` our `mount`:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'At the end of this section, and after a reboot, your `lsblk` printout should
    look like the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works...
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On `systemd` systems, it's generally the case that `fstab` is managed by `systemd`
    anyway.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s actually happening when a system boots is that the `systemd-fstab-generator`
    reads the `/etc/fstab` file, and translates what it finds there into `systemd`
    units. This is the reason you can list mounts with `systemctl`:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'And this is why we can see the details of a partition with `systemctl cat`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This does beg the question of why you would want to use `fstab` at all, if
    you have the option to use `systemd` entirely, and the simple answer is: tradition.
    At the moment, people expect `fstab` to be the place they go to find `mount` information
    but, in the future, this might change.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your system does fail to boot, following a change to `fstab` or one to your
    `systemd-mount` files, then the next step (beyond panic) is to log in to the console
    of your server. In this case, we do this by connecting to the VirtualBox window
    and connecting to the graphical representation of our console session, before
    booting into single user mode.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: You would then remove the offending line from your configuration and reboot
    your system once more.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: I've caused a system to get stuck at boot more times than I can count, and historically
    this hasn't been a problem, for the reasons I mentioned previously. However, in
    modern cloud environments, you might not always get a console (at the time of
    writing, Azure has only just implemented this feature) so ensuring your `fstab`
    entries are correct, prior to rebooting, is a good idea!
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The `systemd.mount` man page is a good place to look for the mount options that
    `systemd` understands.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`fstab` has been around in one form or another since 4.0 BSD, released in 1980\.
    Obviously, back then, it didn''t use `systemd`, but then, 4.0 BSD did not do much
    of anything.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: I would look at the history of the `fstab` file, if you're into that sort of
    thing, and there's nothing good on TV.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '`_netdev` is something else to be aware of, and I''ll mention it here because
    it''s routinely saved my bacon. It''s an option that can be added to mount points
    (like defaults) and it tells `systemd` that the filesystem is dependent on your
    network being up. For NFS and iSCSI environments, this is probably a must.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Disk encryption and working with encryption at rest
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're going to take a look at using `dm-crypt` to encrypt our disk so
    that the data on the device is safe when removed from a machine. We'll touch on
    file encryption locally, too.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use both our `sdb` drives.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: If you have rebuilt your VM, have a go at the previous sections to end up with
    a drive that has a simple filesystem atop a partition.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'On your VM, first, make sure that any `fstab` entries you''ve added are removed;
    for me, this was a case of running the following `sed` command:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'I then rebooted my system to ensure that `/opt` was not mounted at boot, and
    finally I regenerated the first partition on my disk:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Again, your mileage may vary, but what you want to end up with is a disk that
    has one partition on it, unformatted for now.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to install the appropriate tools for this section:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How to do it...
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, it's recommended that you fill your drive with random data, prior to
    creating an encrypted partition on top of it; this is so that data that wasn't
    encrypted can't be recovered later.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to accomplish this with `shred`:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now that we''ve filled our drive with random data, we have to format our partition
    as a **Linux Unified Key Setup** (**LUKS**), an encryption specification:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: As you can see, there are some sanity-check elements, such as getting you to
    type all uppercase `YES` before you're prompted for a password. The password has
    some requirements, such as being a minimum of 12 characters and not being based
    on a dictionary word.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve created an `encrypted` partition, which we now need to open before we
    can work with it:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Using `lsblk`, you should now see the crypt device:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'So, what do we do with it? We format it with the following:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: You may have noticed that I'm using `btrfs` a lot here; this isn't because of
    some misplaced allegiance to a filesystem format that can't even do RAID correctly,
    instead it's because when I type, I read what I'm typing in my head, and it's
    easier to think "*butter fs*" than it is "*ext*". So now you know; you're welcome.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to mount it:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Congratulations! Your encrypted disk will now function as any other would,
    and you can be safe in the knowledge that, if someone steals your hard drive,
    its contents are locked behind encryption and a password. We can see our setup
    with `lsblk`:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To close an encrypted volume, the filesystem first has to be unmounted:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, you run `cryptsetup` again, only with `luksClose` this time:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: But what if we want to mount our disk on boot?
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Well, first, you should question doing this and consider the ramifications.
    The purpose of encryption is to protect data, and if you set up a disk to come
    up automatically, you're nullifying your security (assuming an entire box has
    been taken, and not just the sole hard drive).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: However, there's an argument to be made that encrypting a drive but having an
    "unlock key" automatically unlock and mount it is still useful if your drive dies
    and you want to send it back to the drive manufacturer for a replacement. Without
    the key, even if they could read the data off the platters, all they get is jumbled
    noise.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's mount `/dev/sdb1` at boot.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the UUID of the encrypted disk; for this, we use `luksUUID` to make
    life easy:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'First, place an entry into `/etc/crypttab`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Second, we need to add our `fstab` entry for our disk:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As we saw previously, this could also be its own `systemd` unit file if you
    so wish.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, create a keyfile to use, with a suitably complex key:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, add this key to our encrypted partition. When prompted for any existing
    passphrase, give the one you gave when first creating the drive:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: At this point, you can reboot your VM and, hopefully (keep an eye on the console
    in VirtualBox), it'll come up seamlessly.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that the encrypted volume can now be opened using either
    your passphrase or the keyfile (shown as follows):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How it works...
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've done here is simply created an encrypted volume; it's yet another
    logical disk, that the system can treat as any other storage medium once it's
    been unlocked.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '`cryptsetup` is the key component used here, and it couldn''t be described
    better than by its own manual page.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: cryptsetup is used to conveniently setup dm-crypt managed device-mapper mappings.
    These include plain dm-crypt volumes and  LUKS  volumes.  The difference is that
    LUKS uses a metadata header and can hence offer more features than plain dm-crypt.
    On the other hand, the header is  visible and vulnerable to damage.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: With `cryptsetup`, we started by formatting the partition we'd set up and setting
    an initial passphrase. This was the `luksFormat` element. Once done, our LUKS
    partition could then be opened, which is the process of passing our assigned passphrase
    to the device, for it to then set up a device mapping automatically. We were then
    able to format our mapped device with a useful filesystem for using natively (`btrfs`
    again) and mount it.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work you do with LUKS devices will be done using `cryptsetup` (at
    least on servers).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, if you try to mount a filesystem on an encrypted drive, without
    knowing or caring that it''s LUKS encrypted, you''ll get a descriptive message
    that should give you a hint:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: At this point, you know you need to run `luksOpen` on the drive first, and you
    might find that you've long since forgotten the password and the data on the disk
    has effectively gone to silicon-heaven (or silicon-purgatory).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we mounted our drive using a keyfile on the root partition;
    if instead you add a line with `none` in it to `crypttab` and then add the entry
    to `fstab`, you will get prompted for a password at boot:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, you need to go to your console and put in your LUKS password, as we can
    see in the following screenshot:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891f95f5-4a00-4233-bdf1-62ef61a04f7a.png)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
- en: This has to be done from the console, as SSH won't be up yet. Obviously, in
    a cloud environment or a physical server build, this can be tricky.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been following along, you might be asking what `systemd` does with
    `crypttab`, if it translates `fstab` into `systemd` units.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that it does something very similar, in fact, using a similarly
    named program at boot-time: `systemd-cryptsetup-generator`.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually see what happened to our encrypted device at boot by catting
    the automatically generated file:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: You can see the `attach` command being run at the bottom.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Current filesystem formats
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There're a lot of filesystem formats out there—some are more popular than others;
    some are used for very specific tasks; some are the darlings of certain operating
    systems; and others simply should have gone away years ago.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows world, we typically see NTFS, but FAT32, exFAT, and even FAT16
    in some cases are still options.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: More recently, Apple has dropped the ageing HFS+ and moved full-steam toward
    APFS as its filesystem of the future.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD defaults to either ZFS (if you've got the RAM for it) or UFS (if you
    haven't).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD—well, OpenBSD uses FFS, which is exactly as good as it sounds.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast File System** (**FFS**) is pretty much UFS.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Linux is a whole other kettle of fish because, not only does it do all of the
    filesystems listed previously, to a greater or lesser degree, it also has hundreds
    of others to pick from.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to see what we have available to us on our VM.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-641
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, you'll just need access to your VM and possibly the internet
    as a whole.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your Vagrant box; this section is purely informational, so don't
    worry about what state it's in for now.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Listing systems you can create is relatively easy, as you can tab `mkfs` a
    couple of times to get a list of established aliases:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Your distribution may have others available, though not installed by default.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I want to manage DOS filesystems, I can install `dosfstools`:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'I''ve suddenly got the `msdos`, `vfat`, and `fat` options:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can also list the filesystems your kernel is capable of interacting with
    by using your current kernel''s module directory:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note that the likes of `ext3` might be managed by an `ext4` module of yours,
    so just because `ext3` isn't listed doesn't mean you can't mount, read, and write
    to an `ext3` drive.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Realistically, it doesn't work.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, we would have one filesystem that worked across each OS
    and was suited for every task, but the truth of the matter is that there's always
    going to be some filesystems that are better at some jobs than others.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Red Hat defaults to using XFS as its filesystem of choice,
    a journaling filesystem that was created in 1993\. Before that, the default was
    the `ext` family of filesystems, which some distributions (such as Debian) continue
    to use.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: OpenSUSE likes `btrfs` at the minute, though how much that's likely to change
    is anyone's guess, especially as the likes of Red Hat have just decided against
    including it in future versions.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: This is also all before getting on to **Filesystem in Userspace** (**FUSE**),
    which is capable of bringing a host of other (userspace) filesystems into the
    mix.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: For now, just be safe in the knowledge that XFS and `ext4` will likely be around
    for a while, and they're a solid choice for any system as long as your needs aren't
    too bespoke. You may need to get a storage engineer in if you're planning on doing
    things such as investigating which filesystem will be best for your new, bespoke,
    database.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: My recommendation is to go with whatever is in use by default.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming filesystem formats
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed the old favorites, such as XFS and `ext4`, but we've only touched
    on the likes of ZFS and novelty filesystems such as `btrfs`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: On top of the regular I-need-a-filesystem-for-my-disk filesystems, there're
    others such as LizardFS and SSHFS, which are worth a mention.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, you'll again need access to your VM and the internet as a
    whole.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your VM, but also have a web browser handy.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting out simple-ish, let's talk about ZFS.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Less of a traditional filesystem than others, ZFS has recently been mainstreamed
    on Linux by being bundled into Ubuntu (which caused a lot of arguing and even
    some claims that Canonical were willfully breaking GPL compliance), and it's causing
    a bit of a stir.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: For years, ZFS was the main reason people installed FreeBSD (don't email me),
    and it's the backbone filesystem for systems based on Solaris or OpenSolaris.
    It works differently to XFS or ext4 and is arguably closer to the LVM world.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Disks are placed into VDEVs, which is the bit that handles the mirroring or
    RAID-ing of drives. These VDEVs then form the basis for zpools, which are storage
    pools that datasets then sit atop (datasets are more like traditional partitions—kinda).
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: ZFS on Linux is the project behind putting ZFS on Linux, and I would advise
    checking them out.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: After ZFS, you've got things such as distributed filesystems, which you might
    mount on your local system using FUSE. LizardFS is one such filesystem.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: You use LizardFS if you want distributed and redundant storage, which can be
    accessed over a network and mounted locally. You can do clever things such as
    store multiple copies of data and even have multi-master setups of the controller
    node so that you have some redundancy in the event of hardware failure (because
    hardware does fail).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'If all of that was over your head, don''t panic: it was over my head for the
    longest time too, but it''s pretty nifty software and worth a weekend to get to
    grips with.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: SSHFS is another FUSE filesystem, only this time it's a bit of software that's
    used to mount remote systems directories locally so that you can mangle and mess
    with them to your heart's content, without being on the command line of the remote
    box.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, it generally doesn't work.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are a deep and interesting topic, for a very dedicated and specific
    kind of people. I've met storage engineers who could talk for hours about the
    different filesystems on offer and why you shouldn't bother using `ext2` as a
    `/boot` partition these days, simply because the trade-offs aren't there, or who
    drone on about the selective merit of using **just a bunch of disk** (**JBOD**)
    deployments versus traditional SANs.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I'll point out that there are use cases for every type of filesystem
    on offer, even WikipediaFS, and that's okay! Just be safe in the knowledge that
    the options are there, if you need them.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Round-up - hardware and disks
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of this chapter, quite unintentionally, turned into a breakdown of disks
    and filesystems. This is because, traditionally, disks were the most likely thing
    to go wrong in your system. Recently, disks don't die anywhere near as much, because
    the advent of cheap and commercially available SSDs has removed the "spinning
    rust" from a lot of systems.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: That said, data can, and will, randomly disappear from your life.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Backup! Backup! Backup!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter how many times I say it—some of you will still read those
    words and think "*yeah, I should do that*" with no intention of ever bothering
    to set something up. For your own systems, that's your choice, but you might at
    least consider it for those boxes you manage, as it'll only make your life easier
    (and you the hero) when you break out the backups after a catastrophic failure
    that threatens to cost your employer millions.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: It should go without saying, but you should make a point of testing your backups
    frequently, or you will enter the faith-based backups situation, and that is not
    somewhere you want to be.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are also getting more confusing and feature-rich. If you compare
    something like `ext2` with `btrfs`, you'll find a wealth of tricks and clever
    things that are designed to make your life easier in the long term, but in the
    short term can leave you with a bewildering array of options.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: People also do silly things in this world, such as deploy RAID5 `btrfs` solutions
    in live environments, without doing basic write-hole checks to ensure they won't
    get any data loss if a disk goes pop (for the full story behind this, do an internet
    search for "`btrfs` raid lol" and you'll probably get some meaningful results).
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, just remember that hardware is out to get you, and you may find
    some dark amusement in that knowledge the next time you're sat in a data center
    at four in the morning, holding a hard drive up to your ear to listen for the
    telltale sound of clicking, as a mechanical head tries and fails to correctly
    read that one important payroll database.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
