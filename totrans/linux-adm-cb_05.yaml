- en: Hardware and Disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk configuration on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filesystem hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a blank disk and mounting it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-configuring a disk using LVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `systemd-mount` and `fstab`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk encryption and working with encryption at rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current filesystem formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upcoming filesystem formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your hardware doesn't care for you, like you might care for it.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware is fickle, temperamental, unpredictable, and moody; disks, the rebellious
    teenager of the hardware family, take this to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: You will find yourself confused at some point in your career, baffled as to
    why seemingly unrelated errors are occurring in disparate parts of your system.
    Your SSH daemon might be randomly dying at odd points in a transfer, NTP might
    be drifting, your database might be locking up, and all the while you're tearing
    your hair out trying to find the cause.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware is usually the answer to these random issues (when it's not time, as
    we discussed previously). A bad stick of memory can fail in weird and wonderful
    ways, while a disk occasionally going read-only can mean sporadic and nighttime-disrupting
    events that can be tempting to resolve with a particularly heavy hammer.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to use the phrase "hit it with a hammer" in front of your
    boss, the accepted nomenclature is "percussive maintenance."
  prefs: []
  type: TYPE_NORMAL
- en: When hardware goes bad, there's no recourse other than to replace it. Gone are
    the days when we'd solder and fix components ourselves, as it's simply not a viable
    solution, nor is it cost-effective.
  prefs: []
  type: TYPE_NORMAL
- en: At some point, you'll discover yourself crouched over an open server in a data
    center, scratching your head at the rows of `DIMMs` and a `RAID10` array of disks,
    trying to determine which one is faulty so that you can swap it out and place
    the old one in a grinder, for your own peace of mind.
  prefs: []
  type: TYPE_NORMAL
- en: We spell storage disks such as hard drives with a k, and optical-type discs
    with a c.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at ways of identifying specific hardware, as well
    as some simple troubleshooting steps for finding bad memory. Coupled with this,
    we'll work through adding new disks to systems and how you might configure them
    once installed.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we''re going to use the following `Vagrantfile`, featuring
    two additional disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The extra disks defined here will be created in the local directory you're running
    Vagrant from, make sure you have enough space.
  prefs: []
  type: TYPE_NORMAL
- en: Determining hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we used `dmidecode` and other tooling to work out if we
    were in a VM or not; here, we're going to go a bit further and try to determine
    what hardware we might be running in a system, from the disk IDs to the type of
    graphics card in use.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect to your Vagrant VM and install some of the extra tools we''re going
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to pick through a few different methods for determining the hardware
    a system is running; even if you don't have access to the internet, you should
    be able to determine some basic information using default tools.
  prefs: []
  type: TYPE_NORMAL
- en: lspci
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tool we installed from the `pciutils` suite, `lspci`, is a good way to list
    your collective PCI devices, without a lot of extra noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just run `lspci`, we get a list of devices and their IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What we can see in the previous list are the devices in our system. They've
    actually had their numeric IDs translated into a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to list the IDs alone, you can use the `-n` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if you want both, use `-nn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this list, we can see a few friendly descriptions to help us—things such
    as `Ethernet controller`, `VGA compatible controller`, and `IDE interface`, to
    name a few.
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, you should get a good understanding of which device does what,
    thanks to the hard work of the people who keep the `PCI ID` repository up to date: [http://pci-ids.ucw.cz/](http://pci-ids.ucw.cz/).
  prefs: []
  type: TYPE_NORMAL
- en: Even better than listing the devices in our system, we can also list the kernel
    drive that's handling the device with `-k`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can see that the Ethernet controller is being
    managed by the kernel driver, `e1000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The name of the kernel driver and the actual hardware won't always be obvious,
    which is what makes tools such as `lspci` so handy.
  prefs: []
  type: TYPE_NORMAL
- en: In modern machines, you might see more than one PCI bus, with devices connected
    to it; it just so happens that our VM only utilizes one bus for all of its devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the tree view is very flat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we run `lspci` against a physical machine (in this case, my laptop),
    the tree view can have more branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can''t see a device you know to be there (a graphics card say), it could
    be a few things: maybe the device is disabled in the BIOS or the card itself is
    dead. Try some basic troubleshooting such as checking the BIOS/UEFI configuration
    or flipping the card to a different slot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also `lsusb` for USB devices. This can be handy if you''re using something
    like a USB Ethernet device. In the following example, you can see that the box
    I''m connected to (a Raspberry Pi) has its network port on the USB bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: lshw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particularly useful program, `lshw` has the built-in ability to output your
    hardware tree as JSON, XML, HTML, and presumably more as they're developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the output of `lshw` is very verbose, but should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I tend to find that at-a-glance solutions can work better a lot of the time.
    So, with that in mind, let''s take a look at the `-short` option''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is much easier to read and means that, at a glance, you can see that the
    system has three disks, one network device, and `512MiB` of system memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 1](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml)*, Introduction
    and Environment Setup*, you can also select a `class` output with `-c`, shown
    again here with our network device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From this output, we can see a lot of pertinent information, such as the capacity
    of the network device (`1Gbit/s`), as well as the capabilities of the device.
  prefs: []
  type: TYPE_NORMAL
- en: We can even see its specific configuration, which is useful for potential changes
    you might want to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see the actual numeric IDs, you can add `-numeric` to your command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: /proc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/proc` is the **process information pseudo-filesystem** found on most Linux
    systems (but not the BSDs).'
  prefs: []
  type: TYPE_NORMAL
- en: It is the readable interface-to-kernel data structure, with some files that
    are writable, allowing for on-the-fly changes to be made to your running kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful files within this directory are the likes of `/proc/cpuinfo`, which,
    when queried, gives you all of the information the kernel knows about your CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It also gives you a processor number, meaning that if you want a quick count
    of processors in your system (being used), you can list them with a short command
    and some piping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''re dumping the file, looking for the word `processor`, and then counting
    the lines. It''s not the most foolproof system, but it''s handy in a pinch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy file to be aware of is `/proc/meminfo` for a complete dump of
    everything the system knows about your memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `/proc` filesystem is pretty sprawling and vast; check out the manual page
    for `proc` if you get a spare moment—you won't regret it in a hurry (you might
    regret it later).
  prefs: []
  type: TYPE_NORMAL
- en: /sys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/sys` or `sysfs` is a filesystem for exporting kernel objects (according to
    its manual page), which means it''s another filesystem for accessing kernel information
    (like `/proc`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be very useful in scripts for doing things such as listing discovered
    block devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It can also be useful for finding the device IDs of an individual component
    (if you don't have `lshw` or `lspci` handy, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I''ve listed the vendor and device IDs of the `eth0` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With this information, I can check the details against a list of devices. I
    chose to check out the `PCI ID` repository, where I learned that the vendor ID
    belongs to the Intel Corporation and the device ID translates to 82540EM Gigabit
    Ethernet Controller.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot more to `/sys` outside the hardware realm, and it can be a good
    idea to research the filesystem in more depth. The manual page (`5`) for `sysfs`
    is a debatable must.
  prefs: []
  type: TYPE_NORMAL
- en: dmesg (and the kernel logs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`dmesg` is a way to print or control the kernel ring buffer according to its
    manual but, to you and me, it''s a great way to quickly see if your hardware was
    detected by the kernel as it''s initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `dmesg` will print to `stdout`, so it''s handy to pipe it into `less`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, you should be able to search for specific strings. Continuing with
    our theme, we''re going to look for `Intel` and see what''s loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look for `ATA`, we can also see our disks being detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s even a `-T` option, to give you human-readable timestamps, which can
    be especially useful, as shown in the following against our IDE (`PATA`) controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: dmidecode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another noisy-but-favorite tool from [Chapter 1](e2264f18-69d3-4ff4-af6c-dc8fe152b3e0.xhtml), I*ntroduction
    and Environment setup*, `dmidecode` decodes the DMI table.
  prefs: []
  type: TYPE_NORMAL
- en: We used it to check for virtual hardware initially, but on a non-virtual machine,
    it can be more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the following `-t processor` dumps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the stark emptiness on our virtual machine, compared with the example
    from my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What this serves to show is that, in some scenarios, more information might
    be gleaned from a physical machine than a virtual one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be said in reverse: if someone is doing everything in their power
    to obfuscate what hardware is running from you, firstly you should suspect you''re
    running on a VM, and then secondly you should wonder why they''re going to such
    great lengths to hide that fact.'
  prefs: []
  type: TYPE_NORMAL
- en: /dev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I had to choose a favorite `pseudo-filesystems`, I would be one odd individual,
    but if you forced me, it would probably be `/dev`.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't because of some love for the word `dev` or some affinity for its
    overuse, but rather because I find myself inside it so often.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all of the `pseudo-filesystems`, they''re transient and temporary (`tmpfs`).
    Don''t do as I once saw a colleague do and store things in them, because the moment
    you reboot your box: poof, your files are gone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, `/dev` looks messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, when you know the know, you'll find it invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s `ls` the `/dev/disk/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Intriguing options—I do like those!
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing the `by-id` option shows us all our disk devices, `by-id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is my absolute favorite, `by-uuid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The main reason I like these is because these entries are actually symlinks
    to the device they''re named for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because of this, I now know that my `sda2` partition has a UUID of `570897ca-e759-4c81-90cf-389da6eee4cc`
    that can be used for various tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious use of the UUID is in most systems'' `fstab` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So, marrying the two pieces of information up, we now have the actual device
    designation (`sda2`) of our `fstab` UUID entry!
  prefs: []
  type: TYPE_NORMAL
- en: The reason UUIDs are used is because device designation can change, historically
    more so than now. On one boot, your `/boot` filesystem might be denoted as `sda2`,
    then on another a different device might be found first, and suddenly `/boot`
    is `sdb2,` breaking `fstab`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we're mostly doing here is checking what the kernel is aware of in terms
    of devices connected to your system.
  prefs: []
  type: TYPE_NORMAL
- en: PCI devices, as well as USB devices, have denotions that are the same across
    all operating systems (you'll see the same Hex values on Windows, Mac, and BSD).
    This allows for the kernel to choose and load the appropriate bit of code, written
    to interact with that same device.
  prefs: []
  type: TYPE_NORMAL
- en: It's rare, but it can happen that one module supersedes an older one or two
    drivers can both be used with the same hardware; in this case, it's useful to
    know your hardware device IDs and the bit of kernel code that's running against
    them.
  prefs: []
  type: TYPE_NORMAL
- en: If you use Linux on the desktop, and use an Nvidia or AMD GPU, there's a high
    chance you'll be interacting with drivers and what the kernel loads, as there's
    both closed source and open source versions to pick from.
  prefs: []
  type: TYPE_NORMAL
- en: Testing hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss methods for testing potentially faulty hardware
    by looking at SMART and disk-testing software, as well as physically troubleshooting
    RAM issues.
  prefs: []
  type: TYPE_NORMAL
- en: Working with disks can be exceptionally risky, and you should always make sure
    that you have working backups before you start anything that might be hazardous
    to your data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're mostly going to be using the Vagrant box we've created, but you
    may also want to take a look at Memtest86+ from [http://www.memtest.org/](http://www.memtest.org/),
    which I mention for memory testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to your VM and install `smartmontools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You might also want to download the latest Memtest86+ ISO.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by looking at disk health.
  prefs: []
  type: TYPE_NORMAL
- en: Self-monitoring, analysis, and reporting technology (SMART)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, it''s a good idea to make sure that `smartd` is running on whichever
    system you want to query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`smartd` is the monitoring daemon for SMART; the daemon attempts to enable
    monitoring on compatibly `ATA` devices when it starts and, by default, polls the
    `ATA` devices every 30 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, errors detected by `smartd` as part of its periodic work are logged
    using the `SYSLOG` interface. It can also email out to an administrator if configured
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once enabled, disks can then be queried with the `smartctl` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `sudo` and the denoting of a disk device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, because we''re in a VirtualBox VM, this won''t give us anything useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: However, if you tried this on a physical machine, results differ and more information
    can be gleaned.
  prefs: []
  type: TYPE_NORMAL
- en: hdparm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible that your disks are reporting back fine to your SMART commands,
    but you're still seeing some form of slowdown or other issues.
  prefs: []
  type: TYPE_NORMAL
- en: You can benchmark a disk's read with the `hdparm` tool (available in the default
    repositories).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the speeds of our disk using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The manual page for `hdparm` suggests doing these tests two or three times for
    average results and running them on otherwise inactive systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your mileage may vary, but the results from my system look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Partly, we have a problem here, because what we''re actually doing is reading
    from the kernel''s page cache. We can bypass this using the `--direct` option,
    which reads directly from the drive into buffers of `hdparm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'These results are more raw disk read performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Memory testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory is a little easier to test, though the most thorough way of checking
    every inch of your DIMMs is to take the box offline for a few hours while you
    run Memtest86+.
  prefs: []
  type: TYPE_NORMAL
- en: Programs such as **memtester** also exist, which can be executed on a running
    system. The problem with these types of test is that they won't test memory already
    in use by the system, and they can end up fighting processes such as the **Out
    Of Memory** (**OOM**) killer.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the ISO image from the Memtest86+ website, you can attach it to
    your VM and boot into the program (completely independently of CentOS).
  prefs: []
  type: TYPE_NORMAL
- en: 'It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d3d476a-10bb-4225-98b7-004988bbf141.png)'
  prefs: []
  type: TYPE_IMG
- en: Any errors will show up in the bottom half of the screen, and you'll know you
    have bad memory.
  prefs: []
  type: TYPE_NORMAL
- en: I used to let Memtest86+ do five passes over the memory I was testing when I
    used it every night during my data center days.
  prefs: []
  type: TYPE_NORMAL
- en: If you find that your system won't boot at all, but you suspect memory problems,
    it can be a good idea to test in a binary fashion. By this, I mean that if your
    server has 128 sticks of memory (not uncommon), you should remove 64 of them and
    test the remaining batch. If your server boots, you know your faulty stick is
    somewhere in the 64 you removed. If your server doesn't boot, your faulty stick
    is somewhere in the batch that you left inside.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this technique, halving the memory you check each time, until you're
    down to two DIMMs, one of which you know to be faulty, and then test each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in the previous fashion may sound obvious, but at two o'clock in the
    morning, when you can't think straight, having read these words might save your
    sanity.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMART reads information by querying the `/dev/` device you target and displaying
    what it's learned about a SMART-compatible device.
  prefs: []
  type: TYPE_NORMAL
- en: When we're using `hdparm`, we're actually running tests regardless of our filesystem,
    because the program reads from the disk directly—because of this, real-world speed
    may be different.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I didn't include testing graphics cards and things of that nature in this section
    because it's usually quite easy to tell when a graphics card is on the way out
    (graphical glitches, random lines, and occasional beeps).
  prefs: []
  type: TYPE_NORMAL
- en: I also didn't mention physical RAID cards, because there's such an abundance
    that it would be impossible to list a coherent method for all of them. The best
    advice I can give for physical RAID cards is to check out the manufacturer's details
    on testing.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't cover write tests for disks, partly because it's usually pretty obvious
    to tell disk issues from read tests alone, and partly because a lot of the methods
    of testing writes can be destructive if done incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to watch the kernel running through its startup process, as well
    as look at which modules have been loaded by the time we get to the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this section, ensure your VM is up and running, as we''re going to talk
    about hardware initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Connect to your VM. If you've just come off the previous section, you may want
    to destroy and recreate your VM to ensure a vanilla experience.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we're going to watch our system boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by disabling the `quiet` option in our boot configuration so that we
    can actually see information on our VM display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to generate a new `grub` configuration file, as we''ve made a
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is a good example of what you would do if someone asked you
    to make a `grub` configuration change, a surprisingly common action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, bring up the VirtualBox main window, and double-click your VM so, you
    can see the black console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08f1ae2c-f11c-49ac-aaf9-f0c661ad950b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Bring up your Terminal connection so that you can see both and reboot your
    VM with the `reboot` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep your eyes on the VirtualBox window; you should see something like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae417e9b-2ac0-46dc-b333-34abc9562b23.png)'
  prefs: []
  type: TYPE_IMG
- en: Did you note that scrolling information? It probably flew by too fast for you
    to read, but it's your system working through initializing itself.
  prefs: []
  type: TYPE_NORMAL
- en: You can close your VirtualBox window now and continue in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in reading back through what you just saw, you might remember
    the `dmesg` command we used previously; everything you've just seen is available
    to view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re in a running system again, we can see which modules the kernel
    has loaded to deal with our hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of modules!
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, some of these modules will be obvious, and more still
    won't be.
  prefs: []
  type: TYPE_NORMAL
- en: An obvious one from that list might be `e1000` because we already know that's
    our network module from an earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get specific information about a module using `modinfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code not only gives us the version of the module and the license,
    but the author and their information for contacting purposes (usually bug reports).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to remove a module that''s in use, you won''t be allowed, as seen
    in the following `modprobe` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you want to load a new module (maybe because you want to test
    it), you can again use `modprobe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then see our loaded module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Loading a module on boot is a different matter, as it requires a configuration
    file if not built in to the kernel (and kernel options are usually generic so
    that vendors can cover as many bases as possible without causing problems).
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure `nf_tables` starts with the rest of our kernel, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Reboot and use `lsmod` to see whether your module has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your system boots, several things happen in sequence, and these vary slightly
    depending on trivial differences (such as which bootloader you're using, though
    mostly it's Grub these days).
  prefs: []
  type: TYPE_NORMAL
- en: One of these things is that the kernel extracts itself and loads, before handing
    over control to the `init` system (`systemd`).
  prefs: []
  type: TYPE_NORMAL
- en: While the kernel is loading, it also detects hardware in the system and adds
    the appropriate module to its running state so that hardware can be correctly
    interacted with and managed.
  prefs: []
  type: TYPE_NORMAL
- en: When we list modules with `lsmod`, we're actually just printing `/proc/modules` in
    a more readable format.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can dynamically load and unload modules, as well as manually blacklist certain
    ones from loading at all.
  prefs: []
  type: TYPE_NORMAL
- en: This can come in handy if you have a particular piece of hardware that's faulty,
    and/or causes a Kernel Panic (the kernel ceasing to function entirely and crashing).
  prefs: []
  type: TYPE_NORMAL
- en: 'To blacklist a module, it''s simply a case of adding it to a blacklist in `/etc/modprobe.d/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, I blacklisted `e1000`. Clearly, this is going to cause
    me problems as it means my network card won't have appropriate drivers at boot,
    but it made the system more secure!
  prefs: []
  type: TYPE_NORMAL
- en: Disk configuration on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at the out-of-the-box configuration of
    the disks in our VM and discuss the differences between `vda`, `sda`, `hda`, and
    `nvme`. We're also going to investigate the difference between disks, virtual
    disks, partitions, and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're going to be using the Vagrant box we created at the beginning of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure your `centos1` VM is up and connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Check that your VM has the appropriate packages for this section installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start by looking at the physical disks in our system and work out how
    they relate to what we can see with the `df` command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing disks with lsblk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of your base system, a program called `lsblk` should be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program gives you a human-readable tree view of our system''s
    block devices, their logical separations, and their mount points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A block device is basically a layer of abstraction atop a storage medium; character
    (raw) devices allow direct access to the storage medium, but may have restrictions
    applied that are abstracted away by using a block device instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we have our physical disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sda`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sdc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then have our partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sda1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sda2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sda3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have our volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VolGroup00`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have logical volumes atop our singular volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LogVol00`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogVol01`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have our mount points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/boot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[SWAP]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing mount points with df
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the rough disk layout of our system, we might want to know
    all of the other mount points, too. This is easily achieved with a program called
    `df`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For better, human-readable output, we can use `-h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the mount points we already know about from the previous section,
    those being `/` and `/boot`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see other mount points, specifically those tagged with the `devtmpfs`
    and `tmpfs` filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: These mount points are mounted atop RAM disks—a concept that's been around for
    years, but which we still use because RAM is just so damn quick (considerably
    faster than SSDs at the moment).
  prefs: []
  type: TYPE_NORMAL
- en: Temporary directories are those that contain files we don't care about preserving
    across reboots (for the most part).
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, the mount points you will be concerned with day-to-day are those that
    contain non-transient files.
  prefs: []
  type: TYPE_NORMAL
- en: Listing filesystems with df
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as knowing which of your disks is mounted where, you might also want
    to know which filesystem is being used atop the chunk of space; this is done with
    the `-T` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can easily see that our slash-root mount point (`/`) and boot mount
    point are formatted as XFS.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS and Red Hat prefer to use XFS at present, but it's not uncommon to come
    across systems using `ext4`, `ext3`, `ext2`, `btrfs`, and `zfs`, to name a few.
    Functionally, there are differences, but for day-to-day activities, they all handle
    writing and reading files, which is the important bit.
  prefs: []
  type: TYPE_NORMAL
- en: Listing logical volume manager disks, volume groups, and logical volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using LVM (which we are by default, and which a lot of systems do),
    you may want to know the layout of your disks that are being handled by LVM.
  prefs: []
  type: TYPE_NORMAL
- en: Physical disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we need to know which physical volumes LVM is aware of; this is accomplished
    with `pvs` or `pvdisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note how `sudo pvs` is a more traditional, `unix-y` output, whereas the second
    is more intended for human parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the only physical device LVM is aware of is the `sda3`
    partition atop the `sda` device.
  prefs: []
  type: TYPE_NORMAL
- en: A physical volume in LVM land can be either an entire device (`sda`) or a partition
    on that device (`sda3`). Generally, which one is used is down to the system administrator's
    personal preference, as there are both pros and cons to both methods. Personally,
    I prefer to give the whole device to LVM and let it do all of the work, removing
    a layer of abstraction, but I've known people who swear by carving up the disk
    into partitions before LVM even gets a say.
  prefs: []
  type: TYPE_NORMAL
- en: Volume groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can have more than one physical volume grouped together in a volume group;
    later, this allows for flexibility in terms of the logical volumes that sit on
    top.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a printout when using `pvs` and `pvdisplay` that tells you the
    volume group that the disk is a part of, but if you want to only list the volume
    group information, `vgs` and `vgdisplay` can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that there are two logical volumes atop this volume group.
  prefs: []
  type: TYPE_NORMAL
- en: Logical volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, in the LVM stack, we have the logical volumes. These are the logical
    devices that the filesystems get applied to, and which can then be mounted at
    a point on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Have you worked out the logic behind the command naming?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, we will use `lvs` and `lvdisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There are two logical volumes!
  prefs: []
  type: TYPE_NORMAL
- en: We know that one of them is sitting under our slash-root and, thanks to `lsblk`
    earlier, we know that the second is providing our swap space.
  prefs: []
  type: TYPE_NORMAL
- en: Listing swap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swap is special, and it's more like extended, slow, and somewhat annoying memory
    than it is disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Swap is used when your system's RAM is full, and the kernel starts to offload
    infrequently accessed memory onto the disk, where it can be read back at a much
    slower rate.
  prefs: []
  type: TYPE_NORMAL
- en: Is it time for another holy war? I think it is! Some systems administrators
    swear by swap and will always make sure their system has at least a few megabytes
    of space to swap into, even if they've got 256 GB of RAM; other systems administrators
    say that, if you're using that much RAM and still swapping, you need more RAM.
    Smile and nod if you're not the person making the decision about whether or not
    to even have swap—it's not worth it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list what swap our system is using with `swapon`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see our one swap device is `/dev/dm-1`, but we think it's an LVM
    device? That can't be right.
  prefs: []
  type: TYPE_NORMAL
- en: But it can!
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical volumes are actually mapped; `dm-1` is a low-level representation of
    our logical volume. Running `ls -l` on our logical volume device proves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Our device is actually linked and mapped to `dm-1`, which is why it's listed
    as it is in our `swapon` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physically, you have a disk.
  prefs: []
  type: TYPE_NORMAL
- en: This disk can be a hard disk drive (the old-school spinning platter type) or
    a solid state drive of some sort, be it `NVMe` on an M.2 connector or generic
    SATA.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the type of disk, you want to use it for storage.
  prefs: []
  type: TYPE_NORMAL
- en: To store data on the disk, it needs to have some things. First, it needs to
    be readable by the OS; this bit is handled by the kernel. If the kernel determines
    the disk to be an IDE drive (uncommon), it'll probably show as an `hda` device.
  prefs: []
  type: TYPE_NORMAL
- en: If the disk is SATA or SCSI, it might show up as an `sda` device. If it's a
    virtio virtual disk, and shows as such to the virtual machine, it will be listed
    as `vda`.
  prefs: []
  type: TYPE_NORMAL
- en: The disk lettering is sequential, which is why our three disks show up as `sda`,
    `sdb`, and `sdc`.
  prefs: []
  type: TYPE_NORMAL
- en: This lettering doesn't have to be consistent; the disks are assigned their denotion
    at boot-time, meaning your computer can come up with its first disk as `sdb` one
    day and `sda` another, because of various factors. The way around this is to use
    disk UUIDs (seen in `fstab` earlier) or labels.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, after the operating system recognizes that a disk exists, it has to
    check for partitions and filesystems. Partitions are a segment of a disk, and
    filesystems are the recipe for how files are read and written to the drive.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we started out with `lsblk`,  which we used to query the `sysfs`
    filesystem and the `udev` database, before displaying it in a human-readable way.
    Generally, this is my first stop when trying to determine what a system looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we had a look at mount points and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Mount points are the area of the Linux hierarchy to which disks are assigned.
    Unlike Windows, where the structure starts at the disk, on Linux, the structure
    is set and the disks fit in (flipping the Windows model on its head).
  prefs: []
  type: TYPE_NORMAL
- en: It's a little hard to visualize the Linux hierarchy of mount points and filesystems,
    but the important thing to remember is that everything starts at root (that is,
    slash-root or `/`) and builds from there. You could have one disk, with one partition,
    and put slash-root on that partition, hence making the simplest system possible.
    Or, you could put your home directories (`/home`) on a physical disk of its own,
    but it would still exist as `/home`, one step above slash-root.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the logical layout of the Linux hierarchy as the absolute, with the
    disks almost an irrelevant piece of the puzzle. If you really felt like it, you
    could mount a bit of the filesystem at `/home/me/favourite_things/pokemon/absol`,
    entirely on one disk.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are a bit more obvious and generally static (unless you're a system
    administrator who really wants to live on the wild side). Once you've carved out
    a section of disk that you want to use (say to mount `/home` on), you decide on
    a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: It's best to go with a typical one in a work environment, something like XFS
    or `ext4`, rather than an experimental one, like `btrfs`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of your storage-creating adventure, you've got a disk, with a `partition`,
    which has the `ext4` filesystem atop, and which you've mounted at `/home`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '...There''s so much more!'
  prefs: []
  type: TYPE_NORMAL
- en: The world of filesystems is an ever-evolving and ever-changing one. You'd have
    thought that, by now, we'd have data storage licked, but you would be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: There are some filesystems that are better suited for thousands of small files
    (for example, databases) and some that are better suited for massive blocks of
    files (such as VM disks). Which one you choose to use is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: There are de-duplicating, snapshotting, and even self-healing (apparently) filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD swears by ZFS, which is also shipped in Ubuntu in the Linux world. OpenSUSE
    favors `btrfs` for a lot of its new installations, and some distributions keep
    with the classics, shipping the `ext` family for familiarity reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever you decide to use, be sure to keep backups—backups are important.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss `hier` and `man hier` as a way of determining
    what your filesystem's different names mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at your system, you might question why certain folders are named
    in the way they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What's `sbin` or `opt`?
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also be curious as to know why there''s a folder called `root` when
    we''re supposed to be in the root of the system, `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The filesystem hierarchy has the answers you want!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is going to use our lone VM.
  prefs: []
  type: TYPE_NORMAL
- en: If not already connected, connect to your VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to directly reference a man page, so ensure that your man
    pages are installed with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To discern how your distribution maintainer thinks the distribution filesystem
    should look, run `man hier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The manual page should open in your default pager (usually `less`) and can be
    navigated as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you should see is something akin to the following—a list of paths, with
    a description next to each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb37f69-8cd3-4a23-b2a2-78af79e5b2cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Linux Manual Hier Page
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This manual page is important, and there's no guarantee that it'll be consistent
    across the systems that you manage (that is, Debian and CentOS might look distinctly
    unfamiliar).
  prefs: []
  type: TYPE_NORMAL
- en: 'What it should be is the distribution maintainer''s understanding of where
    specific files go on this distribution. So, according to this manual page, that
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"/bin  This directory contains executable programs which are needed in single
    user mode and to bring the system up or repair it."'
  prefs: []
  type: TYPE_NORMAL
- en: 'That one is fairly obvious, but what if we want a directory for add-on packages?
    `hier` for CentOS has you covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '"/opt   This directory should contain add-on packages that contain static files."'
  prefs: []
  type: TYPE_NORMAL
- en: 'How about if you see a path, and you''re not sure what it''s for, such as `/usr/games`?
    See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"  /usr/games Binaries for games and educational programs (optional)."'
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, one directory that's omitted from the CentOS-supplied `hier` manual
    is `/srv`, and it's one I use quite frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken from the Ubuntu `hier` manual, we can see its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '"/srv   This directory contains site-specific data that is served by this system."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good example of how different systems might put files in different
    places, and it''s a good place to clear up confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '"       /      This is the root directory. This is where the whole tree starts.'
  prefs: []
  type: TYPE_NORMAL
- en: <SNIP>
  prefs: []
  type: TYPE_NORMAL
- en: /root  This directory is usually the home directory for the root user (optional)."
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the bottom of your system''s `hier` manual, you might see a reference to
    The Filesystem Hierarchy Standard, available at [http://www.pathname.com/fhs/](http://www.pathname.com/fhs/).
    This standard is, according to the manual, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The filesystem standard has been designed to be used by Unix distribution
    developers, package developers, and system implementors. However, it is primarily
    intended to be a reference and is not a tutorial on how to manage a Unix filesystem
    or directory hierarchy."'
  prefs: []
  type: TYPE_NORMAL
- en: This in itself isn't very helpful because it effectively says "*these are more
    guidelines than rules*", a la *Pirates of the Caribbean*.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, use `man hier` as a good rule of thumb for working out how a system
    is laid out, but don't assume some narcissistic system administrator hasn't come
    along and put Terraform in `/usr/local/sbin` just to be awkward.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a blank disk and mounting it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use CLI tools to partition and format one of our disks
    (without LVM), talking about GPT and MBR while we do so. We'll then mount our
    disk at `/home` on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using the supplied `Vagrantfile` for this chapter, you'll have a system
    with two blank disks connected. If you're using your own solution, now would be
    the time to add a couple of blank disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to your VM and ensure you can see `/dev/sdb`; if you can''t, double
    check your Vagrant setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to partition our disk. Here, we're going to create two partitions
    of half the disk each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by using `fdisk` against `/dev/sdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You'll be dropped into a different shell, that of `fdisk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create `GPT disklabel` by typing `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create a new partition, with a partition number of `1`, a first
    sector of `2048`, and of the size 1 GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by pressing `n` and *Enter*, accepting the defaults of the first
    two prompts (by pressing *Enter* without input) and typing `+1G` when prompted
    for `Last sector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use `n` again to create a second partition although this time we''re
    going to accept the defaults each time (hit *Enter* thrice) because we want to
    use the rest of the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ve got our partitions laid out as we want, we need to write the table
    to the disk and exist `fdisk`. Do this with `w`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: These days, systems are pretty good about automatically re-reading the partition
    table changes of a device, though occasionally you might still need to run `partprobe`
    to inform your kernel of any changes manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `lsblk` should now show our new partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have two partitions, we're going to format them with a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of this tutorial, we''re going to format one as `ext4`, and one
    as XFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You will be presented with various bits of information, but hopefully the format
    should be done quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For partition two, we''re going to use just the `mkfs` command, which lacks
    the implied type of using `mkfs.ext4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a new tool here (`blkid`) to print the UUID and `TYPE` of these
    partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's a good practice to copy over files from the location you're hoping
    to mount atop, prior to replacing it with your new filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at `/home` at the moment, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If we mount one of our filesystems at `/home` and `ls` again, it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Our Vagrant user's home folder has vanished!
  prefs: []
  type: TYPE_NORMAL
- en: The `lost+found` folder is a function of `fsck` (the filesystem repair utility)
    and is the dumping ground for pieces of files that it can't make head nor tail
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we mounted a system over the top of the old location; if we
    unmount this new filesystem and `ls` the directory again, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: So, what we really need to do is copy over all existing data (preserving ownership
    and rights) before writing atop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder in `/mnt` (a standard place to do such things),
    mounting our new filesystem, and copying the data over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the previous, we used `-r` to recursively copy and `--preserve=all` to preserve
    things such as the SELinux context of the files, alongside the ownership and timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check your results by confirming the Vagrant user''s SSH `authorized_keys`
    file still has the permissions, `-rw-------`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `umount` the filesystem from our temporary location and mount it over
    the top of the previous `/home`, making sure we''re not in `/home` first (by moving
    to a different directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We move to the root of the filesystem (`/`) on purpose, to avoid the device
    being busy and causing complications, though this is more of an issue when trying
    to unmount a filesystem that you're still sitting in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `df` should now show your newly mounted partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: On a reboot, this change will not be preserved. Later, we'll look at making
    this change permanent with `fstab` and `systemd-mountd`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we carved our physical device (`sdb`) into two partitions, we created them
    using `fdisk`.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, we had to give the disk a partition table, where it could store
    the information about the partitions we're creating.
  prefs: []
  type: TYPE_NORMAL
- en: The classic partition table is called **Master Boot Record** (**MBR**) and the
    new-school one is called **GUID Partition Table** (**GPT**).
  prefs: []
  type: TYPE_NORMAL
- en: You may still see MBR systems floating around, but GPT is objectively better
    to use these days, allowing for things such as more than four primary partitions
    (which MBR is limited to).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the partitions on a disk by again loading `fdisk` and passing
    `p` on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: These logical spaces can then have a filesystem applied atop them, so that when
    your OS tries to write files to the disk, the disk knows a way to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: Once done, the disk can then be mounted anywhere in the Linux filesystem hierarchy,
    replacing any path you care to.
  prefs: []
  type: TYPE_NORMAL
- en: This works because Linux doesn't care how many disks are attached to your system,
    or what type of disk they are; all it cares about are the mount points.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing to be aware of is that there are different partition system IDs available
    for different partition types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of Linux ones that are available on CentOS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: These IDs are more informative than anything else these days, though historically,
    they might be used for informing a system of specific methods required for reading
    and writing data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a partition is labelled correctly on an OpenBSD system and then
    the drive it's on is plugged into a Linux system, the Linux system should read
    the ID and realize what it is, preferably not touching the data inside.
  prefs: []
  type: TYPE_NORMAL
- en: Re-configuring a disk using LVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to format the second disk in our system, and this time we'll use
    LVM to do so. We'll use the various LVM tools (`lvs`, `pvs`, and `vgs`) to accomplish
    this, before giving the new logical volume we create a filesystem and mounting
    it somewhere on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to use the second disk in our system (it will
    probably be `sdc` on yours).
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your `centos1` VM and check that another disk is available to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve come straight from the last section, your `lsblk` might look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We're going to use `sdc` here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned previously, some people like to first create a partition on their
    drive before introducing it to the LVM lifestyle.
  prefs: []
  type: TYPE_NORMAL
- en: We'll do that here, but only because I'll end up having a fight with one of
    my technical authors if I don't.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an added bit of novelty, we''re going to use `fdisk` without dropping into
    the command''s shell to hammer home the fact that there are several ways of doing
    the same thing in Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: We also set our partition's system ID to be 31—that is, Linux LVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To take it one step further, we''re going to apply a partition label to our
    partition, giving it a friendly name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: PartLabels are insanely useful, though next to no-one uses them! They're also
    only available for GPT disks. They basically mean you can reference a partition
    by name, instead of number or partition UUID. If you ever find yourself using
    ZFS on a USB hard drive, I might have just saved you an aneurysm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a partition, let''s present it to LVM. First, we have to make
    LVM aware of it, using `pvcreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, a `pvs` command will list our new physical device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding it to a volume group is step two, which involves creating the volume
    group too (or we could add it to `VolGroup00`, but for now we''ll make a new one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re going to create a logical volume within this group, though
    for novelty we''re not going to use all of the available space in the volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that now listing our logical volumes with `lvs` shows our new one, which
    is using 50% of the `VolGroup01` space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Logical volumes can be many things and have various uses. What we have created
    here is a simple linear volume, suitable for day-to-day tasks, but lacking things
    such as redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a disk that we can place a filesystem atop, before mounting it somewhere
    on our VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a filesystem, we again use `mkfs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we can `mount` it (creating a mount point first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`lsblk` can confirm our new setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have created are layers:'
  prefs: []
  type: TYPE_NORMAL
- en: We have our physical disk (`sdc`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a partition atop our physical disk (`sdc1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our volume group, with our physical volume inside (`VolGroup01`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our logical volume, atop our volume group (`Home3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our filesystem, atop our logical volume, which we then mounted at `/mnt/home3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that we have complexity, but we also have flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: What we have done is create a virtual block device, in the form of our logical
    volume. This logical volume will have data written to it and, in turn, will apply
    that data to a physical volume in the volume group, based on decisions by the
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we created the logical volume, we simply specified that the new device
    should use 50% of the available space, but we could have also suggested a specific
    size in absolute values (for example, 1G).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be asking why you would use LVM, if we effectively got to the same
    position we were in when we simply placed a filesystem atop a disk partition.
    The answer is: flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: In LVM-land, you can grow volume groups by adding more physical disks to them,
    you can move data from one physical disk to another (in a running system), and
    you can even shift all data off a drive, before removing that drive in a hotplug
    (or hot unplug) fashion. This relies on your filesystem supporting such changes,
    but modern ones will (allowing you to grow and shrink them on the fly).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of the previous, let''s extend our logical volume to use all
    of the available space of the volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note the `+` symbol in front of the `100%` section. This suggests to `lvextend`
    that you want to add the new size onto the old; it's necessary to use all 2G of
    the disk to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once extended, we still have to grow our filesystem to fit the available space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, we need to use a `btrfs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we should have our space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This is just one example of the flexibility in LVM, and it offers a boatload
    more functionality on top. It even enables easier migration of data, as you can
    easily import pools onto other systems.
  prefs: []
  type: TYPE_NORMAL
- en: It does have its trade-offs, though. For example, I was recently trying to get
    a VM booting as quickly as I could (for testing purposes) and ended up disregarding
    LVM as it was quicker to directly access the disks at boot time (in OS, it's not
    different, but for my environment, it was booting speed that mattered).
  prefs: []
  type: TYPE_NORMAL
- en: Using systemd-mount and fstab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about making sure that our newly configured disks
    appear on boot and how to run a test to see if it'll come up at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we'll use the traditional method of adding a disk to the `fstab` file,
    and we'll also use `systemd-mount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use the following to directly reconfigure `/dev/sdb` as a single
    partition, formatted to `ext4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use both our `sdb` and `sdc` drives.
  prefs: []
  type: TYPE_NORMAL
- en: If you have rebuilt your VM, have a go at the previous sections to end up with
    a drive that has a simple filesystem atop a partition and one atop a LVM logical
    volume.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot your VM so that you're at a point where you have partitioned drives,
    but they're unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: (Note the lack of mount points by `sdb1` and `VolGroup01-Home3`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to start with the traditional `fstab` approach.
  prefs: []
  type: TYPE_NORMAL
- en: fstab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `fstab` currently looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to add another line to the bottom, prompting our `/dev/sdb1` partition
    to mount as `/home`. First, we''re going to get the partition''s UUID, because
    we do not want our `sdb` device to suddenly come up as `sdc` and break our boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool—now that we have that (`10572fe4-5f65-4df0-9e69-dcd885e9f01e`), we can
    add it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is telling `fstab` where our partition is (`UUID`), we're
    telling it where to mount the partition (`/opt`), and we're giving it the filesystem
    format so that it knows how to mount it (`ext4`). Then, we're telling it to use
    the default mount options (`defaults`), which are good enough for most use cases;
    we're specifying that the filesystem doesn't need to be dumped (`0`), and that
    we do not want to run any checks on it at boot (`0`) though in the real world,
    you might want to enable this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can mount `fstab` immediately with `mount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Any errors will be immediately obvious, as `mount` will refuse to work.
  prefs: []
  type: TYPE_NORMAL
- en: Running `mount -a` prior to rebooting is preferable to having your system stall
    and become unable to boot—take it from experience.
  prefs: []
  type: TYPE_NORMAL
- en: systemd-mount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to be new and trendy, you might want to use `systemd-mount` instead
    of the decrepit (emphasis mine) `fstab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create our `local` unit directory if it doesn''t already exist from
    our previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, populate a new file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start and `enable` our `mount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this section, and after a reboot, your `lsblk` printout should
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On `systemd` systems, it's generally the case that `fstab` is managed by `systemd`
    anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s actually happening when a system boots is that the `systemd-fstab-generator`
    reads the `/etc/fstab` file, and translates what it finds there into `systemd`
    units. This is the reason you can list mounts with `systemctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is why we can see the details of a partition with `systemctl cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This does beg the question of why you would want to use `fstab` at all, if
    you have the option to use `systemd` entirely, and the simple answer is: tradition.
    At the moment, people expect `fstab` to be the place they go to find `mount` information
    but, in the future, this might change.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your system does fail to boot, following a change to `fstab` or one to your
    `systemd-mount` files, then the next step (beyond panic) is to log in to the console
    of your server. In this case, we do this by connecting to the VirtualBox window
    and connecting to the graphical representation of our console session, before
    booting into single user mode.
  prefs: []
  type: TYPE_NORMAL
- en: You would then remove the offending line from your configuration and reboot
    your system once more.
  prefs: []
  type: TYPE_NORMAL
- en: I've caused a system to get stuck at boot more times than I can count, and historically
    this hasn't been a problem, for the reasons I mentioned previously. However, in
    modern cloud environments, you might not always get a console (at the time of
    writing, Azure has only just implemented this feature) so ensuring your `fstab`
    entries are correct, prior to rebooting, is a good idea!
  prefs: []
  type: TYPE_NORMAL
- en: The `systemd.mount` man page is a good place to look for the mount options that
    `systemd` understands.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`fstab` has been around in one form or another since 4.0 BSD, released in 1980\.
    Obviously, back then, it didn''t use `systemd`, but then, 4.0 BSD did not do much
    of anything.'
  prefs: []
  type: TYPE_NORMAL
- en: I would look at the history of the `fstab` file, if you're into that sort of
    thing, and there's nothing good on TV.
  prefs: []
  type: TYPE_NORMAL
- en: '`_netdev` is something else to be aware of, and I''ll mention it here because
    it''s routinely saved my bacon. It''s an option that can be added to mount points
    (like defaults) and it tells `systemd` that the filesystem is dependent on your
    network being up. For NFS and iSCSI environments, this is probably a must.'
  prefs: []
  type: TYPE_NORMAL
- en: Disk encryption and working with encryption at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're going to take a look at using `dm-crypt` to encrypt our disk so
    that the data on the device is safe when removed from a machine. We'll touch on
    file encryption locally, too.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use both our `sdb` drives.
  prefs: []
  type: TYPE_NORMAL
- en: If you have rebuilt your VM, have a go at the previous sections to end up with
    a drive that has a simple filesystem atop a partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your VM, first, make sure that any `fstab` entries you''ve added are removed;
    for me, this was a case of running the following `sed` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'I then rebooted my system to ensure that `/opt` was not mounted at boot, and
    finally I regenerated the first partition on my disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Again, your mileage may vary, but what you want to end up with is a disk that
    has one partition on it, unformatted for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need to install the appropriate tools for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, it's recommended that you fill your drive with random data, prior to
    creating an encrypted partition on top of it; this is so that data that wasn't
    encrypted can't be recovered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to accomplish this with `shred`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve filled our drive with random data, we have to format our partition
    as a **Linux Unified Key Setup** (**LUKS**), an encryption specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are some sanity-check elements, such as getting you to
    type all uppercase `YES` before you're prompted for a password. The password has
    some requirements, such as being a minimum of 12 characters and not being based
    on a dictionary word.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve created an `encrypted` partition, which we now need to open before we
    can work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `lsblk`, you should now see the crypt device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what do we do with it? We format it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that I'm using `btrfs` a lot here; this isn't because of
    some misplaced allegiance to a filesystem format that can't even do RAID correctly,
    instead it's because when I type, I read what I'm typing in my head, and it's
    easier to think "*butter fs*" than it is "*ext*". So now you know; you're welcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to mount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! Your encrypted disk will now function as any other would,
    and you can be safe in the knowledge that, if someone steals your hard drive,
    its contents are locked behind encryption and a password. We can see our setup
    with `lsblk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To close an encrypted volume, the filesystem first has to be unmounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you run `cryptsetup` again, only with `luksClose` this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: But what if we want to mount our disk on boot?
  prefs: []
  type: TYPE_NORMAL
- en: Well, first, you should question doing this and consider the ramifications.
    The purpose of encryption is to protect data, and if you set up a disk to come
    up automatically, you're nullifying your security (assuming an entire box has
    been taken, and not just the sole hard drive).
  prefs: []
  type: TYPE_NORMAL
- en: However, there's an argument to be made that encrypting a drive but having an
    "unlock key" automatically unlock and mount it is still useful if your drive dies
    and you want to send it back to the drive manufacturer for a replacement. Without
    the key, even if they could read the data off the platters, all they get is jumbled
    noise.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's mount `/dev/sdb1` at boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need the UUID of the encrypted disk; for this, we use `luksUUID` to make
    life easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'First, place an entry into `/etc/crypttab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we need to add our `fstab` entry for our disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: As we saw previously, this could also be its own `systemd` unit file if you
    so wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, create a keyfile to use, with a suitably complex key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add this key to our encrypted partition. When prompted for any existing
    passphrase, give the one you gave when first creating the drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can reboot your VM and, hopefully (keep an eye on the console
    in VirtualBox), it'll come up seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that the encrypted volume can now be opened using either
    your passphrase or the keyfile (shown as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've done here is simply created an encrypted volume; it's yet another
    logical disk, that the system can treat as any other storage medium once it's
    been unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: '`cryptsetup` is the key component used here, and it couldn''t be described
    better than by its own manual page.'
  prefs: []
  type: TYPE_NORMAL
- en: cryptsetup is used to conveniently setup dm-crypt managed device-mapper mappings.
    These include plain dm-crypt volumes and  LUKS  volumes.  The difference is that
    LUKS uses a metadata header and can hence offer more features than plain dm-crypt.
    On the other hand, the header is  visible and vulnerable to damage.
  prefs: []
  type: TYPE_NORMAL
- en: With `cryptsetup`, we started by formatting the partition we'd set up and setting
    an initial passphrase. This was the `luksFormat` element. Once done, our LUKS
    partition could then be opened, which is the process of passing our assigned passphrase
    to the device, for it to then set up a device mapping automatically. We were then
    able to format our mapped device with a useful filesystem for using natively (`btrfs`
    again) and mount it.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work you do with LUKS devices will be done using `cryptsetup` (at
    least on servers).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, if you try to mount a filesystem on an encrypted drive, without
    knowing or caring that it''s LUKS encrypted, you''ll get a descriptive message
    that should give you a hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you know you need to run `luksOpen` on the drive first, and you
    might find that you've long since forgotten the password and the data on the disk
    has effectively gone to silicon-heaven (or silicon-purgatory).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we mounted our drive using a keyfile on the root partition;
    if instead you add a line with `none` in it to `crypttab` and then add the entry
    to `fstab`, you will get prompted for a password at boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to go to your console and put in your LUKS password, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891f95f5-4a00-4233-bdf1-62ef61a04f7a.png)'
  prefs: []
  type: TYPE_IMG
- en: This has to be done from the console, as SSH won't be up yet. Obviously, in
    a cloud environment or a physical server build, this can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been following along, you might be asking what `systemd` does with
    `crypttab`, if it translates `fstab` into `systemd` units.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that it does something very similar, in fact, using a similarly
    named program at boot-time: `systemd-cryptsetup-generator`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually see what happened to our encrypted device at boot by catting
    the automatically generated file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `attach` command being run at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Current filesystem formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There're a lot of filesystem formats out there—some are more popular than others;
    some are used for very specific tasks; some are the darlings of certain operating
    systems; and others simply should have gone away years ago.
  prefs: []
  type: TYPE_NORMAL
- en: In the Windows world, we typically see NTFS, but FAT32, exFAT, and even FAT16
    in some cases are still options.
  prefs: []
  type: TYPE_NORMAL
- en: More recently, Apple has dropped the ageing HFS+ and moved full-steam toward
    APFS as its filesystem of the future.
  prefs: []
  type: TYPE_NORMAL
- en: FreeBSD defaults to either ZFS (if you've got the RAM for it) or UFS (if you
    haven't).
  prefs: []
  type: TYPE_NORMAL
- en: OpenBSD—well, OpenBSD uses FFS, which is exactly as good as it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast File System** (**FFS**) is pretty much UFS.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux is a whole other kettle of fish because, not only does it do all of the
    filesystems listed previously, to a greater or lesser degree, it also has hundreds
    of others to pick from.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to see what we have available to us on our VM.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, you'll just need access to your VM and possibly the internet
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your Vagrant box; this section is purely informational, so don't
    worry about what state it's in for now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Listing systems you can create is relatively easy, as you can tab `mkfs` a
    couple of times to get a list of established aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Your distribution may have others available, though not installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I want to manage DOS filesystems, I can install `dosfstools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve suddenly got the `msdos`, `vfat`, and `fat` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also list the filesystems your kernel is capable of interacting with
    by using your current kernel''s module directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Note that the likes of `ext3` might be managed by an `ext4` module of yours,
    so just because `ext3` isn't listed doesn't mean you can't mount, read, and write
    to an `ext3` drive.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Realistically, it doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, we would have one filesystem that worked across each OS
    and was suited for every task, but the truth of the matter is that there's always
    going to be some filesystems that are better at some jobs than others.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Red Hat defaults to using XFS as its filesystem of choice,
    a journaling filesystem that was created in 1993\. Before that, the default was
    the `ext` family of filesystems, which some distributions (such as Debian) continue
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSUSE likes `btrfs` at the minute, though how much that's likely to change
    is anyone's guess, especially as the likes of Red Hat have just decided against
    including it in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: This is also all before getting on to **Filesystem in Userspace** (**FUSE**),
    which is capable of bringing a host of other (userspace) filesystems into the
    mix.
  prefs: []
  type: TYPE_NORMAL
- en: For now, just be safe in the knowledge that XFS and `ext4` will likely be around
    for a while, and they're a solid choice for any system as long as your needs aren't
    too bespoke. You may need to get a storage engineer in if you're planning on doing
    things such as investigating which filesystem will be best for your new, bespoke,
    database.
  prefs: []
  type: TYPE_NORMAL
- en: My recommendation is to go with whatever is in use by default.
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming filesystem formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've discussed the old favorites, such as XFS and `ext4`, but we've only touched
    on the likes of ZFS and novelty filesystems such as `btrfs`.
  prefs: []
  type: TYPE_NORMAL
- en: On top of the regular I-need-a-filesystem-for-my-disk filesystems, there're
    others such as LizardFS and SSHFS, which are worth a mention.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, you'll again need access to your VM and the internet as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: Connect to your VM, but also have a web browser handy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting out simple-ish, let's talk about ZFS.
  prefs: []
  type: TYPE_NORMAL
- en: Less of a traditional filesystem than others, ZFS has recently been mainstreamed
    on Linux by being bundled into Ubuntu (which caused a lot of arguing and even
    some claims that Canonical were willfully breaking GPL compliance), and it's causing
    a bit of a stir.
  prefs: []
  type: TYPE_NORMAL
- en: For years, ZFS was the main reason people installed FreeBSD (don't email me),
    and it's the backbone filesystem for systems based on Solaris or OpenSolaris.
    It works differently to XFS or ext4 and is arguably closer to the LVM world.
  prefs: []
  type: TYPE_NORMAL
- en: Disks are placed into VDEVs, which is the bit that handles the mirroring or
    RAID-ing of drives. These VDEVs then form the basis for zpools, which are storage
    pools that datasets then sit atop (datasets are more like traditional partitions—kinda).
  prefs: []
  type: TYPE_NORMAL
- en: ZFS on Linux is the project behind putting ZFS on Linux, and I would advise
    checking them out.
  prefs: []
  type: TYPE_NORMAL
- en: After ZFS, you've got things such as distributed filesystems, which you might
    mount on your local system using FUSE. LizardFS is one such filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: You use LizardFS if you want distributed and redundant storage, which can be
    accessed over a network and mounted locally. You can do clever things such as
    store multiple copies of data and even have multi-master setups of the controller
    node so that you have some redundancy in the event of hardware failure (because
    hardware does fail).
  prefs: []
  type: TYPE_NORMAL
- en: 'If all of that was over your head, don''t panic: it was over my head for the
    longest time too, but it''s pretty nifty software and worth a weekend to get to
    grips with.'
  prefs: []
  type: TYPE_NORMAL
- en: SSHFS is another FUSE filesystem, only this time it's a bit of software that's
    used to mount remote systems directories locally so that you can mangle and mess
    with them to your heart's content, without being on the command line of the remote
    box.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, it generally doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are a deep and interesting topic, for a very dedicated and specific
    kind of people. I've met storage engineers who could talk for hours about the
    different filesystems on offer and why you shouldn't bother using `ext2` as a
    `/boot` partition these days, simply because the trade-offs aren't there, or who
    drone on about the selective merit of using **just a bunch of disk** (**JBOD**)
    deployments versus traditional SANs.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, I'll point out that there are use cases for every type of filesystem
    on offer, even WikipediaFS, and that's okay! Just be safe in the knowledge that
    the options are there, if you need them.
  prefs: []
  type: TYPE_NORMAL
- en: Round-up - hardware and disks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of this chapter, quite unintentionally, turned into a breakdown of disks
    and filesystems. This is because, traditionally, disks were the most likely thing
    to go wrong in your system. Recently, disks don't die anywhere near as much, because
    the advent of cheap and commercially available SSDs has removed the "spinning
    rust" from a lot of systems.
  prefs: []
  type: TYPE_NORMAL
- en: That said, data can, and will, randomly disappear from your life.
  prefs: []
  type: TYPE_NORMAL
- en: Backup! Backup! Backup!
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't matter how many times I say it—some of you will still read those
    words and think "*yeah, I should do that*" with no intention of ever bothering
    to set something up. For your own systems, that's your choice, but you might at
    least consider it for those boxes you manage, as it'll only make your life easier
    (and you the hero) when you break out the backups after a catastrophic failure
    that threatens to cost your employer millions.
  prefs: []
  type: TYPE_NORMAL
- en: It should go without saying, but you should make a point of testing your backups
    frequently, or you will enter the faith-based backups situation, and that is not
    somewhere you want to be.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are also getting more confusing and feature-rich. If you compare
    something like `ext2` with `btrfs`, you'll find a wealth of tricks and clever
    things that are designed to make your life easier in the long term, but in the
    short term can leave you with a bewildering array of options.
  prefs: []
  type: TYPE_NORMAL
- en: People also do silly things in this world, such as deploy RAID5 `btrfs` solutions
    in live environments, without doing basic write-hole checks to ensure they won't
    get any data loss if a disk goes pop (for the full story behind this, do an internet
    search for "`btrfs` raid lol" and you'll probably get some meaningful results).
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, just remember that hardware is out to get you, and you may find
    some dark amusement in that knowledge the next time you're sat in a data center
    at four in the morning, holding a hard drive up to your ear to listen for the
    telltale sound of clicking, as a mechanical head tries and fails to correctly
    read that one important payroll database.
  prefs: []
  type: TYPE_NORMAL
