- en: Automating Juniper Devices in the Service Providers Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline how to automate Juniper devices running the
    Junos OS software in a typical **service provider** (**SP**) environment. We will
    explore how to interact with Juniper devices using Ansible, and how to provision
    different services and protocols on Juniper devices using various Ansible modules.
    We will base our illustration on the following sample network diagram of a basic
    SP network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/13923e95-73e7-4fb8-b34e-cc346f018842.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following table outlines the devices in our sample topology and their respective
    management **Internet Protocols** (**IPs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device** | **Role** | **Vendor** | **Management (MGMT) Port** | **MGMT
    IP** |'
  prefs: []
  type: TYPE_TB
- en: '| `mxp01` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxp02` | P Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.3` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxpe01` | PE Router | Juniper vMX 14.1 | `fxp0` | `172.20.1.4` |'
  prefs: []
  type: TYPE_TB
- en: '| `mxpe02` | PE Router | Juniper vMX 17.1 | `fxp0` | `172.20.1.5` |'
  prefs: []
  type: TYPE_TB
- en: 'The main recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the network inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and authenticating to Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the **Network Configuration Protocol** (**NETCONF**) on Junos OS devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring generic system options on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interfaces on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring **Open Shortest Path First** (**OSPF**) on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring **Multiprotocol Label Switching** (**MPLS**) on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the **Border Gate Protocol** (**BGP**) on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying configuration on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the **Layer 3 virtual private network** (**L3VPN**) service on Juniper
    devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering Juniper device facts using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating network reachability on Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving operational data from Juniper devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the network state using PyEZ operational tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch3_junos).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the software releases on which this chapter is based:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper **Virtual MX** (**vMX**) running Junos OS 14.1R8 and Junos OS 17.1R1
    release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3ajF4Mp](https://bit.ly/3ajF4Mp)'
  prefs: []
  type: TYPE_NORMAL
- en: Building the network inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build and structure the Ansible inventory
    to describe the sample SP network setup outlined previously. The Ansible inventory
    is a pivotal part in Ansible, as it defines and groups devices that should be
    managed by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new folder that will host all the files that we will create in this
    chapter. The new folder is named `ch3_junos`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the new folder, `ch3_junos`, we create a `hosts` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `Ansible.cfg` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We build the Ansible inventory using the `hosts` file and we define multiple
    groups in order to group the different devices in our network infrastructure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the `PE` group, which references all the MPLS **Provider Edge** (**PE**)
    nodes in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create the `P` group, which references all the MPLS **Provider** (**P**)
    nodes in our topology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create the `junos` group, which references all the devices running Junos
    OS as the OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create the `core parent` group, which references both the `PE` and `P` groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we create the `Ansible.cfg` file and configure it to point to our `hosts`
    file, to be used as the Ansible inventory file. We set the `gathering` to `explicit` in
    order to disable the setup module, which runs by default to discover facts for
    the managed hosts. Disabling the setup module is mandatory since the setup module
    will fail when run against network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate that our Ansible inventory is structured and written correctly
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Connecting and authenticating to Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to connect and authenticate to Juniper devices
    from Ansible via **Secure Shell** (**SSH**), in order to start managing the Juniper
    devices. We are going to outline how to use SSH keys as the authentication method
    to establish communication between Ansible and the Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability between the Ansible
    control machine and all the devices in the network must be configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the Ansible machine, create the private and public SSH keys in our `ch3_junos` working
    directory, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Capture the public key that was created in the previous step, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Juniper devices, add a new user called `admin` and designate that we
    will use SSH keys for authentication for this user. Copy the public SSH key that
    was created on the Ansible machine to the device, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating the public and private SSH keys on the Ansible control
    machine, using the `SSH-keygen` command and specifying the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the encryption algorithm with the `-t` option, and we set it to `rsa`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify the size of the encryption key using the `-b` option, and we set
    the size to `2048` bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify the location to save the private and public keys using the `-f` option,
    and we specify the name for the public and private key that will be generated,
    which will be `Ansible_SSH_key`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we run the command, we will see that the following two files (the private
    and public SSH keys) are generated, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: On all the Juniper devices in our inventory, we create the `admin` user and
    we specify that we will use SSH keys for authentication. We paste the contents
    of the public key that we have created on the Ansible control machine under the
    `authentication` stanza for this new user. With this configuration, any host who
    has the corresponding private key can authenticate and log in to the Juniper devices
    as the `admin` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test and validate that we have successfully logged in to the Junos
    OS devices from the compute nodes, we can test this using the Ansible command
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We specify the username to connect to the devices using the `-u` option and
    we specify the private SSH key using the `–private-key` option. Finally, we use
    the `-c` option in order to specify the connection plugin used to connect to the
    managed devices, and, in this case, we use the `network_cli` connection plugin
    to open an SSH session with the managed Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the SSH keys that we have generated in our playbooks, we can
    specify the username and the SSH private key file that we will use to authenticate
    to our Juniper devices as host or group variables in Ansible. In our case, we
    will set these variables as group variables for the `junos` group. We create the
    `group_vars` directory, and we create the `junos.yml` file, and we specify the
    variables as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the connection between Ansible and our devices again using the `Ansible`
    command; however, this time, without specifying any parameters, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Enabling NETCONF on Junos OS devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to enable the NETCONF protocol on Junos
    OS devices. This task is critical since we will use the NETCONF API in all the
    future recipes to manage the Juniper devices. The NETCONF API provides several
    advantages compared to the traditional SSH access method, and that is why we will
    use it in all our interactions with the Junos OS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a prerequisite for this recipe, an Ansible inventory file must be present,
    as well as the SSH authentication being deployed and working, as per the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_jnpr_net_build.yml`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `group_vars/junos.yml` file with the connection details, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start interacting with the Junos OS devices via NETCONF, we need
    to enable it first, therefore we need to SSH into the device initially and enable
    NETCONF. That is why we are using the `network_cli` Ansible connection in order
    to connect with the Junos OS devices via traditional SSH. In order to use the
    `network_cli` connection plugin, we need to set `Ansible_network_os` as `junos`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to use the NETCONF API in all interactions with Juniper devices
    in all coming recipes, we enabled the `network_cli` plugin only for the `junos_netconf`
    task in this playbook via the `vars` attribute. However, for all future tasks
    that we will add in this playbook, we will use the `netconf` connection specified
    in the `Ansible_connection` attribute in the `group_vars/junos.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new playbook called `pb_jnpr_net_build.yml`, and in the first task,
    we use the `junos_netconf` module to enable the NETCONF protocol on the remote
    Junos OS devices. We state the NETCONF port that will be used (by default, it
    is `830`), and we outline that this configuration must be present on the remote
    devices via the `state: present` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we will see that all the Junos OS devices are configured
    with NETCONF, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring generic system options on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure some generic system options
    such as hostname and **Domain Name System** (**DNS**) servers, and provision users
    on Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and NETCONF is enabled on all Juniper devices, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/all.yml` file with the following parameters to define
    the various system-level parameters such as `dns` and system users, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_jnpr_basic_config.yml` with the following
    tasks, to set up `dns`, `hostname` and system users on Juniper devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides declarative modules to configure various system-level parameters
    on Juniper devices. The `junos_system` Ansible module enables us to set up the
    hostname and the DNS servers on the Juniper devices. The `junos_user` module provides
    us with the ability to set up the basic parameters for the system users on a Juniper
    device. In this example, we set up all the users who have SSH keys as their authentication
    method, and we loop over the `users` data structure and select only the users
    with the `SSH_key` option defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run this playbook, we can see that the configuration on the devices
    is updated, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The declarative Ansible modules that we have outlined in this section provide
    a simple way to configure the basic system-level parameters for Juniper devices.
    However, they might not cover all the parameters that we need to set up on a Juniper
    device. In order to have more control and flexibility to configure the system-level
    parameters on a Juniper device, we can use Jinja2 templates along with the Ansible
    `template` module to generate the specific system-level configuration needed for
    our deployment. In this section, we will outline this method in order to achieve
    this goal, and this is the method that we will use in subsequent recipes to generate
    the configuration for the other devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to reuse this method to generate the configuration for our Juniper
    devices for different sections, such as system, interfaces, OSPF, and MPLS. We
    are going to create an Ansible role in order to include all the Jinja2 templates
    and tasks required to generate the final configuration that we will push to our
    devices. The following procedures outline the steps needed to create the role
    and to use this role to generate the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `roles` directory and add a new role called `build_router_config`
    with the following directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `tasks` folder, create a `build_config_dir.yml` YAML file to create
    the required folders to store the configuration that will be generated, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `templates` folder, create a new folder called `junos`, and within
    this folder, create a new Jinja2 template called `mgmt.j2`, with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `tasks` folder, create a new YAML file called `build_device_config.yml`,
    with the following task to create the system configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `main.yml` file under the `tasks` folder, with the following tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_jnpr_net_build.yml` playbook with the following task to generate
    the configuration for all Juniper devices in our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we create a role called `build_router_config` and we create
    a new Jinja2 template called `mgmt.j2`, which includes the template for Junos
    OS system-level configuration. We use the Ansible `template` module in order to
    render the Jinja2 template with the Ansible variables defined under the `group_vars/all.yml`
    file. In order to save the configuration for each device, we create the `configs`
    folder directory, which stores the final configuration for each device.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will use this approach in order to generate the configuration for each
    section (MGMT, OSPF, MPLS, and so on), we will segment each section into a separate
    Jinja2 template, and we will generate each section in a separate file. We use
    the `assemble` module in order to group all these different sections into a single
    configuration file, which we will store in the `configs` directory. This is the
    `final` and `assembled` configuration file for each device. We store the temporary
    configuration snippets for each section in a temporary folder for each device,
    and we delete this temporary folder at the end of the playbook run. This is because
    we assembled the final configuration for the device, and we don't require these
    configuration snippets anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In this playbook, we set the `Ansible_connection` to `local` as we don't need
    to connect to the devices in order to run any of the tasks within our role. We
    are only generating the configuration on the Ansible control machine, therefore
    all the tasks need to run locally on the Ansible control machine. Therefore, there
    is no need to connect to the remotely managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we can see that the following configuration files
    are created inside the `configs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the configuration generated for the `mxpe01` device as an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In subsequent recipes, we will outline how to push the generated configuration
    into the Juniper devices using another Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the Ansible `template` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/template_module.html](https://docs.ansible.com/ansible/latest/modules/template_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the Ansible `assemble` module and the different
    parameters supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/assemble_module.html](https://docs.ansible.com/ansible/latest/modules/assemble_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring interfaces on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to manage interfaces on a Juniper device.
    This allows us to set different parameters for our interfaces, such as the **maximum
    transition unit** (**MTU**) and the IP addresses on Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and NETCONF is enabled on all Juniper devices, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/all.yml` YAML file to include the following data for
    all the **point-to-point** (**P2P**) and loopback interfaces in our sample network
    topology:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_jnpr_basic_config.yml` playbook with the following tasks to
    set up the interfaces on our Juniper devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define all the data for all the interfaces in our sample network topology
    under two main data structures in the `group_vars/all.yml` file. We use the `p2p_ip`
    dictionary to model all the P2P IP addresses in our sample network, and we use
    the `lo_ip` dictionary to specify the loopback IP addresses for our nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `junos_interface` Ansible module to enable the interfaces and set
    the basic parameters for the interfaces, such as MTU and description. We loop
    over the `p2p_ip` data structure for each device, and we set the correct parameters
    for each interface on all the devices in our network inventory. We use the `junos_l3_interface`
    Ansible module to set the correct IPv4 address on all the interfaces in our sample
    network topology across all the devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we can see that the interfaces are configured as
    required, as shown on the `mxpe01` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case we need to have more control over the interface configuration, and to
    set parameters that are not covered by the declarative Ansible modules that we
    have outlined in this section, we can use Jinja2 templates to achieve this goal.
    Using the exact same approach that we outlined in the previous recipe for system
    configuration, we can generate the interface configuration needed for our Juniper
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same Ansible role that we have created in the previous recipe, we
    can extend it to generate the interface configuration for our Juniper devices.
    We use the following steps in order to accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Jinja2 template file called `intf.j2` in the `templates` folder,
    with the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `build_device_config.yml` file under the `tasks` directory with
    the new task to generate the interface configuration, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the generated interface configuration for the `mxp02` device after
    running the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Configuring OSPF on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure OSPF on Juniper devices as
    the **interior gateway protocol** (**IGP**) in our sample network topology, along
    with different OSPF parameters such as OSPF link type and OSPF interface cost.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Jinja2 file, `ospf.j2`, in the `templates/junos` directory, with
    the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `junos_build_config.yml` file inside the `tasks` folder, add the following
    task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the same interface data that was declared in the `p2p_ip` data structure
    in the `all.yml` file, in order to provision the OSPF configuration on the network
    devices in our sample network. We use a new Jinja2 template defined in the `ospf.j2`
    file under the `templates/junos` directory to capture the OSPF configuration parameters
    (OSPF cost, OSPF interface type, and so on) that need to be implemented on the
    Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `tasks/Juniper_build_config.yml` file, we add a new task that uses
    the `ospf.j2` Jinja2 template to render the Jinja2 template, and output the OSPF
    configuration section for each device outlined in our Ansible inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet outlines the OSPF configuration generated for the `mxpe01`
    device after running the playbook with the new task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Configuring MPLS on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure MPLS and some of the related
    protocols such as the **Label Distribution Protocol** (**LDP**) and the **Resource
    Reservation Protocol** (**RSVP**) on Juniper devices. We will outline how to generate
    the required MPLS configuration using Ansible and Jinja2 templates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Jinja2 file, `mpls.j2`, under the `templates/junos` directory
    with the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `build_device_config.yml` file inside the `tasks` folder, add the following
    task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the same methodology as used to configure the interfaces and OSPF, by
    using a Jinja2 template to generate the needed MPLS configuration for the Juniper
    devices in our inventory, and the following is a sample of the MPLS configuration
    for the `mxpe02` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Configuring BGP on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure BGP on Juniper devices. We
    will outline how to set up BGP and BGP **Route Reflectors** (**RR**) as part of
    our sample topology, along with all the required BGP address families to support
    **virtual private network** (**VPN**) services.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/all.yml` file with the following BGP information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For each node within our Ansible inventory, we create a file called `bgp.yml`
    under the `host_vars` directory. This file holds the BGP information and BGP peers
    for each node. This is the example for the `mxpe01` device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Jinja2 file, `bgp.j2`, under the `templates/junos` directory,
    with the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `build_device_config.yml` file inside the `tasks` folder, add the following
    highlighted task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a similar approach to all the previous recipes, we use a Jinja2 template
    to generate the BGP configuration for the Juniper devices. However, in this section,
    we declare the BGP parameters in two different places, which are the `group_vars`
    and `host_vars` directories. In the `group_vars/all.yml` file, we declare the
    overall parameters for our BGP topology, such as the RR that we will use, and
    which address families we will configure. For each node in our inventory, we create
    a directory in the `host_vars` directory, and inside this directory, we create
    a `bgp.yml` file. This new YAML file holds the BGP peers for each node in our
    inventory. We use the data defined in these two locations to render the BGP configuration
    for each device.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a sample of the BGP configuration for the `mxp01` router, which is
    the RR in our topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Deploying configuration on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to push the configuration that we have generated
    via Jinja2 templates in all the previous sections on Juniper devices using Ansible.
    This provides us with the capability to push any custom configuration that we
    create to our Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires NETCONF to be enabled on the Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `pb_junos_push_con` file, add the following task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we generated different sections of the configuration
    for Juniper devices such as interfaces, OSPF, MPLS, and BGP. We have used the
    `assemble` module in order to group all these sections per each node in a single
    configuration file. This file is stored in the `configs` folder for each device.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `junos_config` module in order to push this configuration file that
    we have generated to each device in our network inventory. We can use the `update`
    parameter in order to control how the configuration that we want to push will
    be merged with the existing configuration on the device. It supports the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`merge`: This causes the configuration from our file to be merged with the
    configuration on the device (the candidate configuration). This option is the
    default option that is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Override/update`: This causes the configuration from our file to override
    the complete configuration on the managed device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `check` mode to run our playbook in dry-run mode. In this case,
    we will push the configuration to the devices without committing to the configuration.
    This enables us to check the changes that will be pushed to the devices. This
    can be accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We use the `–check` option to run the playbook in check mode (dry-run), and
    the `–diff` option in order to output the changes that will be pushed to our devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `junos_config` module also supports the rollback feature supported by Junos
    OS, therefore we can add another task to roll back the configuration and control
    how it is run, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding playbook, we roll back to the last version of the configuration.
    However, by changing the number in the `rollback` attribute, we can control the
    version of the configuration to which we want to roll back. Also, we are using
    the tags in order to only execute this task when we specify the `rollback` tag
    during the playbook run, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify another rollback point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `junos_config` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_config_module.html](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_config_module.html)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the L3VPN service on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to model and configure L3VPNs on Juniper
    devices using various Ansible modules. This enables us to model our services using
    **Infrastructure as Code** (**IaC**) practices, and utilize Ansible to deploy
    and push the required configuration to have the L3VPN deployed on Juniper devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NETCONF must be enabled on the Juniper devices so as to use the Ansible modules
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new file called `l3vpn.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_junos_l3vpn.yml` with the following tasks
    to configure the PE-**Customer Edge** (**CE**) links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following tasks in `pb_junos_l3vpn.yml` to set up the P2P IP address
    on the PE-CE links:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following task in `pb_junos_l3vpn.yml` to configure the **virtual routings
    and forwardings** (**VRFs**) on the PE nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new YAML file called `l3vpn.yml` that describes and models the L3VPN
    topology and data that we want to implement on all the Juniper devices on our
    topology. We include this file in the new playbook that we create in order to
    provision the L3VPNs on our network devices.
  prefs: []
  type: TYPE_NORMAL
- en: In the `pb_junos_l3vpn.yml` playbook, we use the data from the `l3vpn.yml` file
    to capture the data required to provision the L3VPN.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first task within our playbook, we create a new variable called `l3vpn_intfs` that
    captures all the L3VPN interfaces on each PE device, across all the VPNs that
    we have defined in our `l3vpn.yml` file. We loop over all the L3VPNs in this file,
    and we create a new list data structure for all the interfaces that belong to
    a specific node. The following snippet outlines the new data structure `l3vpn_intfs`
    for `mxpe01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in our playbook, we divide the provisioning of our L3VPN service to multiple
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `junos_config` module to configure all the interfaces that are part
    of the L3VPNs to be ready to configure **virtual LANs** (**VLANs**) on these interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `junos_l3_interface` module to apply the IPv4 addresses on all these
    interfaces that are part of our L3VPN model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `junos_vrf` module to configure the correct routing instances on
    the nodes, as per our L3VPN data model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following outlines the L3VPN configuration that is applied on `mxpe01`
    after running this playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `junos_vrf` module and the different parameters
    supported by this module to provision L3VPNs on Juniper devices, please consult
    the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)[. ](https://docs.ansible.com/ansible/latest/modules/junos_vrf_module.html#junos-vrf-module)
  prefs: []
  type: TYPE_NORMAL
- en: Gathering Juniper device facts using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will retrieve the basis system facts collected by Ansible
    for a Juniper device. These basic system facts provide us with a basic health
    check regarding our Juniper devices, which we can use to validate its operational
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NETCONF must be enabled on the Juniper devices so as to use the Ansible modules
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook, `pb_jnpr_facts.yml`, with the following task to collect
    the facts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_jnpr_facts.yml` playbook with the following tasks to create
    a facts report for each node in our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to validate the operational state
    for the core interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a fact-gathering module to collect the basic system properties
    for Juniper devices and returns these facts in a consistent and structured data
    structure. We can use the facts collected by this module in order to validate
    the basic properties and operational state of our devices, and we can use this
    data to build simple reports that capture the state of our devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we use the `junos_facts` module to collect the device facts
    for all our Juniper devices. This module returns the basic facts collected by
    Ansible for each device in multiple variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We use this data in order to build a fact report for each device using the `blockinfile`
    module, and we use this data to validate the operational state of the core interfaces
    of each device using the `assert` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our playbook, we can see that a facts report for each device is
    generated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the final task, we use the `assert` module in order to validate that all
    the core interfaces on all the Juniper devices are operational. Ansible stores
    all the interfaces' operational status for the device under `Ansible_net_interfaces`.
    We use the data in this data structure to validate that the operational state
    is up. In the case that all the core interfaces are operational, the task will
    succeed—otherwise, the task will fail.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `junos_facts` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_facts_module.html)
  prefs: []
  type: TYPE_NORMAL
- en: Validating network reachability on Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to validate network reachability via `ping`,
    using Ansible on Juniper devices. This will enable us to validate network reachability
    and traffic forwarding across our sample network topology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that the network is already built and configured, as outlined
    in all the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new playbook called `pb_junos_ping.yml` with the following task, to
    ping all core loopbacks within our sample network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_junos_ping.yml` playbook with the following task to create a
    custom report to capture the ping results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `junos_ping` module in order to ping from all the nodes in our network
    inventory to all the loopback interfaces defined in the `lo_ip` data structure,
    which is defined in the `group_vars/all.yml` file. This module connects to each
    device and executes ping to all the destinations, and validates that ping packets
    are reaching their intended destination. This module requires the use of the `network_cli`
    connection plugin, therefore we supply this parameter as a task variable in order
    to override the group-level NETCONF connection plugin defined at the group level.
  prefs: []
  type: TYPE_NORMAL
- en: We register the output of the module in order to use this data to generate the
    ping report. Finally, we set `ignore_errors` to `yes` in order to ignore any failed
    ping task that we might encounter, and ensure that we will run the subsequent
    tasks to create the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `blockinfile` module in order to create a custom report in Markdown.
    We use a table layout in order to capture the ping results and display a table
    that captures these ping results. The following snippet captures the table generated
    for the `mxpe01` ping test report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the rendered Markdown table for the ping result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8dd7c8e4-61f2-4c27-bf5d-7a5ffd391dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `junos_ping` module and the different parameters
    supported by this module, please consult the following URL: [https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)[.](https://docs.ansible.com/ansible/latest/modules/junos_ping_module.html)
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving operational data from Juniper devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to execute operational commands on Juniper
    devices and store these outputs in text files for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NETCONF must be enabled on the Juniper devices in order to follow along with
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `jxmlease` Python package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_get_ospf_peers.yml` and populate it with the
    following task to extract OSPF peering information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_get_ospf_peers.yml` playbook with the following task to validate
    that all OSPF peerings across all nodes are in a `Full` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using the NETCONF API to interact with Juniper devices
    is that we can get a structured output for all the operational commands that we
    execute on the Juniper devices. The output that the device returns to us over
    the NETCONF session is in XML, and Ansible uses a Python library called `jxmlease`
    to decode this XML and transform it to JSON for better representation. That is
    why our first task was to install the `jxmlease` Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `junos_command` module to send operational commands to a Juniper
    device, and we specify that we need XML as the output format that gets returned
    from the node. This XML data structure is transformed to JSON using the `jxmlease`
    package by Ansible. We save this data using the `register` keyword to a new variable
    called `ospf_output.` Here is a sample of the JSON data that is returned from
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: All this data structure is contained in the `ospf_output.output[0]` variable,
    and we use the `set_fact` module to capture the `ospf-neigbour` data. After that,
    we use the `assert` module to loop through all the OSPF peers in this data structure
    and validate that the OSPF neighbor state is equal to `Full`. If all the OSPF
    peers are in a `Full` state, the task will succeed. However, if the OSPF state
    is in any other state, the task will fail.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we need to get the operational data from Juniper devices in text format
    for log collection, we can use the `junos_command` module without the `xml` display
    option, as shown in this new playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This playbook will collect the `show ospf neigbor` command from all the devices,
    and store them in a new folder called `logs`. Here is the content of the `logs`
    folder after running the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the content of one of the files to confirm that the required output
    is captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Validating the network state using PyEZ operational tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to use Juniper custom Ansible modules to
    validate the network state. We are going to use the Juniper PyEZ Python library
    and PyEZ operational tables and views to validate the operational state for Junos
    OS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NETCONF must be enabled on the Juniper devices in order to follow along with
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `junos-eznc` Python package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `Juniper.junos` Ansible role using `Ansible-galaxy`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook called `pb_jnpr_pyez_table.yml`, and populate it with
    the following task to extract BGP peering information using PyEZ tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to validate that all BGP peering
    across all nodes is operational:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the built-in Juniper modules that come pre-installed with Ansible
    that we have outlined in all our previous recipes, there are additional Ansible
    modules that are maintained by Juniper and are not part of the Ansible release.
    These modules are packaged in an Ansible role that is maintained in Ansible Galaxy,
    and all these modules are based on the Juniper PyEZ Python library that is also
    developed and maintained by Juniper.
  prefs: []
  type: TYPE_NORMAL
- en: The Juniper PyEZ Python library provides a simple and robust API in order to
    interact with Juniper devices and simplifies how to manage Juniper devices using
    Python. The Ansible modules maintained by Juniper are all dependent on the PyEZ
    Python library, and therefore the first task we need to perform is to ensure that
    PyEZ (`junos-eznc`) is installed on our Ansible control machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ansible modules maintained and developed by Juniper are packaged as an
    Ansible role, and they provide multiple modules with extra capabilities compared
    to the built-in Juniper modules that come as part of the Ansible release. We install
    this role using Ansible Galaxy in order to start to utilize these extra modules.
    The following snippet outlines the extra modules that are part of this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we outline how to use the `Juniper_junos_table` Ansible module,
    which uses the PyEZ tables and views to execute operational commands on Juniper
    devices and extract specific information from the Juniper device. It also parses
    this information into a consistent data structure, which we can utilize in our
    automation scripts. In our playbook, our first task is to use the `Juniper_junos_table`
    module using the `bgp.yml` table definition (which is present as part of the `junos-eznc`
    installation). We do this to get the BGP peers on a device and return the relevant
    information in a consistent data structure. The following snippet outlines the
    BGP data returned by the `Juniper_junos_table` for the BGP information on `mxpe01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The last task in our playbook is using the `assert` module in order to validate
    that all our BGP peers (defined under the `host_vars)` directory) are present
    in the returned data structure in the BGP table, which indicates that all the
    BGP peers are operational.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the Juniper Ansible modules maintained by Juniper,
    please consult the following URL: [https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)[.](https://www.juniper.net/documentation/en_US/junos-ansible/topics/reference/general/junos-ansible-modules-overview.html)
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding PyEZ tables and views, please consult the following
    URL: [https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html](https://www.Juniper.net/documentation/en_US/junos-pyez/topics/concept/junos-pyez-tables-and-views-overview.html).
  prefs: []
  type: TYPE_NORMAL
