- en: '*Chapter 13*: Network Automation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, a network consisted of mostly hardware with just a modicum of
    software involvement. Changing the topology of it involved installing and configuring
    new switches or blades in a chassis or, at the very least, re-patching some cables.
    Now, the scenario has changed, and the complex infrastructures built to cater
    for multi-tenant environments such as cloud hosting, or microservice-based deployments,
    require a network that is more agile and flexible. This has led to the emergence
    of **Software-Defined Networking** (**SDN**), an approach that centralizes the
    network configuration (where historically it was configured on a per-device basis)
    and results in a network topology being defined as a whole, rather than as a series
    of component parts. It is, if you like, an abstraction layer for the network itself
    and thus implies that just like infrastructure as a service, networks can now
    be defined in code.
  prefs: []
  type: TYPE_NORMAL
- en: Since the previous edition of this book was published, a great deal of work
    has gone into Ansible to enhance and standardize network automation within the
    project. In addition to this, the advent of collections has enabled the modules
    for many network devices to become decoupled from the `ansible-core` package,
    thus enabling network vendors to take greater ownership of their code and release
    them on an as-needed basis, rather than being driven by the cadence of the Ansible
    releases themselves. At the time of writing, only a handful of Ansible collections
    (and thus modules) remain under the remit of the Ansible Network team, with most
    now being maintained directly by the vendors themselves. This is a good thing
    for all concerned, and it ensures greater reliability and more rapid development
    of Ansible's network offering.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this means one thing – that you can now define your network infrastructure
    in an Ansible playbook, just as you can describe your compute infrastructure,
    as we described in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore this area of rapidly growing importance by
    covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible for network management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling multiple device types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `cli_command` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Arista EOS switches with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Cumulus Networks switches with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do – for those
    interested in specifics, all the code presented in this chapter was tested on
    **Ubuntu Server 20.04 LTS**, unless stated otherwise, and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at this
    URL: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter13).'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action:[https://bit.ly/3G5pNjJ](https://bit.ly/3G5pNjJ).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible for network management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core network devices, such as switches, routers, and firewalls, have long had
    management interfaces, especially in enterprise environments. **Command-Line Interfaces**
    (**CLIs**) have always been popular on such devices as they support scripting,
    so, as you have already guessed, they lend themselves extremely well to Ansible
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, teams have faced a myriad of challenges when managing these devices,
    including maintaining configuration, coping with the failure/loss of a device,
    and obtaining support in the event of an issue. Often, companies found themselves
    locked into a single network vendor (or at best, a small handful) to enable the
    use of proprietary tools to manage the network. As with any situation where you
    are locked into a technology, this carries both benefits and drawbacks. Add to
    this the complexity of software-defined networks that are rapidly changing and
    evolving, and the challenge becomes even greater. In this section, we will explore
    how Ansible addresses these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen throughout this book, Ansible has been designed to make automation
    code portable and reusable in as many scenarios as possible. In [*Chapter 12*](B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224)*,
    Infrastructure Provisioning*, we used almost identical playbooks to configure
    infrastructure on four different providers, and to support this, the examples
    that were given were quite simplistic. Of course, we could have developed this
    further through the use of roles to remove the repetition of so much code if we
    had wished, but the simplicity was deliberate to demonstrate how similar the code
    was, regardless of the provider being used.
  prefs: []
  type: TYPE_NORMAL
- en: In short, Ansible made it possible to write playbooks that ran on multiple environments
    to achieve the same thing with minimal effort once we had defined the first one.
    The same is true of networks. The advent of collections means that there is no
    central network module index anymore, as the collections themselves define which
    platforms are supported. However, the *Ansible for Network Automation* page, available
    at [https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html),
    is a great place to get started with all the basic concepts as it provides a list
    of many of the supported platforms. However, the list of platforms on this page
    is not complete – for example, later in this chapter, we will look at configuring
    a switch based on the Cumulus Linux platform, and support for this is not explicitly
    listed on the aforementioned page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the reason for this is that support for Cumulus Linux and a wide array
    of other network technologies are supported by the `Community.Network` collection.
    The list of supported platforms and modules can be found here: [https://docs.ansible.com/ansible/latest/collections/community/network/](https://docs.ansible.com/ansible/latest/collections/community/network/).'
  prefs: []
  type: TYPE_NORMAL
- en: As the Ansible documentation is automatically built, decentralizing modules
    into collections has been a little disruptive in areas such as networking, and
    will no doubt improve over time. In the meantime, with a little searching, you
    are sure to find support for your network platform as this support has only been
    expanding as Ansible has developed.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that with such a wide (and growing) range of device support, it
    is easy for a network administrator to manage all of their devices from one central
    place, without the need for proprietary tools. However, the benefits are greater
    than just this.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration portability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have discussed already, Ansible code is highly portable. In the world
    of network automation, this is extremely valuable. To start with, it means that
    you could roll out a configuration change on a development network (or simulator)
    and test it, and then be able to roll out the same code against a different inventory
    (for example, a production one) once the configuration has been deemed to have
    been tested successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits don't stop there, however. Historically, in the event of issues
    with a software upgrade or configuration change, the network engineer's challenge
    was to engage the vendor for support and assistance successfully. This required
    sending sufficient detail to the vendor to enable them to at least understand
    the problem and most likely want to reproduce it (especially in the case of firmware
    issues). When the configuration for a network is defined in Ansible, the playbooks
    themselves can be sent to the vendor to enable them to quickly and accurately
    understand the network topology and diagnose the issue. I have come across cases
    where network vendors are now starting to insist on Ansible playbooks containing
    network configuration when a support ticket is raised. This is because it empowers
    them to resolve the issue faster than ever before.
  prefs: []
  type: TYPE_NORMAL
- en: Effective use of **Ansible Vault** ensures that sensitive data is kept out of
    the main playbooks, which means it can easily be removed before being sent to
    a third party (and even if it was sent accidentally, it wouldn't be readable as
    it is encrypted at rest).
  prefs: []
  type: TYPE_NORMAL
- en: Backup, restore, and version control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although most businesses have robust change control procedures, there is no
    guarantee that these are followed 100% of the time, and human beings have been known
    to tweak configurations without accurately recording the changes they've made.
    Moving the network configuration to Ansible removes this issue, as the configuration
    is a known state defined by the playbooks that can be compared easily to the running
    configuration using a `check` run.
  prefs: []
  type: TYPE_NORMAL
- en: Not only is this possible, but configurations can be backed up and restored
    with ease. Say, for example, a switch fails and has to be replaced. If the replacement
    is of the same type, it can be configured and brought into service rapidly by
    running the same Ansible playbooks that configured its predecessor, with the playbook
    run perhaps limited to just the replacement switch inventory host if appropriate
    – though Ansible's idempotent nature means that running it across the entire network
    should be benign.
  prefs: []
  type: TYPE_NORMAL
- en: This lends itself to version control too – network configuration playbooks can
    be pushed to a source control repository, enabling configuration versions to be
    tracked, and differences over time to easily be examined.
  prefs: []
  type: TYPE_NORMAL
- en: Automated change requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, minor changes to a network might be required to roll out a new project
    – perhaps a new VLAN or VXLAN, or some previously unused ports that have been
    brought into the service. The configuration parameters will be well-defined by
    a change request and/or network design, and it is probably not the best use of
    a highly qualified network engineer to be making simple configuration changes.
    Tasks such as these are typically routine, in that the configuration changes can
    be templated in an Ansible playbook, with variables passed to it that have been defined
    by the change request (for example, port numbers and VLAN membership details).
  prefs: []
  type: TYPE_NORMAL
- en: This then frees up the engineers' time for more important work, such as designing
    new architectures, and new product research and testing.
  prefs: []
  type: TYPE_NORMAL
- en: Coupled with the use of a package such as AWX or Ansible Tower (as we discussed
    earlier in this book), simple and well-tested changes could be completely automated
    or passed to a frontline team to be executed safely by simply passing in the required
    parameters. In this way, the risk of human error is significantly reduced, regardless
    of the skillset of the person performing the change.
  prefs: []
  type: TYPE_NORMAL
- en: With these benefits well established and understood, let's look at how we might
    start writing playbooks to handle a multi-device network.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple device types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world where we are not locked into a single vendor, it is important to
    know how we might handle the different network devices in an infrastructure. We
    established in the previous chapter that for different infrastructure providers,
    a similar process was established for each one in terms of getting Ansible to
    interact with it. This can be a little different with switches as not all command-line
    switch interfaces are created the same. Some, such as on a Cumulus Networks switch,
    can make use of straightforward SSH connectivity, meaning that everything we have
    learned about in this book so far on connecting to an SSH-capable device still
    applies.
  prefs: []
  type: TYPE_NORMAL
- en: However, other devices, such as F5 BIG-IP, do not use such an interface and
    therefore require the module to be run from the Ansible host. The configuration
    parameters must be passed to the module directly as opposed to using simple connection-related
    host variables such as `ansible_user`.
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a gray area in the middle of this discussion. Some devices,
    such as an Arista EOS or Cisco IOS-based device will be SSH managed, so you could
    be mistaken for thinking you can connect to them using a straightforward SSH connection
    as if they were any other Linux host. However, this is not the case – if we reflect
    on [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The* *System
    Architecture and Design of Ansible*, we learned that for Ansible to automate commands
    over SSH, it sends over a tiny chunk of Python code to the remote host for execution
    (or PowerShell, in the case of Windows hosts). Most switches, while having an
    SSH-based user interface, cannot be expected to have a Python environment present
    on them, so this mode of operation is not possible (Cumulus Linux is the exception
    here since it features a usable Python environment). As a result, devices such
    as the Arista EOS and Cisco IOS ones historically used to use local execution,
    whereby the Ansible code is run on the control node itself, and then the automation
    requests are translated into the appropriate CLI (or API) calls and passed directly
    to the device. Thus, no remote Python environment is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find many historical examples that make use of this mode of operation,
    and they can easily be identified as they will have the following line somewhere
    in the play definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Possibly, this might also be defined as an inventory variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of how this happens, the local connection mode of operation has been
    deprecated, and while most legacy networking playbooks that utilize this connection
    mode will still run today, it is anticipated that support for this will be dropped
    next year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where possible, users are encouraged to use one of the following communication
    protocols instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.netcommon.network_cli`: This protocol translates play tasks into CLI
    commands over SSH.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.netconf`: This protocol translates play tasks into XML data
    sent over SSH to the device for configuration by `netconf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.netcommon.httpapi`: This protocol talks to network devices using an
    HTTP or HTTPS-based API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three preceding communication protocols are all persistent – that is to
    say, they don't need to set up and tear down network connections for each task
    – the local connection method does not support this, so it is significantly less
    efficient than these modes. Of the preceding list, `ansible.netcommon.network_cli`
    is the most common you will come across, and we will look at this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: It is not expected that many of you will have access to a wide variety of network
    hardware to use in the examples in this chapter. Later, we will look at two examples
    that are freely available to download (at the time of writing, subject to you
    sharing a little personal information) that you can try out if you wish. For now,
    though, we will go into more detail on the process to be employed when automating
    a new network device for the first time so that you know to apply this to a situation
    and preferred network vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Researching your modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your first task when working with any networking device is to understand what
    module you need to use with Ansible. This will involve two things:'
  prefs: []
  type: TYPE_NORMAL
- en: What device do you wish to automate the management of?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What task(s) do you wish to perform on the device?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with this information, you can search the Ansible documentation site and
    Ansible Galaxy to find out if your devices and desired tasks are supported. Let's
    say, for example, that you have an F5 BIG-IP device, and you want to save and
    load configuration on this device.
  prefs: []
  type: TYPE_NORMAL
- en: A quick scan of the available collections on Ansible Galaxy suggests we should
    look at the `f5networks.f5_modules` collection ([https://galaxy.ansible.com/f5networks/f5_modules](https://galaxy.ansible.com/f5networks/f5_modules)),
    and that from this, we should look into the `f5networks.f5_modules.bigip_config` module,
    which will do just what we need. Thus, we can proceed with the module configuration
    (see the next section) and then write the desired playbook around this module.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if there is no module for your device, though? In this instance,
    you have two choices. Firstly, you could write a new module for Ansible to perform
    the tasks you require. This is something you could contribute back to the community,
    and [*Chapter 10*](B17462_10_Final_JC_ePub.xhtml#_idTextAnchor183), *Extending
    Ansible*, contains all the details you need to get started on this task.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you want to get something up and running quickly, remember
    that Ansible can send raw commands in most of the transport methods it supports.
    For example, in the author's lab setup, they have a TP-Link managed switch. There
    are no native Ansible modules that support this particular switch – however, as
    well as a web-based GUI, this switch also has an SSH management interface. If
    I wanted to quickly get something up and running, I could use Ansible's `ansible.builtin.raw`
    module to send raw commands over SSH to the switch. Naturally, this solution lacks
    elegance and makes it difficult to write playbooks that are idempotent, but it
    does enable me to get up and running quickly with Ansible and this device.
  prefs: []
  type: TYPE_NORMAL
- en: This captures the beauty of Ansible – the ease with which new devices can be
    managed, and how, with just a little ingenuity, it can be extended for the benefit
    of the community.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already demonstrated the use of the `ansible.builtin.raw` module,
    as well as extending Ansible, earlier in this book, we will proceed with the case
    where we have found a module we want to work with. As you may have noticed in
    some of the earlier chapters in this book, although Ansible includes many modules
    out of the box, not all of them work straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is written in Python and, in most cases, where there are dependencies,
    there will be Python modules. The important thing is to review the documentation.
    For example, take the `f5networks.f5_modules.bigip_config` module we selected
    in the previous section. A quick review of the *Requirements* section of the documentation
    shows that this requires (at the time of writing) the `ipaddress` Python module
    if you are running a Python version older than 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not running Python 3.5 or later, you will need to install this for
    the collection''s modules to function correctly. There are multiple ways to install
    this – some operating systems may have a native package built, and if this is
    available, then provided it meets the version requirements, it is perfectly fine
    to use this. This may be advantageous in terms of vendor support. However, if
    such a package is not available, Python modules can easily be installed using
    the `pip` (or `pip3`) tool. Assuming this is already on your system, the installation
    is as simple as using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Also, be sure to review the *Notes* section of the documentation (for the module
    we are currently discussing, go to [https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes](https://clouddocs.f5.com/products/orchestration/ansible/devel/modules/bigip_config_module.html#notes)).
    Continuing with this example, we can see that it only supports BIG-IP software
    version 12 and newer, so if you are on an earlier version, you will have to find
    another route to automate your device (or upgrade the software if this is an acceptable
    path).
  prefs: []
  type: TYPE_NORMAL
- en: Writing your playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your modules have been configured and all the requirements (be they Python
    module dependencies or device software ones) have been met, it''s time to start
    writing your playbook. This should be a simple task of following the documentation
    for the module. Let''s suppose we want to reset the configuration on an **F5 BIG-IP**
    device. From the documentation, we can see that authentication parameters are
    passed to the module itself. Also, the example code shows the use of the `delegate_to` task
    keyword; both of these clues tell us that the module is not using the native SSH
    transport of Ansible, but rather one that is defined in the module itself. Thus,
    a playbook to reset the configuration of a single device might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using a textbook example from the documentation to reset
    our configuration. Note that as our `hosts` parameter only defines `localhost`,
    we do not need the `delegate_to` keyword, since the `f5networks.f5_modules.bigip_config`
    module will only be run from `localhost` in this playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, we have automated a simple, but otherwise manual and repetitive,
    task that might need to be performed. Running the playbook would be as simple
    as executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, to test this playbook, you would have to have an F5 BIG-IP device
    to test against. Not everyone will have this available, so, later in this chapter,
    we will move on to demonstrate real-world examples that everyone reading this
    book can work with. However, this part of this chapter is intended to give you
    a solid overview of integrating your network devices, whatever they may be, with
    Ansible. Thus, it is hoped that even if you have a device that we haven't mentioned
    here, you understand the fundamentals of how to get it working.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the cli_command module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to the practical hands-on examples, we must look at a module that
    has become central to network device configuration since the previous edition
    of this book was published.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the preceding section, most network devices cannot be expected
    to have a working Python environment on them, and as such, Ansible will use local
    execution – that is to say, all tasks related to network devices are executed
    on the Ansible control node itself, translated into the correct format for the
    device to receive (be that a CLI, an HTTP-based API, or otherwise), and then sent
    over the network to the device. Ansible 2.7 relied mostly on a communication protocol
    known as `local` for network device automation. This worked well but suffered
    from several drawbacks, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `local` protocol does not support persistent network connections – a new
    connection needs to be set up and then torn down for each task that's executed.
    This is hugely inefficient and slow, and not in line with the original vision
    for Ansible at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module was responsible for its own communication protocol, so the library
    requirements for each module were often different, and code was not being shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was little commonality in the manner in which credentials could be provided
    for network device communication, and credentials had to be provided in each task,
    again resulting in inefficient code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result of these issues, the `local` protocol is expected to be dropped
    from Ansible within the next year, and you are encouraged to start using one of
    the three new protocols listed in the *Handling multiple device types* section,
    earlier in this chapter. Of these, the most common is the `ansible.netcommon.network_cli`
    protocol, which can be used to connect to a great deal of the network devices
    you may wish to automate with Ansible – you can see how common the use of this
    module is for network device configuration by looking at the table provided at
    [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html#settings-by-platform).
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this protocol is that authentication parameters can now be set
    in the inventory, just like they can for any other operating system, simplifying
    playbooks and removing the need for repetitive credentials being set. Persistent
    connections are also supported, meaning a much faster automation run. So, how
    does it work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let''s suppose we have a Cisco IOS-based network device to configure.
    We could define a simple inventory file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easy that is? We set the same `ansible_user`, `ansible_password`,
    and `ansible_become` inventory variables that we have already seen throughout
    the examples in this book. However, we have added the `ansible_connection` variable
    here, which tells Ansible to make use of the `ansible.netcommon.network_cli` protocol.
    Of course, this is only half of the story – this protocol tells Ansible to send
    CLI commands over SSH but doesn't tell Ansible what device type is on the other
    end of the connection. As all CLIs are different in some way, this matters, so
    we use `ansible_network_os` to tell Ansible what type of device it's talking to
    so that it can speak the right CLI language to the device.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to change the `ansible_become` method – on Linux, this would
    almost certainly be `sudo`, but on an IOS switch, it is `enable`. We also need
    to provide the password for the elevation of rights, just as you would if you
    had `sudo` configured to require a password.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s as complex as it gets – a simple playbook that makes use of this inventory
    and its assigned variables might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how easy that is – we can now write playbooks in the same manner as
    when we work with Linux or Windows hosts. Of course, each networking platform
    has subtle differences, and the platform-specific options for a myriad of supported
    devices can be found here: [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other great thing about using the `ansible.netcommon.network_cli` protocol
    is that it supports the `ansible_ssh_common_args` inventory variable, just as
    any other SSH managed host (Linux or Windows with OpenSSH) would. This is important
    because many network devices are managed over a secure, isolated network – and
    given the damage that could be caused if access to this fell into the wrong hands,
    rightly so. This means that these hosts are often accessed using a bastion host
    (also known as a jump host). To run your automation playbooks via this bastion,
    you can add the following to your inventory variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example assumes your bastion or jump host has a hostname of `jumphost.example.org`
    and that you have already set up passwordless key-based SSH access to it from
    your Ansible control node. There are other ways to authenticate with this bastion
    host, of course, and this is left as an exercise for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is just one example, and Cisco IOS-based devices are not something
    that everyone reading this book will have access to. However, at the time of writing,
    you can easily and freely download the Arista vEOS images by signing up for a
    free account on their website and heading over to [https://www.arista.com/en/support/software-download](https://www.arista.com/en/support/software-download).
    From here, you can load these images into a network simulation tool such as GNS3
    and experiment with Ansible's network automation for yourself, without needing
    access to any expensive hardware. We'll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Arista EOS switches with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting up and running with an Arista switch (or virtual switch) is left as
    an exercise f or you, but if you are interested in doing this in GNS3, a popular
    and freely available open source tool for learning about networks, there is some
    excellent guidance here: [https://gns3.com/marketplace/appliances/arista-veos](https://gns3.com/marketplace/appliances/arista-veos).'
  prefs: []
  type: TYPE_NORMAL
- en: You might be lucky enough to have an Arista EOS-based device at your fingertips,
    and that's fine too – the automation code in this section will work equally well
    in either case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples were created against an Arista vEOS device in GNS3,
    created using the instructions found in the aforementioned link. Upon booting
    the device for the first time, you will need to cancel ZeroTouch provisioning.
    To do this, log in with the `admin` username (the password is blank by default)
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual device will reboot, and when it comes up again, log in using the
    same credentials. Enter the following command to enter privileged user mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is the `ansible_become` method that we used in the Cisco IOS
    example earlier, and we''ll be using the same again here shortly. Now, enter configuration
    mode with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot administer a vEOS device over SSH if it has a blank password by
    default, so we''ll set a simple password for our virtual device with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the password for the `admin` user to `admin`. Next (assuming you
    have wired up the management interface of the vEOS device to your virtual network),
    you will need to enable this interface and give it a valid IP address. The exact
    IP address will depend on your test network, but the commands to achieve this
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, exit configuration mode and write the configuration to the switch
    so that it comes up again on the next reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's it – your vEOS device is now ready for management with Ansible!
  prefs: []
  type: TYPE_NORMAL
- en: 'With this configuration in place, you can now define an inventory for your
    test switch. I created mine as follows (based on the preceding configuration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how similar this is to the Cisco IOS-based example inventory we created
    in the previous section? This is one of the great things about the `ansible.netcommon.network_cli`
    protocol – all your code is much easier to write when using this protocol. Of
    course, as with most of the examples in this book, you wouldn't leave your administrative
    password out in the clear, it but serves to keep the examples simple and concise,
    and you are encouraged to explore the use of Ansible Vault for storing them safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can develop a simple playbook to demonstrate command automation
    against our virtual switch. Let''s pick a simple task – we''ll ensure that the
    `Ethernet1` interface on the switch is enabled, give it a meaningful name, and
    then write the config to the switch so that it persists across reboots. A playbook
    that achieves this might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this playbook in the same way you are used to. If you''re running
    the example code that accompanies this book, the command for this would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this against your switch, you should see an Ansible output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Configuring an Arista vEOS device with Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Configuring an Arista vEOS device with Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, of course, since we are performing this configuration change with Ansible,
    we expect the change to be idempotent – we should be able to run the same playbook
    again and nothing disruptive will happen. If you run your playbook a second time,
    the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Running the same playbook again to demonstrate idempotency'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Running the same playbook again to demonstrate idempotency
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the green `ok` task statuses, this playbook has run successfully
    a second time and that this time around, no changes were made to the switch configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to, you can validate the results of our playbook run by SSHing
    directly into the switch and executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Querying the configuration of our vEOS device manually'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Querying the configuration of our vEOS device manually
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the `Ethernet1` interface has the description we set in
    our playbook and has no directive to disable it, thus ensuring it is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: That's it – by working through this example, you've just performed your first
    real-life network device automation in Ansible! Hopefully, this shows you that,
    particularly now, given the advent of the `ansible.netcommon.network_cli` protocol,
    it is very easy and quick to achieve the configuration you desire. Most devices
    that support this protocol will work similarly, and you are encouraged to explore
    this further if this is of interest to you. However, what if we want to work with
    another device? Well, Cumulus Linux (now owned by NVIDIA) is an open source operating
    system for network devices that can run on white box hardware – that is to say,
    it is not proprietary to any specific hardware. Fortunately, you can freely download
    a copy of Cumulus VX, a virtual version of their switch operating system to experiment
    with. We'll look at how Ansible can automate this network platform in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cumulus Networks switches with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cumulus Linux (created by Cumulus Networks, which was acquired by NVIDIA) is
    an open source network operating system that can run on a variety of bare metal
    switches, offering an open source approach to data center networking. This is
    a great leap forward for network design and a significant shift away from the
    proprietary models of the past. They offer a free version of their software that
    will run on the hypervisor of your choice for test and evaluation purposes called
    Cumulus VX. The examples in this section are based on Cumulus VX version 4.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quick bit of research shows us that Cumulus VX will use the standard SSH transport
    method of Ansible. Since it is a Linux distribution designed specifically to run
    on switch hardware, it is capable of running in remote execution mode, so it does
    not require the `ansible.netcommon.network_cli` protocol. Furthermore, just one
    module has been defined for working with this system,`network.cumulus.nclu`, which
    is part of the `community.network` collection ([https://galaxy.ansible.com/community/network](https://galaxy.ansible.com/community/network)).
    No prerequisite modules are required to use this module, so we can proceed straight
    to defining our inventory.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Cumulus VX boots up with the management interface that's been configured
    to get an IP address with DHCP. Depending on how you run it, you may find that
    it also has three other virtual switch ports for us to test and play with its
    configuration, though if you integrate it into a tool such as GNS3, you will find
    that you can easily reconfigure the number of virtual switch ports available to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a version of Cumulus Linux older than 3.7, you will find that the
    image has default login credentials already set. So, provided you establish the
    IP address of your virtual switch, you can create a simple inventory such as the
    following one, which uses the default username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Newer releases of Cumulus Linux, such as version 4.4.0 – the latest available
    at the time of writing and used for the examples in this section – require you
    to set the password for the switch upon first boot. If you are working with this
    version, you will need to boot the virtual switch for the first time, and then
    log in with the default username of `cumulus` and the default password of `cumulus`.
    You will then be prompted to change your password.
  prefs: []
  type: TYPE_NORMAL
- en: With this done, you are ready to automate your switch configuration. You can
    use the inventory we defined previously and simply replace the `ansible_ssh_pass`
    value with the password that you set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The IP address specified in `ansible_host` will almost certainly differ from
    mine – make sure you change this to the correct value for your Cumulus VX virtual
    machine. You might have to log into the VM console to get the IP address with
    a command such as `ip addr show`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, you would never put the password in clear text in the inventory
    file – however, for simplicity and to save time, we will specify the default password
    here. In a real-world use case, always use a vault, or set up key-based SSH authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the inventory defined, let''s test connectivity with the `ping` module
    using an ad hoc command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is set up correctly, you should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Checking Ansible connectivity to our virtual Cumulus Linux
    switch'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Checking Ansible connectivity to our virtual Cumulus Linux switch
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The* *System Architecture and Design of Ansible*, the `ansible.builtin.ping`
    module performs a complete end-to-end connectivity test, including authentication
    at the transport layer. As a result, if you received a successful test result
    like the one shown previously, we can proceed with confidence and write our first
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Cumulus VX image comes completely unconfigured (save for the DHCP client
    configuration on the `eth0` management port). Depending on the version you download,
    it may have three switch ports labeled `swp1`, `swp2`, and `swp3`. Let''s query
    one of those interfaces to see whether there is any existing configuration. We
    can use a simple playbook called `switch-query.yaml` to query `swp1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we run this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Querying the defaults of a switch port on Cumulus Linux with
    Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Querying the defaults of a switch port on Cumulus Linux with Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'This confirms our initial statement about the VM image – we can see that the
    switch port is not configured. It is very easy to turn this VM into a simple layer
    2 switch with Ansible and the `community.network.nclu` module. The following playbook,
    called `switch-l2-configure.yaml`, does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are using some clever inline Jinja2 templating to run a `for` loop
    across the three interfaces, saving the need to create repetitive and cumbersome
    code. These commands bring up the three switch interfaces and add them to the
    default layer 2 bridge.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also demonstrates the differences between the various networking modules
    available in Ansible. In the previous section, where we configured our EOS-based
    switch, we had numerous different modules to work with, each serving a different
    purpose – for example configuring interfaces, configuring routing, and configuring
    VLANs. In contrast, Cumulus Linux-based switches only have one module: `community.network.nclu`.
    This is not an issue, but as we are sending all our configuration commands through
    one module, making use of Jinja2 templates (which can support constructs such
    as `for` loops) serves us well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `commit: true` line applies these configurations immediately to
    the switch. Now, let''s say we run this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we will see a different status for `swp1`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Successfully configuring our Cumulus Linux virtual switch with
    Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Successfully configuring our Cumulus Linux virtual switch with
    Ansible
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `swp1` interface is now up and part of the bridge, ready
    to switch traffic. However, if you look closely at the preceding screenshot, you'll
    see that the `bring up ports swp[1-3]` task has a status of `ok`, rather than
    `changed`. Yet we can see from the `switch` query results that the configuration
    was changed. This appears to be a bug in version `3.0.0` of the `community.network`
    collection and has been raised by the author. Hopefully, newer releases of this
    collection will correctly show the changed status when the configuration of Cumulus
    switches is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re querying the port''s status, though, we can still run the playbook
    a second time to test idempotency. Let''s see what happens if we run the playbook
    again without performing any other steps on the switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Testing the idempotency of our playbook against our Cumulus
    Linux virtual switch'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Testing the idempotency of our playbook against our Cumulus Linux
    virtual switch
  prefs: []
  type: TYPE_NORMAL
- en: This time, the state of this task is still `ok`, but we can see that the interface
    status query results are the same, showing that our configuration has persisted
    and not been modified in any adverse way (which could happen if idempotency was
    not supported). In this way, playbooks that automate the configuration of our
    Cumulus Linux switch are idempotent and result in a consistent state, even when
    they're run multiple times. This also means that if the configuration of the switch
    drifts (for example, due to user intervention), it is very easy to see that something
    has changed. Unfortunately, the `community.network.nclu` module doesn't currently
    support the `check` mode of `ansible-playbook`, but it still provides a powerful
    way to configure and manage your switches.
  prefs: []
  type: TYPE_NORMAL
- en: Automating network hardware, such as that running Arista EOS and Cumulus Linux,
    with Ansible is as simple as that – just think what you could do to automate your
    network configuration using a combination such as this! I encourage you to explore
    these free tools to learn more about network automation; I think you'll quickly
    see the value in it. Hopefully, even with these simple examples, you can see that
    automating network infrastructure with Ansible is now no more difficult than automating
    anything else in your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the usual best practices of using Ansible apply when automating network
    devices with it. For example, never store passwords in the clear, and make use
    of `ansible-vault` where appropriate. Despite this, network devices are their
    own special class of devices when it comes to Ansible, and support for them started
    to flourish from the 2.5 release of Ansible onward. As such, there are a few special
    best practices that deserve to be mentioned when it comes to network automation
    with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make good use of the inventory structure supported by Ansible when it comes
    to organizing your network infrastructure and pay particular attention to grouping.
    Doing so will make your playbook development much easier. For example, suppose
    you have two switches on your network – one is a Cumulus Linux Switch, as we examined
    previously, and the other is an Arista EOS-based device. Your inventory may look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that we cannot run the `community.network.nclu` module on anything
    other than a Cumulus switch, so, with some careful use of the `when` statement,
    we can build tasks in playbooks to ensure that we run the correct command on the
    correct device. Here is a task that will only run on devices in the `cumulus` group
    we defined in the preceding inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, good use of grouping enables us to set variables on a device basis.
    Although you would not put passwords in the clear into your inventory, it might
    be that your switches of a given type all use the same username (for example, `cumulus` in
    the case of Cumulus Linux devices). Alternatively, perhaps your EOS devices need
    specific Ansible host variables set for connectivity to work and to achieve the
    privilege escalation that''s required to perform configuration. Thus, we can extend
    our preceding inventory example by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Good inventory structure and variable definition will make developing your playbooks
    a great deal easier, and the resulting code will be more manageable and easier
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering facts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible includes several specific fact-gathering modules for network devices,
    and these may be useful for running conditional tasks or simply reporting back
    data about your devices. If you are using the older `local` connection-based protocol,
    these device-specific fact modules cannot be run at the start of the playbook
    run since, at this stage, Ansible does not know what sort of device it is communicating
    with. Thus, we must tell it to gather the facts for each device as appropriate. Using
    the `ansible.netcommon.network_cli` protocol described earlier in this chapter
    resolves this issue, as Ansible knows from the inventory what sort of device it
    is talking to.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, there are times when it is useful to manually gather facts on your
    devices – perhaps to validate some configuration work performed as part of a larger
    playbook. Whether you are doing this, or, for legacy reasons, still reliant on
    the `local` connection-based protocol, you need to be aware that you will use
    different fact-gathering modules for different connection types. Let's expand
    our Arista EOS and Cumulus Linux example to look at this.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no specific facts module for Cumulus Linux switches (although, since
    they are based on Linux, the standard host facts can still be gathered). Using
    the example of our Arista EOS device, we would run the `arista.eos.eos_facts`
    module in our playbook based on a unique key in our inventory. In the example
    inventory that we defined in the previous section, our Arista EOS switches are
    in the `eos` group, and also have `ansible_network_os` set to `arista.eos.eos`.
    We can use either of these as a condition in a `when` statement to run the `arista.eos.eos_facts`
    module on our switches. As such, the beginning of our playbook might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we set `gather_facts` to `false` at the beginning of this playbook.
    If you are using the `local` connection-based protocol, you would need to do this
    as we discussed previously – otherwise, using `ansible.netcommon.network_cli`,
    you can gather facts at the start of the play if you wish (obviously, though,
    this is redundant in this example!).
  prefs: []
  type: TYPE_NORMAL
- en: You will also note the more complex conditional we have used on our Arista EOS
    devices. As Cumulus Linux-based switches use the same SSH-based transport as Linux
    hosts, they do not need (or indeed have) `ansible_network_os` set, and if we attempt
    to test this variable in a conditional, we will produce a *variable undefined*
    error, and thus no subsequent tasks for hosts without the variable defined (our
    Cumulus Linux switches, in this case) will be attempted. This is hardly the outcome
    we are looking for! As a result, when combining these hosts with other network
    devices in the same play, we must always check that the `ansible_network_os` variable
    is defined before we attempt to perform any queries on it, just as we did in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed the examples in this chapter and set up your virtual Arista
    EOS and Cumulus Linux-based devices, you could run this playbook with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of a successful playbook run should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Gathering facts for multiple device types with a single playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – Gathering facts for multiple device types with a single playbook
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how our different facts modules are run on the appropriate
    device type, thanks to the conditionals we used in our playbook. You can use the
    techniques outlined in this part of this chapter to build far more complex, multi-device
    setups by extrapolating the work we have done together. However, no chapter on
    network automation would be complete without a little more detail on jump hosts.
    We will look at these next.
  prefs: []
  type: TYPE_NORMAL
- en: Jump hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, a word on jump hosts. It is common for network devices to be behind
    a bastion or jump host of some kind for important security reasons. Ansible provides
    several mechanisms for doing this, depending on the underlying network transport.
    For example, SSH connectivity (such as with Cumulus Linux switches) can make use
    of SSH''s ability to proxy commands. There are several ways to achieve these,
    but the simplest is to add another group variable to the inventory. For example,
    if we can only access our Cumulus Linux switch via a host called `bastion01.example.com`
    and are authenticating using an account called `jfreeman`, our inventory variables
    section would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding proxy command assumes that passwordless authentication has already
    been configured and is working for the `jfreeman` account on `bastion01.example.com`,
    and that SSH host keys have already been accepted. Failure to complete these tasks
    will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: SSH proxy commands like this would work for other `ansible_connection` modes
    that are used in network device management too, including `ansible.netcommon.netconf`
    and `ansible.netcommon.network_cli`, offering support for jump hosts to handle
    a wide range of network devices. As ever, the best method to be sure about the
    way to handle a specific type of connectivity is to check the documentation for
    your specific network device and follow the guidance therein.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we repeat our earlier example for querying the `swp1` interface of our Cumulus
    Linux switch, we will see that (with the bastion host correctly set up) the playbook
    works exactly as it did earlier in this chapter and that no further steps or changes
    to the code are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Running an earlier example playbook, but this time through
    a preconfigured bastion host'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_13_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – Running an earlier example playbook, but this time through a preconfigured
    bastion host
  prefs: []
  type: TYPE_NORMAL
- en: This is yet another reason why Ansible has become so popular – there is no need
    to set up a special proxy application or server for it to access an isolated network.
    Using the standard SSH protocol, it can connect via any secure host on the network
    that has SSH configured.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our exploration of network automation with Ansible. The number
    and range of devices you can automate the configuration of is limited only by
    your imagination, and I hope that this chapter has helped you gain a solid foundation
    in this important field and given you the confidence to explore further.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As more and more of our infrastructure gets defined and managed by code, it
    becomes ever more important that the network layer can be automated effectively
    by Ansible. A great deal of work has gone into Ansible since the previous release
    of this book in precisely this area, especially since the release of Ansible 2.5\.
    With these advancements, it is now easy to build playbooks to automate network
    tasks, from simple device changes to rolling out entire network architectures
    through Ansible. All of the benefits of Ansible relating to code reuse, portability,
    and so on are available to those who manage network devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about how Ansible enables network management. You
    learned about effective strategies for handling different device types within
    your infrastructure and how to write playbooks for them, and then you expanded
    on this with some specific examples on Arista EOS and Cumulus Linux. Finally,
    you learned about some of the best practices that must be applied when using Ansible
    to manage network infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the conclusion of this book. I would like to thank you for
    joining me on this journey into the very heart of Ansible, and I hope you have
    found it beneficial. I believe you should now know about the strategies and tools
    for managing everything, from small configuration changes to entire infrastructure
    deployments with Ansible, and wish you luck in this important and ever-evolving
    area of technology.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible brings all the benefits of automation from infrastructure management
    to the world of network device management.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: When working with a new network device type for the first time, you should always
    do what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Perform a factory reset of the device.
  prefs: []
  type: TYPE_NORMAL
- en: b) Consult the Ansible documentation to learn about which collections and modules
    support it, and what the requirements for those might be.
  prefs: []
  type: TYPE_NORMAL
- en: c) Use the `ansible.netcommon.network_cli` connection protocol.
  prefs: []
  type: TYPE_NORMAL
- en: d) Use the local connection protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Which execution type is described by Ansible as running its automation code
    on the remote host directly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Remote execution
  prefs: []
  type: TYPE_NORMAL
- en: b) Local execution
  prefs: []
  type: TYPE_NORMAL
- en: Which execution type is described by Ansible as running its automation code
    on the control node, and then sending the required data over a pre-selected channel
    (for example, SSH or an HTTP-based API)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Remote execution
  prefs: []
  type: TYPE_NORMAL
- en: b) Local execution
  prefs: []
  type: TYPE_NORMAL
- en: Which connection protocol has (for the most part) superseded the older local
    connection-based protocol for network devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `ansible.netcommon.netconf`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible.netcommon.httpapi`
  prefs: []
  type: TYPE_NORMAL
- en: c) `ansible.netcommon.network_cli`
  prefs: []
  type: TYPE_NORMAL
- en: d) `local`
  prefs: []
  type: TYPE_NORMAL
- en: Can you gather facts for an Arista-based EOS device at the beginning of a play?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Yes.
  prefs: []
  type: TYPE_NORMAL
- en: b) No.
  prefs: []
  type: TYPE_NORMAL
- en: c) Yes, but only when using the `ansible.netcommon.network_cli` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: All network config on Arista EOS is performed using a single module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: Cumulus Linux does not require the `ansible.netcommon.network_cli` protocol
    because of which reason?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It is not a network operating system.
  prefs: []
  type: TYPE_NORMAL
- en: b) It contains a full Linux implementation, including Python.
  prefs: []
  type: TYPE_NORMAL
- en: c) It uses the SSH protocol for management.
  prefs: []
  type: TYPE_NORMAL
- en: d) It does not have a CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Good inventory management is especially important when working in multi-device-type
    networks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can support the use of bastion or jump hosts without the need for special
    configuration or software installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
