- en: Building a Web Application in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we focused on building our microservices, which is,
    basically, backend RESTful APIs, and testing it to make sure the response will
    be as expected. So far, we have been testing these RESTful APIs using curl, or
    maybe, using a testing framework, that is, nose, unittest2, and so on. In this
    chapter, we will create some HTML pages and write a JavaScript REST client, which
    will interact with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building HTML pages and data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript REST client using knockout.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will create a client application which will need to create
    dynamic content that is gathered from an HTML web page and, based on the actions
    of the user, will update the content as a response on the backend service.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you must have come across many application frameworks that adopt
    the MVC pattern. It is a large category, which is a combination of **MVC** (**Model
    View Controller**), **MVP** (**Model View Presenter)**, and **MVVM** (**Model
    View ViewModel**).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will use **knockout.js**, which is a library in JavaScript based
    on the MVVM pattern that helps developers build rich and responsive websites.
    It can work as a standalone or used along with other JavaScript libraries, such
    as jQuery. Knockout.js binds the UI with the underlying JavaScript model. The
    models are updated based on the changes in the UI and vice versa, which is basically
    two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'In knockout.js, we will be dealing with two important concepts: Binding and
    Observables.'
  prefs: []
  type: TYPE_NORMAL
- en: Knockout.js is a JavaScript library that is generally used to develop desktop-like
    web applications. It is useful, as it provides a responsive mechanism that syncs
    with your data sources. It provides a two-way binding mechanism between your data
    model and user interface. Read more about knockout.js at [http://knockoutjs.com/documentation/introduction.html](http://knockoutjs.com/documentation/introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create web applications to add a user and tweets to
    the database, and validate them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with creating a basic HTML template. Create a directory named
    `template` in your app root location; we will create all our future templates
    inside this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the basic skeleton for the `adduser.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we have specified a couple of `.js` scripts
    that are needed to make our HTML responsive. This is similar to twitter-bootstrap,
    which has a `<meta name="viewport">` attribute to help scale the page based on
    the browser dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating application users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing our web page, we need to create a route to create a
    user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the route, let''s create a form in `adduser.html`,
    which will ask for the required information related to the user and help them
    submit the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Currently, the preceding HTML page shows only empty fields, and if you try to
    submit it with data, it won't work, since no data binding is done with the backend
    service as yet.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to create JavaScript, which will make a REST call to the backend
    service, and add the user content provided from the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Observables and AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get the data from the RESTful API, we will use AJAX. Observables
    keep a track of the changes made on the data and reflect them, automatically,
    on all the locations where it is used and defined by `ViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: By using Observables, it becomes very easy to make the UI and `ViewModel` communicate
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file named `app.js`, which has Observables declared, inside
    the static directory with the following code--if the directory does not exist,
    create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I understand it's a lot of code; let's understand the usage of each part of
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you submit your content on the HTML page, a request will be received at
    `app.js`, and the following code will handle the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates the model and sends the content to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `addUser` function calls the `self.save` function with a passing
    data object. The `save` function makes an AJAX RESTful call to the backend services
    and performs the `POST` operation with the data gathered from the HTML pages.
    It then clears the content of the HTML pages as well.
  prefs: []
  type: TYPE_NORMAL
- en: Our work is not yet done. As we mentioned earlier, it is two-way data binding,
    so we need to send the data from the HTML side as well, so that it can be processed
    further in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script section, add the following line, which will identify the `.js`
    file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Binding data for the adduser template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding is useful to bind your data with the UI. The property from the
    UI will be processed only for the first time if we do not use Observables. In
    this case, it cannot update automatically based on the underlying data update.
    To achieve this, bindings must be referred to the Observable properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to bind our data with the form and its field, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to add our users through the template. However, how will we
    validate whether the user is added successfully to our database or not? One way
    would be to manually log in to the database. However, since we are working on
    a web application, let's show our data (present in the database) on the web page
    itself--even the newly added entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read the database and get the user list, add the following code
    to `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make changes in `adduser.html` to show our user list. For that,
    let''s add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! We are done with adding the web page which will create new users for
    our application. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating tweets from users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing our web page, we need to create a route to create tweets.
    This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that, we have created the route, let''s create another form in `addtweets.html`,
    which will ask the user for the required information related to tweets, and help
    them submit the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that currently, this form doesn't have data binding to communicate with
    the RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Working on Observables with AJAX for the addtweet template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's develop a JavaScript that will make a REST call to the backend service
    and add the tweet content provided from the HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file with the name `tweet.js` inside the static directory that
    we created earlier with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the usage of each part of this last code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you submit your content on the HTML page, a request will come to `tweet.js`,
    and the following part of the code will handle the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet creates the model and sends the content to the following
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `addTweet` function calls the `self.save` function with a passing
    data object. The save function makes an AJAX RESTful call to the backend services,
    and performs the `POST` operation with the data gathered from the HTML pages.
    It then clears the content of the HTML pages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to show data on the web page, and to keep the data on it in sync with
    the data in the backend service, the following code is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our work is not yet done. As we mentioned earlier, it is two-way data binding,
    so, we will need to send the data from the HTML side as well, so that it can be
    processed further in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script section, add the following line, which will identify the `.js`
    file with the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Data binding for the addtweet template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once this is done, we need to now bind our data with the form and its field,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to add our tweet through the template. We perform validation
    for tweets just as we performed validation for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read the database and get the tweet list, add the following code
    to `tweet.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to make changes in `addtweets.html` to show our tweet list. For
    that, let''s add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! Let''s test it out. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In a similar fashion, you can extend this use case by deleting users from the
    web page application, or can update user information in the backend services.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to know more about the knockout.js library, go through the live examples
    at [http://knockoutjs.com/examples/helloWorld.html](http://knockoutjs.com/examples/helloWorld.html),
    which will help you gain a better understanding, and help you with implementing
    it in your application.
  prefs: []
  type: TYPE_NORMAL
- en: We created these web pages to make sure our microservices work and to give you
    an understanding about how a web application is developed generally; and, as developers,
    we can create these web applications based on our own use case as well.
  prefs: []
  type: TYPE_NORMAL
- en: CORS - Cross-Origin Resource Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CORS helps maintain data integrity between the API server and the client for
    the API request.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind using CORS is that the server and client should have enough
    information about each other so that they can authenticate each other, and transfer
    data over a secure channel using the HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: When a client makes an API call, it is either a GET or POST request, where the
    body is usually text/plain with headers called **Origin**--this includes protocol,
    domain name, and port with respect to the requesting page. When the server acknowledges
    the request, and sends the response along with the `Access-Control-Allow-Origin`
    header to the same Origin, it makes sure the response is received at the correct
    Origin.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, resource sharing happens between Origins.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all browsers now support CORS, which includes IE 8+, Firefox 3.5+, and
    Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we have the web application ready, but it is not CORS-enabled yet,
    let's enable it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you need to install the module for CORS in Flask using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding package exposes a Flask extension which, by default, enables
    CORS support on all the routes for all Origins and methods. Once the package is
    installed, let''s include it in `app.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable CORS, you need to add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now this CORS is enabled for all the resources in your Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you want to enable CORS on specific resources, then add the following
    code with your specific resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, we don''t have a domain setup, but we are working at the localhost
    level. You can test CORS by adding a custom domain in the domain name server as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you try to access this `<your-domain-name>`, it should be able to work
    properly with this domain name, and you will be able to access the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Session management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sessions are a sequence of request and response transactions associated with
    a single user. The sessions are usually maintained on the server level by authenticating
    the user and keeping track of his/her activity over the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Session with each client is assigned a session ID. Sessions are generally stored
    on top of cookies and the server signs them cryptographically--they are decrypted
    by the Flask application using the secret key for a temporary duration.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we haven't set up authentication--we will be defining it in [Chapter
    8](part0145.html#4A91I0-4022ecb0f8ea4b719ffb742bf2a6a072), *Securing the Web Application*.
    So, at this point in time, we will create the session by asking about the username
    accessing the web page and making sure that the user is identified using the sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a web page, say, `main.html`, which will have a URL to create
    the session if it is needed to be set up, and routes to perform operations on
    the backend services. You could clear the session if it already exists. See the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Currently in this web page, a few URLs, such as `clearsession` and `addname`
    won't work, since we haven't set up the web page and route for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we haven''t set up the route for the `main.html` web page; let''s first
    add it in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have added the route for `main.html`, let''s add the route for `addname`
    in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding route, it calls `addname.html`, which we haven''t
    created yet. Let''s create the `addname` template with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we can set the session using the preceding code; you will see a
    web page that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, what if we need to clear sessions? Since we are already calling the `clearsession`
    function from the main web page, we need to create a route in `app.py`, which
    further calls the session''s `Clear` inbuilt function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is how we can set the session, maintain it for users, and clear the session,
    as per the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are similar to sessions, other than the fact that they are maintained
    on the client computer in the form of a text file; whereas, sessions are maintained
    on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Their main purpose is to keep track of the client's usage and, based on their
    activity, improve the experience by understanding the cookies.
  prefs: []
  type: TYPE_NORMAL
- en: The cookies attribute is stored in the response object, which is a collection
    of key-value pairs that have cookies, variables, and their respective values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the cookies using the `set_cookie()` function of the response object
    to store a cookie as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, reading cookies is pretty easy; the `get()` function will help you
    get the cookies if it is already set, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If the cookie exists, it will get assigned to the cookie, and if not, then the
    cookie will return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to integrate your microservices with the web
    application using a JavaScript library such as knockout.js. You learned about
    the MVVM pattern, and how these can be helpful to create fully developed web applications.
    You also learned user management concepts, such as cookies and sessions, and how
    to make use of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will try to make our database side stronger and secure
    by moving it from SQLite to other NoSQL database services, such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
