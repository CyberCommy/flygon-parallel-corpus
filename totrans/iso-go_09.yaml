- en: Cogs – Reusable Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous five chapters of this book, we focused on developing functionality
    for either a specific web page on IGWEB or a specific feature, such as the live
    chat feature that we implemented in the last chapter. The solutions that we've
    made thus far have served a particular individual purpose. Not much consideration
    was factored into promoting code reuse for a particular user interface feature,
    since we didn't have the need to create multiple instances of it.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable components are user interface widgets that provide a means to promote
    greater reusability. They can be used in a plug and play manner, since each component
    is a standalone user interface widget that contains its own set of Go source files
    and static assets, such as Go template files, along with CSS and JavaScript source
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on creating **cogs**—reusable components that
    can be utilized in Isomorphic Go web applications. The term `cog` stands for **component
    object in Go**. Cogs are reusable user interface widgets that can either be implemented
    exclusively in Go (a **pure cog**) or implemented using Go and JavaScript (a **hybrid
    cog**).
  prefs: []
  type: TYPE_NORMAL
- en: We can create multiple instances of a `cog` and control the cog's behavior by
    supplying input parameters (in the form of key-value pairs) to the `cog`, known
    as **props**. When subsequent changes are made to the props, the `cog` is **reactive**,
    meaning that it can automatically re-render itself. Therefore, cogs have the capability
    to change their appearance, based on changes made to their props.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps, the most attractive feature of cogs is that they are readily reusable.
    Cogs are implemented as standalone Go packages that contain one or more Go source
    files along with any static assets that are needed by the cog's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Essential `cog` concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing pure cogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing hybrid cogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential cog concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cogs** (component objects in Go) are reusable components that are implemented
    in Go. The guiding philosophy behind cogs is to allow developers to create reusable
    components on the front-end in an idiomatic manner. Cogs are self-contained defined
    as their own Go package, which makes it easy to reuse and maintain them. Due to
    their self-contained nature, cogs can be used to create composable user interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Cogs follow a clear separation of concerns where the presentation layer of a
    `cog` is implemented using one or more Go templates, and the controller logic
    of the cog is implemented in one or more Go source files contained within a Go
    package. These Go source files may import Go packages from the standard library
    or third-party libraries. We'll see an example of this when we implement the time
    ago cog in the *Implementing pure cogs* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cogs may also have CSS stylesheet and JavaScript code associated with them,
    allowing `cog` developers/maintainers to leverage prebuilt JavaScript solutions
    as needed rather than porting a JavaScript widget directly to Go. This makes cogs
    interoperable with existing JavaScript solutions and prevents situations where
    the developer can save valuable time, by not having to reinvent the proverbial
    wheel. For example, Pikaday ([https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday))
    is a well-established calendar date picker JavaScript widget. In the *Implementing
    hybrid cogs* section of this chapter, we will learn how to implement a date picker
    `cog` that utilizes the functionality that the Pikaday JavaScript widget provides.
    Go developers that use the date picker `cog` need not have any knowledge of JavaScript,
    and can utilize it solely with their knowledge of Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `cog` comes with a **virtual DOM tree**, an in-memory representation of
    its actual DOM tree. It is far more efficient to manipulate the cog''s in-memory
    virtual DOM tree rather than manipulating the actual DOM tree itself. *Figure
    9.1* is a Venn diagram depicting a cog''s virtual DOM tree, the difference between
    the two trees, and the actual DOM tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53478aff-9055-402c-8a14-4400ab176f58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: A Venn diagram depicting the virtual DOM, the difference, and the
    actual DOM'
  prefs: []
  type: TYPE_NORMAL
- en: As changes are made to a cog's properties (*props*), the cog's rendering engine
    will utilize its virtual DOM tree to determine the changes and then reconcile
    the changes with the actual DOM tree. This allows the `cog` to be *reactive*,
    meaning that the `cog` can automatically re-render itself the moment that one
    of its props gets updated. In this manner, cogs reduce the complexity that is
    involved when updating the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The UX toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The UX toolkit provides the functionality to implement cogs within the `cog`
    package, which can be installed using the following `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All cogs must implement the `Cog` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Render` method is responsible for rendering the `cog` on the web page.
    If there are any errors in the rendering process, the method will return an `error`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start` method is responsible for activating the `cog`. If the `cog` was
    not able to start, the method will return an `error` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `cog` package contains two important exported variables, `ReactivityEnabled`
    and `VDOMEnabled`. Both of these exported variables are of type `bool`, and by
    default, they are both set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When the variable `ReactivityEnabled` is set to `true`, cogs will be re-rendered
    as changes are made to their props. If `ReactivityEnabled` is set to `false`,
    then the cog's `Render` method must explicitly be called to re-render the cog.
  prefs: []
  type: TYPE_NORMAL
- en: When the variable `VDOMEnabled` is set to `true`, cogs will be rendered utilizing
    the cog's virtual DOM tree. If `VDOMEnabled` is set to `false`, the `cog` will
    be rendered using the actual DOM tree through a replace inner HTML operation.
    This can be an expensive operation which can be avoided by utilizing the cog's
    virtual DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UXCog` type implements the `Render` method of the `Cog` interface. Here
    is what the `UXCog struct` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UXCog` type provides the basic functionality to make cogs work. That means
    in order to implement our own cogs, we must type embed `UXCog` in the type definition
    of all cogs that we create. The following methods (for brevity, only the method
    signatures are presented) of the `UXCog` type are of particular interest to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `ID` method is a getter method that returns the ID of the cog's `div` container
    in the DOM. A cog's `div` container is known as its **mount point**.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetID` method is a setter method that is used to set the ID of the cog's
    `div` container in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The `CogInit` method is used to associate the `cog` to the application's `TemplateSet`
    object. There are two significant purposes served for this method. First, the
    method is used to register a `cog` on the server-side, so that all of the templates
    for a given `cog` are included in the template bundle that is produced by the
    static assets bundling system built into `isokit`. Second, calling the cog's `CogInit`
    method on the client-side provides the `cog` access to the client-side application's
    `TemplateSet` object, allowing the `cog` to render itself on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetCogType` method allows us to dynamically set the cog's type by performing
    runtime reflection on a newly instantiated `cog`. This provides the hook needed
    by isokit's static assets bundling system to bundle the template files, CSS source
    files, and JavaScript source files associated for a given `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetProp` method is used to set a key-value pair in the cog's `Props` map,
    which is of type `map[string]interface{}`. The `key` of the map represents the
    name of the prop, and the value represents the value of the prop.
  prefs: []
  type: TYPE_NORMAL
- en: The `Render` method is responsible for rendering the `cog` to the DOM. If a
    change is made to the `cog` (its prop value is updated) after it has been rendered,
    the `cog` will be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visit the UX toolkit website to learn more about cogs: [http://uxtoolkit.io](http://uxtoolkit.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been acquainted with the `UXCog` type, it's time to examine
    the anatomy of a `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the IGWEB project, we will be creating cogs in the `$IGWEB_APP_ROOT/shared/cogs`
    folder. You can take a peek at the time ago `cog`, whose implementation is found
    in the `$IGWEB_APP_ROOT/shared/cogs/timeago` folder, as you read through this
    section, to see a tangible implementation of the concepts presented herein.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of illustration only, we are going to walk you through the
    process of creating a simple `cog` called `widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure for the widget `cog` contained within the `widget` folder
    is organized in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `widget.go` source file will contain the implementation for the widget `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The `templates` folder contains the template source file(s) used to implement
    the `cog`. If the `cog` is to be rendered on the web page, at least one template
    source file must be present. The template source file's name must match the package
    name of the `cog`. For example, for the `cog` package `widget`, the name of the
    template source file must be `widget.tmpl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cogs follow a *convention over configuration* strategy when it comes to naming
    package names and source files. Since we have chosen the name `widget` we must
    declare a Go package named `widget` as well inside the `widget.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All cogs are required to include the `errors` package, the `reflect` package,
    and the `cog` package in their import grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We must declare an un-exported, package scoped variable called `cogType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable represents the cog''s type. We call the `TypeOf` function in
    the `reflect` package, passing in a newly created instance of the `cog`, to dynamically
    set the cog''s type inside the `cog` package''s `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This provides a hook for isokit's static bundling system, to know where to look,
    to obtain the static assets required to make a `cog` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `cog` implements a specific type. In the case of a widget, we implement the
    `Widget` type. Here''s the `Widget struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We must type embed the `cog.UXCog` type to bring all the functionality needed
    from the `cog.UxCog` type in order to implement the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` may contain other field definitions that are required to implement
    the `cog`, depending on the purpose that the `cog` serves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `cog` implementation should include a constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with any typical constructor function, the purpose is to create a new instance
    of the cog, `Widget`.
  prefs: []
  type: TYPE_NORMAL
- en: The cog's constructor function must contain the line that calls the `SetCogType`
    method (shown in bold). This is used as a hook by isokit's automatic static assets
    bundling system to bundle the cog's required static assets.
  prefs: []
  type: TYPE_NORMAL
- en: Additional fields of the `Widget` type may be set to initialize the `cog` based
    on the cog's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fulfill the implementation of the `Cog` interface, all cogs must
    implement a `Start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Start` method is responsible for activating the `cog`, which includes the
    initial render of the `cog` to the web page. The `Start` method will return an
    `error` object, if the `cog` failed to start, otherwise, a `nil` value will be
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration purposes, we have defined an `if` conditional block containing
    a Boolean variable called `allRequiredConditionsHaveBeenMet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If all the conditions to start the `cog` have been met, this variable will be
    equal to `true`. Otherwise, it will be equal to `false`. If it is `false`, then
    we will return a new `error` object, indicating that the `cog` was unable to start
    since all requirements had not been met.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set a key-value pair in a cog''s `Props` map by calling the `SetProp`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have set the prop named `foo` to the value `bar`. The `Props`
    map will automatically be used as the data object that gets fed into a cog's template.
    This means that all props defined in the `Props` map are accessible by the cog's
    template.
  prefs: []
  type: TYPE_NORMAL
- en: The cog's template source file name, by convention, must be named `widget.tmpl`
    to match the cog's package name of `widget`, and the template file should reside
    in the `templates` folder, which is located in the cog's folder, `widget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what the `widget.tmpl` source file may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are able to print out the value of the prop that has a key of
    `foo` within the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return back to the widget cog''s `Start` method. We call the cog''s
    `Render` method to render the `cog` in the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Render` method returns an `error` object if an error was encountered while
    rendering a `cog`, otherwise it will return a value of `nil` to indicate that
    the `cog` was rendered successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `cog` was rendered successfully, the cog''s `Start` method returns a
    value of `nil` to indicate that the `cog` has been started successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to render our `cog` to the real DOM, we need a place to render the
    `cog` to. The `div` container that houses the rendered content of a `cog` is known
    as its **mount point**. The mount point is where the `cog` gets rendered to in
    the DOM. To render the widget `cog` on the home page, we would add the following
    markup to the home page''s content template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `data-component` attribute to `"cog"`, we indicate that the `div` element
    is meant to be used as a cog's mount point, and the cog's rendered content will
    be contained inside this element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the client-side application, the widget `cog` can be instantiated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `Widget` instance and assign it to the variable `w`. We must
    call the `CogInit` method of the `cog` to associate the application's `TemplateSet`
    object with the `cog`. The `cog` utilizes the `TemplateSet` so that it may fetch
    it's associated template(s), which are required to render the `cog`. We call the
    cog's `SetID` method, passing in the `id` to the `div` element that acts as the
    cog's mount point. We call the cog's `Start` method to activate the `cog`. Since
    the `Start` method calls the cog's `Render` method, the cog will be rendered in
    the designated mount point, the `div` element with id, `"widgetContainer"`. Finally,
    when we call the `SetProp` method and change the value of the `"foo"` prop to
    `"bar2"`, the `cog` will get re-rendered automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've examined the basic anatomy of a `cog`, let's consider how cogs
    are rendered using a virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each `cog` instance has a virtual DOM tree associated with it. This virtual
    DOM tree is a parse tree comprised of all the children of the cog's `div` container.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.2* is a flowchart depicting the process to render, and re-render
    (through the application of reconciliation) the `cog` to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0aea435-af93-438d-9ce3-b88c23d6edd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: A flowchart depicting the process to render and re-render a cog'
  prefs: []
  type: TYPE_NORMAL
- en: When the `cog` is first rendered in the DOM, a replace inner HTML operation
    is performed. The operation to replace the inner HTML contents of an element in
    the DOM is an expensive operation. Hence, it is not performed on subsequent renders
    of the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: All subsequent calls to the cog's `Render` method will utilize the cog's virtual
    DOM tree. The cog's virtual DOM tree is used to keep track of changes between
    the cog's current virtual DOM tree and the cog's new virtual DOM tree. A `cog`
    will have a new virtual DOM tree to compare against its current one when a cog's
    prop value has been updated.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider an example scenario with the widget cog. Calling a widget cog's
    `Start` method will perform the initial render of the `cog` (since the cog's `Render`
    method is called within the `Start` method). The `cog` will have a virtual DOM
    tree that will be the parse tree of the `div` container holding the cog's rendered
    content. If we were to update the `"foo"` prop (which is rendered in the cog's
    template) by calling the `SetProp` method on the `cog`, then the `Render` method
    will automatically be called, since the `cog` is reactive. Upon performing the
    subsequent render operation on the `cog`, the cog's current virtual DOM tree will
    be diffed against the cog's new virtual DOM tree (the virtual DOM tree that is
    created after updating the cog's prop).
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are no changes between the current virtual DOM tree and the new virtual
    DOM tree, there is no need to perform any operation. However, if there are differences
    between the current virtual DOM tree and the new virtual DOM tree, then we must
    apply the changes that constitute the difference to the actual DOM. The process
    of applying these changes is known as **reconciliation**. Performing reconciliation
    allows us to avoid performing an expensive replace inner HTML operation. Upon
    successful application of reconciliation, the cog''s new virtual DOM tree will
    be considered as the cog''s current virtual DOM tree to prepare the `cog` for
    the next render cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1b661e1-dbf9-40f0-a649-2349e36cf1c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A cog''s existing virtual DOM tree (left) and the cog''s new virtual
    DOM tree (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.3* depicts a cog''s existing virtual DOM tree on the left and the
    cog''s new virtual DOM tree on the right. After performing a `diff` operation
    on the two virtual DOM trees (new and existing), it is determined that the rightmost
    `div` element (which contains the `ul` element) and its children have changed,
    and the reconciliation operation would only update the `div` element and its children
    in the actual DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of a cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 9.4* depicts the life cycle of a `cog`, which starts on the server-side,
    where we first register the `cog`. The cog''s type must be registered on the server-side
    so that the cog''s associated template(s), along with other static assets can
    be automatically bundled and made available to the client-side application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a0e440-a9ed-406b-a79c-9aa495618c26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The life cycle of a cog'
  prefs: []
  type: TYPE_NORMAL
- en: The subsequent steps in the `cog` life cycle, take place on the client-side.
    We declare a mount point for the `cog`, by introducing a `div` element with a
    data-component attribute equal to `"cog"`, to indicate that the `div` element
    is a mount point for a `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step, is to create a new instance of the `cog` by calling its constructor
    function. We initialize the `cog` by calling its `CogInit` method and pass in
    the `TemplateSet` object of the client-side application. Initializing the `cog` also
    consists of calling the cog's `SetID` method to associate the mount point to the
    `cog` (so that the `cog` knows where to render to). `Cog` initialization also
    includes setting a prop in the cog's `Props map` by calling its `SetProp` method
    before calling the `Start` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that calling a cog's `SetProp` method, before its `Start` method is called,
    will not render the `cog`. A `cog` will re-render upon calling its `SetProp` method
    only after a `cog` has been rendered to the mount point, by calling its `Start`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Cog's `Start` method will activate the `cog` and render the cog's
    contents to the specified mount point.
  prefs: []
  type: TYPE_NORMAL
- en: Any subsequent calls made to the cog's `SetProp` method will result in a re-render
    of the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: When the user navigates to a different page on the website, the container that
    the `cog` resides in is removed, effectively destroying the `cog`. The user may
    specify a clean-up function that should be called just before the `cog` is destroyed.
    This can come in handy to free up resources in a responsible manner prior to the
    cog's destruction. We'll see an example of implementing a clean-up function later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing pure cogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of cogs, its time to implement a few
    cogs in practice. Although cogs operate on the client-side, it is important to
    note that the server-side application needs to acknowledge their existence by
    registering them. Code for cogs are strategically placed in the `shared/cogs` folder
    for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: Pure cogs are implemented exclusively in Go. As you will see, we can leverage
    functionality from existing Go packages to implement cogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the main function in the `igweb.go` source file, we call the `initailizeCogs`
    function passing in the application''s template set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initializeCogs` function is responsible for initializing all the cogs
    that are going to be used in the Isomorphic Go web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `initializeCogs` function takes a sole input argument, `ts`, the
    `TemplateSet` object. We call the cog's constructor function to create a new instance
    of the `cog`, and immediately call the `CogInit` method of the `cog`, passing
    in the `TemplateSet` object, `ts`, as an input argument to the method. This allows
    the `cog` to include its templates to the application's template set, so that
    the subsequent template bundle that is to be produced will include templates associated
    with the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `BundleStaticAssets` method to generate the static assets (CSS and
    JavaScript source files) that are required for each `cog`. Two files will be produced.
    The first file is `cogimports.css`, which will contain the CSS source code needed
    for all the cogs, and the second file is `cogimports.js`, which will contain the
    JavaScript source code needed for all of the cogs.
  prefs: []
  type: TYPE_NORMAL
- en: The time ago cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how the cogs are initialized on the server-side, it's
    time to take a look at what goes into making a `cog`. We're going to start out
    by making a very simple `cog`, a time ago `cog`, which displays time in human
    understandable format.
  prefs: []
  type: TYPE_NORMAL
- en: It's time revisit the gopher bios on the about page. In the section *Custom
    template functions* found in [Chapter 3](0f18d7dd-b081-4090-8b9c-c7a392261b31.xhtml),
    *Go on the Front-End with GopherJS*, we learned how to use a custom template function
    to display the gopher's start date-time in Ruby format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to go a step further and display the start date-time in human
    understandable format by implementing a time ago `cog`. *Figure 9.5* is an illustration
    showing the start date for Molly in the default Go format, in Ruby format, and
    in human understandable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f766aa0-f732-486e-bb0f-b66f8b102f43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Illustration depicting the time ago cog, which is the last line
    showing the time in human readable format'
  prefs: []
  type: TYPE_NORMAL
- en: Molly joined the IGWEB team on May 24, 2017, which in human readable format
    is 6 months ago (at the present time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `about_content.tmpl` template source file, we introduce a `div` container
    for the time ago `cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've assigned the attribute, named `data-component`, with a value
    of `cog`. This is to indicate that this `div` container will serve as a mount
    point, housing the rendered content of a `cog`. We set the `id` attribute of the
    container to the first name of the Gopher with a prefix of `"Gopher-"`.
  prefs: []
  type: TYPE_NORMAL
- en: Later you will see that when we instantiate a `cog`, we must supply a cog's
    `div` container with an ID, so that the `cog` instance knows where its mount point
    is the place that the `cog` should render its output to. We define another custom
    data attribute, `starttimeunix`, and we set it to the Unix timestamp value of
    when the Gopher started working for IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the value is obtained from calling the template action, which places
    the value obtained by pipelining the `StartTime` property to the custom template
    function, `unixformat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unixformat` custom template function is an alias to the `UnixTime` function
    defined in the `shared/templatefuncs/funcs.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This function will return the time as a `string` value, in Unix format, for
    a given `Time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Returning back to the `about_content.tmpl` source file, take note of the `humanReadableDate`
    CSS `className` provided to the `div` container. We'll be using this CSS `className`
    later to fetch all the `timeago` cog `div` containers on the About page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to declare the cog's `div` container on the About page,
    let's take a look at how to implement the time ago `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time ago `cog` is a pure Go `cog`. That means it''s implemented using only
    Go. The Go package, `go-humanize`, provides us the functionality we need to display
    the time in human readable format. We are going to utilize this package to implement
    the time ago `cog`. Here''s the URL to the GitHub page for the `go-humanize` package:
    [https://github.com/dustin/go-humanize](https://github.com/dustin/go-humanize).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `shared/cogs/timeago/timeago.go` source file. We start out
    by declaring the package name as `timeago`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In our import grouping, we include `github.com/uxtoolkit/cog`, the package
    that provides us with functionality to implement a `cog` (shown in bold). We include
    the `go-humanize` grouping in our import grouping and alias it with the name `"humanize"`
    (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All cogs must declare an unexported variable called `cogType`, which is of
    type `reflect.Type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `init` function, we assign the `cogType` variable with the value
    returned by calling the `reflect.TypeOf` function on a newly created `TimeAgo`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Initializing the `cogType` variable is also required for every `cog` that we
    implement. Properly setting the `cogType` allows the static assets bundling system
    to account for the cog's static assets dependencies in the web application. The
    `cogType` will be utilized to gather all of the templates and static assets that
    are required to make the `cog` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `struct` we use to define the `TimeAgo cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Take note that we have embedded `ux.UXCog` in our `struct` definition. As noted
    earlier, the `cog.UXCog` type will provide us the necessary functionality to allow
    us to render the `cog`. Besides embedding the `ux.UXCog`, we have declared an
    unexported field, called `timeInstance`, of type `time.Time`. This will contain
    the `time.Time` instance that we will be converting to human readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a constructor function called `NewTimeAgo` that returns a new `TimeAgo
    cog` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The constructor function that we have here, follows the same pattern as any
    other constructor function implemented in Go. Notice that we pass the `cogType`
    to the `SetCogType` method of the newly created `TimeAgo` instance. This is required
    so that the the cog's static assets are included in the static assets bundle that
    is produced by isokit's static asset bundling system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a setter method for the `TimeAgo` struct''s `timeInstance` field
    called `SetTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This setter method will be used by the client-side application to set the time
    for the `TimeAgo` cog. We will use the `SetTime` method to set the start date
    of when the gopher joined the IGWEB team.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the `Cog` interface, a `cog` must define a `Start` method.
    The `Start` method is where the action in a `cog` happens. You should be able
    to get a general idea of what a `cog` does by reading its `Start` method. Here''s
    the `Start` method for the `TimeAgo` cog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `Start` method returns an error object to inform the caller whether or not
    the `cog` started up properly. Prior to performing any activity, a check is made
    to see if a `timeInstance` value has been set. We use an `if` conditional statement
    to check if the `timeInstance` value is at its zero value, indicating that it
    has not been set. If this condition occurs, the method returns a newly created
    `error` object indicating that the time value has not been set. If the `timeInstance`
    value has been set, we continue forward.
  prefs: []
  type: TYPE_NORMAL
- en: We call the cog's `SetProp` method to set the `timeAgoValue` property with the
    human understandable time value. We get the human understandable time value by
    calling the `Time` function from the `go-humanize` package (aliased as `humanize`)
    and passing it the cog's `timeInstance` value.
  prefs: []
  type: TYPE_NORMAL
- en: We call the cog's `Render` method to render the `cog`. If an error occurred
    while attempting to render the `cog`, the `Start` method will return the `error`
    object. Otherwise, a value of `nil` will be returned to indicate that there was
    no error starting the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have implemented the Go portion of the `timeago` cog. In order
    to make the human readable time appear on the web page, we have to implement the
    cog's template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `timeago.tmpl` file (found in the `shared/cogs/timeago/templates` directory)
    is a simple, one-liner template. We declare the following `span` element, and
    we have a template action to render the `timeAgoValue` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we must name the primary template of a `cog` found in the `cog`
    package's `templates` folder with the same name of the cog's package. For example,
    for the `timeago` package, the primary template of the `cog` will be `timeago.tmpl`.
    You are free to define and use any custom template function that has been registered
    with the application's template set along with the `cog` templates. You are also
    free to create any number of sub-templates that will be called by the cog's primary
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the template for the `TimeAgo` cog in place, we have everything
    we need to instantiate the `cog` on the About page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `InitializeAboutPage` function in the `client/handlers/about.go`
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since there are three gophers listed on the About page, there will be a total
    of three `TimeAgo` cog instances running on the page. We gather the `div` containers
    for the cogs using the `GetElementByClassName` method on the `env.Document` object,
    supplying a class name of `humanReadableDate`. We then loop through each `div`
    element, and this is where all the action to instantiate the `cog` takes place.
  prefs: []
  type: TYPE_NORMAL
- en: First, we extract the Unix timestamp value from the custom data attribute contained
    in the `div` container. Recall that we had populated the `starttimeunix` custom
    data attribute with the Unix timestamp of the Gopher's start time, using the custom
    template function, `unixformat`.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `time.Time` object using the `Unix` function available
    in the `time` package and providing the `unixTimestamp` we extracted from the
    custom data attribute of the `div` container. The code to instantiate and set
    up the `TimeAgo` cog is shown in bold. We first instantiate a new `TimeAgo` cog
    by calling the constructor function, `NewTimeAgo`, and assigning it to the `humanTime` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `CogInit` method on the `humanTime` object and supply it with
    the `env.TemplateSet` object. We call the `SetID` method to register the `div`
    container's `id` attribute to associate it with the `cog` instance. We then call
    the `SetTime` method on the `TimeAgo` cog, passing in the `time.Time` object,
    `t`, that we had created using the `unixTimestamp` we extracted from the `div`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: We have everything in place now to start up the `cog` by calling its `Start`
    method. We assign the `error` object returned by the `Start` method to `err`.
    If `err` is not equal to `nil`, it indicates that an error occurred while starting
    up the `cog`, and in that case we print out a meaningful message in the web console.
    If there were no errors, the `cog` will be rendered to the web page. *Figure 9.6*
    shows a screenshot of Molly's start time in human readable format.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15fecc9b-375a-4b05-89b6-9892c784b211.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The time ago cog in action'
  prefs: []
  type: TYPE_NORMAL
- en: The live clock cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we called the `Start` method on the time ago `cog`, the time was rendered
    on the web page using the virtual DOM, instead of a replace inner HTML operation
    taking place. Since the time ago `cog`, only updates the time once, upon calling
    the `Start` method of the `cog`, it's hard to appreciate the cog's virtual DOM
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we're going to build a live clock `Cog`, which has the ability
    to display the current time of any place in the world. Since we'll be displaying
    the time to the seconds, we'll be performing a `SetProp` operation every second
    to re-render the live clock `Cog`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.7* is an illustration of the live clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa3d10d9-cfda-475d-952d-b54caf49810b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: An illustration depicting the live clock cog'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be rendering the current time for four places: where you are presently
    located, Chennai, Singapore, and Hawaii. Inside the `shared/templates/index_content.tmpl`
    template source file, we declare four `div` containers that serve as the mounting
    points for the four live clock cogs we''ll be instantiating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice again that we have defined the mount points for the live clocks by declaring
    `div` containers containing the attribute, `"data-component"`, and having its
    value set to `"cog"`. We assign unique IDs to all four `cog` containers. The class
    name, `liveclockTime`, that we have declared in the `div` container is for styling
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the mounting points for the four live clock cogs, let's
    take a look at how to implement the live clock `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation for the live clock `Cog` can be found in the `liveclock.go`
    source file in the `shared/cogs/liveclock` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare the name `liveclock` for the cog''s package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, that in our import grouping we have included the `github.com/uxtoolkit/cog`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `cogType` unexported package variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `init` function, we assign the `cogType` variable with the value
    returned by calling the `reflect.TypeOf` function on a newly created `LiveClock`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is a required step to implement a `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've established that declaring and initializing the `cogType` of
    a `cog` are part of the baseline requirements that we must perform to implement
    a `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the struct for the `LiveClock` cog looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We embed the `cog.UXCog` type in the cog's struct definition. We introduce a
    `ticker` field which is a pointer to a `time.Ticker`. We'll be using this `ticker` to
    tick at every second for the live clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `LiveClock` cog''s constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `NewLiveClock` function serves as the constructor function for the live
    clock `cog`. We declare and initialize the `liveClock` variable to a new `LiveClock`
    instance. We call the `SetCogType` method of the `liveClock` object and pass the
    `cogType`. Recall that this is a required step (shown in bold) that must be present
    in a cog's constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `SetCleanupFunc` method of the `liveClock` object, and provide
    it a clean up function, `liveClock.Cleanup`. The `SetCleanUp` method is included
    in the `cog.UXCog` type. It allows us to specify a clean up function that should
    be called prior to the `cog` being removed from the DOM. Finally, we return the
    new instance of the `LiveClock cog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `Cleanup` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function is really simple. We simply call the `Stop` method on the cog's `ticker`
    object to stop the `ticker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the cog''s `Start` method where the `ticker` will be started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out by declaring the time layout constant, `layout`, and setting it
    to the `RFC1123Z` time format. We declare a `location` variable, a pointer to
    a `time.Location` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to starting up a `LiveClock` cog, the user of the `cog` must set two
    important props, the `"timezoneName"`, and the `"timezoneOffset"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These values are used to initialize the location variable. If either of these
    props were not provided, an `error` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If both of the props are present, we proceed to assigning the `ticker` property
    of the live clock `cog` to a newly created `time.Ticker` instance, which will
    tick at every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We `range` on the ticker''s channel to iterate at every one second, as a value
    arrives, and we set the `currentTime` prop, providing it a formatted time value
    (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used both the location, and the time layout to format the time.
    Once the `cog` has been rendered, calls to `SetProp` that will occur every second
    will automatically call the `Render` method to re-render the `cog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a call to the cog''s `Render` method to render the `cog` to the web
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last line of the method, we return a `nil` value to indicate that no
    errors occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined the template for the `cog` in the `liveclock.tmpl` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We print out the time label, along with the current time. The `timeLabel` prop
    is used to supply the time label to the `cog` and will be the name of the place
    for which we want to know the current time of.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen what goes into making the live clock `cog`, and how it displays
    the time, let's go ahead and sprinkle some live clock cogs on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the section of code inside the `InitializeIndexPage` function of the
    `index.go` source file, where we instantiate the live clock cog for the local
    time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In order to instantiate the cog for the local time, we first obtain the local
    zone name and the local time zone offset. We then create a new instance of a `LiveClock
    cog` called `lc`. We call the `CogInit` method to initialize the cog. We call
    the `SetID` method to register the `id` of the cog's mount point, the `div` container
    where the `cog` will render its output to. We make calls to the `SetProp` method
    to set the `"timeLabel"`, `"timezoneName"`, and `"timezoneOffset"` props. Finally,
    we call the `Start` method to start up the `LiveClock` cog. As usual, we check
    to see if the `cog` started up properly, and if it didn't, we print the `error`
    object in the web console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, we instantiate the `LiveClock` cogs for Chennai, Singapore,
    and Hawaii, in much the same way as we did for the local time, except for one
    thing. For the other places, we explicitly provide the timezone name and the GMT
    timezone offset for each place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will be able to see the live clock cogs in action. *Figure 9.8* is a
    screenshot of the live clogs displayed on the homepage.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e166fd4-a7db-4b49-8d19-07f012ac9d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The live clock cog in action'
  prefs: []
  type: TYPE_NORMAL
- en: With every passing second, each live clock gets updated with the new time value.
    The virtual DOM kicks in and renders only the difference of what changed, efficiently
    re-rendering the live clock at every second.
  prefs: []
  type: TYPE_NORMAL
- en: The first two cogs that we have implemented so far, have been pure cogs that
    are entirely implemented in Go. What if we wanted to leverage an existing JavaScript
    solution to provide a specific feature? That would be a situation that calls for
    implementing a hybrid cog, a `cog` that is implemented in Go and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing hybrid cogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has been around for more than two decades. In that time span, a lot
    of robust, production-ready solutions have been created using the language. Isomorphic
    Go cannot exist on its own island, and we have to acknowledge that there are many
    helpful, ready-made solutions that are useful from the JavaScript ecosystem. In
    many scenarios, we can save considerable time and effort by creating solutions
    that leverage existing JavaScript solutions, rather than re-implementing the whole
    solution in a pure Go manner.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid cogs are implemented using Go and JavaScript. The main purpose of hybrid
    cogs is to leverage functionality in existing JavaScript solutions and expose
    that functionality as a `cog`. This means that `cog` implementors would need to
    know both Go and JavaScript to implement hybrid cogs. Keep in mind that users
    of hybrid cogs only need to know Go, since the usage of JavaScript is an internal
    implementation detail of the `cog`. This allows cogs to be readily usable by Go
    developers that may not be familiar with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The date picker cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider a scenario that warrants the implementation of a hybrid `cog`.
    Molly, the de-facto product manager of IGWEB, came up with a killer idea to provide
    better customer support. Her feature request to the tech team was to allow the
    website user to provide an optional priority date on the contact form, by which
    a user should hear back from a gopher on the IGWEB team.
  prefs: []
  type: TYPE_NORMAL
- en: Molly found a self-contained, date picker widget, implemented in vanilla JavaScript
    (no framework/library dependencies) called Pikaday: [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pikaday, JavaScript date picker widget, highlights the fact that was presented
    in the beginning of this section. JavaScript is not going away, and there are
    many useful solutions that have already been made using it. That means, we must
    have the capability to leverage existing JavaScript solutions when it makes sense
    to do so. The Pikaday date picker is a particular use-case where it is more beneficial
    to leverage this existing JavaScript date picker widget, rather than implement
    one as a pure `cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72dbbc90-5aa2-4242-a10a-c8bb83c6cfb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: A wireframe design depicting the time sensitivity date input field
    and the calendar date picker widget'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.9* is a wireframe design depicting the contact form with a time sensitivity
    input field, that when clicked, will reveal a calendar date picker. Let''s see
    what it takes to fulfill Molly''s request by implementing the date picker cog,
    a hybrid cog, made with Go and JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: We start out by placing the JavaScript and CSS source files required by the
    Pikaday, date picker widget, inside the `js` and `css` folders (respectively),
    inside the cog's `static` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `shared/templates/partials/contactform_partial.tmpl` source file,
    we declare the mount point for the date picker cog (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `div` container fulfills two basic requirements of all `cog` mounting points:
    we have set the attribute, `"data-component"`, with the value `"cog"`, and we
    have specified an `id` of `"sensitivityDate"` for the `cog` container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the implementation of the date picker cog, defined in the `shared/cogs/datepicker/datepicker.go`
    source file, section by section. First, we start out by declaring the package
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the cog''s import grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we include the `gopherjs` package in the import grouping (shown
    in bold). We will need functionality from `gopherjs` to query the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after we declare the `cogType`, we initialize the `JS` variable to `js.Global`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you may recall, this saves us a little bit of typing. We can directly refer
    to `js.Global` as `JS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Pikaday project web page, [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday),
    we can learn all of the input parameters the date picker widget accepts. The input
    parameters are provided as a single JavaScript object. The date picker `cog` will
    expose a subset of these input parameters, just enough to fulfill Molly''s feature
    request. We create a `struct` called `DatePickerParams` that serves as the input
    parameters to the date picker widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We embed the `*js.Object` to indicate that this is a JavaScript object. We then
    declare the respective Go fields for the `struct` for the respective properties
    of the JavaScript input object. For example, the field named `Field` is for the
    `field` property. The `"js"` `struct` tags that we have provided for each field
    allows GopherJS to convert the `struct` and its field, from its designated Go
    name to its equivalent JavaScript name. Just as we declared the field named Field,
    we have also declared fields for `FirstDay` (`firstDay`), `MinDate` (`minDate`),
    `MaxDate` (`maxDate`), and `YearRange` (`yearRange`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the Pikaday documentation, [https://github.com/dbushell/Pikaday](https://github.com/dbushell/Pikaday),
    we can learn what purpose each of these input parameters serve:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Field` - Used to bind the date picker to a form field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirstDay` - Used to specify the first day of the week. (0 for Sunday, 1 for
    Monday, etc).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinDate` - The earliest date that can be selected in the date picker widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxDate` - The latest date that can be selected in the date picker widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YearRange` - The range of years to display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve defined the date picker''s input parameters struct, `DatePickerParams`,
    it''s time to implement the date picker `cog`. We start out by declaring the `DatePicker`
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we embed the `cog.UXCog` to bring along all the UXCog functionality
    we need. We also declare a field, `picker`, that's a pointer to a `js.Object`.
    The `picker` property will be used to refer to the Pikaday date picker JavaScript
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then implement a constructor function for the date picker `cog` called `NewDatePicker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: By now, the cog constructor should look familiar to you. Its duties are to return
    a new instance of a `DatePicker` and to set the cog's `cogType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our constructor function is in place, it''s time to examine the date
    picker cog''s `Start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We start out by checking to see if the `"datepickerInputID"` prop has been set.
    This is the `id` of the input field element, which will be used as the `Field`
    value in the `DatePickerParams` `struct`. It is a hard requirement, that this
    prop must be set by the caller, before starting the `cog`. Failure to set this
    prop will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: If the `"datepickerInputID"` prop has been set, we call the cog's `Render` method
    to render the cog. This will render the HTML markup for the input field that the
    date picker JavaScript widget object will rely on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then go on to declare and instantiate, `params`, the input parameters JavaScript
    object that will be shipped to the date picker JavaScript widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The date picker input parameters object, `params`, is a JavaScript object. The
    Pikaday JavaScript object will use the `params` object for initial configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the cog''s `Props` property to range through the cog''s properties.
    For each iteration we fetch the property''s name (`propName`) and the property''s
    value (`propValue`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` block we have declared is important for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Each `case` statement inside the `switch` block, tells us all the properties
    the date picker `cog` accepts as input parameters that will be ferried over to
    the Pikaday JavaScript widget. If a prop name is not recognized, we print out
    a warning in the web console that the prop is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: The first case, handles the `"datepickerInputID"` prop. It will be used to specify
    the `id` of the input element that activates the Pikaday widget. Inside this `case`,
    we get the input element field by calling the `getElementById` method on the `document`
    object and passing the `inputFieldID` to the method. We set the input `params`
    property, `Field` to the input field element that was obtained from the `getElementById` method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The second case handles the `"datepickerLabel"` prop. The value for the `"datepickerLabel"`
    prop will be used in the cog's template source file. Therefore there's no work
    needed to handle this particular case.
  prefs: []
  type: TYPE_NORMAL
- en: The third case handles the `"datepickerMinDate"` prop. It will be used to get
    the minimum date that should be shown by the Pikaday widget. We convert the `"datepickerMinDate"`
    value of `type time.Time` provided by the caller to its Unix timestamp representation.
    We then create a new JavaScript `date` object using the Unix timestamp, which
    is suitable for use for the `minDate` input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth case handles the `"datepickerMaxDate"` prop. It will be used to get
    the maximum date that should be shown by the date picker widget. We follow the
    same strategy here, that we did for the `minDate` argument.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth case handles the `"datepickerYearRange"` prop. It will be used to
    specify the range of years that the displayed calendar will cover. The year range
    is a slice, and we populate the `YearRange` property of the input parameters object
    using the prop's value.
  prefs: []
  type: TYPE_NORMAL
- en: As stated earlier, the `default` `case` handles the scenario, where the caller
    provides a prop name that is not known. If we reach the `default` `case`, we print
    out a warning message in the web console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can instantiate the Pikaday widget and provide the input parameters
    obect, `params`, to it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we indicate that there were no errors starting up the cog, by returning
    a `nil` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have implemented the date picker cog, let''s take a look at what
    the cog''s primary template, defined in the `shared/cogs/datepicker/templates/datepicker.tmpl`
    source file, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We declare a `label` element to display the label of the date picker cog using
    the prop `"datepickerLabel"`. We declare an `input` element that will serve as
    the input element field that will be used in conjunction with the Pikaday widget.
    We specify the `id` attribute of the input element field using the `"datepickerInputID"`
    prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have implemented the date picker cog, it''s time to start using
    it. We instantiate the `cog` inside the `InitializeContactPage` function, found
    in the `client/handlers/contact.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new instance of the `DatePicker cog`. We then call the cog's `CogInit`
    method, to register the application's template set. We call the `SetID` method
    to set the cog's mount point. We make calls to the cog's `SetProp` method to set
    the `datePickerLabel`, `datepickerInputID`, `datepickerMinDate`, and `datepickerMaxDate`
    props. We call the cog's `Start` method to activate it. If there were any errors
    starting the `cog`, we print the error message out to the web console.
  prefs: []
  type: TYPE_NORMAL
- en: And that's all there is to it! We could leverage the functionality we needed
    from the Pikaday widget using the date picker hybrid `cog`. The advantage of this
    approach is that Go developers utilizing the date picker `cog` will not need to
    have knowledge of the inner workings (JavaScript) of the Pikaday widget in order
    to use it. Instead, they can use the functionality that the date picker `cog`
    exposes to them from within the confines of Go.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.10* shows a screenshot of the date picker `cog` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e47b957-a807-4bb5-8ccf-4950f4ddd950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: The calendar date picker widget in action'
  prefs: []
  type: TYPE_NORMAL
- en: Even if the cog user didn't provide any props, other than the required `datepickerInputID`,
    to custom configure the date picker `cog`, the Pikaday widget starts up just fine.
    However, what if we needed to supply a default set of parameters for the `cog`?
    In the next example, we are going to build another hybrid `cog`, a carousel (an
    image slider) `cog`, in which we will define default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The carousel cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will be creating an image carousel cog, as depicted by the
    wireframe design in *Figure 9.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc822f06-91d8-4abd-ad46-dee1c7ecf5f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: A wireframe design depicting the carousel cog'
  prefs: []
  type: TYPE_NORMAL
- en: 'The carousel cog will be powered by the tiny-slider widget which is implemented
    in vanilla JavaScript. Here''s the URL to the tiny-slider project: [https://github.com/ganlanyuan/tiny-slider](https://github.com/ganlanyuan/tiny-slider).'
  prefs: []
  type: TYPE_NORMAL
- en: We place the JavaScript source file for the tiny-slider widget, `tiny-slider.min.js`
    in the cog's `static/js` folder. We place the CSS files associated with the tiny-slider
    widget, `tiny-slider.css`, and `styles.css` in the `static/css` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The carousel cog that we will build will expose the following input parameters
    provided by the tiny-slider widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `container` parameter represents the slider container element or selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `items` parameter represents the number of slides being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slideBy` parameter represents the number of slides going on one "click":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `autoplay` parameter toggles the automatic change of slides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `autoplayText` parameter controls the text or markup that appears in the
    autoplay start/stop button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `controls` parameter is used to toggle the display and functionalities of
    controls (previous/next buttons).
  prefs: []
  type: TYPE_NORMAL
- en: 'The image carousel will display a set of featured products available on IGWEB.
    We''ve declared the cog''s mounting point in the `shared/templates/index_content.tmpl`
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We've declared the `div` container that will serve as the carousel cog's mount
    point. We've declared the attribute, `"data-component"`, and assigned it a value
    of `"cog"`. We've also declared an `id` attribute of `"carousel"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The carousel cog is implemented in the `carousel.go` source file found in the
    `shared/cogs/carousel` folder. Here''s the package declaration and import groupings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The tiny-slider widget is instantiated with an input parameters JavaScript
    object. We''ll be using the `CarouselParams struct` to model the input parameters
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: After embedding the pointer to `js.Object`, each field that we have defined
    in the `struct` corresponds to its equivalent JavaScript parameter object property.
    For example, the `Container` field maps to the `container` property of the input
    parameters object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the struct that defines the `carousel` cog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As usual we embed the `cog.UXCog` type to borrow functionality from the `UXCog`.
    The `carousel` field will be used to refer to the tiny-slider widget, which is
    a JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should be able to guess what the carousel cog''s constructor function
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Besides creating a new reference to a `Carousel` instance, the constructor function
    sets the cog's `cogType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to examine the lion''s share of the carousel cog''s implementation,
    which is found in the cog''s `Start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We start out by checking if the user of the `cog` has set the `contentItems`
    and `carouselContentID` props. The `contentItems` prop is a string slice of server
    relative image paths for the images that should appear in the carousel. The `carouselContentID`
    prop is the value of the `id` attribute of the `div` container that holds the
    carousel's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'If either of these props haven''t been set, we return an `error` indicating
    that both of these props must be set. If the two props have been set, we proceed
    to render the cog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We render the `cog` at this juncture, since there is HTML markup that needs
    to exist on the web page in order for the `cog` to function properly. Notably,
    the `div` container that holds the carousel''s content, whose `id` we supply using
    the required `carouselContentID` prop. If there was an `error` rendering the `cog`,
    we return the `error` to indicate that the `cog` cannot be started. If there was
    no `error` encountered while rendering the `cog`, we proceed to instantiate the
    input parameters object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This `struct` represents the input parameters that we will be feeding to the
    tiny-slider object upon its instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of code is important, since this is where we define the default
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When a cog maintainer looks at this block of code, they can readily ascertain
    what the default behavior of the cog is. From looking at the default parameters,
    one can tell that the slider will show only one item at a time. The slider is
    set to slide by page mode and the slider will automatically start the slideshow.
    We've provided a string slice for the `AutoplayText` property, with text symbols
    for the play and stop buttons using the `PLAYTEXT` and `STOPTEXT` constants respectively.
    We have set the `Controls` property to `false`, so that the Next and Previous
    buttons will not appear on the image carousel by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We proceed to iterate over all the properties that the user of the `cog` has
    provided, accessing each prop, consisting of a `propName` (`string`) and a `propValue`
    (`interface{}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a `switch` block on the `propName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Using the `switch` block makes it easy to see the names of all the valid props
    in each `case` statement that is defined. If a prop name is not known, it falls
    into the `default` case, where we print a warning message in the web console.
  prefs: []
  type: TYPE_NORMAL
- en: The first `case` handles the required `"carouselContentID"` prop. It is used
    to specify the `div` container that will contain the content items of the carousel.
  prefs: []
  type: TYPE_NORMAL
- en: The second `case` handles the required `"contentItems"` prop. This prop is a
    `string` slice, and it's meant to be used in the cog's template, so there's no
    action that we have to perform for it.
  prefs: []
  type: TYPE_NORMAL
- en: The third `case` handles the `"items"` prop. This is the prop that handles the
    tns-slider object's `items` parameter, which shows the amount of slides to display
    at a given time. If the prop value is not `nil`, we assign the `int` value of
    the prop value to the `params.Items` property.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth `case` handles the `slideBy` prop. If the prop value is not `nil`,
    we assign the prop value (type asserted as a `string`) to the `SlideBy` property
    of the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth `case` handles the `"autoplay"` prop. If the prop value is not `nil`,
    we assign the prop value (type asserted as a `bool`) to the `Autoplay` property
    of the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: The sixth `case` handles the `"autoplayText"` prop. If the prop value is not
    `nil`, we assign the prop value (type asserted as a `[]string`) to the `AutoplayText`
    property of the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: The seventh `case` handles the `"controls"` prop. If the prop value is not `nil`
    we assign the property value (type asserted as a `bool`) to the `Controls` property
    of the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: If the property name does not fall under any of the seven previous cases, it
    will be handled by the `default case`. Recall, that if we were to reach this `case`,
    it indicates that the user of the `cog` has supplied a prop name that is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now instantiate the tiny-slider widget and assign it to the cog''s `carousel` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of `nil` is returned by the `Start` method, to indicate that there
    were no errors encountered while starting up the `cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shared/cogs/carousel/templates/carousel.tmpl` source file defines the
    template for the carousel `cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We declare a `div` container to house the carousel's images. Each item in the
    `contentItems` `string` slice is a server relative path to an image. We use the
    `range` template action to iterate through the `contentItems` property (a `string`
    slice) to print out the address of each image, which resides inside its own `div`
    container. Notice that we provide the dot (`.`) template action as the value for
    the `img` element's `src` attribute. The dot template action represents the current
    value while iterating through the `contentItems` slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have implemented the carousel `cog` and created its template, it''s
    time to instantiate and start the `cog` on the homepage. We place the code to
    add the carousel `cog` at the beginning of the `InitializeIndexPage` function
    inside the `client/handlers/index.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We start out by creating a new carousel `cog`, `c`, by calling the constructor
    function `NewCarousel`. We call the `CogInit` method to associate the application's
    template set to the `cog`. We call the `SetID` method to associate the `cog` to
    its mount point, the `div` container where the `cog` will render its output to.
    We create a `string` slice using a `string` slice literal that consists of the
    paths to the image files. We make calls to the `SetProp` method to set the required
    `contentItems` and the required `carouselContent` props. We don't set any other
    prop, because we're satisfied with the carousel cog's default behavior. We start
    up the `cog` and check if we encountered any errors while doing so. If there were
    any errors encountered, we print the error message in the web console.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.12* is a screenshot of the rendered carousel cog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4be2b386-51b2-4bd6-899d-d06b545241a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: The carousel cog in action'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've wrapped up the carousel cog, we're going to create a notify cog
    in the next section that displays an animated notification message on the web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The notify cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All `cog` implementations that we've considered, thus far, have rendered output
    to the web page. Let's consider the implementation of a `cog` that doesn't render
    any output to the web page. The notify `cog` that we are going to implement, will
    utilize the Alertify JavaScript library to display animated notification messages
    on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.13* is an illustration depicting a notification message that appears
    on the bottom-right corner of the web page, when the user adds an item to the
    shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/132cedbc-64e4-4837-8316-8be30cb47e23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: An illustration depicting a notification'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `cog` will solely rely on the JavaScript library for its rendering
    needs, we won't have to implement a template for the `cog`, and we don't have
    to declare a mount point for the cog either.
  prefs: []
  type: TYPE_NORMAL
- en: We will be leveraging the functionality from the Alertify JavaScript library
    to display notifications. Here's the URL to the Alertify project: [https://github.com/MohammadYounes/AlertifyJS](https://github.com/MohammadYounes/AlertifyJS).
  prefs: []
  type: TYPE_NORMAL
- en: Peek inside the `shared/cogs/notify` folder, and notice that no templates folder
    exists. We have placed the static assets for Alertify's CSS, and JavaScript source
    files, in the `shared/cogs/notify/static/css` and `shared/cogs/notify/static/js` folders
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The notify `cog` is implemented in the `notify.go` source file found in the
    `shared/cogs/notify` folder. Since it makes sense for the client-side web application
    to have only one notification system that which is provided by the notify `cog`,
    only once instance of the `cog` should ever be started. In order to keep track
    and ensure that only one notify `cog` instance can be started, we will declare
    the `alreadyStarted` Boolean variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Notify` struct defines the fields of the notify `cog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We type embed the `cog.UXCog` in order to bring over the functionality needed
    to implement the `Cog` interface. The `alertify` field is used to refer to the
    `alertify` JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: The notify `cog` that we are building is event-driven. For example, a success
    notification will be displayed when a custom success notification event is fired
    from any page on the client-side application. We have defined two fields, `successNotificationEventListener`
    and `errorNotificationEventListener`, which are both functions that take a JavaScript
    object pointer as an input variable. We have defined these fields, so that we
    can keep track of the custom event listener functions that we set up to listen
    for success and error notifications. When it comes time to remove the event listeners,
    it becomes easy to access them because they are properties of the notify `cog`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewNotify` function serves as a constructor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have registered a clean-up function (shown in bold), which will
    be called prior to the `cog` being destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the cog''s `Start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We first check to see if a notify `cog` instance has already been started by
    checking the value of the `alreadyStarted` Boolean variable. If the value of `alreadyStarted`
    is `true`, it indicates that a previous notify `cog` instance has already been
    started, so we return an `error` indicating that the notify `cog` could not be
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `cog` has not been started yet, we proceed to instantiate the Alertify
    JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We make a call to the cog''s `StartListening` method to set up the event listeners
    that listen for custom success and error notification message events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the cog''s `StartListening` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If we have reached this method, it indicates that the `cog` was started successfully,
    so we set the `alreadyStarted` Boolean variable to `true`. We set up an event
    listener that will listen for the `displaySuccessNotification` custom event. We
    keep track of the event listener function that we are creating by assigning it
    to the `successNotificationEventListener` property of the `cog` instance. We declare
    and instantiate the `message` variable and set it equal to the the `detail` property
    of the `event` object, which will contain the `string` `message` that should be
    displayed to the user on the web page. We then call the cog's `notifySuccess`
    method to display the success notification message on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: We follow a similar procedure to set up the event listener for the `displayErrorNotification`.
    We assign the event listener function to the cog's `errorNotificationEventListener`
    property. We extract the `detail` property from the `event` object and assign
    it to the `message` variable. We call the cog's `notifyError` method to display
    the error notification message on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notifySuccess` method is responsible for displaying a success notification
    message on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We call the alertify object's `success` method to display the success notification
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notifyError` method is responsible for displaying an error notification
    message on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: We call the alertify object's `error` method to display the error notification
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cog''s `CleanUp` method simply makes a call to the cog''s `StopListening`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `StopListening` method is used to remove the event listeners prior to the
    `cog` being destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We call the DOM object's `RemoveEventListener` method to remove the event listener
    functions that handle the `displaySuccessNotification` and `displayErrorNotification`
    custom events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notify` package''s exported `Success` function is used to broadcast a
    custom success event notification message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function, we create a new JavaScript object called `eventDetail`.
    We assign the `string` `message` that should be displayed on the web page to the
    `detail` property of the `eventDetail` object. We then create a new custom `event`
    object called `customEvent`. We pass in the name of the custom event, `displaySuccessNotification`,
    along with the `eventDetail` object as input arguments to the `CustomEvent` type's
    constructor function. Finally, to dispatch the event, we call the `dispatchEvent`
    method on the `window` object and supply the `customEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The notify package''s exported `Error` function is used to broadcast a custom
    error event notification message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this function is nearly identical to the `Success` function.
    The only difference is that we dispatch a `displayErrorNotification` custom event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate and start the notify `cog` (shown in bold) inside the `InitializePageLayoutControls`
    function found in the `client/handlers/initpagelayoutcontrols.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The notification messages (success or error) for adding an item to the shopping
    cart are found within the `addToCart` function inside the `client/handlers/shoppingcart.go`
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `notify.Error` function is called (shown in bold) if the item could not
    be added to the shopping cart. The `notify.Success` function is called (shown
    in bold) if the item was successfully added to the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The notification messages for removing an item from the shopping cart are found
    in the `removeFromCart` function in the `client/handlers/shoppingcart.go` source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `notify.Error` function is called (shown in bold) if the item could not
    be removed from the shopping cart. The `notify.Success` function is called (shown
    in bold) if the item was successfully removed from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9.14* is a cropped screenshot of the notification cog in action, when
    we add a product to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6776f61a-1404-4129-8eb4-8815fef218c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: The notify cog in action'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to cogs—reusable components that could be
    implemented either exclusively in Go (pure cogs) or with Go and JavaScript (hybrid
    cogs). Cogs come with many benefits. We can use them in a plug and play manner,
    create multiple instances of them, readily maintain them due to their self-contained
    nature, and easily reuse them since they can exist as their own Go package along
    with their required static assets (template files, CSS, and JavaScript source
    files).
  prefs: []
  type: TYPE_NORMAL
- en: We introduced you to the UX toolkit, which provides us with the technology to
    implement cogs. We studied the anatomy of a cog and explored what a cog's file
    structure may look like with regards to the placement of Go, CSS, JavaScript,
    and template files. We considered how cogs utilize a virtual DOM to render their
    contents instead of performing an expensive replace inner HTML operation. We presented
    the various stages of the cog's life cycle. We showed you how to implement various
    cogs that we sprinkled all across IGWEB, which included both pure cogs and hybrid
    cogs.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](23f09ecc-d992-4efb-8f48-b83f65fac7a1.xhtml), *Testing an Isomorphic
    Go Web Application*, we will learn how to perform automated, end-to-end testing
    of IGWEB. This will consist of implementing tests to exercise functionality on
    both the server-side and the client-side.
  prefs: []
  type: TYPE_NORMAL
