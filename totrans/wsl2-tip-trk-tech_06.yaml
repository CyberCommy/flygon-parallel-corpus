- en: '*Chapter 4*: Windows to Linux Interoperability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B16412_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Introduction
    to the Windows Subsystem for Linux*, we compared the WSL experience to running
    Linux in a virtual machine; where virtual machines are focused around isolation,
    WSL has strong interoperability built in between Windows and Linux. In this chapter,
    you will start to be introduced to these capabilities, starting with interacting
    with files and applications running under WSL and files from the Windows host
    environment. This will include looking at how to pipe output between scripts running
    in Windows and WSL. After this, we will look at how WSL enables web applications
    in Linux to be accessed from Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Linux files from Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Linux applications from Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing Linux web applications from Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Linux files from Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have WSL installed, you get a new `\\wsl$` path that you can address
    in Windows Explorer and other programs. If you type `\\wsl$` into the address
    bar in Windows Explorer, it will list any running Linux **distributions** (**distros**)
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A screenshot showing \\wls$ in Windows Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16412_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – A screenshot showing \\wls$ in Windows Explorer
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, each running distro shows as a path
    under `\\wsl$`. Each `\\wsl$\<distroname>` is the path to the root of the file
    system for `<distroname>`. For example, `\\wsl$\Ubuntu-20.04` is the Windows path
    for accessing the root of the file system for the `Ubuntu-20.04` distro from Windows.
    This is a very flexible and powerful capability bringing full access to the file
    systems of your Linux distros to Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `\\wsl$\Ubuntu-20.04\home\stuart\tmp` path
    in Windows Explorer. This corresponds to the `~/tmp` folder in the `Ubuntu-20.04`
    distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A screenshot showing the contents of a Linux distro in Windows
    Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16412_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – A screenshot showing the contents of a Linux distro in Windows
    Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'In these screenshots, you can see the Linux file system in Windows Explorer,
    but these paths can be used by any application that can accept UNC paths (that
    is, paths starting with `\\`). From PowerShell, for example, you can read and
    write from the Linux file system the same as you would from Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a text file has been created as `~/tmp/hello-wsl.txt` in the
    Ubuntu 20.04 distro, with the contents `Hello from WSL!`, and the `Get-Content`
    PowerShell cmdlet is used to read the contents of the file using the `\\wsl$\...`
    path we saw previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you browse the file system in Windows Explorer, double-clicking on a file
    will attempt to open it in Windows. For example, double-clicking on the text file
    we looked at in *Figure 4.2* will open it in your default text editor (Notepad
    in my case), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A screenshot showing a Linux file open in Notepad'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16412_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – A screenshot showing a Linux file open in Notepad
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the same content as in the previous example of getting
    the file content via PowerShell but open in Notepad. The `\\wsl$\...` path.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you browse to `\\wsl$` and don't see one of your installed distros, then
    it is an indication that the distro isn't running.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to start the distro is by launching a shell in it with Windows Terminal.
    Alternatively, if you know the distro name, you can type `\\wsl$\<distroname>`
    in the Windows Explorer address bar (or whatever application you are using) and
    WSL will automatically start the distro to allow you to browse the file system!
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in this section, the `\\wsl$\` share provides the ability to
    access files inside the file systems of your WSL distros from Windows applications.
    This is a useful step in bridging Windows and Linux with WSL as it allows you
    to use Windows tools and applications to work with files in the Linux file system.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at running applications in WSL from Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Running Linux applications from Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B16412_02_Final_JC_ePub.xhtml#_idTextAnchor023), *Installing
    and Configuring the Windows Subsystem for Linux*, you were briefly introduced
    to the `wsl` command and you saw how it could be used both for controlling running
    distros and for executing applications inside distros. In this section, we're
    going to dig deeper into running applications in distros with the `wsl` command.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the last section, being able to access files across Windows and
    Linux is useful and being able to invoke applications builds on this further.
    WSL doesn't stop with just being able to run applications in a distro from Windows,
    it also lets you pipe output between applications. When building up scripts in
    either Windows or Linux, piping output between applications is a very common way
    to build up script functionality. Being able to pipe output between Windows and
    Linux commands allows you to build scripts that run across both Windows *and*
    Linux, which really helps build that sense of uniting the two environments. We'll
    start looking at how that works next.
  prefs: []
  type: TYPE_NORMAL
- en: Piping into Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''re going to explore piping data from Linux to Windows.
    A scenario I have encountered many times is having some data such as log output
    that I want to perform some processing on. An example of this could be processing
    each line to extract an HTTP status code and then grouping and counting to calculate
    how many successes versus failures were logged. We''ll use an example that is
    representative of this scenario but doesn''t require any real setup: we will examine
    the files in the Windows directory and determine how many files there are that
    start with each letter of the alphabet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some PowerShell (we''ll build the script up, so don''t worry
    if you''re not totally familiar with PowerShell):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will use `Get-ChildItem` to get the contents of the `Windows`
    folder as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can perform the extraction, in this case taking the first letter of
    the filename. We can add to our previous command by piping the output from `Get-ChildItem`
    into the `ForEach-Object` cmdlet as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to group and count the items. Since the goal is to demonstrate
    piping output between Windows and Linux, we''ll ignore the PowerShell `Group-Object`
    cmdlet for now and instead use some common Linux utilities: `sort` and `uniq`.
    If you were using these commands in Linux with some other output, you could pipe
    that into them as `other-command | sort | uniq -c`. However, since `sort` and
    `uniq` are Linux commands and we''re running this from Windows, we need to use
    the `wsl` command to run them as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows the result we were aiming for: a count of the number
    of files and folders starting with each letter. But more importantly, it shows
    that piping output from a Windows command into a Linux command just works!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we called `wsl` twice: once for `sort` and once for `uniq`,
    which will cause the output to be piped between Windows and Linux for each stage
    in the pipeline. We can use a single `wsl` call if we structure the commands slightly
    differently. It might be tempting to try piping the input into `wsl sort | uniq
    -c` but that tries to pipe the output of `wsl sort` into a Windows `uniq` command.
    You might also consider `wsl "sort | uniq -c"` but that fails with the error `/bin/bash:
    sort | uniq -c: command not found`. Instead, we can use `wsl` to run `bash` with
    our command `wsl bash -c "sort | uniq -c"`. The full command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this gives the same output as the previous version but with
    only a single execution of `wsl`. While this might not be the most obvious way
    to run complex commands, it is a useful technique.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have been focused on piping data into Linux, but it works
    equally well when piping output from Linux commands, as we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Piping from Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section we looked at piping the output from Windows commands
    into Linux, and explored this by using PowerShell to retrieve the items in the
    `Windows` folder and get their first letters before passing the letters to Linux
    utilities to sort, group, and count them. In this section, we will be looking
    at piping output from Linux utilities to Windows. We'll use the reverse example
    of listing files via Bash and processing the output with Windows utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s get the files and folders from the `/usr/bin` folder in our
    default distro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows the contents of the `/usr/bin` folder and the next step is
    to take the first character of the name. For this, we can use the `cut` command.
    We could run `wsl ls /usr/bin | wsl cut -c1`, but we can reuse the technique we
    saw in the last section to combine it into a single `wsl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, we now have just the first characters
    and we are ready to sort and group them. For this exercise, we will pretend that
    the `sort` and `uniq` commands don''t exist and we will instead use the PowerShell
    `Group-Object` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that the output was successfully piped from the Bash commands
    run in WSL to the PowerShell `Group-Object` cmdlet. In the previous section, we
    forced the characters to be uppercased, but here we didn't need to do that as
    `Group-Object` performs a case-insensitive match by default (although that can
    be overridden with the `-CaseSensitive` switch).
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen through these examples, you call into Linux distros with WSL
    to execute Linux applications and utilities. The examples just used the default
    WSL distro, but in all of the examples above, you can add the `-d` switch on the
    `wsl` command to specify which distro to run the Linux commands in. This can be
    useful if you have multiple distros and the particular application you need is
    only available in one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pipe output in either direction between Windows and Linux applications
    allows a lot of flexibility in combining applications. If you're more familiar
    with Windows utilities, you might execute Linux applications and then process
    the results with Windows utilities. Or if Linux is where you feel more at home
    but you need to work on a Windows machine, then being able to invoke familiar
    Linux utilities to deal with Windows output will help you be more productive.
  prefs: []
  type: TYPE_NORMAL
- en: You've seen how to access Linux files from Windows and call Linux applications
    from Windows. In the next section, you'll see how to access a web application
    running in WSL from Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Linux web applications from Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are developing a web application, then you typically have your application
    open in your web browser as `http://localhost` while you are working on it. With
    WSL, your web application is running inside the WSL lightweight virtual machine,
    which has a separate IP address (you can find this with the Linux `ip addr` command).
    Fortunately, WSL forwards localhost addresses to Linux distros to preserve the
    natural workflow. You'll work through that in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with this, make sure that you have the code for the book cloned
    in a Linux distro, open a terminal, and navigate to the `chapter-04/web-app` folder
    at [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques/tree/main/chapter-04](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques/tree/main/chapter-04).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code uses Python 3, which should already be installed if you are
    using a recent version of Ubuntu. You can test whether Python 3 is installed by
    running `python3 -c ''print("hello")''` in your Linux distro. If the command completes
    successfully, then you''re all set. If not, refer to the Python documentation
    for instructions on installing it: [https://wiki.python.org/moin/BeginnersGuide/Download](https://wiki.python.org/moin/BeginnersGuide/Download).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chapter-04/web-app` folder, you should see `index.html` and `run.sh`.
    In the terminal, run the web server by running `./run.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You should see output similar to the preceding output to indicate that the web
    server is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that the web server is running by starting a new terminal in
    your Linux distro and running `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the HTML returned by the web server in response to the `curl`
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open your web browser in Windows and navigate to `http://localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – A screenshot showing a WSL web application in the Windows browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16412_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – A screenshot showing a WSL web application in the Windows browser
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding screenshot shows, WSL forwards traffic for **localhost** in
    Windows into Linux distros. When you are developing a web application with WSL
    or running applications with a web user interface, you can access the web application
    using **localhost** just as you would if it were running locally in Windows; this
    is another integration that really smooths out the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen the ways in which WSL allows us to interop with
    Linux distros from Windows, starting with accessing the Linux file system via
    the `\\wsl$\...` path. You also saw how to call Linux applications from Windows
    and that you can chain Windows and Linux commands together by piping output between
    them, just as you would normally in either system. Finally, you saw that WSL forwards
    **localhost** requests to web servers running inside WSL distros. This allows
    you to easily develop and run web applications in WSL and test them from the browser
    in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to access the file systems for your WSL distros and execute commands
    in them from Windows really helps to bring the two systems together, and it helps
    you pick your preferred tools for the tasks you are working on, regardless of
    which operating system they are in. In the next chapter, we will explore the capabilities
    for interacting with Windows from inside a WSL distro.
  prefs: []
  type: TYPE_NORMAL
