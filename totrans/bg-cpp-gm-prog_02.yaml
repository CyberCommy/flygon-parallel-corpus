- en: Chapter 2. Variables, Operators, and Decisions – Animating Sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will do quite a bit more drawing on the screen and to achieve
    this we will need to learn some of the basics of C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what is in store:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning all about C++ variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing how to manipulate the values stored in variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a static tree, ready for the player to chop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing and animating a bee and three clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variables** are the way that our C++ games store and manipulate values. If
    we want to know how much health the player has then we need a variable. Perhaps
    you want to know how many zombies are left in the current wave? That is a variable
    as well. If you need to remember the name of the player who got a particular high
    score, you guessed it, we need a variable for that. Is the game over or still
    playing? Yep, that''s a variable too.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables are named identifiers to locations in memory. So we might name a variable
    `numberOfZombies` and that variable could refer to a place in the memory that
    stores a value representing the number of zombies that are left in the current
    wave.
  prefs: []
  type: TYPE_NORMAL
- en: The way that computer systems address locations in memory is complex. Programming
    languages use variables to give a human-friendly way to manage our data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Our brief discussion about variables implies that there must be different types
    of variable.
  prefs: []
  type: TYPE_NORMAL
- en: Types of variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a wide variety of C++ variable types (see the next tip about variables).
    It would easily be possible to spend an entire chapter discussing them. What follows
    is a table of the most commonly used types in this book. Then we will look at
    how to actually use each of these variable types.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Examples of values** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| Int | `-42`, `0`, `1`, `9826`, and so on. | Integer whole numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| Float | `-1.26f`, `5.8999996f`, `10128.3f` | Floating point values with precision
    up to 7 digits. |'
  prefs: []
  type: TYPE_TB
- en: '| Double | `925.83920655234`, `1859876.94872535` | Floating point values with
    precision up to 15 digits. |'
  prefs: []
  type: TYPE_TB
- en: '| Char | `a`, `b`, `c`, `1`, `2`, `3` (a total of 128 symbols including `?`,
    `~`, `#`, and so on...) | Any symbol from the ASCII table (see next tip about
    variables). |'
  prefs: []
  type: TYPE_TB
- en: '| Bool | True or false | Bool stands for Boolean and can be only `true` or
    `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| String | Hello everyone! I am a string. | Any text value from a single letter
    or digit up to perhaps an entire book. |'
  prefs: []
  type: TYPE_TB
- en: The compiler must be told what type a variable is, so that it can allocate the
    right amount of memory for it. It is good practice to use the best and most appropriate
    type for each and every variable you use. In practice, however, you will often
    get away with promoting a variable. Perhaps you need a floating-point number with
    just five significant digits? The compiler won't complain if you store it as a
    `double`. However, if you try to store a `float` or a `double` in an `int`, it
    will change/cast the value to fit the `int`. As we progress through the book,
    I clarify what is the best variable type to use in each case, and we will even
    see a few instances where we deliberately convert/cast between variable types.
  prefs: []
  type: TYPE_NORMAL
- en: A few extra details worth noticing, in the table above, include the `f` postfix
    next to all the `float` values. This `f` tells the compiler that the value is
    a `float` type not a `double`. A floating-point value without the `f` prefix is
    assumed to be a `double`. See the next tip about variables for more about this.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, there are many more types. If you want to find out
    more about types see the next tip about variables.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we need to make sure that a value can never be changed. To achieve
    this we can declare and initialize a **constant** using the `const` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It is conventional to declare constants in all upper case. The value of the
    preceding constants can never be altered. We will see some constants in action
    in [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations, and
    Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*.'
  prefs: []
  type: TYPE_NORMAL
- en: User-defined types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'User-defined types are way more advanced than the types we have just seen.
    When we talk about user-defined types in C++ we are usually talking about classes.
    We briefly talked about classes and their related objects in the previous chapter.
    We can write code in a separate file, sometimes in two separate files. From these
    we will then be able to declare, initialize, and use them. We will leave how we
    define/create our own types until [Chapter 6](ch06.html "Chapter 6.  Object-Oriented
    Programming, Classes, and SFML Views"): *Object-Oriented Programming, Classes,
    and SFML Views*.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we know that variables are for storing the data/values that our games
    need in order to work. For example, a variable could represent the number of lives
    a player has or the player's name. We also know that there is a wide selection
    of different types of values that these variables can represent, such as `int`,
    `float`, `bool`, and so on. Of course what we haven't seen yet is how we would
    actually go about using a variable.
  prefs: []
  type: TYPE_NORMAL
- en: There are two stages for creating and preparing a new variable. The stages are
    called **declaration** and **initialization**.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can declare variables in C++ like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Initializing variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have declared the variables with meaningful names, we can initialize
    those same variables with appropriate values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Declaring and initializing in one step
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it suits us, we can combine the declaration and initialization steps into
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Variables tip**As promised, here is the tip on variables. If you want to
    see a complete list of C++ types then check this web page: [http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm](http://www.tutorialspoint.com/cplusplus/cpp_data_types.htm).
    If you want a deeper discussion on floats, doubles, and the `f` postfix then read
    this: [http://www.cplusplus.com/forum/beginner/24483/](http://www.cplusplus.com/forum/beginner/24483/).
    And if you want to know the ins and out of  ASCII character codes then there is
    some more information here: [http://www.cplusplus.com/doc/ascii/](http://www.cplusplus.com/doc/ascii/).
    Note that these links are for the curious reader and we have already discussed
    enough in order to proceed.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing user-defined types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen examples of how we declare and initialize some SFML defined
    types. Because the way we can create/define these types (classes) is so flexible,
    the way we declare and initialize them is also highly varied. Here are a couple
    of reminders for declaring and initializing user-defined types, from the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an object of type `VideoMode`, called `vm`, and initialize it with two
    `int` values, `1920` and `1080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an object of type `Texture`, called `textureBackground` but don''t do
    any initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is possible (in fact very likely) that even though we are not suggesting
    any specific values with which to initialize `textureBackground`, some variables
    may be set up internally. Whether or not an object needs/has the option of giving
    initialization values at this point is entirely dependent on how the class is
    coded and is almost infinitely flexible. This further suggests that when we get
    to write our own classes there will be some complexity. Fortunately, it also means
    we will have significant power to design our types/classes, so they are just what
    we need to make our games! Add this huge flexibility to SFML-designed classes
    and the potential for our games is almost limitless.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a few more user-created types/classes provided by SFML in this chapter
    too and loads more throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we know exactly what variables are, the main types, and how to
    declare and initialize them, but we still can't do that much with them. We need
    to manipulate our variables, add them, take them away, multiply, divide, and test
    them.
  prefs: []
  type: TYPE_NORMAL
- en: First we will deal with how we can manipulate them and later we will look at
    how and why we test them.
  prefs: []
  type: TYPE_NORMAL
- en: C++ arithmetic and assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to manipulate variables, C++ has a range of **arithmetic operators**
    and **assignment operators**. Fortunately, most arithmetic and assignment operators
    are quite intuitive to use, and those that aren''t are quite easy to explain.
    To get us started, let''s look at a table of arithmetic operators followed by
    a table of assignment operators that we will regularly use throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arithmetic operator** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | The addition operator can be used to add together the values of two
    variables or values. |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | The subtraction operator can be used to take away the value of one
    variable or value from another variable or value. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | The multiplication operator can multiply the value of variables and
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | The division operator can divide the value of variables and values.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | The modulo operator divides a value or variable by another value or
    variable to find the remainder of the operation. |'
  prefs: []
  type: TYPE_TB
- en: 'And now for the assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assignment operators** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | We have already seen this one. It is *the* assignment operator. We
    use it to initialize/set a variable''s value. |'
  prefs: []
  type: TYPE_TB
- en: '| `+=` | Add the value on the right-hand side to the variable on the left.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **`-=`** | Take away the value on the right-hand side from the variable on
    the left. |'
  prefs: []
  type: TYPE_TB
- en: '| `*=` | Multiply by the value on the right-hand side by the variable on the
    left. |'
  prefs: []
  type: TYPE_TB
- en: '| `/=` | Divide the value on the right-hand side by the variable on the left.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `++` | **Increment** operator; add 1 to a variable |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | **Decrement** operator; take away 1 from a variable |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically, all the above operators except for `=, --` and `++` are called
    **compound assignment operators** because they comprise more than one operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a good range of arithmetic and assignment operators we
    can actually see how to manipulate our variables by combining operators, variables,
    and values to form **expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting things done with expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Expressions** are combinations of variables, operators, and values. Using
    expressions we can arrive at a result. Furthermore, as we will soon see, we can
    use an expression in a test. These tests can be used to decide what our code should
    do next. First, let''s look at some simple expressions we might see in our game
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the addition operator, used in conjunction with the assignment
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that it is perfectly acceptable to use the same variable on both sides
    of an operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the subtraction operator in conjunction with the assignment
    operator. This next code subtracts the value on the right side of the subtraction
    operator from the value on the left. It is usually used in conjunction with the
    assignment operator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we might use the division operator. This next code divides the
    number on the left by the number on the right. Again, it is usually used with
    the assignment operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, in the previous example, the variable `recycledValueOfBlock` will
    need to be of the type `float` to accurately store the answer to a calculation
    like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps unsurprisingly, we could use the multiplication operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an aside, have you ever wondered how C++ got its name? C++ is an extension
    of the C language. Its inventor, Bjarne Stroustrup**,** originally called it *C
    with classes* but the name evolved. If you are interested, read the C++ story
    at : [http://www.cplusplus.com/info/history/](http://www.cplusplus.com/info/history/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the increment operator in action. This is a really
    neat way to add `1` to the value of one of our game's variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the same result as this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The decrement operator `--` is, you guessed it, a really neat way to subtract
    `1` from something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It is the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a few more operators in action and then we can get back to building
    the Timber!!! game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to add some more sprites to our game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding clouds, a tree, and a buzzing bee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we will add a tree. This is going to be really easy. The reason it's easy
    is because the tree doesn't move. We will use exactly the same procedure that
    we used in the previous chapter when we drew the background.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following highlighted code. Notice the un-highlighted code, which is
    the code that we have already written. This should help you identify that the
    new code should be typed immediately after we set the position of the background,
    but before the start of the main game loop. We will recap what is actually going
    on in the new code after you have added it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The five lines of code (excluding the comment) that we just added do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an object of the type `Texture` called `textureTree`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we load a graphic into the texture from the `tree.png` graphics file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we declare an object of the type `Sprite` called `spriteTree`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we associate `textureTree` with `spriteTree`. Whenever we draw `spriteTree`
    it will show the `textureTree` texture, which is a neat tree graphic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally we set the position of the tree using the coordinates `810` on the x
    axis and 0 on the y axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on to the bee object, which is handled in an almost identical manner.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the bee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The difference between this next code and the tree code is small but important.
    As the bee needs to move, we also declare two bee-related variables. Add the highlighted
    code in the place shown, and see if you can work out how we might use the variables
    `beeActive` and `beeSpeed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We create a bee in exactly the same way we created a background and a tree.
    We use a `Texture` and a `Sprite`, and associate the two. Note that in the previous
    bee code there was some new code we haven't seen before. There is a `bool` variable
    for determining whether or not the bee is active. Remember that a `bool` variable
    can be either `true` or `false`. We initialize `beeActive` to `false`, for now.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a new `float` variable called `beeSpeed`. This will hold the
    speed, in pixels per second, at which our bee will fly across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Soon we will see how we use these two new variables to move the bee. Before
    we do, let's set up some clouds in an almost identical manner.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the clouds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the highlighted code shown next. Study the new code and try and work out
    what it will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The only thing about the code we have just added that might seem a little odd
    is that we have only one object of the type `Texture`. It's completely normal
    for multiple `Sprite` objects to share a texture. Once a `Texture` is stored in
    the GPU memory it can be associated with a `Sprite` object very quickly. It is
    only the initial loading of the graphic in the `loadFromFile` code that is a relatively
    slow operation. Of course, if we wanted three different-shaped clouds then we
    would need three textures.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the minor texture issue, the code we have just added is nothing new
    compared to the bee. The only difference is that there are three cloud sprites,
    three `bool` variables to determine if each cloud is active and three `float`
    variables to hold the speed for each cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the tree, the bee, and the clouds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally we can draw them all onto the screen by adding this highlighted code
    in the drawing section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Drawing the three clouds, the bee, and the tree is done in exactly the same
    way that the background was drawn. Notice, however, the order in which we draw
    the different objects to the screen. We must draw all the graphics after the background
    or they will be covered, and we must draw the clouds before the tree or they will
    look a bit odd drifting in front of the tree. The bee would look OK either in
    front or behind the tree. I opted to draw the bee in front of the tree so that
    it can try and distract our lumberjack, a bit like a real bee might.
  prefs: []
  type: TYPE_NORMAL
- en: Run Timber!!! and gaze in awe at the tree, three clouds, and a bee, which don't
    do anything! They look like they are lining up for a race, where the bee goes
    backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the tree, the bee, and the clouds](img/image_02_001-300x169.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using what we know about operators, we could try and move the graphics around
    that we have just added, but there are a couple of problems. Firstly, real clouds
    and bees move in a non-uniform manner. They don't have a set speed or location.
    Although their location and speed are determined by factors such as wind speed
    or how much of a hurry the bee might be in, to the casual observer the path they
    take, and their speed, appear random.
  prefs: []
  type: TYPE_NORMAL
- en: Random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Random numbers** are useful for lots of reasons in games. Perhaps you could
    use them for determining what card the player is dealt, or how much damage within
    a certain range is subtracted from an enemy''s health. As hinted at, we will use
    random numbers to determine the starting location and the speed of the bee and
    the clouds.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate random numbers we will need to use some more C++ functions, two
    more to be precise. Don't add any code to the game yet. Let's just take a look
    at the syntax and the steps required with some hypothetical code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers can''t actually pick random numbers. They can only use algorithms/calculations
    to pick a number that *appears* to be random. So that this algorithm doesn''t
    constantly return the same value, we must **seed** the random number generator.
    The seed can be any integer number, although it must be a different seed each
    time you require a unique random number. Take a look at this code, which seeds
    the random number generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The code above gets the time from the PC using the `time` function like this
    `time(0)`. The call to the `time` function is enclosed as the value to be sent
    to the `srand` function. The result of this is that the current time is used as
    the seed.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code is made to look a little more complicated because of the slightly
    unusual-looking `(int)` syntax. What this does is convert/cast the value returned
    from `time` to an `int`. This is required by the `srand` function in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A conversion from one type to another is called a **cast**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in summary, this is what happens in the previous line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the time using `time`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It converts it to type `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sends this resulting value to `srand`, which seeds the random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time is, of course, always changing. This makes the `time` function a great
    way to seed the random number generator. However, think about what might happen
    if we seed the random number generator more than once and in such quick succession
    that `time` returns the same value? We will see and solve this problem when we
    animate our clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage we can create a random number between a range, and save it to
    a variable for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice the odd-looking way we assign a value to `number`. By using the Modulo
    operator `%` and the value of `100`, we are asking for the remainder, after dividing
    the number returned from `rand` by `100`. When you divide by `100`, the highest
    number you can possibly have as a remainder is 99\. The lowest number possible
    is 0\. Therefore the previous code will generate a number between 0 and 99 inclusive.
    This knowledge will be really useful for generating a random speed and starting
    location for our bees and clouds.
  prefs: []
  type: TYPE_NORMAL
- en: We will do this soon, but we first need to learn how to make decisions in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Making decisions with if and else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ `if` and `else` keywords are what enable us to make decisions. Actually,
    we have already seen `if` in action in the previous chapter when we detected,
    in each frame, whether the player had pressed the ***Esc***  key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So far we have seen how we can use arithmetic and assignment operators to create
    expressions. Now we can see some new operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Logical operators** are going to help us make decisions by building expressions
    that can be tested for a value of either true or false. At first this might seem
    like quite a narrow choice and insufficient for the kind of choices that might
    be needed in an advanced PC game. Once we dig a little deeper, we will see that
    we can actually make all the required decisions we will need, with just a few
    logical operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a table of the most useful logical operators. Take a look at them and
    their associated examples, and then we will see how to put them to use.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Logical operator** | **Name and example** |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | The **comparison operator** tests for equality and is either true
    or false. An expression such as `(10 == 9)`, for example, is false. 10 is obviously
    not equal to 9. |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | This is the logical **NOT** operator. The expression `(! (2 + 2 ==
    5))`. This is true because `2 + 2` is NOT `5` |'
  prefs: []
  type: TYPE_TB
- en: '| `!=` | This is another comparison operator but is different to the `=` comparison
    operator. This tests if something is **NOT equal**. For example, the expression
    `(10 != 9)` is true. `10` is not equal to `9`. |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Another comparison operator - actually there are a few more as well.
    This tests if something is greater than something else. The expression `(10 >
    9)` is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | You guessed it. This tests for values less than. The expression `(10
    < 9)` is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | This operator tests for whether one value is greater than or equal
    to the other, and if either is true, the result is true. For example, the expression
    `(10 >= 9)` is true. The expression `(10 >= 10)` is also true. |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Like the previous operator, this one tests for two conditions, but
    this time less than or equal to. The expression `(10 <= 9)` is false. The expression
    `(10 <= 10)` is true. |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | This operator is known as logical **AND**. It tests two or more separate
    parts of an expression and both parts must be true in order for the result to
    be true. Logical AND is usually used in conjunction with the other operators to
    build more complex tests. The expression `((10 > 9) && (10 < 11))` is true because
    both parts are true, so the expression is true. The expression `((10 > 9) && (10
    < 9))` is false because only one part of the expression is true and the other
    is false. |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | This operator is called logical **OR,** and it is just like
    logical AND except that at least one, of two or more parts of an expression, needs
    to be true for the expression to be true. Let''s look at the last example we used
    above but replace the `&&` with `&#124;&#124;`. The expression `((10 > 9) &#124;&#124;
    (10 < 9))` is now true because one part of the expression is true. |'
  prefs: []
  type: TYPE_TB
- en: Let's meet the C++ `if` and `else` keywords which will enable us to put all
    these logical operators to good use.
  prefs: []
  type: TYPE_NORMAL
- en: C++ if and else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the previous examples less abstract. Meet the C++ `if` keyword. We
    will use `if` and a few operators along with a small story to demonstrate their
    use. Next follows a made-up military situation that will hopefully be less abstract
    than the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: If they come over the bridge, shoot them!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a C++ program to convey his last orders for after
    he has died. The troops must hold one side of a bridge while awaiting reinforcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command the captain wants to make sure his troops understand is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"If they come over the bridge, shoot them!"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, how do we simulate this situation in C++? We need a `bool` variable: `isComingOverBridge`.
    The next bit of code assumes that the `isComingOverBridge` variable has been declared
    and initialized to either `true` or `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use `if` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the `isComingOverBridge` variable is equal to `true`, the code inside the
    opening and closing curly braces `{...}` will run. If not, the program continues
    after the `if` block and without running the code within it.
  prefs: []
  type: TYPE_NORMAL
- en: Or do this instead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The captain also wants to tell his troops to stay put, if the enemy is not coming
    over the bridge.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can introduce another C++ keyword, `else`. When we want to explicitly
    do something when the `if` does not evaluate to `true`, we can use `else`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we could write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The captain then realized that the problem wasn''t as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad would
    be overrun and slaughtered. So, he came up with this code (we''ll use some variables
    as well this time.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code has three possible paths of execution. The first one is if the
    enemy is coming over the bridge, and the friendly troops are greater in number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then the third and final possible outcome, which will execute if neither of
    the others is `true`, is captured by the final `else`, without an `if` condition.
  prefs: []
  type: TYPE_NORMAL
- en: Reader challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly,
    and would therefore be handled by the final `else`. The final `else` is meant
    for when there are no enemy troops. I guess any self-respecting captain would
    expect his troops to fight in this situation. He could change the first `if` statement
    to accommodate this possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the captain''s last concern was that, if the enemy came over the
    bridge waving the white flag of surrender and were promptly slaughtered, then
    his men would end up as war criminals. The C++ code needed was obvious. Using
    the `wavingWhiteFlag` Boolean variable he wrote this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But the issue of where to put this code was less clear. In the end, the captain
    opted for the following nested solution and for changing the test for `wavingWhiteFlag`
    to logical NOT, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    to create quite deep and detailed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We could go on making more and more complicated decisions with `if` and `else`
    but what we have seen is more than sufficient as an introduction. It is probably
    worth pointing out that, very often there is more than one way to arrive at a
    solution to a problem. The right way will usually be the way that solves the problem
    in the clearest and simplest manner.
  prefs: []
  type: TYPE_NORMAL
- en: We are getting closer to having all the C++ knowledge we need to be able to
    animate our clouds and bee. We have one final animation issue to discuss and then
    we can get back to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can move the bee and the clouds, we need to consider timing. As we
    already know, the main game loop executes over and over again, until the player
    presses the ***Esc***  key.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learnt that C++ and SFML are exceptionally fast. In fact, my ageing
    laptop executes a simple game loop (such as the current one) at around five thousand
    times per second.
  prefs: []
  type: TYPE_NORMAL
- en: The frame-rate problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider the speed of the bee. For the purpose of discussion we could
    pretend that we are going to move it at 200 pixels per second. On a screen that
    is 1920 pixels wide, it would take, very approximately, 10 seconds to cross the
    entire width, because 10 x 200 is 2000 (near enough to 1920).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we know that we can position any of our sprites with `setPosition(...,...)`.
    We just need to put the x and the y coordinates in the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting the position of a sprite, we can also **get** the position
    of a sprite. To get the horizontal x coordinate of the bee, for example, we would
    use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The current x coordinate of the bee is now stored in `currentPosition`. To
    move the bee to the right, we could then add the appropriate fraction of 200 (our
    intended speed) divided by 5000 (the approximate frames per second on my laptop)
    to `currentPosition` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we could use `setPosition` to move our bee. It would smoothly move from
    left to right by 200 divided by 5000 pixels each frame. But there are two big
    problems with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Frame rate** is the number of times per second that our game loop is processed.
    That is, the number of times that we handle the player''s input, update the game
    objects, and draw them onto the screen. We will expand on and discuss frame rate
    implications now and throughout the rest of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: The frame rate on my laptop might not always be constant. The bee might look
    like it is intermittently **boosting** its way across the screen.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, we want a wider audience for our game than just my laptop! Every
    PC's frame rate will vary, at least slightly. If you have a really old PC, the
    bee will appear to be weighed down with lead and if you have the latest gaming
    rig it will probably be something of a blurry turbo bee.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this problem is the same for every game and SFML has provided a
    solution. The easiest way to understand the solution is to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: The SFML frame-rate solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now measure and use the frame rate to control our game. To get started
    with implementing this, add this code just before the main game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code we declare an object of the type `Clock` and we name it
    `clock`. The class name starts with a capital letter and the object name (that
    we will actually use) starts with a lower-case letter. The object name is arbitrary
    but `clock` seems like an appropriate name for, well, a clock. We will add some
    more time-related variables here soon as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the update section of our game code add this highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `clock.restart()` function, as you might expect, restarts the clock. We
    want to restart the clock each and every frame so that we can time how long each
    and every frame takes. In addition, however, it returns the amount of time that
    has elapsed since the last time we restarted the clock.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, in the previous code, we are declaring an object of the
    type `Time,` called `dt,` and using it to store the value returned by the `clock.restart()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a `Time` object, called `dt`, which holds the amount of time that
    elapsed since the last time we updated the scene and restarted the clock. Maybe
    you can see where this is going.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some more code to the game and then we will see what we can do with
    `dt`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`dt` stands for **delta time**, the time between two updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the clouds and the bee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use the elapsed time since the last frame, to breathe life into the bee
    and the clouds. This will solve the problem of having a consistent frame rate
    across different PCs.
  prefs: []
  type: TYPE_NORMAL
- en: Giving life to the bee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we want to do is to set up the bee at a certain height and
    a certain speed. We only want to do this when the bee is inactive. So we wrap
    the next code in an `if` block. Examine and add the highlighted code, then we
    will discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the bee is not active, just like it won''t be when the game first starts,
    `if(!beeActive)` will be `true` and the code above will do the following things,
    in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: Seed the random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a random number between 199 and 399 and assign the result to `beeSpeed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seed the random number generator again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a random number between 499 and 999 and assign the result to a new `float`
    variable called `height`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the position of the bee to `2000` on the x axis (just off-screen to the
    right) and to whatever `height` equals on the y axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `beeActive` to true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the `height` variable is the first variable we have ever declared
    inside the game loop. Furthermore, because it was declared inside an `if` block,
    it is actually "invisible" outside the `if` block. This is fine for our use because
    once we have set the height of the bee we don''t need it any more. This phenomenon,
    which affects variables, is called **scope**. We will explore this more fully
    in [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations, and
    Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions - Implementing Game Mechanics*.'
  prefs: []
  type: TYPE_NORMAL
- en: If we run the game, nothing will actually happen to the bee yet, but now the
    bee is active we can write some code that runs when `beeActive` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code, which, as you can see, executes whenever
    `beeActive` is `true`. This is because it follows with an `else` after the `if(!beeActive)`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the `else` block the following things happen.
  prefs: []
  type: TYPE_NORMAL
- en: The bee position is changed using the following criteria. The `setPosition`
    function uses the `getPosition` function to get the current x coordinate of the
    bee. It then adds `beeSpeed * dt.asSeconds()` to that coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: The `beeSpeed` variable value is many pixels per second and was randomly assigned
    in the previous `if` block. The value of `dt.asSeconds()` will be a fraction of
    1 that represents how long the previous frame of the animation took.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the bee''s current x coordinate is 1000\. Now suppose a fairly
    basic PC loops at 5000 frames per second. This would mean that `dt.asSeconds`
    would be 0.0002\. And further suppose that `beeSpeed` was set to the maximum 399
    pixels per second. Then the code that determines the value that `setPosition`
    uses for the x coordinate can be explained like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: So the new position on the x axis for the bee would be 999.9202\. We can see
    that the bee is, very smoothly drifting to the left, at well under a pixel per
    frame. If the frame rate fluctuates then the formula will produce a new value
    to suit. If we run the same code on a PC that only achieves 100 frames per second
    or a PC that achieves a million frames per second, the bee will move at the same
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: The `setPosition` function uses `getPosition().y` to keep the bee in exactly
    the same y coordinate throughout this cycle of being active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code in the `else` block we just added is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code tests each and every frame (when `beeActive` is `true`), whether the
    bee has disappeared off the left-hand side of the screen. If the `getPosition`
    function returns less than -100, it will certainly be out of view of the player.
    When this has occurred, `beeActive` is set to `false` and, on the next frame,
    a new bee will be set flying at a new random height and a new random speed.
  prefs: []
  type: TYPE_NORMAL
- en: Try running the game and watch our bee dutifully fly from right to left and
    then come back to the right again at a new height and speed. It's almost like
    a new bee every time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course a real bee would stick around for ages and pester you while you're
    trying to concentrate on chopping the tree. We will make some smarter game characters
    in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will get the clouds moving in a very similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Blowing the clouds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we want to do is set up the first cloud at a certain height
    and a certain speed. We only want to do this when the cloud is inactive. So we
    wrap the next code in an `if` block. Examine and add the highlighted code, just
    after the code we added for the bee, then we will discuss it. It is almost identical
    to the code we used for the bee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the code we have just added and the bee code is
    that we work on a different sprite and use different ranges for our random numbers.
    Also, we use `*10` to the result returned by time(0) so we are always guaranteed
    to get a different seed for each of the clouds. When we code the other cloud movement
    next you will see that we use `*20` and`*30` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can take action when the cloud is active. We will do so in the `else`
    block. As with the `if` block, the code is identical to that of the bee, except
    that all the code works on the cloud and not the bee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know what to do, we can duplicate the same code for the second and third
    clouds. Add this highlighted code that handles the second and third clouds, immediately
    after the code for the first cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now you can run the game and the clouds will randomly and continuously drift
    across the screen, and the bee will buzz from right to left before re-spawning
    once more back on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Blowing the clouds](img/image_02_002-300x169.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Does all this cloud and bee handling seem a little bit repetitious? We will
    see how we could save lots of typing and make our code more readable. In C++ there
    are ways of handling multiple instances of the same type of variable or object.
    These are called **arrays** and we will learn about them in [Chapter 4](ch04.html
    "Chapter 4.  Loops, Arrays, Switch, Enumerations, and Functions – Implementing
    Game Mechanics"): *Loops, Arrays, Switch, Enumerations, and Functions - Implementing
    Game Mechanics*. At the end of the project, once we have learnt about arrays,
    we will discuss how we could improve our cloud code.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at a few frequently asked questions related to the topics in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: FAQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) Why do we set the bee to inactive when it gets to -100? Why not just zero
    because zero is the left-hand side of the window?
  prefs: []
  type: TYPE_NORMAL
- en: A) The bee graphic is 60 pixels wide and its origin is at the top left pixel.
    So when the bee is drawn with its origin at x equals zero, the entire bee graphic
    is still on screen for the player to see. By waiting until it is at -100, we can
    be sure it is definitely out of the player's view.
  prefs: []
  type: TYPE_NORMAL
- en: Q) How do I know how fast my game loop is?
  prefs: []
  type: TYPE_NORMAL
- en: 'A) To measure this we will need to learn a few more things. We will add the
    ability to measure and display the current frame rate in [Chapter 5](ch05.html
    "Chapter 5. Collisions, Sound, and End Conditions – Making the Game Playable"):
    *Collisions, Sound, and End Conditions - Making the Game Playable*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learnt that a variable is a named storage location in memory,
    in which we can keep values of a specific type. Types include `int`, `float`,
    `double`, `bool`, `String`, and `char`.
  prefs: []
  type: TYPE_NORMAL
- en: We can declare and initialize all the variables we need, to store the data for
    our game. Once we have our variables, we can manipulate them using the arithmetic
    and assignment operators and use them in tests with the logical operators. Used
    in conjunction with the `if` and `else` keywords, we can branch our code dependent
    upon the current situation in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Using all this new knowledge, we animated some clouds and a bee. In the next
    chapter we will continue to use these skills to add a **Heads Up Display**(**HUD**)
    and add more input options for the player, as well as representing time visually
    via a time bar.
  prefs: []
  type: TYPE_NORMAL
