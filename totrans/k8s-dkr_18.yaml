- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. A container that is based on one architecture cannot
    be run on a different architecture. For example, an image created using the x86
    architecture will not run on an ARM-based architecture.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Union filesystem. Docker uses the Union filesystem to manage
    multiple image layers. The layers are read from top to bottom to provide the appearance
    of a single filesystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Overlay2\. A system running a kernel that''s version 4.0
    or above will use the Overlay2 storage driver.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Container layer. Any changes that are made to a running
    container''s filesystem are stored in the topmost layer, called the container
    layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) **docker exec -it <container> /bin/bash**. The **docker
    exec** command is used to execute a process in a container. Using the **-it**
    option tells the exec command to use an interactive terminal for its execution.
    The process you want to execute is the last parameter, and since we want to gain
    access to the container''s Bash shell, we are executing **/bin/bash**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. When you stop a running container, the daemon will
    only stop the running image. The container layer will remain on the host''s filesystem.
    If you want to delete the container, you must remove the container from the daemon
    using the **docker rm** command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) **docker ps -a**. To view a list of all containers that
    are running and have been stopped, use the **docker ps -a** command. If you use
    **-all** or **-list**, the daemon will interpret the option as **-l**, which will
    only list the latest containers. Listing the latest containers will exclude containers
    that have been stopped for a longer period of time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answers: (B) Bind mounts and (C) Volumes. Only a Docker volume and
    bind mount provide persistency to a container. tmpfs volumes are stored in RAM
    and are not written to disk.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) True. A volume must be created before it can be used in
    a container. If a volume is not created before running a container, Docker will
    create the volume before mounting it to the container.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) 32 GB. If a tmpfs size is not specified, Docker will create
    a volume that is equal to half of the host''s RAM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Stopping or removing an image will not remove a
    persistent volume by default. To delete a volume, you can add the **-v** option
    to the **docker rm** command, or you can use the **docker volume rm** command
    to remove the volume manually.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) Named volumes. Only anonymous and named volumes are managed
    by the Docker daemon.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) You must manually delete the Bind folder. Since Bind mounts
    are not managed by Docker, the daemon cannot delete unused volumes. To remove
    a Bind mount, you need to manually delete the directory that the Bind mount used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. The default bridge assigned by Docker has limitations.
    It is considered a best practice to create a custom bridge network if you plan
    to run multiple containers on your host.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) **192.168.100.10:80**. A socket is a combination of an
    IP address and a port. **192.168.100.10:80** is a socket for a server running
    a service on port **80** with an IP address of **192.168.100.10**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) **docker run -p 8081:8080 -d nginx-web bitnami/nginx**.
    Since the host has already bound port **8080** to another service, we cannot start
    the new container using **8080:8080**. Since each Docker container has its own
    IP address, we can still use port **8080** for the container, but the incoming
    host port assignment must use an unused port. The only correct answer is C, since
    it binds the host''s port, **8081**, to the container port running on port **8080**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) **docker run --network=none -it badimage bash**. If you
    start a container without supplying any network options, the container will attempt
    to run on the default Docker bridge network. To start a container without a network
    you can set the network to none by running the image with the **–network=none**
    option.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Being able to change the connected network on the
    fly is a feature of custom bridge networks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) **65535**. The valid port range for IP ports is **1-65535**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (C) PersistentVolume. PersistentVolumes are claimed using PersistentVolumeClaims
    – PersistentVolume must exist before you can create a PersistentVolumeClaim.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Rancher. KinD includes the local-path-provisioner, which
    was created by Rancher.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) Load balancer. When a cluster has multiple worker nodes,
    you need to install a load balancer in front of the cluster to direct traffic
    to the backend worker nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. As shown in *Figure 5.9*, a Kubernetes cluster can
    have multiple CSIDrivers. This allows a cluster to connect to multiple backend
    storage systems.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Ingress controller. An Ingress controller is an add-on
    component used to expose services – it is not part of the control plane.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Correct answer: (D) ETCD. ETCD is the database that Kubernetes uses to store
    all objects and their state.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Correct answer: (C)** **kube-scheduler**. **kube-scheduler** **uses various
    criteria from** **kubelet** **on each worker node to schedule a workload.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Correct answer: (B)** **-v****. The** **-v** **option enables verbose output
    from a** **kubectl** **command.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Correct answer: (D)** **NodePort****. When you create a** **NodePort** **service,
    it will be assigned a port between** **30000-32767**. Each node will be updated
    with the service and the port to access it. Since each node knows the service,
    any node can service the incoming request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Correct answer: (A)** **StatefulSet****. A** **StatefulSet** **will create
    each pod with a known name, based on the name assigned in the manifest. Each pod
    will receive the name with a number appended to it. To provide creation controls,
    as a pod is created, it must completely deploy before the next pod is created.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (D) By the selector label. When you create a service object,
    you include a selector that includes the label to match for the service endpoints.
    Any matching pods will be added as an endpoint.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) **kubectl get ep <service name>**. Services use endpoints
    to select the pods that receive requests to the service. One of the first steps
    when it comes to troubleshooting a service is to verify that endpoints have been
    assigned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Some distributions do include support for **LoadBalancer**
    services out of the box, but most still do not include support without the need
    to add a component such as MetalLB.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Layer 4\. The two load balancers used in Kubernetes are
    Layer 7 and Layer 4\. Layer 7 load balancers run in Layer 7 of the OSI model and
    can only accept application-level traffic such as HTTP and HTTPS. Since Layer
    4 load balancers run at a lower layer of the OSI model, they have access to lower
    level packets such as direct TCP and UDP.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) **NodePort** and **ClusterIP**. A base Kubernetes cluster
    does not allow the **LoadBalancer** type to use multiple protocols. Only **ClusterIP**
    and **NodePort** can create a single service that has both UDP and TCP protocols
    defined.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) True. OpenID Connect is a standard published by IETF: [https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) **id_token**. **id_token** contains claims about the user''s
    identity. **refresh_token** is used to get a new **id_token**. **access_token**
    is used to interact with the identity provider. **certificate_token** doesn''t
    exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Break-glass-in-case-of-emergency when all other authentication
    solutions are unavailable. Remember to keep this certificate and key pair under
    strict controls.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) An immutable ID not based on a user''s name. This way,
    if a user''s name ever changes, which happens more often than may be expected,
    their access isn''t changed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Set as flags on the Kubernetes API server executable. How
    you set the flags will depend on your distribution, but ultimately, every distribution
    sets these flags on the API server''s command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Impersonated users are not granted the default group;
    that is, **system:authenticated**. The reverse proxy needs to add this group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. The Dashboard should never have its own privileges.
    Otherwise, anyone who can connect to it can use it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) False. RBAC is the preferred method for authorizing resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) apiGroups, resources, verbs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) Kubernetes API reference. This is an invaluable tool that
    will list every URL for an API. This can be used to determine the resource.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) Define a ClusterRole and reference it in each namespace
    as a RoleBinding. This way, changes to the ClusterRole are reflected whenever
    it is referenced.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Whenever possible, RoleBindings and ClusterRoleBindings
    should reference groups. Referencing users directly is an anti-pattern that is
    difficult to maintain, audit, and debug.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. RBAC requires all rights to be enumerated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Custom authorization webhooks are also available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) False. The Dashboard and make consistent throughout chapter
    is not inherently insecure; how it''s deployed matters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) No authentication, a token, injected from a reverse proxy.
    The dashboard has no way of collecting a username, password, or second factor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) If a token is uploaded, it''s encrypted and stored in the
    browser as a cookie. The dashboard doesn''t persist the session in any backend.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) None of the above. The dashboard doesn''t know how to refresh
    a token.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Behind a reverse proxy. Use a reverse proxy to manage the
    login process, control sessions, and add multi-factor authentication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. The 2.0+ versions of the dashboard support impersonation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Any reverse proxy can, if configured properly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) False. A container is a process, not a VM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) If marked as privileged, yes. A privileged container can
    access a host''s resources just like a privileged process can.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Both. Attackers will string together multiple vulnerabilities
    to gain access to their target.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) By comparing the Pod''s requested capabilities and the
    policies authorized via the union of the Pod''s creator and its own **ServiceAccount**.
    Policies can''t be explicitly set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) An admission controller that inspects all Pods on creation
    and when they''re updated. Policy enforcement is not handled by the **PodSecurityPolicy**
    API, only the definition of policies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. It will take multiple years between determining
    a replacement, implementing it, and then the deprecation process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. You wouldn''t run a process as root on your server,
    so don''t do it in a container.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. GateKeeper is a tool originally built by Microsoft
    on top of OPA, but they are not the same thing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) Rego is saved as a **ConstraintTemplate**, which is a **CustomResourceDefenition**
    defined by the **GateKeeper** project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) Using an automated framework built directly into OPA. OPA''s
    automated testing framework provides a powerful way to pre-validate Rego before
    deploying to GateKeeper.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) You don''t need to as Rego will identify iterative steps.
    When using loops in Rego, use either the underscore to resolve all values or a
    placeholder (such as I or j) for array indexes. Rego will fill the counter by
    iterating over the array.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Add trace functions to your code and run the **opa test**
    command with **-v** to see execution traces. **opa** will tell you where the problem
    is. Use its built-in tools.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Constraint templates can include parameters that
    are defined using the same schema as any other CRD.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. Not at the time of writing, at least. GateKeeper
    can''t mutate yet, so additional webhooks would need to be built to fill the gap.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (D) **falco_rules.local.yaml**. Any changes to rules that have
    been customized to your installation should go in your **falco_rules.changes.yaml**
    file. You should not edit the include set of rules, which are part of **falco_rules.yaml**.
    The **falco.yaml** file is the base Falco configuration file and does not contain
    any rules.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) FluentD. There are many forwarders that are compatible
    with Kubernetes, but one of the most commonly used forwarders is FluentD.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Kibana. The EFK stack includes ElasticSearch, FluentD,
    and Kibana. Kibana is the component that provides visualizations and dashboards
    for your logs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) Falcosidekick. The Falcosidekick utility only forwards
    Falco logs to a central logging server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) Lists. You can group a collection of items in Falco using
    Lists.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) True. Velero backups can only use an S3 target to store
    backups.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Install MinIO and use the NFS volumes as persistent disks
    in the deployment phase. You can install MinIO and use any persistent volumes
    with the deployment. MinIO will present the allocated storage as a S3 bucket,
    which are compatible with MinIO.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. One of Velero''s features is the ability to use
    a backup from one cluster to restore namespaces and objects in a different cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) etcdctl. etcdctl has an option to create a snapshot of
    the ETCD database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) **Velero create schedule daily-backup --schedule="0 3 *
    * *"**. This command will create a scheduled backup job that runs at 3 a.m. every
    day. The schedule command accepts a tag called **–schedule** that uses cron expressions.
    **0 3 * * *** is a cron expression for 3 A.M. every day.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Correct answer: (A) False. It''s not a requirement, but it certainly makes
    life easier!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (D) None of the above. There is no minimum number of steps.
    How you implement your pipelines will depend on your own requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (C) Using Git as an authoritative source for operations configuration.
    Instead of interacting directly with the Kubernetes API, you store your objects
    in a Git repository, letting a controller keep them in sync.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) There are no standards; every project and vendor has their
    own implementation. For this chapter, we used Tekton, which is a combination of
    YAML, containers, and shell scripts. Amazon, Azure, and GitHub all store their
    pipeline scripts in the application source. There is no requirement for what you
    write it in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) Update the **Deployment** or **StatefulSet** manifest in
    Git, letting the GitOps controller update the objects in Kubernetes. The goal
    is to minimize the use of kubectl and maintain a log of changes in Git.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (B) False. This is nearly impossible. The operators model,
    where custom controllers create objects based on custom resources, would almost
    never work with this assumption. At least not yet. Once you''ve deployed the examples,
    you''ll see Tekton creates objects that aren''t in Git. Secrets are other objects
    that probably shouldn''t be in Git either.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Correct answer: (A) True. Kubernetes is a platform for building platforms.
    While there are certainly common patterns and best practices, when all is said
    and done, the power of Kubernetes is that it gives you the flexibility to automate
    your systems in a way that best suits you.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
