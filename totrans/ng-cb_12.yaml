- en: '*Chapter 12*: Performance Optimization in Angular'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：Angular性能优化'
- en: 'Performance is always a concern in any product that you build for end users.
    It is a critical element in increasing the chances of someone using your app for
    the first time becoming a customer. Now, we can''t really improve an app''s performance
    until we identify potential possibilities for improvement and the methods to achieve
    this. In this chapter, you''ll learn some methods to deploy when it comes to improving
    Angular applications. You''ll learn how to analyze, optimize, and improve your
    Angular app''s performance using several techniques. Here are the recipes we''re
    going to cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能始终是您为最终用户构建的任何产品中关注的问题。这是增加某人第一次使用您的应用程序成为客户的机会的关键因素。现在，除非我们确定了改进的潜在可能性和实现这一点的方法，否则我们无法真正提高应用程序的性能。在本章中，您将学习一些在改进Angular应用程序时要部署的方法。您将学习如何使用多种技术来分析、优化和改进您的Angular应用程序的性能。以下是本章中要涵盖的内容：
- en: Using `OnPush` change detection to prune component subtrees
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OnPush`变更检测来修剪组件子树
- en: Detaching the change detector from components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组件中分离变更检测器
- en: Running `async` events outside Angular with `runOutsideAngular`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`runOutsideAngular`在Angular外部运行`async`事件
- en: Using `trackBy` for lists with `*ngFor`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`*ngFor`中使用`trackBy`来处理列表
- en: Moving heavy computation to pure pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重型计算移至纯管道
- en: Using web workers for heavy computation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web Workers进行重型计算
- en: Using performance budgets for auditing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能预算进行审计
- en: Analyzing bundles with `webpack-bundle-analyzer`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`webpack-bundle-analyzer`分析捆绑包
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at the following link: [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter12](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter12).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的食谱，请确保您的计算机上已安装了**Git**和**Node.js**。您还需要安装`@angular/cli`包，可以在终端中使用`npm
    install -g @angular/cli`来安装。本章的代码可以在以下链接找到：[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter12](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter12)。
- en: Using OnPush change detection to prune component subtrees
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OnPush变更检测来修剪组件子树
- en: In today's world of modern web applications, performance is one of the key factors
    for a great **user experience** (**UX**) and, ultimately, conversions for a business.
    In this recipe, being the first recipe of this chapter, we're going to discuss
    the fundamental or the most basic optimization you can do with your components
    wherever it seems appropriate, and that is by using the `OnPush` change-detection
    strategy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今现代Web应用程序的世界中，性能是出色的**用户体验**（**UX**）和最终业务转化的关键因素之一。在本章的第一个食谱中，我们将讨论您可以在组件中进行的基本优化，即使用`OnPush`变更检测策略。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project we are going to work with resides in `Chapter12/start_here/using-onpush-change-detection`,
    inside the cloned repositor:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`Chapter12/start_here/using-onpush-change-detection`中，位于克隆存储库内：
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio Code** (**VS Code**)中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ng serve -o`命令启动Angular应用程序并在浏览器上提供服务。您应该看到以下应用程序：
- en: '![Figure 12.1 – App using OnPush change detection running at http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 使用OnPush变更检测运行的应用程序，位于http://localhost:4200'
- en: '](image/Figure_12.1_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.1_B15150.jpg)'
- en: Figure 12.1 – App using OnPush change detection running at http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 应用程序使用OnPush变更检测在http://localhost:4200上运行
- en: Now that we have the project served on the browser, let's see the steps of the
    recipe in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在浏览器上提供了项目，让我们在下一节中看到食谱的步骤。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The app we''re working with has some performance issues, particularly with
    the `UserCardComponent` class. This is because it is using the `idUsingFactorial()`
    method to generate a unique ID to show on the card. We''re going to experience
    and understand the performance issue this causes. We will try to fix the issue
    using the `OnPush` change-detection strategy. Let''s get started:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的应用程序存在一些性能问题，特别是`UserCardComponent`类。这是因为它使用`idUsingFactorial()`方法来生成要显示在卡片上的唯一ID。我们将尝试体验和理解这会导致的性能问题。我们将尝试使用`OnPush`变更检测策略来解决这个问题。让我们开始吧：
- en: First, try to search for a user named `Elfie Siegert` by entering their name
    in the search box. You'll notice that the app immediately hangs and that it takes
    a few seconds to show the user. You'll also notice that you don't even see the
    typed letters in the search box as you type them.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，尝试在搜索框中输入名为`Elfie Siegert`的用户。您会注意到应用程序立即挂起，并且需要几秒钟才能显示用户。您还会注意到在输入时，甚至看不到在搜索框中输入的字母。
- en: Let's add some logic to the code. We'll check how many times Angular calls the
    `idUsingFactorial()` method when the page loads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向代码添加一些逻辑。我们将检查页面加载时Angular调用`idUsingFactorial()`方法的次数。
- en: 'Modify the `app/core/components/user-card/user-card.component.ts` file, updating
    it as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`app/core/components/user-card/user-card.component.ts`文件，更新如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, refresh the app and open the Chrome DevTools and, in the **Console** tab,
    type `appLogs` and press *Enter*. You should see an object, as follows:![Figure
    12.2 – Logs reflecting number of calls to idUsingFactorial() method
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，刷新应用程序并打开Chrome DevTools，在**控制台**选项卡中，输入`appLogs`并按*Enter*。您应该会看到一个对象，如下所示：![图12.2
    – 反映对idUsingFactorial()方法调用次数的日志
- en: '](image/Figure_12.2_B15150.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.2_B15150.jpg)'
- en: Figure 12.2 – Logs reflecting number of calls to idUsingFactorial() method
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 反映对idUsingFactorial()方法调用次数的日志
- en: Now, type the name `Elfie Siegert` again in the search box. Then, type `appLogs`
    again in the **Console** tab and press *Enter* to see the object again. You'll
    see that it has some increased numbers. If you didn't make a typo while entering
    the name, you should see something like this:![Figure 12.3 – Logs after typing
    the name Elfie Siegert
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在搜索框中再次输入名称`Elfie Siegert`。然后，在**控制台**选项卡中再次输入`appLogs`并按*Enter*以再次查看对象。您会看到它有一些增加的数字。如果在输入名称时没有打错字，您应该会看到类似于这样的内容：![图12.3
    – 输入名称Elfie Siegert后的日志
- en: '](image/Figure_12.3_B15150.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.3_B15150.jpg)'
- en: Figure 12.3 – Logs after typing the name Elfie Siegert
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 输入名称Elfie Siegert后的日志
- en: Notice the count when calling the `idUsingFactorial()` method for `justin.grewal@example.com`.
    It has increased from `40` to `300` now, in just a few key presses.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用`idUsingFactorial()`方法时的计数，例如`justin.grewal@example.com`。现在，它从`40`增加到`300`，仅需按几下按键。
- en: Let's use the `OnPush` change-detection strategy now. This will avoid the Angular
    change-detection mechanism running on each browser event, which currently causes
    a performance issue on each key press.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`OnPush`变更检测策略。这将避免Angular变更检测机制在每个浏览器事件上运行，这目前会导致性能问题。
- en: 'Open the `user-card.component.ts` file and update it, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`user-card.component.ts`文件并进行更新，如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, try typing the name `Elfie Siegert` again in the search box. You''ll notice
    that you can now see the typed letters in the search box, and it doesn''t hang
    the app as much. Also, if you look at the `appLogs` object in the **Console**
    tab, you should see something like this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再试着在搜索框中输入`Elfie Siegert`这个名字。你会注意到，现在你可以在搜索框中看到输入的字母，而且应用程序不会卡住那么多。另外，如果你在**控制台**选项卡中查看`appLogs`对象，你应该会看到类似下面的内容：
- en: '![Figure 12.4 – Logs after typing the name Elfie Siegert with OnPush strategy'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - 使用OnPush策略输入Elfie Siegert名称后的日志'
- en: '](image/Figure_12.4_B15150.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.4_B15150.jpg)'
- en: Figure 12.4 – Logs after typing the name Elfie Siegert with OnPush strategy
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 使用OnPush策略输入Elfie Siegert名称后的日志
- en: Notice that even after refreshing the app, and after typing the name `Elfie
    Siegert`, we now have a very low number of calls to the `idUsingFactorial()` method.
    For example, for the `justin.grewal@example.com` email address, we only have **20**
    hits, instead of the initial **40** hits shown in *Figure 12.2*, and **300** hits,
    as shown in *Figure 12.3*, after typing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使刷新应用程序并输入`Elfie Siegert`这个名字后，对`idUsingFactorial()`方法的调用次数也大大减少了。例如，对于`justin.grewal@example.com`电子邮件地址，我们只有**20**次调用，而不是*图12.2*中显示的初始**40**次调用，以及*图12.3*中显示的**300**次调用。
- en: Great! Within a single step, by using the `OnPush` strategy we were able to
    improve the overall performance of our `UserCardComponent`. Now you know how to
    use this strategy, see the next section to understand how it works.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过使用`OnPush`策略，我们能够在一个步骤中改善`UserCardComponent`的整体性能。现在你知道如何使用这个策略了，接下来看下一节来了解它是如何工作的。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular by default uses the **Default** change-detection strategy—or technically,
    it is the `ChangeDetectionStrategy.Default` enum from the `@angular/core` package.
    Since Angular doesn't know about every component we create, it uses the Default
    strategy to not encounter any surprises. But as developers, if we know that a
    component will not change unless one of its `@Input()` variables changes, we can—and
    we should—use the `OnPush` change-detection strategy for that component. Why?
    Because it tells Angular to not run change detection until an `@Input()` variable
    for the component changes. This strategy is an absolute winner for **presentational**
    components (sometimes called **dumb** components), which are just supposed to
    show data using `@Input()` variables/attributes, and emit `@Output()` events on
    interactions. These presentational components usually do not hold any business
    logic such as heavy computation, using services to make **HyperText Transfer Protocol**
    (**HTTP**) calls, and so on. Therefore, it is easier for us to use the `OnPush`
    strategy in these components because they would only show different data when
    any of the `@Input()` attributes from the parent component change.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Angular默认使用**默认**的变更检测策略 - 或者从`@angular/core`包中的`ChangeDetectionStrategy.Default`枚举来说，技术上来说是这样。由于Angular不知道我们创建的每个组件，它使用默认策略来避免遇到任何意外。但是作为开发人员，如果我们知道一个组件除非它的`@Input()`变量之一发生变化，否则不会改变，我们可以
    - 而且应该 - 为该组件使用`OnPush`变更检测策略。为什么？因为它告诉Angular在组件的`@Input()`变量发生变化之前不要运行变更检测。这个策略对于**呈现**组件（有时被称为**哑**组件）来说是绝对胜利的，它们只是使用`@Input()`变量/属性来显示数据，并在交互中触发`@Output()`事件。这些呈现组件通常不包含任何业务逻辑，比如重型计算，使用服务进行**超文本传输协议**（**HTTP**）调用等。因此，对于这些组件来说，我们更容易使用`OnPush`策略，因为它们只会在父组件的`@Input()`属性发生变化时显示不同的数据。
- en: Since we are now using the `OnPush` strategy on our `UserCardComponent`, it
    only triggers change detection when we replace the entire array upon searching.
    This happens after the **300ms** debounce (*line 28* in the `users.component.ts`
    file), so we only do it when the user stops typing. So, essentially, before the
    optimization, the default change detection was triggering on each keypress being
    a browser event, and now, it doesn't.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在 `UserCardComponent` 上使用了 `OnPush` 策略，它只在我们替换整个数组时触发变更检测。这发生在**300ms**
    的去抖之后（*`users.component.ts` 文件中的第28行*），因此只有在用户停止输入时才会执行。因此，在优化之前，默认的变更检测是在每次按键时触发的浏览器事件，现在不会触发。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you now know that the `OnPush` strategy only triggers the Angular change-detection
    mechanism when one or more of the `@Input()` bindings changes, this means that
    if we change a property within the component (`UserCardComponent`), it will not
    be reflected in the view because the change-detection mechanism won't run in this
    case, since that property isn't an `@Input()` binding. You would have to mark
    the component as dirty so that Angular could check the component and run change
    detection. You'll do this using the `ChangeDetectorRef` service—specifically,
    with the `.markForCheck()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道 `OnPush` 策略仅在一个或多个 `@Input()` 绑定发生变化时触发 Angular 变更检测机制，这意味着如果我们在组件 (`UserCardComponent`)
    中更改属性，它不会在视图中反映出来，因为在这种情况下变更检测机制不会运行，因为该属性不是一个 `@Input()` 绑定。您必须标记组件为脏，以便 Angular
    可以检查组件并运行变更检测。您将使用 `ChangeDetectorRef` 服务来实现这一点，具体来说，使用 `.markForCheck()` 方法。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular `ChangeDetectionStrategy` official documentation ([https://angular.io/api/core/ChangeDetectionStrategy](https://angular.io/api/core/ChangeDetectionStrategy))
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `ChangeDetectionStrategy` 官方文档（[https://angular.io/api/core/ChangeDetectionStrategy](https://angular.io/api/core/ChangeDetectionStrategy)）
- en: '`markForCheck()` method official documentation ([https://angular.io/api/core/ChangeDetectorRef#markforcheck](https://angular.io/api/core/ChangeDetectorRef#markforcheck))'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`markForCheck()` 方法官方文档（[https://angular.io/api/core/ChangeDetectorRef#markforcheck](https://angular.io/api/core/ChangeDetectorRef#markforcheck)）'
- en: Detaching the change detector from components
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件中分离变更检测器
- en: In the previous recipe, we learned how to use the `OnPush` strategy in our components
    to avoid Angular change detection running unless one of the `@Input()` bindings
    has changed. There is, however, another way to tell Angular to not run change
    detection at all, in any instance. This is handy when you want full control on
    when to run change detection. In this recipe, you'll learn how to completely detach
    the change detector from an Angular component to gain performance improvements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何在组件中使用 `OnPush` 策略，以避免 Angular 变更检测运行，除非其中一个 `@Input()` 绑定发生了变化。然而，还有另一种方法可以告诉
    Angular 完全不运行变更检测。当您希望完全控制何时运行变更检测时，这将非常方便。在本示例中，您将学习如何完全分离 Angular 组件的变更检测器，以获得性能改进。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The project for this recipe resides in `Chapter12/start_here/detaching-change-detecto:`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的项目位于 `Chapter12/start_here/detaching-change-detecto`：
- en: Open the project in VS Code.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `ng serve -o` 命令来启动 Angular 应用程序并在浏览器上提供服务。您应该看到应用程序如下：
- en: '![Figure 12.5 – App detaching-change-detector running at http://localhost:4200'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 应用程序 detaching-change-detector 在 http://localhost:4200 运行'
- en: '](image/Figure_12.5_B15150.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.5_B15150.jpg)'
- en: Figure 12.5 – App detaching-change-detector running at http://localhost:4200
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 应用程序 detaching-change-detector 在 http://localhost:4200 运行
- en: Now that we have the project served on the browser, let's see the steps of the
    recipe in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the same users list application but with a twist. Right now, we have
    the `UserSearchInputComponent` component that holds the search input box. This
    is where we type the username to search for it in the users list. On the other
    hand, we have the `UserCardListComponent` component that has a list of users.
    We''ll first experience the performance issues, and then we''ll detach the change
    detector smartly to gain performance improvements. Let''s get starte:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the app in the browser, then just click inside the search input, and
    then click outside the search input to first trigger a `focus` event on the input
    and then to trigger a `blur` event. Repeat this two times more, and then, on the
    console inside the Chrome Dev Tools, check the value of the `appLogs` object.
    You should see something like this:![Figure 12.6 – Logs after performing focus
    and blur three times on the search input
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.6_B15150.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Logs after performing focus and blur three times on the search
    input
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that the `idUsingFactorial()` method in the `UserCardComponent`
    class for the `justin.grewal@example.com` user has been called about 100 times,
    just in the steps we've performed so far.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Now, try to search for the `elfie` user by entering the name quickly in the
    search box.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll notice that the app immediately hangs, and it takes a few seconds to
    show the user. You''ll also notice that you don''t even see the letters being
    typed in the search box as you type them. If you''ve followed *Step 1* and *Step
    2* correctly, you should see an `appLogs` object, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Logs after typing elfie in the input search box'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.7_B15150.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Logs after typing elfie in the input search box
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding screenshot that the `idUsingFactorial()` method
    for the `justin.grewal@example.com` user has now been called about 220 times.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to improve performance, we''ll use the `ChangeDetectorRef` service
    in this recipe to completely detach the change detector from the `UsersComponent`
    component, which is our top component for the **Users** page. Update the `users.component.ts`
    file, as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you refresh the app now, you'll see… Actually, you won't see anything, and
    that's fine—we have more steps to follow.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, since we want to run change detection only when we have searched the users—that
    is, when the `users` array changes in the `UsersComponent` class—we can use the
    `detectChanges()` method of the `ChangeDetectorRef` instance. Update the `users.component.ts`
    file again, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, try performing the actions again—that is, refresh the page, focus in on
    the input, focus out, focus in, focus out, focus in, focus out, and then type
    `elfie` in the search input. Once you''ve followed the steps, you should see the
    `appLogs` object, as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Logs after performing the test steps and using ChangeDetectorRef.detach()'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.8_B15150.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Logs after performing the test steps and using ChangeDetectorRef.detach()
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding screenshot that even after performing all the actions
    mentioned in *Step 1* and *Step 2*, we have a very low count of the change-detection
    run cycle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Awesomesauce! You've just learned how to detach the Angular change detector
    using the `ChangeDetectorRef` service. Now that you've finished the recipe, see
    the next section to understand how it works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ChangeDetectorRef` service provides a bunch of important methods to control
    change detection completely. In the recipe, we use the `.detach()` method in the
    `ngOnInit()` method of the `UsersComponent` class to detach the Angular change-detection
    mechanism from this component as soon as it is created. As a result, no change
    detection is triggered on the `UsersComponent` class, nor in any of its children.
    This is because each Angular component has a change-detection tree in which each
    component is a node. When we detach a component from the change-detection tree,
    that component (as a tree node) is detached, and so are its child components (or
    nodes). By doing this, we end up with absolutely no change detection happening
    for the `UsersComponent` class. As a result, when we refresh the page nothing
    is rendered, even after we've got the users from the **application programming
    interface** (**API**) and have got them assigned to the `users` property inside
    the `UsersComponent` class. Since we need to show the users on the view, which
    requires the Angular change-detection mechanism to be triggered, we use the `.detectChanges()`
    method from the `ChangeDetectorRef` instance, right after we've assigned the users
    data to the `users` property. As a result, Angular runs the change-detection mechanism,
    and we get the user cards shown on the view.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef`服务提供了一系列重要的方法来完全控制变化检测。在这个示例中，我们在`UsersComponent`类的`ngOnInit()`方法中使用`.detach()`方法来从这个组件中分离出Angular变化检测机制。结果，`UsersComponent`类以及其子类都不会触发任何变化检测。这是因为每个Angular组件都有一个变化检测树，其中每个组件都是一个节点。当我们从变化检测树中分离一个组件时，该组件（作为树节点）以及其子组件（或节点）也会被分离。通过这样做，我们最终使`UsersComponent`类不会发生任何变化检测。因此，当我们刷新页面时，即使我们从**应用程序编程接口**（**API**）获取了用户并将它们分配给`UsersComponent`类中的`users`属性，也不会渲染任何内容。由于我们需要在视图上显示用户，这需要触发Angular变化检测机制，我们在将用户数据分配给`users`属性后，立即使用`ChangeDetectorRef`实例的`.detectChanges()`方法。结果，Angular运行了变化检测机制，我们在视图上看到了用户卡片。'
- en: This means that in the entire **Users** page (that is, on the `/users` route)
    the only time the Angular change-detection mechanism would trigger after the `UsersComponent`
    class has initiated is when we call the `searchUsers()` method, get the data from
    the API, and assign the result to the `users` property, thus creating a highly
    controlled change-detection cycle, resulting in much better performance overall.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在整个**Users**页面（即`/users`路由）上，只有在`UsersComponent`类初始化后，当我们调用`searchUsers()`方法，从API获取数据并将结果分配给`users`属性时，Angular变化检测机制才会触发，从而创建一个高度受控的变化检测周期，从而在整体上获得更好的性能。
- en: See also
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`ChangeDetectorRef` official documentation ([https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef))'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChangeDetectorRef`官方文档([https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef))'
- en: Running async events outside Angular with runOutsideAngular
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular之外运行异步事件的runOutsideAngular
- en: Angular runs its change-detection mechanism on a couple of things, including—but
    not limited to—all browser events such as `keyup`, `keydown`, and so on. It also
    runs change detection on `setTimeout`, `setInterval`, and Ajax HTTP calls. If
    we had to avoid running change detection on any of these events, we'd have to
    tell Angular not to trigger change detection on them—for example, if you were
    using the `setTimeout()` method in your Angular component, it would trigger an
    Angular change detection each time its callback method was called. In this recipe,
    you'll learn how to execute code blocks outside of the `ngZone` service, using
    the `runOutsideAngular()` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `Chapter12/start_here/run-outside-angula:`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – App run-outside-angular running on http://localhost:4200'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.9_B15150.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – App run-outside-angular running on http://localhost:4200
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running, let's see the steps of the recipe in the next
    section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an app that shows a watch. However, the change detection right now in
    the app is not optimal, and we have plenty of room for improvement. We'll try
    to remove any unnecessary change detection using the `runOutsideAngular` method
    from `ngZone`. Let's get starte:.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The clock values are constantly updating. Thus, we have change detection running
    for each update cycle. Open the Chrome DevTools and switch to the **Console**
    tab. Type `appLogs` and press *Enter* to see how many times change detection has
    run for the `hours`, `minutes`, `seconds`, and `milliseconds` components. It should
    look like this:![Figure 12.10 – The appLogs object reflecting number of change-detection
    runs
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.10_B15150.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – The appLogs object reflecting number of change-detection runs
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To measure performance, we need to see the numbers within a fixed time period.
    Let''s add some code to turn off the interval timer in 4 seconds from the app''s
    start for the clock. Modify the `watch-box.component.ts` file, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refresh the app and wait for 4 seconds for the clock to stop. Then, type `appLogs`
    multiple times in the **Console** tab, press *Enter*, and see the results. The
    clock stops but the animation is still running. You should see that change detection
    for the `watch` key still increases, as follows:![Figure 12.11 – Change detection
    still running for the watch component
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.11_B15150.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Change detection still running for the watch component
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also stop the animation inside the watch after 4 seconds. Update the
    `watch.component.ts` file, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Refresh the app and wait for the animation to stop. Have a look at the `appLogs`
    object in the Chrome DevTools. You should see that change detection stops for
    the `watch` key, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Change detection stops after we stop the animation interval'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.12_B15150.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – Change detection stops after we stop the animation interval
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the animation to run but without causing additional change-detection
    runs. This is because we want to make our app more performant. So, let''s just
    stop the clock for now. To do that, update the `watch-box.component.ts` file,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we've now stopped the clock, the values for `appLogs` for the `watch`
    key are now only based on the animation for these 4 seconds. You should now see
    a value between **250** and **260** for the `watch` key.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s avoid running change detection on the animation by running the interval
    outside the `ngZone` service. We''ll use the `runOutsideAngular()` method for
    this. Update the `watch.component.ts` file, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Refresh the app and wait for about 5 seconds. If you check the `appLogs` object
    now, you should see a decrease in the overall number of change-detection runs
    for each of the properties, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – The appLogs object after using runOutsideAngular() in WatchComponent'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.13_B15150.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – The appLogs object after using runOutsideAngular() in WatchComponent
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Yayy! Notice that the value for the `watch` key in the `appLogs` object has
    decreased from about **250** to **4** now. This means that our animation now doesn't
    contribute to change detection at all.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the usage of `clearInterval()` from the animation for the `WatchComponent`
    class. As a result, the animation should keep running. Modify the `watch.component.ts`
    file, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, remove the usage of `clearInterval()` from the `WatchBoxComponent`
    class to run the clock. Update the `watch-box.component.ts` file, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Refresh the app and check the value of the `appLogs` object after a few seconds,
    multiple times. You should see something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – The appLogs object after performance optimization with runOutsideAngular()'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.14_B15150.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – The appLogs object after performance optimization with runOutsideAngular()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding screenshot, you''d be like: "*Ahsan! What is this?
    We still have a huge number for the change-detection runs for the watch key. How
    is this performant exactly?*" Glad you asked. I will tell you the *why* in the
    *How it works…* section.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final step, stop the Angular server and run the following command to start
    the server in production mode:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Navigate to [https://localhost:4200](https://localhost:4200) again. Wait for
    a few seconds and then check the `appLogs` object in the **Console** tab multiple
    times. You should see the object, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.15 – The appLogs object using the production build'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.15_B15150.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – The appLogs object using the production build
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Boom! If you look at the preceding screenshot, you should see that the change-detection
    run count for the `watch` key is always just one cycle more than the `milliseconds`
    key. This means that the `WatchComponent` class is almost only re-rendered whenever
    we have the value of the `@Input() milliseconds` binding updated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've finished the recipe, see the next section to understand how
    it all works.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we begin by looking at the `appLogs` object, which contains
    some key-value pairs. The value for each key-value pair represents the number
    of times Angular ran change detection for a particular component. The `hours`,
    `milliseconds`, `minutes`, and `seconds` keys represent the `WatchTimeComponent`
    instance for each of the values shown on the clock. The `watch` key represents
    the `WatchComponent` instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the recipe, we see that the value for the `watch` key is
    more than twice the value of the `milliseconds` key. Why do we care about the
    `milliseconds` key at all? Because the `@Input()` attribute binding `milliseconds`
    changes most frequently in our application—that is, it changes every 1 **millisecond**
    (**ms**). The second most frequently changed values are the `xCoordinate` and
    `yCoordinates` properties within the `WatchComponent` class, which change every
    30 ms. The `xCoordinate` and `yCoordinate` values aren''t bound directly to the
    template (the **HyperText Markup Language** (**HTML**)) because they change the
    **Cascading Style Sheets** (**CSS**) variables of the `stopWatch` view child.
    This happens inside the `animate()` method, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Thus, changing these values shouldn't actually trigger change detection at all.
    We begin by limiting the clock window, using the `clearInterval()` method in the
    `WatchBoxComponent` class so that the clock stops within 4 seconds and we can
    evaluate the numbers. In *Figure 12.11*, we see that even after the clock stops,
    the change-detection mechanism keeps triggering for the `WatchComponent` class.
    This increases the count for the `watch` key in the `appLogs` object as time passes.
    We then stop the animation by using `clearInterval()` in the `WatchComponent`
    class. This stops the animation after 4 seconds as well. In *Figure 12.12*, we
    see that the count for the `watch` key stops increasing after the animation stops.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We then try to see the count of change detection only based on the animation.
    In *Step 6*, we stop the clock. Therefore, we only get a count based on the animation
    in the `appLogs` object for the `watch` key, which is a value between **250**
    and **260**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We then introduce the magic `runOutsideAngular()` method into our code. This
    method is part of the `NgZone` service. The `NgZone` service is packaged with
    the `@angular/core` package. The `runOutsideAngular()` method accepts a method
    as a parameter. This method is executed outside the Angular zone. This means that
    the `setTimeout()` and `setInterval()` methods used inside the `runOutsideAngular()`
    method do not trigger the Angular change-detection cycle. You can see in *Figure
    12.13* that the count drops to **4** after using the `runOutsideAngular()` method.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We then remove the `clearInterval()` usage from both the `WatchBoxComponent`
    and the `WatchComponent` classes—that is, to run the clock and the animation again,
    as we did in the beginning. In *Figure 12.14*, we see that the count for the `watch`
    key is almost twice the value of the `milliseconds` key. Now, why is that double
    exactly? This is because in development mode, Angular runs the change-detection
    mechanism twice. Therefore, in *Step 9* and *Step 10*, we run the application
    in production mode, and in *Figure 12.15*, we see that the value for the `watch`
    key is just one greater than the value for the `milliseconds` key, which means
    that the animation does not trigger any change detection for our application any
    more. Brilliant, isn't it? If you found this recipe useful, do let me know on
    my socials.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how it works, see the next section for further reading.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NgZone` official documentation ([https://angular.io/api/core/NgZone](https://angular.io/api/core/NgZone))'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular `ChangeDetectorRef` official documentation ([https://angular.io/api/core/ChangeDetectorRef](https://angular.io/api/core/ChangeDetectorRef))
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using trackBy for lists with *ngFor
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are an essential part of most of the apps we build today. If you're building
    an Angular app, there's a great chance you will use the `*ngFor` directive at
    some point. We know that `*ngFor` allows us to loop over arrays or objects generating
    HTML for each item. However, for large lists, using it may cause performance issues,
    especially when the source for `*ngFor` is changed completely. In this recipe,
    we'll learn how we can improve the performance of lists using the `*ngFor` directive
    with the `trackBy` function. Let's get started.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `Chapter12/start_here/using-ngfor-trackb:`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.16 – App using-ngfor-trackby running on http://localhost:4200'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.16_B15150.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – App using-ngfor-trackby running on http://localhost:4200
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running, let's see the steps of the recipe in the next
    section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an app that has a list of 1,000 users displayed on the view. Since we're
    not using a virtual scroll and a standard `*ngFor` list, we do face some performance
    issues at the moment. Notice that when you refresh the app, even after the loader
    is hidden, you see a blank white box for about 2-3 seconds before the list appears.
    Let's start the recipe to reproduce the performance issues and to fix them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: First of all, open the Chrome DevTools and look at the **Console** tab. You
    should see a `ListItemComponent initiated` message logged 1,000 times. This message
    will be logged any time a list-item component is created/initiated.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, delete the first item by using the cross button on it. You should see the
    same message logged again about 999 times now, as shown in the following screenshot.
    This means we recreate the list-item component for the remaining 999 items:![Figure
    12.17 – Logs shown again after deleting an item
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.17_B15150.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.17 – Logs shown again after deleting an item
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now, refresh the app and tap on the first list item. You should see the `ListItemComponent
    initiated` logs again, as shown in the following screenshot. This means we recreate
    all the list items on an item update. You will notice that the update to the first
    item's name in the **user interface** (**UI**) is reflected in about 2-3 seconds:![Figure
    12.18 – Logs shown again after updating an item
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.18_B15150.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Logs shown again after updating an item
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fix the performance issue by using the `trackBy` function. Open
    the `the-amazing-list.component.ts` file and update it, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, update the `the-amazing-list.component.html` file to use the `trackByFn()`
    method we just created, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, refresh the app, and click the first list item to update it. You will notice
    that the item is updated immediately and we don't log the `ListItemComponent initiated`
    message again anymore, as shown in the following screenshot:![Figure 12.19 – No
    further logs after updating an item using the trackBy function
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.19_B15150.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – No further logs after updating an item using the trackBy function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Delete an item as well now, and you will see we do not log the `ListItemComponent
    initiated` message again in this case, as well.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great!! You now know how to use the `trackBy` function with the `*ngFor` directive
    to optimize the performance of lists in Angular. To understand all the magic behind
    the recipe, see the next section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `*ngFor` directive by default assumes that the object itself is its unique
    identity, which means that if you just change a property in an object used in
    the `*ngFor` directive, it won''t re-render the template for that object. However,
    if you provide a new object in its place (different reference in memory), the
    content for the particular item will re-render. This is what we actually do in
    this recipe to reproduce the performance-issue content. In the `data.service.ts`
    file, we have the following code for the `updateUser()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that we use the object spread operator ( `{ … }` ) to return a new object
    for each item in the array. This tells the `*ngFor` directive to re-render the
    UI for each item in the `listItems` array in the `TheAmazingListComponent` class.
    Suppose you send a query to the server to find or filter users. The server could
    return a response that has 100 users. Out of those 100, about 90 were already
    rendered on the view, and only 10 are different. Angular, however, would re-render
    the UI for all the list items because of the following potential reasons (but
    not limited to these):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The sorting/placement of the users could have changed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the users could have changed.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we want to avoid using the object reference as the unique identifier for
    each list item. For our use case, we know that each user's email is unique, therefore
    we use the `trackBy` function to tell Angular to use the user's email as the unique
    identifier. Now, even if we return a new object for each user after a user update
    from the `updateUser()` method (as previously shown), Angular doesn't re-render
    all the list items. This is because the new objects (users) have the same email
    and Angular uses it to track them. Pretty cool, right?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned how the recipe works, see the next section to view a
    link for further reading.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NgForOf` official documentation ([https://angular.io/api/common/NgForOf](https://angular.io/api/common/NgForOf))'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving heavy computation to pure pipes
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular, we have a particular way of writing components. Since Angular is
    heavily opinionated, we already have a lot of guidelines from the community and
    the Angular team on what to consider when writing components—for example, making
    HTTP calls directly from a component is considered a not-so-good practice. Similarly,
    if we have heavy computation in a component, this is also not considered a good
    practice. And when the view depends upon a transformed version of the data using
    a computation constantly, it makes sense to use Angular pipes. In this recipe,
    you'll learn how to use Angular pure pipes to avoid heavy computation within components.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we are going to work with resides in `Chapter12/start_here/using-pure-pipes`,
    inside the cloned repositor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.20 – using-pure-pipes app running at http://localhost:4200'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.20_B15150.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – using-pure-pipes app running at http://localhost:4200
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the project served on the browser, let's see the steps of the
    recipe in the next section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app we''re working with has some performance issues, particularly with
    the `UserCardComponent` class because it uses the `idUsingFactorial()` method
    to generate a unique ID to show on the card. You''ll notice that if you try typing
    `''irin''` in the search box, the app hangs for a while. We''re not able to see
    the letters being typed instantly in the search box, and it takes a while before
    the results show. We will fix the issues by moving the computation in the `idUsingFactorial()`
    method to an Angular (pure) pipe. Let''s get starte:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an Angular pipe. We''ll move the computation for generating a
    unique ID for this pipe to later code. In the project root, run the following
    command in the terminal:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, copy the code for the `createUniqueId()` method from the `user-card.component.ts`
    file and paste it into the `unique-id.pipe.ts` file. We''ll also modify the code
    a bit, so it should now look like this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, also copy the `idUsingFactorial()` method from the `user-card.component.ts`
    file to the `unique-id.pipe.ts` file and update the file, as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, update the `user-card.component.html` file to use the `uniqueId` pipe
    instead of the component''s method. The code should look like this:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, refresh the app and type the name `Elfie Siegert` in the search box. Notice
    that the UI is not blocked. We're able to see the typed letters immediately as
    we type them, and the search results are faster as well.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boom! Now that you know how to optimize performance by moving heavy computation
    to pure Angular pipes, see the next section to understand how this works.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Angular by default runs change detection on each browser event triggered
    in the app, and since we're using an `idUsingFactorial()` method in the component
    template (UI), this function runs each time Angular runs the change-detection
    mechanism, causing more computation and performance issues. This would also hold
    true if we used a getter instead of a method. Here, we use a method because each
    unique ID is dependent on the index and we need to pass the index in the method
    when calling it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: We can take a step back from the initial implementation and think what the method
    actually does. It takes an input, does some computation, and returns a value based
    on the input—a classic example of data transformation, and also an example of
    where you would use a pure function. Luckily, Angular pure pipes are pure functions,
    and they do trigger change detection unless the input changes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we move the computation to a newly created Angular pipe. The
    pipe's `transform()` method receives the value to which we're applying the pipe,
    which is the index of each user card in the `users` array. The pipe then uses
    the `idUsingFactorial()` method and, ultimately, the `createUniqueId()` method
    to calculate a random unique ID. When we start typing in the search box, the values
    for the index do not change. This results in no change detection being triggered
    until we get back a new set of users as output. Therefore, there is no unnecessary
    computation run as we type the input into the search box, thus optimizing performance
    and unblocking the UI thread.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular pure and impure pipes official documentation ([https://angular.io/guide/pipes#pure-and-impure-pipes](https://angular.io/guide/pipes#pure-and-impure-pipes))
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using web workers for heavy computation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your Angular application does a lot of computation during an action, there's
    a great chance that it will block the UI thread. This will cause a lag in rendering
    the UI because it blocks the main JavaScript thread. Web workers allow us to run
    heavy computation in the background thread, thus freeing the UI thread as it is
    not blocked. In this recipe, we're going to use an application that does a heavy
    computation in the `UserService` class. It creates a unique ID for each user card
    and saves it into the `localStorage`. However, it loops a couple of thousand times
    before doing so, which causes our application to hang for a while. In this recipe,
    we'll move the heavy computation from the components to a web worker and will
    also add a fallback in case web workers aren't available.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we are going to work with resides in `Chapter12/start_here/using-web-workers`,
    inside the cloned repositor:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ng serve -o` command to start the Angular app and serve it on the
    browser. You should see the app, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – App using-web-workers running at http://localhost:4200'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.21_B15150.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – App using-web-workers running at http://localhost:4200
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running, let's see the steps of the recipe in the next
    section.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you open the app, you''ll notice that it takes some time before the user
    cards are rendered. This shows that the UI thread is blocked until we have the
    computation finished. The culprit is the `saveUserUniqueIdsToStorage()` method
    in the `UserService` class. This generates a unique ID a couple of thousands of
    times before saving it to the `localStorage`. Let''s start the recipe, to improve
    the performance of the app. We''ll start by implementing the web worke:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first create a web worker. Run the following command in the project
    root:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, copy the `for` loop from the `saveUserUniqueIdsToStorage()` method in
    the `UserService` class to the newly created `id-generator.worker.ts` file. The
    code should look like this:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have the worker file created, let''s create a single instance of
    a worker to use it in the next steps. Create a new file in the `constants` folder.
    Name it `get-unique-id-worker.ts` and add the following code inside the file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we''ll use the worker in the `user.service.ts` file. Update it, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll update the file again to modify the `saveUserUniqueIdsToStorage()` method.
    We''ll use the worker instead of using the existing code, if we have web workers
    available in the environment. Update the `user.service.ts` file, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Refresh the app and notice how long it takes for the user cards to render.
    They should appear much faster than before. Also, you should be able to see the
    following logs reflecting the communication from the app to the web worker, and
    vice versa:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22 – Logs showing messages to and from the app to web workers'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.22_B15150.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.22 – Logs showing messages to and from the app to web workers
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Woohoo!!! The power of web workers! And now you know how to use web workers
    in an Angular app to move heavy computation to them. Since you've finished the
    recipe, see the next section on how this works.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed in the recipe''s description, web workers allow us to run and
    execute code in a separate thread from the main JavaScript (or UI thread). At
    the beginning of the recipe, whenever we refresh the app or search for a user,
    it blocks the UI thread. This is until a unique ID is generated for each card.
    We begin the recipe by creating a web worker using the Angular **command-line
    interface** (**CLI**). This creates an `id-generator.worker.ts` file, which contains
    some boilerplate code to receive messages from the UI thread and to send a message
    back to it as a response. The CLI command also updates the `angular.json` file
    by adding a `webWorkerTsConfig` property. The value against the `webWorkerTsConfig`
    property is the path to the `tsconfig.worker.json` file, and the CLI command also
    creates this `tsconfig.worker.json` file. If you open the `tsconfig.worker.json`
    file, you should see the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After creating a web worker file, we create another file named `uniqueIdWorker.ts`.
    This file exports the `getUniqueIdWorker()` method as the default export. When
    we call this method, it generates a new `Worker` instance if we don't have a worker
    generated already. The method uses the `id-generator.worker.ts` file to generate
    a worker. We also use the `addEventListener()` method inside the worker file to
    listen to the messages sent from the UI thread (that is, the `UserService` class).
    We receive the `index` of the user card and the `email` of the user as the data
    in this message. We then use a `for` loop to generate a unique ID (`uniqueId`
    variable), and once the loop ends, we use the `postMessage()` method to send the
    `uniqueId` variable and the `email` back to the UI thread.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the `UserService` class, we listen to messages from the worker. In the
    `constructor()` method, we check if web workers are available in the environment
    by checking the value from the `getUniqueIdWorker()` method, which should be a
    non-null value. Then, we use the `worker.onmessage` property to assign it a method.
    This is to listen to the messages from the worker. Since we already know that
    we get the `uniqueId` variable and the `email` from the worker, we use the `email`
    to get the appropriate user from the `usersCache` variable. Then, we store the
    user data with the `uniqueId` variable to the `localStorage` against the user's
    `email`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the `saveUserUniqueIdsToStorage()` method to use the worker
    instance if it is available. Notice that we use the `worker.postMessage()` method
    to pass the `index` and the `email` of the user. Note also that we are using the
    previous code as a fallback for cases where we don't have web workers enabled.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular official documentation on web workers ([https://angular.io/guide/web-worker](https://angular.io/guide/web-worker))
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MDN web worker documentation ([https://developer.mozilla.org/en-US/docs/Web/API/Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker))
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using performance budgets for auditing
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, most of the population has a pretty good internet connection
    to use everyday applications, be it a mobile app or a web app, and it is fascinating
    how much data we ship to our end users as a business. The amount of JavaScript
    shipped to users has an ever-increasing trend now, and if you're working on a
    web app, you might want to use performance budgets to make sure the bundle size
    doesn't exceed a certain limit. With Angular apps, setting the budget sizes is
    a breeze. In this recipe, you're going to learn how to use the Angular CLI to
    set up budgets for your Angular apps.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The project for this recipe resides in `Chapter12/start_here/angular-performance-budget:`
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ng build --configuration production` command to build the Angular
    app in production mode. Notice the output on the console. It should look like
    this:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23 – Build output for production mode, without performance budgets'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.23_B15150.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.23 – Build output for production mode, without performance budgets
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the bundle size for the `main.*.js` file is about 260 **kilobytes**
    (**KB**) at the moment. Now that we have built the app, let's see the steps of
    the recipe in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that is really small in terms of bundle size at the moment.
    However, this could grow into a huge app with upcoming business requirements.
    For the sake of this recipe, we''ll increase the bundle size deliberately and
    will then use performance budgets to stop the Angular CLI from building the app
    for production if the bundle size exceeds the budget. Let''s begin the recip:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app.component.ts` file and update it, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, build the app again for production using the `ng build --configuration
    production` command. You should see that the bundle size for the `main.*.js` file
    is now 1.12 **megabytes** (**MB**). This is a huge increase in size compared to
    the original 268.05 KB, as you can see in the following screenshot:![Figure 12.24
    – The bundle size for main.*.js increased to 1.11 MB
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.24_B15150.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.24 – The bundle size for main.*.js increased to 1.11 MB
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose our business requires us to not ship apps with main bundle sizes
    more than 1.0 MB. For this, we can configure our Angular app to throw an error
    if the threshold is met.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the app, open the `angular.json file`, and update it. The property
    that we''re targeting is `projects.angular-performance-budgets.architect.build.configurations.production.budgets`.
    The file should look like this:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that we have the budgets in place, let's build the app once again using
    the `ng build --configuration production` command. The build should fail and you
    should see both a warning and an error on the console, as follows:![Figure 12.25
    – Angular CLI throwing errors and warnings based on performance budgets
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.25_B15150.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.25 – Angular CLI throwing errors and warnings based on performance
    budgets
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve our application by not importing the entire libraries in the
    `app.component.ts` file, and use the `date-fns` package instead of `moment.js`
    to do the same thing. Run the following command to install the `date-fns` package:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, update the `app.component.ts` file, as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the `ng build --configuration production` command again. You should see
    a decreased bundle size, as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.26 – Reduced bundle size after using date-fns and optimized imports'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.26_B15150.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.26 – Reduced bundle size after using date-fns and optimized imports
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Boom!! You just learned how to use the Angular CLI to define performance budgets.
    These budgets can be used to throw warnings and errors based on your configuration.
    Note that the budgets can be modified based on changing business requirements.
    However, as engineers, we have to be cautious about what we set as performance
    budgets to not ship JavaScript over a certain limit to the end users.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance budgets with the Angular CLI official documentation ([https://web.dev/performance-budgets-with-the-angular-cli/](https://web.dev/performance-budgets-with-the-angular-cli/))
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing bundles with webpack-bundle-analyzer
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at configuring budgets for our Angular app,
    and this is useful because you get to know when the overall bundle size exceeds
    a certain threshold, although you don't get to know how much each part of the
    code is actually contributing to the final bundles. This is what we call *analyzing*
    the bundles, and in this recipe, you will learn how to use `webpack-bundle-analyzer`
    to audit the bundle sizes and the factors contributing to them.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project we are going to work with resides in `Chapter12/start_here/using-webpack-bundle-analyzer`,
    inside the cloned repositor:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `ng serve -o` command to start the Angular app and serve it on the browser.
    You should see the app, as follows:![Figure 12.27 – App using-webpack-bundle-analyzer
    running at http://localhost:4200
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_12.27_B15150.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.27 – App using-webpack-bundle-analyzer running at http://localhost:4200
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, build the app using the `ng build --configuration production` command
    to build the Angular app in production mode. You should see the following output:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.28 – The main bundle, having a size of 1.11 MB'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.28_B15150.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.28 – The main bundle, having a size of 1.11 MB
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have built the app, let's see the steps of the recipe in the next
    section.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have noticed, we have a main bundle of size 1.12 MB. This is because
    we are using the `Three.js` library and the `moment.js` library in our `app.component.ts`
    file, which imports those libraries, and they end up being in the main bundle.
    Let''s start the recipe to analyze the factors for the bundle size visuall:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll first install the `webpack-bundle-analyzer` package. Run the following
    command in the project root:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, create a script in the `package.json` file. We''ll use this script in
    the next steps to analyze our final bundles. Update the `package.json` file, as
    follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, build the production bundle again, but with an argument to generate a
    `stats.json` file as well. Run the following command from the project root:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, run the `analyze-bundle` script to use the `webpack-bundle-analyzer` package.
    Run the following command from the project root:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will spin up a server with the bundle analysis. You should see a new tab
    opened in your default browser, and it should look like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29 – Bundle analysis using webpack-bundle-analyzer'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.29_B15150.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.29 – Bundle analysis using webpack-bundle-analyzer
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `lib` folder takes a huge portion of the bundle size—648.29
    KB, to be exact, which you can check by just doing a mouseover on the `lib` box.
    Let''s try to optimize the bundle size. Let''s install the `date-fns` package
    so that we can use it instead of `moment.js`. Run the following command from your
    project root:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, update the `app.component.ts` file to use the `date-fns` package''s `format()`
    method instead of using the `moment().format()` method. We''ll also just import
    the `Scene` class from the `Three.js` package instead of importing the whole library.
    The code should look like this:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the `ng build --configuration production --stats-json` command, and then
    run `npm run analyze-bundle`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once `webpack-bundle-analyzer` runs you should see the analysis, as shown in
    the following screenshot. Notice that we don''t have the `moment.js` file or the
    `lib` block anymore, and the overall bundle size has reduced from 1.15 MB to 831.44
    KB:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30 – Bundle analysis after using date-fns instead of moment.js'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.30_B15150.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.30 – Bundle analysis after using date-fns instead of moment.js
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Woohoo!!! You now know how to use the `webpack-bundle-analyzer` package to audit
    bundle sizes in Angular applications. This is a great way of improving overall
    performance, because you can identify the chunks causing the increase in the bundle
    size and then optimize the bundles.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting started with webpack ([https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/))
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpack-bundle-analyzer`—GitHub repository ([https://github.com/webpack-contrib/webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer))'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
