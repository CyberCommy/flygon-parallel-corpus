- en: Chapter 7. Working with Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game's success depends largely on its look and feel. This directly means
    that the game must have an eye-catching graphical display. It is not always possible
    to provide maximum quality graphical assets due to space and heap restrictions.
    So, there has to be a way to create or improvise the graphical assets at runtime
    for display. This necessity gave birth to the concept of shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can operate on any visual element and can tweak every pixel of drawable
    elements before rendering. Mostly, shaders are optimized for a specific graphics
    processor. However, nowadays, shaders can be written to support multiple processors
    on multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Android accommodates the option to work with shaders in the Android framework
    itself. Additionally, OpenGL shaders can also be used and customized with the
    help of the Android NDK. There are many occasions where exquisite graphical quality
    is delivered with the help of shaders without excellent raw art assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a discussion about shaders in this chapter from the point of view
    of Android game development through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How shaders work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android library shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders through OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of shaders in games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders and game performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers develop games on Android, but do not possess much knowledge
    about shaders. In most cases, developers do not need to work with shaders, or
    there are some pre-defined shaders inside the game development framework or engines.
  prefs: []
  type: TYPE_NORMAL
- en: In 1988, the animation studio Pixar introduced the modern concept of shaders.
    However, GPUs were not capable of handling shaders at that point of time. OpenGL
    and Direct3D are the first two graphic libraries to support shaders. GPU started
    supporting shaders through pixel shading at the 2D level. Soon, it was enhanced
    to support vertex shaders. Nowadays, geometry shaders are also supported by OpenGL
    3.2 and Direct3D 10 libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dive a bit deeper into shaders to understand their definition, necessity,
    and scope for Android games.
  prefs: []
  type: TYPE_NORMAL
- en: What is a shader?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple words, a shader is an instruction set to manipulate the visual display
    of the input graphic assets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's elaborate the definition a bit. All the instructions are basically done
    through programming. That's the reason the concept of a shader exists only in
    computer graphics. Shaders are able to perform a computation based on the instruction
    and input asset to produce more efficient output-displayable assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical shaders can process either a vertex or a pixel. Pixel shaders can compute
    on the color, depth, and alpha properties of an asset. Vertex shaders can compute
    the position, color, co-ordinates, depth, illuminations, and so on of a vertex.
    Thus, shaders can be primarily divided into two categories depending on the operational
    base type:'
  prefs: []
  type: TYPE_NORMAL
- en: 2D shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Necessity of shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the normal practice of game development, Android developers do not bother
    about shaders. But the necessity of shaders is inevitable. Initially, for small-scale
    games, art assets are used without improvement. Any modification to the assets
    is managed by the old process of updating the art asset itself.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can minimize this extra time-consuming effort. The same asset can be
    manipulated to create different objects on screen. For example, you can blur out
    the object as it goes out of focus, change the color of the sprites during gameplay
    to indicate different teams or players, create masks of art assets, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders have the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: When different shaders are applied to the same art asset, it produces different
    assets, depending on your requirements at runtime. Thus, the shader can save extra
    art-creation time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-time integration of drawable objects in the game can lead to a different
    visual experience through different shaders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the art assets are minimized, using shaders can reduce the game build size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be more visual difference with the same set of assets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation can be created by shaders with simple art by manipulating the visual
    content repeatedly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders are useful for creating visual effects during runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, using shaders may lead to some negative consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Using shaders will increase the processing time due to the manipulation of the
    visual assets during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unoptimized use of shaders may lead to more heap memory consumption as various
    intermediate instances will be stored in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, shaders are responsible for the distortion of objects while processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Art assets become vulnerable to quality loss using shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the first two are actual direct consequences of using shaders. The rest
    of the problems can occur only if the developer uses a badly written shader or
    faulty shader. Therefore, it is extremely necessary to choose the perfect shader
    for a specific task.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the shader process takes a long time, resulting in poor FPS output.
    A few old GPUs do not support all kinds of shaders. Therefore, the developer should
    check and confirm the hardware platform on which the shader is to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Scope of shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shaders can be used in a variety of sectors related to computer graphics, such
    as image processing, photography, digital animation, video/computer/digital games,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The gaming sector is one of the largest communities that uses shaders. The Android
    platform is no exception. Android game developers use shaders on a large scale
    in both 3D and 2D games.
  prefs: []
  type: TYPE_NORMAL
- en: Frankly speaking, 2D games do not have much scope for shaders. Only a pixel
    shader can manipulate the color, opacity, saturation, and hue of a pixel. This
    is useful when the same raw assets are used for different visibility.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a 2D cricket game has many teams with different outfits to distinguish
    between them. The developer creates all the sprite animation assets in one design
    and applies shaders to manipulate color differently for different teams. Thus,
    the output sprites have different visibility and are recognized easily by the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: How shaders work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed that shaders process either vertices or pixels. So,
    the basic working principle is to change or manipulate data at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How shaders work](img/B05069_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A shader process is a specific set of instructions to process vertices or fragments.
    Different shader programs can be written for various types of processing.
  prefs: []
  type: TYPE_NORMAL
- en: A vertex shader is used to change the shape of the model; it can also change
    the surface-formation system.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel/fragment shaders can change the pixel color value along with opacity.
    Pixel data can be merged, modified, or replaced by a shader program to form a
    new digital image.
  prefs: []
  type: TYPE_NORMAL
- en: Types of shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many shaders used in the gaming industry. They are categorized on
    the basis of their behavior and features. Some of the shaders are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pixel shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertex shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geometry shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tessellation shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a detailed look at these types.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pixel shaders are 2D shaders that work on textures or digital images. Pixel
    shaders process colors and other attributes of a single pixel. Each single pixel
    is called a fragment. This is the reason pixel shaders are often called fragment
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vertex shader mainly operates on the vertices of a mesh or model. Every mesh
    of a model is made up of multiple vertices. A vertex shader can only be applied
    to 3D models. So, a vertex shader is a type of 3D shader.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geometry shaders are used to create new primitive graphic elements. After applying
    a vertex shader in order to execute a rendering pipeline, geometry shaders are
    used to create points, lines, and triangles to form a surface.
  prefs: []
  type: TYPE_NORMAL
- en: Tessellation shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a typical 3D shader used to simplify and improve 3D mesh during tessellation.
    It is subdivided into two shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Hull shaders or tessellation control shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain shaders or tessellation evolution shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two shaders are used together to reduce mesh bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Tessellation shaders have the power to improve 3D models in such a way that
    the drawable vertex count is reduced significantly. Thus, rendering becomes faster.
  prefs: []
  type: TYPE_NORMAL
- en: Android library shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android provides the shader option in its framework in the `android.graphics`
    package. A few well-known and widely used shaders are also in the Android library.
    Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BitmapShader`: This can be used to draw a bitmap in the texture format. It
    also supports tiling or mirroring of the bitmap. It is very useful for creating
    terrain with tiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComposeShader`: This is used to merge two shaders. So, it is very useful for
    masking or merging colors for two different shaders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearGradient`: This is used to create a gradient along with the given line
    segment with a defined color set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadialGradient`: This is used to create a gradient along with the given circle
    segment with a defined color set. A radial origin and radius are provided to create
    the gradient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SweepGradient`: This is used to create a sweep gradient color around a point
    with the given radius.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Android library shaders](img/B05069_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These options are really good for creating different objects with different
    styles of the same primitive object.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A developer has the option to write a customized shader as per their requirements.
    Android provides the `android.graphics.Shader` class. It is easy to create your
    own shader class using the primitive shaders provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom shader may not include only one shader. It can be a combination
    of various shaders. For example, consider masking an image with a circular view
    port with a motion-touch event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example is one of the most commonly used shader styles in picture-based
    games. You can also implement such shaders to create hidden object games.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is highlighting a specific object on the screen. The same viewable
    circle can be used to show only the highlighted object. In this case, color can
    be semitransparent to show a dull background.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders through OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, OpenGL supports implementing shaders for Android 3D games. OpenGL
    ES 2.0 is the supporting platform in Android for shaders. It has two functional
    segments while manually creating the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shader is converted into intermediate code to support the program to run
    on GPU. In the compiling stage, the shaders are converted. This is the reason
    why shaders need to be recompiled before the program execution.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with `GLSurfaceView` of the `android.opengl` package in our example.
  prefs: []
  type: TYPE_NORMAL
- en: For 3D games, an Android developer can use this package to play with shaders
    on the Android SDK. This package provides the API to create and use an OpenGL
    shader with Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `GLSurfaceView` instead of the normal Android `View` or `SurfaceView`.
    The implementation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a renderer for the view to draw objects through OpenGL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The vertex shader code (`String vs_SolidColor`) has two parameters that it needs.
    The `uMVPMatrix` parameter is of the type `mat4`, which holds in the transformation
    matrix that can be used to translate the position. The `uMVPMatrix` parameter
    is a uniform matrix. The `vPosition` parameter is of type `vec4`, which holds
    the positions of vertex.
  prefs: []
  type: TYPE_NORMAL
- en: This system can be applied for a triangular surface.
  prefs: []
  type: TYPE_NORMAL
- en: Use of shaders in games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaders are vastly used in games and animation, especially when creating dynamic
    lighting, changing tints, and making dynamic visual improvements. Sometimes, the
    world environment is created with shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 2D game space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only pixel shaders can be used in 2D games. Each pixel of a digital image is
    considered a fragment. This is the reason why pixel shaders are also called fragment
    shaders. Pixel shaders can only perform color changes, tiling, and masking.
  prefs: []
  type: TYPE_NORMAL
- en: '`BitmapShader`, `ComposeShader`, `LinearGradient`, `RadialGradient`, and `SweepGradient`
    are the variants of Android 2D shaders.'
  prefs: []
  type: TYPE_NORMAL
- en: A 2D game world is created with images. Developers often choose to create different
    assets to give the same object a different look and feel. In this process, developers
    end up making a bigger APK with almost the same use set.
  prefs: []
  type: TYPE_NORMAL
- en: Sprites can also be a field where shaders can hold a significant role. When
    using the same sprite to create different objects, the colors of certain fragments
    need to change dynamically. Pixel shaders can be very useful here.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 2D space are used to change color, blur segments, change brightness,
    change opacity, tint images, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 3D game space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common use of shaders in 3D games is for dynamic shadow. In modern
    game development, a shadow is an inevitable element to improve the game experience.
    3D models look real after applying a texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, a 3D shader is applied through OpenGL. We have already discussed
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A raw model with only vertex information
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple model without any lightening or shaders. Let''s apply some
    shaders to give it a solid 3D look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A simple flat shader applied
  prefs: []
  type: TYPE_NORMAL
- en: Now, the developer can apply any texture or color to give it a different feel.
    In this part, the developer can choose to restrict this with color or texture.
    Generally, textures are used in this kind of scenarios in order to make the model
    visually real. However, this costs more than just color manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a color and lighting change here to get a completely different feel
    of the same object. There are different procedures to handle different scenario
    requirements for the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example, however, is just a visual representation of how shaders can manipulate
    3D models for a different look and feel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shaders and game performance
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are usually process-heavy. A fragment shader processes each fragment
    of a texture and manipulates its data. A large texture may lead to a visible delay
    in the game loop.
  prefs: []
  type: TYPE_NORMAL
- en: We can see shaders from different perspectives to create an idea of performance.
    Large textures decrease performance, and many small textures also affect performance.
    There has to be a balance between them to have a feasible real-time use of shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Creating shadows is one of the extensive uses of shaders. However, the quality
    of shadow processing is inversely proportionate to performance. In high-quality
    games, we can experience real-time shadow. Shaders map the object vertices and
    process it according to the light direction. It is then projected on the *X-Z*
    plane to create shadow. Shadows are merged with objects on the plane and with
    other shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can be used to improve world visibility with different lights, materials,
    and colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using shaders in games:'
  prefs: []
  type: TYPE_NORMAL
- en: Complete flexibility when rendering assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer asset packages and increased reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic visual effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic lighting and shadow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite manipulation on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few disadvantages of using shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparatively low frame rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance drop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required supported hardware platforms and graphic drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In spite of the few disadvantages, shaders have proved enough to be an intrinsic
    part of game development. Any performance drop is handled by upgrading the hardware
    and graphic drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, shaders are being optimized for embedded devices with limited resources.
    This even opens up the chance to increase the use of shaders on almost every platform,
    without affecting the performance significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Android API level 15, the framework supports OpenGL ES 2.0\. This gave
    immense flexibility to graphic programmers to implement shaders in Android games.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every hardware configuration supports shaders to run on GPU. However,
    the scale of using shaders determines the performance. In modern day, this is
    not actually an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are being used widely in games. In every aspect of graphical programming,
    shaders have already proven their place. All the famous and successful game developers
    have acknowledged the importance of shaders. Graphic artists need not worry about
    everything visual in the game, which reduces the development time significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are, therefore, widely used in games. Newer shaders are coming up with
    additional features now. The upgrading cycle of shaders has become less. However,
    hardware is also being upgraded with newer technology to support the graphical
    updates.
  prefs: []
  type: TYPE_NORMAL
- en: It feels like magic to see a simple cube turn into anything that has the same
    orientation. This magic will keep happening on a larger scale in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Just developing a game is not enough. Shaders help a lot in reducing memory
    usage, but they increase processing overhead. We will try to explore various optimization
    techniques of storage and processing in the next chapter.
  prefs: []
  type: TYPE_NORMAL
