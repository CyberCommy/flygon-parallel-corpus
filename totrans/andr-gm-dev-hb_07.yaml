- en: Chapter 7. Working with Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game's success depends largely on its look and feel. This directly means
    that the game must have an eye-catching graphical display. It is not always possible
    to provide maximum quality graphical assets due to space and heap restrictions.
    So, there has to be a way to create or improvise the graphical assets at runtime
    for display. This necessity gave birth to the concept of shaders.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can operate on any visual element and can tweak every pixel of drawable
    elements before rendering. Mostly, shaders are optimized for a specific graphics
    processor. However, nowadays, shaders can be written to support multiple processors
    on multiple platforms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Android accommodates the option to work with shaders in the Android framework
    itself. Additionally, OpenGL shaders can also be used and customized with the
    help of the Android NDK. There are many occasions where exquisite graphical quality
    is delivered with the help of shaders without excellent raw art assets.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a discussion about shaders in this chapter from the point of view
    of Android game development through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to shaders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How shaders work
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of shaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android library shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom shader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders through OpenGL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of shaders in games
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders and game performance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to shaders
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers develop games on Android, but do not possess much knowledge
    about shaders. In most cases, developers do not need to work with shaders, or
    there are some pre-defined shaders inside the game development framework or engines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In 1988, the animation studio Pixar introduced the modern concept of shaders.
    However, GPUs were not capable of handling shaders at that point of time. OpenGL
    and Direct3D are the first two graphic libraries to support shaders. GPU started
    supporting shaders through pixel shading at the 2D level. Soon, it was enhanced
    to support vertex shaders. Nowadays, geometry shaders are also supported by OpenGL
    3.2 and Direct3D 10 libraries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Let's now dive a bit deeper into shaders to understand their definition, necessity,
    and scope for Android games.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: What is a shader?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In simple words, a shader is an instruction set to manipulate the visual display
    of the input graphic assets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Let's elaborate the definition a bit. All the instructions are basically done
    through programming. That's the reason the concept of a shader exists only in
    computer graphics. Shaders are able to perform a computation based on the instruction
    and input asset to produce more efficient output-displayable assets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical shaders can process either a vertex or a pixel. Pixel shaders can compute
    on the color, depth, and alpha properties of an asset. Vertex shaders can compute
    the position, color, co-ordinates, depth, illuminations, and so on of a vertex.
    Thus, shaders can be primarily divided into two categories depending on the operational
    base type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 2D shaders
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D shaders
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Necessity of shaders
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the normal practice of game development, Android developers do not bother
    about shaders. But the necessity of shaders is inevitable. Initially, for small-scale
    games, art assets are used without improvement. Any modification to the assets
    is managed by the old process of updating the art asset itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can minimize this extra time-consuming effort. The same asset can be
    manipulated to create different objects on screen. For example, you can blur out
    the object as it goes out of focus, change the color of the sprites during gameplay
    to indicate different teams or players, create masks of art assets, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders have the following benefits:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When different shaders are applied to the same art asset, it produces different
    assets, depending on your requirements at runtime. Thus, the shader can save extra
    art-creation time.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-time integration of drawable objects in the game can lead to a different
    visual experience through different shaders.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the art assets are minimized, using shaders can reduce the game build size.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be more visual difference with the same set of assets.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation can be created by shaders with simple art by manipulating the visual
    content repeatedly.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders are useful for creating visual effects during runtime.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, using shaders may lead to some negative consequences:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Using shaders will increase the processing time due to the manipulation of the
    visual assets during runtime
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unoptimized use of shaders may lead to more heap memory consumption as various
    intermediate instances will be stored in it
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, shaders are responsible for the distortion of objects while processing
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Art assets become vulnerable to quality loss using shaders
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the first two are actual direct consequences of using shaders. The rest
    of the problems can occur only if the developer uses a badly written shader or
    faulty shader. Therefore, it is extremely necessary to choose the perfect shader
    for a specific task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the shader process takes a long time, resulting in poor FPS output.
    A few old GPUs do not support all kinds of shaders. Therefore, the developer should
    check and confirm the hardware platform on which the shader is to perform.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Scope of shaders
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shaders can be used in a variety of sectors related to computer graphics, such
    as image processing, photography, digital animation, video/computer/digital games,
    and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The gaming sector is one of the largest communities that uses shaders. The Android
    platform is no exception. Android game developers use shaders on a large scale
    in both 3D and 2D games.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Frankly speaking, 2D games do not have much scope for shaders. Only a pixel
    shader can manipulate the color, opacity, saturation, and hue of a pixel. This
    is useful when the same raw assets are used for different visibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: For example, a 2D cricket game has many teams with different outfits to distinguish
    between them. The developer creates all the sprite animation assets in one design
    and applies shaders to manipulate color differently for different teams. Thus,
    the output sprites have different visibility and are recognized easily by the
    player.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: How shaders work
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed that shaders process either vertices or pixels. So,
    the basic working principle is to change or manipulate data at runtime:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![How shaders work](img/B05069_07_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: A shader process is a specific set of instructions to process vertices or fragments.
    Different shader programs can be written for various types of processing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A vertex shader is used to change the shape of the model; it can also change
    the surface-formation system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Pixel/fragment shaders can change the pixel color value along with opacity.
    Pixel data can be merged, modified, or replaced by a shader program to form a
    new digital image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Types of shaders
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many shaders used in the gaming industry. They are categorized on
    the basis of their behavior and features. Some of the shaders are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Pixel shaders
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertex shaders
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geometry shaders
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tessellation shaders
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a detailed look at these types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Pixel shaders
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pixel shaders are 2D shaders that work on textures or digital images. Pixel
    shaders process colors and other attributes of a single pixel. Each single pixel
    is called a fragment. This is the reason pixel shaders are often called fragment
    shaders.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Vertex shaders
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A vertex shader mainly operates on the vertices of a mesh or model. Every mesh
    of a model is made up of multiple vertices. A vertex shader can only be applied
    to 3D models. So, a vertex shader is a type of 3D shader.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Geometry shaders
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Geometry shaders are used to create new primitive graphic elements. After applying
    a vertex shader in order to execute a rendering pipeline, geometry shaders are
    used to create points, lines, and triangles to form a surface.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Tessellation shaders
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a typical 3D shader used to simplify and improve 3D mesh during tessellation.
    It is subdivided into two shaders:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Hull shaders or tessellation control shaders
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain shaders or tessellation evolution shaders
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two shaders are used together to reduce mesh bandwidth.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Tessellation shaders have the power to improve 3D models in such a way that
    the drawable vertex count is reduced significantly. Thus, rendering becomes faster.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Android library shaders
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android provides the shader option in its framework in the `android.graphics`
    package. A few well-known and widely used shaders are also in the Android library.
    Some of them are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`BitmapShader`: This can be used to draw a bitmap in the texture format. It
    also supports tiling or mirroring of the bitmap. It is very useful for creating
    terrain with tiling.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComposeShader`: This is used to merge two shaders. So, it is very useful for
    masking or merging colors for two different shaders.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearGradient`: This is used to create a gradient along with the given line
    segment with a defined color set.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadialGradient`: This is used to create a gradient along with the given circle
    segment with a defined color set. A radial origin and radius are provided to create
    the gradient.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SweepGradient`: This is used to create a sweep gradient color around a point
    with the given radius.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is what it looks like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Android library shaders](img/B05069_07_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: These options are really good for creating different objects with different
    styles of the same primitive object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom shaders
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A developer has the option to write a customized shader as per their requirements.
    Android provides the `android.graphics.Shader` class. It is easy to create your
    own shader class using the primitive shaders provided.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom shader may not include only one shader. It can be a combination
    of various shaders. For example, consider masking an image with a circular view
    port with a motion-touch event:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This example is one of the most commonly used shader styles in picture-based
    games. You can also implement such shaders to create hidden object games.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is highlighting a specific object on the screen. The same viewable
    circle can be used to show only the highlighted object. In this case, color can
    be semitransparent to show a dull background.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Shaders through OpenGL
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, OpenGL supports implementing shaders for Android 3D games. OpenGL
    ES 2.0 is the supporting platform in Android for shaders. It has two functional
    segments while manually creating the shader:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Shader
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shader is converted into intermediate code to support the program to run
    on GPU. In the compiling stage, the shaders are converted. This is the reason
    why shaders need to be recompiled before the program execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We will work with `GLSurfaceView` of the `android.opengl` package in our example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: For 3D games, an Android developer can use this package to play with shaders
    on the Android SDK. This package provides the API to create and use an OpenGL
    shader with Java.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use `GLSurfaceView` instead of the normal Android `View` or `SurfaceView`.
    The implementation will look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to create a renderer for the view to draw objects through OpenGL:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The vertex shader code (`String vs_SolidColor`) has two parameters that it needs.
    The `uMVPMatrix` parameter is of the type `mat4`, which holds in the transformation
    matrix that can be used to translate the position. The `uMVPMatrix` parameter
    is a uniform matrix. The `vPosition` parameter is of type `vec4`, which holds
    the positions of vertex.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: This system can be applied for a triangular surface.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Use of shaders in games
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaders are vastly used in games and animation, especially when creating dynamic
    lighting, changing tints, and making dynamic visual improvements. Sometimes, the
    world environment is created with shaders.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 2D game space
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only pixel shaders can be used in 2D games. Each pixel of a digital image is
    considered a fragment. This is the reason why pixel shaders are also called fragment
    shaders. Pixel shaders can only perform color changes, tiling, and masking.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`BitmapShader`, `ComposeShader`, `LinearGradient`, `RadialGradient`, and `SweepGradient`
    are the variants of Android 2D shaders.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A 2D game world is created with images. Developers often choose to create different
    assets to give the same object a different look and feel. In this process, developers
    end up making a bigger APK with almost the same use set.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Sprites can also be a field where shaders can hold a significant role. When
    using the same sprite to create different objects, the colors of certain fragments
    need to change dynamically. Pixel shaders can be very useful here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 2D space are used to change color, blur segments, change brightness,
    change opacity, tint images, and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in a 3D game space
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common use of shaders in 3D games is for dynamic shadow. In modern
    game development, a shadow is an inevitable element to improve the game experience.
    3D models look real after applying a texture.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, a 3D shader is applied through OpenGL. We have already discussed
    an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: A raw model with only vertex information
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple model without any lightening or shaders. Let''s apply some
    shaders to give it a solid 3D look:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: A simple flat shader applied
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Now, the developer can apply any texture or color to give it a different feel.
    In this part, the developer can choose to restrict this with color or texture.
    Generally, textures are used in this kind of scenarios in order to make the model
    visually real. However, this costs more than just color manipulation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We will see a color and lighting change here to get a completely different feel
    of the same object. There are different procedures to handle different scenario
    requirements for the game.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This example, however, is just a visual representation of how shaders can manipulate
    3D models for a different look and feel:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Shaders in a 3D game space](img/B05069_07_05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Shaders and game performance
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Shaders are usually process-heavy. A fragment shader processes each fragment
    of a texture and manipulates its data. A large texture may lead to a visible delay
    in the game loop.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We can see shaders from different perspectives to create an idea of performance.
    Large textures decrease performance, and many small textures also affect performance.
    There has to be a balance between them to have a feasible real-time use of shaders.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Creating shadows is one of the extensive uses of shaders. However, the quality
    of shadow processing is inversely proportionate to performance. In high-quality
    games, we can experience real-time shadow. Shaders map the object vertices and
    process it according to the light direction. It is then projected on the *X-Z*
    plane to create shadow. Shadows are merged with objects on the plane and with
    other shadows.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Shaders can be used to improve world visibility with different lights, materials,
    and colors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros of using shaders in games:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Complete flexibility when rendering assets
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer asset packages and increased reusability
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic visual effects
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic lighting and shadow
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sprite manipulation on the fly
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are few disadvantages of using shaders:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Comparatively low frame rate
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance drop
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required supported hardware platforms and graphic drivers
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In spite of the few disadvantages, shaders have proved enough to be an intrinsic
    part of game development. Any performance drop is handled by upgrading the hardware
    and graphic drivers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, shaders are being optimized for embedded devices with limited resources.
    This even opens up the chance to increase the use of shaders on almost every platform,
    without affecting the performance significantly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Android API level 15, the framework supports OpenGL ES 2.0\. This gave
    immense flexibility to graphic programmers to implement shaders in Android games.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android API级别15起，框架支持OpenGL ES 2.0。这为图形程序员在Android游戏中实现着色器提供了巨大的灵活性。
- en: Almost every hardware configuration supports shaders to run on GPU. However,
    the scale of using shaders determines the performance. In modern day, this is
    not actually an issue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种硬件配置都支持着色器在GPU上运行。然而，使用着色器的规模决定了性能。在现代，这实际上并不是一个问题。
- en: Shaders are being used widely in games. In every aspect of graphical programming,
    shaders have already proven their place. All the famous and successful game developers
    have acknowledged the importance of shaders. Graphic artists need not worry about
    everything visual in the game, which reduces the development time significantly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器在游戏中被广泛使用。在图形编程的各个方面，着色器已经证明了它们的重要性。所有著名和成功的游戏开发者都承认了着色器的重要性。图形艺术家不需要担心游戏中的所有视觉内容，这显著减少了开发时间。
- en: Shaders are, therefore, widely used in games. Newer shaders are coming up with
    additional features now. The upgrading cycle of shaders has become less. However,
    hardware is also being upgraded with newer technology to support the graphical
    updates.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，着色器在游戏中被广泛使用。新的着色器现在带有额外的功能。着色器的升级周期已经减少。然而，硬件也在升级，以支持图形更新的新技术。
- en: It feels like magic to see a simple cube turn into anything that has the same
    orientation. This magic will keep happening on a larger scale in the future.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一个简单的立方体变成具有相同方向的任何东西，感觉就像魔术。这种魔术将在未来更大规模地持续发生。
- en: Just developing a game is not enough. Shaders help a lot in reducing memory
    usage, but they increase processing overhead. We will try to explore various optimization
    techniques of storage and processing in the next chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一款游戏并不足够。着色器在减少内存使用方面有很大帮助，但它们会增加处理开销。我们将在下一章尝试探索各种存储和处理的优化技术。
