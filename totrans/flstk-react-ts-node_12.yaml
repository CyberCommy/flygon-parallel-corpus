- en: '*Chapter 9*: What is GraphQL?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about GraphQL, one of the hottest web technologies
    currently being used. Many large companies have adopted GraphQL for their APIs,
    including companies such as Facebook, Twitter, New York Times, and GitHub. We'll
    learn what makes GraphQL so popular, how it works internally, and how we can take
    advantage of its features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GraphQL schemas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding typedefs and resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding queries, mutations, and subscriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development using Node. We will
    once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap9` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the `Chap9` code folder, go to your `HandsOnTypescript` folder and
    create a new folder called `Chap9`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore what GraphQL is, why it was created, and what
    problems it attempts to solve. It is important to understand the underlying reasons
    for GraphQL's existence as it will help us design better web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is GraphQL? Let''s list some of its main characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphQL is a data schema standard developed by Facebook.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL provides a standard language for defining data, data types, and related
    data queries. You can think of GraphQL as roughly analogous to an interface that
    provides a contract. There's no code there, but you can still see what types and
    queries are available.
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphQL works across platforms, frameworks, and languages.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we create an API using GraphQL, the same GraphQL language will be used
    to describe our data, its types, and queries no matter what programming language
    or operating system we use. Having a consistent and reliable representation of
    data across a wide variety of systems and platforms is, of course, a good thing
    for clients and systems. But it's also beneficial to programmers, since we can
    continue to use our normal programming language and frameworks of choice.
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphQL returns control for what is queried to the caller.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a standard web service, it is the server that controls what fields of the
    data will be returned. However, in a GraphQL API, it is the client that determines
    which fields they would like to receive. This gives clients better control and
    reduces bandwidth usage and cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, there are two main uses of a GraphQL endpoint. One is as
    a gateway to consolidate other data services, and the other is as the main web
    API service that directly receives data from a datastore and provides it to clients.
    Here''s a diagram of GraphQL being used as a gateway for other data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – GraphQL as a gateway'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – GraphQL as a gateway
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, GraphQL is acting as the single source of truth for all clients.
    It works well in this capacity due to its standards-based language that is supported
    across a wide variety of systems.
  prefs: []
  type: TYPE_NORMAL
- en: For our own application, we will use it as our entire web API, but it is possible
    to mix it in with existing web services so that GraphQL handles only a part of
    the service calls being made. This means you do not need to rewrite your entire
    application. You can introduce GraphQL slowly and deliberately where it makes
    sense to do so, without disrupting your current application services.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a look at GraphQL at a conceptual level. GraphQL has
    its own data language, meaning it can be used regardless of server framework,
    application programming language, or operating system. This flexibility allows
    GraphQL to be a powerful means of sharing data throughout an organization or even
    across the web. In the next section, we will explore the GraphQL schema language
    and see how it works. It will help us structure our data models and understand
    how to set up our GraphQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GraphQL schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated, GraphQL is a language used to provide structure and type information
    to our entity data. Regardless of which vendor's implementation of GraphQL is
    used on the server, our client can expect the same data structures to be returned.
    This ability to abstract away the implementation details of servers to clients
    is one of the strengths of GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple GraphQL schema and see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chap9` folder, create a new folder called `graphql-schema`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your terminal in that folder and then run this command, accepting the
    defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now install these packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize TypeScript with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new TypeScript file called `typeDefs.ts` and add this to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This import gets the `gql` object, which allows syntax formatting and highlighting
    of the GraphQL schema language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The language is fairly simple and looks a lot like TypeScript. Starting from
    the top, first we have a `User` entity, as indicated by the `type` keyword. `type`
    is a GraphQL keyword that indicates that an object of a certain structure is being
    declared. As you can see, the `User` type has multiple fields. The `id` field
    is of type `ID!`. The `ID` type is a built-in type that indicates a unique value,
    basically a GUID of some kind. The exclamation mark indicates that the field cannot
    be `null`, whereas no exclamation mark would indicate that it can be `null`. Next,
    we see the `username` field and its type of `String!`, which of course means it
    is a non-nullable string type. Then, we have the `description` field, but it has
    a `String` type without an exclamation mark, so it is nullable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Todos` type has similar fields, but notice the `Query` type. This shows
    that even queries are types in GraphQL. So, if you look at the two queries, `getUser`
    and `getTodos`, you can see why we created the `User` and `Todos` types, as they
    become the return values for our two `Query` methods. Also notice that the `getTodos`
    function returns an array of non-nullable `Todos`, which is indicated by the brackets.
    Finally, we export our type definitions using the `typeDefs` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Type definitions are used by Apollo GraphQL to describe the schema types in
    a schema file. Before your server can start providing any GraphQL data, it must
    first have a complete schema file that lists *all* of your application's types,
    their fields, and queries that will be served in its API.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that GraphQL has several default scalar types that
    are built into the language. These are `Int`, `Float`, `String`, `Boolean`, and
    `ID`. As you noticed in the schema file, we did not have to create a type notation
    for these types.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed what a simple GraphQL schema file looks like. We
    will be using this syntax as we build out our API. In the next section, we will
    dive deeper into the GraphQL language and also learn what resolvers are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Typedefs and Resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will further explore GraphQL schemas, but we will also implement
    resolvers, which are the functions that do the actual work. This section will
    also introduce us to Apollo GraphQL and how to create a GraphQL server instance.
  prefs: []
  type: TYPE_NORMAL
- en: What are resolvers? Resolvers are the functions that get or edit the data from
    our datastore. This data is then matched with the GraphQL type definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see what the role of resolvers is in more depth, we need to continue
    building out our previous project. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the dependency UUID. This tool will allow us to create a unique ID
    for our `ID` types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `server.ts`, which will start our server, with this
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we import dependencies needed to set up our server. We already created
    the `typeDefs` file and we will soon create the `resolvers` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we create our Express server `app` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`makeExecutableSchema` builds a programmatic schema from the combination of
    our `typeDefs` file and our `resolvers` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create an instance of our GraphQL server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`context` is made up of the request and response objects of Express. Then,
    we add our middleware, which for GraphQL is our Express server object called `app`.
    The `cors` option indicates to disable GraphQL from acting as our CORS server.
    We''ll discuss CORS in later chapters as we build out our app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we are now starting up our Express server by listening on port
    `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `listen` handler just logs a message to announce it has started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create our resolvers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `resolvers.ts` file and add this code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using TypeScript, we want to use types to represent our returned
    objects, and that''s what `User` and `Todo` represent. These types will be matched
    by GraphQL to the GraphQL types of the same name we had created in our `typeDefs.ts`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here is our first resolver function, matching the `getUser` query. Notice that
    the parameter is more than just the `id` parameter. This is coming from the Apollo
    GraphQL server and adds additional information for our call. (Note that to save
    time, I am hardcoding a `User` object.) Also, we will create the `GqlContext`
    type later, but basically, it is a container that holds our request and response
    objects that we learned about in [*Chapter 8*](B15508_08_Final_JC_ePub.xhtml#_idTextAnchor122)*,
    Learning Server-Side Development with Node.js and Express*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to `getUser`, our `getTodos` resolver receives similar parameters
    and also returns a hardcoded set of `Todo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we export the `resolvers` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our actual data getters are just normal TypeScript code. If
    we had used Java or C# or any other language, the resolvers would simply be **Create
    Read Update Delete** (**CRUD**) operations in those languages as well. The GraphQL
    server, then, is just translating the data entity models into the types in our
    type definition schema file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create our `GqlContext` type. Create a file called `GqlContext.ts`
    and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is just a simple shell interface that allows us to provide type safety
    to our context in our GraphQL resolver calls. As you can see, this type contains
    the Express `Request` and `Response` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we need to compile our code to JavaScript since we are using TypeScript.
    Run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run our new code; enter this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you go to the URL `http://localhost:` `8000/graphql`, you should see the
    GraphQL Playground screen. This is a query testing page provided by Apollo GraphQL
    that allows us to manually test our queries. It looks like this:![Figure 9.2 –
    The GraphQL dev client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – The GraphQL dev client
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I have already run one of the queries, which looks like JSON and
    is on the left, and the result is shown, which is also JSON and on the right.
    If you look at our query on the left, I am explicitly asking for only the `id`
    field, which is why only the `id` field is returned. Notice that the standard
    result format is `data > <function name> > <fields>`. Try running the `getTodos`
    query as a test.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is the **DOCS** tab, which shows all the available queries,
    mutations, and subscriptions (we will go over these in the next section). It looks
    like this:![Figure 9.3 – The DOCS tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The DOCS tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the **SCHEMA** tab shows the schema type information of all our entities
    and queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The SCHEMA tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – The SCHEMA tab
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it looks identical to our `typeDefs.ts` file.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a look at resolvers by running a small GraphQL server.
    Resolvers are the other half that makes GraphQL actually function. We also saw
    how relatively easy it is to get a small GraphQL server running by using the Apollo
    GraphQL library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve more deeply into queries by looking at mutations
    and subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding queries, mutations, and subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating a GraphQL API, we want to do more than just get data: we may
    also want to write to a datastore or be notified when some data changes. In this
    section, we''ll see how to do both actions in GraphQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to write data using mutations first:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a mutation called `addTodo`, but in order to make the mutation
    more realistic, we will need a temporary datastore. So, we will create an in-memory
    datastore for testing purposes. Create the `db.ts` file and add this code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have just added `Todos` from our previous list into an array that we are
    exporting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to update our `typeDefs.ts` file to include our new mutation. Update
    it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to add our `addTodo` resolver. Add this code to your `resolvers.ts`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a new container object called `Mutation`, and inside
    of it is our `addTodo` mutation. It has similar parameters to the queries, but
    this mutation will add a new `Todo` to the `todos` array. If we run this code
    in the playground, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The GraphQL playground for the addTodo mutation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The GraphQL playground for the addTodo mutation
  prefs: []
  type: TYPE_NORMAL
- en: When our query is of type Query, we can leave out the query prefix. However,
    since this is a mutation, we must include it. As you can see, we only get back
    `id` and `title`, because that is all we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at subscriptions, which are a way of being notified
    when certain data changes. Let''s get notified when our `addTodo` adds a new `Todo`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add an object of type `PubSub` from the `apollo-server-express`
    library into the GraphQL server `context`. This object is what allows us to both
    subscribe (ask to be notified when changes occur) and publish (send a notification
    when changes occur). Update the `server.ts` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `pubsub` object, based on the `PubSub` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we add the `pubsub` object to the GraphQL server''s `context` so that it
    can be used from our resolvers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `httpServer` instance from Node directly and then use the `installSubscription
    Handlers` function on it. Then, when we call `listen`, we are now calling `listen`
    on the `httpServer` object and *not* the `app` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s update our `typeDefs.ts` file to add our new mutation. Just add
    this type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update our `resolvers.ts` file with our new subscription resolver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'const resolvers: IResolvers = {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'getUser: async ('
  prefs: []
  type: TYPE_NORMAL
- en: 'parent: any,'
  prefs: []
  type: TYPE_NORMAL
- en: 'args: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'ctx: GqlContext,'
  prefs: []
  type: TYPE_NORMAL
- en: 'info: any'
  prefs: []
  type: TYPE_NORMAL
- en: '): Promise<User> => {'
  prefs: []
  type: TYPE_NORMAL
- en: return {
  prefs: []
  type: TYPE_NORMAL
- en: 'id: v4(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'username: "dave",'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'getTodos: async ('
  prefs: []
  type: TYPE_NORMAL
- en: 'parent: any,'
  prefs: []
  type: TYPE_NORMAL
- en: 'args: null,'
  prefs: []
  type: TYPE_NORMAL
- en: 'ctx: GqlContext,'
  prefs: []
  type: TYPE_NORMAL
- en: 'info: any'
  prefs: []
  type: TYPE_NORMAL
- en: '): Promise<Array<Todo>> => {'
  prefs: []
  type: TYPE_NORMAL
- en: return [
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: v4(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'title: "First todo",'
  prefs: []
  type: TYPE_NORMAL
- en: 'description: "First todo description",'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: v4(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'title: "Second todo",'
  prefs: []
  type: TYPE_NORMAL
- en: 'description: "Second todo description",'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'id: v4(),'
  prefs: []
  type: TYPE_NORMAL
- en: 'title: "Third todo",'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '];'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Mutation: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'addTodo: async ('
  prefs: []
  type: TYPE_NORMAL
- en: 'parent: any,'
  prefs: []
  type: TYPE_NORMAL
- en: 'args: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'title: string;'
  prefs: []
  type: TYPE_NORMAL
- en: 'description: string;'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'ctx object, we have deconstructed it to just use the pubsub object, as it''s
    the only one we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: return todos[todos.length - 1];
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscription: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'Todo adds. Notice that our subscription newTodo is not a function. It''s an
    object with a member called subscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The rest is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try testing this. First, make sure you have compiled your code with
    `tsc`, started your server, and refreshed the playground. Then, open a new tab
    in the playground, enter this subscription, and click the play button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The newTodo subscription'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – The newTodo subscription
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click the play button, nothing happens, because a new `Todo` has not
    been added yet. So, let''s go back to our `addTodo` tab and add a new `Todo`.
    Once you''ve done that, come back to the `newTodo` tab and you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The newTodo subscription result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – The newTodo subscription result
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, that works, and we get the newly added `Todo`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about GraphQL queries, mutations, and subscriptions.
    We will be using these to build out our application API. Because GraphQL is an
    industry standard, all GraphQL client frameworks can work with any vendor's GraphQL
    server framework. Furthermore, clients using a GraphQL API can expect consistent
    behavior and the same query language regardless of server or vendor. This is the
    power of GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the power and capabilities of GraphQL, one of the
    hottest new technologies for creating web APIs. GraphQL is an extremely capable
    technology, but also, because it is an industry standard, we can always expect
    consistent behavior across servers, frameworks, and languages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start bringing together the technologies we've
    learned about thus far and create an Express server using TypeScript, GraphQL,
    and helper libraries.
  prefs: []
  type: TYPE_NORMAL
