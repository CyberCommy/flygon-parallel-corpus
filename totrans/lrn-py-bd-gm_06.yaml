- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is not only about writing programs—it's just as important to understand
    them so that we can fix the bugs and errors in them, if there are any. Thus, we
    say that programmers are born to read and understand code. However, as programs
    become more and more complicated, it becomes more difficult to write programs
    that maintain readability. We have written both aesthetic and messy code in this
    book. We made a tic-tac-toe game with sequential programming that had less readability.
    We can consider these programs as inelegant because we will have a hard time reading
    and understanding their code and sequential flow. After writing those programs,
    we modified them using functions, which upgraded our messy code so that it was
    more elegant. However, if you are working on programs containing thousands of
    lines of code, it's hard to write a program within the same file and understand
    each and every behavior of the functions you're using. Thus, discovering and fixing
    the bugs of programs  written in a procedural manner is also difficult. Due to
    this, we need a way in which we can easily break multi-line programs into smaller
    modules or parts so that discovering and fixing these bugs is easier. There are
    many ways of achieving this, but the most efficient and popular way is using the
    **object-oriented programming** (**OOP**) approach.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we have been using objects since the beginning of this book,
    but haven't understood how precisely they are made and used. This chapter will
    help you to learn about the terminology and concepts of object-oriented programming
    through some simple examples. We will also modify our Snake game code that we
    wrote using functions in the preceding chapters in line with the OOP approach
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snake game implementation using OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible errors and modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will require the following in order to get the most out of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Python version 3.5 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python IDLE (Python's inbuilt IDE)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter06)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oKD6D2](http://bit.ly/2oKD6D2)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Everything in Python is an object*. We have been eloquently stating this remark
    from the beginning of this book and we have been proving this statement in every
    chapter. Everything is an object. Objects can be a collection of elements, properties,
    or functions. Data structures, variables, numbers, and functions are objects.
    OOP is a programming paradigm that provides an elegant way of structuring programs
    with the help of objects. The behavior and properties of the objects are bundled
    together into templates, which we call a class. That behavior and their properties
    can be called from the different objects of that class. Don''t get confused by
    the terms behavior and properties. They are just different names for methods and
    variables, respectively. Functions that are defined inside some classes are referred
    to as methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We will dig into the concepts of classes and methods later in this chapter,
    but for now, let's learn more about objects before actually making a template
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been using objects unknowingly from the beginning of this book. We
    have used methods from different classes before, such as the `randint()` method.
    This method was used by importing a module named `random`. This method is also
    a built-in Python class. A class is a template where we can write functions of
    objects. For example, a man can be represented as an object. A man has different
    characteristics, such as a `name`, `age`, and `hair_color`, which are unique properties.
    However, the actions that the man performs, such as eating, walking, and sleeping,
    are behaviors or methods. We can make as many objects as we like from these templates.
    But for now, let''s visualize two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding two objects, `name`, `age`, and `hair_color` are unique. All
    of the objects will have unique properties, but the behavior or method that they
    perform is the same as eating, walking, and sleeping. Thus, we can conclude that
    the data model that interacts with the input and output is a property since it
    will be fed into the methods. Based on the unique properties of each object, the
    methods of the classes will produce different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we can say that OOP is the approach of modeling real-world entities as
    objects that have unique data associated with them and can execute certain functions.
    Functions that are defined inside classes are called methods, and so we just have
    to switch from functions to methods. Note, however, that the way methods work
    is similar to that of functions. Just like functions are called with the names
    or signs of it, methods also need to be called with their names. However, this
    call should be initiated with objects. Let''s look at a simple example to clarify
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We looked at these methods in the preceding chapters. But if you take a good
    look at this code, you will find that we are making a method call from the object.
    We used the `pop` method and called it on the list-objects. This is a simple prototype
    of object-oriented programming. One of the advantages of OOP is that it hides
    the inner complexity of the method call. As you may recall, we called the `randint`
    method with the random module. We didn't even look at the content of the random
    library. Thus, we obviate the working complexities of the library. This feature
    of OOP will allow us to focus only on the important parts of the program rather
    than the internal working of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: The two main entities of object-oriented programming are objects and classes.
    We can remember a class by emulating it with templates where methods and attributes
    are mapped. Methods are a synonym for functions, while attributes are the properties
    that distinguish each object from another. Let's get a good grasp of this terminology
    by making a simple class and object.
  prefs: []
  type: TYPE_NORMAL
- en: Python classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the previous section, objects inherit all the code that''s
    written inside the classes. Thus, we can use methods and attributes that are mapped
    inside the body of class. A class is a template from which instances can be created.
    Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f96c5006-9dd8-4944-b0c4-3c0a5dfd2257.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding, the `Bike` class can be considered a template from which
    objects can be instantiated. In the `Bike` class, there are attributes that uniquely
    represent objects that are created from this class. Each object that is created
    will have different properties, such as name, color, and price, but they will
    invoke the same methods. This method should be invoked with the instance of the
    class. Let''s see how classes can be created in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a class in Python with a class keyword, followed by the name of the
    class. Usually, the first letter of the class name is written in uppercase; here
    we have written `Bike`, with a capital B. Now globally, we have created the `Bike`
    class. Instead of methods and attributes, we have written a pass inside the body
    of the class. Now, let''s make the object of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we made an instance named `Suzuki` from the `Bike` class.
    The instantiation expression looks similar to the function call. Now, if you check
    the type of the `Suzuki` object, it is a type of the `Bike` class. Thus, the type
    of any object will be the class type because objects are an instance of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to add a couple of methods to this `Bike` class. This is similar
    to the declaration of the function. The `def` keyword, followed by the names of
    the methods, is the best way to declare the methods of a class. Let''s take a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have added three methods to the `Bike` class. The parameter that we used
    while declaring these methods was the `self` variable. This `self` variable or
    keyword is also an instance of the class. You can compare this `self` variable
    with the pointer, which is pointing to the current object. At each instantiation,
    the `self` variable represents the pointer object that is pointing to the current
    class. We will clarify the usage and importance of the `self` keyword shortly,
    but before that, take a look at the preceding code, where we created a `Suzuki`
    object and called the methods of the class with it.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is similar to the code where we called the `randint` method
    from the random module. This is because we are using methods of the random library.
  prefs: []
  type: TYPE_NORMAL
- en: 'When any classes are defined, only the representation for the object is defined
    with it, which eventually reduces memory loss. In the preceding example, we made
    a prototype with the name `Bike`. Different instances can be made out of it, las
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve looked at how to create objects and use the methods that are
    defined inside the class, we will add attributes to the class. The attributes
    or properties define the unique features of each object. Let''s add some attributes,
    such as `name`, `color`, and `price`, to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of jargon in the preceding code. Under the hood, this program
    is about the creation of classes and objects. We have added three attributes:
    `name`, `color`, and `price`. To use those properties of the class, we have to
    reference them with the `self` keyword. The `name`, `color`, and `price` arguments
    are passed into the `info` function and are assigned to the corresponding `name`,
    `color`, and `price` properties of the `Bike` class. The `self.name, self.color,
    self.price = name,color,price` statement is going to initialize the class variables.
    This process is called initialization. We can also do initialization using a constructor,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In Python, the special `init` method is going to simulate the constructor. A
    constructor is a method or function that's used to initialize the attributes of
    the class. The definition of the constructor is executed when we make instances
    of the class. Depending on the `init` definition, we can provide any number of
    arguments while creating the objects of the class. The first method of the class
    should be a constructor, and it must initialize the members of the class. The
    basic format of the class should have an attribute declaration at the beginning
    and the methods after it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've created our own class and declared some methods of it let's explore
    some essential features of the object-oriented paradigm. We will start with **encapsulation**,
    which is used to embed the access permissions of the methods and variables that
    are declared within the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encapsulation is a way of binding data with the code into a single unit known
    as a capsule. This way, it provides security so that no unwanted modifications
    can be made to the code. The code that''s written with the object-oriented paradigm
    will have critical data in the form of attributes. Thus, we have to prevent that
    data from being corrupted or becoming vulnerable. This is known as data hiding,
    and is the prime feature of encapsulation. To prevent data from being modified
    accidentally, encapsulation plays a vital role. We can make members of the class
    private members in order to embrace encapsulation. Private members, either methods
    or properties, can be made using double underscores at the beginning of their
    signature. In the following example, `__updateTech` is a private method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we were unable to invoke the `updateTech` method
    from the object of the class. This is due to encapsulation. We made this method
    private using a double underscore at the beginning of it. But sometimes we may
    need to modify the value of these attributes or behaviors. We can modify this
    using getters and setters. These methods will get the value and set the value
    for the attributes of the class. Thus, we can conclude that encapsulation is a
    feature of OOP that will prevent us from modifying and accessing data accidentally,
    but not intentionally. The private members of the class are not actually hidden;
    instead, they are just made unique from other members so that the Python parser
    will interpret them uniquely. The `updateTech` method is made unique and private
    using a double underscore (`__`) at the beginning of its name. The attributes
    of the class can also be made private using the same technique. Let''s take a
    look at this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can clearly see that the `name` and `color` attributes are private as they
    begin with double underscores. Now, let''s try to modify those values using an
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We tried to modify the color attribute of the `Bike` class, but nothing happened.
    This shows us that encapsulation will prevent accidental changes from being made.
    But what if we need to change it intentionally? This can be done with getters
    and setters. Take a look at the following example to find out more about getters
    and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we defined a `Bike` class with some private members,
    such as `name` and `color`. We used the `init` constructor to initialize the values
    of the attributes while creating the instance of the class. We tried to modify
    its value. However, we couldn't change its value because the Python parser treats
    these attributes as private. Thus, we used the `setNewColor` setter to set a new
    value for that private member. By providing these getters and setter methods,
    we can make a class either read-only or write-only, which prevents accidental
    data modification and intentional theft.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to take a look at another important feature of the object-oriented
    paradigm known as inheritance. Inheritance helps us write classes that will inherit
    each and every member from its parent class and also allows us to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is the most important and well-known feature of the object-oriented
    programming paradigm. Do you remember the reusability feature of functions? Inheritance
    also provides reusability but with a lot of code. To use inheritance, we must
    have an existing class with some code inside it. This must be inherited by a new
    class. Such an existing class is called a **Parent** or **Base** class. We can
    create a new class as a `Child` class, which will acquire and access all the properties
    and methods of the parent class, so that we don't have to write the code from
    scratch. We can also modify the definitions and specifications of the methods
    that are inherited by the child class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following illustration, we can see that the **Child** class, or the **Derived**
    class, is pointing to the **Base** or **Parent** class, which implies that there
    is a single inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/49a3b5cc-20a5-4a22-935d-770befb3da2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, it is easy to use inheritance. A `Child` class can inherit from
    a `Parent` class by mentioning the name of the `Parent` class within the brackets
    after the `Child` class. The following code shows how we can implement single
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A single class can also inherit multiple classes. We can achieve this by writing
    all of those classes'' names within the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a simple example so that we can understand inheritance a little
    more. In the following example, `Bike` will be the `Parent` class and `Suzuki`
    will be the `Child` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's have a look at the preceding code and be amazed by inheritance. First,
    we created a `Base` class with two methods in it. After that, we created another
    class, that is, the child or derived class, called `Suzuki`. It is a child class
    because it has inherited the members of its parent `Bike` class with the `class
    Suzuki(Bike)` syntax. We added a couple of methods to the child class too. After
    creating these two classes, we created an object of the child class. We know that,
    when an object is created, the method that is going to be invoked automatically
    is a constructor, or `init`. Thus, we passed a value that was demanded by the
    constructor while creating the object of that class. After that, we made a call
    to the `Ride` method from the object of the `Suzuki` class. You can check the
    `Ride` method inside the body of the `Suzuki` class. It isn't there—instead, it's
    inside the suite of the `Bike` class. Due to inheritance, we were able to call
    the methods of the `Base` class as if they were inside the `Child` class. We can
    also use every property that's defined inside the `Base` class in the `Child`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all features are inherited inside the child class. When we create
    instances of the child class, the `init` method of the child class was called,
    but not those of the `Parent`. However, there is a way to call that constructor:
    by using the `super` method. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `super()` method refers to the superclass or `Parent` class. Thus, after
    the instantiation of the superclass, we made a call to the `init` method of that
    superclass.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to `Bike().__init__()`, but in this case Bike is starting.. will
    be printed twice because the `Bike()` statement is going to create an object of
    the `Bike` class. This means that the `init` method will be called automatically.
    The second call is made with the object of the `Bike` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, multi-level inheritance is available. This is a chained sequence
    that''s created when any child class inherits from another child class. There
    are no limits regarding how a multi-level inheritance chain can be created. The
    following diagram depicts multiple classes inheriting features from their parent
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4dfded1e-55cf-43fa-8e23-5512ec11b5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code shows the features of multi-level inheritance. We have made
    three classes, with each one inheriting the features of the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've looked at inheritance, it's time to have a look at another feature,
    known as polymorphism. In a literal sense, **polymorphism** is the ability to
    accommodate different forms. Thus, this feature is going to help us use the same
    code in a different form so that multiple tasks can be carried out with it. Let's
    take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the object-oriented paradigm, polymorphism allows us to define methods in
    the `Child` class with the same signature that's defined in the `Parent` class.
    As we know, inheritance allows us to use every method of the `Parent` class as
    if it were inside the `Child` class with the help of child class objects. However,
    we may encounter a situation where we have to modify the specification of the
    method that is defined inside the parent class so that it is executed independently
    of the `Parent` class. This technique is called method overriding. As the name
    suggests, we are overriding the existed method of the `Base` class with the new
    specification inside the `Child` class. Using method overriding, we can call both
    of the methods independently. If you have overridden a method of the parent class
    in the child class, then any version of that method (either the new one of the
    child or the old one of the parent) will be called based on the type of object
    it is being used to call. For example, if you want to call the new version of
    the method, you should call it with the `Child` class object. Speaking of the
    Parent class method, we have to use a `Parent` class object to call it. Thus,
    we can visualize that the two sets of methods have been developed but with the
    same name and signature, which signifies basic polymorphism. In programming, polymorphism
    is where the same function or method is used in different forms or types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start thinking about examples of polymorphism from what we have learned
    so far. Do you remember the `len()` function? This is a built-in Python function
    and takes an object as a parameter. Here, an object can be anything; it can be
    a string, list, tuple, and so on. Even if it has the same name, it is not limited
    to performing a single task—it can be used in different forms, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example to demonstrate polymorphism with inheritance. We
    will write a program that will create three classes; one will be a `Base` class
    while the other two will be `Child` classes. The two `Child` classes will inherit
    each and every member of the `Parent` class, but each of them will have one method
    implemented independently. This will be the application of method overriding.
    Let''s look at an example of polymorphism using the concept of polymorphism with
    inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first thing you see is that the `Dance` method is common among all three
    classes. But in each of these classes, we have different specifications for the
    `Dance` method. This feature is particularly useful because, in some cases, we
    may want to customize the method that is inherited from the `Parent` class, which
    may not have any significance in the `Child` class. In such cases, we redefine
    this method with the same signature that's inside the `Child` class. This technique
    of reimplementing a method is known as method overriding, and the different methods
    it creates using this process enable polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the important concepts of object-oriented programming
    and their prime features, such as encapsulation, inheritance, and polymorphism,
    it's time to use this knowledge to modify the Snake game that we made using curses
    in the previous chapter. Since we can't use these object-oriented principles to
    make the code from the previous chapter less messy and abstruse, we will make
    our code more reusable and readable. We will start modifying our game with OOP
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Snake game implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've explored various features of object-oriented programming in this chapter,
    including inheritance, polymorphism, data hiding, and encapsulation. One feature
    that we didn't cover, known as method overloading, will be covered in [Chapter
    9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model Implementation*. We
    have learned enough about OOP to make our code more readable and reusable. Let's
    start this section by following the conventional pattern, that is, brainstorming
    and information gathering.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discussed, object-oriented programming is not related to
    game interface programming; instead, it is a paradigm that makes code sturdier
    as well as more lucid. Thus, our interface will be similar to that of programs
    that are made by the curses module—text-based terminals. However, we will use
    the object-oriented paradigm to refine our code, and we will focus on the object
    rather than the actions and logic. We know that OOP is a data-driven methodology.
    Thus, our program must accommodate the game screen and user events data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main aims of using the object-oriented principle in our game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To divide programs into smaller parts, called objects. This will make programs
    more readable and allow us to track bugs and errors easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to communicate between objects through functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data is secure as it cannot be used by outer functions. This is called encapsulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will put more emphasis on the data rather than the methods or procedures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making modifications to the program, such as adding properties and methods,
    can be done easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's start brainstorming and gather some information about the game model.
    Obviously, we have to use the same code from the previous chapter for the game
    layout and its characters, that is, `Snake` and `Food`. Thus, we have to take
    two classes for each of them. The `Snake` and `Food` classes will have methods
    defined in them that will control game layouts and user events.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to use curses events such as `KEY_DOWN`, `KEY_UP`, `KEY_LEFT`, and
    `KEY_RIGHT` to handle the movement of the snake character. Let''s visualize the
    essential classes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to import curses to initialize the game screen and handle user
    key movements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have to import the random module as we have to generate food in a random
    position once the snake has eaten it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we initialize the constants, such as screen height, width, default
    snake length, and timeout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we declare eh `Snake` class with a constructor, which will initialize
    the default position of the snake, window, head position, and the body of the
    snake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Snake` class, we will add a couple of methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`eat_food` will check whether the snake has eaten the food. If it has, the
    length of the snake will increase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collision` will check whether the snake has collided with itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update` will be invoked every time the user makes a move and changes the position
    of the `Snake` character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we declare the `Food` class and define the render and reset methods
    to generate and delete the food from a random position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's start writing the program by declaring the constants and importing
    the essential modules. This is no different from the previous chapter—we will
    use curses to initialize the game screen and handle user events. We will use the
    random module to generate a random position on the game console so that we can
    generate new food at that position.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring constants and initializing the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the preceding chapter, we are going to import the curses module
    so that we can initialize the game screen and customize it by specifying the height
    and width. We have to declare the default snake length and its position as constants.
    The following code will be familiar to you, except for the `name == "__main__"` pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have declared a bunch of constants to specify the
    height, width, default snake length, and timeout. We are familiar with all of
    these terms, except for the `__name__ == "__main__"` pattern. Let''s talk about
    it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at this pattern, we can conclude that the assignment of the `"main"` string
    is done in the name variable. Just like `__init__()` was a special method, `__name__`
    is a special variable. Whenever we execute our script file, the Python interpreter
    will execute the code that is written at the zero indentation level. But in Python,
    there is no `main()` function like there is in C/C++, which is invoked automatically.
    Thus, the Python interpreter will set the special `__name__` variable with the
    `__main__` string. Whenever the Python script is executed as a main program, the
    interpreter sets the special variable with the string. But when the file is being
    imported from another module, the value of the name variable will be set to that
    module name. Thus, we can conclude that the name variable will determine the current
    working module. We can evaluate how this pattern works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When the current source code file is the main program**:When we run the current
    source file as the main program, that is, `C:/> python example.py`, the interpreter
    will assign the`"__main__"` string to the special name variable known as `name
    == "__main__"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When another program is importing your module**: Suppose any other program
    is the main program and it is importing our module. The `>>> import example` statement
    will import the example module into the main program. Now, the Python interpreter
    will refine the name of the script file by removing the `.py` extension and setting
    that module name to the name variable, that is, `name == "example"`. Due to this,
    the code that is written in the example module will be available for the main
    program. After the special variable has been set up, the Python interpreter will
    execute the statements line by line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the `__name__ == "__main__"` pattern can be used to execute the code that's
    written inside it if the source file is executed directly, and is not imported.
    We can conclude that the code that's written inside this pattern is the code that
    will be executed. Functions, classes, and the code inside them that isn't defined
    aren't going to run until they are called from the zero indentation level. This
    is due to the lack of a `main()` function in Python, which is automatically invoked
    in low-level programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the top-level code starts with an `if` block that's followed by
    the pattern's **name**, which evaluates the current working module. If the current
    program is `main`, we are going to execute the code that's written inside the
    `if` block, which initializes the game screen and creates a new window for the
    game by using curses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have started writing a program that''s initialized the game screen
    and declared some constants, it''s time to create some classes. We have two characters
    in the game: `Snake` and `Food`. We will begin by creating two classes for now
    and modify them according to our needs. Let''s start by creating the `Snake` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the snake class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After creating the screen for our game, our next focus will be on rendering
    the game character in our screen. We will start off by creating the `Snake` class.
    We know that classes will have different members, that is, attributes and methods.
    As we mentioned in the previous chapter, while creating the `Snake` character,
    we have to track the *x* and *y* positions of the snake in the game window. To
    track the body position of the snake, we have to extract the *x* and *y* coordinates
    of the snake. We should use alphabetical characters to make up the body of the
    snake as curses only supports text-based Terminals. Let''s start creating the
    `Body` class, which will provide us with the position of the snake and provide
    the character for the body of the snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, `#` is used to make up the body structure of the
    snake. We have defined two members inside the `Body` class: the constructor and
    the `coor` method. The `coor` method is used to extract the current coordinates
    of the snake body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a class for the game characters. We will start with the `Snake`
    class. We should maintain a listed data structure so that we can store the body
    position of the snake. Initializing these properties should be done using a constructor.
    Let''s start writing the constructor for the `Snake` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `Snake` class, we made a dictionary. Each of the keys and values
    represents a reverse direction. If you are confused about how the direction on
    the screen is represented, go back to the previous chapter. The positions of the
    characters are represented in the coordinates. We declared the constructor, which
    allows us to initialize the properties of the classes. We made `body_list` to
    hold the snake body; a window object that represents the game screen for the snake
    game; the default direction of the snake, which is the RIGHT direction; and a
    direction map, which accommodates the movement of the character with curses constants
    such as `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, and `KEY_RIGHT`.
  prefs: []
  type: TYPE_NORMAL
- en: For every direction map, we make a call to the `move_up`, `move_down`, `move_left`,
    and `move_right` functions. We will create these methods shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines of code are declared inside the `Snake` class and will
    add the coordinates of the snake body to `body_list`. The `Body(x-i,y)` statement
    is the instance of `Body` class that will specify the coordinates of the snake''s
    body. In the constructor of the `Body` class, `#` is used to specify the layout
    of the snake''s body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the preceding code and explore it. This code is going
    to extend the characteristics of the `Snake` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to begin by adding some new members inside the `Snake` class.
    We start by adding a simple method that will extend the body of the snake:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to create another method that will render game objects onto the
    screen. One of the important steps of this program is to render the snake''s body
    onto the game screen. Since we have to represent the snake with`#`, we can use
    curses for this and use the `addstr` method. In the following render method, we
    looped the entire `body_list` of the snake and added `''#''` to each instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the object of the `Snake` class. We can create it inside
    the `name == ''__main__''` pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created a snake object. Since the constructor of
    the `Snake` class will be automatically invoked while creating an object of it,
    we passed in the `SNAKE_X` and `SNAKE_Y` arguments, which provide the default
    position of the snake and window, The window object screen is created by the `newwin`
    method from curses. Inside the while loop, we used the snake object to invoke
    the render method, which will add a snake in the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have successfully rendered the snake into the game console, our
    game isn't ready to test yet because the program is unable to address certain
    actions, for example, whenever the user presses the LEFT, RIGHT, UP, and DOWN
    keys on the keyboard to move the `Snake` character. We know that the curses module
    provides us with a method so that we can get input from the user, and we can handle
    it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, it is really easy to take input from the
    user and handle it using the curses module. In this section, we are going to add
    those methods inside the `Snake` class because methods related to the user''s
    actions are related to the movement of the `Snake` character. Let''s add a couple
    of methods inside the `Snake` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method is going to change the direction of the snake. Here, we
    have initialized the `REV_DIR_MAP` directory, which contains the key and value
    that represent their opposite directions. Thus, we pass the current direction
    to this method to change it based on the event that's pressed by the user. The
    direction argument is inputted from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to extract the head and coordinates for the head of snake.
    We know that the head position of the snake changes while the snake moves. Even
    when crossing the boundary of the snake, we must make the snake appear from the
    other side. Thus, the snake''s head position will change according to the user''s
    movements. We need to create a method that can accommodate these changes. We can
    use the property decorator for this, which will treat changing the head properties
    of the `Snake` class as a method. This works like a getter. Don''t be overwhelmed
    by these terms, as we will cover these in a later chapter (List Comprehension
    and Properties). This being said, let''s take a look at the following example.
    This example will help you understand the `@property` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change the value of the `first` attribute and print all those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can clearly see that the change has not been reflected in the email. The
    name for the email has been preserved from the previous value of `Ross`. Thus,
    in order to make the program accommodate changes spontaneously, we need to make
    the attributes property decorators. Let''s make the email a property and observe
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is executed in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The change we have made to the attribute has been reflected spontaneously in
    the attribute of the class with the help of the decorator property. We will learn
    about this in detail in the next chapter. This was just a quick introduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only covered it because it''s an essential part of making the head attribute
    of the snake a property decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `head` method is going to extract the last element of the list, which indicates
    the head of the snake. The `coor` method is going to return a tuple containing
    the (*x*,*y*) coordinates, which represent the head of the snake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add one more function that will update the direction of the snake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `update` method is going to pop out the last part of the body
    and insert it with the head position before updating the new head position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s handle the user events using the curses module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We learned about the working mechanism in the preceding code in the previous
    chapter, so you shouldn''t have any problems grasping it. Now, let''s make the
    snake move in a certain direction. Previously, in the `Snake` class, we added
    the `direction_map` attribute, which held the dictionary mapping to different
    functions, such as `move_up`, `move_down`, `move_left`, and `move_right`. These
    functions will change the position of the snake based on the user''s action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We made this logic in the previous chapter and will make the snake move either
    up, down, left, or right. We can imagine the screen as a matrix containing rows
    and columns. With the up action, the snake will move in the Y-axis, and so the
    y position should be decreased; similarly, with the down action, the snake will
    move to down the Y-axis, and so we need to increment the y coordinate. For the
    LEFT and RIGHT movements of the snake, we will have to decrement and increment
    the X-axis, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that we have handled user events, this concludes the `Snake` class. It's
    time to handle the collision, if there is one. We also have to add another character
    to the game, that is, `Food`, which will be made by creating a new class.
  prefs: []
  type: TYPE_NORMAL
- en: Handling collisions elp of decorator property.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No noble logic will be created in this section. We have to check whether the
    head of the snake has collided with the body part of the snake. This should be
    done by checking the coordinates of the head (*y*,*x*) against any of the coordinates
    of the snake''s body. Thus, let''s make a new method, `@property`, which will
    check for the collision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, any function will return `True` if any item in the
    iterable is `True`; otherwise, it will return `False`. The statement inside the
    `any` function is a list comprehension statement that checks whether the coordinates
    for the head of the snake are the same as the coordinates for any part of the
    body of the snake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s invoke this method with the `snake` object in our main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding the food class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next character we need to add to our game is `Food`. As we have already
    said, we have to make a different class for each character because they should
    have different behaviors and attributes. Let''s create another class for the `Food`
    character. We will call this the `Food` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you read the *Python classes* section in this chapter carefully, this section
    should not create any confusion for you. To create a class in Python, we use the
    `class` keyword, followed by the class name. However, we have to use parentheses
    to show inheritance. If you left the parentheses empty, they will throw an error.
    Thus, we have added an object inside the parentheses, which is optional. You can
    simply remove the parentheses and they will work perfectly. We used the `randint`
    method from the random module to create food in a random position. The render
    method is going to add the `X` character to the specified (*y*,*x*) position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the object of the `Food` class and render the food on the
    screen by invoking the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, the logic that we''ve created to make the snake eat the
    food is the same logic that we used for the snake head coordinate colliding with
    the food coordinate. Before we actually make that logic, we will make another
    method for the `Snake` class that will add the logic for the aftermath of eating
    the food:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding logic is going to be called after the snake eats the food. After
    eating the food, we will reset it, which means the food will be generated in the
    next random position. We will then make an increment in the body position by adding
    the last coordinate of the food to the body of the snake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add some logic that will make sure we invoke this method. As we
    have already discussed, the logic will be simple: whenever the head of the snake
    collides with the position of the food, we will invoke the `eat_food` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our game and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e913c55-45cb-4b3c-ae48-3d794eb98a42.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we have modified the game with the object-oriented paradigm. You might
    feel that working with classes and objects is more complicated and lengthy, but
    with more practice, you will become more comfortable with it. That being said,
    OOP has provided more readability and reusability features in our program. As
    an example, if you find a bug in the `Snake` character, you can simply track it
    down by overlooking the unnecessary code for the food. Now, let's hop over to
    the next section, where we will test the game and make the necessary modifications
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The curses application cannot be run directly from the Python script by pressing
    *F5*. Thus, we have to run it externally from the command prompt with the `filename.py` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the score to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to initialize the score value as 0 at the `Snake` class.
    We will also add a `score` method in the `Snake` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to increase this score every time the snake eats the food. The
    method that will be called after the snake eats food is the `eat_food` method.
    Thus, we will increase the score inside this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s render the score with the `addstr` method of the curses window
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement will call the `score` method from the snake object and
    add the score at the (0,5) position. Remember that, in curses, the first position
    is y and the second is x.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run our game one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ffdafeea-9cb8-407a-a07b-35439d08ce74.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about one of the most important paradigms in programming—object-oriented
    programming. We covered all the concepts of classes and objects to make it easier
    for you to read and write your own code. We also explored how to define the members
    of a class and access them. We got familiar with the features of the object-oriented
    approach by implementing hands-on examples. We also learned about inheritance,
    encapsulation, polymorphism, and method overriding. These features will be used
    in upcoming chapters too, so make sure you have a good grasp of each of these
    topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about list comprehension and properties.
    The aim of the next chapter is to find a way to optimize code to make the program
    shorter and faster in terms of its execution. We will look at how to work with
    conditions and logic in order to implement one-line code that will be more readable
    and easier to debug. We will also use that concept to modify our Snake game.
  prefs: []
  type: TYPE_NORMAL
