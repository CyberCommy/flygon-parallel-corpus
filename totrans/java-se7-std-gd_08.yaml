- en: Chapter 8. Handling Exceptions in an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are objects that are thrown by an application or the **Java Virtual
    Machine** (**JVM**) when an error of some sort occurs. Java provides a wide range
    of predefined exceptions and allows the developer to declare and create their
    own exception classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a number of ways of classifying exceptions, one scheme classifies
    them into three types:'
  prefs: []
  type: TYPE_NORMAL
- en: Program errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper use of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-related failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program errors are internal flaws in a code sequence. The programmer may or
    may not be able to do much about these types of errors. For example, a common
    exception is `NullPointerException` . This is frequently a result of not properly
    initializing or assigning a value to a reference variable. This type of error
    can be hard to avoid and anticipate when first writing a piece of code. However,
    once detected, the code can be revised to correct the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Code may be improperly used. Most libraries are designed to be used in a specific
    manner. They may expect data to be organized in one way and if the user of the
    library fails to follow the format, an exception may be thrown. For example, the
    parameter of a method may not be structured as expected by the method or may be
    of the wrong type.
  prefs: []
  type: TYPE_NORMAL
- en: Some errors are related to resource failure. When the underlying system is not
    able to satisfy the program's needs, a resource type of exception can occur. For
    example, a failure in the network may prevent the program from executing properly.
    This type of error may require re-executing the program at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A traditional approach to handling exceptions is to return an error code from
    a procedure. For example, a function may normally return a zero if it executed
    without an error. If an error did not occur, a non-zero value would be returned.
    The problem with this approach is that the calling of the function may either:'
  prefs: []
  type: TYPE_NORMAL
- en: Be unaware that the function returns an error code (for example, C's `printf`
    function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forget to check for an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the error completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the error is not caught, the continued execution of the program can lead
    to unpredictably and possibly disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to this method is to "catch" errors. Most modern block structured
    languages such as Java use this approach. This technique requires less coding
    and is more readable and robust. When a routine detects an error, it "throws"
    an exception object. The exception object is then returned to the caller which
    then catches and handles the error.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions should be caught for a number of reasons. Failure to deal with exceptions
    can result in the application failing, or ending up in an invalid state with incorrect
    output. It is always a good idea to maintain a consistent environment. Also, if
    you open a resource, such as a file, you should always close the resource when
    you are done except for the most trivial programs.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handling mechanisms available in Java allow you to do this. When
    a resource is opened, it can be closed even if an exception occurs in the program.
    To accomplish this task, a resource is opened in a `try` block and closed in a
    `catch` or `finally` block. The `try`, `catch`, and `finally` blocks constitute
    the core of the exception handling mechanism used in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Exception types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java has provided an extensive set of classes to support exception handling
    in Java. An exception is an instance of a class derived directly, or indirectly,
    from the `Throwable` class. Two predefined Java classes are derived from `Throwable`—`Error`
    and `Exception`. From the `Exception` class is derived a `RuntimeException` class.
    As we will see shortly, programmer-defined exceptions are normally derived from
    the `Exception` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception types](img/7324_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are numerous pre-defined errors that are derived from the `Error` and
    `RuntimeException` classes. There is little that a programmer will do with the
    exceptions derived from the `Error` object. These exceptions represent problems
    with the JVM and normally can''t be recovered. The `Exception` class is different.
    The two classes that derive from the `Exception` class support two types of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checked**: These are exceptions that need to be dealt with in the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unchecked**: These are exceptions that do not need to be dealt with in the
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checked exceptions include all exceptions derived from the `Exception` class
    and are not derived from the `RuntimeException` class. These must be handled in
    code or the code will not compile cleanly, resulting in compile-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions are all other exceptions. They include exceptions, such
    as division by zero and array subscripting errors. These do not have to be caught
    but like the `Error` exceptions, if they are not caught, the program will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: We can create our own exception classes. When we do, we need to decide whether
    to create a checked or unchecked exception. A general rule of thumb is to declare
    the exception as an unchecked exception if the client code cannot do anything
    to recover from the exception. Otherwise, if they can handle it, make it a checked
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The users of a class do not have to account for unchecked exceptions that can
    result in the program terminating, if the client program does not ever deal with
    them. A checked exception requires the client to either catch the exception or
    explicitly pass it up the call hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling techniques in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three general techniques we can use when dealing with exceptions
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: Traditional `try` block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new "try-with-resources" block introduced in Java 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the buck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The third technique is used when the current method is not the appropriate
    place to handle the exception. It allows the exception to be propagated higher
    into the sequence of method calls. In the following example, `anotherMethod` may
    encounter some condition where it may throw `IOException`. Instead of dealing
    with the exception in `someMethod` , the `throws` keyword in the `someMethod`
    definition results in the exception being passed to the code that called this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The method will skip all of the remaining lines of code in the method and immediately
    return to the caller. Uncaught exceptions are propagated to the next higher context
    until they are caught or they are thrown from `main`, where an error message and
    stack trace will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Stack trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `printStackTrace` is a method of the `Throwable` class that will display
    the program stack at that point in the program. It is used automatically when
    an exception is not caught or can be called explicitly. The output of the method
    pinpoints the line and method that caused the program to fail. You have seen this
    method in action before, whenever you had an unhandled runtime exception. The
    method is automatically called when an exception is not handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExceptionDemo` program illustrates the explicit use of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using Throwable methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Throwable` class possesses a number of other methods that can provide
    more insight in to the nature of the exception. To illustrate the use of many
    of these methods we will use the following code sequence. In this sequence we
    attempt to open a non-existent file and examine the exception thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the nature of some IDEs, an application''s standard output and standard
    error output can be interleaved. For example, the execution of the above sequence
    may result in the following output. You may not or may see the interleaving in
    your output. The dashes in front of the output are used to help see the interleaving
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods used in this example are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getCause` | Returns the cause of the exception. If it cannot be determined
    it returns null. |'
  prefs: []
  type: TYPE_TB
- en: '| `getMessage` | Returns a detailed message. |'
  prefs: []
  type: TYPE_TB
- en: '| `getLocalizedMessage` | Returns a localized version of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `toString` | Returns the string version of the message. |'
  prefs: []
  type: TYPE_TB
- en: Notice that the first line of the `printStackTrace` method is the output of
    the `toString` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getStackTrace` method returns an array of `StackTraceElement` objects
    where each element represents a line of the stack trace. We can duplicate the
    effect of the `printStackTrace` method with the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The traditional try-catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional technique to handle exceptions uses a combination of a `try`,
    `catch`, and `finally` blocks. A `try` block is used to surround code that might
    throw exceptions and is followed by zero or more `catch` blocks and then, optionally,
    by a single `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: The `catch` blocks are added after a `try` block to "catch" exceptions. The
    statements in the `catch` block provide blocks of code to "handle" the error.
    A `finally` clause can optionally be used after the catch blocks. It is guaranteed
    to execute even if code within a `try` or a `catch` block throws or does not throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, a finally block will not execute if the `System.exit` method is invoked
    in a try or catch block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence illustrates the use of these blocks. Within the try
    block, a line is read in and an integer is extracted. Two catch blocks are used
    to handle the exceptions that might be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One of two types of errors is possible in this code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Either an error will occur trying to read a line of input or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error will occur trying to convert the string to an integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first catch block will catch IO errors and the second catch block will catch
    conversion errors. Only one catch block is ever executed when an exception is
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: An error may, or may not, occur. Regardless, the finally block will execute
    either after the try block completes or after a catch block executes. The `finally`
    clause is guaranteed to run and generally contains "clean-up" code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the try-with-resource block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of the previous technique can be cumbersome when multiple resources
    are opened and a failure occurs. It can result in multiple try-catch blocks that
    become hard to follow. In Java 7, the try-with-resources block was introduced
    to address this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the try-with-resources block is that all resources opened with
    the block are automatically closed upon exit from the block. Any resources used
    with the try-with-resources block must implement the interface `java.lang.AutoCloseable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will illustrate this approach by creating a simple method to copy one file
    to another. In the following example, one file is opened for reading and the other
    is opened for writing. Notice how they are created between the `try` keyword and
    the block''s open curly brace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Resources to be managed are declared and initialized inside a set of parentheses
    and are placed between the `try` keyword and the opening curly brace of the try
    block. The first resource is a `BufferedReader` object that uses the `data.txt`
    file and the second resource is a `BufferedWriter` object used with the `data.bak`
    file. The `Paths` class is new to Java 7 and provides improved IO support.
  prefs: []
  type: TYPE_NORMAL
- en: Resources declared with a try-with-resources block must be separated by semicolons
    otherwise a compile-time error will be generated. More in-depth coverage of the
    try-with-resources block can be found in The Java 7 Cookbook.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the vertical bar in the catch block is new to Java 7 and allows us
    to catch multiple exceptions in a single catch block. This is explained in the
    *Using the | operator in a catch block* section.
  prefs: []
  type: TYPE_NORMAL
- en: Catch statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The catch statement has exactly one argument. The catch statement will trap
    the exception if its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exactly matches the exception type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is a base of the exception type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is an interface that the exception type implements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the first catch statement that matches the exception will execute. If no
    matches are made, the method will terminate and the exception will bubble up to
    the calling method where it may be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'A part of the earlier `try` block is duplicated as follows. The format of the
    `catch` statement consists of the `catch` keyword followed by a set of open and
    close parentheses enclosing an exception declaration. The set of parentheses is
    then followed by zero or more statements in a block statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The process of handling an error is up to the programmer. It may be as simple
    as displaying an error message or it can be quite complex. The programmer may
    use the error object to retry the operation or otherwise deal with it. This may
    involve propagating it back to the calling method in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: Order of the catch blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The order in which catch blocks are listed after a try block can be significant.
    When an exception is thrown, the exception object is compared to the catch blocks
    in the order that they are listed. The comparison checks to see if the thrown
    exception is a type of the exception in the catch block.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a `FileNotFoundException` is thrown, it will match either a
    catch block that has an `IOException` or a `FileNotFoundException` exception because
    `FileNotFoundException` is a sub-type of `IOException`. As the comparison is stopped
    when the first match is found, if the catch block for `IOException` is listed
    before the catch block for `FileNotFoundException`, the `FileNotFoundException`
    block will never be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following hierarchy of exception classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Order of the catch blocks](img/7324_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If an exception is thrown that is one of these types of exceptions, the `AException`
    catch block will always be executed. This is because an `AException`, `BException`,
    `CException`, or a `DException` are all of the `AException` type. The exception
    will always match the `AException` exception. The other `catch` blocks will never
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general rule is always to list the "most-derived" exceptions first. The
    following is the correct way of listing the exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice, that it doesn't make any difference with this hierarchy of exceptions
    whether the `BException` immediately precedes or follows the `CException`, as
    they are at the same level.
  prefs: []
  type: TYPE_NORMAL
- en: Using the | operator in a catch block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is desirable to handle multiple exceptions in the same way. Instead
    of duplicating the code in each catch block, we can use a vertical bar to permit
    one catch block to capture more than one exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the situation where two exceptions are potentially thrown and are
    handled in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A vertical bar can be used to catch two or more exceptions in the same `catch`
    statement as illustrated in the following code snippet. This can reduce the amount
    of code needed to handle two exceptions that are handled in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach works when more than one exception can be handled in the same
    way. Keep in mind that the catch block''s parameter is implicitly final. It is
    not possible to assign a different exception to the parameter. The following attempt
    is illegal and will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The finally block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `finally` block follows a series of `catch` blocks and consists of the `finally`
    keyword followed by a block of statements. It contains one or more statements
    that will always be executed to clean up previous actions. The `finally` block
    will always execute regardless of the existence or non-existence of exceptions.
    However, if a `try` or `catch` block invokes the `System.exit` method, the program
    immediately terminates and the `finally` block does not execute.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a `finally` block is to close or otherwise handle any resources
    that were opened within the `try` block. It is always a good practice to close
    resources after they have been opened and are no longer needed. We will this in
    the next example.
  prefs: []
  type: TYPE_NORMAL
- en: However, in practice this is often tedious and can be error prone if it is necessary
    to close multiple resources where the close process may also generate exceptions.
    In addition, if one resource throws an exception while being opened and another
    one was not opened, we have to be careful not to attempt to close the second one.
    As a result, in Java 7 the try-with-resources block has been introduced to address
    this type of problem. This block was discussed in the *Using the try-with-resource
    block* section. Here, we will cover the simplified use of the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of using the `finally` block is shown as follows. In this
    sequence we will open a file for input and then display its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The file will be closed regardless of whether an exception was thrown or not.
    If the file does not exist, a `FileNotFoundException` will be thrown. This will
    be caught in the `catch` block. Notice how we checked the `reader` variable to
    make sure it was not null.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we open two files and then try to copy one file to
    another. The finally block is used to close the resources. This illustrates a
    problem with the finally block when dealing with multiple resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice, that the `close` methods may also throw a `IOException`. We must also
    handle these exceptions. This may require a more complicated exception handling
    sequence which can be error prone. In this case, note that the second file will
    not be closed if an exception is thrown when the first file is closed. In this
    situation it is better to use the try-with-resources block, as discussed in the
    *Using the try-with-resources block* section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A try block needs either a catch block or a finally block. Without one or both
    a compile time error will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Nested try-catch blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exception handling can be nested. This can become necessary when methods are
    used in a `catch` or `finally` block that also throws exceptions. The following
    illustrates using a nested `try` block inside of a `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the last example of the previous section, we used the `close` method inside
    a `finally` block. However, the `close` method may throw a `IOException`. As it
    is a checked exception, we will need to catch it. This results in a `try` block
    being nested inside of a `finally` block. In addition, when we try to close the
    `BufferedReader`, a `NullPointerException` will be thrown in the second `try`
    block because we attempted to execute the close method against the `reader` variable
    which was never assigned a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the previous example, consider the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We used the `|` bar to simplify the capture of both exceptions as detailed in
    the *Using the | operator in a catch block* section. This is also another example
    where we may lose the original exception. In this case, the `FileNotFoundException`
    was lost to a `NullPointerException`. This will be discussed in the *Losing the
    stack trace* section.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section addresses general guidelines for working with exceptions. It is
    intended to provide examples of how to use exception handling in a more useful
    and productive manner. While poor techniques may not result in a compile-time
    error, or an incorrect program, they often reflect a poor design.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating code that threw an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is thrown and then caught we will sometimes want to try and
    re-execute the offending code. This is not difficult if the code is structured
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code sequence, errors are assumed to be present when the `try` block
    is entered. If an error is generated it is caught and handled by the `catch` block.
    As the `errorsArePresent` is still set to true, the try block will be repeated.
    However, if no errors occur, at the end of the try block the `errorsArePresent`
    flag is set to false which will allow the program to execute the while loop and
    continue executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: An assumption is made, in this example, that the code used to process the error
    will necessitate that the `try` block be re-executed. This may be the case when
    all we do in the process error code sequence is to display an error message that
    identifies the error, such as when the user enters a bad filename.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be careful using this approach if the resource needed is not available.
    This can result in an infinite loop where we check for a resource that is not
    available, throw an exception, and then do it all over again. A loop counter can
    be added to specify the number of times we try to handle the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Not being specific in which exception you are catching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When catching an exception, be specific about the one you need to catch. For
    example, in the following example the generic `Exception` is caught. There is
    nothing specific that will reveal more useful information about what caused the
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A more useful version follows which catches the actual exception thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Losing the stack trace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes an exception is caught and then a different one is re-thrown. Consider
    the following method where a `FileNotFoundException` exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that the file does not exist, the following stack trace is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can tell what the precise exception was and where it occurred. Next, consider
    the use of using the `MyException` class instead of the `FileNotFoundException`
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we re-throw the exception, as shown in the following code snippet, we will
    lose information about the original exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack trace that results from this implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice, that the details of the actual exception have been lost. In general
    it is a good idea not to use this approach as information crucial for debugging
    is lost. Another example of this problem is found in the *Nested try-catch blocks*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to re-throw and preserve the stack trace. To do this we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a constructor with a `Throwable` object as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this when we want to preserve the stack trace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following shows such a constructor added to the `MyException` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the `catch` block we will use this constructor, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have thrown the exception. Instead, we use the `printStackTrace` method,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Scoping and block lengths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scope of any variable declared within a `try`, `catch`, or `finally` block
    is limited to that block. It is a good idea to limit the scope of a variable as
    much as possible. In the following example, it is necessary to define the `reader`
    variable outside of the try and catch blocks because it is needed in the `finally`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of a block should be limited. However, blocks that are too small
    can result in your code becoming cluttered with the exception handling code. Let''s
    assume there are four methods that can each throw distinct exceptions. If we use
    separate try blocks for each method we will wind up with code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is somewhat unwieldy and also presents problems if a `finally` block is
    needed for each `try` block. A better approach, if these are logically related,
    uses a single `try` block, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the nature of the exceptions we can also use a common base class
    exception or, as introduced in Java 7, we can use the `|` operator with a single
    catch block. This is particularly useful if the exceptions can be dealt with in
    the same way.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is a bad practice to place the entire body of a method in a try/catch
    block which contains code not related to the exception. It is better to separate
    the exception handling code from the non-execution handling code if possible.
  prefs: []
  type: TYPE_NORMAL
- en: A general rule of thumb is to keep the length of the exception handling code
    to a size that can be seen all at once. It is perfectly acceptable to use multiple
    try blocks. However, make sure that each block contains operations that are logically
    related. This helps modularize your code and makes it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a UnsupportedOperationException object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods that are intended to be overridden will sometimes return an "invalid"
    value to indicate that the method needs to be implemented. For example, in the
    following code sequence the `getAttribute` method returns `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: However, if the method is not overridden and the base class method is used,
    problems such as an incorrect result may result, or a `NullPointerException` may
    be generated, if a method is executed against the return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to throw an `UnsupportedOperationException` to indicate
    that the method functionality has not yet been implemented. This is illustrated
    in the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The method cannot be used successfully until a valid implementation is provided.
    This approach is used frequently in the Java API. The `java.util.Collection` class'
    `unmodifiableList` method uses this technique ([http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29)).
    Similar effects can be achieved by declaring the method as abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is generally a bad practice to ignore exceptions. They are thrown for a reason
    and if there is something you can do to recover, then you should deal with it.
    Otherwise, at minimum, you can gracefully terminate your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it is common to ignore an `InterruptedException`, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: However, even here something went wrong. For example, if the thread is a part
    of a thread pool, the pool may be terminating and you should handle this event.
    Always understand the environment in which your program is running in and expect
    the unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of poor error handling is shown in the following code snippet.
    In this example we ignore the `FileNotFoundException` exception that may be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This user is not aware that an exception was ever encountered. This is rarely
    an acceptable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Handle exceptions as late as you can
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is thrown by a method, the user of the method can either deal
    with it at that point or pass the exception up the call sequence to another method.
    The trick is to handle the exception at the appropriate level. That level is typically
    the one that can do something about the exception.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if input is needed from the application's user to successfully
    handle the exception, then the level best suited for interacting with the user
    should be used. If the method is part of a library, then it may not be appropriate
    to assume that the user should be prompted. When we try to open a file and the
    file does not exist, we don't expect, or want the method we called, to prompt
    the user for a different file name. Instead, we are more inclined to do it ourselves.
    In some cases there may not even be a user to prompt as is the case with many
    server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Catching too much in a single block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we add catch blocks to an application, we are frequently tempted to use
    a minimal number of catch blocks by using a base class exception class to capture
    them. This is illustrated below where the catch block uses the `Exception` class
    to capture multiple exceptions. Here, we assume that multiple checked exceptions
    can be thrown and need to be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If they are all handled exactly the same way, this might be alright. However,
    if they differ in how they should be handled then we need to include additional
    logic to determine what actually happened. If we ignore the differences, then
    it can make any debugging process more difficult because we may have lost useful
    information about the exception. In addition, not only is this approach too coarse
    but we also catch all `RuntimeException`s which we may not be able to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it is generally better to catch multiple exceptions in their own catch
    block, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Logging exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common practice is to log exceptions even if they are handled successfully.
    This can be useful in assessing the behavior of an application. Of course, if
    we cannot handle the exception and need to gracefully terminate the application,
    error logs can be quite useful in determining what went wrong in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log the exception only once. Logging multiple times can confuse whoever is trying
    to see what happened and create log files larger than they need to be.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use exceptions to control normal logic flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a poor practice to use exceptions where validation should be performed.
    In addition, throwing an exception uses up additional resources. For example,
    the `NullPointerException` is a common exception that results when a method is
    attempted to be executed against a reference variable that has a null value assigned
    to it. Instead of catching this exception, we should detect this condition and
    handle it in the normal logic sequence. Consider the following where we catch
    a `NullPointerException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we should check the value of the state variable before it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The need for the `try` block is eliminated altogether. An alternate approach
    uses short-circuiting as illustrated in the following code snippet and is covered
    in the *Short circuit evaluation* section of [Chapter 3](ch03.html "Chapter 3. Decision
    Constructs"), *Decision Constructs*. The use of the `equals` method is avoided
    if the `state` variable is null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Do not try to handle unchecked exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is usually not worth the effort to deal with unchecked exceptions. Most of
    these are beyond the control of the programmer and would require significant effort
    to recover from. For example, a `ArrayIndexOutOfBoundsException`, while the result
    of a programming error, is not easily dealt with at runtime. Assuming that it
    would be feasible to modify the array index variable, it may not be clear what
    new value should be assigned to it or how to re-execute the offending code sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never catch `Throwable` or `Error` exceptions. These should never be handled
    or suppressed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proper exception handling in your program will enhance its robustness and reliability.
    The `try`, `catch`, and `finally` blocks can be used to implement exception handling
    within an application. In Java 7, the try-with-resources block has been added
    which more easily handles the opening and closing of resources. It is also possible
    to propagate an exception back up the call sequence.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that the order of catch blocks is important in order to properly
    handle exceptions. In addition, the `|` operator can be used in a catch block
    to handle more than one exception in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling may be nested to address problems where the code within a
    catch, or finally block, may also throw an exception. When this happens, the programmer
    needs to be careful to insure that previous exceptions are not lost and that the
    new exceptions are handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: We also addressed a number of common problems that can occur when handling exceptions.
    They provided guidance as to avoid poorly structured and error prone code. These
    included not ignoring exceptions when they occur and to handle exceptions at the
    appropriate level.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the exception handling process, we're ready to
    wrap up our coverage of the Java certification objectives in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The certification objectives covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe what exceptions are used for in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiate among checked exceptions, runtime exceptions, and errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a try-catch block and determine how exceptions alter normal program flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke a method that throws an exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize common exception classes and categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following implement checked exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `Class A extends RuntimeException`
  prefs: []
  type: TYPE_NORMAL
- en: b. `Class A extends Throwable`
  prefs: []
  type: TYPE_NORMAL
- en: c. `Class A extends Exception`
  prefs: []
  type: TYPE_NORMAL
- en: d. `Class A extends IOException`
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following set of classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`class Exception A extends Exception {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Exception B extends A {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Exception C extends A {}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`class Exception D extends C {}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the correct sequence of catch blocks for the following `try` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: a. Catch `A`, `B`, `C`, and `D`
  prefs: []
  type: TYPE_NORMAL
- en: b. Catch `D`, `C`, `B`, and `A`
  prefs: []
  type: TYPE_NORMAL
- en: c. Catch `D`, `B`, `C`, and `A`
  prefs: []
  type: TYPE_NORMAL
- en: d. Catch `C`, `D`, `B`, and `A`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Checked exceptions are those derived from the `Error` class.
  prefs: []
  type: TYPE_NORMAL
- en: b. Checked exceptions should normally be ignored as we cannot not handle them.
  prefs: []
  type: TYPE_NORMAL
- en: c. Checked exceptions must be re-thrown.
  prefs: []
  type: TYPE_NORMAL
- en: d. Checked exceptions should be handled at the appropriate method in the call
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: When a method throws a checked exception which of the following are valid responses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Place the method in a try-catch block.
  prefs: []
  type: TYPE_NORMAL
- en: b. Do not use these types of methods.
  prefs: []
  type: TYPE_NORMAL
- en: c. Do nothing as we normally cannot handle checked exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: d. Use the `throws` clause on the method which calls this method.
  prefs: []
  type: TYPE_NORMAL
- en: What exceptions may the following code generate at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: a. `ArithmeticException`
  prefs: []
  type: TYPE_NORMAL
- en: b. `DivisionByZeroException`
  prefs: []
  type: TYPE_NORMAL
- en: c. `FileNotFoundException`
  prefs: []
  type: TYPE_NORMAL
- en: d. `NullPointerException`
  prefs: []
  type: TYPE_NORMAL
