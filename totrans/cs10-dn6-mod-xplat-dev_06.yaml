- en: '06'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '06'
- en: Implementing Interfaces and Inheriting Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口和继承类
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP** ). You will learn about defining operators and local functions
    for performing simple actions and delegates and events for exchanging messages
    between types. You will implement interfaces for common functionality. You will
    learn about generics and the difference between reference and value types. You
    will create a derived class to inherit from a base class to reuse functionality,
    override an inherited type member, and use polymorphism. Finally, you will learn
    how to create extension methods and how to cast between classes in an inheritance
    hierarchy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用**面向对象编程**（**OOP**）从现有类型派生新类型。您将学习定义运算符和执行简单操作的本地函数，以及在类型之间交换消息的委托和事件。您将为常见功能实现接口。您将学习泛型和引用类型与值类型之间的区别。您将创建一个派生类，以从基类继承功能，重写继承的类型成员，并使用多态。最后，您将学习如何创建扩展方法以及如何在继承层次结构中进行类之间的转换。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Setting up a class library and console application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: More about methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于方法
- en: Raising and handling events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发和处理事件
- en: Making types safely reusable with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型使类型安全地可重用
- en: Implementing interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Managing memory with reference and value types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用和值类型管理内存
- en: Working with null values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理空值
- en: Inheriting from classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类继承
- en: Casting within inheritance hierarchies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继承层次结构中进行转换
- en: Inheriting and extending .NET types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承和扩展.NET类型
- en: Using an analyzer to write better code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析器编写更好的代码
- en: Setting up a class library and console application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置类库和控制台应用程序
- en: 'We will start by defining a workspace/solution with two projects like the one
    created in *Chapter 5* , *Building Your Own Types with Object-Oriented Programming*
    . Even if you completed all the exercises in that chapter, follow the instructions
    below because we will use C# 10 features in the class library, so it needs to
    target .NET 6.0 rather than .NET Standard 2.0:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个包含两个项目的工作空间/解决方案，就像在*第5章*，*使用面向对象编程构建自己的类型*中创建的那样。即使您在该章节中完成了所有的练习，也请按照以下说明操作，因为我们将在类库中使用C#
    10功能，因此它需要针对.NET 6.0而不是.NET Standard 2.0进行目标设置：
- en: Use your preferred coding tool to create a new workspace/solution named `Chapter06`
    .
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编码工具创建一个名为`Chapter06`的新工作空间/解决方案。
- en: 'Add a class library project, as defined in the following list:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类库项目，如下列表所定义的那样：
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**类库** / `classlib`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PacktLibrary`
- en: 'Add a console app project, as defined in the following list:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个控制台应用程序项目，如下列表所定义的那样：
- en: 'Project template: **Console Application** / `console`'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作空间/解决方案文件和文件夹：`Chapter06`
- en: 'Project file and folder: `PeopleApp`'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`PeopleApp`
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`
    .
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktLibrary`项目中，将名为`Class1.cs`的文件重命名为`Person.cs`。
- en: 'Modify the `Person.cs` file contents, as shown in the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`Person.cs`文件内容，如下所示的代码：
- en: '```cs'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: using
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用
- en: static
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 静态
- en: System.Console;
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: System.Console;
- en: namespace
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Packt.Shared
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Packt.Shared
- en: ;
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: class
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Person
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ：对象
- en: '{'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // fields
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: // 字段
- en: public
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: string
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: '? Name;    // ? allows null'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ？ 名称；    // ？允许为空
- en: public
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: DateTime DateOfBirth;
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DateTime DateOfBirth;
- en: public
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: List<Person> Children = new
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> Children = new
- en: (); // C# 9 or later
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (); // C# 9或更高版本
- en: // methods
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: void
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: WriteToConsole
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: WriteToConsole
- en: ()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{Name}'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '{Name}'
- en: was born on a
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 出生于
- en: '{DateOfBirth:dddd}'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '{DateOfBirth:dddd}'
- en: ."
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 。"
- en: );
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ）;
- en: '}'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary` , as
    shown highlighted in the following markup:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PeopleApp`项目中，添加对`PacktLibrary`的项目引用，如下标记中所示：
- en: '```cs'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <Project Sdk="Microsoft.NET.Sdk"
- en: '>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: <PropertyGroup>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <OutputType>Exe</OutputType>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <OutputType>Exe</OutputType>
- en: <TargetFramework>net6.0
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <TargetFramework>net6.0
- en: </TargetFramework>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: </TargetFramework>
- en: <Nullable>enable</Nullable>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <Nullable>enable</Nullable>
- en: <ImplicitUsings>enable</ImplicitUsings>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <ImplicitUsings>enable</ImplicitUsings>
- en: </PropertyGroup>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '**<ItemGroup>**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ItemGroup>**'
- en: '**<ProjectReference**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**<ProjectReference**'
- en: '**Include=**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Include=**'
- en: '**"..\PacktLibrary\PacktLibrary.csproj"**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**"..\PacktLibrary\PacktLibrary.csproj"**'
- en: '**/>**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**/>**'
- en: '**</ItemGroup>**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**</ItemGroup>**'
- en: </Project>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: </Project>
- en: '```'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Build the `PeopleApp` project and note the output indicating that both projects
    have been built successfully.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建`PeopleApp`项目，并注意输出指示两个项目都已成功构建。
- en: More about methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于方法
- en: We might want two instances of `Person` to be able to procreate. We can implement
    this by writing methods. Instance methods are actions that an object does to itself;
    static methods are actions the type does.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望两个`Person`的实例能够繁殖。我们可以通过编写方法来实现这一点。实例方法是对象对自身执行的操作；静态方法是类型执行的操作。
- en: Which you choose depends on what makes the most sense for the action.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您的选择取决于对操作最合理的选择。
- en: '**Good Practice** : Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：同时具有静态方法和实例方法来执行类似的操作通常是有意义的。例如，`string`既有`Compare`静态方法，也有`CompareTo`实例方法。这样做将功能的使用方式放在了使用您的类型的程序员手中，为他们提供了更多的灵活性。'
- en: Implementing functionality using methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法实现功能
- en: 'Let''s start by implementing some functionality by using both static and instance
    methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过使用静态和实例方法来实现一些功能：
- en: 'Add one instance method and one static method to the `Person` class that will
    allow two `Person` objects to procreate, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: // static method to "multiply"
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Person
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Procreate
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Person p1, Person p2
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Person baby = new
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Name = $"Baby of
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '{p1.Name}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '{p2.Name}'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: p1.Children.Add(baby);
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: p2.Children.Add(baby);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: baby;
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: // instance method to "multiply"
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Person
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: ProcreateWith
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Person partner
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Procreate(this
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: ', partner);'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the `static` method named `Procreate` , the `Person` objects to procreate
    are passed as parameters named `p1` and `p2` .
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable's `Name` property.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object. You will learn
    the difference between reference types and value types later in this chapter.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method named `ProcreateWith` , the `Person` object to procreate
    with is passed as a parameter named `partner` , and it, along with `this` , is
    passed to the static `Procreate` method to reuse the method implementation. `this`
    is a keyword that references the current instance of the class.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PeopleApp` project, at the top of the `Program.cs` file, delete the
    comment and import the namespace for our `Person` class and statically import
    the `Console` type, as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared;
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , create three people and have them procreate with each other,
    noting that to add a double-quote character into a `string` , you must prefix
    it with a backslash character like this, `\"` , as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Person harry = new
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Harry"
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Person mary = new
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Mary"
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Person jill = new
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Jill"
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: // call instance method
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Person baby1 = mary.ProcreateWith(harry);
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: baby1.Name = "Gary"
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: // call static method
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Person baby2 = Person.Procreate(harry, jill);
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '{harry.Name}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: has
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '{harry.Children.Count}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: children."
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '{mary.Name}'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: has
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '{mary.Children.Count}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: children."
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '{jill.Name}'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: has
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '{jill.Children.Count}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: children."
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'format: "{0}''s first child is named \"{1}\"."'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: harry.Name,'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: harry.Children[0'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '].Name);'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Harry has 2 children.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Mary has 1 children.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Jill has 1 children.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Harry's first child is named "Gary".
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using operators
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two string values and returns the result, as shown in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: s1 = "Hello "
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: s2 = "World!"
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: s3 = string
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: .Concat(s1, s2);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(s3); // Hello World!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to "add" two `string` values together, as shown
    in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: s3 = s1 + s2;
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A well-known biblical phrase is *Go forth and multiply* , meaning to procreate.
    Let's write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but uses a
    symbol instead of a method name, which makes the syntax more concise.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , create a `static` operator for the `*` symbol, as shown in
    the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: // operator to "multiply"
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Person operator
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*(Person p1, Person p2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Person.Procreate(p1, p2);
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Unlike methods, operators do not appear in IntelliSense
    lists for a type. For every operator that you define, make a method as well, because
    it may not be obvious to a programmer that the operator is available. The implementation
    of the operator can then call the method, reusing the code you have written. A
    second reason for providing a method is that operators are not supported by every
    language compiler; for example, although arithmetic operators like * are supported
    by Visual Basic and F#, there is no requirement that other languages support all
    operators supported by C#.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , after calling the `Procreate` method and before the statements
    that write to the console, use the `*` operator to make another baby, as shown
    highlighted in the following code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: // call static method
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Person baby2 = Person.Procreate(harry, jill);
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**// call an operator**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '**Person baby3 = harry * mary;**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Harry has 3 children.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Mary has 2 children.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Jill has 1 children.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Harry's first child is named "Gary".
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using local functions
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A language feature introduced in C# 7.0 is the ability to define a **local function**
    .
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Local functions are the method equivalent of local variables. In other words,
    they are methods that are only accessible from within the containing method in
    which they have been defined. In other languages, they are sometimes called **nested**
    or **inner functions** .
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Local functions can be defined anywhere inside a method: the top, the bottom,
    or even somewhere in the middle!'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a local function to implement a factorial calculation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a `Factorial` function that uses
    a local function inside itself to calculate the result, as shown in the following
    code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: // method with a local function
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Factorial
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: number
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: (number < 0
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: throw
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: new
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentException(
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: $"
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: nameof
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: (number)}
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: cannot be less than zero."
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: localFactorial(number);
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: localFactorial
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: localNumber
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: // local function
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: (localNumber < 1
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: ) return
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: localNumber * localFactorial(localNumber - 1
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to call the `Factorial` function and write
    the return value to the console, as shown in the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"5! is
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '{Person.Factorial('
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: )}
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 5! is 120
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Raising and handling events
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects* . For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Events are often described as *actions that happen to an object* . For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button, and `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted` that are triggered
    when a directory or file changes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Another way of thinking of events is that they provide a way of exchanging messages
    between two objects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Events are built on **delegates** , so let's start by having a look at what
    delegates are and how they work.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods using delegates
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already seen the most common way to call or execute a method: use
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to access its `WriteLine` method.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers** , then think of a delegate as
    being a **type-safe method pointer** .
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a delegate contains the memory address of a method that matches
    the same signature as the delegate so that it can be called safely with the correct
    parameter types.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，委托包含与委托相同签名的方法的内存地址，以便可以安全地使用正确的参数类型调用它。
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下`Person`类中有一个方法，它必须传递一个`string`类型作为它唯一的参数，并返回一个`int`类型，如下面的代码所示：
- en: '```cs'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: MethodIWantToCall
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要调用的方法
- en: (
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: input
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: )
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: input.Length; // it doesn't matter what the method does
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: input.Length; // 方法的具体操作并不重要
- en: '}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以这样在名为`p1`的`Person`实例上调用这个方法：
- en: '```cs'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: answer = p1.MethodIWantToCall("Frog"
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: answer = p1.MethodIWantToCall("Frog"
- en: );
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我可以定义一个具有匹配签名的委托来间接调用方法。请注意，参数的名称不必匹配。只有参数和返回值的类型必须匹配，如下面的代码所示：
- en: '```cs'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: delegate
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: int
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: DelegateWithMatchingSignature
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 具有匹配签名的委托
- en: (
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: string
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: string
- en: s
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: )
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以创建一个委托的实例，将其指向方法，最后调用委托（调用方法），如下面的代码所示：
- en: '```cs'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // create a delegate instance that points to the method
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个委托实例，指向方法
- en: DelegateWithMatchingSignature d = new
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 具有匹配签名的委托 d = new
- en: (p1.MethodIWantToCall);
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: (p1.MethodIWantToCall);
- en: // call the delegate, which calls the method
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: // 调用委托，调用方法
- en: int
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: answer2 = d("Frog"
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 答案2 = d("Frog"
- en: );
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You are probably thinking, "What's the point of that?" Well, it provides flexibility.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“这有什么意义呢？”嗯，它提供了灵活性。
- en: For example, we could use delegates to create a queue of methods that need to
    be called in order. Queuing actions that need to be performed is common in services
    to provide improved scalability.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用委托来创建一个需要按顺序调用的方法队列。在服务中排队执行需要执行的操作是很常见的，以提供更好的可伸缩性。
- en: Another example is to allow multiple actions to perform in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    and that can provide improved responsiveness. You will learn how to do this in
    *Chapter 12* , *Improving Performance and Scalability Using Multitasking* .
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是允许多个操作并行执行。委托内置支持在不同线程上运行的异步操作，并且可以提供改进的响应性。您将在*第12章*中学习如何做到这一点，*使用多任务改进性能和可伸缩性*。
- en: The most important example is that delegates allow us to implement events for
    sending messages between different objects that do not need to know about each
    other. Events are an example of loose coupling between components because the
    components do not need to know about each other, they just need to know the event
    signature.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的例子是，委托允许我们实现事件，以在不需要相互了解的不同对象之间发送消息。事件是组件之间松散耦合的一个例子，因为组件不需要相互了解，它们只需要知道事件签名。
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don't worry if you feel lost!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件是C#中最令人困惑的特性之一，可能需要几次尝试才能理解，所以如果你感到迷茫，不要担心！
- en: Defining and handling delegates
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和处理委托
- en: 'Microsoft has two predefined delegates for use as events. Their signatures
    are simple, yet flexible, as shown in the following code:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有两个预定义的委托，用作事件。它们的签名很简单，但灵活，如下面的代码所示：
- en: '```cs'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: delegate
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: void
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: EventHandler
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler
- en: (
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? sender, EventArgs e'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '? sender, EventArgs e'
- en: )
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: public
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: delegate
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 委托
- en: void
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: EventHandler
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler
- en: <
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <
- en: TEventArgs
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: TEventArgs
- en: '>('
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '>('
- en: object
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? sender, TEventArgs e'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '? sender, TEventArgs e'
- en: )
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '```'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '**Good Practice** : When you want to define an event in your own types, you
    should use one of these two predefined delegates.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当您想在自己的类型中定义事件时，应该使用这两个预定义的委托之一。'
- en: 'Let''s explore delegates and events:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨委托和事件：
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person`类中添加语句，并注意以下几点，如下面的代码所示：
- en: It defines an `EventHandler` delegate field named `Shout` .
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Shout`的`EventHandler`委托字段。
- en: It defines an `int` field to store `AngerLevel` .
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个`int`字段来存储`AngerLevel`。
- en: It defines a method named `Poke` .
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个名为`Poke`的方法。
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null` :'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次戳一个人，他们的`AngerLevel`都会增加。一旦他们的`AngerLevel`达到三，他们就会触发`Shout`事件，但前提是代码中的某个地方定义了至少一个事件委托指向另一个方法；也就是说，它不是`null`：
- en: '```cs'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // delegate field
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: // 委托字段
- en: public
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: EventHandler? Shout;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: EventHandler? Shout;
- en: // data field
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: // 数据字段
- en: public
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: int
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: AngerLevel;
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: AngerLevel;
- en: // method
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: // 方法
- en: public
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: void
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: void
- en: Poke
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 戳
- en: ()
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: '{'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: AngerLevel++;
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: AngerLevel++;
- en: if
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (AngerLevel >= 3
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: (AngerLevel >= 3
- en: )
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // if something is listening...
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果有监听...
- en: if
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (Shout != null
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (Shout != null
- en: )
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '{'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // ...then call the delegate
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: // ...然后调用委托
- en: Shout(this
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Shout(this
- en: ', EventArgs.Empty);'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '}'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6.0 and later allows `null` checks to be simplified inline
    using a `?` symbol before the `.` operator, as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用对象的方法之前检查对象是否不为`null`是非常常见的。C# 6.0及更高版本允许使用`?`符号在`.`运算符之前内联简化`null`检查，如下面的代码所示：
- en: '```cs'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Shout?.Invoke(this
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Shout?.Invoke(this
- en: ', EventArgs.Empty);'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ', EventArgs.Empty);'
- en: '```'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'At the bottom of `Program.cs` , add a method with a matching signature that
    gets a reference to the `Person` object from the `sender` parameter and outputs
    some information about them, as shown in the following code:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Harry_Shout
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: object
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '? sender, EventArgs e'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: (sender is
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: ) return
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Person p = (Person)sender;
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '{p.Name}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'is this angry:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '{p.AngerLevel}'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: ."
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's convention for method names that handle events is `ObjectName_EventName`
    .
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to assign the method to the delegate field,
    as shown in the following code:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: harry.Shout = Harry_Shout;
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to call the `Poke` method four times, after assigning the method
    to the `Shout` event, as shown highlighted in the following code:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: harry.Shout = Harry_Shout;
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '**harry.Poke();**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**harry.Poke();**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '**harry.Poke();**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '**harry.Poke();**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, and note that Harry says nothing the first
    two times he is poked, and only gets angry enough to shout once he''s been poked
    at least three times, as shown in the following output:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Harry is this angry: 3\.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'Harry is this angry: 4.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling events
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, and then call that method and any others
    that are hooked up to the delegate field.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: But what about events? There is less to them than you might think.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so we could add more methods to the same delegate field. When the delegate
    is called, all the assigned methods are called, although you have no control over
    the order in which they are called.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Shout` delegate field was already referencing one or more methods,
    by assigning a method, it would replace all the others. With delegates that are
    used for events, we usually want to make sure that a programmer only ever uses
    either the `+=` operator or the `-=` operator to assign and remove methods:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce this, in `Person.cs` , add the `event` keyword to the delegate field
    declaration, as shown highlighted in the following code:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '**event**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: EventHandler? Shout;
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Program.cs(41,13): error CS0079: The event ''Person.Shout'' can only appear
    on the left hand side of += or -='
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    "events," but it is still good practice to indicate your meaning and that you
    expect a delegate field to be used as an event.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the method assignment to use `+=` , as shown in the following code:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: harry.Shout += Harry_Shout;
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and note that it has the same behavior as before.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2005, with C# 2.0 and .NET Framework 2.0, Microsoft introduced a feature
    named **generics** , which enables your types to be more safely reusable and more
    efficient. It does this by allowing a programmer to pass types as parameters,
    similar to how you can pass objects as parameters.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Working with non-generic types
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's look at an example of working with a non-generic type so that you
    can understand the problem that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`
    .
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.Hashtable` can be used to store multiple values each with
    a unique key that can later be used to quickly look up its value. Both the key
    and value can be any object because they are declared as `System.Object` . Although
    this provides flexibility when storing value types like integers, it is slow,
    and bugs are easier to introduce because no type checks are made when adding items.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Hashtable`可用于存储多个值，每个值都有一个唯一的键，以便以后可以快速查找其值。键和值都可以是任何对象，因为它们声明为`System.Object`。尽管这在存储整数等值类型时提供了灵活性，但它很慢，并且在添加项目时很容易引入错误，因为不进行类型检查。'
- en: 'Let''s write some code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一些代码：
- en: 'In `Program.cs` , create an instance of the non-generic collection, `System.Collections.Hashtable`
    , and then add four items to it, as shown in the following code:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个非泛型集合`System.Collections.Hashtable`的实例，然后向其中添加四个项目，如下面的代码所示：
- en: '```cs'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // non-generic lookup collection
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: // 非泛型查找集合
- en: System.Collections.Hashtable lookupObject = new
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: System.Collections.Hashtable lookupObject = new
- en: ();
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: 'lookupObject.Add(key: 1'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 1'
- en: ', value'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ，值
- en: ': "Alpha"'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Alpha"'
- en: );
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: 2'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 2'
- en: ', value'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ，值
- en: ': "Beta"'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Beta"'
- en: );
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: 3'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: 3'
- en: ', value'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Gamma"'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Gamma"'
- en: );
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupObject.Add(key: harry, value'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupObject.Add(key: harry, value'
- en: ': "Delta"'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Delta"'
- en: );
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the hash table, as shown in the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以定义一个`key`，其值为`2`，并使用它在哈希表中查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: int
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: key = 2
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: key = 2
- en: ; // lookup the value that has 2 as its key
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ; // 查找具有2作为其键的值
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: key,'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: key,'
- en: 'arg1: lookupObject[key]);'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupObject[key]);'
- en: '```'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以使用`harry`对象查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // lookup the value that has harry as its key
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: // 查找具有harry作为其键的值
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: ，
- en: 'arg0: harry,'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: harry,'
- en: 'arg1: lookupObject[harry]);'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupObject[harry]);'
- en: '```'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它的工作原理，如下面的输出所示：
- en: '```cs'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Key 2 has value: Beta'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 键2的值为：Beta
- en: 'Key Packt.Shared.Person has value: Delta'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'Key Packt.Shared.Person has value: Delta'
- en: '```'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your lookup object
    and expected all the items to be a certain type, they might cast them to that
    type and get exceptions because some values might be a different type. A lookup
    object with lots of items would also give poor performance.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码可以工作，但是由于键或值可以使用任何类型，因此存在出错的可能性。如果另一个开发人员使用您的查找对象，并且期望所有项目都是某种类型，他们可能会将它们转换为该类型并因为某些值可能是不同类型而导致异常。具有大量项目的查找对象也会导致性能不佳。
- en: '**Good Practice** : Avoid types in the `System.Collections` namespace.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：避免在`System.Collections`命名空间中使用类型。'
- en: Working with generic types
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型类型
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>` , `TKey` , and `TValue` .'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Generic.Dictionary<TKey, TValue>`可用于存储多个值，每个值都有一个唯一的键，以便以后可以快速查找其值。键和值都可以是任何对象，但是在首次实例化集合时，必须告诉编译器键和值的类型是什么。您可以通过在尖括号`<>`，`TKey`和`TValue`中指定**泛型参数**的类型来实现这一点。'
- en: '**Good Practice** : When a generic type has one definable type, it should be
    named `T` , for example, `List<T>` , where `T` is the type stored in the list.
    When a generic type has multiple definable types, they should use `T` as a name
    prefix and have a sensible name, for example, `Dictionary<TKey, TValue>` .'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：当泛型类型有一个可定义的类型时，应将其命名为`T`，例如`List<T>`，其中`T`是列表中存储的类型。当泛型类型有多个可定义的类型时，它们应该使用`T`作为名称前缀，并具有合理的名称，例如`Dictionary<TKey,
    TValue>`。'
- en: This provides flexibility, it is faster, and bugs are easier to avoid because
    type checks are made when adding items.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了灵活性，速度更快，并且更容易避免错误，因为在添加项目时进行了类型检查。
- en: 'Let''s write some code to solve the problem by using generics:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来使用泛型解决问题：
- en: 'In `Program.cs` , create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个泛型查找集合`Dictionary<TKey, TValue>`的实例，然后向其中添加四个项目，如下面的代码所示：
- en: '```cs'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: // generic lookup collection
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: // 泛型查找集合
- en: Dictionary<int
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Dictionary<int
- en: ', string'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ', string'
- en: lookupIntString = new
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: lookupIntString = new
- en: ();
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ();
- en: 'lookupIntString.Add(key: 1'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 1'
- en: ', value'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Alpha"'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Alpha"'
- en: );
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: 2'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 2'
- en: ', value'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Beta"'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Beta"'
- en: );
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: 3'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: 3'
- en: ', value'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ', value'
- en: ': "Gamma"'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Gamma"'
- en: );
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: 'lookupIntString.Add(key: harry, value'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'lookupIntString.Add(key: harry, value'
- en: ': "Delta"'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ': "Delta"'
- en: );
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '```'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在使用`harry`作为键时的编译错误，如下面的输出所示：
- en: '```cs'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: '/Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503:
    Argument 1: cannot convert from ''Packt.Shared.Person'' to ''int'' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj]'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '/Users/markjprice/Code/Chapter06/PeopleApp/Program.cs(98,32): error CS1503:
    Argument 1: cannot convert from ''Packt.Shared.Person'' to ''int'' [/Users/markjprice/Code/Chapter06/PeopleApp/PeopleApp.csproj]'
- en: '```'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Replace `harry` with `4` .
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`4`替换`harry`。
- en: 'Add statements to set the `key` to `3` and use it to look up its value in the
    dictionary, as shown in the following code:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加语句以将`key`设置为`3`，并使用它在字典中查找其值，如下面的代码所示：
- en: '```cs'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: key = 3
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: key = 3
- en: ;
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: 'WriteLine(format: "Key {0} has value: {1}"'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 'WriteLine(format: "Key {0} has value: {1}"'
- en: ','
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ','
- en: 'arg0: key,'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg0: key,'
- en: 'arg1: lookupIntString[key]);'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 'arg1: lookupIntString[key]);'
- en: '```'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and note that it works, as shown in the following output:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并注意它可以工作，如下面的输出所示：
- en: '```cs'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Key 3 has value: Gamma'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 键3的值为：Gamma
- en: '```'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Implementing interfaces
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: Interfaces are a way of connecting different types to make new things. Think
    of them like the studs on top of LEGO™ bricks, which allow them to "stick" together,
    or electrical standards for plugs and sockets.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是连接不同类型以创建新事物的一种方式。将它们视为LEGO™积木顶部的凸起，使它们可以“粘”在一起，或者是插头和插座的电气标准。
- en: If a type implements an interface, then it is making a promise to the rest of
    .NET that it supports specific functionality. This is why they are sometimes described
    as being contracts.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了接口，那么它就承诺.NET的其余部分支持特定功能。这就是为什么有时它们被描述为合同。
- en: Common interfaces
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见接口
- en: 'Here are some common interfaces that your types might need to implement:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些您的类型可能需要实现的常见接口：
- en: '| Interface | Method(s) | Description |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 方法 | 描述 |'
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| `IComparable` | `CompareTo(other)` | 这定义了一个类型实现的比较方法，用于对其实例进行排序。|'
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| `IComparer` | `Compare(first, second)` | 这定义了一个次要类型实现的比较方法，用于对主类型的实例进行排序。|'
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer (see the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `IDisposable` | `Dispose()` | 这定义了一种释放非托管资源的处理方法，比等待终结器更有效（有关更多详细信息，请参见本章后面的*释放非托管资源*部分。|'
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `IFormattable` | `ToString(format, culture)` | 这定义了一个具有文化意识的方法，将对象的值格式化为字符串表示形式。|'
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | 这定义了将对象转换为字节流并从中转换的方法，以便进行存储或传输。|'
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| `IFormatProvider` | `GetFormat(type)` | 这定义了一种根据语言和地区格式化输入的方法。|'
- en: Comparing objects when sorting
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在排序时比较对象
- en: 'One of the most common interfaces that you will want to implement is `IComparable`
    . It has one method named `CompareTo` . It has two variations, one that works
    with a nullable `object` type and one that works with a nullable generic type
    `T` , as shown in the following code:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要实现的最常见的接口之一是`IComparable`。它有一个名为`CompareTo`的方法。它有两种变体，一种适用于可空的`object`类型，一种适用于可空的泛型类型`T`，如下面的代码所示：
- en: '```cs'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: namespace
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: namespace
- en: System
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: System
- en: '{'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: interface
- en: IComparable
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: IComparable
- en: '{'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: object
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: object
- en: '? obj'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '? obj'
- en: )
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: interface
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: interface
- en: IComparable
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: IComparable
- en: <in
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: <in
- en: T
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: '>'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '{'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: int
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: CompareTo
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: CompareTo
- en: (
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: T? other
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: T? other
- en: )
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: ;
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ;
- en: '}'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` is less than the `string` being compared to or `1` if it is greater.
    The `int` type implements `IComparable` by returning `-1` if the `int` is less
    than the `int` being compared to or `1` if it is greater.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`string`类型通过返回`-1`来实现`IComparable`，如果`string`小于要比较的`string`，则返回`1`。`int`类型通过返回`-1`来实现`IComparable`，如果`int`小于要比较的`int`，则返回`1`。
- en: If a type implements one of the `IComparable` interfaces, then arrays and collections
    can sort it.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型实现了`IComparable`接口之一，则数组和集合可以对其进行排序。
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let''s see what happens when we try to sort an array of
    `Person` instances:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`Person`类实现`IComparable`接口及其`CompareTo`方法之前，让我们看看当我们尝试对`Person`实例数组进行排序时会发生什么：
- en: 'In `Program.cs` , add statements that create an array of `Person` instances
    and write the items to the console, and then attempt to sort the array and write
    the items to the console again, as shown in the following code:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，添加语句创建`Person`实例数组并将项目写入控制台，然后尝试对数组进行排序并再次将项目写入控制台，如下面的代码所示：
- en: '```cs'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: Person[] people =
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Person[] people =
- en: '{'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: new
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Simon"
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Simon"
- en: '},'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Jenny"
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Jenny"
- en: '},'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Adam"
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Adam"
- en: '},'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: new
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: () { Name = "Richard"
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: () { Name = "Richard"
- en: '}'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: WriteLine("Initial list of people:"
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("人员的初始列表："
- en: );
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: foreach
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (Person p in
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: (Person p in
- en: people)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: people)
- en: '{'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: '"'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: WriteLine("Use Person's IComparable implementation to sort:"
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine("使用Person的IComparable实现进行排序："
- en: );
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: Array.Sort(people);
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: Array.Sort(people);
- en: foreach
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: foreach
- en: (Person p in
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (Person p in
- en: people)
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: people)
- en: '{'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: WriteLine($"
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: WriteLine($"
- en: '{p.Name}'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '{p.Name}'
- en: '"'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '"'
- en: );
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Run the code and an exception will be thrown. As the message explains, to fix
    the problem, our type must implement `IComparable` , as shown in the following
    output:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会抛出异常。正如消息所解释的那样，为了解决问题，我们的类型必须实现`IComparable`，如下面的输出所示：
- en: '```cs'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: 'Unhandled Exception: System.InvalidOperationException: Failed to compare two
    elements in the array. ---> System.ArgumentException: At least one object must
    implement IComparable.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的异常：System.InvalidOperationException：无法比较数组中的两个元素。--->System.ArgumentException：至少一个对象必须实现IComparable。
- en: '```'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In `Person.cs` , after inheriting from `object` , add a comma and enter `IComparable<Person>`
    , as shown in the following code:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Person.cs`中，从`object`继承后，添加逗号并输入`IComparable<Person>`，如下面的代码所示：
- en: '```cs'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '```cs'
- en: public
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: public
- en: class
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: class
- en: Person
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: Person
- en: ': object'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ': object'
- en: ', IComparable'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ', IComparable'
- en: <Person
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: <Person
- en: '>'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '```'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you have promised to. Your code editor
    can write the skeleton implementation for you if you click on the light bulb and
    choose the **Implement interface** option.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you and delete the statement that throws the `NotImplementedException`
    error, as shown highlighted in the following code:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: CompareTo
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Person? other
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '**throw**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedException();**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a statement to call the `CompareTo` method of the `Name` field, which uses
    the `string` type''s implementation of `CompareTo` and return the result, as shown
    highlighted in the following code:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: CompareTo
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: Person? other
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: (Name is
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: ) return
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '**return**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '**Name.CompareTo(other?.Name);**'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. For
    simplicity, I have not added `null` checks throughout these examples.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that this time it works as it should, as shown in the
    following output:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial list of people:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Simon
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Jenny
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Adam
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Richard
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Person''s IComparable implementation to sort:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: Adam
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Jenny
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Richard
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Simon
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : If anyone will want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects using a separate class
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you won''t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer` :'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`
    containing a class that implements the `IComparer` interface that will compare
    two people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` field, or if the names are the same length, then by comparing
    the names alphabetically, as shown in the following code:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: PersonComparer
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: ': IComparer'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: <Person
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: Compare
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: Person? x, Person? y
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: (x is
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '|| y is'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: // Compare the Name lengths...
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: result = x.Name.Length.CompareTo(y.Name.Length);
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: // ...if they are equal...
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: (result == 0
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: // ...then compare by the Names...
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: x.Name.CompareTo(y.Name);
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: else
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: // result will be -1 or 1
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: // ...otherwise compare by the lengths.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: result;
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to sort the array using this alternative implementation,
    as shown in the following code:'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Use PersonComparer's IComparer implementation to sort:"
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Array.Sort(people, new
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: PersonComparer());
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: (Person p in
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: people)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '{p.Name}'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-811
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'Use PersonComparer''s IComparer implementation to sort:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: Adam
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: Jenny
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: Simon
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: Richard
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead, so that the people are sorted with the
    shortest names first, like Adam, and the longest names last, like Richard; and
    when the lengths of two or more names are equal, to sort them alphabetically,
    like Jenny and Simon.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit interface implementations
  id: totrans-820
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. In
    a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    that works, but if not then the other `Lose` method will have to be implemented
    differently and called explicitly, as shown in the following code:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: IGamePlayer
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: Lose
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: IKeyHolder
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: Lose
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Person
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: ': IGamePlayer'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: ', IKeyHolder'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Lose
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: // implicit implementation
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: // implement losing a key
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: IGamePlayer.Lose() // explicit implementation
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: // implement losing a game
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: // calling implicit and explicit implementations of Lose
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Person p = new
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: p.Lose(); // calls implicit implementation of losing a key
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: ((IGamePlayer)p).Lose(); // calls explicit implementation of losing a game
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: IGamePlayer player = p as
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: IGamePlayer;
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: player.Lose(); // calls explicit implementation of losing a game
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces with default implementations
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A language feature introduced in C# 8.0 is **default implementations** for
    an interface. Let''s see it in action:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new file named `IPlayable.cs` .
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements to define a public `IPlayable` interface with two methods
    to `Play` and `Pause` , as shown in the following code:'
  id: totrans-874
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: IPlayable
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: Play
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: Pause
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs` .
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the statements in the file to implement the `IPlayable` interface, as
    shown in the following code:'
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: DvdPlayer
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: ': IPlayable'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Pause
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("DVD player is pausing."
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: Play
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("DVD player is playing."
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: This is useful, but what if we decide to add a third method named `Stop` ? Before
    C# 8.0, this would be impossible once at least one type implements the original
    interface. One of the main points of an interface is that it is a fixed contract.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: C# 8.0 allows an interface to add new members after release as long as they
    have a default implementation. C# purists do not like the idea, but for practical
    reasons, such as avoiding breaking changes or having to define a whole new interface,
    it is useful, and other languages such as Java and Swift enable similar techniques.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5.0 or later, .NET Core 3.0 or later, or .NET Standard 2.1\. They are
    therefore not supported by .NET Framework.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as shown highlighted in the following code:'
  id: totrans-928
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '**using**'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '**static**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Console;**'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: IPlayable
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Play
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Pause
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '**void**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '**()**'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '**// default interface implementation**'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '**"Default implementation of Stop."**'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: Build the `PeopleApp` project and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop` . In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing memory with reference and value types
  id: totrans-960
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have mentioned reference types a couple of times. Let's look at them in more
    detail.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of memory: **stack** memory and **heap** memory. With
    modern operating systems, the stack and heap can be anywhere in physical or virtual
    memory.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: Stack memory is faster to work with (because it is managed directly by the CPU
    and because it uses a last-in, first-out mechanism, it is more likely to have
    the data in its L1 or L2 cache) but limited in size, while heap memory is slower
    but much more plentiful.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a macOS terminal, I can enter the command `ulimit -a` to discover
    that the stack size is limited to 8,192 KB and that other memory is "unlimited."
    This limited amount of stack memory is why it is so easy to fill it up and get
    a "stack overflow."
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: Defining reference and value types
  id: totrans-965
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three C# keywords that you can use to define object types: `class`
    , `record` , and `struct` . All can have the same members, such as fields and
    methods. One difference between them is how memory is allocated.'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: When you define a type using `record` or `class` , you are defining a **reference
    type** . This means that the memory for the object itself is allocated on the
    heap, and only the memory address of the object (and a little overhead) is stored
    on the stack.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: When you define a type using `record struct` or `struct` , you are defining
    a **value type** . This means that the memory for the object itself is allocated
    on the stack.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: If a `struct` uses field types that are not of the `struct` type, then those
    fields will be stored on the heap, meaning the data for that object is stored
    in both the stack and the heap!
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common struct types:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '**Number** `System` **types** : `byte` , `sbyte` , `short` , `ushort` , `int`
    , `uint` , `long` , `ulong` , `float` , `double` , and `decimal`'
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other** `System` **types** : `char` , `DateTime` , and `bool`'
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Drawing` **types** : `Color` , `Point` , and `Rectangle`'
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all the other types are `class` types, including `string` .
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the difference in terms of where in memory the data for a type is
    stored, the other major difference is that you cannot inherit from a `struct`
    .
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: How reference and value types are stored in memory
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have a console app that declares some variables, as shown
    in the following code:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: number1 = 49
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: long
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: number2 = 12
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: System.Drawing.Point location = new
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '(x: 4'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: ', y: 5'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: Person kevin = new
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Kevin"
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 1988'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 9'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 23'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: ) };
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: Person sally;
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review what memory is allocated on the stack and heap when these statements
    execute, as shown in *Figure 6.1* and as described in the following list:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: The `number1` variable is a value type (also known as `struct` ) so it is allocated
    on the stack and it uses 4 bytes of memory since it is a 32-bit integer. Its value,
    49, is stored directly in the variable.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `number2` variable is also a value type so it is also allocated on the stack,
    and it uses 8 bytes since it is a 64-bit integer.
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `location` variable is also a value type so it is allocated on the stack
    and it uses 8 bytes since it is made up of two 32-bit integers, `x` and `y` .
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `kevin` variable is a reference type (also known as `class` ) so 8 bytes
    for a 64-bit memory address (assuming a 64-bit operating system) is allocated
    on the stack and enough bytes on the heap to store an instance of a `Person` .
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sally` variable is a reference type so 8 bytes for a 64-bit memory address
    is allocated on the stack. It is currently `null` , meaning no memory has yet
    been allocated for it on the heap.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Image00069.jpg)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: How value and reference types are allocated in the stack and heap'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: All the allocated memory for a reference type is stored on the heap. If a value
    type such as `DateTime` is used for a field of a reference type like `Person`
    , then the `DateTime` value is stored on the heap.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: If a value type has a field that is a reference type, then that part of the
    value type is stored on the heap. `Point` is a value type that consists of two
    fields, both of which are themselves value types, so the entire object can be
    allocated on the stack. If the `Point` value type had a field that was a reference
    type, like `string` , then the `string` bytes would be stored on the heap.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: Equality of types
  id: totrans-1009
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to compare two variables using the `==` and `!=` operators. The
    behavior of these two operators is different for reference types and value types.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check the equality of two value type variables, .NET literally compares
    the values of those two variables on the stack and returns `true` if they are
    equal, as shown in the following code:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: a = 3
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: b = 3
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"a == b:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '{(a == b)}'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: ); // true
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'When you check the equality of two reference type variables, .NET compares
    the memory addresses of those two variables and returns `true` if they are equal,
    as shown in the following code:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: Person a = new
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Kevin"
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Person b = new
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Kevin"
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"a == b:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '{(a == b)}'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: ); // false
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because they are not the same object. If both variables literally point
    to the same object on the heap, then they would be equal, as shown in the following
    code:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Person a = new
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: () { Name = "Kevin"
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: Person b = a;
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"a == b:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '{(a == b)}'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: ); // true
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'The one exception to this behavior is the `string` type. It is a reference
    type, but the equality operators have been overridden to make them behave as if
    they were value types, as shown in the following code:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: a = "Kevin"
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: b = "Kevin"
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"a == b:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '{(a == b)}'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: ); // true
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: You can do something similar with your classes to make the equality operators
    return `true` even if they are not the same object (same memory address on the
    heap) but instead if their fields have the same values, but that is beyond the
    scope of this book. Alternatively, use a `record class` because one of their benefits
    is that they implement this behavior for you.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Defining struct types
  id: totrans-1062
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore defining your own value types:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a file named `DisplacementVector.cs` .
  id: totrans-1064
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the file, as shown in the following code, and note the following:'
  id: totrans-1065
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The type is declared using `struct` instead of `class` .
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has two `int` fields, named `X` and `Y` .
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a constructor for setting initial values for `X` and `Y` .
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an operator for adding two instances together that returns a new instance
    of the type with `X` added to `X` , and `Y` added to `Y` .
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: struct
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: X;
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: Y;
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: initialX,
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: initialY
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: X = initialX;
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: Y = initialY;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector operator
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: +(
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector vector1,
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector vector2)
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: new
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: vector1.X + vector2.X,
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: vector1.Y + vector2.Y);
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create two new instances of `DisplacementVector`
    , add them together, and output the result, as shown in the following code:'
  id: totrans-1111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector dv1 = new
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: (3
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: ', 5'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector dv2 = new
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: (-2
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: ', 7'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector dv3 = dv1 + dv2;
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"(
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: '{dv1.X}'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: '{dv1.Y}'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: ) + (
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: '{dv2.X}'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '{dv2.Y}'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: ) = (
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '{dv3.X}'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '{dv3.Y}'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: )"
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: (3, 5) + (-2, 7) = (1, 12)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : If the total bytes used by all the fields in your type
    is 16 bytes or less, your type only uses value types for its fields, and you will
    never want to derive from your type, then Microsoft recommends that you use `struct`
    . If your type uses more than 16 bytes of stack memory, if it uses reference types
    for its fields, or if you might want to inherit from it, then use `class` .'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: Working with record struct types
  id: totrans-1142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# 10 introduced the ability to use the `record` keyword with `struct` types
    as well as with class types.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: 'We could define the `DisplacementVector` type, as shown in the following code:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: record
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: struct
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: DisplacementVector
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: X,
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: Y
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'With this change, Microsoft recommends explicitly specifying `class` if you
    want to define a `record class` even though the `class` keyword is optional, as
    shown in the following code:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: record
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: ImmutableAnimal
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Name
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: Releasing unmanaged resources
  id: totrans-1170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we saw that constructors can be used to initialize
    fields and that a type may have multiple constructors. Imagine that a constructor
    allocates an unmanaged resource; that is, anything that is not controlled by .NET,
    such as a file or mutex under the control of the operating system. The unmanaged
    resource must be manually released because .NET cannot do it for us using its
    automatic garbage collection feature.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection is an advanced topic, so for this topic, I will show some
    code examples, but you do not need to write the code yourself.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: Each type can have a single **finalizer** that will be called by the .NET runtime
    when the resources need to be released. A finalizer has the same name as a constructor;
    that is, the type name, but it is prefixed with a tilde, `~` .
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not confuse a finalizer (also known as a **destructor** ) with a `Deconstruct`
    method. A destructor releases resources; that is, it destroys an object in memory.
    A `Deconstruct` method returns an object split up into its constituent parts and
    uses the C# deconstruction syntax, for example, when working with tuples:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: Animal
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: Animal
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: // constructor
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: // allocate any unmanaged resources
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: ~Animal() // Finalizer aka destructor
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: // deallocate any unmanaged resources
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code example is the minimum you should do when working with unmanaged
    resources. But the problem with only providing a finalizer is that the .NET garbage
    collector requires two garbage collections to completely release the allocated
    resources for this type.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: Though optional, it is recommended to also provide a method to allow a developer
    who uses your type to explicitly release resources so that the garbage collector
    can release managed parts of an unmanaged resource, such as a file, immediately
    and deterministically, and then release the managed memory part of the object
    in a single garbage collection instead of two rounds of garbage collection.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard mechanism for doing this by implementing the `IDisposable`
    interface, as shown in the following example:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: Animal
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: ': IDisposable'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: Animal
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: // allocate unmanaged resource
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: ~Animal() // Finalizer
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Dispose(false
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: bool
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: disposed = false
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: ; // have resources been released?
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: Dispose
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: Dispose(true
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: // tell garbage collector it does not need to call the finalizer
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: GC.SuppressFinalize(this
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: protected
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: Dispose
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: bool
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: disposing
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: (disposed) return
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: // deallocate the *unmanaged* resource
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: (disposing)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: // deallocate any other *managed* resources
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: // ...
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: disposed = true
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two `Dispose` methods, one `public` and one `protected` :'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: The `public void Dispose` method will be called by a developer using your type.
    When called, both unmanaged and managed resources need to be deallocated.
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `protected virtual void Dispose` method with a `bool` parameter is used
    internally to implement the deallocation of resources. It needs to check the `disposing`
    parameter and `disposed` field because if the finalizer thread has already run
    and it called the `~Animal` method, then only unmanaged resources need to be deallocated.
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `GC.SuppressFinalize(this)` is what notifies the garbage collector
    that it no longer needs to run the finalizer, and removes the need for a second
    garbage collection.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that Dispose is called
  id: totrans-1256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When someone uses a type that implements `IDisposable` , they can ensure that
    the public `Dispose` method is called with the `using` statement, as shown in
    the following code:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: (Animal a = new
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: ())
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: // code that uses the Animal instance
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler converts your code into something like the following, which guarantees
    that even if an exception occurs, the `Dispose` method will still be called:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Animal a = new
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: try
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: // code that uses the Animal instance
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: finally
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: (a != null
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: ) a.Dispose();
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: You will see practical examples of releasing unmanaged resources with `IDisposable`
    , `using` statements, and `try` ...`finally` blocks in *Chapter 9* , *Working
    with Files, Streams, and Serialization* .
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: Working with null values
  id: totrans-1282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to store primitive values like numbers in `struct` variables.
    But what if a variable does not yet have a value? How can we indicate that? C#
    has the concept of a `null` value, which can be used to indicate that a variable
    has not been set.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type nullable
  id: totrans-1284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, value types like `int` and `DateTime` must always have a value,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or null values, it is convenient to allow a value
    type to be `null` . We call this a **nullable value type** .
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **Console Application** to the `Chapter06`
    workspace/solution named `NullHandling` . This section requires a full application
    with a project file, so you will not be able to use a .NET Interactive notebook.
  id: totrans-1288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `NullHandling` as the active OmniSharp project.
    In Visual Studio, set `NullHandling` as the startup project.
  id: totrans-1289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , type statements to declare and assign values, including `null`
    , to `int` variables, as shown in the following code:'
  id: totrans-1290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: thisCannotBeNull  = 4
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: thisCannotBeNull = null
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: ; // compile error!
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '? thisCouldBeNull = null'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(thisCouldBeNull);
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(thisCouldBeNull.GetValueOrDefault());
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: thisCouldBeNull = 7
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(thisCouldBeNull);
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(thisCouldBeNull.GetValueOrDefault());
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: Comment out the statement that gives a compile error.
  id: totrans-1307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: The first line is blank because it is outputting the `null` value!
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nullable reference types
  id: totrans-1315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. But there are many scenarios
    where we could write better, simpler code if a variable is not allowed to have
    a `null` value.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: The most significant change to the language in C# 8 was the introduction of
    nullable and non- nullable reference types. "But wait!", you are probably thinking,
    "Reference types are already nullable!"
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to no longer allow the `null` value by setting a file- or project-level option
    to enable this useful new feature. Since this is a big change for C#, Microsoft
    decided to make the feature opt-in.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: It will take multiple years for this new C# language feature to make an impact
    since thousands of existing library packages and apps will expect the old behavior.
    Even Microsoft did not have time to fully implement this new feature in all the
    main .NET packages until .NET 6.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '**Default** : No changes are needed. Non-nullable reference types are not supported.'
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in project, opt-out files** : Enable the feature at the project level
    and, for any files that need to remain compatible with old behavior, opt out.
    This is the approach Microsoft is using internally while it updates its own packages
    to use this new feature.'
  id: totrans-1322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in files** : Only enable the feature for individual files.'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling nullable and non-nullable reference types
  id: totrans-1324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the feature at the project level, add the following to your project
    file:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: This is now done by default in project templates that target .NET 6.0.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '#nullable disable'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the feature at the file level, add the following to the top of a
    code file:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: '#nullable enable'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: Declaring non-nullable variables and parameters
  id: totrans-1341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enable nullable reference types and you want a reference type to be assigned
    the `null` value, then you will have to use the same syntax as making a value
    type nullable, that is, adding a `?` symbol after the type declaration.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do nullable reference types work? Let''s look at an example. When storing
    information about an address, you might want to force a value for the street,
    city, and region, but the building can be left blank, that is, `null` :'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: 'In `NullHandling.csproj` , in `Program.cs` , at the bottom of the file, add
    statements to declare an `Address` class with four fields, as shown in the following
    code:'
  id: totrans-1344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: Address
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '? Building;'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: Street;
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: City;
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: Region;
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2* :![Graphical user interface, text,
    application, chat or text message Description automatically generated](img/Image00070.jpg)
  id: totrans-1363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.2: Warning messages about non-nullable fields in the PROBLEMS window'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the empty `string` value to each of the three fields that are non-nullable,
    as shown in the following code:'
  id: totrans-1365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: Street = string
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: .Empty;
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: City = string
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: .Empty;
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: Region = string
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: .Empty;
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , at the top of the file, statically import `Console` and then
    add statements to instantiate an `Address` and set its properties, as shown in
    the following code:'
  id: totrans-1380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: Address address = new
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: address.Building = null
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: address.Street = null
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: address.City = "London"
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: address.Region = null
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: Note the warnings, as shown in *Figure 6.3* :![Graphical user interface, text,
    application, chat or text message, email Description automatically generated](img/Image00071.jpg)
  id: totrans-1393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.3: Warning message about assigning null to a non-nullable field'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: So, this is why the new language feature is named nullable reference types.
    Starting with C# 8.0, unadorned reference types can become non-nullable, and the
    same syntax is used to make a reference type nullable as is used for value types.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  id: totrans-1396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking whether a nullable reference type or nullable value type variable
    currently contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: // check that the variable is not null before using it
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: (thisCouldBeNull != null
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: // access a member of thisCouldBeNull
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: length = thisCouldBeNull.Length; // could throw exception
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 7 introduced `is` combined with the `!` (not) operator as an alternative
    to `!=` , as shown in the following code:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: (!(thisCouldBeNull is
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: ))
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: (thisCouldBeNull is
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: not
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are trying to use a member of a variable that might be `null` , use
    the null-conditional operator `?.` , as shown in the following code:'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: authorName = null
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: // the following throws a NullReferenceException
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: x = authorName.Length;
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: // instead of throwing an exception, null is assigned to y
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '? y = authorName?.Length;'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you want to either assign a variable to a result or use an alternative
    value, such as `3` , if the variable is `null` . You do this using the null-coalescing
    operator, `??` , as shown in the following code:'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: // result will be 3 if authorName?.Length is null
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: int
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: result = authorName?.Length ?? 3
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine(result);
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Even if you enable nullable reference types, you should
    still check non-nullable parameters for `null` and throw an `ArgumentNullException`
    .'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null in method parameters
  id: totrans-1448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When defining methods with parameters, it is good practice to check for `null`
    values.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null` , as shown in the following code:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: Hire
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Person manager, Person employee
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: (manager == null
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: throw
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: new
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentNullException(nameof
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: (manager));
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: (employee == null
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: throw
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: new
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentNullException(nameof
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: (employee));
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 11 might introduce a new `!!` suffix that does this for you, as shown in
    the following code:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: Hire
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: Person manager!!, Person employee!!
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement and throwing of the exception are done for you.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from classes
  id: totrans-1493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Person` type we created earlier derived (inherited) from `object` , the
    alias for `System.Object` . Now, we will create a subclass that inherits from
    `Person` :'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs` .
  id: totrans-1495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`
    , as shown in the following code:'
  id: totrans-1496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: System;
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: Employee
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: ': Person'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create an instance of the `Employee` class,
    as shown in the following code:'
  id: totrans-1510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: Employee john = new
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: Name = "John Jones"
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 1990'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 7'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 28'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: john.WriteToConsole();
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: John Jones was born on a Saturday.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Employee` class has inherited all the members of `Person` .
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes to add functionality
  id: totrans-1530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will add some employee-specific members to extend the class.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs` , add statements to define two properties for an employee
    code and the date they were hired, as shown in the following code:'
  id: totrans-1532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '? EmployeeCode { get'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: DateTime HireDate { get
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to set John''s employee code and hire date,
    as shown in the following code:'
  id: totrans-1544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: john.EmployeeCode = "JJ001"
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: john.HireDate = new
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 2014'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 11'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 23'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '{john.Name}'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: was hired on
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '{john.HireDate:dd/MM/yy}'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: John Jones was hired on 23/11/14
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: Hiding members
  id: totrans-1564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the `WriteToConsole` method is inherited from `Person` , and it only
    outputs the employee''s name and date of birth. We might want to change what this
    method does for an employee:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs` , add statements to redefine the `WriteToConsole` method,
    as shown highlighted in the following code:'
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: '**using**'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '**static**'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Console;**'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: Employee
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: ': Person'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '? EmployeeCode { get'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: DateTime HireDate { get
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '**void**'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteToConsole**'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: '**()**'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(format:**'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '**"{0} was born on {1:dd/MM/yy} and hired on {2:dd/MM/yy}"**'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: '**,**'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: '**arg0: Name,**'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: '**arg1: DateOfBirth,**'
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '**arg2: HireDate);**'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: John Jones was born on 28/07/90 and hired on 01/01/01
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: John Jones was hired on 23/11/14
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: 'Your coding tool warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS** /**Error List**
    window includes more details, and the compiler will output the warning when you
    build and run the console application, as shown in *Figure 6.4* :'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00072.jpg)'
  id: totrans-1608
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Hidden method warning'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: 'As the warning describes, you can hide this message by applying the `new` keyword
    to the method, to indicate that you are deliberately replacing the old method,
    as shown highlighted in the following code:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: WriteToConsole
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: Overriding members
  id: totrans-1618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override if the base class chooses to allow overriding, by applying the `virtual`
    keyword to any methods that should allow overriding.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  id: totrans-1621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(john.ToString());
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the `ToString` method is inherited from `System.Object`
    , so the implementation returns the namespace and type name, as shown in the following
    output:'
  id: totrans-1625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared.Employee
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , override this behavior by adding a `ToString` method to output
    the name of the person as well as the type name, as shown in the following code:'
  id: totrans-1629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: // overridden methods
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: override
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: $"
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: is a
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: base
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: .ToString()}
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: The `base` keyword allows a subclass to access members of its superclass; that
    is, the **base class** that it inherits or derives from.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result. Now, when the `ToString` method is called,
    it outputs the person''s name, as well as returning the base class''s implementation
    of `ToString` , as shown in the following output:'
  id: totrans-1650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: John Jones is a Packt.Shared.Employee
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Many real-world APIs, for example, Microsoft''s Entity
    Framework Core, Castle''s DynamicProxy, and Episerver''s content models, require
    the properties that you define in your classes to be marked as `virtual` so that
    they can be overridden. Carefully decide which of your method and property members
    should be marked as `virtual` .'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from abstract classes
  id: totrans-1655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: In those earlier platforms, you could use abstract classes as a sort of halfway
    house between a pure interface and a fully implemented class.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: When a class is marked as `abstract` , this means that it cannot be instantiated
    because you are indicating that the class is not complete. It needs more implementation
    before it can be instantiated.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.IO.Stream` class is abstract because it implements
    common functionality that all streams would need but is not complete, so you cannot
    instantiate it using `new Stream()` .
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the two types of interface and two types of class, as shown
    in the following code:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: INoImplementation
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: // C# 1.0 and later
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: ; // must be implemented by derived type
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: interface
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: ISomeImplementation
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: // C# 8.0 and later
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: ; // must be implemented by derived type
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: Beta
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: // default implementation; can be overridden
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: abstract
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: PartiallyImplemented
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: // C# 1.0 and later
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: abstract
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: Gamma
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: ; // must be implemented by derived type
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: Delta
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: // can be overridden
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: // implementation
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: FullyImplemented
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: ': PartiallyImplemented'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: ', ISomeImplementation'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: // implementation
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: override
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: Gamma
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: // implementation
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: // you can only instantiate the fully implemented class
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: FullyImplemented a = new
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: ();
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: // all the other types give compile errors
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: PartiallyImplemented b = new
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: (); // compile error!
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: ISomeImplementation c = new
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: (); // compile error!
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: INoImplementation d = new
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: (); // compile error!
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: Preventing inheritance and overriding
  id: totrans-1744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. No one can inherit from Scrooge McDuck,
    as shown in the following code:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: sealed
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: ScroogeMcDuck
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. No one can change the way
    Lady Gaga sings, as shown in the following code:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: Singer
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: // virtual allows this method to be overridden
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: Sing
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Singing..."
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: LadyGaga
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: ': Singer'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: // sealed prevents overriding the method in subclasses
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: sealed
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: override
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: Sing
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Singing with style..."
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: You can only seal an overridden method.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  id: totrans-1797
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**
    ), or we can *override* it (known as **polymorphic inheritance** ).
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person` .
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this could affect your code:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs` , add statements to override the `ToString` method so it writes
    the employee''s name and code to the console, as shown in the following code:'
  id: totrans-1802
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: override
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: ToString
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: $"
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '{Name}'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: '''s code is'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: '{EmployeeCode}'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , write statements to create a new employee named Alice, store
    it in a variable of type `Person` , and call both variables'' `WriteToConsole`
    and `ToString` methods, as shown in the following code:'
  id: totrans-1819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: Employee aliceInEmployee = new
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '{ Name = "Alice"'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: ', EmployeeCode = "AA123"'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: Person aliceInPerson = aliceInEmployee;
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: aliceInEmployee.WriteToConsole();
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: aliceInPerson.WriteToConsole();
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(aliceInEmployee.ToString());
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(aliceInPerson.ToString());
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: Alice was born on 01/01/01 and hired on 01/01/01
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: Alice was born on a Monday
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: Alice's code is AA123
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: Alice's code is AA123
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: When a method is hidden with `new` , the compiler is not smart enough to know
    that the object is an `Employee` , so it calls the `WriteToConsole` method in
    `Person` .
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: When a method is overridden with `virtual` and `override` , the compiler is
    smart enough to know that although the variable is declared as a `Person` class,
    the object itself is an `Employee` class and, therefore, the `Employee` implementation
    of `ToString` is called.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: 'The member modifiers and the effect they have are summarized in the following
    table:'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable type | Member modifier | Method executed | In class |'
  id: totrans-1842
  prefs: []
  type: TYPE_TB
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  id: totrans-1843
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  id: totrans-1844
  prefs: []
  type: TYPE_TB
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  id: totrans-1845
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  id: totrans-1846
  prefs: []
  type: TYPE_TB
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that's cool; but, if not, I suggest that you don't worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers to learn, but IMHO it's not.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn't need to be able to explain the
    engineering behind fuel injection.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  id: totrans-1850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting between types is subtly different from converting between types. Casting
    is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. Converting is between dissimilar
    types, such as between text and a number.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: Implicit casting
  id: totrans-1852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base's base type, and so on). When we do
    this, it is called **implicit casting** .
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting
  id: totrans-1854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going the other way is an explicit cast, and you must use parentheses around
    the type you want to cast into as a prefix to do it:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  id: totrans-1856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: Employee explicitAlice = aliceInPerson;
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: Your coding tool displays a red squiggle and a compile error, as shown in *Figure
    6.5* :![Graphical user interface, text, application, email, website Description
    automatically generated](img/Image00073.jpg)
  id: totrans-1860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.5: A missing explicit cast compile error'
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the statement to prefix the assigned variable named with a cast to the
    `Employee` type, as shown in the following code:'
  id: totrans-1862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: Employee explicitAlice = (Employee)aliceInPerson;
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding casting exceptions
  id: totrans-1866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is now happy; but, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee` , we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the explicit cast statement in an `if` statement, as shown highlighted
    in the following code:'
  id: totrans-1869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '**(aliceInPerson**'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: '**is**'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '**Employee)**'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: '**$"**'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: '**nameof**'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '**(aliceInPerson)}**'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '**IS an Employee"**'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: Employee explicitAlice = (Employee)aliceInPerson;
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: '**// safely do something with explicitAlice**'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1887
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: aliceInPerson IS an Employee
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simplify the code further using a declaration pattern and this will
    avoid needing to perform an explicit cast, as shown in the following code:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: (aliceInPerson is
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: Employee explicitAlice)
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: nameof
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: (aliceInPerson)}
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: IS an Employee"
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
- en: // safely do something with explicitAlice
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the `as` keyword to cast. Instead of throwing an
    exception, the `as` keyword returns `null` if the type cannot be cast.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Main` , add the statements to cast Alice using the `as` keyword and then
    check whether the return value is not null, as shown in the following code:'
  id: totrans-1907
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: Employee? aliceAsEmployee = aliceInPerson as
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: Employee; // could be null
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: (aliceAsEmployee != null
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: nameof
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: (aliceInPerson)}
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: AS an Employee"
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: // safely do something with aliceAsEmployee
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-1925
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: aliceInPerson AS an Employee
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to execute a block of statements when Alice is not an employee?
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: (!(aliceInPerson is
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
- en: Employee))
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: (aliceInPerson is
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: not
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
- en: Employee)
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use the `is` and `as` keywords to avoid throwing exceptions
    when casting between derived types. If you don''t do this, you must write `try`
    -`catch` statements for `InvalidCastException` .'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  id: totrans-1944
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has prebuilt class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft's types to inherit some or all of its behavior
    and then overriding or extending it.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting exceptions
  id: totrans-1946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of inheritance, we will derive a new type of exception:'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`
    .
  id: totrans-1948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  id: totrans-1949
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: PersonException
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: ': Exception'
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
- en: PersonException
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
- en: '() :'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: base
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: ()
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: '{ }'
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: PersonException
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: message
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: ') :'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: base
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: message
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
- en: '{ }'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: PersonException
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: message, Exception innerException
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
- en: base
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: message, innerException
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: '{ }'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the base constructor implementations in `System.Exception`
    to make them available to programmers who might want to use those constructors
    with our custom exception.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs` , add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person''s date of birth, as shown in
    the following code:'
  id: totrans-1991
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
- en: TimeTravel
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: DateTime
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: when
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: if
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: (when
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: <= DateOfBirth)
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: throw
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
- en: new
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: PersonException("If you travel back in time to a date earlier than your own
    birth, then the universe will explode!"
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: else
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Welcome to
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
- en: when
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: :yyyy}
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: '!"'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to test what happens when employee John Jones
    tries to time travel too far back, as shown in the following code:'
  id: totrans-2021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
- en: try
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: john.TimeTravel(when
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: ': new'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: (1999
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: ', 12'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: ', 31'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
- en: john.TimeTravel(when
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: ': new'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: (1950
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: ', 12'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: ', 25'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: ));
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: catch (PersonException ex)
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(ex.Message);
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-2043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to 1999!
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: If you travel back in time to a date earlier than your own birth, then the universe
    will explode!
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones.'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
- en: Extending types when you can't inherit
  id: totrans-2049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods** , which was introduced with C# 3.0.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: Using static methods to reuse functionality
  id: totrans-2053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the first version of C#, we've been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8* , *Working with Common .NET Types* .
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class named `StringExtensions` , as
    shown in the following code, and note the following:'
  id: totrans-2056
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class imports a namespace for handling regular expressions.
  id: totrans-2057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IsValidEmail` method is `static` and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol.
  id: totrans-2058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.RegularExpressions;
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: StringExtensions
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: bool
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
- en: IsValidEmail
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
- en: input
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: // use simple regular expression to check
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: // that the input string is a valid email
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: return
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: Regex.IsMatch(input,
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: '@"[a-zA-Z0-9\.-_]+@[a-zA-Z0-9\.-_]+"'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to validate two examples of email addresses,
    as shown in the following code:'
  id: totrans-2087
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: email1 = "pamela@test.com"
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: email2 = "ian&test.com"
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: ;
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: email1,'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: StringExtensions.IsValidEmail(email1));'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: email2,'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: StringExtensions.IsValidEmail(email2));'
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  id: totrans-2104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
- en: 'pamela@test.com is a valid e-mail address: True'
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
- en: 'ian&test.com is a valid e-mail address: False'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: Using extension methods to reuse functionality
  id: totrans-2110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is easy to make `static` methods into extension methods:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
- en: 'In `StringExtensions.cs` , add the `static` modifier before the class, and
    add the `this` modifier before the `string` type, as highlighted in the following
    code:'
  id: totrans-2112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
- en: '**static**'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
- en: StringExtensions
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: bool
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
- en: IsValidEmail
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
- en: '**this**'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
- en: input
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: These two changes tell the compiler that it should treat the method as one that
    extends the `string` type.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  id: totrans-2131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: email1,'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: email1.IsValidEmail());'
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0} is a valid e-mail address: {1}"'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: email2,'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: email2.IsValidEmail());'
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: Note the subtle simplification in the syntax for calling the `IsValidEmail`
    method. The older, longer syntax still works too.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
- en: The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized` and `Insert`
    , as shown in *Figure 6.6* :![Graphical user interface, text, application Description
    automatically generated](img/Image00074.jpg)
  id: totrans-2143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.6: Extension methods appear in IntelliSense alongside instance methods'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the result, which will be the same as before.
  id: totrans-2145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11* , *Querying and Manipulating Data Using LINQ* , you will see some extremely
    powerful uses of extension methods.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
- en: Using an analyzer to write better code
  id: totrans-2148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET analyzers find potential issues and suggest fixes for them. **StyleCop**
    is a commonly used analyzer for helping you write better C# code.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see it in action, advising how to improve the code in the project template
    for a console app when targeting .NET 5.0 so that the console app already has
    a `Program` class with a `Main` method:'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  id: totrans-2151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console -f net5.0`'
  id: totrans-2152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter06`'
  id: totrans-2153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `CodeAnalyzing`'
  id: totrans-2154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Target framework: **.NET 5.0 (Current)**'
  id: totrans-2155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `CodeAnalyzing` project, add a package reference for `StyleCop.Analyzers`
    .
  id: totrans-2156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a JSON file to your project named `stylecop.json` for controlling StyleCop
    settings.
  id: totrans-2157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents, as shown in the following markup:'
  id: totrans-2158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
- en: '"$schema"'
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: '"settings"'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: The `$schema` entry enables IntelliSense while editing the `stylecop.json` file
    in your code editor.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the project file, change the target framework to `net6.0` , add entries
    to configure the file named `stylecop.json` to not be included in published deployments,
    and to enable it as an additional file for processing during development, as shown
    highlighted in the following markup:'
  id: totrans-2170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: '**<ItemGroup>**'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: '**<None Remove=**'
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: '**"stylecop.json"**'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: '**</ItemGroup>**'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: '**<ItemGroup>**'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: '**<AdditionalFiles Include=**'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
- en: '**"stylecop.json"**'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '**/>**'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
- en: '**</ItemGroup>**'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference Include="StyleCop.Analyzers"
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: Version="1.2.0-*"
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: <PrivateAssets>all</PrivateAssets>
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
- en: </PackageReference>
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: Build your project.
  id: totrans-2199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see warnings for everything it thinks is wrong, as shown in *Figure
    6.7* :![](img/Image00075.jpg)
  id: totrans-2200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.7: StyleCop code analyzer warnings'
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it wants `using` directives to be put within the namespace declaration,
    as shown in the following output:'
  id: totrans-2202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: 'C:\Code\Chapter06\CodeAnalyzing\Program.cs(1,1): warning SA1200: Using directive
    should appear within a namespace declaration [C:\Code\Chapter06\CodeAnalyzing\CodeAnalyzing.csproj]'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing warnings
  id: totrans-2206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To suppress a warning, you have several options, including adding code and setting
    configuration.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
- en: 'To suppress using an attribute, as shown in the following code:'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: '[assembly:SuppressMessage('
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: '"StyleCop.CSharp.OrderingRules"'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: '"SA1200:UsingDirectivesMustBePlacedWithinNamespace"'
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: ', Justification ='
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: '"Reviewed."'
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: 'To suppress using a directive, as shown in the following code:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: pragma
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: warning
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: disable SA1200 // UsingDirectivesMustBePlacedWithinNamespace
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: System;
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
- en: pragma
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
- en: warning
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: restore SA1200 // UsingDirectivesMustBePlacedWithinNamespace
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppress the warning by modifying the `stylecop.json` file:'
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: 'In `stylecop.json` , add a configuration option to set `using` statements to
    be allowable outside a namespace, as shown highlighted in the following markup:'
  id: totrans-2233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '"$schema"'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: '"settings"'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: '"orderingRules"'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: '"usingDirectivesPlacement"'
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: ': "outsideNamespace"'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
- en: Build the project and note that warning SA1200 has disappeared.
  id: totrans-2249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `stylecop.json` , set the using directives placement to `preserve` , which
    allows `using` statements both inside and outside a namespace, as shown in the
    following markup:'
  id: totrans-2250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: '"orderingRules"'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
- en: '"usingDirectivesPlacement"'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: ': "preserve"'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the code
  id: totrans-2258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s fix all the other warnings:'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: 'In `CodeAnalyzing.csproj` , add an element to automatically generate an XML
    file for documentation, as shown highlighted in the following markup:'
  id: totrans-2260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: '**<GenerateDocumentationFile>**'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: '**true**'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: '**</GenerateDocumentationFile>**'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: 'In `stylecop.json` , add a configuration option to provide values for documentation
    for the company name and copyright text, as shown highlighted in the following
    markup:'
  id: totrans-2273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: '"$schema"'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: ': "https://raw.githubusercontent.com/DotNetAnalyzers/StyleCopAnalyzers/master/StyleCop.Analyzers/StyleCop.Analyzers/Settings/stylecop.schema.json"'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: ','
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: '"settings"'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: '"orderingRules"'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: ': {'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
- en: '"usingDirectivesPlacement"'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: ': "preserve"'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
- en: '**"documentationRules"**'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: '**: {**'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: '**"companyName"**'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: '**:**'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: '**"Packt"**'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: '**,**'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: '**"copyrightText"**'
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
- en: '**:**'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: '**"Copyright (c) Packt. All rights reserved."**'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add comments for a file header with company and copyright
    text, move the `using System;` declaration inside the namespace, and set explicit
    access modifiers and XML comments for the class and method, as shown in the following
    code:'
  id: totrans-2299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
- en: // <copyright file="Program.cs" company="Packt">
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: // Copyright (c) Packt. All rights reserved.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
- en: // </copyright>
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: CodeAnalyzing
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: using
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: System;
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: <summary>
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: The main class for this console app.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: </summary>
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: class
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
- en: Program
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: <summary>
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: The main entry point for this console app.
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: </summary>
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
- en: ///
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: <param name="args">
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
- en: A string array of arguments passed to the console app.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: </param>
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
- en: static
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: void
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
- en: Main
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
- en: (
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: string
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
- en: '[] args'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: Console.WriteLine("Hello World!"
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: Build the project.
  id: totrans-2344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expand the `bin/Debug/net6.0` folder and note the autogenerated file named
    `CodeAnalyzing.xml` , as shown in the following markup:'
  id: totrans-2345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
- en: <?xml version="1.0"?>
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
- en: doc
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
- en: assembly
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: CodeAnalyzing</
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
- en: assembly
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
- en: members
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: member
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
- en: '"T:CodeAnalyzing.Program"'
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
- en: summary
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: The main class for this console app.
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
- en: summary
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: member
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: member
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: '"M:CodeAnalyzing.Program.Main(System.String[])"'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
- en: summary
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: The main entry point for this console app.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: summary
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
- en: <
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
- en: param
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: name
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '"args"'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: A string array of arguments passed to the console app.</
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
- en: param
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
- en: member
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: members
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
- en: </
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
- en: doc
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: Understanding common StyleCop recommendations
  id: totrans-2414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside a code file, you should order the contents, as shown in the following
    list:'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: External alias directives
  id: totrans-2416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using directives
  id: totrans-2417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-2418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delegates
  id: totrans-2419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enums
  id: totrans-2420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-2421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structs
  id: totrans-2422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Classes
  id: totrans-2423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within a class, record, struct, or interface, you should order the contents,
    as shown in the following list:'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  id: totrans-2425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-2426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Destructors (finalizers)
  id: totrans-2427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delegates
  id: totrans-2428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Events
  id: totrans-2429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enums
  id: totrans-2430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-2431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties
  id: totrans-2432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indexers
  id: totrans-2433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods
  id: totrans-2434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structs
  id: totrans-2435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nested classes and records
  id: totrans-2436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice** : You can learn about all the StyleCop rules at the following
    link: [https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md](https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/DOCUMENTATION.md)
    .'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  id: totrans-2438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions. Get some
    hands-on practice and explore this chapter's topics with more in-depth research.
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.1 – Test your knowledge
  id: totrans-2440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: What is a delegate?
  id: totrans-2442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an event?
  id: totrans-2443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  id: totrans-2444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `is` and `as` operators?
  id: totrans-2445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  id: totrans-2446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  id: totrans-2447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to allow a member to be overridden?
  id: totrans-2448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a destructor and a deconstruct method?
  id: totrans-2449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the signatures of the constructors that all exceptions should have?
  id: totrans-2450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an extension method, and how do you define one?
  id: totrans-2451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  id: totrans-2452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explore inheritance hierarchies by following these steps:'
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: Add a new console application named `Exercise02` to your `Chapter06` solution/workspace.
  id: totrans-2454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `Shape` with properties named `Height` , `Width` , and
    `Area` .
  id: totrans-2455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three classes that derive from it—`Rectangle` , `Square` , and `Circle`
    —with any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  id: totrans-2456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Main` , add statements to create one instance of each shape, as shown in
    the following code:'
  id: totrans-2457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle r = new
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: '(height: 3'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: ', width: 4.5'
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Rectangle H:'
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
- en: '{r.Height}'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: ', W:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: '{r.Width}'
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
- en: ', Area:'
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: '{r.Area}'
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
- en: Square s = new
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: (5
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Square H:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: '{s.Height}'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: ', W:'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: '{s.Width}'
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: ', Area:'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: '{s.Area}'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: Circle c = new
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
- en: '(radius: 2.5'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Circle H:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Height}'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: ', W:'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Width}'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: ', Area:'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Area}'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
- en: );
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the console application and ensure that the result looks like the following
    output:'
  id: totrans-2494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: 'Rectangle H: 3, W: 4.5, Area: 13.5'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
- en: 'Square H: 5, W: 5, Area: 25'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: 'Circle H: 5, W: 5, Area: 19.6349540849362'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.3 – Explore topics
  id: totrans-2500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-2503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about local functions and operators, delegates
    and events, implementing interfaces, generics, and deriving types using inheritance
    and OOP. You also learned about base and derived classes, and how to override
    a type member, use polymorphism, and cast between types.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how .NET is packaged and deployed, and,
    in subsequent chapters, the types that it provides you with to implement common
    functionality such as file handling, database access, encryption, and multitasking.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
