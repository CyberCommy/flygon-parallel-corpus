- en: Implementing the Weather Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现天气应用程序
- en: 'The first application in this book is going to be a web scraping application
    that will scrape weather forecast information from [https://weather.com](https://weather.com)
    and present it in a terminal. We will add some options that can be passed as arguments
    to the application, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的第一个应用程序将是一个网络爬虫应用程序，它将从[https://weather.com](https://weather.com)爬取天气预报信息并在终端中呈现。我们将添加一些选项，可以将其作为应用程序的参数传递，例如：
- en: The temperature unit (Celsius or Fahrenheit)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 温度单位（摄氏度或华氏度）
- en: The area where you can get the weather forecast
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以获取天气预报的地区
- en: Output options where the user of our application can choose between the current
    forecast, a five-day forecast, a ten-day forecast, and the weekend
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在我们的应用程序中选择当前预报、五天预报、十天预报和周末的输出选项
- en: Ways to complement the output with extra information such as wind and humidity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充输出的方式，例如风和湿度等额外信息
- en: Apart from the aforementioned arguments, this application will be designed to
    be extendable, which means that we can create parsers for different websites to
    get a weather forecast, and these parsers will be available as argument options.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述参数之外，此应用程序将被设计为可扩展的，这意味着我们可以为不同的网站创建解析器来获取天气预报，并且这些解析器将作为参数选项可用。
- en: 'In this chapter, you will learn how to:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何：
- en: Use object-oriented programming concepts in Python applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python应用程序中使用面向对象编程概念
- en: Scrape data from websites using the `BeautifulSoup` package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BeautifulSoup`包从网站上爬取数据
- en: Receive command line arguments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收命令行参数
- en: Utilize the `inspect` module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`inspect`模块
- en: Load Python modules dynamically
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载Python模块
- en: Use Python comprehensions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python推导
- en: Use `Selenium` to request a webpage and inspect its DOM elements
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Selenium`请求网页并检查其DOM元素
- en: Before we get started, it is important to say that when developing web scraping
    applications, you should keep in mind that these types of applications are susceptible
    to changes. If the developers of the site that you are getting data from change
    a CSS class name, or the structure of the HTML DOM, the application will stop
    working. Also, if the URL of the site we are getting the data from changes, the
    application will not be able to send requests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，重要的是要说，当开发网络爬虫应用程序时，您应该牢记这些类型的应用程序容易受到更改的影响。如果您从中获取数据的网站的开发人员更改了CSS类名或HTML
    DOM的结构，应用程序将停止工作。此外，如果我们获取数据的网站的URL更改，应用程序将无法发送请求。
- en: Setting up the environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Before we get right into writing our first example, we need to set up an environment
    to work and install any dependencies that the project may have. Luckily, Python
    has a really nice tooling system to work with virtual environments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写第一个示例之前，我们需要设置一个环境来工作并安装项目可能具有的任何依赖项。幸运的是，Python有一个非常好的工具系统来处理虚拟环境。
- en: Virtual environments in Python are a broad subject, and beyond the scope of
    this book. However, if you are not familiar with virtual environments, it will
    suffice to know that a virtual environment is a contained Python environment that
    is isolated from your global Python installation. This isolation allows developers
    to easily work with different versions of Python, install packages within the
    environment, and manage project dependencies without interfering with Python's
    global installation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的虚拟环境是一个广泛的主题，超出了本书的范围。但是，如果您不熟悉虚拟环境，知道虚拟环境是一个与全局Python安装隔离的Python环境即可。这种隔离允许开发人员轻松地使用不同版本的Python，在环境中安装软件包，并管理项目依赖项，而不会干扰Python的全局安装。
- en: Python's installation comes with a module called `venv`, which you can use to
    create virtual environments; the syntax is fairly straightforward. The application
    that we are going to create is called `weatherterm` (weather terminal), so we
    can create a virtual environment with the same name to make it simple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python的安装包含一个名为`venv`的模块，您可以使用它来创建虚拟环境；语法非常简单。我们将要创建的应用程序称为`weatherterm`（天气终端），因此我们可以创建一个同名的虚拟环境，以使其简单。
- en: 'To create a new virtual environment, open a terminal and run the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的虚拟环境，请打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If everything goes well, you should see a directory called `weatherterm` in
    the directory you are currently at. Now that we have the virtual environment,
    we just need to activate it with the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在当前目录中看到一个名为`weatherterm`的目录。现在我们有了虚拟环境，我们只需要使用以下命令激活它：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I recommend installing and using `virtualenvwrapper`, which is an extension
    of the `virtualenv` tool. This makes it very simple to manage, create, and delete
    virtual environments as well as quickly switch between them. If you wish to investigate
    this further, visit: [https://virtualenvwrapper.readthedocs.io/en/latest/#](https://virtualenvwrapper.readthedocs.io/en/latest/#).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议安装并使用`virtualenvwrapper`，这是`virtualenv`工具的扩展。这使得管理、创建和删除虚拟环境以及快速在它们之间切换变得非常简单。如果您希望进一步了解，请访问：[https://virtualenvwrapper.readthedocs.io/en/latest/#](https://virtualenvwrapper.readthedocs.io/en/latest/#)。
- en: Now, we need to create a directory where we are going to create our application.
    Don't create this directory in the same directory where you created the virtual
    environment; instead, create a projects directory and create the directory for
    the application in there. I would recommend you name it with the same name as
    the virtual environment for simplicity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个目录，我们将在其中创建我们的应用程序。不要在创建虚拟环境的同一目录中创建此目录；相反，创建一个项目目录，并在其中创建应用程序目录。我建议您简单地使用与虚拟环境相同的名称命名它。
- en: I am setting the environment and running all the examples in a machine with
    Debian 9.2 installed, and at the time of writing, I am running the latest Python
    version (3.6.2). If you are a Mac user, it shouldn't be so different; however,
    if you are on Windows, the steps can be slightly different, but it is not hard
    to find information on how to set up virtual environments on it. A Python 3 installation
    works nicely on Windows nowadays.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在设置环境并在安装了Debian 9.2的机器上运行所有示例，并且在撰写本文时，我正在运行最新的Python版本（3.6.2）。如果您是Mac用户，情况可能不会有太大差异；但是，如果您使用Windows，步骤可能略有不同，但是很容易找到有关如何在其中设置虚拟环境的信息。现在，Windows上的Python
    3安装效果很好。
- en: 'Go into the project''s directory that you just created and create a file named
    `requirements.txt` with the following content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 进入刚创建的项目目录并创建一个名为`requirements.txt`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These are all the dependencies that we need for this project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们这个项目所需的所有依赖项：
- en: '`BeautifulSoup`**:** This is a package for parsing HTML and XML files. We will
    be using it to parse the HTML that we fetch from weather sites and to get the
    weather data we need on the terminal. It is very simple to use and it has a great
    documentation available online at: [http://beautiful-soup-4.readthedocs.io/en/latest/](http://beautiful-soup-4.readthedocs.io/en/latest/).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeautifulSoup`**：**这是一个用于解析HTML和XML文件的包。我们将使用它来解析从天气网站获取的HTML，并在终端上获取所需的天气数据。它非常简单易用，并且有在线上有很好的文档：[http://beautiful-soup-4.readthedocs.io/en/latest/](http://beautiful-soup-4.readthedocs.io/en/latest/)。'
- en: '`Selenium`**:** This is a well-known set of tools for testing. There are many
    applications, but it is mostly used for the automated testing of web applications.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selenium`**：**这是一个用于测试的知名工具集。有许多应用程序，但它主要用于自动测试Web应用程序。'
- en: 'To install the required packages in our virtual environment, you can run the
    following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的虚拟环境中安装所需的软件包，可以运行以下命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is always a good idea to make use of version-control tools like GIT or Mercurial.
    It is very helpful to control changes, check history, rollback changes, and more.
    If you are not familiar with any of these tools, there are plenty of tutorials
    on the internet. You can get started by checking the documentation for GIT at: [https://git-scm.com/book/en/v1/Getting-Started](https://git-scm.com/book/en/v1/Getting-Started).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用GIT或Mercurial等版本控制工具是一个好主意。它非常有助于控制更改，检查历史记录，回滚更改等。如果您对这些工具不熟悉，互联网上有很多教程。您可以通过查看GIT的文档来开始：[https://git-scm.com/book/en/v1/Getting-Started](https://git-scm.com/book/en/v1/Getting-Started)。
- en: One last tool that we need to install is PhantomJS; you can download it from: [http://phantomjs.org/download.html](http://phantomjs.org/download.html)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装的最后一个工具是PhantomJS；您可以从以下网址下载：[http://phantomjs.org/download.html](http://phantomjs.org/download.html)
- en: After downloading it, extract the contents inside the `weatherterm` directory
    and rename the folder to `phantomjs.`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，提取`weatherterm`目录中的内容，并将文件夹重命名为`phantomjs`。
- en: With our virtual environment set up and PhantomJS installed, we are ready to
    start coding!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好我们的虚拟环境并安装了PhantomJS后，我们准备开始编码！
- en: Core functionality
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心功能
- en: 'Let''s start by creating a directory for your module. Inside of the project''s
    root directory, create a subdirectory called `weatherterm.` The subdirectory `weatherterm`
    is where our module will live. The module directory needs two subdirectories -
    `core` and `parsers`. The project''s directory structure should look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个模块的目录。在项目的根目录内，创建一个名为`weatherterm`的子目录。`weatherterm`子目录是我们模块的所在地。模块目录需要两个子目录-`core`和`parsers`。项目的目录结构应该如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Loading parsers dynamically
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态加载解析器
- en: 'This application is intended to be flexible and allow developers to create
    different parsers for different weather websites. We are going to create a parser
    loader that will dynamically discover files inside of the `parsers` directory,
    load them, and make them available to be used by the application without requiring
    changes to any other parts of the code. Here are the rules that our loader will
    require when implementing new parsers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序旨在灵活，并允许开发人员为不同的天气网站创建不同的解析器。我们将创建一个解析器加载器，它将动态发现`parsers`目录中的文件，加载它们，并使它们可供应用程序使用，而无需更改代码的其他部分。在实现新解析器时，我们的加载器将需要遵循以下规则：
- en: Create a file with a class implementing the methods for fetching the current
    weather forecast as well as five-day, ten-day, and weekend weather forecasts
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现获取当前天气预报以及五天、十天和周末天气预报方法的类文件
- en: The file name has to end with `parser`, for example, `weather_com_parser.py`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名必须以`parser`结尾，例如`weather_com_parser.py`
- en: The file name can't start with double underscores
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名不能以双下划线开头
- en: 'With that said, let''s go ahead and create the parser loader. Create a file
    named `parser_loader.py` inside of the `weatherterm/core` directory and add the
    following content:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们继续创建解析器加载器。在`weatherterm/core`目录中创建一个名为`parser_loader.py`的文件，并添加以下内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, the `_get_parser_list` function is executed and returns a list of all
    files located in `weatherterm/parsers`; it will filter the files based on the
    rules of the parser described previously. After returning a list of files, it
    is time to import the module. This is done by the `_import_parsers` function,
    which first imports the `weatherterm.parsers` module and makes use of the inspect
    package in the standard library to find the parser classes within the module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行`_get_parser_list`函数并返回位于`weatherterm/parsers`中的所有文件的列表；它将根据先前描述的解析器规则过滤文件。返回文件列表后，就可以导入模块了。这是由`_import_parsers`函数完成的，它首先导入`weatherterm.parsers`模块，并利用标准库中的inspect包来查找模块中的解析器类。
- en: The `inspect.getmembers` function returns a list of tuples where the first item
    is a key representing a property in the module, and the second item is the value,
    which can be of any type. In our scenario, we are interested in a property with
    a key ending with `parser` and with the value of type class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect.getmembers`函数返回一个元组列表，其中第一项是表示模块中的属性的键，第二项是值，可以是任何类型。在我们的情况下，我们对以`parser`结尾的键和类型为类的值感兴趣。'
- en: 'Assuming that we already have a parser in place in the `weatherterm/parsers` 
    directory, the value returned by the `inspect.getmembers(_modules)` will look
    something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经在`weatherterm/parsers`目录中放置了一个解析器，`inspect.getmembers(_modules)`返回的值将看起来像这样：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`inspect.getmembers(_module)` returns many more items, but they have been omitted
    since it is not relevant to show all of them at this point.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect.getmembers(_module)`返回了更多的项目，但它们已被省略，因为在这一点上展示它们并不相关。'
- en: Lastly, we loop through the items in the module and extract the parser classes,
    returning a dictionary containing the name of the class and the class object that
    will be later used to create instances of the parser.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历模块中的项目，并提取解析器类，返回一个包含类名和稍后用于创建解析器实例的类对象的字典。
- en: Creating the application's model
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序的模型
- en: 'Let''s start creating the model that will represent all the information that
    our application will scrape from the weather website. The first item we are going
    to add is an enumeration to represent each option of the weather forecast we will
    provide to the users of our application. Create a file named `forecast_type.py`
    in the directory `weatherterm/core` with the following contents:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建将代表我们的应用程序从天气网站上爬取的所有信息的模型。我们要添加的第一项是一个枚举，用于表示我们应用程序的用户将提供的天气预报选项。在`weatherterm/core`目录中创建一个名为`forecast_type.py`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Enumerations have been in Python's standard library since version 3.4 and they
    can be created using the syntax for creating classes. Just create a class inheriting
    from `enum.Enum` containing a set of unique properties set to constant values.
    Here, we have values for the four types of forecast that the application will
    provide, and where values such as `ForecastType.TODAY`, `ForecastType.WEEKEND`,
    and so on can be accessed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举自Python 3.4版本以来一直存在于Python标准库中，可以使用创建类的语法来创建。只需创建一个从`enum.Enum`继承的类，其中包含一组设置为常量值的唯一属性。在这里，我们为应用程序提供的四种类型的预报设置了值，可以访问`ForecastType.TODAY`、`ForecastType.WEEKEND`等值。
- en: Note that we are assigning constant values that are different from the property
    item of the enumeration, the reason being that later these values will be used
    to build the URL to make requests to the weather website.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在分配与枚举的属性项不同的常量值，原因是以后这些值将用于构建请求天气网站的URL。
- en: The application needs one more enumeration to represent the temperature units
    that the user will be able to choose from in the command line. This enumeration
    will contain Celsius and Fahrenheit items.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要另一个枚举来表示用户在命令行中可以选择的温度单位。这个枚举将包含摄氏度和华氏度项目。
- en: 'First, let''s include a base enumeration. Create a file called `base_enum.py`
    in the `weatherterm/core` directory with the following contents:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们包含一个基本枚举。在`weatherterm/core`目录中创建一个名为`base_enum.py`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`BaseEnum` is a very simple class inheriting from `Enum `. The only thing we
    want to do here is override the method `_generate_next_value_` so that every enumeration
    that inherits from `BaseEnum` and has properties with the value set to `auto() ` will
    automatically get the same value as the property name.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseEnum`是一个非常简单的类，继承自`Enum`。我们在这里想要做的唯一一件事是覆盖`_generate_next_value_`方法，以便从`BaseEnum`继承的每个枚举和具有值设置为`auto()`的属性将自动获得与属性名称相同的值。'
- en: 'Now, we can create an enumeration for the temperature units. Create a file
    called `unit.py` in the `weatherterm/core` directory with the following content:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为温度单位创建一个枚举。在`weatherterm/core`目录中创建一个名为`unit.py`的文件，内容如下：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This class inherits from the `BaseEnum` that we just created, and every property
    is set to `auto()`, meaning the value for every item in the enumeration will be
    set automatically for us. Since the `Unit` class inherits from `BaseEnum`, every
    time the `auto()` is called, the `_generate_next_value_` method on `BaseEnum `will
    be invoked and will return the name of the property itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类继承自我们刚刚创建的`BaseEnum`，每个属性都设置为`auto()`，这意味着枚举中每个项目的值将自动设置。由于`Unit`类继承自`BaseEnum`，每次调用`auto()`时，`BaseEnum`上的`_generate_next_value_`方法将被调用，并返回属性本身的名称。
- en: 'Before we try this out, let''s create a file called `__init__.py` in the `weatherterm/core`
    directory and import the enumeration that we just created, like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试这个之前，让我们在`weatherterm/core`目录中创建一个名为`__init__.py`的文件，并导入我们刚刚创建的枚举，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we load this class in the Python REPL and check the values, the following
    will occur:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python REPL中加载这个类并检查值，将会发生以下情况：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another item that we also want to add to the core module of our application
    is a class to represent the weather forecast data that the parser returns. Let''s
    go ahead and create a file named `forecast.py` in the `weatherterm/core` directory
    with the following contents:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要添加到我们应用程序的核心模块的另一项内容是一个类，用于表示解析器返回的天气预报数据。让我们继续在`weatherterm/core`目录中创建一个名为`forecast.py`的文件，内容如下：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the Forecast class, we will define properties for all the data we are going
    to parse:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Forecast类中，我们将定义我们将要解析的所有数据的属性：
- en: '| `current_temp` | Represents the current temperature. It will only be available
    when getting today''s weather forecast. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `current_temp` | 表示当前温度。仅在获取今天的天气预报时才可用。 |'
- en: '| `humidity` | The humidity percentage for the day. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `humidity` | 一天中的湿度百分比。 |'
- en: '| `wind` | Information about today''s current wind levels. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `wind` | 有关今天当前风级的信息。 |'
- en: '| `high_temp` | The highest temperature for the day. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `high_temp` | 一天中的最高温度。 |'
- en: '| `low_temp` | The lowest temperature for the day. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `low_temp` | 一天中的最低温度。 |'
- en: '| `description` | A description of the weather conditions, for example, *Partly
    Cloudy.* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `description` | 天气条件的描述，例如*部分多云*。 |'
- en: '| `forecast_date` | Forecast date; if not supplied, it will be set to the current
    date. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `forecast_date` | 预测日期；如果未提供，将设置为当前日期。 |'
- en: '| `forecast_type` | Any value in the enumeration `ForecastType` (`TODAY`, `FIVEDAYS`,
    `TENDAYS`, or `WEEKEND`). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `forecast_type` | 枚举`ForecastType`中的任何值（`TODAY`，`FIVEDAYS`，`TENDAYS`或`WEEKEND`）。
    |'
- en: We can also implement two methods called `forecast_date ` with the decorators
    `@property ` and `@forecast_date.setter `. The `@property ` decorator will turn
    the method into a getter for the `_forecast_date` property of the Forecast class,
    and the `@forecast_date.setter` will turn the method into a setter.  The setter
    was defined here because, every time we need to set the date in an instance of
    `Forecast`, we need to make sure that it will be formatted accordingly. In the
    setter, we call the `strftime` method, passing the format codes `%a` (weekday
    abbreviated name), `%b` (monthly abbreviated name), and `%d` (day of the month).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现两个名为`forecast_date`的方法，使用`@property`和`@forecast_date.setter`装饰器。`@property`装饰器将方法转换为`Forecast`类的`_forecast_date`属性的getter，而`@forecast_date.setter`将方法转换为setter。之所以在这里定义setter，是因为每次需要在`Forecast`的实例中设置日期时，我们都需要确保它将被相应地格式化。在setter中，我们调用`strftime`方法，传递格式代码`%a`（缩写的星期几名称），`%b`（缩写的月份名称）和`%d`（月份的第几天）。
- en: The format codes `%a` and `%b` will use the locale configured in the machine
    that the code is running on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 格式代码`%a`和`%b`将使用在运行代码的机器上配置的区域设置。
- en: Lastly, we override the `__str__` method to allow us to format the output the
    way we would like when using the `print`, `format`, and `str` functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写`__str__`方法，以便在使用`print`，`format`和`str`函数时以我们希望的方式格式化输出。
- en: 'By default, the temperature unit used by `weather.com` is `Fahrenheit`, and
    we want to give the users of our application the option to use Celsius instead.
    So, let''s go ahead and create one more file in the `weatherterm/core` directory called
    `unit_converter.py` with the following content:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`weather.com`使用的温度单位是`华氏度`，我们希望我们的应用程序用户可以选择使用摄氏度。因此，让我们继续在`weatherterm/core`目录中创建一个名为`unit_converter.py`的文件，内容如下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the class that is going to make the temperature conversions from Celsius
    to Fahrenheit and vice versa. The initializer of this class gets two arguments;
    the default unit used by the parser and the destination unit. In the initializer,
    we will define a dictionary containing the functions that will be used for temperature
    unit conversion.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将负责将摄氏度转换为华氏度，反之亦然。这个类的初始化器有两个参数；解析器使用的默认单位和目标单位。在初始化器中，我们将定义一个包含用于温度单位转换的函数的字典。
- en: The `convert` method only gets one argument, the temperature. Here, the temperature
    is a string, so the first thing we need to do is try converting it to a float
    value; if it fails, it will return a zero value right away.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert`方法只接受一个参数，即温度。在这里，温度是一个字符串，因此我们需要尝试将其转换为浮点值；如果失败，它将立即返回零值。'
- en: You can also verify whether the destination unit is the same as the parser's
    default unit or not. In that case, we don't need to continue and perform any conversion;
    we simply format the value and return it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以验证目标单位是否与解析器的默认单位相同。在这种情况下，我们不需要继续执行任何转换；我们只需格式化值并返回它。
- en: If we need to perform a conversion, we can look up the `_convert_functions ` dictionary
    to find the `conversion` function that we need to run. If we find the function
    we are looking for, we invoke it and return the formatted value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要执行转换，我们可以查找`_convert_functions`字典，找到需要运行的`conversion`函数。如果找到我们正在寻找的函数，我们调用它并返回格式化的值。
- en: 'The code snippet below shows the `_format_results` method, which is a utility
    method that will format the temperature value for us:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了`_format_results`方法，这是一个实用方法，将为我们格式化温度值：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_format_results` method checks if the number is an integer; the `value.is_integer()`
    will return `True` if the number is, for example, 10.0\. If `True`, we will use
    the `int` function to convert the value to 10; otherwise, the value is returned
    as a fixed-point number with a precision of 1\. The default precision in Python
    is 6\. Lastly, there are two utility methods that perform the temperature conversions, `_to_celsius` and
    `_to_fahrenheit`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`_format_results`方法检查数字是否为整数；如果`value.is_integer()`返回`True`，则表示数字是整数，例如10.0。如果为`True`，我们将使用`int`函数将值转换为10；否则，该值将作为具有精度为1的定点数返回。Python中的默认精度为6。最后，有两个实用方法执行温度转换，`_to_celsius`和`_to_fahrenheit`。'
- en: 'Now, we only need to edit the `__init__.py` file in the `weatherterm/core`
    directory and include the following import statements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要编辑`weatherterm/core`目录中的`__init__.py`文件，并包含以下导入语句：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Fetching data from the weather website
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从天气网站获取数据
- en: 'We are going to add a class named `Request` that will be responsible for getting
    the data from the weather website. Let''s add a file named `request.py` in the
    `weatherterm/core` directory with the following content:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个名为`Request`的类，负责从天气网站获取数据。让我们在`weatherterm/core`目录中添加一个名为`request.py`的文件，内容如下：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This class is very simple; the initializer defines the base URL and creates
    a PhantomJS driver, using the path where PhantomJS is installed. The `fetch_data`
    method formats the URL, adding the forecast option and the area. After that, the
    `webdriver` performs a request and returns the page source. If the title of the
    markup returned is `404 Not Found`, it will raise an exception. Unfortunately,
    `Selenium` doesn't provide a proper way of getting the HTTP Status code; this
    would have been much better than comparing strings.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that I prefix some of the class properties with an underscore
    sign. I usually do that to show that the underlying property is private and shouldn't
    be set outside the class. In Python, there is no need to do that because there's
    no way to set private or public properties; however, I like it because I can clearly
    show my intent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can import it in the `__init__.py ` file in the `weatherterm/core` directory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now we have a parser loader to load any parser that we drop into the directory
    `weatherterm/parsers`,  we have a class representing the forecast model, and an
    enumeration `ForecastType` so we can specify which type of forecast we are parsing.
    The enumeration represents temperature units and utility functions to convert
    temperatures from `Fahrenheit` to `Celsius` and `Celsius` to `Fahrenheit.` So
    now, we should be ready to create the application's entry point to receive all
    the arguments passed by the user, run the parser, and present the data on the
    terminal.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Getting the user's input with ArgumentParser
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we run our application for the first time, we need to add the application's
    entry point. The entry point is the first code that will be run when our application
    is executed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: We want to give the users of our application the best user experience possible,
    so the first features that we need to add are the ability to receive and parse
    command line arguments, perform argument validation, set arguments when needed,
    and, last but not least, show an organized and informative help system so the
    users can see which arguments can be used and how to use the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Sounds like tedious work, right?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Python has batteries included and the standard library contains a great
    module that allows us to implement this in a very simple way; the module is called
    `argparse`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that would be good to have is for our application to be easy
    to distribute to our users. One approach is to create a `__main__.py` file in
    the `weatherterm` module directory, and you can run the module as a regular script.
    Python will automatically run the `__main__.py` file, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another option is to zip the entire application's directory and execute the
    Python passing the name of the ZIP file instead. This is an easy, fast, and simple
    way to distribute our Python programs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: There are many other ways of distributing your programs, but they are beyond
    the scope of this book; I just wanted to give you some examples of the usage of
    the `__main__.py` file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s create a `__main__.py` file inside of the `weatherterm` directory
    with the following content:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The weather forecast options (today, five days, ten days, and weekend forecast)
    that our application will accept will not be required; however, at least one option
    must be provided in the command line, so we create a simple function called `_validate_forecast_args`
    to perform this validation for us. This function will show a help message and
    exit the application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: First, we get all the parsers available in the `weatherterm/parsers` directory.
    The list of parsers will be used as valid values for the parser argument.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is the `ArgumentParser` object that does the job of defining the parameters,
    parsing the values, and showing help, so we create an instance of `ArgumentParser`
    and also create an argument group for the required parameters. This will make
    the help output look much nicer and organized.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the parameters and the help output more organized, we are going
    to create a group within the `ArgumentParser` object. This group will contain
    all the required arguments that our application needs. This way, the users of
    our application can easily see which parameters are required and the ones that
    are not required.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使参数和帮助输出更有组织，我们将在`ArgumentParser`对象中创建一个组。此组将包含我们的应用程序需要的所有必需参数。这样，我们的应用程序的用户可以轻松地看到哪些参数是必需的，哪些是不必需的。
- en: 'We achieve this with the following statement:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下语句实现了这一点：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After creating the argument group for the required arguments, we get a list
    of all members of the enumeration `Unit` and use the `title()` function to make
    only the first letter a capital letter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在为必需参数创建参数组之后，我们获取枚举`Unit`的所有成员的列表，并使用`title()`函数使只有第一个字母是大写字母。
- en: Now, we can start adding the arguments that our application will be able to
    receive on the command line. Most argument definitions use the same set of keyword
    arguments, so I will not be covering all of them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加我们的应用程序能够在命令行接收的参数。大多数参数定义使用相同的一组关键字参数，因此我不会覆盖所有参数。
- en: 'The first argument that we will create is `--parser` or `-p`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个参数是`--parser`或`-p`：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break down every parameter of the `add_argument ` used when creating
    the parser flag:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解创建解析器标志时使用的`add_argument`的每个参数：
- en: The first two parameters are the flags. In this case, the user passes a value
    to this argument using either `-p` or `--parser` in the command line, for example,
    `--parser WeatherComParser`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个参数是标志。在这种情况下，用户可以使用`-p`或`--parser`在命令行中传递值给此参数，例如`--parser WeatherComParser`。
- en: The `choices` parameter specifies a list of valid values for that argument that
    we are creating. Here, we are using `parsers.keys()`, which will return a list
    of parser names. The advantage of this implementation is that if we add a new
    parser, it will be automatically added to this list, and no changes will be required
    in this file.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices`参数指定我们正在创建的参数的有效值列表。在这里，我们使用`parsers.keys()`，它将返回一个解析器名称的列表。这种实现的优势是，如果我们添加一个新的解析器，它将自动添加到此列表中，而且不需要对此文件进行任何更改。'
- en: The `required` parameter, as the name says, specifies if the argument will be
    required or not.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`参数，顾名思义，指定参数是否为必需的。'
- en: The `dest` parameter specifies the name of the attribute to be added to the
    resulting object of the parser argument. The object returned by `parser_args()` will
    contain an attribute called `parser` with the value that we passed to this argument
    in the command line.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dest`参数指定要添加到解析器参数的结果对象中的属性的名称。`parser_args()`返回的对象将包含一个名为`parser`的属性，其值是我们在命令行中传递给此参数的值。'
- en: Finally, the `help` parameter is the argument's help text, shown when using
    the `-h` or `--help` flag.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`help`参数是参数的帮助文本，在使用`-h`或`--help`标志时显示。
- en: 'Moving on to the `--today` argument:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`--today`参数：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we have two keyword arguments that we haven't seen before, `action` and
    `const`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个我们以前没有见过的关键字参数，`action`和`const`。
- en: Actions can be bound to the arguments that we create and they can perform many
    things. The `argparse` module contains a great set of actions, but if you need
    to do something specific, you can create your own action that will meet your needs.
    Most actions defined in the `argparse` module are actions to store values in the
    parse result's object attributes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 行动可以绑定到我们创建的参数，并且它们可以执行许多操作。`argparse`模块包含一组很棒的操作，但如果您需要执行特定操作，可以创建自己的操作来满足您的需求。`argparse`模块中定义的大多数操作都是将值存储在解析结果对象属性中的操作。
- en: In the previous code snippet, we use the `store_const` action, which will store
    a constant value to an attribute in the object returned by `parse_args()`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`store_const`操作，它将一个常量值存储到`parse_args()`返回的对象中的属性中。
- en: We also used the keyword argument `const`, which specifies the constant default
    value when the flag is used in the command line.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了关键字参数`const`，它指定在命令行中使用标志时的常量默认值。
- en: 'Remember that I mentioned that it is possible to create custom actions? The
    argument unit is a great use case for a custom action. The `choices` argument
    is just a list of strings, so we use this comprehension to get the list of names
    of every item in the `Unit` enumeration, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我提到过可以创建自定义操作吗？参数unit是自定义操作的一个很好的用例。`choices`参数只是一个字符串列表，因此我们使用此推导式获取`Unit`枚举中每个项目的名称列表，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The object returned by `parse_args()` will contain an attribute called unit
    with a string value (`Celsius` or `Fahrenheit`), but this is not exactly what
    we want. Wouldn't it be nice to have the value as an enumeration item instead?
    We can change this behavior by creating a custom action.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_args()`返回的对象将包含一个名为unit的属性，其值为字符串（`Celsius`或`Fahrenheit`），但这并不是我们想要的。我们可以通过创建自定义操作来更改此行为。'
- en: 'First, add a new file named `set_unit_action.py` in the `weatherterm/core`
    directory with the following contents:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`weatherterm/core`目录中添加一个名为`set_unit_action.py`的新文件，内容如下：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This action class is very simple; it just inherits from `argparse.Action` and
    overrides the `__call__` method, which will be called when the argument value
    is parsed. This is going to be set to the destination attribute.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作类非常简单；它只是继承自`argparse.Action`并覆盖`__call__`方法，当解析参数值时将调用该方法。这将设置为目标属性。
- en: 'The `parser` parameter will be an instance of `ArgumentParser`. The namespace
    is an instance of `argparser.Namespace` and it is just a simple class containing
    all the attributes defined in the `ArgumentParser` object. If you inspect this
    parameter with the debugger, you will see something similar to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser`参数将是`ArgumentParser`的一个实例。命名空间是`argparser.Namespace`的一个实例，它只是一个简单的类，包含`ArgumentParser`对象中定义的所有属性。如果您使用调试器检查此参数，您将看到类似于这样的东西：'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `values` parameter is the value that the user has passed on the command
    line; in our case, it can be either Celsius or Fahrenheit. Lastly, the `option_string` parameter
    is the flag defined for the argument. For the unit argument, the value of `option_string` will
    be `-u`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, enumerations in Python allow us to access their members and attributes
    using item access:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Verifying this in Python REPL, we have:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After getting the correct enumeration member, we set the value of the property
    specified by `self.dest` in the namespace object. That is much cleaner and we
    don't need to deal with magic strings.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'With the custom action in place, we need to add the import statement in the `__init__.py` file
    in the `weatherterm/core` directory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Just include the line above at the end of the file. Then, we need to import
    it into the `__main__.py` file,  like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And we are going to add the `action` keyword argument in the definition of
    the unit argument and set it to `SetUnitAction`, like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, when the user of our application uses the flag `-u` for Celsius, the value
    of the attribute unit in the object returned by the `parse_args() ` function will
    be:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`<Unit.CELSIUS: ''CELSIUS''>`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is very straightforward; we invoke the `parse_args` function
    to parse the arguments and set the result in the `args` variable. Then, we use
    the value of `args.parser` (the name of the selected parser) and access that item
    in the parser's dictionary. Remember that the value is the class type, so we create
    an instance of the parser, and lastly, invoke the method run, which will kick
    off website scraping.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Creating the parser
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run our code for the first time, we need to create a parser. We
    can quickly create a parser to run our code and check whether the values are being
    parsed properly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a file called `weather_com_parser.py` in the `weatherterm/parsers` directory.
    To make it simple, we are going to create just the necessary methods, and the
    only thing we are going to do when the methods are invoked is to raise a `NotImplementedError`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the initializer, we create a dictionary where the key is a member of the `ForecasType` enumeration,
    and the value is the method bound to any of these options. Our application will
    be able to present today's, a five-day, ten-day, and the weekend forecast, so
    we implement all four methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The `run` method only does two things; it looks up the function that needs to
    be executed using the `forecast_option` that we passed as an argument in the command
    line, and executes the function returning its value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the application is finally ready to be executed for the first time if
    you run the command in the command line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see the application''s help options:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the `ArgumentParse` module already provides out-of-the-box output
    for help. There are ways you can customize the output how you want to, but I find
    the default layout really good.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `-p` argument already gave you the option to choose the `WeatherComParser`.
    It wasn't necessary to hardcode it anywhere because the parser loader did all
    the work for us. The `-u` (`--unit`) flag also contains the items of the enumeration
    `Unit`. If someday you want to extend this application and add new units, the
    only thing you need to do here is to add the new item to the enumeration, and
    it will be automatically picked up and included as an option for the `-u` flag.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the application again and this time pass some parameters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will get an exception similar to this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2b594fc-7ad7-4b4f-877a-3476564ec7f6.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Don't worry -- this is exactly what we wanted! If you follow the stack trace,
    you can see that everything is working as intended. When we run our code, we call
    the `run` method on the selected parser from the `__main__.py` file, then we select
    the method associated with the forecast option, in this case, `_today_forecast`,
    and finally store the result in the `forecast_function` variable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心——这正是我们想要的！如果您跟踪堆栈跟踪，您会看到一切都按预期工作。当我们运行我们的代码时，我们在`__main__.py`文件中选择了所选解析器上的`run`方法，然后选择与预报选项相关联的方法，例如`_today_forecast`，最后将结果存储在`forecast_function`变量中。
- en: When the function stored in the `forecast_function` variable was executed, the
    `NotImplementedError` exception was raised. So far so good; the code is working
    perfectly and now we can start adding the implementation for each of these methods.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行存储在`forecast_function`变量中的函数时，引发了`NotImplementedError`异常。到目前为止一切顺利；代码完美运行，现在我们可以开始为这些方法中的每一个添加实现。
- en: Getting today's weather forecast
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取今天的天气预报
- en: The core functionality is in place and the entry point of the application with
    the argument parser will give the users of our application a much better experience.
    Now, it is finally the time we all have been waiting for, the time to start implementing
    the parser. We will start implementing the method to get today's weather forecast.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能已经就位，应用程序的入口点和参数解析器将为我们的应用程序的用户带来更好的体验。现在，终于到了我们一直在等待的时间，开始实现解析器的时间。我们将开始实现获取今天的天气预报的方法。
- en: 'Since I am in Sweden, I will use the area code `SWXX2372:1:SW` (Stockholm,
    Sweden); however, you can use any area code you want. To get the area code of
    your choice, go to [https://weather.com](https://weather.com) and search for the
    area you want. After selecting the area, the weather forecast for the current
    day will be displayed. Note that the URL changes, for example, when searching
    Stockholm, Sweden, the URL changes to:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我在瑞典，我将使用区号`SWXX2372:1:SW`（瑞典斯德哥尔摩）；但是，您可以使用任何您想要的区号。要获取您选择的区号，请转到[https://weather.com](https://weather.com)并搜索您想要的区域。选择区域后，将显示当天的天气预报。请注意，URL会更改，例如，搜索瑞典斯德哥尔摩时，URL会更改为：
- en: '[https://weather.com/weather/today/l/SWXX2372:1:SW](https://weather.com/weather/today/l/SWXX2372:1:SW)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://weather.com/weather/today/l/SWXX2372:1:SW](https://weather.com/weather/today/l/SWXX2372:1:SW)'
- en: 'For São Paulo, Brazil it will be:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于巴西圣保罗，将是：
- en: '[https://weather.com/weather/today/l/BRXX0232:1:BR](https://weather.com/weather/today/l/BRXX0232:1:BR)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://weather.com/weather/today/l/BRXX0232:1:BR](https://weather.com/weather/today/l/BRXX0232:1:BR)'
- en: Note that there is only one part of the URL that changes, and this is the area
    code that we want to pass as an argument to our application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，URL只有一个部分会更改，这就是我们要作为参数传递给我们的应用程序的区号。
- en: Adding helper methods
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加辅助方法
- en: 'To start with, we need to import some packages:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入一些包：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And in the initializer, we are going to add the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化程序中，我们将添加以下代码：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the initializer, we define the URL template we are going to use to perform
    requests to the weather website; then, we create a `Request` object. This is the
    object that will perform the requests for us.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化程序中，我们定义了要使用的URL模板，以执行对天气网站的请求；然后，我们创建了一个`Request`对象。这是将代表我们执行请求的对象。
- en: Regular expressions are only used when parsing today's weather forecast temperatures.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在解析今天的天气预报温度时才使用正则表达式。
- en: We also define a `UnitConverter` object and set the default unit to `Fahrenheit`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`UnitConverter`对象，并将默认单位设置为`华氏度`。
- en: 'Now, we are ready to start adding two methods that will be responsible for
    actually searching for HTML elements within a certain class and return its contents.
    The first method is called `_get_data`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始添加两个方法，这两个方法将负责实际搜索某个类中的HTML元素并返回其内容。第一个方法称为`_get_data`：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The idea of this method is to search items within a container that matches some
    criteria. The `container` is just a DOM element in the HTML and the `search_items` is
    a dictionary where the key is a CSS class and the value is the type of the HTML
    element. It can be a DIV, SPAN, or anything that you wish to get the value from.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的想法是在匹配某些条件的容器中搜索项目。`container`只是HTML中的DOM元素，而`search_items`是一个字典，其中键是CSS类，值是HTML元素的类型。它可以是DIV、SPAN或您希望获取值的任何内容。
- en: It starts looping through `search_items.items()` and uses the find method to
    find the element within the container. If the item is found, we use `get_text` to
    extract the text of the DOM element and add it to a dictionary that will be returned
    when there are no more items to search.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始循环遍历`search_items.items()`，并使用find方法在容器中查找元素。如果找到该项，我们使用`get_text`提取DOM元素的文本，并将其添加到一个字典中，当没有更多项目可搜索时将返回该字典。
- en: 'The second method that we will implement is the `_parser` method. This will
    make use of the `_get_data` that we just implemented:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的第二个方法是`_parser`方法。这将使用我们刚刚实现的`_get_data`：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we also get a `container` and `criteria` like the `_get_data` method.
    The container is a DOM element and the criterion is a dictionary of nodes that
    we want to find. The first comprehension gets all the container's children elements
    and passes them to the `_get_data` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还会得到一个`container`和`criteria`，就像`_get_data`方法一样。容器是一个DOM元素，标准是我们要查找的节点的字典。第一个推导式获取所有容器的子元素，并将它们传递给刚刚实现的`_get_data`方法。
- en: The results will be a list of dictionaries with all the items that have been
    found, and we will only return the dictionaries that are not empty.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个包含所有已找到项目的字典列表，我们只会返回不为空的字典。
- en: 'There are only two more helper methods we need to implement in order to get
    today''s weather forecast in place. Let''s implement a method called `_clear_str_number`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现另外两个辅助方法，以便获取今天的天气预报。让我们实现一个名为`_clear_str_number`的方法：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This method will use a regular expression to make sure that only digits are
    returned.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将使用正则表达式确保只返回数字。
- en: 'And the last method that needs to be implemented is the `_get_additional_info` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method loops through the table rows, getting the text of every cell. This
    comprehension will return lots of information about the weather, but we are only
    interested in the first `2`, the wind and the humidity.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Implementing today's weather forecast
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to start adding the implementation of the `_today_forecast` method,
    but first, we need to import `BeautifulSoup`. At the top of the file, add the
    following import statement:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can start adding the `_today_forecast` method:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That is the function that will be called when the `-td` or `--today` flag is
    used on the command line. Let's break down this code so that we can easily understand
    what it does. Understanding this method is important because these methods parse
    data from other weather forecast options (five days, ten days, and weekend) that
    are very similar to this one.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The method''s signature is quite simple; it only gets `args`, which is the
    `Argument` object that is created in the `__main__` method. The first thing we
    do in this method is to create a `criteria` dictionary with all the DOM elements
    that we want to find in the markup:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As mentioned before, the key to the `criteria` dictionary is the name of the
    DOM element''s CSS class, and the value is the type of the HTML element:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The `today_nowcard-temp` class is a CSS class of the DOM element containing
    the current temperature
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `today_nowcard-phrase` class is a CSS class of the DOM element containing
    weather conditions text (Cloudy, Sunny, and so on)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `today_nowcard-hilo` class is the CSS class of the DOM element containing
    the highest and lowest temperature
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we are going to fetch, create, and use `BeautifulSoup` to parse the DOM:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we make use of the `fetch_data` method of the `Request` class that we
    created on the core module and pass two arguments; the first is the forecast option
    and the second argument is the area code that we passed on the command line.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: After fetching the data, we create a `BeautifulSoup` object passing the `content`
    and a `parser`. Since we are getting back HTML, we use `html.parser`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to start looking for the HTML elements that we are interested
    in. Remember, we need to find an element that will be a container, and the `_parser` function
    will search through the children elements and try to find items that we defined
    in the dictionary criteria. For today's weather forecast, the element that contains
    all the data we need is a `section` element with the `today_nowcard-container` CSS
    class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`BeautifulSoup` contains the `find` method, which we can use to find elements
    in the HTML DOM with specific criteria. Note that the keyword argument is called
    `class_` and not `class` because `class` is a reserved word in Python.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the container element, we can pass it to the `_parse` method,
    which will return a list. We perform a check if the result list contains at least
    one element and raise an exception if it is empty. If it is not empty, we just
    get the first element and assign it to the `weatherinfo` variable. The `weatherinfo`
    variable now contains a dictionary with all the items that we were looking for.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is split the highest and lowest temperature:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We want to parse the text that has been extracted from the DOM element with
    the `today_nowcard-hilo` CSS class, and the text should look something like `H
    50 L 60`, `H -- L 60`, and so on. An easy and simple way of extracting the text
    we want is to use a regular expression:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`H\s+(\d+|\-{,2}).L\s+(\d+|\-{,2})`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We can break this regular expression into two parts. First, we want to get the
    highest temperature—`H\s+(\d+|\-{,2})`; this means that it will match an `H` followed
    by some spaces, and then it will group a value that matches either numbers or
    a maximum of two dash symbols. After that, it will match any character. Lastly,
    comes the second part that basically does the same; however, it starts matching
    an `L`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: After executing the search method, it gets regular expression groups that have
    been returned calling the `groups()` function, which in this case will return
    two groups, one for the highest temperature and the second for the lowest.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Other information that we want to provide to our users is information about
    wind and humidity. The container element that contains this information has a
    CSS class called `today_nowcard-sidecar`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We just find the container and pass it into the `_get_additional_info` method
    that will loop through the children elements of the container, extracting the
    text and finally returning the results for us.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last part of this method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the current temperature contains a special character (degree sign) that
    we don't want to have at this point, we use the `_clr_str_number` method to pass
    the `today_nowcard-temp` item of the `weatherinfo` dictionary.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the information we need, we construct the `Forecast` object
    and return it. Note that we are returning an array here; this is because all other
    options that we are going to implement (five-day, ten-day, and weekend forecasts)
    will return a list, so to make it consistent; also to facilitate when we will
    have to display this information on the terminal, we are also returning a list.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that we are making use of the convert method of our
    `UnitConverter` to convert all the temperatures to the unit selected in the command
    line.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the command again:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see an output similar to this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f2ea039-104c-4786-a400-ae107a248609.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have implemented your first web scraping application. Next
    up, let's add the other forecast options.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Getting five- and ten-day weather forecasts
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The site that we are currently scraping the weather forecast from ([weather.com](https://weather.com/en-IN/))
    also provides the weather forecast for
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: five and ten days, so in this section, we are going to implement methods to
    parse these forecast options as well.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The markup of the pages that present data for five and ten days are very similar;
    they have the same DOM structure and share the same CSS classes, which makes it
    easier for us to implement just one method that will work for both options. Let''s
    go ahead and add a new method to the `wheater_com_parser.py` file with the following
    contents:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As I mentioned before, the DOM for the five- and ten-day weather forecasts
    is very similar, so we create the `_parse_list_forecast` method, which can be
    used for both options. First, we define the criteria:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The `date-time` is a `span` element and contains a string representing the day
    of the week
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `day-detail` is a `span` element and contains a string with the date, for
    example, `SEP 29`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `description` is a `TD` element and contains the weather conditions, for
    example, ``Cloudy``
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temp` is a `TD` element and contains temperature information such as high
    and low temperature'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wind` is a `TD` element and contains wind information'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`humidity` is a `TD` element and contains humidity information'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the criteria, we create a `BeatufulSoup` object, passing the
    content and the `html.parser`. All the data that we would like to get is on the
    table with a CSS class named `twc-table`. We find the table and define the `tbody` element
    as a container.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we run the `_parse` method, passing the `container` and the `criteria`
    that we defined. The return of this function will look something like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Another method that we need to create is a method that will prepare the data
    for us, for example, parsing and converting temperature values and creating a `Forecast` object.
    Add a new method called `_prepare_data` with the following content:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method is quite simple. First, loop through the results and apply the regex
    that we created to split the high and low temperatures stored in `item['temp']`.
    If there's a match, it will get the groups and assign the value to `high_temp` and
    `low_temp`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: After that, we create a `Forecast` object and append it to a list that will
    be returned later on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we add the method that will be invoked when the `-5d` or `-10d` flag
    is used. Create another method called `_five_and_ten_days_forecast` with the following
    contents:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This method only fetches the contents of the page passing the `forecast_option`
    value and the area code, so it will be possible to build the URL to perform the
    request. When the data is returned, we pass it down to the `_parse_list_forecast`,
    which will return a list of `Forecast` objects (one for each day); finally, we
    prepare the data to be returned using the `_prepare_data` method.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run the command, we need to enable this option in the command line
    tool that we implemented; go over to the `__main__.py` file, and, just after the
    definition of the `-td` flag, add the following code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, run the application again, but this time using the `-5d` or `--fivedays` flag:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It will produce the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To wrap this section up, let''s include the option to get the weather forecast
    for the next ten days as well, in the `__main__.py` file, just below the `-5d`
    flag definition. Add the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you run the same command as we used to get the five-day forecast but replace
    the `-5d` flag with `-10d`, like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should see the ten-day weather forecast output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the weather was not so great here in Sweden while I was writing
    this book.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Getting the weekend weather forecast
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last weather forecast option that we are going to implement in our application
    is the option to get the weather forecast for the upcoming weekend. This implementation
    is a bit different from the others because the data returned by the weekend's
    weather is slightly different from today's, five, and ten days weather forecast.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The DOM structure is different and some CSS class names are different as well.
    If you remember the previous methods that we implemented, we always use the `_parser` method,
    which gives us arguments such as the container DOM and a dictionary with the search
    criteria. The return value of that method is also a dictionary where the key is
    the class name of the DOM that we were searching and the value is the text within
    that DOM element.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Since the CSS class names of the weekend page are different, we need to implement
    some code to get that array of results and rename all the keys so the `_prepare_data` function
    can use scraped results properly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s go ahead and create a new file in the `weatherterm/core` directory
    called `mapper.py` with the following contents:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Mapper` class gets a list with dictionaries and renames specific keys that
    we would like to rename. The important methods here are `remap_key` and `remap`.
    The `remap_key` gets two arguments, `source` and `dest`. `source` is the key that
    we wish to rename and `dest` is the new name for that key. The `remap_key` method
    will add it to an internal dictionary called `_mapping`, which will be used later
    on to look up the new key name.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The `remap` method simply gets a list containing the dictionaries and, for every
    item on that list, it calls the `_exec` method that first creates a brand new
    dictionary, then checks whether the dictionary is empty. In that case, it raises an
    `AttributeError`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: If the dictionary has keys, we loop through its items, search for whether the
    current item's key has a new name in the mapping dictionary. If the new key name
    is found, will to create a new item with the new key name; otherwise, we just
    keep the old name. After the loop, the list is returned with all the dictionaries
    containing the keys with a new name.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to add it to the `__init__.py` file in the `weatherterm/core` directory:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And, in the `weather_com_parser.py` file in `weatherterm/parsers`, we need
    to import the `Mapper`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With the mapper in place, we can go ahead and create the `_weekend_forecast`
    method in the `weather_com_parser.py` file, like so:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The method starts off by defining the criteria in exactly the same way as the
    other methods; however, the DOM structure is slightly different and some of the
    CSS names are also different:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`weather-cell`: Contains the forecast date: `FriSEP 29`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temp`: Contains the temperature (high and low): `57°F48°F`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weather-phrase`: Contains the weather conditions: `Cloudy`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wind-conditions`: Wind information'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`humidity`: The humidity percentage'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, to make it play nicely with the `_prepare_data` method, we will
    need to rename some keys in the dictionaries in the result set—`wind-conditions`
    should be `wind` and `weather-phrase` should be the `description`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we have introduced the `Mapper` class to help us out:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We create a `Mapper` object and say, remap `wind-conditions` to `wind` and
    `weather-phrase` to `description`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We fetch all the data, create a `BeautifulSoup` object using the `html.parser`,
    and find the container element that contains the children elements that we are
    interested in. For the weekend forecast, we are interested in getting the `article`
    element with a CSS class called `ls-mod` and within that `article` we go down
    to the first child element, which is a DIV, and gets its first child element,
    which is also a DIV element.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML should look something like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That's the reason we first find the article, assign it to `forecast_data`, and
    then use `forecast_data.div.div` so we get the DIV element we want.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: After defining the container, we pass it to the `_parse` method together with
    the container element; when we get the results back, we simply need to run the
    `remap` method of the `Mapper` instance, which will normalize the data for us
    before we call `_prepare_data`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last detail before we run the application and get the weather forecast
    for the weekend is that we need to include the `--w` and `--weekend` flag to the
    `ArgumentParser`. Open the `__main__.py` file in the `weatherterm` directory and,
    just below the `--tenday` flag, add the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Great! Now, run the application using the `-w` or `--weekend` flag:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that this time, I used the `-u` flag to choose Celsius. All the temperatures
    in the output are represented in Celsius instead of Fahrenheit.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of object-oriented programming in Python;
    we covered how to create classes, use inheritance, and use the `@property` decorators
    to create getter and setters.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to use the inspect module to get more information about modules,
    classes, and functions. Last but not least, we made use of the powerful package
    `Beautifulsoup` to parse HTML and `Selenium` to make requests to the weather website.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to implement command line tools using the `argparse` module
    from Python's standard library, which allows us to provide tools that are easier
    to use and with very helpful documentation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to develop a small wrapper around the Spotify Rest API
    and use it to create a remote control terminal.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
