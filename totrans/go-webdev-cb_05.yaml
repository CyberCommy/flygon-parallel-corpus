- en: Working with SQL and NoSQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating MySQL and Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first record in MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading records from MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating your first record in MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting your first record from MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating MongoDB and Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first document in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading documents from MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating your first document in MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting your first document from MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to persist data we always look forward to saving it in databases,
    which are mainly divided into two categories—**SQL** and **NoSQL**. There are
    a number of databases under each category that can be used depending on the business
    use case because each one has different characteristics and serves a different
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will integrate a Go web application with the most famous
    open source databases—**MySQL** and **MongoDB** and learn to perform CRUD operations
    on them. As we will use MySQL and MongoDB, I assume both of the databases are
    installed and running on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating MySQL and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume you are a developer and want to save your application data in a
    MySQL database. As a first step, you have to establish a connection between your
    application and MySQL, which we will cover in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether MySQL is installed and running locally on port `3306` by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53efed06-d9a0-4f73-b865-85ba8e619fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, log into the MySQL database and create a mydb database, executing the
    commands as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04132684-d375-44e4-88cc-dd91026a9a36.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/go-sql-driver/mysql` package, using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `connect-mysql.go`. Then we connect to the MySQL database and perform
    a `SELECT` query to get the current database name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to `http://localhost:8080/` will return you the current database name,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec5b9a53-7f99-40b2-91f4-d38bc84233d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "database/sql" "fmt" "log" "net/http" _ "github.com/go-sql-driver/mysql")`,
    we imported `github.com/go-sql-driver/mysql` for its side effects or initialization,
    using the underscore in front of an import statement explicitly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `var db *sql.DB`, we declared a private `DB` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the project size, you can declare a DB instance globally, inject
    it as a dependency using handlers, or put the connection pool pointer into `x/net/context`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined an `init()` function where we connect to the database passing
    the database driver name and data source to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we defined a `getCurrentDb` handler, which basically performs a select
    query on the database to get the current database name, iterates over the records,
    copies its value into the variable, and eventually writes it to an HTTP response
    stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating your first record in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating or saving a record in a database requires us to write SQL queries and
    execute them, implement **object-relational mapping** (**ORM**), or implement
    data-mapping techniques.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be writing a SQL query and executing it using the `database/sql`
    package to create a record. To achieve this, you can also implement ORM using
    any library from a number of third-party libraries available in Go, such as `https://github.com/jinzhu/gorm`,
    `https://github.com/go-gorp/gorp`, and `https://github.com/jirfag/go-queryset`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already established a connection with the MySQL database in our previous
    recipe, we will just extend it to create a record executing a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating a record, we have to create a table in the MySQL database,
    which we will do by executing the commands shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cf3005e-2549-4802-b109-2d2c18bc9a27.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `create-record-mysql.go`. Then we connect to the MySQL database and
    perform an INSERT query to create an employee record, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing a `POST` request to create an employee record from the command line
    as follows will give you the ID of the last record created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ("database/sql" "fmt" "log" "net/http" "strconv" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`, we imported `github.com/gorilla/mux` to create a Gorilla
    Mux Router and initialized the Go MySQL driver, importing the `github.com/go-sql-driver/mysql`
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `createRecord` handler, which fetches the name from the request,
    assigns it to the local variable name, prepares an `INSERT` statement with a name
    placeholder that will be replaced dynamically with the name, executes the statement,
    and eventually writes the last created ID to an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading records from MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created an employee record in the MySQL database.
    Now, in this recipe, we will learn how we can read it by executing a SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `read-record-mysql.go` where we connect to the MySQL database, perform
    a `SELECT` query to get all the employees from the database, iterate over the
    records, copy its value into the struct, add all of them to a list, and write
    it to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to `http://localhost:8080/employees` will list all the records from
    the employee table as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c289af02-53f5-42d2-8b78-582b369e93fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "database/sql" "encoding/json" "log" "net/http" _ "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux")`, we imported an additional package, `encoding/json`,
    which helps in marshalling the Go data structure to `JSON`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we declared the Go data structure `Person`, which has `Id` and `Name`
    fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do remember that the field name should begin with a capital letter in the type
    definition or there could be errors.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `readRecords` handler, which queries the database to get
    all the records from the employee table, iterates over the records, copies its
    value into the struct, adds all the records to a list, marshals the object list
    to JSON, and writes it to an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating your first record in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a scenario where you have created a record for an employee in a database
    with all its details, such as name, department, address, and so on, and after
    some time the employee changes departments. In that case, we have to update their
    department in a database so that their details are in sync all across the organization,
    which can be achieved using a `SQL UPDATE` statement, and in this recipe we will
    learn how we can implement it in Go.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `update-record-mysql.go`. Then we connect to the MySQL database, update
    the name of an employee for an ID, and write the number of records updated in
    a database to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, executing a `PUT` request from the command line to update an employee
    record with the ID as `1` will give you the number of records updated in the database
    as a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined an `updateRecord` handler, which gets the ID to be updated in the
    database as a URL path variable path, and the new name as the request variable,
    prepares an `update` statement with a name and UID as a placeholder, which will
    be replaced dynamically, executes the statement, gets the number of rows updated
    as a result of its execution, and writes it to an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we registered an `updateRecord` handler to be called for the URL pattern `/employee/update/{id}` for
    every `PUT` request with the `gorilla/mux` router and closed the database using
    the `defer db.Close()` statement once we return from the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting your first record from MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a scenario where an employee has left the organization and you want
    to revoke their details from the database. In that case, we can use the `SQL DELETE`
    statement, which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `github.com/go-sql-driver/mysql` and `github.com/gorilla/mux` packages,
    using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `delete-record-mysql.go`. Then we connect to the MySQL database, delete
    the name of an employee from the database, and write the number of records deleted
    from a database to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, executing a `DELETE` request from the command line to delete an employee
    with the name as `bar` will give you the number of records deleted from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined a `deleteRecord` handler, which gets the name to be deleted from
    the database as the request variable, prepares a `DELETE` statement with a name
    as a placeholder, which will be replaced dynamically, executes the statement,
    gets the count of rows deleted as a result of its execution, and writes it to
    an HTTP response stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we registered a `deleteRecord` handler to be called for the URL pattern `/employee/delete`
    for every `DELETE` request with `gorilla/mux` router and closed the database using
    the `defer db.Close()` statement once we returned from the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrating MongoDB and Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you want to persist data in a MongoDB database, the first step you
    have to take is to establish a connection between the database and your web application,
    which we will be covering in this recipe using one of the most famous and commonly
    used MongoDB drivers for Go - `gopkg.in/mgo.v2`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `MongoDB` is installed and running locally on port `27017` by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/063c04f9-4a03-455a-b1f7-723eba8828e7.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `gopkg.in/mgo.v` package, using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `connect-mongodb.go`. Then we connect to the `MongoDB` database, get
    all the database names from the cluster, and write them to an HTTP response stream,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsing to `http://localhost:8080/` will list you the name of all the databases
    that exist in the MongoDB cluster and will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3f544b8-eaf5-4716-8018-51e858236b81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "fmt" "log" "net/http" "strings" mgo
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"gopkg.in/mgo.v2" )`, we imported `gopkg.in/mgo.v2` with the package alias
    name as `mgo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `var session *mgo.Session`, we declared the private MongoDB `Session`
    instance, which acts as a communication session with the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `var connectionError error`, we declared a private `error` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined the `init()` function, where we connected to MongoDB, passing
    the host as `127.0.0.1`, which means both MongoDB and the application are running
    on the same machine at port `27017`, optionally switching the session to a monotonic
    behavior so that the read data will be consistent across sequential queries in
    the same session, and modifications made within the session will be observed in
    the queries that follow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your MongoDB is running on a port other than `27017`, then you have to pass
    both the host and port separated by a colon, as: `mgo.Dial("localhost:27018")`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined a `getDbNames` handler, which basically gets all the database
    names from the MongoDB cluster and writes them to an HTTP response stream as a
    comma-separated string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating your first document in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how we can create a BSON document (a binary-encoded
    serialization of JSON-like documents) in a database, using a MongoDB driver for
    Go ([gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `gopkg.in/mgo.v2` and `github.com/gorilla/mux` packages, using
    the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `create-record-mongodb.go`. Then we connect to the MongoDB database,
    create an employee document with two fields—ID and name—and write the last created
    document ID to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, executing a `POST` request to create an employee document from the command
    line as follows will give you the ID of the document created in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "fmt" "log" "net/http" "strconv" "github.com/gorilla/mux" mgo
    "gopkg.in/mgo.v2")`, we imported `github.com/gorilla/mux` to create a Gorilla
    Mux Router and `gopkg.in/mgo.v2` with the package alias name as `mgo`, which will
    act as a MongoDB driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `createDocument` handler, which fetches the name and ID of
    an employee from the HTTP request. Because request variables are of type `string`,
    we converted the variable ID of `string` type to `int` type. Then, we get the
    employee collection from MongoDB and call the `collection.Insert` handler to save
    an instance of the `Employee` struct type in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading documents from MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a BSON document in MongoDB. Now, in this
    recipe, we will learn how to read it using the `gopkg.in/mgo.v2/bson` package,
    which helps to query the MongoDB collection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `read-record-mongodb.go`. Then we connect to the MongoDB database, read
    all the documents from an employee collection, marshal the list to JSON, and write
    it to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, browsing to `http://localhost:8080/employees` will give you the list
    of all employees from the MongoDB employee collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76fe5abd-4e48-4d30-aa23-d97d15b85a61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at the changes we introduced in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ( "encoding/json" "log" "net/http" "github.com/gorilla/mux" mgo
    "gopkg.in/mgo.v2" "gopkg.in/mgo.v2/bson")`, we imported an additional `gopkg.in/mgo.v2/bson`
    package, which is a BSON specification for Go, and the `encoding/json` package,
    which we used to marshal the object list, which we got from MongoDB, to `JSON`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we defined a `readDocuments` handler, where we first get the employee
    collection from MongoDB, query for all the documents inside it, iterate over the
    documents to map it to an array of the `Employee` struct, and, finally, marshal
    it to `JSON`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating your first document in MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a BSON document is created we may need to update some of its fields. In
    that case, we have to execute `update/upsert` queries on the MongoDB collection,
    which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `update-record-mongodb.go`. Then we connect to the MongoDB database,
    update the name of an employee for an ID, and write the number of records updated
    in MongoDB to an HTTP response stream, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, executing a `PUT` request to `UPDATE` an employee document from the command
    line as follows will give you the number of documents updated in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined an `updateDocument` handler, which gets the ID to be updated in MongoDB
    as a URL path variable and the new name as the HTTP request variable. As request
    variables are of string type, we have converted the variable ID of `string` type
    to `int` type. Then, we get the employee collection from MongoDB and call the
    `collection.Upsert` handler to insert if not present, or update an employee document
    with a new name for the supplied ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we registered an `updateDocument` handler to be called for the URL pattern `/employee/update/{id}` for
    every `PUT` request with `gorilla/mux` router and close the MongoDB session, using
    the `defer session.Close()` statement once we return from the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting your first document from MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we want to clean up the database or delete the documents that are no
    longer needed, we can easily remove them using a MongoDB driver for Go ([gopkg.in/mgo.v2](http://gopkg.in/mgo.v2)),
    which we will be covering in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `gopkg.in/mgo.v2`, `gopkg.in/mgo.v2/bson`, and `github.com/gorilla/mux`
    packages, using the `go get` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `delete-record-mongodb.go`. Then we connect to MongoDB, get the name
    of an employee to be deleted from the database as an HTTP request variable, get
    the named collection, and remove the document, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, executing a `DELETE` request to delete a BSON document from the command
    line as follows will give you the name of the document deleted from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: We defined a `deleteDocument` handler, which gets the name to be deleted from
    MongoDB as the request variable, gets the employee collection from MongoDB, and
    calls the `collection.Remove` handler to remove a document for a given name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we registered a `deleteDocument` handler to be called for the URL pattern `/employee/delete` for
    every `DELETE` request with a `gorilla/mux` router, and closed the MongoDB session, using
    the `defer session.Close()` statement once we returned from the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
