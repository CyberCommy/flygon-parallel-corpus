- en: Proper Creation of Vue Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确创建Vue项目
- en: In this chapter, we'll be looking at how we can create maintainable Vue projects,
    and take advantage of the many tools and patterns available. If you currently
    aren't maximizing the use of these things within your development workflow, you
    may find that the majority of the concepts we discuss in this chapter are applicable
    to other technologies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何创建可维护的Vue项目，并充分利用许多可用的工具和模式。如果您目前在开发工作流程中没有充分利用这些功能，您可能会发现本章讨论的大部分概念也适用于其他技术。
- en: 'In this chapter, we will be looking at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Vue devtools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue devtools
- en: Visual Studio Code extensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code扩展
- en: TypeScript integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript集成
- en: Reactivity with RxJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJS进行响应式编程
- en: Visual Studio Code extensions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code扩展
- en: 'Our development environment is an important part of application development.
    When using Visual Studio Code to create Vue applications, the following extensions
    are recommended:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发环境是应用程序开发的重要部分。在使用Visual Studio Code创建Vue应用程序时，建议安装以下扩展：
- en: Vetur
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vetur
- en: Vue 2 Snippets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue 2 Snippets
- en: Let's take a look at both of these in more detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这两个。
- en: Vetur
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vetur
- en: 'Vetur is powered by the Vue Language Server and provides us with syntax highlighting,
    Emmet (for increased HTML/CSS workflow), snippets, linting, IntelliSense, and
    more. This greatly improves our development experience and is widely supported,
    with over 1,000 stars on GitHub. To install the extension, click the Extensions
    icon within Visual Studio Code and type `Vetur`; from here, you can select Install
    and it''ll automatically be used throughout your project(s):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vetur由Vue语言服务器提供支持，为我们提供语法高亮、Emmet（用于增加HTML/CSS工作流程）、代码片段、linting、IntelliSense等功能。这极大地改善了我们的开发体验，并得到了广泛的支持，在GitHub上有超过1,000个星标。要安装该扩展，点击Visual
    Studio Code中的扩展图标，然后输入`Vetur`；从这里，您可以选择安装，它将自动在您的项目中使用：
- en: '![](assets/cc72dedd-cdee-4a3a-ae5d-12840c66693a.png)Installing Vetur'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/cc72dedd-cdee-4a3a-ae5d-12840c66693a.png)安装Vetur'
- en: 'This then gives us access to snippets such as `scaffold`, which generates a
    new blank template, script, and style object(s) for us to use within our Vue components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以访问到诸如`scaffold`之类的代码片段，它为我们在Vue组件中生成了一个新的空模板、脚本和样式对象：
- en: '![](assets/15c16209-2768-4463-9632-9d735b08bc6e.jpg)Scaffolding a new Vue project'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/15c16209-2768-4463-9632-9d735b08bc6e.jpg)搭建一个新的Vue项目'
- en: Vue 2 Snippets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 2 Snippets
- en: Snippets are an important part of application development; in a similar way
    to Emmet, they allow us to quickly scaffold common patterns within our application.
    We'll also be installing another Visual Studio Code extension that provides us
    with a variety of commonly used snippets named Vue 2 Snippets**.**
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段是应用程序开发的重要部分；与Emmet类似，它们允许我们快速搭建应用程序中常见的模式。我们还将安装另一个名为Vue 2 Snippets的Visual
    Studio Code扩展，该扩展为我们提供了各种常用的代码片段。
- en: 'This allows us to save a substantial amount of time that we otherwise would
    have had to spend writing out the same boilerplate code. Take the next example;
    although it''s simplistic in nature, we get a description of the snippet, and
    with a hit of *Tab* it expands to our predefined code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以节省大量时间，否则我们将不得不花费时间编写相同的样板代码。接下来的例子，虽然它很简单，但我们可以得到代码片段的描述，然后按下*Tab*键，它就会扩展为我们预定义的代码：
- en: '![](assets/234a2a64-d70c-44f4-902d-6c6c603f10be.jpg)Taking advantage of Vue
    snippets'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/234a2a64-d70c-44f4-902d-6c6c603f10be.jpg)充分利用Vue代码片段'
- en: Vue CLI
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue CLI
- en: The Vue **Command Line Interface** (**CLI**) allows us to quickly scaffold new
    Vue projects with a variety of different template options. Currently, the template
    options available include technologies such as Webpack, Browserify, and Progressive
    Web Application features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vue **命令行界面**（**CLI**）允许我们快速使用各种不同的模板选项搭建新的Vue项目。目前，可用的模板选项包括Webpack、Browserify和渐进式Web应用程序功能等技术。
- en: Sure, we could create our own Vue application and manually add tools such as
    Webpack, but this creates technical overhead in the sense that we have to learn,
    build, and maintain our configuration. The Vue CLI does this for us while maintaining
    a select set of official templates, but doesn't restrict us from modifying the
    generated Webpack configuration. All of this allows us to generate new unopinionated
    Vue projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以创建自己的Vue应用程序，并手动添加诸如Webpack之类的工具，但这会在技术上增加负担，因为我们必须学习、构建和维护我们的配置。Vue
    CLI可以为我们做到这一点，同时保持一组官方模板，但不限制我们修改生成的Webpack配置。所有这些都允许我们生成新的无偏见的Vue项目。
- en: 'To start using the Vue CLI, let''s ensure we have it installed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Vue CLI，让我们确保已经安装了它：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then use the Vue `init` command to scaffold a new Vue project using
    the Webpack template:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Vue `init`命令使用Webpack模板搭建一个新的Vue项目：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On entering the preceding command we should get the following as shown on the
    Terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述命令后，我们应该在终端上看到以下内容：
- en: '![](assets/ddc98095-267c-405f-bed1-fda9f1cfd584.png)Creating projects with
    Vue init'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ddc98095-267c-405f-bed1-fda9f1cfd584.png)使用Vue init创建项目'
- en: If we break this down, we're essentially initializing a new Vue project based
    on the webpack-simple template named my-vue-project. We're then navigated to a
    wizard process that asks us for more metadata about our project. This metadata
    and configuration will differ depending on the template you choose.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解这个，实质上我们正在基于webpack-simple模板初始化一个新的Vue项目，名为my-vue-project。然后我们会进入一个向导过程，询问我们关于项目的更多元数据。这些元数据和配置将根据您选择的模板而有所不同。
- en: 'Let''s investigate the files and folders that the template created:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究模板创建的文件和文件夹：
- en: '| **File/Folder** | **Description** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **文件/文件夹** | **描述** |'
- en: '| `src/` | This folder contains all of our project code. We''ll spend the majority
    of our time within src. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `src/` | 这个文件夹包含我们项目的所有代码。我们将在src中花费大部分时间。 |'
- en: '| `.bablrc` | This is our Babel configuration file that allows us to write
    ES2015 and have it appropriately transpiled. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `.bablrc` | 这是我们的Babel配置文件，允许我们编写ES2015并进行适当的转译。 |'
- en: '| `index.html` | This is our default HTML file. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `index.html` | 这是我们的默认HTML文件。 |'
- en: '| `package.json` | This holds our dependencies and other project-specific metadata.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `package.json` | 这个文件包含我们的依赖和其他项目特定的元数据。 |'
- en: '| `webpack.config.js` | This is our Webpack configuration file, allowing us
    to use `.vue` files, Babel, and more. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `webpack.config.js` | 这是我们的Webpack配置文件，允许我们使用`.vue`文件、Babel等。 |'
- en: Notice how we're no longer working with `.js` files, and we now have `.vue`
    files inside of our `src` directory. A Vue file is known as a Single File Component
    and it has a template, script, and style tag, allowing us to scope everything
    to this component only.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不再使用`.js`文件，现在我们的`src`目录里有`.vue`文件。Vue文件被称为单文件组件，它包含模板、脚本和样式标签，允许我们将所有内容限定在这个组件内部。
- en: This is possible due to our Webpack template, as we have a custom "loader".
    How does this work? Prior to looking at this, let's take a quick detour and review
    modern JavaScript build systems.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为我们有一个自定义的“loader”。这是如何工作的？在看这个之前，让我们快速了解一下现代JavaScript构建系统。
- en: JavaScript modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模块
- en: In order to create reusable modular code, our aim should be to have one file
    per feature in most cases. This allows us to avoid the dreaded "Spaghetti code"
    anti-pattern, where we have strong coupling and little separation of concerns.
    Continuing with the pasta-oriented theme, the solution to this is to embrace the
    "Ravioli code" pattern with smaller, loosely coupled, distributed modules that
    are easier to work with. What does a JavaScript module look like?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'In ECMAScript2015, a module is simply a file that uses the `export` keyword,
    and allows other modules to then import that piece of functionality:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We could then `import` `add` from another module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As browsers haven't fully caught up with module imports yet, we often use tools
    to assist with the bundling process. Common projects in this area are Babel, Bublé,
    Webpack, and Browserify. When we create a new project with the Webpack template,
    it uses the Vue-loader to transform our Vue components into a standard JavaScript
    module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Vue-loader
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside of our `./webpack-config.js` within the standard `webpack-simple` template,
    we have a module object that allows us to set up our loader; this tells Webpack
    that we''d like it to use `.vue` files inside of our project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For this to work, Webpack runs a regular expression for anything that matches
    `.vue` and then passes this to our `vue-loader` to be transformed into a plain
    JavaScript module. In this simple example, we're loading files with a `.vue` extension,
    but `vue-loader` can be further customized and you may want to look into this
    further ([https://goo.gl/4snNfD](https://goo.gl/4snNfD)). We could certainly do
    this configuration ourselves, but hopefully, you can see the benefits of using
    the Vue CLI to generate our Webpack projects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Loading modules without Webpack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Webpack helps us in more ways than simply loading a module, we can
    load a JavaScript module at this moment in time natively in the browser. It tends
    to perform worse than bundling tools (at the time of writing), but this may change
    over time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s head over to the terminal and make a simple counter
    with a project based on the simple template. This template effectively starts
    a new Vue project without any bundling tools:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then edit our `index.html` to add script files from `type="module"`
    this allows us to use the export/import syntax outlined before:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Warning: Ensure that your browser is up to date so that the preceding code
    can run successfully.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside of our `counter.js`, we can export a new `default` object, which
    acts as a new Vue instance. It acts as a simple counter that allows us to either
    increment or decrements a value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then import the `counter.js` file inside of `app.js`, thus demonstrating
    the ways we can import/export modules. To get our counter to display inside of
    our root Vue instance, we''re registering the counter as a component inside this
    instance, and setting the template to `<counter></counter>`, the name of our component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll look at this in more detail in future sections of the book, but all you
    need to know at this point is that it effectively acts as another Vue instance.
    When we register the component inside of our instance, we're only able to access
    this component from that instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome! Here are the results of our module import/exports:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0439ff73-38f9-4452-88a0-6c0695188524.png)Vue.js Modules'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a deeper look at debugging our Vue applications,
    and the role Vue devtools plays in this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: VueJS devtools
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to accurately debug our application is an important part of our
    development workflow. In the previous chapter, we installed the VueJS devtools,
    and we''ll be looking at using it in more detail within this section. Let''s make
    a playground project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then open up our developer console and navigate to the Vue tab. When
    we select App from within the components list, we can see the data object(s) and
    other information for this component. By default, we have the `msg` variable that
    we''re then binding to within our template, and we can see this within our developer
    tools:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9b7c49cd-7e51-45ff-9ba0-992d0231b6cc.png)Inspecting a Vue instance'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'This goes both ways though - we could access the objects inside of this Vue
    instance with `$vm0.$data`, scoping this to `msg`. To view this within the console,
    selecting `<Root>` then `<App>` will display the `msg`0;within the console. We
    can change this value and as Vue is watching the value, it will automatically
    change on screen:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5e7927c-b0ee-4b93-a634-9116253f9c37.png)Editing Vue instance data
    from the console'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Notice how our message has changed to `"Hello Vue Devtools!"`; if we had multiple
    Vue instances, there would be other prefixed versions of Vue with `$vm1`, `$vm2`,
    and so on. Later in the book when we come to using `Vuex`, we'll be using this
    often. Next, let's take a look at how we can integrate TypeScript into our Vue
    projects. This is useful for those with an Angular background or anyone that's
    looking to take advantage of static typing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript and Vue
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have used TypeScript in the past, or you may be curious about how you
    can take advantage of the extra tooling TypeScript provides inside of your Vue
    projects. Why use TypeScript? A recent study by Gao et al found that TypeScript/static
    typing tools reduced committed bugs by 15% ([https://goo.gl/XUTPf4](https://goo.gl/XUTPf4)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve used Angular before, this syntax should make you feel right at home,
    as we''ll be using decorators and ES2015 classes. Let''s investigate how we can
    add TypeScript to a project built with the Vue CLI:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should get the following output on the Terminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c023a2c4-80d8-4527-aca1-b542d61685d3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'If we navigate to our project directory and run `npm install` as per the instructions,
    we then need to install the TypeScript loader and edit our Webpack configuration.
    This allows us to load `.ts` files inside of the project, and because we''ve used
    the `webpack-simple` template, it''s as simple as installing the loader and making
    a few changes. At the same time, we can also install TypeScript to the project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We then need to make some changes to our Webpack configuration to add our new
    loader. Hot Module Replacement is enabled by default, so there is no need to refresh
    to see any changes once loaded.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Remember to run the project from the command line, and type `npm dev`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change our entry point to be `main.ts` (and subsequently rename
    it), as well as define the `ts-loader` and remove the `babel-loader` in order
    to do it, and edit the `webpack.config.js` file, pasting the following contents:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, we can create a `tsconfig.json` inside of our project root, which
    is responsible for appropriately configuring our TypeScript setup:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'TypeScript is now set up in our project, but to truly take advantage of this
    within our Vue applications we should also use `vue-class-component`. This allows
    us to take advantage of static typing on our component properties, as well as
    define components as native JavaScript classes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can then define our `App.vue` file by first specifying it as a script with
    the `lang="ts"` attribute. We can then import Vue as always, but as well as this,
    we're also importing `Component` from `vue-class-component` to be used as a decorator
    within this file. This allows us to specify this as a new Vue component, and using
    the Component decorator we can define properties, templates, and more.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of our Component decorator, we''re specifying a template with an input
    box and button. This example allows us to see how we can bind to class properties,
    as well as call methods from our class. The following code should replace the
    code already in the `App.vue` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running the preceding code, you should get something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d9abed5a-93a7-495b-8592-96c52b9268ec.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Lifecycle hooks
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifecycle hooks such as `created()`, `mounted()`, `destroyed()`, and so on can
    be defined as functions within the class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`created()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows for actions to be performed to a component before it is added into
    the DOM. Using this hook allows access to both data and events.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`mounted()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounted gives access to a component before it is rendered as well as after it
    has been rendered. It provides full access for interacting with the DOM and component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '`destroyed()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything that was attached to the component has been destroyed. It allows
    for cleanup of the component when it is removed from the DOM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'They''ll be recognized and act the same way as expected without TypeScript.
    Here''s an example when using the `created` and `mounted` hooks:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now if we head over to the console, we can see that the message of ''Hello''
    is outputted with the name of Paul:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/429bcf4f-96d4-4d7e-a833-13c72456ac3a.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Properties
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how we can create classes and use the Component decorator; let''s
    now take a look at how we can define "props" inside of our class using the `vue-property-decorator`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This depends on the `vue-class-component`, so anytime we install `vue-property-decorator`
    you''ll need to ensure `vue-class-component` is also installed. Let''s then define
    a `Component` property using the `@Prop` decorator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Notice how we''re now importing the `Component` from `''vue-property-decorator''`
    instead of `vue-class-component`. This is because it exports this as a module
    for us to import. We''re then defining a new component property with the key of
    name and the `default` value of `''Paul Halliday''`; prior to using TypeScript,
    it would have looked as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Computed
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Computed properties allow for multiple expressions to be passed, and these
    properties on the Vue instance require the use of class getters/setters. So, if
    we wanted to retrieve a reversed version of our name, we could simply pass the
    following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This would otherwise have been equivalent to:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other decorators can be used, such as `@Watch`, `@Inject`, `@Model`, and `@Provide`.
    Each decorator allows for a consistent implementation, and provides a similar
    API to the vanilla Vue instance. In the next section, we're going to look at how
    we can enhance the reactivity of our Vue applications with RxJS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: RxJS and Vue
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from an Angular background, you'll most likely feel right at home
    with *at least* the basic concepts of RxJS. This means we're usually dealing with
    things such as Observables, Subjects, and a variety of operators. If you haven't
    used them before, not to worry - we'll be investigating what RxJS is, and why
    we'd want to use it within Vue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: What is RxJS?
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look at the RxJS documentation, we''re greeted with the following definition:
    *"**ReactiveX is a library for composing asynchronous and event-based programs
    by using observable sequences"* ([http://reactivex.io/intro.html](http://reactivex.io/intro.html)).
    At first glance, this is not exactly a description that makes us feel comfortable
    using this within our projects.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: RxJS assists us in using reactive programming principles inside of our application,
    often referred to as a more declarative style rather than imperative. When we
    talk about an imperative programming style, we're usually telling the computer
    the exact steps of how to do a particular task. A declarative style allows us
    to focus more on the expected outcome rather than the implementation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, we can create an `event` stream by using the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This then allows us to observe any mouse clicks on the document. We can capture
    things such as the click coordinates, target, event type, and so on. Evidently,
    this is an asynchronous observable data stream. We don't know when someone is
    going to click the screen, nor do we care. All we do is observe and perform a
    particular action when that event occurs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: We can use RxJS to take these same principles and apply it to our modern day
    applications where everything is a stream. We could have an observable data stream
    of everything from a Facebook feed to document click events, timers, anything!
    Everything can be a stream.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Vue
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate RxJS with Vue, we'll need to make a new Vue project and install
    both RxJS and Vue-Rx. One of the great things about using the Vue-Rx plugin is
    that it's officially supported by the Vue.js team, which gives us confidence that
    it'll be supported in the long term.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new project with the Vue CLI, and integrate RxJS:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now need to tell Vue that we''d like to use the `VueRx` plugin. This can
    be done using `Vue.use()`, and is not specific to this implementation. Any time
    we''re looking to add new plugins to our Vue instance(s), calling `Vue.use()`
    makes an internal call to the plugin''s `install()` method, extending the global
    scope with the new functionality. The file to edit will be our `main.js` file,
    which is located at `src/main.js`. We''ll be looking at plugins in more detail
    within later chapters of this book:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice any issues with the preceding implementation? Well, in the interests
    of application performance and reducing bundle size, we should only import what
    we need. This then becomes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then create an `Observable` data stream inside of our Vue application.
    Let''s head over to `App.vue`, and import the necessary modules from RxJS:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then create a new `Observable` of data; in this example, we''ll be using
    a simple array of people:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This then allows us to subscribe to this `Observable` from within the subscriptions
    object. If you''ve ever used Angular before, this allows us to access the `Observable`
    (and handles the necessary unsubscription) similar to the Async pipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As well as this, if we wanted to create a new instance of our `Observable`
    for each component, we can instead declare our subscriptions as a function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we can then display the results of the `Observable` inside of our
    template. We can use the `v-for` directive to iterate over the array and display
    the results on screen. How does this work? Using the following example, the `v-for`
    syntax uses an `item in items` syntax, which can be thought of a `person in people$`
    in our context. This allows us to access each item inside of our `people$` Observable
    (or any other array) with interpolation binding:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see inside of the browser, our three items have now appeared on
    the screen inside of our list item:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2230e189-f1b4-412e-9141-6a0dfc296b15.png)Iterating over RxJS Observables'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can take advantage of the Vue CLI to scaffold
    new Vue projects with appropriate bundling configurations and ES2015 support.
    We've seen that not only does this give us extra power, but it also saves us a
    significant amount of time in the long run. We don't have to remember how to create
    a Webpack or Babel configuration, as this is all handled for us by the starter
    templates; but even still, if we want to add extra configuration options, we can.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how we can implement TypeScript with Webpack and the `ts-loader`,
    as well as taking advantage of common TypeScript and Vue patterns with the property
    decorator(s). This allows us to take advantage of core tooling and help reduce
    bugs in our code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also implemented RxJS and Vue-Rx in our application to take advantage
    of the Observable pattern. If you're interested in using RxJS inside of your projects,
    this is a good starting point for future integrations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a deeper look at the Vue.js instance
    and the different reserved properties, such as data, computed, ND watch, as well
    as creating getters and setters. This chapter especially considers when you should
    use computed to use or watch properties.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll be investigating how a Vue.js instance works at a lower
    level by looking at how this is handled by Vue. We'll also be looking at the various
    properties on our instance such as data, computed, watch, as well as best practices
    when using each one. Furthermore, we'll be looking at the various lifecycle hooks
    available within our Vue instance, allowing us to call particular functions at
    various stages of our application. Finally, we'll be investigating the **Document
    Object Model** (**DOM**) and why Vue implements a Virtual DOM for enhanced performance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter you will:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Have a greater understanding of how `this` keyword works within JavaScript
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how Vue proxies `this` keyword within Vue instances
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data properties to create reactive bindings
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use computed properties to create declarative functions based on our data model
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use watched properties to access asynchronous data and build upon the foundations
    of computed properties
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lifecycle hooks to activate functionality at particular stages of the Vue
    lifecycle
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigate the DOM and Virtual DOM for an understanding of how Vue renders
    data to the screen
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, let's start off by looking into how this works within JavaScript and
    how this relates to the context within our Vue instances.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Proxying
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you may have interacted with a Vue application and thought to yourself:
    How does `this` work the way it does? Before looking into how Vue.js handles `this`,
    let''s have a look at how it works within JavaScript.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: How 'this' works within JavaScript
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within JavaScript, `this` has varying contexts that range from the global window
    context to eval, newable, and function contexts. As the default context for this
    relates to the global scope, this is our window object:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The context of this changes depending on where we are in scope. This means,
    that if we had a `Student` object with particular values, such as `firstName`,
    `lastName`, `grades`, and so on, the context of `this` would be related to the
    object itself:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we run the preceding code with `console.log(Student.toString())`, we get
    this: `Student Paul Halliday scored 315/500` as the context of this is now scoped
    to the object itself rather than the global window scope.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to display this in the document we could do it like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that, with the preceding code, once again we don't have to use `this`
    as it isn't needed with the global context.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how `this` works at a basic level, we can
    investigate how Vue proxies `this` inside of our instances to make interacting
    with the various properties much easier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: How Vue handles 'this'
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed up to this point that we're able to reference values inside
    of our data, methods, and other objects using `this` syntax, but the actual structure
    of our instance is `this.data.propertyName` or `this.methods.methodName`; all
    of this is possible due to the way Vue proxies our instance properties.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a very simple Vue application that has one instance. We have a `data`
    object that has a `message` variable and a method named `showAlert`; how does
    Vue know how to access our alert text with `this.message`?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Vue proxies the instance properties to the top level object, allowing us to
    access these properties via this. If we were to log out the instance to the console
    (with the help of Vue.js devtools), we''d get the following result:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41cc6781-067d-452c-8da3-53bb10569abb.png)Console logout'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The key properties to look at within the preceding screenshot are `message`
    and `showAlert`, both of which are defined on our Vue instance yet proxied to
    the root object instance at initialization time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Data properties
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a variable to our data object, we''re essentially creating a reactive
    property that updates the view any time it changes. This means that, if we had
    a data object with a property named `firstName`, that property would be re-rendered
    on the screen each time the value changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This reactivity does not extend to objects added to our Vue instance after
    the instance has been created outside of the data object. If we had another example
    of this, but this time including appending another property such as `fullName`
    to the instance itself:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Even though this item is on the root instance (the same as our `firstName` variable),
    `fullName` is not reactive and will not re-render upon any changes. This does
    not work because, when the Vue instance is initialized, it maps over each one
    of the properties and adds a getter and setter to each data property, thus, if
    we add a new property after initialization, it lacks this and is not reactive.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Vue achieve reactive properties? Currently, it uses `Object.defineProperty`
    to define a custom getter/setter for items inside of the instance. Let''s create
    our own property on an object with standard `get`/`set` features:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As the watchers are set with a custom property setter/getter, merely adding
    a property to the instance after initialization doesn't allow for reactivity.
    This is likely to change within Vue 3 as it will be using the newer ES2015+ Proxy
    API (but potentially lacking support for older browsers).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: There's more to our Vue instance than a data property! Let's use computed to
    create reactive, derived values based on items inside of our data model.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be looking at computed properties within our Vue instance.
    This allows us to create small, declarative functions that return a singular value
    based on items inside of our data model. Why is this important? Well, if we kept
    all of our logic inside of our templates, both our team members and our future
    self would have to do more work to understand what our application does.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can use computed properties to vastly simplify our templates and
    create variables that we can reference instead of the logic itself. It goes further
    than an abstraction; computed properties are cached and will not be recalculated
    unless a dependency has changed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple project to see this in action:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Interpolation is powerful; for example, inside of our Vue.js templates we can
    take a string (for example, `firstName`) and reverse this using the `reverse()`
    method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We'll now be showing a reversed version of our `firstName`, so Paul would become
    luaP. The issue with this is that it's not very practical to keep logic inside
    of our templates. If we'd like to reverse multiple fields, we have to then add
    another `split()`, `reverse()`, and `join()` on each property. To make this more
    declarative, we can use computed properties.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of `App.vue`, we can add a new computed object, that contains a function
    named `reversedName`; this takes our logic for reversing our string and allows
    us to abstract this into a function containing logic that would otherwise pollute
    the template:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We could then see more information about our computed properties within Vue.js
    devtools:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/016c15d1-b6a4-4798-a04f-f37bcdc56ba3.png)Using devtools to display
    data'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, it's important to realize that, while we could make this
    a method, there are reasons why we should keep this as a computed property. Computed
    properties are cached and are not re-rendered unless their dependency changes,
    which is especially important if we have a larger data-driven application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Watched properties
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are not always the answer to our reactive data problems,
    sometimes we need to create our own custom watched properties. Computed properties
    can only be synchronous, must be pure (for example, no observed side-effects),
    and return a value; this is in direct contrast to a watched property, which is
    often used to deal with asynchronous data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'A watched property allows us to reactively execute a function whenever a piece
    of data changes. This means that we can call a function every time an item from
    our data object changes, and we''ll have access to this changed value as a parameter.
    Let''s take a look at this with a simple example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: `Axios` is a library that will need to be added to the project. To do
    so, head to [https://github.com/axios/axios](https://github.com/axios/axios) and
    follow the installation steps provided.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, any time our text box changes with a new `id` (1-10), we get
    information about that particular user, like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/63948d07-5f10-4348-ab27-e44f5bc310e8.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: This is effectively watching for any changes on the `id` and calling the `getDataForUser`
    method, retrieving new data about this user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Although watched properties do have a lot of power, the benefits of computed
    properties on performance and ease of use should not be understated; therefore
    wherever possible, favor computed properties over watched properties.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have access to a variety of lifecycle hooks that fire at particular points
    during the creation of our Vue instance. These hooks range from prior to creation
    with `beforeCreate`, to after the instance is `mounted`, `destroyed`, and many
    more in between.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: As the following figure shows, the creation of a new Vue instance fires off
    functions at varying stages of the instance lifecycle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be looking at how we can activate these hooks within this section:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ad4f9ba-c04c-44f6-b6a5-3b6e4e297c38.png)Vue.js instance lifecycle
    hooks'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the lifecycle hooks ([https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html))
    can be done in a similar way to any other property on our Vue instance. Let''s
    take a look at how we can interact with each one of the hooks, starting from the
    top; I''ll be creating another project based on the standard `webpack-simple`
    template:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice how we''ve simply added these functions to our instance without any
    extra imports or syntax. We then get two different log statements in our console,
    one prior to the creation of our instance and one after it has been created. The
    next stage for our instance is the `beforeMounted` and `mounted` hooks; if we
    add these, we''ll be able to see a message on the console once again:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we then modified our template so it had a button that updated one of our
    data properties, we''d be able to fire a `beforeUpdated` and `updated` hook:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Whenever we select the `Update Message` button, our `beforeUpdated` and `updated`
    hooks both fire. This allows us to perform an action at this stage in the lifecycle,
    leaving us only with `beforeDestroy` and destroyed yet to cover. Let''s add a
    button and a method to our instance that call `$destroy`, allowing us to trigger
    the appropriate lifecycle hook:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can then add the `remove` method to our instance, as well as the functions
    that allow us to capture the appropriate hooks:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When we select the `destroy` instance button, the `beforeDestroy` and `destroy`
    lifecycle hooks will fire. This allows us to clean up any subscriptions or perform
    any other action(s) when destroying an instance. In a real-world scenario, lifecycle
    control should be left up to data-driven directives, such as `v-if` and `v-for`.
    We'll be looking at these directives in more detail in the next chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js and the Virtual DOM
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the topic of performance improvements, let's consider why Vue.js makes extensive
    use of the Virtual DOM to render our elements on the screen. Before looking at
    the Virtual DOM, we need to have a foundational understanding of what the DOM
    actually is.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DOM is what is used to describe the structure of an HTML or XML page. It
    creates a tree-like structure that provides us with the ability to do everything
    from creating, reading, updating, and deleting nodes to traversing the tree and
    many more features, all within JavaScript. Let''s consider the following HTML
    page:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''re able to look at the HTML and see that we have one **div**, two **p**,
    one **ul**, and **li** tags. The browser parses this HTML and produces the DOM
    Tree, which at a high level looks similar to this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb087b90-2dfe-4994-ab62-1da34db49db7.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'We can then interact with the DOM to get access to these elements by `TagName`
    using `document.getElementsByTagName()`, returning a HTML collection. If we wanted
    to map over these collection objects, we could create an array of these elements
    using `Array.from`. The following is an example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This should then log the `innerHTML` of each item to the console inside of
    our array(s), thus showing how we can access items inside of the DOM:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dda3c743-af98-4890-90ef-62707cec011e.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Virtual DOM
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating DOM nodes is computationally expensive and depending on the size of
    your application, this can substantially slow down the performance of your application.
    The Virtual DOM takes the concept of the DOM and provides us an abstraction, which
    allows for a diffing algorithm to be used to update DOM nodes. To fully take advantage
    of this, these nodes are no longer accessed with the document prefix and instead
    are often represented as JavaScript objects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: This allows Vue to work out exactly *what* changed and only re-render items
    in the actual DOM that is different from the previous.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about the Vue instance and how we can take
    advantage of a variety of property types such as data, watchers, computed values,
    and more. We've learned about how `this` works in JavaScript and the differences
    when using it inside of a Vue instance. Furthermore, we've investigated the DOM
    and why Vue uses the Virtual DOM to create performant applications.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In summary, data properties allow for reactive properties within our templates,
    computed properties allow us to take our template and filtering logic and separate
    it into performant properties that can be accessed within our templates, and watched
    properties allow us to work with the complexities of asynchronous operations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking an in-depth look at Vue directives, such
    as `v-if`, `v-model`, `v-for`, and how they can be used to create powerful reactive
    applications.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
