- en: Go on the Front-End with GopherJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since its creation, JavaScript has been the de facto programming language
    of the web browser. Accordingly, it has had a monopoly over front-end web development
    for a very long period of time. It's been the only game in town that comes with
    the capability to manipulate a web page's **Document Object Model** (**DOM**)
    and access various **application programming interfaces** (**APIs**) implemented
    in modern web browsers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Due to this exclusivity, JavaScript has been the only viable option for isomorphic
    web application development. With the introduction of GopherJS, we now have the
    ability to create Go programs in the web browser, which also makes it possible
    to develop isomorphic web applications using Go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: GopherJS allows us to write programs, in Go, that get converted into an equivalent
    JavaScript representation, which is suitable to run in any JavaScript-enabled
    web browser. GopherJS provides us with a viable and attractive alternative to
    using JavaScript, especially if we are using Go on the server side. With Go on
    both ends of the spectrum (front-end and back-end), we have new opportunities
    to share code and eliminate the mental context shifts that come with having to
    juggle different programming languages across environments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic DOM operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GopherJS overview
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GopherJS examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline template rendering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Document Object Model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive deeper into GopherJS, it's important for us to get an appreciation
    of what JavaScript, and by extension—GopherJS, does for us. One of the major capabilities
    that JavaScript has is its ability to access and manipulate the **DOM** (short
    for **Document Object Model**). The DOM is a tree data structure that represents
    the structure of a web page and all of the nodes (elements) that exist within
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The significance of the DOM is that it acts as a programming interface for HTML
    documents, whereby programs that have access to the DOM can change a web page's
    style, structure, and content. Since each node in a DOM tree is an object, the
    DOM can be considered the object-oriented representation of a given web page.
    As such, the objects and their given properties can be accessed and changed using
    JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.1* depicts the DOM hierarchy for a given web page. All elements on
    the web page are children of the **html** node, which is represented by the `<html>` tag
    in the web page''s HTML source code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cae7934-c0ad-4bab-96d3-ff260b9d3422.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: A web page''s DOM hierarchy'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The **head** node is a child of the **html** node and contains two children—meta
    (defined, in HTML, using the `<meta>` tag) and a script node (for an external
    CSS or JavaScript source file). At the same level of the head node exists the
    body node, which is defined using the `<body>` tag.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The body node contains all the elements that are to be rendered on the web page.
    Directly under the body node, we have a child, which is a heading node (defined
    using the `<h1>` tag), that is, the title of the web page. This node has no child
    elements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: At the same level of the heading node, we also have a div node (defined using
    a `<div>` tag). This node contains a div child node, which has two children—a
    paragraph node (defined using the `<p>` tag) and at the same level of this node
    exists an image node (defined using the `<img>` tag).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The image node has no child elements, and the paragraph node has one child element—a
    span node (defined using the `<span>` tag).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript runtime included in the web browser provides us with the functionality
    to access the various nodes in the DOM tree along with their respective values.
    Using the JavaScript runtime, we can access both an individual node, and, if the
    given node contains children, we can access a collection of all the parent's child
    nodes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Since web pages are represented as a collection of objects, using the DOM we
    can access the events, methods, and properties of any given DOM object. In fact,
    the `document` object represents the web page document itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页被表示为一组对象，使用DOM，我们可以访问任何给定DOM对象的事件、方法和属性。事实上，`document`对象代表了网页文档本身。
- en: 'Here''s a helpful introduction to the DOM from the MDN website:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MDN网站上关于DOM的有用介绍：
- en: '[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)。'
- en: Accessing and manipulating the DOM
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和操作DOM
- en: 'As noted previously, we can use JavaScript to access and manipulate the DOM
    for a given web page. Since GopherJS transpiles to JavaScript, we now have the
    capability to access and manipulate the DOM within the confines of Go. *Figure
    3.2* depicts a JavaScript Program accessing/manipulating the DOM along with a
    Go program also accessing/manipulating the DOM:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用JavaScript来访问和操作给定网页的DOM。由于GopherJS转译为JavaScript，我们现在有能力在Go的范围内访问和操作DOM。*图3.2*描述了一个JavaScript程序访问/操作DOM以及一个Go程序也访问/操作DOM：
- en: '![](img/0b73a589-0ac3-48df-9410-e1418404e5b1.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b73a589-0ac3-48df-9410-e1418404e5b1.png)'
- en: 'Figure 3.2: The DOM can be accessed and manipulated by a JavaScript program
    and/or a Go program (using GopherJS)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：DOM可以被JavaScript程序和/或Go程序（使用GopherJS）访问和操作
- en: Now, let's take a look at a few simple programming snippets, where we can access
    the JavaScript functionality using Go, followed by some basic DOM operations using
    JavaScript and their equivalent instruction in GopherJS. For the time being, let's
    get a preview of what coding with GopherJS looks like. These concepts will be
    explained in further detail, as fully fleshed out examples, later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些简单的编程片段，我们可以使用Go访问JavaScript功能，然后使用JavaScript进行一些基本的DOM操作，以及它们在GopherJS中的等效指令。暂时让我们预览一下使用GopherJS编码的样子。这些概念将在本章后面作为完整的例子进行进一步详细解释。
- en: Basic DOM operations
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的DOM操作
- en: In this section, we'll look at a collection of some basic DOM operations. Each
    DOM operation presented includes the equivalent operation performed in JavaScript,
    GopherJS, and using the DOM binding.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些基本的DOM操作集合。每个呈现的DOM操作都包括在JavaScript、GopherJS和使用DOM绑定中执行的等效操作。
- en: Displaying an alert message
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示警报消息
- en: '**JavaScript**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript**'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**GopherJS**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**GopherJS**'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**DOM Binding**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOM绑定**'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'One of the most basic operations we can perform is to show an `alert` message
    in a modal dialog. In JavaScript, we can display the `alert` message using the
    built-in `alert` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行的最基本的操作之一是在模态对话框中显示`alert`消息。在JavaScript中，我们可以使用内置的`alert`函数显示`alert`消息：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code will print out the message `Hello Isomorphic Go!` in a modal
    window dialog. The `alert` function blocks further execution until the user dismisses
    the `alert` dialog.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将在模态窗口对话框中打印出消息`Hello Isomorphic Go!`。`alert`函数会阻止进一步执行，直到用户关闭`alert`对话框。
- en: 'When we make a call to the `alert` method, we are actually calling it in this
    manner:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`alert`方法时，实际上是这样调用的：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `window` object is a global object, representing an open window in the web
    browser. The JavaScript implementation allows us to directly call the `alert`
    function along with the other built-in functions, without explicitly referencing
    them as methods of the window object as a means of convenience.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`对象是一个全局对象，代表浏览器中打开的窗口。JavaScript实现允许我们直接调用`alert`函数以及其他内置函数，而不需要将它们显式地引用为窗口对象的方法，这是一种方便的方式。'
- en: 'We use the `js` package to access the JavaScript functionality through Go,
    using GopherJS. We can import the package into our Go program as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`js`包通过GopherJS访问JavaScript功能。我们可以将包导入到我们的Go程序中，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `js` package provides us with functionality to interact with native JavaScript
    APIs. Calls to functions in the `js` package are translated directly to their
    equivalent JavaScript syntax.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`js`包为我们提供了与原生JavaScript API交互的功能。对`js`包中的函数的调用直接转换为它们等效的JavaScript语法。'
- en: 'We can display an `alert` message dialog using Go, with GopherJS, in the following
    manner:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用GopherJS在Go中以以下方式显示`alert`消息对话框：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, we used the `Call` method that is available to
    the `js.Global` object. The `js.Global` object provides us with JavaScript's global
    object (the `window` object).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`js.Global`对象可用的`Call`方法。`js.Global`对象为我们提供了JavaScript的全局对象（`window`对象）。
- en: 'Here''s what the `Call` method signature looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Call`方法的签名：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Call` method will call the global object's method with the provided name.
    The first parameter provided to the method is the name of the method to call.
    The second parameter is a list of arguments that are to be passed on to the global
    object's method. The `Call` method is known as a variadic function, since it can
    take in a variable number of parameters of the `interface{}` type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Call`方法将调用全局对象的方法，并提供名称。提供给方法的第一个参数是要调用的方法的名称。第二个参数是要传递给全局对象方法的参数列表。`Call`方法被称为可变函数，因为它可以接受`interface{}`类型的可变数量的参数。'
- en: You can learn more about the `Call` method by viewing the GopherJS documentation
    at [https://godoc.org/github.com/gopherjs/gopherjs/js#Object.Call](https://godoc.org/github.com/gopherjs/gopherjs/js#Object.Call).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看GopherJS文档了解更多关于`Call`方法的信息[https://godoc.org/github.com/gopherjs/gopherjs/js#Object.Call](https://godoc.org/github.com/gopherjs/gopherjs/js#Object.Call)。
- en: Now that we've seen how to display the `alert` dialog window using the `Call`
    method of the `js.Global` object, let's take a look at the DOM bindings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用`js.Global`对象的`Call`方法来显示`alert`对话框窗口，让我们来看看DOM绑定。
- en: The `dom` package provides us with convenient GopherJS bindings to the JavaScript
    DOM API. The idea behind using this package, as opposed to performing all operations
    using the `js.Global` object, is that the DOM bindings provides us with an idiomatic
    way to call the common DOM API functionality.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`dom`包为我们提供了方便的GopherJS绑定到JavaScript DOM API。使用这个包的想法是，与使用`js.Global`对象执行所有操作相比，DOM绑定为我们提供了一种惯用的方式来调用常见的DOM
    API功能。'
- en: 'If you are already familiar with the JavaScript APIs used to access and manipulate
    the DOM, then using the `dom` package will feel second nature to you. We can access
    the global window object using the `GetWindow` function, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉用于访问和操作DOM的JavaScript API，那么使用`dom`包将对您来说感觉自然。我们可以使用`GetWindow`函数访问全局窗口对象，就像这样：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `dom` package, we can display the alert dialog message with the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dom`包，我们可以使用以下代码显示警报对话框消息：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A cursory view of this code snippet shows that this feels closer to the JavaScript
    way of calling the `alert` dialog:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对这段代码片段的粗略观察表明，这更接近于调用`alert`对话框的JavaScript方式：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Due to this similarity, it's a good idea to be well-versed in the JavaScript
    DOM APIs, since it will provide you with the ability to be familiar with equivalent
    function calls, using the `dom` package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种相似性，熟悉JavaScript DOM API是一个好主意，因为它将使您能够熟悉等效的函数调用，使用`dom`包。
- en: You can learn more about the `dom` package by viewing the documentation for
    the package at </span>[https://godoc.org/honnef.co/go/js/dom](https://godoc.org/honnef.co/go/js/dom).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看包的文档来了解更多关于`dom`包的信息</span>[https://godoc.org/honnef.co/go/js/dom](https://godoc.org/honnef.co/go/js/dom)。
- en: Getting a DOM element by ID
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ID获取DOM元素
- en: We can use the `document` object's `getElementById` method to access an element
    for a given `id`. In these examples, we access the primary content `div` container,
    which has `id` of `"primaryContent"`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`document`对象的`getElementById`方法来访问给定`id`的元素。在这些例子中，我们访问了具有`id`为`"primaryContent"`的主要内容`div`容器。
- en: '**JavaScript**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**GopherJS**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**DOM Binding**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DOM绑定
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although the `dom` package's method calls are very similar to the JavaScript
    method calls, subtle differences can occur.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`dom`包的方法调用与JavaScript的方法调用非常相似，但可能会出现细微的差异。
- en: For example, take note of the capitalization in the `getElementById` method
    call on the `document` object using JavaScript, and compare it with the capitalization
    of the `GetElementByID` method call when using the DOM binding.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，注意在JavaScript中使用`document`对象的`getElementById`方法调用时的大写，以及使用DOM绑定时使用`GetElementByID`方法调用时的大写。
- en: In order to export the `GetElementByID` method in Go, we must capitalize the
    first letter, here, *G*. Also, notice the subtle difference in the capitalization
    of the substring *Id* when using the JavaScript way, compared with the capitalization
    of *ID* when using the DOM binding.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Go中导出`GetElementByID`方法，我们必须大写第一个字母，这里是*G*。此外，注意在使用JavaScript方式时，*Id*的大小写的微妙差异，与使用DOM绑定时*ID*的大小写的微妙差异。
- en: Query selector
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询选择器
- en: The `querySelector` method of the `document` object provides us with a means
    to access a DOM element using a CSS query selector, in a manner similar to the
    jQuery library. We can access the `h2` element containing the welcome message,
    on the IGWEB homepage, using the `querySelector` method of the document object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`document`对象的`querySelector`方法为我们提供了一种使用CSS查询选择器访问DOM元素的方法，类似于jQuery库。我们可以使用文档对象的`querySelector`方法访问包含欢迎消息的`h2`元素，在IGWEB主页上。'
- en: '**JavaScript**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**GopherJS**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**DOMBinding**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: DOM绑定
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Changing the CSS style property of an element
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改元素的CSS样式属性
- en: In the previous code snippets that we covered, we only considered examples where
    we accessed the DOM element. Now, let's consider an example where we change an
    element's CSS style property. We will hide the content inside the primary content
    `div` container by changing the value of the `div` element's `display` property.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前涵盖的代码片段中，我们只考虑了访问DOM元素的例子。现在，让我们考虑一个例子，我们将改变一个元素的CSS样式属性。我们将通过改变`div`元素的`display`属性来隐藏主要内容`div`容器中的内容。
- en: 'We can save ourselves some typing by aliasing calls to `js.Global` and the `dom` package
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过给`js.Global`和`dom`包的调用起别名来节省一些输入，就像这样：
- en: 'For GopherJS:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GopherJS：
- en: '`JS := js.Global`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`JS := js.Global`'
- en: 'For the `dom` package:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dom`包：
- en: '`D := dom.GetWindow().Document()`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`D := dom.GetWindow().Document()`'
- en: In order to change the display property of the primary content div container,
    we will first need to access the `div` element, and then change it's `display`
    property to the `none` value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改变主要内容div容器的显示属性，我们首先需要访问`div`元素，然后将其`display`属性更改为`none`值。
- en: '**JavaScript**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**GopherJS**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**DOM Binding**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: DOM绑定
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can get a feel for working with GopherJS, using the GopherJS Playground
    at [https://gopherjs.github.io/playground/](https://gopherjs.github.io/playground/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用GopherJS Playground来体验使用GopherJS，网址为[https://gopherjs.github.io/playground/](https://gopherjs.github.io/playground/)。
- en: GopherJS overview
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS概述
- en: 'Now that we''ve seen a preview of using GopherJS, let''s consider a high-level
    overview on how GopherJS works. *Figure 3.3* depicts an Isomorphic Go application
    that consists of a Go front-end web application (using GopherJS) and a Go back-end
    web application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经预览了使用GopherJS，让我们来考虑一下GopherJS的工作原理的高级概述。*图3.3*描述了一个同构的Go应用程序，其中包括一个使用GopherJS的Go前端Web应用程序和一个Go后端Web应用程序：
- en: '![](img/20fc07f2-fb79-454b-a515-00ad25513e50.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20fc07f2-fb79-454b-a515-00ad25513e50.png)'
- en: 'Figure 3.3: An Isomorphic Go web application consists of a Go front-end web
    application (using GopherJS) and a Go back-end web application'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：同构的Go Web应用程序包括一个使用GopherJS的Go前端Web应用程序和一个Go后端Web应用程序
- en: In *Figure 3.3*, we illustrated the means of communication as an HTTP transaction,
    but it's important to note that this is not the only means by which the client
    and web server can communicate. We can also establish a persistent connection
    using the web browser's WebSocket API, which we will cover in [Chapter 8](38c071ef-d44c-452c-80dd-0b76837cc5e8.xhtml),
    *Real-Time Web Application Functionality*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.3中，我们将通信方式描述为HTTP事务，但重要的是要注意，这不是客户端和Web服务器进行通信的唯一方式。我们还可以使用Web浏览器的WebSocket
    API建立持久连接，这将在[第8章](38c071ef-d44c-452c-80dd-0b76837cc5e8.xhtml)中介绍，即*实时Web应用程序功能*。
- en: In the microexamples that we covered in the previous section, we were introduced
    to the GopherJS DOM bindings, which provide us access to the DOM API—a JavaScript
    API implemented in the web browser. In addition to the DOM API, there are other
    APIs such as the XHR (to create and send XMLHttpRequests) API and WebSocket API
    (to create a bidirectional, persistent connection with the web server). There
    are GopherJS bindings available for the XHR and WebSocket APIs as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们介绍了GopherJS DOM绑定的微例子，它们为我们提供了对DOM API的访问，这是在Web浏览器中实现的JavaScript API。除了DOM
    API之外，还有其他API，如XHR（用于创建和发送XMLHttpRequests）API和WebSocket API（用于与Web服务器创建双向持久连接）。XHR和WebSocket
    API也有GopherJS绑定可用。
- en: '*Figure 3.4* depicts common JavaScript APIs on the left, and their equivalent
    GopherJS binding on the right. With a GopherJS binding available, we can access
    JavaScript API functionality from within the Go programming language itself:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4显示了左侧的常见JavaScript API，右侧是它们对应的GopherJS绑定。有了GopherJS绑定，我们可以从Go编程语言中访问JavaScript
    API功能：
- en: '![](img/4f3bdd37-00ad-44a5-90ba-567cdcdebe49.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f3bdd37-00ad-44a5-90ba-567cdcdebe49.png)'
- en: 'Figure 3.4: Common JavaScript APIs and their Equivalent GopherJS bindings'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：常见的JavaScript API及其等效的GopherJS绑定
- en: The GopherJS transpiler
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS转译器
- en: 'We use the GopherJS transpiler to convert a Go program into a JavaScript program.
    *Figure 3.5* depicts a Go program that not only makes use of the functionality
    from the Go standard library but also uses the functionality from various JavaScript
    APIs using the equivalent GopherJS bindings package:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GopherJS转译器将Go程序转换为JavaScript程序。图3.5描述了一个Go程序，不仅使用了Go标准库的功能，还使用了各种JavaScript
    API的功能，使用了等效的GopherJS绑定包：
- en: '![](img/03e2e6dc-3294-4428-896f-ac16c157496a.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03e2e6dc-3294-4428-896f-ac16c157496a.png)'
- en: 'Figure 3.5: A Go program that makes use of the standard library and GopherJS
    bindings transpiled to an equivalent JavaScript program'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：使用标准库和GopherJS绑定转译为等效JavaScript程序的Go程序
- en: We use the `gopherjs build` command to transpile the Go program into its equivalent
    JavaScript representation. The produced JavaSript source code is not meant to
    be modified by humans. The JavaScript program has access to the underlying JavaScript
    runtime embedded in the web browser, along with access to common JavaScript APIs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gopherjs build`命令将Go程序转译为其等效的JavaScript表示。生成的JavaScript源代码不是供人类修改的。JavaScript程序可以访问嵌入在Web浏览器中的JavaScript运行时，以及常见的JavaScript
    API。
- en: To get an idea of how types are converted from Go to JavaScript, take a look
    at the table available at [https://godoc.org/github.com/gopherjs/gopherjs/js](https://godoc.org/github.com/gopherjs/gopherjs/js).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解类型是如何从Go转换为JavaScript的，请查看[https://godoc.org/github.com/gopherjs/gopherjs/js](https://godoc.org/github.com/gopherjs/gopherjs/js)上的表格。
- en: With regard to IGWEB, we have organized the front-end Go web application project
    code inside of the `client` folder. This allows us to neatly separate the front-end
    web application from the back-end web application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IGWEB，我们将前端Go Web应用程序项目代码组织在`client`文件夹中。这使我们可以将前端Web应用程序与后端Web应用程序清晰地分开。
- en: '*Figure 3.6* depicts the client project folder containing numerous Go source
    files:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6显示了包含许多Go源文件的客户端项目文件夹：
- en: '![](img/4758a86b-a357-4112-b9f0-c6040844c343.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4758a86b-a357-4112-b9f0-c6040844c343.png)'
- en: 'Figure 3.6: The client Folder Houses the Go source files that comprise the
    Front-End Go Web application. The GopherJS transpiler produces a JavaScript program
    (client.js) and a source map (client.js.map)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：客户端文件夹包含组成前端Go Web应用程序的Go源文件。GopherJS转译器生成一个JavaScript程序（client.js）和一个源映射（client.js.map）
- en: Upon running the GopherJS transpiler on the Go source files inside the `client`
    folder, by issuing the `gopherjs build` command, two output files are created.
    The first output file is the `client.js` file, which represents the equivalent
    JavaScript program. The second output file is the `client.js.map` file, which
    is a source map that's used for debugging purposes. This source map helps us when
    we are chasing down bugs using the web browser's console by providing us detailed
    information on produced errors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client`文件夹中运行GopherJS转译器对Go源文件进行处理时，通过发出`gopherjs build`命令，将创建两个输出文件。第一个输出文件是`client.js`文件，代表等效的JavaScript程序。第二个输出文件是`client.js.map`文件，这是用于调试目的的源映射。这个源映射在我们使用Web浏览器的控制台追踪错误时，通过提供详细的错误信息来帮助我们。
- en: '*The Appendix: Debugging Isomorphic Go*, contains guidance and advice on debugging
    an isomorphic web application implemented in Go.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 附录：调试同构Go包含了有关调试使用Go实现的同构Web应用程序的指导和建议。
- en: The `gopherjs build` command is synonymous in behavior with its `go build` counterpart.
    The client project folder can contain any number of subfolders, which may also
    contain Go source files. When we execute the `gopherjs build` command, a single
    JavaScript source program is created along with a source `map` file. This is analogous
    to the single static binary file that gets created when issuing a `go build` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`gopherjs build`命令在行为上与其`go build`对应命令相同。客户端项目文件夹可以包含任意数量的子文件夹，这些子文件夹也可能包含Go源文件。当我们执行`gopherjs
    build`命令时，将创建一个JavaScript源程序和一个源`map`文件。这类似于在发出`go build`命令时创建的单个静态二进制文件。'
- en: Code that is shared between the server and the client, outside of the client
    folder, may be shared by specifying the proper path to the shared package in the
    `import` statement. The `shared` folder will contain code that is to be shared
    across environments, such as models and templates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client`文件夹之外，服务器和客户端之间共享的代码可以通过在`import`语句中指定共享包的正确路径来共享。`shared`文件夹将包含要在各个环境中共享的代码，例如模型和模板。
- en: 'We can include the GopherJS produced JavaScript source file as an external
    `javascript` source file in our web page using the `<script>` tag, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`<script>`标签将GopherJS生成的JavaScript源文件作为外部`javascript`源文件包含在我们的Web页面中，如下所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Keep in mind that when we issue a `gopherjs build` command, we are not just
    creating a JavaScript equivalent of the program we are writing, but we are also
    bringing along any packages from the standard library or third-party packages
    that our program relies on. So in addition to including our front-end Go program,
    GophjerJS also includes any dependent packages that our program is dependent on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们发出`gopherjs build`命令时，我们不仅创建了我们正在编写的程序的JavaScript等效程序，还带来了我们的程序依赖的标准库或第三方包。因此，除了包含我们的前端Go程序外，GopherJS还包括我们的程序依赖的任何依赖包。
- en: Not all packages from the Go standard library work inside the web browser. You
    can reference the GopherJS compatibility table to view a list of supported packages
    from the Go standard library at [https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md](https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有来自Go标准库的包都可以在Web浏览器中使用。您可以参考GopherJS兼容性表，查看Go标准库中受支持的包的列表，网址为[https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md](https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md)。
- en: 'The ramification of this fact is that the produced JavaScript source code''s
    file size will grow proportionately to the amount of dependencies we introduce
    in our Go program. The other ramification of this fact is that it doesn''t make
    sense to include multiple GopherJS produced JavaScript files on the same same
    web page as depicted in *Figure 3.7*, since dependent packages (such as common
    packages from the standard library) will be included multiple times, unnecessarily
    bulking up our total script payload and offering no value in return:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这一事实的后果是，生成的JavaScript源代码文件大小将与我们在Go程序中引入的依赖关系数量成比例增长。这一事实的另一个后果是，如*图3.7*所示，在同一个Web页面中包含多个GopherJS生成的JavaScript文件是没有意义的，因为依赖包（例如标准库中的常见包）将被多次包含，不必要地增加我们的总脚本负载，并且没有任何回报价值：
- en: '![](img/c50fbfc9-8ffa-41b3-94bf-91fd6243c09e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c50fbfc9-8ffa-41b3-94bf-91fd6243c09e.png)'
- en: 'Figure 3.7: Do not import multiple GopherJS produced source files in a single
    web page'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：不要在单个Web页面中导入多个GopherJS生成的源文件
- en: 'A web page should therefore, at maximum, include only one GopherJS produced
    source file, as depicted in *Figure 3.8*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个Web页面最多应包含一个GopherJS生成的源文件，如*图3.8*所示：
- en: '![](img/99c52275-0f7c-4958-9f46-6168436a2eb6.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99c52275-0f7c-4958-9f46-6168436a2eb6.png)'
- en: 'Figure 3.8: Only a single GopherJS produced source file should be included
    in a web page'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：Web页面中应包含一个GopherJS生成的源文件
- en: GopherJS examples
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS示例
- en: Earlier in this chapter, we got a preview of what coding with GopherJS looks
    like. Now we will take a look at some fully fleshed out examples to solidify our
    understanding of some basic concepts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们预览了使用GopherJS编码的样子。现在我们将看一些完全充实的示例，以巩固我们对一些基本概念的理解。
- en: As mentioned previously, the source code for the front-end web application can
    be found within the `client` folder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前端Web应用程序的源代码可以在`client`文件夹中找到。
- en: 'If you want to manually transpile the Go code in the client directory, you
    can issue the `gopherjs build` command inside the `client` folder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要手动转换客户端目录中的Go代码，可以在`client`文件夹中发出`gopherjs build`命令：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned earlier, two source files will be produced—the `client.js` JavaScript
    source file, and the `client.js.map` source map file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将生成两个源文件——`client.js` JavaScript源文件和`client.js.map`源映射文件。
- en: 'To run the web server manually, you can go into the `igweb` folder and run
    the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动运行Web服务器，可以进入`igweb`文件夹并运行以下命令：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A more convenient alternative is to compile the Go code and the GopherJS code
    using `kick`, with the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更方便的替代方法是使用`kick`编译Go代码和GopherJS代码，命令如下：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The advantage of using `kick` is that it will automatically watch for changes
    made either to the Go back-end web application or the GopherJS front-end web application.
    As noted in the previous chapter, `kick` will perform an *instant kickstart* when
    a change is detected, which will speed up your iterative development cycles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kick`的优势在于它将自动监视对Go后端Web应用程序或GopherJS前端Web应用程序所做的更改。如前一章所述，当检测到更改时，`kick`将执行*instant
    kickstart*，这将加快您的迭代开发周期。
- en: 'Once you have the `igweb` program running, you may access the GopherJS examples
    at the following URL: [](http://localhost:8080/front-end-examples-demo) `http://localhost:8080/front-end-examples-demo`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了`igweb`程序，可以在以下网址访问GopherJS示例：[](http://localhost:8080/front-end-examples-demo)
    `http://localhost:8080/front-end-examples-demo`
- en: The front-end examples demo will contain some basic GopherJS examples. Let's
    open up the `igweb.go` source file in the `igweb` folder to see how everything
    works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前端示例演示将包含一些基本的GopherJS示例。让我们打开`igweb`文件夹中的`igweb.go`源文件，看看一切是如何工作的。
- en: 'Inside the `registerRoutes` function, we register the following routes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerRoutes`函数中，我们注册以下路由：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `/front-end-examples-demo` route is used to display our front-end examples
    web page. The `/lowercase-text` route is used to transform text into lowercase.
    We will be covering the second route in more detail later on; first, let''s take
    a look at the handler function (found in the `handlers/frontendexamples.go` source
    file) that handles the `/front-end-examples-demo` route:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`/front-end-examples-demo`路由用于显示我们的前端示例网页。`/lowercase-text`路由用于将文本转换为小写。我们将在稍后更详细地介绍第二个路由；首先，让我们看一下处理`/front-end-examples-demo`路由的处理程序函数（位于`handlers/frontendexamples.go`源文件中）：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we have defined our handler function, `FrontEndExamplesHandler`, which
    accepts a pointer to an `env` object as an input argument, and returns an `http.Handler`
    function. We have defined a closure to return the `http.HandlerFunc`, which accepts
    `http.ResponseWriter` and `*http.Request` as input arguments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经定义了我们的处理程序函数`FrontEndExamplesHandler`，它接受一个`env`对象的指针作为输入参数，并返回一个`http.Handler`函数。我们已经定义了一个闭包来返回`http.HandlerFunc`，它接受`http.ResponseWriter`和`*http.Request`作为输入参数。
- en: We call the `Render` method on the `TemplateSet` object to render the front-end
    examples page. The first input argument to the method is the template's name,
    which is `frontend_examples_page`. The second input argument is the render parameters
    that are to be used. Since we are rendering the template from the server side,
    we pass `w`, `http.ResponseWriter`, which is responsible for writing out the web
    page response (the rendered template). Since we are not passing any data to the
    template, we assign a value of `nil` to the `Data` field of the `RenderParams`
    struct.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`TemplateSet`对象上调用`Render`方法来渲染前端示例页面。方法的第一个输入参数是模板的名称，即`frontend_examples_page`。第二个输入参数是要使用的渲染参数。由于我们是从服务器端渲染模板，我们传递`w`，即`http.ResponseWriter`，负责写出网页响应（渲染的模板）。由于我们没有向模板传递任何数据，我们将`RenderParams`结构体的`Data`字段赋值为`nil`。
- en: In [Chapter 4](eec79e85-e888-47e8-851e-d983d5aea55d.xhtml), *Isomorphic Templates*,
    we will explain how template sets work, and how we can use the isomorphic template renderer,
    provided by the `isokit` package, to render templates on both the server-side
    and the client-side.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](eec79e85-e888-47e8-851e-d983d5aea55d.xhtml)中，*同构模板*，我们将解释模板集是如何工作的，以及我们如何使用`isokit`包提供的同构模板渲染器在服务器端和客户端渲染模板。
- en: 'Inside the partial source code listing of the `initializePage` function, found
    in the `client.go` source file, we have included the following line of code to
    initialize the GopherJS code examples (shown in bold):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client.go`源文件中的`initializePage`函数的部分源代码列表中，我们包含了以下代码行来初始化GopherJS代码示例（以粗体显示）：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `gopherjsprimer.InitializePage` function is responsible for adding event
    listeners to elements found on the front-end examples web page. Before we register
    any events, we first check to see if the page with the `/front-end-examples` route has
    been accessed. If the user is accessing a page with a different route, such as
    `/index`, there is no need to set up the event handlers for the front-end examples
    page. If the user has accessed the `/front-end-examples` route, then the flow
    of control will reach the `case` statement specifying the `"front-end-examples-demo"` value,
    and we will set up all the event handlers for the UI elements on the web page
    by calling the `gopherjsprimer.InitializePage` function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`gopherjsprimer.InitializePage`函数负责向前端示例网页中的元素添加事件侦听器。在注册任何事件之前，我们首先检查页面是否已经访问了`/front-end-examples`路由。如果用户正在访问不同路由的页面，例如`/index`，则无需为前端示例页面设置事件处理程序。如果用户已经访问了`/front-end-examples`路由，那么控制流将到达指定值为`"front-end-examples-demo"`的`case`语句，并且我们将通过调用`gopherjsprimer.InitializePage`函数为网页上的UI元素设置所有事件处理程序。'
- en: 'Let''s take a closer look at the `InitializePage` function found in the `client/gopherjsprimer/initpage.go` source
    file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`client/gopherjsprimer/initpage.go`源文件中的`InitializePage`函数：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `InitializePage` function is responsible for adding the event listeners
    to elements found in the front-end examples web page using the element's `AddEventListener`
    method (shown in bold).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializePage`函数负责使用元素的`AddEventListener`方法（以粗体显示）向前端示例网页中的元素添加事件侦听器。'
- en: Displaying an alert message
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示警报消息
- en: 'Let''s start off with an example to display an alert dialog. Earlier in this
    chapter, we saw how we could accomplish displaying the alert dialog using the
    `Call` method of the `js.Global` object and the GopherJS DOM bindings. *Figure
    3.9* depicts the user interface of our first example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，显示一个警报对话框。在本章的前面，我们看到了如何使用`js.Global`对象的`Call`方法和GopherJS DOM绑定来显示警报对话框。*图3.9*描述了我们第一个例子的用户界面：
- en: '![](img/740dc41d-898d-425d-9898-8ee2959e019c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/740dc41d-898d-425d-9898-8ee2959e019c.png)'
- en: 'Figure 3.9: The Display Alert message example'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：显示警报消息示例
- en: 'The user interface consists of an input text field, where the user can enter
    a custom message to display in the alert dialog. Following the text field are
    two buttons:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面包括一个输入文本字段，用户可以在其中输入要显示在警报对话框中的自定义消息。文本字段后面是两个按钮：
- en: The first button will display the alert dialog using the `Call` method on the
    `js.Global` object
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个按钮将使用`js.Global`对象上的`Call`方法显示警报对话框
- en: The second button will display the alert dialog using the GopherJS DOM Bindings
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个按钮将使用GopherJS DOM绑定显示警报对话框
- en: The HTML markup for the front-end examples can be found in the template file
    located at `shared/templates/frontend_examples_page.tmpl`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前端示例的HTML标记可以在位于`shared/templates/frontend_examples_page.tmpl`的模板文件中找到。
- en: 'Here''s the HTML markup for the alert message example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是警报消息示例的HTML标记：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we declared two buttons (shown in bold) and assigned unique ids to them.
    The button that will display the alert dialog using the `js.Global.Call` functionality
    has an `id` of `alertMessageJSGlobal`. The button that will display the alert
    dialog using the GopherJS DOM bindings has an `id` of `alertMessageDOM`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个按钮（用粗体显示）并为它们分配了唯一的id。使用`js.Global.Call`功能显示警报对话框的按钮具有`alertMessageJSGlobal`的id。使用GopherJS
    DOM绑定显示警报对话框的按钮具有`alertMessageDOM`的id。
- en: 'The following code snippet from the `InitializePage` function, defined in the
    `initpage.go` source file, is responsible for setting up the event handlers for
    the `Display Alert Message` buttons that will be displayed in the example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initpage.go`源文件中定义的`InitializePage`函数中的以下代码片段负责为在示例中显示的`Display Alert Message`按钮设置事件处理程序：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We fetch the first button by making a call to the `GetElementByID` function
    on the `document` object, passing in the `id` of the button as the input argument
    to the function. We then call the `AddEventListener` method on the button to create
    a new event listener, which will listen for a click event. We call the `DisplayAlertMessagesJSGlobal`
    function when the first button has been clicked, and pass in the value of the
    `messageInput` text field, which contains the custom Alert Message that the user
    can enter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`document`对象上调用`GetElementByID`函数来获取第一个按钮，将按钮的`id`作为函数的输入参数传递。然后，我们调用按钮上的`AddEventListener`方法来创建一个新的事件监听器，该监听器将监听点击事件。当第一个按钮被点击时，我们调用`DisplayAlertMessagesJSGlobal`函数，并传递`messageInput`文本字段的值，其中包含用户可以输入的自定义警报消息。
- en: We set up the event listener for the second button in a similar fashion, except
    the function we call when a click event is detected on the button is `DisplayAlertMessageDOM`,
    which calls the function to show the alert dialog using the GopherJS DOM bindings.
    Again, we pass in the value of the `messageInput` text field to the function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式为第二个按钮设置了事件监听器，只是当检测到按钮上的点击事件时，我们调用`DisplayAlertMessageDOM`函数，该函数调用使用GopherJS
    DOM绑定显示警报对话框的函数。同样，我们将`messageInput`文本字段的值传递给函数。
- en: 'Now, if you were to click on either button, you should be able to see the alert
    dialog. Change the alert message to something different, and notice that the change
    you make to the Alert Message text field will be reflected in the alert dialog.
    *Figure 3.10* depicts the alert dialog with a custom message of Hello Isomorphic
    Gopher!:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你点击任何一个按钮，你应该能够看到警报对话框。将警报消息更改为不同的内容，并注意你对警报消息文本字段所做的更改将反映在警报对话框中。*图3.10*描述了具有自定义消息Hello
    Isomorphic Gopher!的警报对话框：
- en: '![](img/8ce236ca-e89a-45e5-b86d-0ef86cca8a95.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ce236ca-e89a-45e5-b86d-0ef86cca8a95.png)'
- en: 'Figure 3.10: The example that displays the alert dialog with a custom alert
    message'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：显示具有自定义警报消息的示例
- en: Changing an element's CSS style property
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改元素的CSS样式属性
- en: 'Now we will take a look at an example where we actually manipulate the DOM
    by changing an element''s CSS style property. The user interface of this example
    consists of the image of the Isomorphic Gopher, and right below it are two buttons,
    as shown in *Figure 3.11*. The first button, when clicked, will show the Isomorphic
    Gopher image, if it is hidden. The second button, when clicked, will hide the
    Isomorphic Gopher image, if it is shown. *Figure 3.11* shows the Isomorphic Gopher
    when it is visible:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一个例子，其中我们实际上通过改变元素的CSS样式属性来操作DOM。这个例子的用户界面由等距地图鼹鼠的图像组成，正下方是两个按钮，如*图3.11*所示。第一个按钮被点击时，如果它被隐藏，将显示等距地图鼹鼠图像。第二个按钮被点击时，如果它被显示，将隐藏等距地图鼹鼠图像。*图3.11*显示了等距地图鼹鼠可见时的情况：
- en: '![](img/08a48cf6-fa7c-4848-a09b-a8981a2fb0c7.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08a48cf6-fa7c-4848-a09b-a8981a2fb0c7.png)'
- en: 'Figure 3.11: The user interface when the Isomorphic Gopher image is visible'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：当等距地图鼹鼠图像可见时的用户界面
- en: '*Figure 3.12* depicts the user interface when the Isomorphic Gopher image is
    not visible:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.12*描述了当等距地图鼹鼠图像不可见时的用户界面：'
- en: '![](img/14bd6b99-7a09-41af-b4cd-815616e2a4a6.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14bd6b99-7a09-41af-b4cd-815616e2a4a6.png)'
- en: 'Figure 3.12: The user interface when the Isomorphic Gopher image is not visible'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：当等距地图鼹鼠图像不可见时的用户界面
- en: 'Here''s the HTML markup that generates the user interface for this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为此示例生成用户界面的HTML标记：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we declare an image tag that represents the Isomorphic Go image and assign
    it an `id` of `isomorphicGopher`. We declare two buttons (shown in bold):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了代表等距地图鼹鼠图像的图像标签，并为其分配了`isomorphicGopher`的id。我们声明了两个按钮（用粗体显示）：
- en: The first button, having an `id` of `showGopher`, will show the Isomorphic Gopher
    image, when clicked
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个按钮，具有`showGopher`的id，将在点击时显示等距地图鼹鼠图像
- en: The second button, having an `id` of `hideGopher`, will hide the Isomorphic
    Gopher image, when clicked
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个按钮，具有`hideGopher`的id，将在点击时隐藏等距地图鼹鼠图像
- en: 'The following code snippet from the `InitializePage` function is responsible
    for setting up the event handlers for the two buttons that show and hide the Isomorphic
    Gopher image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializePage`函数中的以下代码片段负责为显示和隐藏等距地图鼹鼠图像的两个按钮设置事件处理程序：'
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the Show Isomorphic Gopher button is clicked, we call the `ShowIsomorphicGopher` function.
    If the Hide Isomorphic Gopher button is clicked, we call the `HideIsomorphicGopher` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击显示等距地图鼹鼠按钮，我们调用`ShowIsomorphicGopher`函数。如果点击隐藏等距地图鼹鼠按钮，我们调用`HideIsomorphicGopher`函数。
- en: 'Let''s examine the `ShowIsomorphicGopher` and `HideIsomorphicGopher` functions
    defined in the `client/gopherjsprimer/cssexample.go` source file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`client/gopherjsprimer/cssexample.go`源文件中定义的`ShowIsomorphicGopher`和`HideIsomorphicGopher`函数：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Both the `ShowIsomorphicGopher` and `HideIsomorphicGopher` functions call the
    `toggleIsomorphicGopher` function. The only difference is that the `ShowIsomorphicGopher` function
    calls the `toggleIsomorphicGopher` function with an input parameter of true, and
    the `HideIsomorphicGopher` function calls the `toggleIsomorphicGopher` function
    with an input parameter of `false`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowIsomorphicGopher`和`HideIsomorphicGopher`函数都调用`toggleIsomorphicGopher`函数。唯一的区别是，`ShowIsomorphicGopher`函数调用`toggleIsomorphicGopher`函数并传入`true`的输入参数，而`HideIsomorphicGopher`函数调用`toggleIsomorphicGopher`函数并传入`false`的输入参数。'
- en: The `toggleIsomorphicGopher` function takes in a single argument, which is a
    Boolean variable indicating whether or not the `IsomorphicGopher` image should
    be shown, or not.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleIsomorphicGopher`函数接受一个布尔变量作为参数，指示是否应显示`IsomorphicGopher`图像。'
- en: If we pass in a value of `true` to the function, then the Isomorphic Gopher
    image should be displayed, as shown in *Figure 3.11*. If we pass in a value of
    `false` to the function, then the Isomorphic Gopher image should not be displayed,
    as shown in *Figure 3.12*. We assign the value of the `Document` object to the `d` variable.
    We make a call to the `GetElementByID` method of the `Document` object to get
    the Isomorphic Gopher image. Notice that we have performed a type assertion (shown
    in bold) to assert that the value returned by `d.GetElementByID("isomorphicGopher")`
    has a concrete type of `*dom.HTMLImageElement`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向函数传递`true`的值，那么等距地图像将被显示，如*图3.11*所示。如果我们向函数传递`false`的值，那么等距地图像将不会被显示，如*图3.12*所示。我们将`Document`对象的值赋给`d`变量。我们调用`Document`对象的`GetElementByID`方法来获取等距地图像。请注意，我们已经执行了类型断言（粗体显示），以断言`d.GetElementByID("isomorphicGopher")`返回的值具有`*dom.HTMLImageElement`的具体类型。
- en: We declared an `if` conditional block that checks if the value of the `isVisible`
    Boolean variable is `true`, and if it is, we set the `display` property of the
    image element's `Style` object to be `inline`. This will cause the Isomorphic
    Gopher image to appear, as shown in *Figure 3.11*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`if`条件块，检查`isVisible`布尔变量的值是否为`true`，如果是，我们将图像元素的`Style`对象的`display`属性设置为`inline`。这将导致等距地图像出现，如*图3.11*所示。
- en: If the value of the `isVisible` Boolean variable is `false`, we reach the `else`
    block, and we set the `display` property of the image element's `Style` object
    to be `none`, which will prevent the Isomorphic Gopher image from being displayed,
    as shown in *Figure 3.12*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isVisible`布尔变量的值为`false`，我们进入`else`块，并将图像元素的`Style`对象的`display`属性设置为`none`，这将防止等距地图像显示，如*图3.12*所示。
- en: The JavaScript typeof operator functionality
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript typeof运算符功能
- en: 'The JavaScript `typeof` operator is used to return the type of a given operand.
    For example, let''s consider the following JavaScript code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`typeof`运算符用于返回给定操作数的类型。例如，让我们考虑以下JavaScript代码：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This expression will evaluate to the Boolean value of `true`. On a similar
    note, now consider this JavaScript code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式将求值为布尔值`true`。同样，现在考虑这段JavaScript代码：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This expression will also evaluate to the Boolean value of `true`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式也将求值为布尔值`true`。
- en: So you might be wondering, how can we make use of the JavaScript `typeof` operator
    using Go? The answer is, we will need the `jsbuiltin` package, the GopherJS bindings
    for built-in JavaScript functionality, which includes the `typeof` operator.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可能会想，我们如何使用Go来使用JavaScript的`typeof`运算符？答案是，我们将需要`jsbuiltin`包，GopherJS对内置JavaScript功能的绑定，其中包括`typeof`运算符。
- en: 'In this example, we will make use of JavaScript''s `typeof` operator using
    the `jsbuiltin` package. *Figure 3.13* depicts the user interface for this example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`jsbuiltin`包使用JavaScript的`typeof`运算符。*图3.13*展示了这个例子的用户界面：
- en: '![](img/12865f98-0842-417e-8e3d-b5b7ea66b13a.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12865f98-0842-417e-8e3d-b5b7ea66b13a.png)'
- en: 'Figure 3.13: The user interface for the JavaScript typeof example'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：JavaScript typeof示例的用户界面
- en: 'Here''s the HTML markup that implements the user interface for this example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现此示例用户界面的HTML标记：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have declared a button with an `id` of `bultinDemoButton`. Now, let''s set
    up an event listener for the Builtin Demo button, inside the `InitializePage`
    function, to handle the click event:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`id`为`bultinDemoButton`的按钮。现在，让我们在`InitializePage`函数中为内置演示按钮设置一个事件侦听器，以处理点击事件：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We get the `button` element by calling the `GetElementID` method on the `Document`
    object, `d`. We assign the returned `button` element to the `builtinDemoButton` variable.
    We then add an event listener to the `button` element to detect when it's clicked.
    If a click event is detected, we call the `builtinDemo` function and pass in the
    value of the `button` element, which happens to be the event target.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`Document`对象`d`上调用`GetElementID`方法来获取`button`元素。我们将返回的`button`元素赋给`builtinDemoButton`变量。然后我们向`button`元素添加事件侦听器以检测其是否被点击。如果检测到点击事件，我们调用`builtinDemo`函数并传入`button`元素的值，这恰好是事件目标。
- en: 'Let''s examine the `builtindemo.go` source file found in the `client/gopherjsprimer`
    folder:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`client/gopherjsprimer`文件夹中的`builtindemo.go`源文件：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `bulitindemo` function accepts an input argument of the `dom.Element` type.
    Inside this function, we perform a JavaScript `typeof` operation on the element
    that''s passed into the function by calling the `TypeOf` function from the `jsbuiltin`
    package (shown in bold). We check to see if the element passed in is an object.
    If it is an object, we print out a message to the web console, confirming that
    the element passed into the function is an object. *Figure 3.14* depicts the message
    printed on the web console:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`bulitindemo`函数接受`dom.Element`类型的输入参数。在这个函数内部，我们通过调用`jsbuiltin`包的`TypeOf`函数（粗体显示）对传入函数的元素执行JavaScript的`typeof`操作。我们检查传入的元素是否是对象。如果是对象，我们会在Web控制台上打印出一条消息，确认传入函数的元素是一个对象。*图3.14*展示了在Web控制台上打印的消息：'
- en: '![](img/668122f7-9980-4234-b3b0-50af070d483f.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/668122f7-9980-4234-b3b0-50af070d483f.png)'
- en: 'Figure 3.14: The message printed on the web console after the built in demo
    button is clicked'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, this is a pretty trivial example. However, it highlights a very
    important concept—from within the confines of Go, we can still access the built-in
    JavaScript functionality.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Transforming text to lowercase using an XHR post
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create a simple lowercase text transformer. Any text the user enters
    will be converted to lowercase. The user interface for our lowercase text transformer
    solution is depicted in *Figure 3.15*. In the image, the input text is GopherJS.
    When the user clicks on the Lowercase It! button, the text in the text field will
    be transformed to its lowercase equivalent, which is gopherjs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9618da7-a56b-498f-b10c-74e41aa50f38.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: The lowercase Text Transformer example'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can apply the text transformation on the client side; however, it
    would be more interesting to see an example where we send the input text over
    to the web server in the form of an `XHR Post`, and then perform the lowercase
    transformation on the server side. Once the server is done transforming the text
    to lowercase, the input is sent back to the client, and the text field is updated
    with the lowercase version of the input text.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the HTML markup for the user interface looks like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We declare an `input` text field, where the user can enter text that they want
    to convert to lowercase. We assign an `id` of `textToLowercase` for the `input`
    text field. We then declare a button with an `id` of `lowercaseTransformButton`.
    When this button is clicked, we will initiate an `XHR Post` to the server. The
    server will convert the text to lowercase and send back the lowercase version
    of the entered text.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code from the `InitializePage` function, that is used to set up
    the event listener for the button:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We assign the `button` element to the `lowercaseTransformButton` variable. We
    then call the `AddEventListener` method on the `button` element to detect a click
    event. When a click event is detected, we call the `lowercaseTextTransformer` function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `lowercaseTextTransformer` function defined in the `client/gopherjsprimer/xhrpost.go`
    source file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We first start out by fetching the text input element and assigning it to the `textToLowercase` variable.
    We then marshal the text value entered into the text input element to its JSON
    representation, using the `Marshal` function from the `json` package. We assign
    the marshaled value to the `textBytes` variable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We use the GopherJS XHR bindings to send the `XHR Post` to the web server. The
    XHR bindings are made available to us through the `xhr` package. We call the `Send`
    function from the `xhr` package to submit the `XHR Post`. The first argument to
    the function is the HTTP method that we are going to use to submit the data. Here
    we have specified `POST` as the HTTP method. The second input argument is the
    path to `POST` the data to. Here we have specified the `/lowercase-text` route, which
    we had set up in the `igweb.go` source file. The third and last argument is the
    data that is to be sent through the `XHR Post`, which is `textBytes`—the JSON
    marshaled data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The server response from the `XHR Post` will be stored in the `data` variable.
    We call the `Unmarshal` function in the `json` package to unmarshal the server's
    response and assign the unmarshaled value to the `s` variable of the `string`
    type. We then set the value of the text input element to the value of the `s` variable,
    using the `Set` method of the `textToLowercase` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the server-side handler that''s responsible for
    the lowercase transformation in the `handlers/lowercasetext.go` source file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the `LowercaseTextTransformHandler` function, we make a call to the `ReadAll`
    function in the `ioutil` package to read the request body. We save the string
    value of `reqBody` to the `reqBodyString` variable. We then JSON unmarshal this
    string, and store the unmarshaled value to the `s` variable, which is of the `string` type.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We use the `ToLower` function from the `strings` package to transform the value
    of the `s` string variable to lowercase, and marshal the value into its JSON representation.
    We then call the `Write` method on `http.ResponseWriter`, `w`, to write out the
    JSON marshaled value of the string in lowercase.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click on the Lowercase It! button in the user interface, the string
    GopherJS gets transformed into its lowercase representation gopherjs, as shown
    in *Figure 3.16*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51fee22d-c095-4427-aeee-15ef890c2179.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: The text "GopherJS" is converted to lowercase "gopherjs" once
    the button is clicked'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Inline template rendering
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to perform client-side template rendering
    in Go using GopherJS. We can render templates directly within the web browser
    using the `html/template` package. We will render the individual rows of a table
    of cars, using an inline template.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The cars listing demo
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the cars listing demo, we will populate a table with rows that are rendered
    from an inline client-side Go template. In our example, the table will be a list
    of cars, and we will obtain the cars to be shown in the table from a slice of
    cars. We will then encode the slice of cars using `gob` encoding and transmit
    the data to the web server instance over an XHR call.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Client-side template rendering has many benefits:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: CPU usage on the web server is rendered, which is caused by server-side template
    rendering
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full page reloads are not required to render the client-side template
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth consumption is reduced by rendering the template on the client-side
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s open up the `cars.html` source file in the `shared/templates/carsdemo_page.tmpl` directory:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This HTML source file contains the web page content for our example, a table
    of cars, where we will be rendering each row of the table using an inline template.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We have declared the table that will be displayed on the web page using the
    `table` tag. We have declared the headers for each column. Since we will be displaying
    a table of cars, we have three columns for each car; we have a column for the
    the model name, a column for the color, and a column for the manufacturer.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Each new row that we will be adding to the table will be appended to the `tbody`
    element (shown in bold).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we use the `carsdemolayout.tmpl` layout template, to layout the
    cars demo page. Let''s open this file located in the `shared/templates/layouts`
    directory:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The layout template is responsible for not only rendering the `pagecontent`
    template but also the header template, `carsdemoheader.tmpl`, which is located
    in the `templates/shared/partials` directory. The layout template is also responsible
    for importing the `client.js` external JavaScript source file that was produced
    by GopherJS.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `carsdemoheader.tmpl` source file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this header template file, we import the CSS stylesheet and the JavaScript
    source file for Material Design Library. We'll use Material Design Library to
    make our table look pretty with the default material design styles.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `initializePage` function of the `client.go` source file, we included
    the following line of code to initialize the cars demo code example, upon landing
    on the cars demo web page:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the `cars.go` source file in the `client/carsdemo` directory, we have
    declared the inline template used to render the information for a given car:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We declared the `CarItemTemplate` constant, which is a multi-line string that
    comprises our inline template. In the first line of our template, we render the
    column containing the model name. In the second line of our template, we render
    the color of the car. Finally, in the third line of our template, we render the
    manufacturer of the car.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'We declared and initialized the `D` variable with the `Document` object, as
    shown here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `InitializePage` function (found in the `client/carsdemo/cars.go` source
    file) is responsible for calling the `cars` function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `cars` function, we create a `nano`, an `ambassador`, and an `omni`—three
    instances of the `Car` type. Right after this, we use the car objects to populate
    the `cars` slice:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that we have a slice of `cars` to populate the table with, it''s time to
    generate each row of the table with the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have declared and initialized the `autoTableBody` variable, which is
    the `tbody` element of the table. This is the element we will use to append new
    rows to the table. We loop through the `cars` slice, and for each `Car` struct,
    we dynamically create a `tr` element, using the `CreateElement` method of the
    `Document` object. We then create a new template, and parse the contents of the
    car item template.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: We declare a buffer variable named `buff`, to hold the result of the executed
    template. We call the `Execute` function on the template object, `tpl`, passing
    in `buff`, and the current `Car` record at the `i` index of the `cars` slice,
    which will be the data object that is fed to the inline template.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `SetInnerHTML` method on the `tr` element object and pass in
    the string value of the `buff` variable, which will contain our rendered template
    contents.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the cars table looks like with all the rows populated:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5cb151a-e871-42ea-9bd8-f2ebbe2f98d9.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.17: The cars table'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: This example was useful for illustration purposes, however, it is not very practical
    in a real-world scenario. Mixing inline templates, written in HTML, inside Go
    source files can become an unmaintainable mess, as the project codebase scales.
    In addition to this, it would be nice if we had a means to access all the templates
    for user-facing web pages that the server had access to, on the client side. In
    fact, we can, and that will be our focus in [Chapter 4](eec79e85-e888-47e8-851e-d983d5aea55d.xhtml), *Isomorphic
    Templates*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to render an inline template, let's consider how we
    can transmit the `cars` slice to the server as binary data, encoded in the `gob`
    format.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Transmitting gob encoded data
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `encoding/gob` package provides us with the functionality to manage streams
    of gobs, which are binary values exchanged between an encoder and a decoder. You
    use the encoder to encode a value into `gob` encoded data and you use the decoder
    to decode `gob` encoded data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'With Go on the server side and on the client-side, we have created a Go-specific
    environment, as shown in *Figure 3.18*. This is an ideal environment to use the `encoding/gob` package, as
    a means for data exchange between the client and the server:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/948fb981-58cf-4b2a-b0ff-e74256d19245.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: A Go-specific environment'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The data that we will be transmitting consists of the `cars` slice. The `Car`
    struct can be considered isomorphic, since we can use the `Car` struct on both
    the client side and the server side.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the `cars.go` source file, we have included the `encoding/gob`
    package (shown in bold) in our import groupings:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We encode the `cars` slice to the `gob` format using the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here we have declared a bytes buffer called `carsDataBuffer` that will contain
    the `gob` encoded data. We created a new `gob` encoder, and specified that we
    want to store the encoded data into `carsDataBuffer`. We then called the `Encode`
    method on our `gob` encoder object, and passed in the `cars` slice. At this point,
    we have encoded the `cars` slice into `carsDataBuffer`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have encoded the `cars` slice into the `gob` format, we can transmit
    the `gob` encoded data to the server over an XHR call using the `HTTP POST` method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We call the `Send` function in the `xhr` package, and specify that we want to
    use the `POST` method, and will be sending the data to the `/cars-data` URL. We
    call the `Bytes` method on the `carsDataBuffer` to get the representation of the
    buffer as a byte slice. It is this byte slice that we will send off to the server,
    and it is the `gob` encoded `car` slice.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The response from the server will be stored in the `xhrResponse` variable, and
    we will print this variable out in the web console.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the client-side of our program, it''s time to take a look
    at the server-side handler function that services the `/cars-data` route. Let''s
    examine the `CarsDataHandler` function defined in the `carsdata.go` source file
    found in the handlers directory:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Inside the `CarsDataHandler` function, we declare the `cars` variable, which
    is a slice of `Car` objects. Right below this, we have `carsDataBuffer`, which
    will contain the `gob` encoded data that we receive from the XHR call that was
    sent from the client-side web application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We create a new `gob` decoder and we specify that the `gob` data will be stored
    in `carsDataBuffer`. We then use the `ReadAll` function from the `ioutil` package
    to read the request body and to save all the contents to the `body` variable.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new bytes buffer and pass in the `body` variable as the input
    argument to the `NewBuffer` function. The `carsDataBuffer` now contains the `gob`
    encoded data that was transmitted over the XHR call. Finally, we make a call to
    the `Decode` function of the `dec` object to convert the `gob` encoded data back
    into a slice of the `Car` objects.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn''t receive any errors, we print out the `cars` slice to standard
    out:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In addition to printing the `cars` slice to standard out, we write a response
    back to the web client indicating that the slice of `cars` has been received successfully.
    We can view this message in the web browser console:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24b9fade-eb63-4b23-a704-55d075d06f03.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.19: The server response to the web client'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Local storage
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you know that the web browser comes with a built-in key-value database?
    The name of this database is local storage, and in JavaScript, we can access the
    `localStorage` object as a property of the `window` object. Local storage allows
    us to store data locally within the web browser. Local storage is per domain and
    protocol, meaning that pages from the same origin can access and modify shared
    data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of local storage:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: It provides secure data storage
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a far greater storage limit than cookies (at least 5 MB)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides low latency data access
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is helpful for web applications that need to operate offline (internet connection
    not required)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be utilized as a local cache
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common local storage operations
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be showing you how to perform some common operations on the `localStorage`
    object using JavaScript code. These operations include the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Setting a key-value pair
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting a value for a given key
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting all key-value pairs
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clearing all entries
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will show you how to perform the same operations using
    GopherJS, in a fully fleshed out example.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Setting a key-value pair
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To store an item into local storage, we call the `setItem` method of the `localStorage`
    object, and pass in the key and value as parameters to the method:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we have provided a `"foo"` key, with a `"bar"` value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Getting a value for a given key
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an item from local storage, we call the `getItem` method of the `localStorage`
    object and pass in the key as the single parameter to the method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here we have provided the `"foo"` key, and we expect that the value of the `x` variable will
    be equal to `"bar"`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Getting all key value pairs
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can retrieve all key-value pairs from local storage using a `for` loop and
    accessing the values of the key and value, using the `key` and `getItem` methods
    of the `localStorage` object:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We use the `key` method on the `localStorage` object, passing in the numeric
    index, `i`, to get the i^(*th*) key in the storage. Similarly, we pass in the `i` numeric
    index to the `key` method of the `localStorage` object, in order to get the name
    of the key at the ith place in the storage. Note that the name of the key is obtained
    by the `localStorage.key(i)` method call and passed to the `getItem` method to
    retrieve the value for the given key.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Clearing all entries
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily remove all the entries in local storage by calling the `clear`
    method on the `localStorage` object:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Building a local storage inspector
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the information presented in the previous section on how to utilize the
    `localStorage` object, let''s go ahead and build a local storage inspector. The
    local storage inspector, will allow us to perform the following operations:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Viewing all the key-value pairs that are currently stored in local storage
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new key-value pair to local storage
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing all key-value pairs in local storage
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.20* depicts the user interface for the local storage inspector:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f23ed4be-f436-4afe-b71f-7ced3274cf8c.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.20: The Local Storage Demo user interface'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The box directly under the LocalStorage Demo title is a `div` container that
    is responsible for holding the list of key-value pairs that are currently stored
    in local storage. The Key input text field is where the user enters the key for
    the key-value pair. The Value input text field is where the user enters the value
    for the key-value pair. Clicking on the Save button will save the new key-value
    entry into local storage. Clicking on the Clear All button, will clear all key-value
    entries in local storage.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve defined the layout for the local storage demo page inside the `localstorage_layout.tmpl`
    source file found in the `shared/templates/layouts` folder:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This layout template defines the layout of the local storage demo web page.
    We use template actions (shown in bold) to render the `partials/localstorageheader_partial` header
    template, and the `pagecontent` page content template.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Notice that at the bottom of the web page, we include the JavaScript source
    file, `client.js`, which was produced by GopherJS, using the `script` tag (shown
    in bold).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined the header template for the local storage demo page inside the
    `localstorageheader_partial.tmpl` source file found in the `shared/templates/partials`
    folder:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This header template is meant to render the `head` tag, where we include external
    CSS stylesheets using the `link` tags (shown in bold).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve defined the HTML markup for the local storage demo''s user interface
    in the `localstorage_example_page.tmpl` source file found in the `shared/templates`
    folder:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `div` element with the `id` of `"storageContents"` will be used to store
    the list of item entries in the local storage database. In fact, we will use the
    dl (description list) element with `id` of `"itemList"` to display all the key-value
    pairs.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We have defined an input text field for the user to enter the key, and we have
    also defined an input text field for the user to enter the value. We've also defined
    the markup for the `Save` button, and directly under that, we've defined the markup
    for the `Clear All` button.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the server-side route
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve registered the `/localstorage-demo` route inside the `registerRoutes`
    function found in the `igweb.go` source file:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We''ve defined the `LocalStorageDemoHandler` server-side handler function to
    service the `/localstorage-demo` server-side route in the `localstoragedemo.go`
    source file found in the `handlers` folder:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `LocalStorageDemoHandler` function is responsible for writing the web page
    response to the client. It calls the `Render` method of the application's `TemplateSet`
    object, to render the `localstorage_example_page` template. You will learn more
    about rendering isomorphic templates, in [Chapter 4](eec79e85-e888-47e8-851e-d983d5aea55d.xhtml), *Isomorphic
    Templates*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the client-side functionality
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the client-side functionality of the local storage inspector consists
    of these steps:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the local storage inspector web page
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the local storage inspector
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the local storage inspector web page
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to initialize the event handlers on the local storage inspector web
    page, we need to add the following line of code in the localstorage-demo `case`,
    inside the `initializePage` function found in the `client.go` source file:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Calling the `InitializePage` function, defined in the `localstoragedemo` package,
    will add the event listeners for the Save and Clear All buttons.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the local storage inspector
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of the local storage inspector can be found in the `localstorage.go`
    source file in the `client/localstoragedemo` directory.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `import` groupings we include the `js` and `dom` packages (shown in
    bold):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We''ve defined the `localStorage` variable and we''ve assigned it the value
    of the `localStorage` object that is attached to the `window` object:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As usual, we''ve aliased the `Document` object with the `D` variable to save
    us some typing:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `InitializePage` function is responsible for setting up the event listeners
    for the Save and Clear All buttons:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We fetch the `saveButton` element by calling the `GetElementByID` method of
    the `Document` object and providing the `id`, `"saveButton"`, as the sole input
    parameter to the method. Right below this, we add an event listener on the click
    event to call the `Save` function. Calling the `Save` function will save a new
    key-value pair entry.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We also fetch the `clearAllButton` element by calling the `GetElementByID` method
    of the `Document` object and providing the `id`, `"clearAllButton"`, as the sole
    input parameter to the method. Right below this, we add an event listener on the
    click event to call the `ClearAll` function. Calling the `ClearAll` function will
    clear all key-value pairs that are currently stored in local storage.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Save` function is responsible for saving the key-value pair into the web
    browser''s local storage:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We get the text input fields for the key and the value (shown in bold) using
    the `GetElementByID` method of the `Document` object. In the `if` conditional
    block, we check to see if the user has not entered a value for the Key input text
    field. If they have not entered a value, we return from the function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: If the user has entered a value into the Key input text field, we continue forward.
    We call the `SetKeyValuePair` function and provide the values for `itemKey` and
    `itemValue` as input parameters to the function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: We then set the `Value` property of both `itemKey` and `itemValue` to an empty
    string, to clear the input text field, so that the user can easily add new entries
    later without having to manually clear the text in these fields.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Finally we call the `DisplayStorageContents` function, which is responsible
    for displaying all the current entries in local storage.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `SetKeyValuePair` function:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Inside this function, we simply call the `setItem` method of the `localStorage`
    object, passing in the `itemKey` and `itemValue` as input parameters to the function.
    At this point, the key-value pair entry will be saved to the web browser's local
    storage.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DisplayStorageContents` function is responsible for displaying all the
    key-value pairs that are in local storage inside the `itemList` element, which
    is a `dl` (description list) element:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We call the `SetInnerHTML` method with an input value of empty string to clear
    the contents of the list.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: We iterate through all the entries in local storage using a `for` loop. For
    each key-value pair present, we get `itemKey` and `itemValue` by calling the `localStorage`
    object's `key` and `getItem` methods, respectively.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: We use a `dt` element (`dtElement`) to display the key. A `dt` element is used
    to define a term in a description list. We use a `dd` element (`ddElement`) to
    display the value. A `dd` element is used to describe a term in a description
    list. Using the description list and its associated elements to display key-value
    pairs, we are using a semantic friendly approach to displaying the key-value pairs
    on the web page. We append the `dt` and `dd` elements to the `itemList` object
    by calling its `AppendChild` method.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ClearAll` function is used to remove all the key-value pairs that have
    been saved in local storage:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We call the `clear` method of the `localStorage` object, and then make a call
    to the `DisplayStorageContents` function. If everything is working properly, all
    the items should be cleared, and we should see no values appear in the `itemList`
    element once the Clear All button has been clicked.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Running the local storage demo
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the local storage demo at `http://localhost:8080/localstorage-demo`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new key-value pair to local storage. In the Key input text field,
    let's add the `"foo"` key, and in the Value input text field, let's add the `"bar"` value.
    Click on the Save button to add the new key-value pair to local storage.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.21* shows the newly created key-value pair appear, after clicking
    on the Save button:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/923f5dd7-6b4b-42d9-b8bd-d739bf695dfd.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21: The Local Storage Inspector showing a newly added key-value pair'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Try refreshing the web page, and after that, try restarting the web browser
    and returning to the web page. Notice that in these scenarios, local storage still
    retains the key-value pairs that were saved. Upon clicking on the Clear All button,
    you will notice that the `itemList` has been cleared, as shown in *Figure 3.20*,
    since local storage has been emptied of all key-value pairs.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'The local storage inspector that we just created is especially handy to inspect
    key-value pairs that have been populated by third party JavaScript solutions,
    used by our client-side web application. If you land on the local storage demo
    page, after viewing the image carousel on the IGWEB home page, you will notice
    that the itemList is populated with the key-value pairs shown in *Figure 3.22*:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7232412-3b7a-4b72-873e-9f60e2b7fd6f.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22: Local Storage Demo displaying key-value pairs that were populated
    by the image carousel'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: These key-value pairs were populated by the image carousel, which we will implement
    as a reusable component in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs
    – Reusable Components*.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to programming with Go on the front-end using
    GopherJS. We introduced you to the DOM and showed how you can access and manipulate
    it using GopherJS. We walked you through several microexamples to get you acquainted
    with what coding with GopherJS looks like. We then proceeded to show you fully
    fleshed out examples.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: We showed you how to display the alert dialog and display a custom message.
    We also showed you how to change the CSS style property of an element. We proceeded
    to show you how to call JavaScript's `typeof` operator from within the confines
    of Go using the `jsbuiltin` package. We showed you how to create a simple lowercase
    text transformer and demonstrated how to send an `XHR Post` using the `xhr` package.
    We also showed you how to render an inline Go template, and finally, we showed
    you how to build a local storage inspector.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](eec79e85-e888-47e8-851e-d983d5aea55d.xhtml), *Isomorphic Templates*,
    we will introduce isomorphic templates, which are templates that can be rendered
    either on the server side or the client side.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
