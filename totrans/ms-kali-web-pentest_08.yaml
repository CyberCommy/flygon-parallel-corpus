- en: Chapter 9. Stress Testing Authentication and Session Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an attacker can find or act like a legitimate user and the application believes
    him, then no amount of downstream protection can prevent illicit operation. In
    [Chapter 8](000.html#), *Exploiting Trust Through Cryptography Testing*, we saw
    how attackers can intercept and with some effort--proxy or decrypt information
    on the fly. A lot of things need to happen to make those attacks work, and the
    attacker runs the risk of being noticed by network defenses or aware users. The
    authentication applications use is another story. Users are constantly pressuring
    web application and security teams to streamline and improve the login experience,
    and this pressure often runs in direct conflict to the security of the application.
    Because the application owners are hesitant to push users to use newer hardware
    and software, experience any interruptions or lengthy login processes, and give
    up freedom of access and the ability to multitask, they are often designing applications
    to work with a much less secure, more common client profile. Application login
    and session management processes have been slow to adopt measures that can protect
    against many of the flaws that have led to some of the largest breaches in recent
    history.
  prefs: []
  type: TYPE_NORMAL
- en: Session management was borne out of trying to make security flexible. Users
    don't like being connected via theÂ **Virtual Private Network** (**VPN**) tunnels,
    and so web applications have progressed from using unique session keys to authentication
    cookies and now authentication tokens, each allowing users to have continued access
    and servers to track stateful information. This was a huge help after initial
    authentication, as it allowed HTTP to explode its use without the hassle of users
    continually proving their identity. For hackers, session management approaches
    were now a mechanism they could defeat--possessing credentials was no longer necessary
    for hijacking sessions or impersonating users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication and session management vulnerabilities are often a second level
    of a coordinated breach effort as well. While other compromises will enable an
    initial â��beach-headâ�� in a target environment, brute-forcing of user stores
    in use in an environment are often a critical piece in allowing an attacker to
    maintain access through lateral movement and privilege escalation. Unlike an enterprise''s
    use of **Lightweight Directory Access Protocol (LDAP)**, Microsoft **Active Directory**
    (**AD**) or some other identity store, web portals are often heavily customized
    and rarely, if ever hardened appropriately when bought off the shelf. This is
    where we''ll be operating--exposing all of the cracks in a target environment''s
    authentication. In this chapter, we''ll see how the various forms of authentication
    perform and how best to test them. In the process, we will develop an understanding
    of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how HTTP authentication is implemented in basic, form-based or digest-based
    approaches and what the strengths and weaknesses of each are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Burp Suite's Intruder module to circumvent these authentication walls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the impact of **Two Factor Authentication** (**2FA**) and approaches
    to overcome it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about how function-level access control works, how it may be misconfigured,
    and how to take advantage through forgeries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the possibilities for brute-force and dictionary attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knock knock, who's there?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication is the art of determining who someone is, and to do so with
    certainty. Since the advent of the web, this process has become treacherous as
    the implications of mishandling this process can compromise the rest of the environment.
    This risk, despite the potential impact, is often lost on non-security personnel--the
    user''s convenience once again causing relaxation in security. OWASP lists it
    as the number 2 most pressing threat in web security, and characterizes the threat
    as having a severe impact, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Â OWASP Summary for broken authentication and session management
  prefs: []
  type: TYPE_NORMAL
- en: Does authentication have to be hard?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most authentication approaches start with the premise that there are valid users,
    usually with different privilege levels associated with them that need access
    to something. Now, how do we confirm they are who they say they are? These so-called
    **credentials** are very much analogous to physical security measures. The right
    person will both look like who they say they are and hopefully have the appropriate
    key or answers to a challenge. It used to be that the username and password based
    authentication was perfectly acceptable, but we are now at the point where this
    flawed single-factor approach is no longer able to assure us that the client connecting
    is trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, websites and applications have incorporated a so-called 2FAÂ to
    improve fidelity. 2FA adds a second factor to the required authentication checks,
    drastically reducing the likelihood of stolen credentials succeeding in gaining
    illicit access. These factors are often described as someone you are (usernames
    or e-mails, for instance), something you know (passwords or passphrases), and
    something you have (commonly a soft token, RSA key, or the other **One-Time Password**
    (**OTP**)). In theÂ premise authentication uses, we're even seeing fingerprints,
    retina scans, and other biometrics in use. Add in security questions, **CAPTCHA**
    or other picture verification techniques, and even certificates, and we can see
    why this is enough to overwhelm users who have come to the target application
    for ease of use, not a polygraph test.
  prefs: []
  type: TYPE_NORMAL
- en: 'A general authentication approach is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_02-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Â General authentication approach for websites
  prefs: []
  type: TYPE_NORMAL
- en: Authentication 2.0 - grabbing a goldenÂ ticket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with the fine Roald Dahl bookÂ *Charlie and the Chocolate
    Factory*, you know that the **Golden Tickets** the children found in their candy
    bars opened some pretty exclusive doors to them, and even helped Charlie Bucket
    win the ultimate prize. While our targets may not be giving victims candy, they
    are issuing their own *tickets--*tokens that provide continued and privileged
    access. The trick for us is understanding how to take advantage of that.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions developed to fix the user population's work-intensive authentication
    headaches needed to evolve. Initial attempts to associate users with a session
    saw web developers embedding unique session ID codes in post-authentication packets
    to remember the user, track their activity, and provide maintained access. These
    stateful keys were, and sometimes still are, unprotected; and hackers will either
    steal and reuse those or use **session fixation** to fool a user into legitimizing
    an attacker-created session ID or token using a malicious redirect containing
    the session ID, and then authenticating on it. Efforts to secure these IDs have
    come a long way, and we're now seeing encrypted tokens in use that both obscure
    the token itself and even engage client-side scripts to help ensure the integrity
    of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regardless of the available countermeasures, app developers are creatures of
    habit and will use cookies and tokens to carry all sorts of sensitive information.
    Sounds like a fun thing to tackle as a pen tester!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods commonly used to pull and transport credentials: basic
    authentication, form-based authentication, and digest-based authentication. The
    table followingÂ helps us understand the strengths, weaknesses, applications,
    and special considerations of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Strengths** | **Weaknesses** | **Typical Applications** |'
  prefs: []
  type: TYPE_TB
- en: '| **Basic** | Typically SSL/TLS encrypted. | This is prone to client-side scripts
    and easy to capture if not properly encrypted |'
  prefs: []
  type: TYPE_TB
- en: Web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile application persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Form-Based** | Least intrusive on user | This is most likely to be unprotected,
    infer database contents, or expose unused fields |'
  prefs: []
  type: TYPE_TB
- en: Traditional credential challenges on websites and portals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Digest-Based** | Basic + machine hashing | This is relatively safe â��
    as good as it gets in current state of the art |'
  prefs: []
  type: TYPE_TB
- en: Web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile application persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what the users see on their end, and then we can go about attacking!
  prefs: []
  type: TYPE_NORMAL
- en: The basic authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some websites will allow user credentials to be passed on to the authenticating
    web server via fields reserved for this purpose in the HTTP request itself. This
    is referred to as basic authentication and can be configured either with user
    input or more commonly through preconfigured profiles implemented in client-side
    scripts or browser plugins. While this seems like something a little too easy
    to attack, when done right, the mechanism is typically protected by TLS encryption,
    and entities are both leveraging certificates to provide even greater certainty.
    This is quite commonly used in **Application Programming Interfaces** (**APIs**)
    and corporate Intranet applications used by operators and support staff, and some
    mobile applications will use this technique to maintain secured access to their
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Form-based authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Despite there being a basic authentication, most users will be familiar with
    a different form as the default user-facing approach. Form-based authentication
    is pretty self-explanatory as to what the user will see. The authentication challenge
    to the client is issued as a form, usually requiring a username or e-mail address
    and at a minimum, a password or passphrase. In most cases, there is no validation
    and authentication of the server--form-based authentication supposes that the
    server is a trusted device. This is a considerable weakness that attackers will
    tend to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: The variables provided by the user, when submitted, are actually carried out-of-band
    as they relate to the HTTP requests themselves, carried as some encapsulated data
    rather than using the built-in HTTP authentication provisions. Black-hat hackers
    will also find these submissions worth targeting, as a single user's valid credentials
    can provide just enough room with which they are able to initiate a whole host
    of other attacks and avoid several layers of protection posing as the real authenticated
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Digest-based authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Digest-based authentication takes the basics of the Basic Authentication, but
    applies MD5 hashing and a nonce to hopefully provide greater security than Basic
    alone. A nonce is like a machine version of a OTP--a number that is applied and
    valid only once to make the hashes immune to replay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Trust but verify
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Public awareness of the limitations in simple credential-based authentication
    is finally starting to catch-up, as many are now required to use additional factors
    in their authentication process. 2FA is now going mainstream and, while it saw
    its beginnings in corporate VPN use, it has now spread to a wide variety of applications
    and even consumer products and services. Google, Dropbox, Facebook, and their
    competition--all of them are now offering different forms of 2FA to help secure
    their users and reduce the company''s exposure to bad publicity. Some of the additional
    factors (beyond just a password) are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware tokens**: One of the first measures, hardware tokens provided by
    several companies were issued to employees or contractors explicitly, and displayed
    temporal codes that would provide a second factor. These have seen a decline with
    the rise of other more-easily deployed mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-time passwords** (via trusted device): Seeing great use today in both
    consumer and enterprise applications (like Dropbox in the following screenshot),
    this technique is a software version of the hardware token. In addition to providing
    codes via a text, SMS, or e-mail, many applications are allowing synchronization
    of their OTP with applications like Google Authenticator, PingID, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B03918_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Dropbox 2FA in action
  prefs: []
  type: TYPE_NORMAL
- en: '**Smart cards**: These cards are often seen in more rigorous environments (government,
    defense, and so on) where it is essential to not only prevent access to the application,
    but also to the workstation or device on which it runs. Usually, a smart-chip
    enabled card, implementations exist that use USB dongles, magnetic tokens, and
    good old fashioned mechanical keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biometrics**: A recent addition to 2FA, biometric scans and tests have been
    a key element of physical access control for a long time. Common tests involve
    finger or hand print scans, retinal scans, voice recognition, and now, even facial
    recognition has started to creep into the scene. Some mobile device manufacturers
    and now financial applications are making use of facial and voice recognition
    to unlock devices and provide additional factors to mobile applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considerably less secure than the precedingÂ methods, the following additional
    information is often used by legacy applications or custom authentication portals
    in attempts to thwart brute-force attempts or fuzzing. That being said, these
    methods are also picked on relentlessly by attackers, as they all are common fodder
    for social engineering attacks, easily distilled from tangential information leaks,
    lacking in time-sensitivity, and are sometimes available on the dark web as part
    of a compromised account listing. If these are in use, they should be in addition
    to a more hardened 2FA method from those preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security questions**: One or more questions from a common pick list are typical,
    and given that these have for many years been used in verification across attacks,
    they are almost as prevalent as the usernames themselves in leak dumps on the
    dark web. Users often answer these questions similarly across multiple services,
    and these questions are often part of an account recovery process. Should attackers
    guess answers here or buy them, there is a good chance of significant multisite
    breaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Picture recall**: Some applications have combined more traditional credentials
    with memory pictures, asking users to select from random scenes or objects and
    expecting users to remember those for future logins. This protection also prevents
    automated brute-force attempts and fuzzing, as a spatial input is required. Human
    behavior being what it is, the users will pick pictures representing their interests.
    Social engineering can greatly improve chances of guessing here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Account information**: One of the earliest forms of *enhanced* authentication
    was for portals to request digits from account numbers, addresses, or phone numbers.
    I would hope this goes without saying, but if this is our customer''s idea of
    2FA, they are in sore need of some effective penetration testing and subsequent
    guidance on proper security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the session you are looking for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen all of the ways in which web app developers attempt to make
    our job tough, let's take a look at how we can test how well they have done. We'll
    see that there are several places we can attack the chain of trust, test for the
    resiliency of the session management mechanisms, and learn to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Munching on some cookies?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most attackers and pen testers will find that theÂ sloppy management of session
    information is often the easiest path to compromising the application. Cookies
    are a pretty broad term for that session information, and intercepting and mangling
    that information can be a windfall. Burp Suite is well suited to help in doing
    this using its **Proxy Intercept** and **Repeater** capabilities. For this test,
    we''ll begin by logging into our **Mutillidae**Â (OWASP Broken Web App VM) application''s
    **`A2 - Broken Authentication and Session Management`** | **`Privilege Escalation`**
    | **`Login`** page through Firefox (as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting Mutillidae Session Management Lab
  prefs: []
  type: TYPE_NORMAL
- en: 'For this test, let''s go ahead and use some credentials we just happened to
    find earlier (through social engineering or various methods covered in [Chapter
    7](000.html#),*Â Injection and Overflow Testing*) and type in `user`Â for both
    the username and password. Once we''ve authenticated, we''ll turn on **Proxy Intercept**
    and refresh the page, allowing us to capture the HTTP messages (as shown in the
    following screenshot) and their included cookie data in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Locating the cookies to fuzz
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see pretty clearly that the web developer was trying to do an awful
    lot with the cookie but somehow forgot to secure it.Â  We can see our session''s
    username, user ID (`uid`) and PHP session ID (`PHPSESSID`) all included, and it
    appears there is no timeout associated with the session (`max-age=0`). Let''s
    pass this request to our Burp Repeater and see what sorts of damage we can do.
    Right-click on the event and click on **`Send to Repeater`**Â to load the request
    in the **`Repeater`** tool; click on its now highlighted tab, and select the **`Params`**
    tab to bring up the options seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the Repeater tool for cookies
  prefs: []
  type: TYPE_NORMAL
- en: As you can hopefully see, the parameters in the cookie itself can be altered
    (outlined by the orange field). We can also add or remove altogether (using the
    appropriate buttons outlined in green) the portions of the cookie to determine
    their significance and impact to session integrity. As we step through our alterations,
    we can look to the right-hand side (using the **`Render`** tab in the **`Response`**
    section) to see what the end result of our manipulation is (in this case, the
    change in status to the login status and username, outlined in red). There is
    no need to fret if you take it too far and strip or alter too much--the back and
    forward buttons can help you go back and forth as needed to see the impact.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the UIDÂ and PHPSESSID are both able to maintain the state of
    the session independently (as shown in the following screenshot), meaning that
    only when you remove both of these from a request at the same time will you lose
    the session and see a logout.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Maintaining state with bare essentials in cookie
  prefs: []
  type: TYPE_NORMAL
- en: 'This also implies that there is only one valid session per user, but that you
    can easily craft an authenticated session of your own if need be. Gee, I wonder
    what user we''d really like to be right now? Well, assuming that the default SQL,
    XML, or other user table format is in place and efforts to harden it weren''t
    taken, we can try for something a little more aspirational in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzing the UID to provide admin
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this simple example helped you learn to gain root by manipulating
    the components of a cookie using some fun tricks in Burp Suite's **`Repeater`**
    tool. This, of course, required us capturing an authenticated session. But what
    if we don't already have one, or we want to trick a user into unlocking all of
    the 2FA traps we may run into along the way?
  prefs: []
  type: TYPE_NORMAL
- en: Don't eat fuzzy cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a single cookie needs work, the more manual process of **`Repeater`** might
    make great sense. When we're looking to brute force a cookie however, it may make
    better use of our time to use Burp Suite's Sequencer, as it can help us analyze
    how well the application maintains session randomness.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to visit an application and capture a request with a session
    ID.Â  Pick on the stand-alone **Damn Vulnerable Web** (**DVWA**) app (standalone
    rather than the OWASP BWA bundled version, which doesn''t expose cookies appropriately).
    Let''s grab a suitable request, right-click on the event, and **`Send to Sequencer`**,
    similar to what we see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding the right request to Sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **`Sequencer`** tab, we can then set about highlighting the field we
    want to randomize with **`Sequencer`**, as seen in the following screenshot. For
    this test, we''re really interested in how well the application randomizes the
    PHPSESSID, and so we''ll select that accordingly, and then click on the button
    to **`Start Live Capture`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Sequencer
  prefs: []
  type: TYPE_NORMAL
- en: 'This will pop up a special window that allows you to see how many iterations
    were completed. After you''ve run it for at least 100 or more iterations, you
    can either stop the process or continue to iterate; in the mean-time, you can
    also run analysis of the randomness. If an application scores poorly in this,
    it tends to mean we have a reasonable shot of fuzzing a session key and hijacking
    the access of the poor user mapped to that session. We can see what it looked
    like when I let the test run to over 5700 sessions (which takes only a couple
    of minutes) in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Sequencer Analysis of Session Randomness
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to save cookies for potential session fixation candidates as discussed
    in the next session, we could drop them into a file and save them for future use.
  prefs: []
  type: TYPE_NORMAL
- en: Session Randomization is a great indicator of how well the application was built
    and how security conscious the customer's developers were. Remember how we discussed
    web developers using cookies for so much more than storing a session ID? A sequencer
    has a lot of other applications in web app pen testing, as tokens are used for
    much more than just tracking session state. The Burp Suite's documentation is
    fantastic at helping understand the other capabilities of the tool (available
    in the **`Help`** menu) and the Packt book *Burp Suite Essentials* ([https://www.packtpub.com/hardware-and-creative/burp-suite-essentials](https://www.packtpub.com/hardware-and-creative/burp-suite-essentials))
    may be a good resource to have on hand.
  prefs: []
  type: TYPE_NORMAL
- en: Jedi session tricks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common attack black hats use against custom authentication front-ends is session
    fixation. Hackers bank on the fact that developers are not taking into consideration
    how to adequately protect and sequence their Session IDs. Through social engineering
    (a simple e-mail or instant message will do) the hacker is able to deliver a URL
    string with a prepositioned invalid session ID. If this were our testing, we'd
    certainly want some other traffic to use as a template or knowledge of the application
    from scans or covert collection, such that we're able to offer a session ID format
    and length that the application would expect. Improperly configured authentication
    portals will allow our victims to bring their own session ID (ha! BYOSID?) and,
    by authenticating their own credentials and even 2FA, they legitimize the session
    ID. We testers, lying in wait, can then use this newly legitimate session ID to
    run amok and pose as the victim.
  prefs: []
  type: TYPE_NORMAL
- en: 'A secure application would prevent this from causing damage by ensuring that
    Session IDs or cookies in use change with authentication, but, it turns out, this
    is not as standard as we would all like. This is also very common in online shopping
    websites, which is quite dangerous given that legitimate users may have payment
    information just a quick social attack away. A common method of conducting a session
    fixation attack is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_12-1.png)'
  prefs: []
  type: TYPE_IMG
- en: General approach to Session Fixation
  prefs: []
  type: TYPE_NORMAL
- en: 'Certainly, the easiest sites to use this sort of attack might be those that
    use the Session ID or cookie as part of the URL string. More often than not, however,
    we''ll need to set the cookie through some clever client-side scripts or meta
    tag inclusion. The **WebGoat** application included on the OWASP BWA VM is a great
    way to practice the entire process, from generating the bogus link to fooling
    users into authenticating and thus legitimizing it, with the end result similar
    to the following screenshot, where Joe Hacker, through phishing Victim Jane, is
    able to get her to authenticate using his session ID and then follow behind her
    to gain complete account access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Using WebGoat to practice Session Fixation
  prefs: []
  type: TYPE_NORMAL
- en: The scariest part of this might actually be that once in the account, Joe Hacker
    can actually force an account password change, reroute banking transactions, and
    lock the user out! Many insurance, human resources, and financial sites are only
    rarely used by general employees, so hackers can often have a month or more to
    make their move before account notices tip off the victims that they have been
    had.
  prefs: []
  type: TYPE_NORMAL
- en: Functional access level control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, most of the techniques and concerns we've talked about have
    dealt with the bad guys (or us) gaining access to *information* they should not
    have had. In the OWASP 2013 Top 10 ([https://www.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References](https://www.owasp.org/index.php/Top_10_2013-A4-Insecure_Direct_Object_References)),
    this was known as **Insecure Direct Object Reference** (**IDOR**), and was number
    4 on the list. There is another concern however, that used to exist as number
    7 on the list, known as **Missing Functional Access Level Control** (**[https://www.owasp.org/index.php/Top_10_2013-A7-Missing_Function_Level_Access_Control](https://www.owasp.org/index.php/Top_10_2013-A7-Missing_Function_Level_Access_Control)**),
    with its 2013 OWASP summary capturedÂ in the following screenshot.Â This category
    means to address the inadvertent or inappropriate disclosure of *functions* rather
    than *information* to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'OWASP 2013 #7 Threat: Missing Functional Access Level Control'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, this sort of flaw is noted when simply attempting to visit hidden
    pages or attempt hidden commands within an authenticated session that should not
    have those privileges. Web developers may mistake obfuscation for security, and
    rather than wrestling with policy engines, they simply rely on hiding functions
    or commands from view rather than explicitly blocking their use. Scanning using
    Burp Suite or OWASP ZAP can quickly find candidate areas of the target site worthy
    of testing this, and the process of scanning may even provide some partial validation
    of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Refining a brute's vocabulary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the attacks we've seen above attempt to hijack the sessions, trick users
    into establishing sessions on their behalf, or otherwise exploit the application's
    inability to enforce rules around them. Eventually, we're going to find a case
    where we need to address the elephant in the room and just guess the password.
    There is a plethora of tools that can attempt this very fundamental task, but,
    in general, they approach it the same way--iterating via wordlists generated either
    through full brute-force engines (using **crunch**, for instance), refined wordlists
    and syllable engines (**John the Ripper**, **THC-Hydra**, and so on), and even
    by using prehashed solutions (using rainbow tables and similar ones).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Web applications, Burp Suite is a great tool for brute-forcing attacks,
    you can refer to [Chapter 5](000.html#),***Â **Proxy Operations with OWASP ZAP
    and Burp Suite*, to see how that might be used, and merely apply the same fuzzing
    technique to the password field. We can also conduct brute-force attacks against
    web login pages using tools like THC-Hydra. When getting used to THC-Hydra''s
    capabilities and formatting, it is helpful to practice using the **xHydra** GUI
    frontend. To use xHydra (also called **hydra-gtk**), you can call the process
    using either the shortcut in the menus shown in the following screenshotÂ or typeÂ `xhydra`
    in the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_15.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding Hydra's GUI front-end
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve opened up Hydra''s GUI, we can begin configuring the options we
    need to tackle our target. The **`Target`**Â tab (as shown in the following screenshot)
    allows us to point to the correct IP or hostname, identify the type of request
    submission we''re targeting (in this case, `http-post-form`), and even toggle
    logging, debug, and verbose modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_16.png)'
  prefs: []
  type: TYPE_IMG
- en: Hydra target information
  prefs: []
  type: TYPE_NORMAL
- en: In the **`Passwords`** tab (as shown in the following screenshot), we can configure
    hydra to use single submissions or pull from lists for usernames and passwords.
    Many applications lacking password complexity rules will allow users to use usernames
    or blank spaces in some accounts, and so checkboxes are provided to allow us to
    check those. **Reversed login** allows you to attempt reversing the order of the
    username and attempting that as a password.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_17.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting username and password list
  prefs: []
  type: TYPE_NORMAL
- en: Our last tweaks will come in the **`Specific`**Â tab (as shown in the following
    screenshot). Here the all-important URL pattern that we are testing against is
    defined. The fields we're filling need to be gleaned from either **`View Source`**
    on your browser, a plugin to the browser, or using Burp Suite's Proxy Intercept.
    In any case, the variables being filled by the **`Passwords`** tab will be flagged
    as `^USER^` and `^PASS^`.Â  The last string is actually any identifying string
    that denotes a failed authentication. In DVWA, the string would be seeing `login.php`
    in the returned result, thus pushing us towards the same login portal. If we were
    applying this to Mutillidae, we may use `Not Logged In`.
  prefs: []
  type: TYPE_NORMAL
- en: The target's applicable URL the answer will vary from site to site, and that
    information is often gathered from scans, spidering, or old fashioned surfing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_18.png)'
  prefs: []
  type: TYPE_IMG
- en: Designating the evaluated URL
  prefs: []
  type: TYPE_NORMAL
- en: Our last step is to actually run the scan from the **`Start`**Â tab (as shown
    in the following screenshot). We can watch the scan iterate--thanks to our verbose
    flag, and any successful results will be stated at the bottom of the output. We
    can also see the CLI equivalent of our GUI configuration so that you can repeat
    these scans as part of scripts or move to tweaking in the CLI. A word of caution
    or clarification--I found that the CLI was finicky, in that it had issues depending
    on the formatting of the URL string I was using, or that the order flags added
    for options sometimes had very different results. Using the GUI tool eliminated
    a lot of the uncertainty and is a great way to avoid these same pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_09_19.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing Hydra results and the command line version
  prefs: []
  type: TYPE_NORMAL
- en: Hydra's use as a purpose built brute-force tool is a fantastic way to tackle
    web and non-web credential hacking. The old saying *garbage-in, garbage-out* applies
    here as well--our results will only be as good as the password and user lists
    feeding the tool, so I would recommend exploring ways to better organize your
    OSINT gathering. Get comfortable with the wordlists you have in the various tools
    included with Kali, and become familiar with tools like **Crunch** ([https://sourceforge.net/projects/crunch-wordlist/](https://sourceforge.net/projects/crunch-wordlist/))
    and **CeWL** ([https://digi.ninja/projects/cewl.php](https://digi.ninja/projects/cewl.php))
    to help generate the wordlists. It is also worth investigating hash-based attacks,
    which allow us to avoid the cryptographic hashing to the password and leverage
    more of the **Single Sign-On** (**SSO**), **Open Authentication** (**OAuth**),
    and hybrid authentication architectures commonly used in Microsoft ADÂ environments.
    These hash-based approaches (like **Pass-the-hash**:**Â [https://www.sans.org/reading-room/whitepapers/testing/pass-the-hash-attacks-tools-mitigation-33283](https://www.sans.org/reading-room/whitepapers/testing/pass-the-hash-attacks-tools-mitigation-33283)**)
    make more sense in full-suite penetration testing where system testing is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is the basis for trust on the web. A compromise in this area
    may not be as flashy as in other aspects of the application, but the impact is
    critical. A break in authentication or session management renders all other security
    measures moot. Teaching customers understand this is important, but we need to
    advocate for greater adoption of temporal 2FA, reuse of standardized and well-understood
    frameworks versus home grown portals, and continual penetration testing throughout
    all phases of the software development lifecycle to ensure that the maturation
    of an application does not leave a credible, hardened authentication unfinished.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw how there are many ways in which web applications can
    identify and verify users and assign privileges. We now have the tools to test
    both the resiliency of session management within the application as well as charging
    head first into obtaining the credentials. Burp Suite, Hydra, OWASP ZAP, and,
    of course, your browser and some OSINT will be very useful in validating your
    target's hardening.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](000.html#), *Launching Client-Side Attacks*, we'll take client-side
    attacks to the next level and revisit DOM-based, cross-site scripting. You'll
    also learn how to leverage clients to mount attacks and escalate our privileges,
    hijack communications on your behalf, and even learn about the mystical cross-site
    request forgery. We're in the homestretch, folks, and I am stoked you are still
    with me! Let's charge forward and pick on some browsers.
  prefs: []
  type: TYPE_NORMAL
