- en: Securing Kubernetes Clusters and Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of security deserves special attention—Kubernetes is a huge and complex
    system where security is not obvious and potential **attack vectors** are not
    immediately visible. Thinking about security in Kubernetes is even more important
    if you consider the powerful operations that this system can perform and how deeply
    it integrates with the operating system internals. Just to shed some light on
    how things may go south if you overlook configuration details, take a look at
    an article on how Tesla got cryptojacked because of a *public*, *unauthenticated*
    endpoint for Kubernetes Dashboard ([https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca](https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca)).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to provide you with the general best practices
    for securing Kubernetes clusters, including the Windows workloads perspective.
    Windows nodes have some limitations—for example, mounting secrets in clear text
    directly from the node storage only (not memory)—but they also are more secure
    than Linux nodes in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing Kubernetes clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the container runtime on Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying secure applications using network policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes secrets on Windows machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10 Pro, Enterprise, or Education (version 1903 or later, 64-bit) installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows/Linux Kubernetes cluster deployed using AKS Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To follow along, you will need your own Azure account in order to create Azure
    resources for the Kubernetes cluster. If you haven't already created the account
    in the previous chapters, you can read more about how to obtain a limited free
    account for personal use at [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Kubernetes cluster using AKS Engine has been covered in [Chapter
    8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying a Hybrid Azure Kubernetes
    Service Engine Cluster*.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this book chapter from the official
    GitHub repository at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Securing Kubernetes clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will give some general guidance on how to secure Kubernetes
    clusters. Additionally, we are going to explore the topic of API user authentication in
    AKS Engine clusters using **Azure Active Directory **(**AAD**) integration. The
    list of best practices provided in this chapter is not exhaustive, so please always
    review the latest official documentation to ensure that you follow the recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go through the list of general recommendations in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using built-in RBAC for authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the **role-based access control** (**RBAC**) provided by Kubernetes
    for API authorization in [Chapter 11](9ad8c38e-6d0d-435b-a46c-82a468f18007.xhtml), *Configuring
    Applications to Use Kubernetes Features*. This mechanism allows you to configure
    fine-grained sets of permissions and assign them to users, groups, and service
    accounts. In this way, as a cluster administrator, you can control how cluster
    users (internal and external) interact with the API server, which API resources
    they can access, and which actions they can perform. At the same time, you should
    use namespaces to create the first boundary between resources. This also makes
    applying RBAC policies easier.
  prefs: []
  type: TYPE_NORMAL
- en: For RBAC, use the principle of least privilege and prefer assigning RoleBindings
    to groups instead of individual users to reduce management overhead. If you use
    an external authentication provider, you can easily integrate with groups provided
    by the provider. When bootstrapping the cluster, it is recommended that you use
    the Node and RBAC authorizers together (use the `--authorization-mode=Node,RBAC`
    parameter for the API server), in combination with the **NodeRestriction** admission
    plugin. This is the default way that AKS Engine initializes your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Using an external authentication provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All API calls must be authenticated. This is true for both external (normal)
    users as well as members of the internal Kubernetes infrastructure—for example,
    kubelet. In the case of the infrastructure, such users generally use ServiceAccounts
    with tokens or X509 client certificates, which are created when bootstrapping
    the cluster. Kubernetes itself does not provide the means for managing normal external
    users who access the cluster; this should be delegated to an external authentication
    provider that can integrate with Kubernetes—for example, via an authenticating
    proxy.
  prefs: []
  type: TYPE_NORMAL
- en: You should choose an authentication mechanism that fits your organization and
    follows the common access patterns for the users. For example, if you are running
    AKS Engine, it is likely that you are already using Azure Active Directory to
    manage users and roles in your Azure subscription. On top of that, you should
    consider using groups to make RBAC policy management easier and more integrated
    with AAD.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from AAD, authenticating proxies and authentication webhooks give you
    the possibility to integrate with different protocols, such as LDAP, SAML, or
    Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this section, we will demonstrate how to enable AAD integration
    for your AKS Engine cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the cluster using kubeadm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are deploying the cluster manually, use **kubeadm**, which can bootstrap
    the cluster securely. It can generate a **self-signed CA** to set up identities
    for all components in the cluster, generate **tokens **for joining new nodes (TLS
    bootstrapping), and offer **certificate management **capabilities ([https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/](https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/)).
    Initializing a **secure** Kubernetes cluster is the top design priority for kubeadm
    ([https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md](https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.10.md)).
  prefs: []
  type: TYPE_NORMAL
- en: Disabling public API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For production scenarios, using proper user authentication with RBAC authorization
    for the Kubernetes API may not be enough (from a security perspective) if the
    API is publicly accessible. To reduce the attack vector for your Kubernetes API,
    consider *disabling* public API access, as well as not exposing any Kubernetes
    nodes directly to the internet. This will, of course, require you to use a **VPN**
    or a **jumpbox host** to access the API, but it is definitely more secure.
  prefs: []
  type: TYPE_NORMAL
- en: AKS Engine can configure this for you by a simple change to the cluster apimodel.
    You can read more about disabling public API access in the official documentation
    at [https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster](https://github.com/Azure/aks-engine/blob/master/docs/topics/features.md#private-cluster).
    Alternatively, you may consider hardening the **NAT inbound rules** for master
    VMs, restricting the range of IPs that are allowed to connect to the machine via
    HTTPS and SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the public Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the Kubernetes API, you should disable the publicly accessible Kubernetes
    Dashboard. In common installations, the Dashboard may be exposed as a LoadBalancer
    service; in the worst case, this will be on a ServiceAccount with a `cluster-admin` role.
    The recommended practice is to never expose Kubernetes Dashboard using a LoadBalancer
    service, and to always use `kubectl proxy` to access the page.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the ServiceAccount for Kubernetes Dashboard should have the **least
    privileges **that are enough for your use cases. You will most likely never use
    Kubernetes Dashboard for creating or editing deployments in production, so why
    would you need write access for such sensitive API resources?
  prefs: []
  type: TYPE_NORMAL
- en: Running containers in nonprivileged mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, it is possible to specify whether a pod is privileged or not.
    Privileged pods may have containers that are running in privileged mode—this essentially
    means that the container has access to all devices on the host, which is similar
    to what processes running with root (or administrative) privileges on the host
    would have.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to ensure that your pod containers are running in nonprivileged
    mode in the operating system; this follows the principle of least privilege. Additionally,
    you should consider using the PodSecurityPolicy admission controllerto enforce
    a set of rules that a pod must fulfill to be scheduled. An example restrictive
    policy can be found at [https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml](https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in the case of Windows containers, running privileged containers
    is not supported. Additionally, for Windows workloads, consider using **Group-Managed
    Service Accounts** (**gMSAs**, [https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)).
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting data at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Encrypting data at rest** is considered a general good practice (and sometimes
    a law-enforced requirement) for all systems. In Kubernetes, you need to ensure
    that **etcd cluster **data is encrypted. This will provide an extra layer of security
    for your API resources and secrets that would otherwise be kept in etcd in unencrypted
    form. Encrypting secrets at rest is covered as a separate topic in the official
    Kubernetes documentation at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For secrets, you should always use late binding by injecting the secrets to
    pods as volumes or environment variables. Note that injecting secrets as environment
    variables is less secure on Linux; when you have root privileges, you can enumerate
    all environment variables for a process from `/proc/<pid>/environ`. On Windows
    nodes, the issue is even more complex: you can still access environment variables
    for processes, but volumes cannot currently use the in-memory filesystem. This
    means that secrets are then stored directly on the node disk storage. This means
    that you should consider encrypting your Windows node storage to minimize the
    exposure of credentials. We will take a look at this issue in the next sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Using network policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network policies act as a firewall between your pods, allowing you to control
    network access into and out of your containerized applications. In a Kubernetes
    cluster, there are no limitations in network communication between pods by default—basically,
    all-to-all traffic is possible. It is a good practice to use a permissive network
    policy model that, by default, denies all traffic and allows connections only
    if a dedicated network policy has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about network providers that support network policies that
    are available on AKS Engine in the official documentation at [https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy](https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy).
    Please take note that currently Windows pods are not supported by these providers,
    apart from the Enterprise version of Calico that is provided as a part of the
    Tigera Essentials subscription service ([https://www.tigera.io/media/pr-calico-for-windows](https://www.tigera.io/media/pr-calico-for-windows)).
  prefs: []
  type: TYPE_NORMAL
- en: Securing the image supply chain and scan images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](e00b7610-2513-4513-863f-62a054d8cd98.xhtml), *Working with Container
    Images*, we described how you can sign and verify your Docker images using **Docker
    Content Trust** (**DCT**). You should definitely consider using this approach
    for your Docker image pipelines in production. Additionally, consider incorporating
    open source tools, such as **Anchore** ([https://github.com/anchore/anchore-engine](https://github.com/anchore/anchore-engine))
    and **Clair** ([https://github.com/quay/clair](https://github.com/quay/clair)),
    which can help you identify common vulnerabilities and exposures (**CVEs**) and
    mitigate them.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating infrastructure credentials and certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, the shorter the validity time of a credential or a token, the harder
    it will be for the attacker to make any use of such a credential. Use this principle
    to set short lifetimes for certificates and tokens that are used in your cluster
    and implement **automated rotation **whenever possible. This can become your secret
    weapon when you detect that you are under attack;  if you can effectively rotate
    certificates, you can simply rotate them on demand and make any intercepted credentials
    useless.
  prefs: []
  type: TYPE_NORMAL
- en: For AKS and AKS Engine, consider using integration with **Azure Key Vault**,
    which makes your secret and certificate management and rotation much easier. You
    can read more in the official documentation at [https://github.com/Azure/kubernetes-keyvault-flexvol](https://github.com/Azure/kubernetes-keyvault-flexvol).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, consider integrating an authentication provider for issuing user
    tokens with a short expiration time. You can use this approach for providing **just-in-time
    privileged access management**, which can drastically limit the amount of time
    that a user has *God-mode*access to the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling audit logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Audit logs** should always be available in production clusters. This will
    make it possible to set up monitoring and alerting for access anomalies and unexpected
    API calls. The earlier you detect any forbidden API responses, the greater the
    chance that you will react in time and prevent the attacker from gaining access
    to the cluster. You can read more about Kubernetes auditing in the official documentation
    at [https://kubernetes.io/docs/tasks/debug-application-cluster/audit/](https://kubernetes.io/docs/tasks/debug-application-cluster/audit/).'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you go through the official Kubernetes guide for securing a cluster
    when you set up a production cluster. You can find more details at [https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/](https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, after we have gone through the most important security best practices for
    Kubernetes clusters, we will take a look at how to enable **Azure Active Directory**
    (**AAD**) for client authentication in an AKS Engine cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating AAD with AKS Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AKS Engine can be easily integrated with AAD in order to provide Kubernetes
    API client authentication. Together with AAD **groups**, this approach can be
    used for creating RoleBindings and ClusterRoleBindings for user groups that are
    mapped to AAD groups.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how you can create an AKS Engine cluster with AAD integration and
    create an AAD group for cluster admins. This approach can be extended to manage
    multiple AAD groups that can have different bindings in RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Adding AAD integration to an existing AKS Engine cluster is not supported. Therefore,
    you need to make this decision at cluster deployment time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for configuring AAD applications for a server and client, as well
    as the creation of the admin AAD group, have been provided as a Powershell script at [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13/01_AksEngineCreateAadProfile.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/tree/master/Chapter13/01_AksEngineCreateAadProfile.ps1) for
    your convenience. You can use the script or go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the PowerShell window and define the `$dnsPrefix` variable with a globally
    unique DNS prefix, which you will later use for AKS Engine deployment—for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an AAD server application that will represent the Kubernetes API server
    and store the `appId` for further use as a `$serverApplicationId` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Update group membership claims for this application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a **service principal **that will be used for Azure platform authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the **secret** for the service principal and store it for further use as
    a `$serverApplicationSecret` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add permissions for the server application to read directory data and sign
    in and read the user profiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Grant the permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next steps will be similar, but will apply to an AAD **client application** that
    represents kubectl. Create the application and store the `appId` for further use
    as a `$clientApplicationId` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your AAD tenant configuration, you may require additional permissions
    to create the service principal. You can read more in the official documentation
    at [https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions](https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal#required-permissions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the service principal for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine the OAuth2 ID for the server application and store it as `$oauth2PermissionId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the OAuth2 ID to allow the authentication flow between the client and server
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an AAD group named `AksEngineAdmins` for AKS Engine administrators and
    store its ID as a `$adminGroupId` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to add the current user to this group. First, let''s retrieve
    the `objectId` for the user and store it as a `$currentUserObjectId` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the user to the AKS Engine administrators group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Determine the AAD Tenant ID for your current subscription and store it as a `$tenantId`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the JSON object based on the previous variables that will be used in
    the AKS Engine apimodel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have everything we need to deploy AKS Engine with AAD integration. To do
    this, we will use a PowerShell script in almost exactly the same way that we used
    it in previous chapters ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/CreateAKSEngineClusterWithWindowsNodes.ps1)),
    together with the apimodel template ([https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Windows/blob/master/Chapter13/02_aks-engine-aad/kubernetes-windows-template.json)).
    To perform AKS Engine deployment, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download both the PowerShell script and the apimodel template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the PowerShell window in the location of the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `kubernetes-windows-template.json` file, replace `aadProfile` with your
    own values from the previous paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the script with appropriate parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, the script will execute the `kubectl get pods` command
    and you will be prompted to *authenticate* in the web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f8a01372-d9c8-4987-9a74-d659c938ff65.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigate to the URL, provide the code, and log in. After that, you will be authenticated
    successfully in the Kubernetes API server and be able to use kubectl.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To check the definition of the ClusterRoleBinding, which allows you access,
    execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your needs, you can now configure more AAD groups, create roles
    and provide appropriate RoleBindings for them. In the next section, we will take
    a look at how you can ensure that the Windows container runtime is running securely.
  prefs: []
  type: TYPE_NORMAL
- en: Securing container runtime in Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to securing container runtime, Windows containers are a bit different
    than Linux containers. For Windows containers, the operating system uses a `Job`
    object (not to be confused with Kubernetes `Job` object!) **per container** with
    a system namespace filter for all processes running in a given container. This
    provides a logical isolation from the host machine that cannot be disabled. You
    can read more about the Windows container architecture in [Chapter 1](deffbcf5-3a21-4690-ad42-ae5e4cd97dea.xhtml), *Creating
    Containers.*
  prefs: []
  type: TYPE_NORMAL
- en: This fact has a consequence: **privileged** containers are not available in
    Windows, though they are available in Linux. Additionally, with the incoming support
    for Hyper-V containers in Kubernetes, you will be able to secure the container
    runtime even more and enforce better isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux containers**,** you would consider using `securityContext` for a
    pod in order to run as a **nonprivileged** user (with an ID different from `0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can enforce **PodSecurityPolicies**, which are verified by
    the admission controller before scheduling a pod. In this way, as an example,
    you can ensure that no pods in a given namespace are running in privileged mode.
    You have to use RBAC to properly configure policy access.
  prefs: []
  type: TYPE_NORMAL
- en: AKS Engine comes by default with the PodSecurityPolicy admission controller
    enabled and **privileged** and **restricted** policies available.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows containers, the standard `securityContext` will not work as it
    is meant to be used for Linux containers. Windows containers have a dedicated
    object inside `securityContext` named `windowsOptions`, which can enable some
    Windows-specific features that are currently still in the **alpha** state:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring running pod containers with a different user name ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-runasusername/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Group-Managed Service Accounts (gMSA) for pod containers ([https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/](https://kubernetes.io/docs/tasks/configure-pod-container/configure-gmsa/)).
    The gMSA is a specific type of Active Directory account that provides automatic
    password management, simplified service principal name management, and the ability
    to delegate the management to other administrators on multiple servers. Azure
    Active Directory comes with support for gMSA ([https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa](https://docs.microsoft.com/en-us/azure/active-directory-domain-services/create-gmsa)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will learn more about network policies and how they
    can be used to deploy more secure applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying secure applications using network policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, you can provide better granularity for your application deployments
    in terms of network isolation using network policies. Represented by `NetworkPolicy`
    objects, they define how groups of pods can communicate with each other and network
    endpoints in general—think of them as a basic firewall for enforcing network segmentation
    at layer 3 of the OSI model. Of course, they are not a substitution for advanced
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkPolicy` object uses label selectors in order to identify the pods
    that they are attached to. Similarly, label selectors and IP CIDRs are used for
    defining ingress and egress rule targets for these pods. A given network policy
    is used only if it has a label selector that matches a given pod. If there are
    no network policies matching a given Pod, it can accept any traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Network policy support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use network policies, you need to use one of the **network providers**
    (used for installing the pod network, as described in [Chapter 5](da2ee6af-a754-4fc8-ae62-86d8e68f0bd0.xhtml),
    *Kubernetes Networking*) that supports network policies. The most popular are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calico ([https://www.projectcalico.org/](https://www.projectcalico.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cilium ([https://cilium.io/](https://cilium.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kube-router ([https://www.kube-router.io/](https://www.kube-router.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Romana ([https://romana.io/](https://romana.io/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weave Net ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, there are *no* network providers that currently support Windows
    nodes, which means you can only use network policies in Linux clusters. The only
    network provider that has announced incoming support for Windows nodes and network
    policies is the enterprise version of Calico, provided as a part of the **Tigera
    Essentials** subscription service ([https://www.tigera.io/media/pr-calico-for-windows](https://www.tigera.io/media/pr-calico-for-windows)).
    You can currently try this offering, including Windows node support, in a private
    preview version. Please note that if you are using AKS or AKS Engine, you are
    limited to Calico or Cilium, working together with **A****zure** or **kubenet**
    network CNI plugins.
  prefs: []
  type: TYPE_NORMAL
- en: For more details regarding AKS Engine configuration for network policy support,
    please refer to the official documentation at [https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy](https://github.com/Azure/aks-engine/tree/master/examples/networkpolicy).
    Additionally, for managed AKS, you may consider using an **advanced networking**
    feature that allows you to configure your own VNet, define Azure network security
    groups, and provide automatic connectivity of your pods to the VNet—you can read
    more in the official documentation at [https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni](https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni.).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how you could use network policies to enforce pod isolation in your
    clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring network policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a security perspective, network policies are important because, by default,
    Kubernetes allows **all-to-all** communication in the cluster. Namespaces only
    provide a simple isolation that still allows pods to communicate with each other
    by IP address. In larger clusters or in multitenant scenarios, you have to provide
    better network isolation. Even though Windows nodes do not yet support network
    policies (but eventually they ***will*** be supported), we feel that it is important
    to make you aware of how you can approach network segmentation using native Kubernetes
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an AKS Engine Linux cluster with a Calico network on an Azure CNI
    plugin, you can follow along and configure the network policies for your pods.
    Deployment of AKS Engine with such a configuration requires a simple change to
    the cluster apimodel, namely by adding the following property in `properties.orchestratorProfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a network policy that *blocks all ingress* traffic to all
    pods in the `default` namespace. This is the opposite of what you have in the
    cluster by default—the pods in the namespace will be not able to communicate with
    each other unless you specifically allow it. After that, we will deploy a simple
    Nginx web server behind a LoadBalancer service and try to communicate internally
    from a different pod in the cluster and externally from the Azure load balancer.
    Then we will create a network policy that will act as a **whitelisting rule**
    just for TCP port 80 for the web server. Please go through the following steps
    to create the default deny-all rule and deploy the Nginx web server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `default-deny-all-ingress.yaml` manifest file for the `NetworkPolicy` object
    that denies all ingress traffic to pods in the `default` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is achieved by using an empty `podSelector`, which will select all pods.
  prefs: []
  type: TYPE_NORMAL
- en: Apply the manifest file using the `kubectl apply -f .\default-deny-all-ingress.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can use the following command for any network policy if you want to better
    understand what its effect is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a simple manifest file named `nginx-deployment.yaml` for Nginx deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\nginx-deployment.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `nginx-service.yaml` manifest file for the LoadBalancer service for
    the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\nginx-service.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be careful when defining very restrictive egress rules. With deny-all egress
    rules, you will block access to the Kubernetes DNS service for the pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our Nginx web server deployed and the default rule for denying all ingress
    traffic to pods in the `default` namespace, we can test the connection to the
    web server:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the external IP of the service to appear using `kubectl get svc -w`
    and open the address in a web browser.You will see that the connection hangs and
    eventually times out, as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s check this using an ad-hoc pod running in the same namespace. Create
    a `busybox` pod in the interactive mode, running a Bourne shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the shell session in the pod, try getting the web page hosted by Nginx.
    You can use both the service DNS name and the IP of one of the pods. In both cases
    it will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a network policy that allows ingress traffic to Nginx pods
    on TCP port `80`. After that, you will be able to communicate from both pods in
    the cluster, as well as from the Azure load balancer. To configure the policy,
    go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Leave the `busybox` interactive session running and open a new PowerShell window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `default-nginx-allow-ingress.yaml` manifest file that allows ingress
    traffic on TCP port `80` to all pods with label `app=nginx` from all sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\default-nginx-allow-ingress.yaml`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your web browser, navigate again to the external IP for the service. Now,
    you should be able to reach the web page without any problems!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, try the same in the `busybox` pod container using `wget`. You will
    also be able to reach the web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an exercise, to prove that port filtering works properly, you can modify
    the network policy to use a different port or run Nginx on a TCP port different
    than `80`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have successfully used network policies to configure permissive
    networking rules in your Kubernetes cluster. It is a good practice to start with
    a *permissive *network policy model where you *deny all ingress* traffic to your
    pods (sometimes also all egress traffic from the pods) and allow the connections
    by specific network policies. Please note that, for this, you should organize
    the network policies in a predictable manner, using naming conventions. This will
    make the management of your networking rules much easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how you should handle Kubernetes secrets
    on Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes secrets on Windows machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](118e3c89-786e-4718-ba67-6c38928e2a42.xhtml), *Kubernetes Concepts
    and Windows Support*, we mentioned that one of Windows's node support limitations
    is that Kubernetes secrets that are mounted to pods as volumes are written in
    *clear-text* on node disk storage (not RAM memory). The reason for this is that
    Windows currently does not support mounting in-memory filesystems to pod containers.
    This may pose security risks, and needs additional actions to secure the cluster.
    At the same time, mounting secrets as environment variables has its own security
    risks—you can enumerate environment variables for processes if you have access
    to the system. Until it is possible to mount secrets as volumes from in-memory
    filesystems, there is no completely secure solution for injecting secrets for
    Windows containers apart from using third-party providers, such as Azure Key Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption of secrets *at rest* in a Kubernetes etcd cluster is a different
    and important topic that is covered in the official documentation at [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform a small experiment to better understand the issue and any possible
    implications. You will need your AKS Engine cluster with Windows nodes that we
    used in the previous chapters. Please go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the PowerShell window and create a `secret-example.yaml` manifest file
    that contains the username `admin` and password `Password123` encoded in Base64:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\secret-example.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `windows-example-deployment.yaml` manifest file for the deployment
    of the sample ASP.NET application running on Windows with a `secret-example` 
    secret mounted in the `C:\SecretExample` directory on the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Apply the manifest file using the `kubectl apply -f .\windows-example-deployment.yaml` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine which Windows node is running the pod using the `kubectl get pods
    -o wide` command. In our case, it is `2972k8s011`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions from [Chapter 8](ab695a0d-05dc-48f8-8c41-bbd167cfbfa6.xhtml), *Deploying
    Hybrid Azure Kubernetes Service Engine Cluster* in the subsection *Connecting
    to virtual machines* in order to create a remote desktop connection to node `2972k8s011`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a command-line prompt initializes, use the `docker ps` command to identify
    the ID of the Docker container that runs our application. Next, run the `docker
    inspect -f {{.Mounts}} <containerID>` command to get the *physical* location of
    the Docker volume data on the *host''s* disk storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/80d43a8d-4ef0-4490-9a21-8abc4d804b13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, simply use this path, check the directory contents, and use the `type
    <filePath>` command to reveal the contents of the file that maps to the `password`
    key in our secret object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cfb041d5-5118-4ffd-ab46-4b8bbee2bd2a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have retrieved the `Password123` value without any problems.
    On a Linux system that uses an in-memory *tmpfs* filesystem for mounting volumes
    into secrets, it wouldn't be that easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'This current design has an obvious security issue: whoever manages to access
    the node disk storage data can get your secrets (currently used) in *plain-text*.
    This concerns not only the access to the machine itself (physical or remote) but
    also the *backups* of your disks that store Docker volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this issue, at least to some extent, you should use *disk encryption*
    for the Windows node disks. In an on-premises scenario, you can consider using
    BitLocker, which has native support on the Windows server operating system; you
    can find more details in the official documentation at [https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server](https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server).
  prefs: []
  type: TYPE_NORMAL
- en: For Azure deployments, the good news is that Azure VM disks are always *encrypted
    at rest in Azure data centers*. If your scenario requires you to provide encryption
    at VM-operating-system level, then this feature is not supported yet for managed
    AKS ([https://github.com/Azure/AKS/issues/629](https://github.com/Azure/AKS/issues/629)),
    and, in the case of AKS Engine, the node VMs are created by default without encryption
    (you cannot control them in the cluster apimodel), but you can enable it manually
    yourself. You can read more about scenarios for Windows VM encryption in the official
    documentation at [https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/disk-encryption-windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how you can encrypt the Windows node disks manually, let''s
    turn on encryption for one of the nodes in our cluster, `2972k8s011`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the PowerShell window and create an Azure key vault named `AksEngineEncryptionVault`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the usage of the key vault for disk encryption for Azure VMs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable encryption of the `2972k8s011` node for `All` disks mounted to the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When the encryption process is finished, check the current status of the encryption
    feature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This process would have to be repeated for all Windows nodes in the cluster
    and repeated whenever you scale your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully encrypted a Windows node disk in order
    to increase Kubernetes secret security.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has focused on Kubernetes security in general. We have provided
    you with 11 recommendations and best practices for securing your Kubernetes cluster,
    from using RBAC and integrating an external authentication provider, such as Azure
    Active Directory, to disabling public access for the Kubernetes API and Dashboard
    and enabling audit logging. We demonstrated how to make your RBAC management and
    authentication easier on AKS Engine clusters using Azure Active Directory integration.
    Next, we discussed how to secure container runtime in Kubernetes and the role
    of network policies (which are not supported on Windows nodes yet).
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, you learned the differences between the injection of Kubernetes
    secrets on Linux and Windows machines and saw that, with the current design, accessing
    secrets on Windows machines is easier and can cause security problems. To mitigate
    this, we showed you how you can encrypt disks for Azure VMs that are used as Windows
    nodes in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how to approach the monitoring of Kubernetes
    clusters, especially Windows nodes and .NET applications running on Windows nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should you use an external authentication provider in Kubernetes, such as
    AAD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is disabling public access to Kubernetes Dashboard important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the reason for recommending the encryption of etcd data storage at rest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you run privileged containers on Windows machines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are network policies in Kubernetes and what are the prerequisites to have
    them enabled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between Linux and Windows nodes when it comes to
    mounting secrets as volumes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is injecting secrets as environment variables considered less safe than
    using volumes, especially on Linux nodes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find answers to these questions in *Assessments* of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about Kubernetes security, please refer to the following
    PacktPub books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Com**plete Kubernetes Guide* ([https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide](https://www.packtpub.com/virtualization-and-cloud/complete-kubernetes-guide)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes - Third Edition* ([https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://www.packtpub.com/virtualization-and-cloud/getting-started-kubernetes-third-edition)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes fo**r Developers* ([https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/virtualization-and-cloud/kubernetes-developers)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
