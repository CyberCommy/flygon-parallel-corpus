- en: Preparing a RESTful API for Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a full fledged catalog RESTful API;
    however, there is a difference between a completely functional API and a production-ready
    one. In this chapter, we will cover how an API should be documented and tested
    thoroughly. These key requirements have to be completed by any piece of software
    before going productive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Documenting RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing RESTful APIs with Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservices revolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we partially covered how RESTful web services APIs are described
    by wadl and documented by swagger specifications. Now it''s time to take full
    advantage of them and expose their self-descriptive metadata in express.js routes
    in our catalog application. That way, both consumers and end users will have separate
    URLs for the metadata they will need to adopt the service easily. Let''s start
    with the wadl definitions. Here''s how an operation is fully described by wadl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each route thoroughly describes all the operations it exposes; that way, they
    will be indexed and discoverable by clients compliant with the `wadl` specification.
    Once you have all your operations described, simply store the `wadl` file in the
    `static` directory of your `express.js` project and expose it from application:
    `app.use(''/catalog/static'', express.static(''static''));`'
  prefs: []
  type: TYPE_NORMAL
- en: After starting your application locally, your `wadl` file will be ready to serve
    clients at `http://localhost:3000/catalog/static/catalog.wadl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give that a try and import it to Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8ad76fb-4325-4b5b-96f6-190768f907c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Importing wadl file into Postman. This is a screenshot for Postman. The individual
    settings are not important here. The purpose of the image is just to show how
    the window looks.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the `wadl` file statically will help your application in getting indexed
    by search engines; this further increases the adoption of your API.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, slowly but surely, `wadl` is losing grip in favor of `swagger`. The
    evolution of JavaScript REST-enabled applications has led to the requirement of
    the non-XML based standard for discovering RESTful services. That is the reason
    for `swagger` to become the de facto standard, not only for documenting RESTful
    services, but also for its widely adopted discovery format. While XML-aware platforms
    are still relying on `wadl`, JavaScript and other non XML-native platforms are
    heavily relying on the `swagger` specification, not only for description but also
    for discovery and consumption, and its adoption is progressing rapidly. So you
    should consider having your APIs described in `swagger` to ensure easy adoption
    from any platform out there. Here''s how an operation is fully described in a
    `swagger` dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after having all the APIs'' operations described in a `swagger.json`
    file, it should be statically exposed, similar to the `wadl` file. Since the application
    already has a route for the static directory, just place the `swagger.json` file
    there, and it will be ready for serving consumers and promoting discovery. `Swagger`,
    being mainly a documentation tool, however, mainly targets developers; thus, it
    needs a frontend that makes the documentation easy to read and understand. There
    is an `npm` module—`swagger-ui`—that wraps up the default swagger frontend for
    us. We will adopt it in our application, so let''s use the package manager to
    install it—`npm install swagger-ui`. Once installed, simply require an instance
    of the module along with an instance of the static `swagger.json` file and use
    them in a separate route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your application and request `http://localhost:3000/catalog/api-docs/`
    in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f3a352d-f327-4759-9979-621b2388988d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the swagger-ui module provided the standard swagger frontend
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, as a developer, keeping your API documentation in a shape
    and up to date is your responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Testing RESTful APIs with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you noted that the `app.js` express application created with `express-generator`
    is actually a `node.js` module exporting the express instance? In case you have,
    you must have asked yourself why that is actually needed. Well, having the express
    instance exported as a module enables it to be unit-tested. We already utilized
    the `mocha` framework in [Chapter 4](3332b6f7-ed61-4fc6-a674-5e8c4952aa77.xhtml),
    *Using NoSQL Databases,* where we developed a unit test for the `CatalogItem`
    module. We will use `mocha` once again and wrap a unit test around each operation
    API exposes. To unit-test the express application, we will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Require an instance to the `express.js` application with the routes, making
    use of its being exported as a module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `express.js` instance in unit test environment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke its operations via a test library and assert against the results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, execute the `npm test` command to trigger the unit test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before moving on and implementing mocha tests, we need a library for sending
    HTTP requests from the unit tests; we will make use of the `chai` module. It provides
    convenient functions for sending HTTP requests, and it also bundles the `should.js`
    assertion library to verify the expected results. To install `chai`, simply execute
    `npm install chai` and then its `npm install chai-http` HTTP plugin, and we are
    ready to start unit testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any other mocha test, we will have to carry out the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe each test case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the test fixture; this time, we will be using `chai-http` for invoking
    the rest operations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert against the returned results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A basic unit test covering the operations for creating, accessing, and deleting
    resources looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Store this file in the test directory of your project; this directory is defined
    as a test directory in the `package.json` by default, so to run the unit test,
    just execute `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d631466-3680-4d73-a8f4-84fea9173b23.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! Now you have your API covered with unit tests, and note that
    the tests aren't mocking anything! They are running the express application; exactly
    the same way, the application will be run when it becomes productive, ensuring
    stability and backward compatibility! Currently, the unit test asserts only against
    status code. Spend some time with it and extend them further to assert against
    the response body as well. This will be a good exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices revolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It wasn't very long ago when the RESTful API madness started and almost everyone
    decided that RESTful APIs were the right way to go, was it? With `Linux` containers
    available, it turned out that switching to the REST approach was only half of
    the way. Currently, everyone is benefiting from containers. They provide better,
    faster, and cheaper development and operational model, but are microservices just
    yet another buzz term for RESTful services? Well, no, not at all; RESTful services
    are just the foundation of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are small and independent processes exposing a simple interface
    that allows communication with them and building complex applications without
    depending on library artefacts. These services resemble small building blocks,
    highly decoupled and focused on doing a small task, facilitating a modular approach
    to system-building.
  prefs: []
  type: TYPE_NORMAL
- en: While REST emphasizes on resources and their natural handling, the microservices
    architecture emphasizes on simplicity, fail-safeness, and isolation. A RESTful
    API doesn't have separate states per operation; it is either that the entire API
    is available or it is completely down. Microservices attempt to solve that problem,
    providing means to host each operation on a separate container, or subset of containers,
    ensuring maximum fault tolerance and agility.
  prefs: []
  type: TYPE_NORMAL
- en: A microservice is expected to provide a single simple action, nothing more.
    This enables developers to group and consume them exactly the way they want. Policy
    handling, governance, security, and monitoring are usually out of the scope when
    dealing with microservices, mainly because they require some kind of context.
    In general, binding context to a service increases its dependencies and makes
    it less reusable; this is why microservices leave context to API management gateways,
    which allow you to create a composite of microservices and then bind a policy
    to it and monitor every activity on the gateway. This distribution development
    model empowers programmers to rapidly grow a collection of microservices without
    considering complex topics such as governance and security.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices world is a game changer, benefiting from Linux containers.
    Currently, all cloud-based offerings similar to AWS and Azure provide microservices
    hosting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we stepped slightly aside from `Express.js` related topics.
    Instead, we concentrated on how to productionize our code base by providing up-to-date
    API documentation, along with the API itself. We had our application invest in
    precautionary measures for ensuring backward compatibility by implementing more
    complex unit tests that actually target close-to-real-life implementation. Finally,
    we decided to look into the future, which is all about microservices. Ensure that
    you keep this hot topic up in your skill-list; it will inevitably evolve in the
    near future, and the more you know about it, the better!
  prefs: []
  type: TYPE_NORMAL
