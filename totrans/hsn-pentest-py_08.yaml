- en: Automating Web Application Scanning - Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about web application scanning, there are various attack vectors
    that come to mind, such as SQL injection, XSS, CSRF, LFI, and RFI. The tool that
    we might think of when we talk about web application testing is the Burp Suite.
    In this chapter, we are going to study how we can use Python in order to try and
    automate web application attack vector detection. We will also look at how Python
    can be used to automate Burp scanning in order to cover the vulnerabilities that
    we would otherwise have to discover manually. In this chapter, we are going to
    look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating web application scanning with Burp Suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Burp automation with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic detection of SQL injection with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating web application scanning with Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Suite Professional has exposed an additional functionality for pen-testers
    in terms of its API. With the help of the Burp Suite Professional API, a tester
    can automatically invoke a scan and integrate their findings with other tools
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Burp suite currently offers API support with its licensed version (burp-suite
    professional). This is one of the utility that all  cyber security professionals
    must have. I would recommended to get the licensed version of Burp Suite in order
    to get maximum out of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Burp Suite and configure the API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4ce8eae-640e-4880-8f32-65e911e0ef72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, start the API and configure the API key as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06a55de3-a63a-48a4-8061-aea501583b03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The key would be copied to the clipboard when we click on the button. We can
    use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3a7587c-9f78-437f-82bf-efe060c1f24e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the API is listening at port `1337`. We use the API key to
    refer to this endpoint address. The API exposes three endpoints: to get issue
    definitions, to start a scan, and to get the status of a running scan.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the parameters that are expected for us to start a new scan to test
    the Damn Vulnerable Web Application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application can be installed from the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.dvwa.co.uk/](http://www.dvwa.co.uk/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ethicalhack3r/DVWA](https://github.com/ethicalhack3r/DVWA)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once installed and set up, we can use the following `curl` command in order
    to start an active scan with Burp on the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A more generic request containing a more exhaustive test for crawling and auditing
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the preceding request can either be sent via the Terminal
    on Ubuntu or the web interface provided by Burp API can be used to generate the
    request. It should be noted that if the request is invoked in the manner shown
    previously, it will not return us anything, but would instead create a new scan
    with a task ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be seen at the Burp Suite console as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4f2011e-9920-41cf-adfe-9f51337b2faf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous screenshot, we can see that a new task with the ID as `9` has
    been created and it is scanning our Damn Vulnerable Web Application, which is
    hosted locally. When the screenshot was captured, the task was able to identify
    four high, ten medium, and three low issues. In the following section, we can
    see how to make the scanner constantly tell us the status of the scan. In order
    for it to do so, we need to set up a call back URL. In other words, we need to
    have a listening port where the scanner will constantly send results. We can print
    this on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2919585e-8d65-4874-a61b-8201ed5a2d4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The status of the scan and all the findings will be sent back to the address
    indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a30a396-3b57-489a-96ea-59e76ddd2b6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Given that we now have an understanding of how to automate a scan with Burp
    Suite API, let's make a Python script to do this. We will create a Python script
    to invoke the scan and at the same time the same script will listen to callback
    requests and parse the responses to display all the high, medium, and low issues.
  prefs: []
  type: TYPE_NORMAL
- en: Burp automation with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple Python script and call it `burp_automate.py`. Enter
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we execute the script, it will display all the issues reported by the Burp
    scan that might be of a `high`, `medium`, or `low` nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29538d16-d08b-42f5-8fec-9f0fe1fab1fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot represents the status of the scan and the total number
    of requests made. The script will keep on running until the scan is finished,
    which is depicted by the status **succeeded**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20dad012-3a34-4b6c-bd3c-378f498f1370.png)'
  prefs: []
  type: TYPE_IMG
- en: SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **SQL injection attack** is an attack, using which the execution of an SQL
    query can be altered to cater to the needs of an attacker. A web application might
    be interacting with a database at the backend and it might take user inputs that
    form parameters or part of the SQL query that is to be executed to insert, delete,
    update, or retrieve data from the database tables. In this case, a developer must
    take the utmost care not to pass the user-supplied parameters directly to the
    backend database system as this may lead to SQL injection. The developer must
    make sure to use parameterized queries. Let's assume that we have a login page
    on the application that takes a username and a password from the user and passes
    this information to the backed SQL query as:  `select * from users where email
    ='"+request.POST['email']+"' and password ='"+request.POST['password']"`.
  prefs: []
  type: TYPE_NORMAL
- en: The logic written in the application would check if there are any rows returned
    by the query. If there are, then the user is legit and a valid session would be
    assigned to the user, otherwise an error message showing `Invalid credentials` would
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say a user puts their email address as `admin@abc.com` and their password
    as `admin@123`, in that case the query that will get executed at the backend will
    be the following: `select * from users where email =''admin@abc.com'' and password
    =''admin@123''`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user enters the email as `hacker@abc.com'` or `'1'='1` and their
    password as `hacker'` or `'1'='1` , the query that will be executed at the backend
    will become:`select * from users where email ='hacker@abc.com' or '1'='1' and
    password ='hacker' or '1'='1'`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the first record of the dataset returned will be considered as the
    user who is trying to login, resulting in the authentication being bypassed because
    of SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic detection of SQL injection with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our focus here is to understand how can we automate the detection of SQL injections
    with the help of Python. Whenever we talk about SQL injections, the tool that
    comes to our mind is SQLmap, an excellent tool that is my personal favorite for
    detecting SQL injection in web applications. There are a number of tutorials on
    the internet about how to use SQLmap to detect SQL injection. In this section,
    we will see how can we use the server version of SQLmap, which exposes an API,
    to automate the whole process of detecting SQL injection vulnerabilities. We will
    use a Python script in order to automate the detection process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the SQLmap server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b05c9931-ed0e-457b-bba4-a87c67eeeb8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the server is up and running on the localhost (port `8775`), let''s
    look at how to scan an application (DVWA), for SQL injection, using cURL and API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new task as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/10c420c5-00d4-47a9-a4dc-70929be7d3a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set `scan` options for the new task as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2aa2f353-fb96-4096-b479-2b5c6fd98aee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set `list` options for the new task as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a3a34ab3-25e0-4335-91ac-45d222bd999f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start the scan with the `set` options as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/27bda66f-8f89-4d47-ad03-0d193be91bce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check the `status` of the created scan to discover SQL injection as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/24549a86-71b3-4da7-8e2f-1caa74dbe25c.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/98393f6a-9bef-47ce-975d-5da6438fb606.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/0c836bba-b17f-4ae6-bb41-f625705ee784.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot validates that the backend database is MySQL and the
    parameter ID is vulnerable to SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s automate this whole process with the help of a Python script as shown
    in the following. Name the script `sql_automate.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute the script and obtain the output for SQL injection, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output obtained can be parsed and printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the approaches that we can use to automate our
    web application scanning and assessment with Python. We saw how can we use the
    Burp Suite API in order to scan an underlying application with Python and studied
    a collection of assessment results. We also discussed SQL injection and how Python
    can be used with our favorite tool, SQLmap. Finally, we looked at an invocation
    of SQLmap with Python to automate the whole process of SQL injection detection.
    In the next chapter, we will read about using Python to automate the detection
    of other web application vulnerabilities such as XSS, CSRF, Click jacking, and
    SSL strips.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are other ways of writing Python code with Burp?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which other SQL injection tools can be automated with Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the drawbacks and advantages of using an automated approach of web
    application scanning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp and SQL plugin: [https://github.com/codewatchorg/sqlipy](https://github.com/codewatchorg/sqlipy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending Burp to detect SQL injection with SQL map: [https://www.codewatch.org/blog/?p=402](https://www.codewatch.org/blog/?p=402)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Burp extensions: [https://portswigger.net/burp/extender](https://portswigger.net/burp/extender)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
