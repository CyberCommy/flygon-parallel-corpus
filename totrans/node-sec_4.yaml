- en: Chapter 4. Request Layer Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some vulnerabilities appear at the request phase of your application. As mentioned
    before, Node.js does little for you by default, leaving you with complete freedom
    to craft a server that meets your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the request size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One major request-handling feature that is commonly left out of Node.js applications
    is size limits. **Express** (optionally) handles buffering of request body data
    and parsing that request body into some meaningful data structure. While the request
    is still being fulfilled, the entire content of that body is in memory. If you
    place no limits, malicious users have a number of ways to affect your system,
    such as exhausting memory limits, and uploading files that take up unnecessary
    disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your needs, you will need to determine a reasonable limit for
    your application. While your needs may differ, you should always set some sort
    of limit, Connect and Express exposes a middleware just for this purpose, called
    limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This middleware needs to be added early in the stack, otherwise it won't be
    caught until it's too late. It takes a single piece of configuration, which is
    the upper limit on the request size. If you send a number, it will be translated
    as a number of bytes. You can also send a more readable string, such as `"5mb"`
    or `"1gb"`.
  prefs: []
  type: TYPE_NORMAL
- en: This middleware responds with a **413 (Request Entity Too Large)** error to
    be thrown, if the limit is exceeded. First, the `Content-Length` header of the
    request is checked, and if it is too large it denies the request outright. Of
    course, the header could be faked or even absent, so the middleware also monitors
    the incoming data and triggers an error if the actual request body size reaches
    the limit.
  prefs: []
  type: TYPE_NORMAL
- en: The `bodyParser` middleware is used to parse incoming request bodies for particular
    content types. In fact, the `bodyParser` middleware specifically is just short
    hand for three different middlewares namely, `json`, `urlencoded`, and `multipart`.
    Each of these corresponds to a different content-type. Setting an absolute size
    via the limit middleware is helpful, but not always enough. Some request bodies
    should be limited differently than others.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may wish to allow file uploads that are up to 100 MB. However,
    that same amount of JSON will bring your application to a halt, while the `JSON.parse()`
    function runs, since it is a blocking operation. As a result, it is highly recommended
    to set a much smaller limit on request bodies other than multipart (since it deals
    with file uploads).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I would recommend avoiding the `bodyParser` middleware, in order
    to be more explicit, and allow you to set different limits for each of the sub-middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While setting different limits for different content types like we are talking
    about here, the results could be unexpected if you are not careful about the order
    you choose for your middleware.
  prefs: []
  type: TYPE_NORMAL
- en: If the limit middleware is used first, it will cause the other middlewares to
    ignore their own size limits. Make sure that you place the global limit middleware
    last, so it acts as a catch-all for any other content type, and not dealt with
    by the `bodyParser` middleware family.
  prefs: []
  type: TYPE_NORMAL
- en: Using streams instead of buffering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js includes a module called **streams**, which contains the implementation
    used widely throughout Node.js platform's own core modules. A stream is a lot
    like a Unix pipe, they can be read from, written to, or even both depending on
    the context. I won't go into great detail here, but streams are one of Node.js
    killer features, and you should be using them as much as possible in your applications
    and any npm modules you publish.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are implementing more of a RESTful API, that accepts a file upload as
    a `PUT` request, for example, use streams in your request handler. The following
    code shows an inefficient way to handle putting a request body into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are buffering the entire request body into memory, before writing it
    to disk. At small sizes, this is not a problem, but an attacker could simultaneously
    send many large request bodies, and you're putting yourself in unnecessary risk
    by buffering. In Node.js, with streams at your disposal, this is the long way
    to do it (thank goodness the shorter way is also the best way!).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of the same request, only using a stream to
    pipe the data to the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our example here sets up a writeable stream that represents the destination
    of the uploaded data. Rather than buffering the entire request body into memory,
    the data will simply be piped into that file, as it becomes available. It should
    be noted that this example does not properly filter the user input; this was entirely
    to stay focused on the topic of the example and should not be applied directly
    to production code.
  prefs: []
  type: TYPE_NORMAL
- en: Streams are a proven and effective pattern for dealing with data in numerous
    contexts, and leverage the event-driven model of Node.js to its full potential.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with many simultaneous users, especially with unforeseen bursts
    of traffic, it's important to be ready for disaster scenarios, where the load
    becomes too much for your server to handle. This is also applicable in mitigating
    **Denial of Service** (**DoS**) attacks that attempt to flood your server with
    more requests than it could ever possibly handle, bringing it down completely
    (or just slowing it down to a crawl) for every other user.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the event loop's responsiveness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a server that doesn't just melt under heavy load can be done. One useful
    pattern is to monitor the event loop's responsiveness, and deny some requests
    right away, if the server is just under too much load to respond quickly. One
    module out there, called node-toobusy ([https://github.com/lloyd/node-toobusy](https://github.com/lloyd/node-toobusy))
    does just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once initialized, toobusy polls the event loop, and watches for lag or requests
    to the event loop that takes longer than expected. In your application, you set
    up a middleware layer that simply queries the monitor to determine whether or
    not to add to the server''s current processing queue. If the server is too busy,
    it will respond with a **503**, (**Server Currently Unavailable**) rather than
    taking on more load that it is able to satisfy. Instead of crashing your server,
    this pattern allows you to continue serving as many requests as possible, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample was found on node toobusy's github page. It sets up a simple
    server with a middleware employing the toobusy module. It also sets up a single
    route that blocks the event loop by running for five straight seconds. If a number
    of simultaneous requests that block the event loop for long enough come in, the
    server will start responding with a **503 (Server Currently Unavailable)** error,
    rather than taking on more than it should. Lastly, this also includes a graceful
    shutdown for the process.
  prefs: []
  type: TYPE_NORMAL
- en: This example also demonstrates a very important point about the event loop in
    Node.js that is worth repeating. The contract made between your code and the event
    loop scheduler is that all code should execute quickly, to keep from blocking
    the event loop for other code. This means to avoid CPU-intensive calculations
    in your application code, unlike the preceding example, which blocks the CPU during
    its while-loop iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js works best when your application is primarily I/O-bound, so CPU-intensive
    operations, such as complex calculations or very large data-set iterations should
    be avoided. If your system requires such operations, consider spawning the blocking
    portions off as separate processes to keep from hogging your application's event
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple methods to accomplish this, such as using the HTML5 Web Worker
    API for node ([https://github.com/pgriess/node-webworker](https://github.com/pgriess/node-webworker)).
    In addition, a more bare-metal approach is to utilize Node's `child_process` module
    in conjunction with **Inter-Process Communication** (**IPC**).The IPC specifics
    on this are potentially heavily dependent on your platform and architecture, which
    is beyond the scope of this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site Request Forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-site Request Forgery** (**CSRF**) is an attack vector that exploits
    the trust, an application has for a specific user''s browser. A request is made
    on the user''s behalf without their consent, allowing the application to perform
    some action under the assumption that the trusted user initiated the request,
    even though they have not.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways this can be accomplished. One example is that an
    HTML image tag (for example, an `<img>`) somehow injected into the page, legitimately
    or not, such as via XSS, a vulnerability we will discuss in the next chapter.
    The browser implicitly sends a request to the URL specified in the `src` attribute,
    and sends any cookies it has as a part of the HTTP request. Many applications
    that track a user's identity do so via cookies that contains some sort of session
    identifier, which to the server makes it appear as though the user is making the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Prevention is pretty straightforward; the most common approach is requiring
    a generated, user-specific token to be included with each request that modifies
    state. In fact, Connect already includes the `csrf` middleware for just this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: It works by adding a generated token to the current user's session, which can
    be included in an HTML form, as a hidden input field or as a query-string value
    in any links with side-effects. When a later request is being handled, the middleware
    checks to ensure the value in the user's session, matches what was submitted with
    the request, which fails with a **403 (Forbidden)**, in the event of a mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example application has some defined middleware, namely the `bodyParser`,
    `cookieParser`, and `session`. These are all required by `csrf`, which is why
    they go first in the order. In addition, there are a few routes which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The homepage, which just provides links to both sample forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form action/target, which simply redirects the user home on a successful
    submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The valid form, which includes the token as a hidden input and successfully
    submits it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The invalid form, which does not include the token and consequently fails, when
    submitted (with a (**403 Forbidden)** HTTP response)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method prevents an attacker from successfully making false requests, as
    the required token will be different for each form submission.
  prefs: []
  type: TYPE_NORMAL
- en: Input validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While protecting against many attack vectors, such as XSS, which we will deal
    with in the next chapter, it is important to filter and sanitize your inputs as
    you receive them from the user. This occurs during the request phase of a web
    application, so we will address it here. The general rule of thumb is to always
    validate inputs and escape outputs.
  prefs: []
  type: TYPE_NORMAL
- en: A popular library for validating user input is node-validator ([https://github.com/chriso/node-validator](https://github.com/chriso/node-validator)).
    This library is by no means the only option, but it is the one we will be using
    in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: There are several goals of input validation, first of which is to verify that
    incoming user input matches the criteria of our application and its workflow;
    for example, you may want to ensure that a user submits a valid e-mail address.
    I am not referring to sending an e-mail for confirmation to test that the e-mail
    address is real, instead I am just talking about ensuring that they do not enter
    an erroneous value in the first place. Another example is to ensure that the number
    matches a particular range, such as being greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, input filtering is meant to prevent bad data from making it into your
    system that could compromise another subsystem; for example, if you accept an
    input for a certain numeric input, which you then pass along to another subsystem
    for some additional processing, such as a report or some other remote API. If
    your users, intentionally or not, submit some other unexpected value, like a symbol
    or an alphabetic character, it could cause problems in future operations. In large
    part, computers are garbage-in, garbage-out, so we need to make sure we are careful
    with any user input.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, as already mentioned briefly before, input filtering is a helpful (albeit
    incomplete) preventative measure against attacks like **Cross-Site Scripting**
    (**XSS**). XSS attacks in HTML, CSS, and JavaScript, there are big problems with
    access control, meaning that any script has the same access as every other one.
    This means that if an attacker can find a way to inject further code into your
    page, they will have a great degree of control, which is potentially harmful to
    your users. Input filtering can help by removing malicious code that may be cleverly
    embedded in other user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the base node-validator library, there is also a middleware
    plugin (express-validator: [https://github.com/ctavan/express-validator](https://github.com/ctavan/express-validator)),
    made especially for Express.js, which we will be using for our examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example will be a form that accepts a large variety of inputs, just
    to help demonstrate as much as possible. Consider the following HTML form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This sample code sets up an HTML form with five fields: `name`, `e-mail`, `website`,
    `age`, and `gender`. A user can enter values in the provided inputs and `POST`
    to the same URL. While processing the `POST` request, we will validate the data
    and give some sort of response. The next code sample will be our application code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This example sets up a basic web server with only two routes, a `GET /` which
    just sends the HTML form, we showed earlier as the response. The second route
    is a `POST /` which takes the data submitted from the aforementioned form, and
    first validates it with the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Rules |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | This field cannot be empty.It must match a regular expression (this
    one means it must be only alphabetic, numeric, whitespace, and a few select symbols).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `e-mail` | This must be a valid e-mail address. |'
  prefs: []
  type: TYPE_TB
- en: '| `website` | This must be a valid URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `age` | This must be a number.It must be greater than or equal to 0.It must
    be less than or equal to 100. |'
  prefs: []
  type: TYPE_TB
- en: '| `gender` | This must be either "M" or "F". |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to validating the input, it also performs some filtering and transforming
    before the output, according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Rule |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Trim leading and trailing whitespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `e-mail` | Trim leading and trailing whitespace. |'
  prefs: []
  type: TYPE_TB
- en: '| `age` | Convert to an integer. |'
  prefs: []
  type: TYPE_TB
- en: Depending on how the validation goes, it will either respond with a **403 (Forbidden)**,
    with the list of validation errors, or it will respond with a **200 (OK)** with
    the filtered input.
  prefs: []
  type: TYPE_NORMAL
- en: This should demonstrate that it is pretty straightforward to add input validation
    and filtering to your applications, and the rewards are well worthwhile. You can
    ensure that the data matches expected formats for your various workflows, and
    help preemptively protect against some attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we specifically examined request vulnerabilities, and provided
    some ways to avoid and deal with those vulnerabilities. In the next chapter, we
    will look at the response phase of applications, and the vulnerabilities that
    appear there.
  prefs: []
  type: TYPE_NORMAL
