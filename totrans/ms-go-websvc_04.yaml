- en: Chapter 4. Designing APIs in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now barreled through the basics of REST, handling URL routing, and multiplexing
    in Go, either directly or through a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, creating the skeleton of our API has been useful and informative,
    but we need to fill in some major blanks if we're going to design a functioning
    REST-compliant web service. Primarily, we need to handle versions, all endpoints,
    and the `OPTIONS` headers as well as multiple formats in an elegant, easy way
    that can be managed going forward.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to flesh out the endpoints we want to lay out for an API-based application
    that allows clients to get all of the information they need about our application
    as well as create and update users, with valuable error information relating to
    both the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should also be able to switch between REST and
    WebSocket applications as we'll build a very simple WebSocket example with a built-in
    client-side testing interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Outlining and designing our complete social network API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling code organization and the basics of API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing multiple formats (XML and JSON) for our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closer look at WebSockets and implementing them in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating more robust and descriptive error reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating user records via the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you should be able to elegantly handle multiple
    formats and versions of your REST Web Services and have a better understanding
    of utilizing WebSockets within Go.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our social network API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've gotten our feet wet a bit by making Go output data in our web
    service, one important step to take now is to fully flesh out what we want our
    major project's API to do.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application is a social network, we need to focus not only on user
    information but also on connections and messaging. We'll need to make sure that
    new users can share information with certain groups, make and modify connections,
    and handle authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let''s scope out our following potential API endpoints,
    so that we can continue to build our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoints | Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/users` | `GET` | Return a list of users with optional parameters |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/users` | `POST` | Create a user |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/XXX` | `PUT` | Update a user''s information |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/users/XXX` | `DELETE` | Delete a user |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/connections` | `GET` | Return a list of connections based on users
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/connections` | `POST` | Create a connection between users |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/connections/XXX` | `PUT` | Modify a connection |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/connections/XXX` | `DELETE` | Remove a connection between users |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/statuses` | `GET` | Get a list of statuses |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/statuses` | `POST` | Create a status |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/statuses/XXX` | `PUT` | Update a status |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/statuses/XXX` | `DELETE` | Delete a status |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/comments` | `GET` | Get list of comments |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/comments` | `POST` | Create a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/comments/XXX` | `PUT` | Update a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/comments/XXX` | `DELETE` | Delete a comment |'
  prefs: []
  type: TYPE_TB
- en: In this case, any place where `XXX` exists is where we'll supply a unique identifier
    as part of the URL endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we've moved to all plural endpoints. This is largely a matter
    of preference and a lot of APIs use both (or only singular endpoints). The advantages
    of pluralized endpoints relate to consistency in the naming structure, which allows
    developers to have predictable calls. Using singular endpoints work as a shorthand
    way to express that the API call will only address a single record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these endpoints reflects a potential interaction with a data point.
    There is another set of endpoints that we''ll include as well that don''t reflect
    interaction with our data, but rather they allow our API clients to authenticate
    through OAuth:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Endpoint | Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/oauth/authorize` | `GET` | Returns a list of users with optional parameters
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/oauth/token` | `POST` | Creates a user |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/oauth/revoke` | `PUT` | Updates a user''s information |'
  prefs: []
  type: TYPE_TB
- en: If you're unfamiliar with OAuth, don't worry about it for now as we'll dig in
    a bit deeper later on when we introduce authentication methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**OAuth**, short for **Open Authentication**, was born from a need to create
    a system for authenticating users with OpenID, which is a decentralized identity
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: By the time OAuth2 came about, the system had been largely retooled to be more
    secure as well as focus less on specific integrations. Many APIs today rely on
    and require OAuth to access and make changes on behalf of users via a third party.
  prefs: []
  type: TYPE_NORMAL
- en: The entire specification document (RFC6749) from the Internet Engineering Task
    Force can be found at [http://tools.ietf.org/html/rfc6749](http://tools.ietf.org/html/rfc6749).
  prefs: []
  type: TYPE_NORMAL
- en: The endpoints mentioned earlier represent everything that we'll need to build
    a minimalistic social network that operates entirely on a web service. We will
    be building a basic interface for this too, but primarily, we're focusing on building,
    testing, and tuning our application at the web service level.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that we won't address here is the `PATCH` requests, which as we mentioned
    in the previous chapter, refer to partial updates of data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will augment our web service to allow the `PATCH` updates,
    and we'll outline all our endpoints as part of our `OPTIONS` response.
  prefs: []
  type: TYPE_NORMAL
- en: Handling our API versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any amount of time dealing with web services and APIs across the
    Internet, you'll discover a great amount of variation as to how various services
    handle their API versions.
  prefs: []
  type: TYPE_NORMAL
- en: Not all of these methods are particularly intuitive and often they break forward
    and backward compatibility. You should aim to avoid this in the simplest way possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an API that, by default, uses versioning as part of the URI: `/api/v1.1/users`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will find this to be pretty common; for example, this is the way Twitter
    handles API requests.
  prefs: []
  type: TYPE_NORMAL
- en: There are some pluses and minuses to this approach, so you should consider the
    potential downsides for your URI methodology.
  prefs: []
  type: TYPE_NORMAL
- en: With API versions being explicitly defined, there is no default version, which
    means that users always have the version they've asked for. The good part of this
    is that you won't necessarily break anyone's API by upgrading. The bad part is
    that users may not know which version is the latest without checking explicitly
    or validating descriptive API messages.
  prefs: []
  type: TYPE_NORMAL
- en: As you may know, Go doesn't allow conditional imports. Although this is a design
    decision that enables tools such as `go fmt` and `go fix` to work quickly and
    elegantly, it can sometimes hamper application design.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, something like this is not directly possible in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can improvise around this a bit though. Let''s assume that our application
    structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then import each as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, also means that we need to use these in our application, otherwise
    Go will trigger a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of maintaining multiple versions can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The unfortunate reality of this design decision is that your application will
    break one of programming cardinal rules: *don''t duplicate code*.'
  prefs: []
  type: TYPE_NORMAL
- en: This isn't a hard and fast rule of course, but duplicating code leads to functionality
    creep, fragmentation, and other headaches. As long as we make primary methods
    to do the same things across versions, we can mitigate these problems to some
    degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, each of our API versions will import our standard API serving-and-routing
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And, of course, our v2 version will look nearly identical to a different version.
    Essentially, we use these as wrappers that bring in our important shared data
    such as database connections, data marshaling, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we could put a couple of our essential variables and functions
    into our `api.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If this looks familiar, this is because it's the core of what we had in our
    first attempt at the API from the last chapter, with a few of the routes stripped
    for space here.
  prefs: []
  type: TYPE_NORMAL
- en: Now is also a good time to mention an intriguing third-party package for handling
    JSON-based REST APIs—**JSON API Server** (**JAS**). JAS sits on top of HTTP (like
    our API) but automates a lot of the routing by directing requests to resources
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON API Server or JAS allows a simple set of JSON-specific API tools on top
    of the HTTP package to augment your web service with minimal impact.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about this at [https://github.com/coocood/jas](https://github.com/coocood/jas).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install it via Go by using this command: `go get github.com/coocood/jas`.
    Delivering our API in multiple formats'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it makes sense to formalize the way we approach multiple formats.
    In this case, we're dealing with JSON, RSS, and generic text.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get to generic text in the next chapter when we talk about templates,
    but for now, we need to be able to separate our JSON and RSS responses.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to do this is to treat any of our resources as an interface
    and then negotiate marshaling of the data based on a request parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some APIs define the format directly in the URI. We can also do this fairly
    easily (as shown in the following example) within our mux routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will allow us to extract the requested format directly from
    URL parameters. However, this is also a bit of a touchy point when it comes to
    REST and URIs. And though it's one with some debate on either side, for our purpose,
    we'll use the format simply as a query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `api.go` file, we''ll need to create a global variable called `Format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And a function that we can use to ascertain the format for each respective
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We'll call this with each request. Although the preceding option automatically
    restricts to JSON, XML, or text, we can build it into the application logic as
    well and include a fallback to `Format` if it doesn't match the acceptable options.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a generic `SetFormat` function to marshal data based on the currently
    requested data format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Within any of our endpoint functions, we can return any data resource that
    is passed as an interface to `SetFormat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to remove the marshaling from the response function(s). Now that
    we have a pretty firm grasp of marshaling our data into XML and JSON, let's revisit
    another protocol for serving a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent WebSockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the previous chapter, a WebSocket is a method to keep an open
    connection between the client and the server, which is typically meant to replace
    multiple HTTP calls from a browser to a client, but also between two servers that
    may need to stay in a semi-reliable constant connection.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of using WebSockets for your API are reduced latency for the
    client and server and a generally less complex architecture for building a client-side
    solution for long-polling applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To outline the advantages, consider the following two representations; the
    first of the standard HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concurrent WebSockets](img/1304OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now compare this with the more streamlined WebSocket request over TCP, which
    eliminates the overhead of multiple handshakes and state control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concurrent WebSockets](img/1304OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how traditional HTTP presents levels of redundancy and latency that
    can hamper a long-lived application.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, it's only HTTP 1 that has this problem in a strict sense. HTTP 1.1
    introduced keep-alives or persistence in a connection. And while that worked on
    the protocol side, most nonconcurrent web servers would struggle with resource
    allocation. Apache, for example, by default left keep-alive timeouts very low
    because long-lived connections would tie up threads and prevent future requests
    from completing in a reasonable manner of time.
  prefs: []
  type: TYPE_NORMAL
- en: The present and future of HTTP offers some alternatives to WebSockets, namely
    some big options that have been brought to the table by the SPDY protocol, which
    was developed primarily by Google.
  prefs: []
  type: TYPE_NORMAL
- en: While HTTP 2.0 and SPDY offer concepts of multiplexing connections without closing
    them, particularly in the HTTP pipelining methodology, there is no wide-ranging
    client-side support for them yet. For the time being, if we approach an API from
    a web client, WebSockets provide far more client-side predictability.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that SPDY support across web servers and load balancers is
    still largely experimental. Caveat emptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'While REST remains our primary target for our API and demonstrations, you''ll
    find a very simple WebSocket example in the following code that accepts a message
    and returns the length of that message along the wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the loop here; it's essential to keep this loop running within the `EchoLengthServer`
    function, otherwise your WebSocket connection will close immediately on the client
    side, preventing future messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our primary socket router. We''re listening on port `12345` and evaluating
    the incoming message''s length and then returning it. Note that we essentially
    *cast* the `http` handler to a `websocket` handler. This is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This last piece, in addition to instantiating the WebSocket portion, also serves
    a flat file. Due to some cross-domain policy issues, it can be cumbersome to test
    client-side access and functionality of a WebSocket example unless the two are
    running on the same domain and port.
  prefs: []
  type: TYPE_NORMAL
- en: To manage cross-domain requests, a protocol handshake must be initiated. This
    is beyond the scope of the demonstration, but if you choose to pursue it, know
    that this particularly package does provide the functionality with a `serverHandshaker`
    interface that references the `ReadHandshake` and `AcceptHandshake` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source for handshake mechanisms of `websocket.go` can be found at [https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net](https://code.google.com/p/go/source/browse/websocket/websocket.go?repo=net).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a wholly WebSocket-based presentation at the `/length` endpoint,
    if you attempt to reach it via HTTP, you''ll get a standard error, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concurrent WebSockets](img/1304OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence, the flat file will be returned to the same domain and port. In the preceding
    code, we simply include jQuery and the built-in WebSocket support that exists
    in the following browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chrome**: Version 21 and higher versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safari**: Version 6 and higher versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firefox**: Version 21 and higher versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IE**: Version 10 and higher versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opera**: Versions 22 and higher versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern Android and iOS browsers also handle WebSockets now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for connecting to the WebSocket-side of the server and testing some
    messages is as follows. Note that we don''t test for WebSocket support here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code returns the message that we get from the WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we visit the `/websocket` URL in our browser, we''ll get the text area
    that allows us to send messages from the client side to the WebSocket server,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Concurrent WebSockets](img/1304OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Separating our API logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the section on versioning earlier, the best way for us to
    achieve consistency across versions and formats is to keep our API logic separate
    from our overall version and delivery components.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen a bit of this in our `GetFormat()` and `SetFormat()` functions, which
    span all the endpoints and versions.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding our error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we briefly touched on sending error messages via our HTTP
    status codes. In this case, we passed along a 409 status conflict when a client
    attempted to create a user with an e-mail address that already existed in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `http` package provides a noncomprehensive set of status codes that you
    can use for standard HTTP issues as well as REST-specific messages. The codes
    are noncomprehensive because there are some additional messages that go along
    with some of these codes, but the following list satisfies the RFC 2616 proposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Error | Number |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusContinue` | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusSwitchingProtocols` | 101 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusOK` | 200 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusCreated` | 201 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusAccepted` | 202 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNonAuthoritativeInfo` | 203 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNoContent` | 204 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusResetContent` | 205 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusPartialContent` | 206 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusMultipleChoices` | 300 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusMovedPermanently` | 301 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusFound` | 302 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusSeeOther` | 303 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNotModified` | 304 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusUseProxy` | 305 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusTemporaryRedirect` | 307 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusBadRequest` | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusUnauthorized` | 401 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusPaymentRequired` | 402 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusForbidden` | 403 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNotFound` | 404 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusMethodNotAllowed` | 405 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNotAcceptable` | 406 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusProxyAuthRequired` | 407 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusRequestTimeout` | 408 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusConflict` | 409 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusGone` | 410 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusLengthRequired` | 411 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusPreconditionFailed` | 412 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusRequestEntityTooLarge` | 413 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusRequestURITooLong` | 414 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusUnsupportedMediaType` | 415 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusRequestedRangeNotSatisfiable` | 416 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusExpectationFailed` | 417 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusTeapot` | 418 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusInternalServerError` | 500 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusNotImplemented` | 501 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusBadGateway` | 502 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusServiceUnavailable` | 503 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusGatewayTimeout` | 504 |'
  prefs: []
  type: TYPE_TB
- en: '| `StatusHTTPVersionNotSupported` | 505 |'
  prefs: []
  type: TYPE_TB
- en: 'You may recall that we hard coded this error message before; our error-handling
    should still be kept above the context of API versions. For example, in our `api.go`
    file, we had a switch control in our `ErrorMessage` function that explicitly defined
    our 409 HTTP status code error. We can augment this with constants and global
    variables that are defined in the `http` package itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall that this does some translation of errors in other components
    of the application; in this case 1062 was a MySQL error. We can also directly
    and automatically implement the HTTP status codes here as a default in the switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Updating our users via the web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have an ability here to present another point of potential error when we
    allow users to be updated via the web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll add an endpoint to the /`api/users/XXX` endpoint by adding
    a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And in our `UsersUpdate` function, we'll first check to see if the said user
    ID exists. If it does not exist, we'll return a 404 error (a document not found
    error), which is the closest approximation of a resource record not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user does exist, we''ll attempt to update their e-mail ID through a
    query; if that fails, we''ll return the conflict message (or another error). If
    it does not fail, we''ll return 200 and a success message in JSON. Here''s the
    beginning of the `UserUpdates` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We'll expand on this a bit, but for now, we can create a user, return a list
    of users, and update users' e-mail addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While working with APIs, now is a good time to mention two browser-based tools:
    **Postman** and **Poster**, that let you work directly with REST endpoints from
    within a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Postman in Chrome, go to [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Poster in Firefox, go to [https://addons.mozilla.org/en-US/firefox/addon/poster/](https://addons.mozilla.org/en-US/firefox/addon/poster/).
  prefs: []
  type: TYPE_NORMAL
- en: Both tools do essentially the same thing; they allow you to interface with an
    API directly without having to develop a specific HTML or script-based tool or
    using cURL directly from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, we have the guts of our social networking web service
    scoped out and ready to fill in. We've shown you how to create and outlined how
    to update our users as well as return valuable error information when we cannot
    update our users.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has dedicated a lot of time to the infrastructure—the formats and
    endpoints—of such an application. On the former, we looked at XML and JSON primarily,
    but in the next chapter, we'll explore templates so that you can return data in
    any arbitrary format in which you deem necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also delve into authentication, either via OAuth or a simple HTTP basic
    authentication, which will allow our clients to connect securely to our web service
    and make requests that protect sensitive data. To do this, we'll also lock our
    application down to HTTPS for some of our requests.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we'll focus on a REST aspect that we've only touched on briefly—outlining
    our web service's behavior via the `OPTIONS HTTP` verb. Finally, we'll look more
    closely at the way headers can be used to approximate state on both the server
    and receiving end of a web service.
  prefs: []
  type: TYPE_NORMAL
