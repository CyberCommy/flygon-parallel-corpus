- en: Vulnerability Scanner Python - Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: kWhen we talk of port scanning, the tool that automatically comes to mind is
    Nmap. Nmap has a good reputation and it is arguably the best open source port
    scanner available. It has tons of features that allow you to carry out a wide
    variety of scans over the network to discover what hosts are alive, what ports
    are open, and also which services and service versions are running on the host.
    It also has an engine (the Nmap scanning engine) that can scan NSE scripts, that
    is used to discover common vulnerabilities with the running services. In this
    chapter, we will make use of Python in order to automate the process of port scanning.
    This chapter will form the basis for our automated vulnerability scanner, and
    will supplement the subsequent chapter, which will focus on automating service
    scanning and enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a network scanner with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our  port scanner will be made on top of Nmap, with additional features and
    capabilities, such as parallel port scanning a target and pausing and resuming
    a scan. It will also have a web GUI that we can use to conduct our scans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the various properties of Nmap:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the different scan techniques that are available
    with Nmap:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bc202233-ec7a-4cf2-9f45-f460cbf1989f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows host discovery and port specification, along
    with some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6d0cc2a1-1a99-4b91-a955-7c716b98e2b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows service and version detection and OS detection,
    along with some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0916b622-58df-43d6-8352-47abde235a89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the timing and performance, along with some
    examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2c977b22-4f6f-4759-a377-2f524a871ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows NSE scripts, along with some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/65ff3c58-e849-4150-adf9-d23d42e34175.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows Firewall/IDS evasion and spoofing, along with
    some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/73d765cb-3e08-4f16-8897-5b8e5440adb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows some helpful Nmap output examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d133fd74-18da-4b31-931c-965053f0e6fb.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshots provide a comprehensive list of the Nmap commands
    that we frequently use in our day-to-day operations. We will not be covering how
    to run Nmap commands on the Terminal, as it is assumed that this is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, from now on, we will be using Kali Linux as our pen-test
    lab OS. All the Python automation that we will see will therefore be implemented
    on the Kali Linux box. To install a Kali Linux VM/VirtualBox image, please refer
    to [https://www.osboxes.org/Kali-linux/](https://www.osboxes.org/Kali-linux/).
    To download VirtualBox, refer to [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    Once downloaded, perform the steps shown in the following screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, enter a Name for the new virtual machine along with the Type and Version;
    in our case, this is Linux and Debian (64-bit). After that, allocate the memory
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8660a60c-33a3-4bbd-a4ae-89f264016990.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, choose the virtual hard disk file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb56c950-1a2e-40aa-b206-c3316e593f3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a network scanner with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are all set up with our VirtualBox image, let''s have a look at
    a simple Python script that will help us to call Nmap and initiate a scan. Later
    on, we will optimize this script to make it better. We will finish by making it
    a full-fledged port scanning Python engine with pause, resume, and multiprocessing
    abilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f39d287f-fe41-46e2-9472-e1905e658275.png)'
  prefs: []
  type: TYPE_IMG
- en: The information produced by the preceding script is hard for the Python code
    to filter and store. If we want to store all the open ports and services in a
    dictionary, it would be hard to do that with the preceding method. Let's think
    about another way in which the information produced can be parsed and processed
    by the script. We know that the `oX` flag is used to produce output in XML format.
    We will use the `oX` flag to convert the XML string to a Python dictionary as
    shown in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Nmap output with the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following example, we reused the same concepts that we studied earlier.
    We redirected the Nmap output in XML format to the screen. We then collected the
    output produced as a string and used the `import xml.Etree.elementTree` Python
    module as `ET` in order to convert the XML output to Python dictionaries. Using
    the following code, we can control Nmap using our program and filter out all the
    useful information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/642b97d5-7cb5-4089-aaa2-186d75977dbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then store that information in database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18f9a7f3-34e3-4fe4-a586-cca99832a8a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although the preceding method is good, and gives us granular control over Nmap
    output, it involves processing and parsing code that we may not want to write
    every time we conduct a scan with Nmap. An alternative and better approach is
    to use Python's built-in Nmap wrapper module. We can install Python's Nmap module
    with `pip install`, and it does pretty much the same as what we did before, but
    allows us to avoid writing all the processing and subprocessing logic. It keeps
    the code clean and more readable. Whenever we wish to have more granular control,
    we can always fall back to the preceding approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Nmap module to conduct Nmap port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now go ahead and install the Python Nmap module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will install the `Nmap` utility. The following section
    provides an overview as to how the library can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This gives a quick start to an excellent utility written by Alexandre Norman.
    More details of this module can be found at [https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-nmap/).
    We will be using the same module in order to conduct parallel port scanning with
    Nmap with the additional capabilities of pausing and resuming the scans.
  prefs: []
  type: TYPE_NORMAL
- en: Objective and architectural overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into granular code details, its important for us to understand
    what are we doing and why are we doing it. Nmap, by default, is very powerful
    and has tons of capabilities. In a typical network pen test using OS tools, the
    methodology adapted is to employ Nmap for port scanning to get open ports, the
    services running, and the service versions. Based on the port scanning results,
    a tester usually uses various service scanning scripts to get the service versions
    and the CVE IDs associated (if there are any) and then, in turn, based on these,
    a tester can use Metasploit to exploit the vulnerabilities. For service scanning,
    a tester uses various open source technologies, such as NSE, Ruby, Python, Java,
    bash scripts, or tools such as Metasploit, w3af, nikto, Wireshark, and so on.
    The whole cycle forms a process that needs to be followed every time, but it is
    very disintegrated. The idea we are trying to present here is that, in the following
    section, we will orchestrate all the activities a pen tester needs to perform
    and automate all of them with the help of Python, such that all the tools and
    scripts required to be run can be preconfigured and run all in one go. Not only
    are we just orchestrating and automating the activities, but we are also making
    the code optimized to make use of multiprocessing and multithreading to reduce
    the scan time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the code can be bifurcated into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning (service/port discovery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The port scanning part refers to how we are going to implement it in our Python
    code. The idea is to use a combination of threading and multiprocessing. If we
    want 10 hosts to be scanned, we will break it into 5 batches. Each batch has two
    hosts (the batch size can be increased depending upon the RAM and processor capabilities
    of your lab machine). For a four-core processor and 2 GB RAM, the batch size should
    be 2. At any one time, we will process one batch and dedicate a single thread
    to each host. For this reason, two threads will be running in parallel to scan
    two hosts. Once a host is dedicated to a thread, the thread will pick the port
    range for that host to be scanned (let''s say it''s between 1 and 65535). Instead
    of scanning the ports sequentially, the logic is to break the whole range into
    three chunks, each of a size of 21,845\. Now, the three chunks of a single host
    are scanned in parallel. If the number of processor cores is higher, the chunk
    size can be increased. For a four-core processor and 2 GB RAM, three chunks are
    recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43439e13-237b-41cd-9532-19de6878b022.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, hosts are broken into batches with a batch size of 2 and are dedicated
    to a single host. Further ports are broken into chunks and a multiprocessing process
    is dedicated to scan each chunk such that port scanning happens in parallel. Thus,
    at any one time, two threads and six processes will be running for a port scanning
    activity. If the user wants to pause the scan, they can use *Ctrl* + *C *at the
    Terminal window to pause. When they rerun the code, they will be prompted with
    the option of launching a new scan or resuming an earlier paused scan.
  prefs: []
  type: TYPE_NORMAL
- en: Service scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the port scanning activity is over, we save all the results in our MySQL
    database table. Depending on the service discovered, we have a configured list
    of scripts that we need to execute if a specific service is found. We use a JSON
    file to map the service and the corresponding scripts to execute. A user is prompted
    with the port scanning results and is given the option to reconfigure or change
    the results if needed, to reduce false positives. Once the final configuration
    is set, service scanning is started. We pick one host at a time from the database
    and, based on the services discovered, read the appropriate scripts from the JSON
    file, execute them for this particular host, and save the results in the database.
    This continues until all the hosts are scanned for their services. Finally, an
    HTML report is produced that contains the formatted results and screenshots to
    attach to **proof of concept (POC)** reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an architectural diagram of service scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d773d881-a6d1-49a6-8553-07c81a5aed82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot depicts how the JSON file is configured to execute
    the scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c8f1abe-7e5b-4057-a877-13af911e8717.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen in the preceding screenshot, there are various categories of
    commands that are placed in the JSON file. The Metasploit template shows the commands
    that are used to execute the Metasploit modules. Single-line commands are used
    to execute NSE scripts and all modules or scripts that are not interactive. The
    other categories include `interactive_commands` and `single_line_sniffing`, which
    is where we need to sniff the traffic along with executing the scripts. The general
    template of the JSON file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/705fd705-0c7b-48aa-b505-cf34c0fb0b9d.png)'
  prefs: []
  type: TYPE_IMG
- en: The key is the name of the service. The title has the file description. The `method_id`
    is the actual Python method that should be invoked to call the external script
    that is to be executed. Note that for single-line commands, we also specify a
    timeout parameter in seconds as the first argument under the `args` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an overview of the essential files and methods that we
    will use to build our network scanner using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Driver_main_class.py`: This is the Python class, file, or module that prompts
    the user for input information such as the project name, the IP addresses to scan,
    the port range to scan, the scan switch to use, and the scan type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main_class_based_backup.py`: This is the Python class, file, or module that
    contains all the main logic for port scanning that we discussed previously. It
    takes an input from `Driver_main_class.py` and stores the input in the database.
    Finally, it starts port scanning on our targets using threading and multiprocessing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Driver_scanner.py`: After port scanning is over, the next step is to perform
    service scanning and this Python class invokes another class, `driver_meta.py`,
    which takes the project name or ID for which service scanning is to be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_meta.py`: This class displays the default result of the port scanning
    and gives the user the option to reconfigure the results if needed. After reconfiguration,
    this class reads the hosts from the database table for the current project for
    which service scanning is to be done. For each host, it then reads the JSON file
    to get the commands to be executed, and for each command to be executed, it passes
    on the control to another file, `auto_comamnds.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto_commands.py`: This is the file that takes arguments from `driver_meta.py`
    and calls the external technologies such as NSE, Ruby, Python, Java, bash scripts,
    or tools such as Metasploit, Wireshark, and Nikto. These are then used to perform
    service scanning for a chosen service, host, and port. After the command execution
    is over, it returns the results to `driver_meta.py` to be saved in the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPtable.py`: This is the class that stores the port scanning results in the
    database table. It represents the data layer of our vulnerability scanner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPexploits.py`: This is the class that stores the service scanning results
    in the database table. It also represents the data layer of our vulnerability
    scanner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The whole code base can be found at the following GitHub repository. The installation
    instructions are specified on the home page. We will take a look at the sections
    of the code and that files that have the central logic to implement the scanner.
    Feel free to download the code from the repository and execute it as specified
    in the execution section. Alternatively, I have created a plug and play Kali VM
    image, which has got all the prerequisite installations and the code base out
    of the box. This can be downloaded and executed hassle-free from the URL [<https://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing>](http://%3Chttps://drive.google.com/file/d/1e0Wwc1r_7XtL0uCLJXeLstMgJR68wNLF/view?usp=sharing%3E).
    The default username is: `PTO_root` and the password is: `PTO_root`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we will be discussing the central logic of the code,
    which is represented by the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/906ee2de-700c-48dc-aa75-c98131399c4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The whole class can be found at the URL [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/Driver_main_class.py%3E)
    for `Driver_main_class.py`. The constructor of the class declares an object for
    the `NmapScan` class found in `main_class_based_backup.py`. The lines highlighted
    as **(1)** and **(2)** are the places where the actual logic is triggered after
    collecting all inputs, including the project name, the IPs, the port range, the
    scan switch and the scan type. Scan type 1 signifies a new scan, while scan type
    2 signifies resuming an existing scan, which would have been paused earlier. The
    `self.scanbanner()` method prompts the user to enter the Nmap scan switch that
    the user wishes to use. There are seven switch types that are most frequently
    used in day-to-day scans. The following screenshot shows the configuration file, `Nmap.cfg`,
    that has the scan switches configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db825a7f-52ec-40d7-a2d2-76923a5600b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet represents the flow of the `main_class_based_backup.py` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f7219c0-f153-451e-aa10-0381f5441da9.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot represents the main `NmapScan` class. The constructor of the
    class contains various variables that we will be using throughout the execution
    flow of the class. As mentioned earlier, `IPtable` is a python class that is written
    to push the data in the backend database. The structure of the database will be
    discussed in the `db_structure` section. For now, we should understand that by
    using the MySQLdb db connector / Python module, we will push all the port scanning
    details in the backend tables via the `IPtable` class. Furthermore, `textable`
    is a Python module that is used to draw tables on the Terminal windows to represent
    data. `Simple_Logger` is a Python module that is required to log the debug and
    error messages in files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw previously, when we looked at `Driver_main_class.py`, the actual
    execution flow starts with the `driver_main` method of the `NmapScan` class (highlighted
    in code snippets **(1)** and **(2)** of the `Driver_main_class.py` class). The
    following screenshot shows this method in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bfc3fe2-0ae7-4311-9419-1ed0006c3c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code snippet is straightforward. The method receives all the
    arguments from the caller. We save the start time of the scan in a variable called start.
    The highlighted code snippet **(1)** invokes another `main` method of the same
    class and passes all the received parameters to it. This is the method where the
    port scanning for all the hosts is initiated. Once the invoked `self.main` method finishes
    its execution, as highlighted by code snippet (2), we need to check whether all
    the hosts were successfully scanned. This can be deduced from a backhand table,
    which maintains a `status_code` for all the hosts that are being scanned, referenced
    by the current project ID. If the hosts are successfully scanned, the status would
    be complete, otherwise it would be processing or incomplete. If the current project
    is not under the paused status and there are still a few hosts that have a status
    of incomplete or processing, we need to process those hosts again, which is something
    that is highlighted by code snippet (3). If the processing status is complete
    for all the hosts, we update the final project status as complete, as specified
    by the `self.IPtable.clearLogs` method. Finally, we display the execution time
    in seconds. In the next code snippet, we will take a look at the main method of
    the `NmapScan` class, which gets things running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e985decc-f655-423b-a6ae-6099dce2091b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `main` method begins by checking the `scan_type`. It must be noted that
    `scan_type ="1"` means a new scan and `scan_type="2"` stands for resuming an earlier
    paused scan. The code also checks the scan mode. Note that c stands for command-line
    mode. The vulnerability scanner we are making operates in both GUI mode, which
    we will discuss later, and command-line mode. We can ignore the `g-init` and `g-start` modes
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line 6, the code stores the current project name in the backend database.
    The logic of the code is handled by the `self.db_projectname` method. The method
    takes the project name, stores it in a database table, returns a unique project
    ID, and stores it in class variable called `self.CURRENT_PROJECT_ID`. It also
    creates a folder called `Results_project_id` under the `Results` folder, which
    lies under the root of the parent project folder. The complete details of the
    method can be found at the following path: [<https://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py>](http://%3Chttps://github.com/FurqanKhan1/Dictator/blob/master/Dictator_service/main_class_based_backup.py%3E).'
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet highlighted as **(2)** invokes a method called `self.numofips(targethosts)`,
    which returns the length of the hosts to be scanned. If there are multiple hosts,
    they are expected to be inputted as either comma-separated (such as `192.168.250.143`,
    `192.168.250.144`) or in CIDR notation (such as `192.168.250.140/16`). If they
    are comma-separated, then `targethosts.split(',')` will split the input and return
    the list of IPs to the `listip `variable. If the notation is CIDR, code snippet
    **(3)** will translate the CIDR IP list into a native Python list of IPs and return
    the result, which will again be stored in the `listip `variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code snippet highlighted as **(4)** is responsible for breaking the ports
    into small chunks and storing them in the database against the current project
    ID, as we discussed previously. Let''s assume that we have two hosts to scan,
    `192.168.250.143` and `192.168.250.136`, and we want to scan the entire port range
    (from 1 to 65,535) for the hosts. In this case, the invocation of method would
    be `self.makeBulkEntries([192.168.250.143,192.168.250.136], "1-65535")`. The method
    processes the input and converts it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[192.168.250.143,"1-21845"],[192.168.250.143,"21845-43690"],[192.168.250.143,"43690-65535"],[192.168.250.144,"1-21845"],[192.168.250.144,"21845-43690"],[192.168.250.144,"43690-65535"]].`'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list is inserted in the database table as six rows, each having
    a scan status of incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, `threading.enumurate()` returns the current number of running
    threads. It should return us a value of 1, as just the main thread is running.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet highlighted as **(5)** calls the `startProcessing` method.
    This is the method that reads a batch of distinct hosts from the backend database
    table, where the status is incomplete. It further allocates a thread to scan these
    hosts. It must be noted that `self.N` signifies the batch size, which we have
    already discussed is 2, and is initialized in constructor of class. We can increase
    the number for a higher processor count.
  prefs: []
  type: TYPE_NORMAL
- en: While the `startProcessing` method spawns threads and allocates one thread per
    unscanned host, there has to be some logic that checks when the host is scanned
    completely, such that if batch size is `2`, and 1 host is scanned, it pulls out
    another unscanned host and allocates a thread to it. The method is also required
    to check whether all the hosts are completely scanned. If this is the case, the
    scan must end. This piece of logic is handled by the `start_Polling()` method,
    as shown in the code snippet marked as **(6)**.
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet highlighted as **(7)** will invoke a method that will resume
    paused scans. It will therefore load all the project IDs of the scans that have
    a paused status. A user can select any valid project ID to resume the scan.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, snippet **(8)** mentions` Start_Polling()`, which has the same function
    as discussed previously, but in this case for scans that are resumed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `startProcessing()` method shown in the following snippet simply pulls
    all the different hosts from the database table where the status is incomplete and
    places them in the native Python list `All_hosts`. For the current example, it
    will return the following list: [`192.168.250.143`, `192.168.250.144`].  After
    that, the snippet highlighted as (1) will invoke the `startThreads `method, where
    one thread will be allocated to a host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c9a7de3-73d9-40fe-b127-81948237195c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `startThreads()` method is straightforward. We iterate over the list hosts
    and allocate a thread to each host, by invoking the `obj.simplescanner` method and
    passing the current IP list to it. The `simplescanner `method will be invoked
    two times for our current example. First, it will be invoked for Thread 1, which
    has an IP address of `192.168.250.143` and then it will be invoked for Thread
    2, which has an IP address of `192.168.250.144`. This is highlighted by snippet
    **(1)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `simpleScanner()` method is also straightforward and uses the concept of
    multiprocessing that we studied earlier. First, it  reads all the records or port
    chunks for the current host for which it is invoked. For example, when its invoked
    against host `192.168.250.143`, it reads the database rows [`[192.168.250.143,"1-21845"],
    [192.168.250.143,"21845-43690"], and [192.168.250.143,"43690-65535"]`]. After
    that, it will update the status for all of them and mark them as: processing,
    as we are about to dedicate processes that would process the port chunks. Finally,
    we iterate over the port list and invoke a multiprocessing process for the current
    IP and current port chunk, which is highlighted by section **(1)**. Going by the
    current example, we would have three parallel processes running for Thread 1 and
    three for Thread 2 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Process 1 (method = portscanner(), IP = 192.168.250.143, portx = 1-21845,
    rec_id = 100)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process 2 (method = portscanner(), IP = 192.168.250.143, portx = 21845-43690,
    rec_id = 101)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process 3 (method = portscanner(), IP=  192.168.250.143, portx = 43690-65535,
    rec_id = 102)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process 4 (method = portscanner(), IP = 192.168.250.144, portx = 1-21845,
    rec_id = 103)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process 5 (method = portscanner(), IP = 192.168.250.144, portx = 21845-43690,
    rec_id = 104)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Process 6 (method = portscanner(), IP = 192.168.250.144, portx = 43690-65535,
    rec_id = 105)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, each process would be executed on a processor core. It would be great
    to have a seven-core processor. In that case, the main program would be utilizing
    one core and the other six cores would have been distributed in parallel among
    the preceding six processes. In our case, however, we have a four-core processor,
    where one core is used by the main thread and the remaining three are shared between
    the six processes that are spawned. This will involve certain delay due to context
    switching. Also note that we are using the mp.Process utility of the multiprocessing
    library. Feel free to use the batch processing module, as we discussed in the
    previous chapters, with a batch size of 3 and see if there is any difference in
    the scan time. Finally, we want the Thread 1 thread to stay alive until all the
    host chunks are scanned, as our polling logic indicates that if a thread is finished
    then host scan is over. We therefore invoke the `join()` method on the current
    thread. This ensures that Thread 1 and Thread 2 both stay alive until all the
    processes are finished; in other words, all chunks are scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is self-explanatory. We are using Python''s built-in Nmap
    utility to scan a host and port chunk. If the scan is successful, we simply parse
    the results and extract the TCP and UDP results separately. After extracting the
    results, we simply save the results in the backend database table using the `self.IPtable
    .Update ()` method. We mark the status as complete and save the results for the
    ports and services which were found to be open. On the other hand, if the port
    scanning results for the port chunks and IPs returned any exceptions, we make
    three repeated attempts to carry out a scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c69fb2c-a863-4c03-9951-d6587f0e30d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After three retries, if the scan is unsuccessful, then for that record (`I`,
    `port-chunk`, `project_id`) we update the status as error-complete as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07daa4ad-28c8-4ce9-ab0e-368f1d2b1577.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `start_Polling` method continuously monitors the number of active threads, as
    shown in lines **(1)** and **(2)**. If it finds only one running thread, then
    it checks the backend table to see whether all hosts are marked with a status
    of complete. If there is only one running thread (`main`) and all hosts are marked
    as complete, it breaks out of the infinite polling loop. On the other hand, if
    it finds that the current number of threads running is less than the maximum permitted
    batch size, and there are few unscanned hosts left in the database table, it picks
    an unscanned host and allocates a thread to it by invoking the `startProcessing()` method.
    This is highlighted by sections **(3)** and **(4)** of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/474536d9-0239-4bd0-b419-d93f3e97063f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code handles how to resume a paused scan. The `self.IPtable.MakeUpdate` method
    updates the status of the unscanned hosts to `incomplete`. It returns 1 when there
    were hosts that have a status of processing that are now marked as `incomplete`.
    If the scan was paused before the hosts were placed in the database table, then
    it returns a status of `2`. In this case, we are required to make the bulk entries
    again. The rest of the code is straightforward; we invoke the `startProcessing()` method
    to delegate a thread for a host to be scanned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d998a5dc-be7b-4796-a2a5-4b3f0a3a9275.png)'
  prefs: []
  type: TYPE_IMG
- en: It must be noted that in order to pause the scan we simply need to press *Ctrl*
    + *C* on the console or Terminal window. The current scan would be paused, updating
    the status appropriately in the backend database against the current project ID. It
    should also be noted that, as mentioned earlier, the methods discussed above form
    the central logic of the port scanner (portion) of our vulnerability scanner.
    The exact code has a few other functions and the details can be found at the GitHub
    repository [<https://github.com/FurqanKhan1/Dictator>](http://%3Chttps://github.com/FurqanKhan1/Dictator%3E).
  prefs: []
  type: TYPE_NORMAL
- en: Executing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before executing the code, refer to the installation and setup instructions
    at the GitHub URL [<https://github.com/FurqanKhan1/Dictator/wiki>](http://%3Chttps://github.com/FurqanKhan1/Dictator/wiki%3E).
    The installation guide also talks about how to set up the backend database and
    tables. Alternatively, you can download the plug and play VM that has everything
    installed and preconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the code, go to `/root/Django_project/Dictator/Dictator_Servicepath` and
    run the `driver_main_class.py` code file as `python Driver_main_class.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef89bf7-bfcd-495b-814e-a5402aff164e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the program in the process of scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7db4c409-3d62-48d3-aec5-1bdeb4057460.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the log details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4feca97b-57a3-40ba-8ee2-04c02ff0ead0.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen in the preceding screenshots that for one host, three subprocesses
    were spawned and one thread was created.
  prefs: []
  type: TYPE_NORMAL
- en: Database schema for the port scanning portion of the vulnerability scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to understand the backend database and the structure of the various
    tables within the database that we are using. The `show databases` command is
    used to list all the databases present in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33fbdd85-907e-4b6c-81b8-3713c8e0c79c.png)      ![](img/6b682cfd-471e-4e60-ba2e-16e9734fd478.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to use the current database, which is relevant for our vulnerability
    scanner, we use the use `nmapscan` command. Furthermore, to see all the tables
    within the current database, we use the `show tables` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34d0290a-b420-42ed-8d8e-db7f49cd82a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order for us to see the structure or schema of the table that will hold
    all the scan projects, we use the `desc project` command. To see the data of the
    project we scanned, we issue the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf85b82b-b7bb-41c8-ac59-d63bb1a430e7.png)'
  prefs: []
  type: TYPE_IMG
- en: '`IPtable` is the table that holds the results for the port scanning results
    of our target. The following command, `desc IPtable`, shows us the schema of the
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4848d35-8c04-4c37-8534-a8d613ca6661.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the data present in the `IPtable` for the current
    project, `744`. We can see that all the service scan results are placed in the
    table in CSV format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19ce5118-42ad-4cdb-b976-1d46ee553d09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the port scanning of the project is successfully finished, all the details
    of the project are moved from `IPtable` to `IPtable_history`. This is to make
    the lookup operation fast on `IPtable`. As a result, the schema of `IPtable_history`
    table would be exactly the same as IPtable. This can be verified in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee50a4d2-fe36-4dcd-85d8-978e85dd336f.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to use Python's built-in Nmap utility to conduct
    and automate port scanning with the additional capabilities of pausing and resuming
    the scans and adding a layer of optimization using threads and multiprocessing.
    In the next chapter, we will be continuing with our vulnerability scanner, to
    understand how we can now use the port scanning results to further automate and
    orchestrate service scanning. We will also discuss a GUI version of our vulnerability
    scanner, which has tons of features and a very intuitive dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are we using a combination of threads and multiprocessing to automate port
    scanning?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we possibly do to further optimize the throughput?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there any other Python module or library that we can use to automate Nmap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we use other scanners such as Angry-IP or Mass Scan using the same methodology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Python class on how to use Nmap and access scan results from `python3`: [https://pypi.org/project/python-Nmap/](https://pypi.org/project/python-Nmap/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Nmap tutorial:[ https://hackertarget.com/Nmap-tutorial/](https://hackertarget.com/Nmap-tutorial/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python MySQL: [https://www.w3schools.com/python/python_mysql_getstarted.asp](https://www.w3schools.com/python/python_mysql_getstarted.asp)
    and [https://dev.mysql.com/doc/connector-python/en/](https://dev.mysql.com/doc/connector-python/en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
