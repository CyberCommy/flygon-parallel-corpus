- en: Chapter 6. The Backup Plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Archiving with tar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving with cpio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing with gunzip (gzip)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing with bunzip (bzip)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing with lzma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving and compressing with zip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heavy compression squashfs fileystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting files and folders (with standard algorithms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup snapshots with rsync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version controlled backups with git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning disks with dd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking snapshots and backups of data are regular tasks we come across. When
    it comes to a server or large data storage systems, regular backups are important.
    It is possible to automate backups via shell scripting. Archiving and compression
    seems to find usage in the everyday life of a system admin or a regular user.
    There are various compression formats that can be used in various ways so that
    best results can be obtained. Encryption is another task that comes under frequent
    usage for protection of data. In order to reduce the size of encrypted data, usually
    files are archived and compressed before encrypting. Many standard encryption
    algorithms are available and it can be handled with shell utilities. This chapter
    walks through different recipes for creating and maintaining files or folder archives,
    compression formats, and encrypting techniques with shell. Let's go through the
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving with tar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tar` command can be used to archive files. It was originally designed for
    storing data on tape archives (tar). It allows you to store multiple files and
    directories as a single file. It can retain all the file attributes, such as owner,
    permissions, and so on. The file created by the `tar` command is often referred
    to as a tarball.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tar` command comes by default with all UNIX like operating systems. It
    has a simple syntax and is a portable file format. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '`tar` has got a list of arguments: `A`, `c`, `d`, `r`, `t`, `u`, `x`, `f`,
    and `v`. Each of these letters can be used independently for different purposes
    corresponding to it.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To archive files with tar, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `-c` stands for "create file" and `–f` stands for "specify
    filename".
  prefs: []
  type: TYPE_NORMAL
- en: We can specify folders and filenames as `SOURCES`. We can use a list of file
    names or wildcards such as `*.txt` to specify the sources.
  prefs: []
  type: TYPE_NORMAL
- en: It will archive the source files into a file called `output.tar`.
  prefs: []
  type: TYPE_NORMAL
- en: The filename must appear immediately after the `–f` and should be the last option
    in the argument group (for example, `-cvvf filename.tar` and `-tvvf filename.tar`).
  prefs: []
  type: TYPE_NORMAL
- en: We cannot pass hundreds of files or folders as command-line arguments because
    there is a limit. So it is safer to use the append option if many files are to
    be archived.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional features that are available with the `tar` command.
  prefs: []
  type: TYPE_NORMAL
- en: Appending files to an archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we may need to add files to an archive that already exists (an example
    usage is when thousands of files are to be archived and when they cannot be specified
    in one line as command-line arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'Append option: `-r`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to append a file into an already existing archive use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'List the files in an archive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to print more details while archiving or listing, use the `-v` or the
    `–vv` flag. These flags are called verbose (`v`), which will enable to print more
    details on the terminal. For example, by using verbose you could print more details,
    such as the file permissions, owner group, modification date, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extracting files and folders from an archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command extracts the contents of the archive to the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `-x` option stands for extract.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `–x` is used, the `tar` command extracts the contents of the archive to
    the current directory. We can also specify the directory where the files need
    to be extracted by using the `–C` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The command extracts the contents of an archive to insert image a specified
    directory. It extracts the entire contents of the archive. We can also extract
    only a few files by specifying them as command arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The command above extracts only `file1` and `file4`,and ignores other files
    in the archive.
  prefs: []
  type: TYPE_NORMAL
- en: stdin and stdout with tar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While archiving, we can specify `stdout` as the output file so that another
    command appearing through a pipe can read it as `stdin` and then do some process
    or extract the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is helpful in order to transfer data through a Secure Shell (SSH) connection
    (while on a network). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, `file1`, `file2`, and `file3` are combined into a tarball
    and then extracted to `~/destination`. In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f` specifies `stdout` as the file for archiving (when the `-c` option used)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` specifies `stdin` as the file for extracting (when the `-x` option used)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating two archives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can easily merge multiple tar files with the `-A` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pretend we have two tarballs: `file1.tar` and `file2.tar`. We can merge
    the contents of `file2.tar` to `file1.tar` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify it by listing the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Updating files in an archive with timestamp check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The append option appends any given file to the archive. If the same file is
    inside the archive is given to append, it will append that file and the archive
    will contain duplicates. We can use the update option `-u` to specify only append
    files that are newer than the file inside the archive with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command lists the files in the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to append `filea` only if `filea` has newer modification time than
    `filea` inside `archive.tar`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nothing happens if the version of `filea` outside the archive and the `filea`
    inside `archive.tar` have the same timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `touch` command to modify the file timestamp and then try the `tar`
    command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The file is appended since its timestamp is newer than the one inside the archive.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing files in archive and file system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes it is useful to know whether a file in the archive and a file with
    the same filename in the filesystem are the same or contain any differences. The
    `–d` flag can be used to print the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Deleting files from archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can remove files from a given archive using the `–delete` option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can also use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compression with tar archive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tar` command only archives files, it does not compress them. For this
    reason, most people usually add some form of compression when working with tarballs.
    This significantly decreases the size of the files. Tarballs are often compressed
    into one of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file.tar.gz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.tar.bz2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.tar.lzma`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.tar.lzo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different `tar` flags are used to specify different compression formats.
  prefs: []
  type: TYPE_NORMAL
- en: '`-j` for bunzip2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-z` for gzip'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--lzma` for lzma'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are explained in the following compression-specific recipes.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use compression formats without explicitly specifying special
    options as above. `tar` can compress by looking at the given extension of the
    output or input file names. In order for `tar` to support compression automatically
    by looking at the extensions, use `-a` or `--auto-compress` with `tar`.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding a set of files from archiving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to exclude a set of files from archiving by specifying patterns.
    Use `--exclude [PATTERN]` for excluding files matched by wildcard patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to exclude all `.txt` files from archiving use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the pattern should be enclosed in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to exclude a list of files provided in a list file with
    the `-X` flag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now it excludes `filea` and `fileb` from archiving.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding version control directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We usually use tarballs for distributing source code. Most of the source code
    is maintained using version control systems such as subversion, Git, mercurial,
    cvs, and so on. Code directories under version control will contain special directories
    used to manage versions like `.svn` or `.git`. However, these directories aren't
    needed by the code itself and so should be eliminated from the tarball of the
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to exclude version control related files and directories while archiving
    use the `--exclude-vcs` option along with `tar`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Printing total bytes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is sometimes useful if we can print total bytes copied to the archive. Print
    the total bytes copied after archiving by using the --`totals` option as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Compressing with gunzip (gzip)*, explains the gzip command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compressing with bunzip (bzip2)*, explains the bzip2 command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compressing with lzma*, explains the lzma command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving with cpio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**cpio** is another archiving format similar to `tar`. It is used to store
    files and directories in a file with attributes such as permissions, ownership,
    and so on. But it is not commonly used as much as `tar`. However, `cpio` seems
    to be used in RPM package archives, initramfs files for the Linux kernel, and
    so on. This recipe will give minimal usage examples of `cpio`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cpio` takes input filenames through `stdin` and it writes the archive into
    `stdout`. We have to redirect `stdout` to a file to receive the output `cpio`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can archive the test files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-o` specifies the output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` is used for printing a list of files archived'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By using `cpio`, we can also archive using files as absolute paths. `/usr/somedir`
    is an absolute path as it contains the full path starting from root (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: A relative path will not start with `/` but it starts the path from the current
    directory. For example, `test/file` means that there is a directory `test` and
    the `file` is inside the `test` directory.
  prefs: []
  type: TYPE_NORMAL
- en: While extracting, `cpio` extracts to the absolute path itself. But incase of
    `tar` it removes the `/` in the absolute path and converts it as relative path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list files in a `cpio` archive use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list all the files in the given `cpio` archive. It reads
    the files from `stdin`. In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i` is for specifying the input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` is for listing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to extract files from the `cpio` archive use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, `-d` is used for extracting.
  prefs: []
  type: TYPE_NORMAL
- en: It overwrites files without prompting. If the absolute path files are present
    in the archive, it will replace the files at that path. It will not extract files
    in the current directory like `tar`.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing with gunzip (gzip)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**gzip** is a commonly used compression format in GNU/Linux platforms. Utilities
    such as `gzip`, `gunzip`, and `zcat` are available to handle gzip compression
    file types. `gzip` can be applied on a file only. It cannot archive directories
    and multiple files. Hence we use a `tar` archive and compress it with `gzip`.
    When multiple files are given as input it will produce several individually compressed
    (`.gz`) files. Let''s see how to operate with `gzip`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compress a file with `gzip` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then it will remove the file and produce a compressed file called `filename.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract a `gzip` compressed file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It will remove `filename.gz` and produce an uncompressed version of `filename.gz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to list out the properties of a compressed file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `gzip` command can read a file from `stdin` and also write a compressed
    file into `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read from `stdin` and out as `stdout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `-c` option is used to specify output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify the compression level for `gzip`. Use `--fast` or the `--best`
    option to provide low and high compression ratios, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `gzip` command is often used with other commands. It also has advanced options
    to specify the compression ratio. Let's see how to work with these features.
  prefs: []
  type: TYPE_NORMAL
- en: Gzip with tarball
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We usually use `gzip` with tarballs. A tarball can be compressed by using the
    `–z` option passed to the `tar` command while archiving and extracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create gzipped tarballs using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option specifies that the compression format should automatically be
    detected from the extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create a tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Compress it after tarballing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If many files (a few hundreds) are to be archived in a tarball and need to
    be compressed, we use Method - 2 with few changes. The issue with giving many
    files as command arguments to `tar` is that it can accept only a limited number
    of files from the command line. In order to solve this issue, we can create a
    `tar` file by adding files one by one using a loop with an append option (`-r`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to extract a gzipped tarball, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x` for extraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-z` for gzip specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the above command, the `-a` option is used to detect the compression format
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: zcat – reading gzipped files without extracting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`zcat` is a command that can be used to dump an extracted file from a `.gz`
    file to `stdout` without manually extracting it. The `.gz` file remains as before
    but it will dump the extracted file into `stdout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Compression ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify compression ratio, which is available in range 1 to 9, where:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 is the lowest, but fastest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 is the best, but slowest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also specify the ratios in between as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will compress the file to the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Archiving with tar*, explains the tar command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing with bunzip (bzip)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**bunzip2** is another compression technique which is very similar to `gzip`.
    `bzip2` typically produces smaller (more compressed) files than `gzip`. It comes
    with all Linux distributions. Let''s see how to use `bzip2`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compress with `bzip2` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Then it will remove the file and produce a compressed file called `filename.bzip2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract a bzipped file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It will remove `filename.bz2` and produce an uncompressed version of `filename`.
  prefs: []
  type: TYPE_NORMAL
- en: '`bzip2` can read a file from `stdin` and also write a compressed file into
    `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read from `stdin` and read out as `stdout` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`-c` is used to specify output to `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: We usually use `bzip2` with tarballs. A tarball can be compressed by using the
    `-j` option passed to the `tar` command while archiving and extracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a bzipped tarball can be done by using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option specifies to automatically detect compression format from the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First create the tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Compress it after tarballing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we need to add hundreds of files to the archive, the above commands may fail.
    To fix that issue, use a loop to append files to the archive one by one using
    the `–r` option. See the similar section from the recipe, *Compressing with gunzip
    (gzip)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract a bzipped tarball as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-x` is used for extraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-j` is for `bzip2` specification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C` is for specifying the directory to which the files are to be extracted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`-a` will automatically detect the compression format.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: bunzip has several additional options to carry out different functions. Let's
    go through few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping input files without removing them
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While using `bzip2` or `bunzip2`, it will remove the input file and produce
    a compressed output file. But we can prevent it from removing input files by using
    the `–k` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Compression ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can specify the compression ratio, which is available in the range of 1 to
    9 (where 1 is the least compression, but fast, and 9 is the highest possible compression
    but much slower).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This command provides maximum compression.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Archiving with tar*, explains the tar command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing with lzma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**lzma** is comparatively new when compared to `gzip` or `bzip2`. `lzma` offers
    better compression rates than `gzip` or `bzip2`. As `lzma` is not preinstalled
    on most Linux distros, you may need to install it using the package manager.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compress with `lzma` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the file and produce a compressed file called `filename.lzma`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract an `lzma` file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will remove `filename.lzma` and produce an uncompressed version of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `lzma` command can also read a file from `stdin` and write the compressed
    file to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read from `stdin` and read out as `stdout` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`-c` is used to specify output to `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: We usually use `lzma` with tarballs. A tarball can be compressed by using the
    `--lzma` option passed to the `tar` command while archiving and extracting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods to create a `lzma` tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option specifies to automatically detect the compression format from
    the extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method - 2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create the tarball:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Compress it after tarballing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If we need to add hundreds of files to the archive, the above commands may fail.
    To fix that issue, use a loop to append files to the archive one by one using
    the `–r` option. See the similar section from the recipe, *Compressing with gunzip
    (gzip)*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional options associated with `lzma` utilities
  prefs: []
  type: TYPE_NORMAL
- en: Extracting an lzma tarball
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to extract a tarball compressed with `lzma` compression to a specified
    directory, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `-x` is used for extraction. `--lzma` specifies the use of
    `lzma` to decompress the resulting file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, we could also use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option specifies to automatically detect the compression format from
    the extension.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping input files without removing them
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While using `lzma` or `unlzma`, it will remove the input file and produce an
    output file. But we can prevent from removing input files and keep them by using
    the `-k` option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Compression ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can specify the compression ratio, which is available in the range of 1 to
    9 (where 1 is the least compression, but fast, and 9 is the highest possible compression
    but much slower).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify ratios in between as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This command compresses the file to the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Archiving with tar*, explains the tar command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Archiving and compressing with zip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ZIP is a popular compression format used on many platforms. It isn't as commonly
    used as `gzip` or `bzip2` on Linux platforms, but files from the Internet are
    often saved in this format.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to archive with ZIP, the following syntax is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `file.zip` file will be produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Archive directories and files recursively as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `-r` is used for specifying recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `lzma`, `gzip`, or `bzip2`, `zip` won't remove the source file after
    archiving. `zip` is similar to `tar` in that respect, but `zip` can compress files
    where `tar` does not. However, `zip` adds compression too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to extract files and folders in a ZIP file, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It will extract the files without removing `filename.zip` (unlike `unlzma` or
    `gunzip`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to update files in the archive with newer files in the filesystem,
    use the `-u` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete a file from a zipped archive, by using `–d` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to list the files in an archive use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: squashfs – the heavy compression filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**squashfs** is a heavy-compression based read-only filesystem that is capable
    of compressing 2 to 3GB of data onto a 700 MB file. Have you ever thought of how
    Linux Live CDs work? When a Live CD is booted it loads a complete Linux environment.
    Linux Live CDs make use of a read-only compressed filesystem called squashfs.
    It keeps the root filesystem on a compressed filesystem file. It can be loopback
    mounted and files can be accessed. Thus when some files are required by processes,
    they are decompressed and loaded onto the RAM and used. Knowledge of squashfs
    can be useful when building a custom live OS or when required to keep files heavily
    compressed and to access them without entirely extracting the files. For extracting
    a large compressed file, it will take a long time. However, if a file is loopback
    mounted, it will be very fast since the required portion of the compressed files
    are only decompressed when the request for files appear. In regular decompression,
    all the data is decompressed first. Let''s see how we can use squashfs.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have an Ubuntu CD just locate a `.squashfs` file at `CDRom ROOT/casper/filesystem.squashfs`.
    `squashfs` internally uses compression algorithms such as `gzip` and `lzma`. `squashfs`
    support is available in all of the latest Linux distros. However, in order to
    create `squashfs` files, an additional package **squashfs-tools** needs to be
    installed from package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a `squashfs` file by adding source directories and files,
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Sources can be wildcards, or file, or folder paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to mount the `squashfs` file to a mount point, use loopback mounting
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can copy contents by accessing `/mnt/squashfs`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `squashfs` file system can be created by specifying additional parameters.
    Let's go through the additional options.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding files while creating a squashfs file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While creating a `squashfs` file, we can exclude a list of files or a file pattern
    specified using wildcards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exclude a list of files specified as command-line arguments by using the `-e`
    option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `–e` option is used to exclude `passwd` and `shadow` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify a list of exclude files given in a file with
    `–ef` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If we want to support wildcards in excludes lists, use `-wildcard` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic tools and hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption techniques are used mainly to protect data from unauthorized access.
    There are many algorithms available and we use a common set of standard algorithms.
    There are a few tools available in a Linux environment for performing encryption
    and decryption. Sometimes we use encryption algorithm hashes for verifying data
    integrity. This section will introduce a few commonly-used cryptographic tools
    and a general set of algorithms that these tools can handle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how to use the tools such as crypt, gpg, base64, md5sum, sha1sum,
    and openssl:'
  prefs: []
  type: TYPE_NORMAL
- en: '**crypt**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `crypt` command is a simple cryptographic utility, which takes a file from
    `stdin` and a passphrase as input and outputs encrypted data into `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It will interactively ask for a passphrase. We can also provide a passphrase
    through command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decrypt the file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**gpg (GNU privacy guard)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gpg (GNU privacy guard) is a widely-used encryption scheme used for protecting
    files with key signing techniques that enables to access data by authentic destination
    only. gpg signatures are very famous. The details of gpg are outside the scope
    of this book. Here we can learn how to encrypt and decrypt a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to encrypt a file with `gpg` use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This command reads the passphrase interactively and generates `filename.gpg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to decrypt a `gpg` file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This command reads a passphrase and decrypts the file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Base64**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base64 is a group of similar encoding schemes that represents binary data in
    an ASCII string format by translating it into a radix-64 representation. The `base64`
    command can be used to encode and decode the Base64 string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to encode a binary file into Base64 format, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: It can read from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decode Base64 data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '**md5sum** and **sha1sum**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**md5sum** and **sha1sum** are unidirectional hash algorithms, which cannot
    be reversed to form the original data. These are usually used to verify the integrity
    of data or for generating a unique key from a given data. For every file it generates
    a unique key by analyzing its content.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: These types of hashes are ideal for storing passwords. Passwords are stored
    as its hashes. When a user wants to authenticate, the password is read and converted
    to the hash. Then hash is compared to the one that is stored already. If they
    are same, the password is authenticated and access is provided, else it is denied.
    Storing original password strings is risky and poses a security risk of exposing
    the password.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shadowlike hash (salted hash)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how to generate shadow like salted hash for passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user passwords in Linux are stored as its hashes in the `/etc/shadow` file.
    A typical line in `/etc/shadow` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In this line `$6$fG4eWdUi$ohTKOlEUzNk77.4S8MrYe07NTRV4M3LrJnZP9p.qc1bR5c.EcOruzPXfEu1uloBFUa18ENRH7F70zhodas3cR`
    is the shadow hash corresponding to its password.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, we may need to write critical administration scripts that
    may need to edit passwords or add users manually using a shell script. In that
    case we have to generate a shadow password string and write a similar line as
    above to the shadow file. Let's see how to generate a shadow password using `openssl`.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow passwords are usually salted passwords. `SALT` is an extra string used
    to obfuscate and make the encryption stronger. The salt consists of random bits
    that are used as one of the inputs to a key derivation function that generates
    the salted hash for the password.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on salt, see the Wikipedia page [http://en.wikipedia.org/wiki/Salt_(cryptography)](http://en.wikipedia.org/wiki/Salt_(cryptography)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Replace `SALT_STRING` with a random string and `PASSWORD` with the password
    you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Backup snapshots with rsync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backing up data is something that most sysadmins need to do regularly. We may
    need to backup data in a web server or from remote locations. `rsync` is a command
    that can be used to synchronize files and directories from one location to another
    while minimizing data transfer using file difference calculations and compression.
    The advantage of `rsync` over the `cp` command is that `rsync` uses strong difference
    algorithms. Also, it supports data transfer across networks. While making copies,
    it compares the files in the original and destination locations and will only
    copy the files that are newer. It also supports compression, encryption, and a
    lot more. Let's see how we can work with `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to copy a source directory to a destination (to create a mirror) use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a` stands for archiving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v` (verbose) prints the details or progress on `stdout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The above command will recursively copy all the files from the source path to
    the destination path. We can specify paths as remote or localhost paths.
  prefs: []
  type: TYPE_NORMAL
- en: It can be in the format `/home/slynux/data`, [slynux@192.168.0.6:/home/backups/data](http://slynux@192.168.0.6:/home/backups/data),
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/slynux/data` specifies the absolute path in the machine in which the
    `rsync` command is executed. `slynux@192.168.0.6:/home/backups/data` specifies
    that the path is`/home/backups/data` in the machine with IP address `192.168.0.6`
    and is logged in as user `slynux`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to back up data to a remote server or host, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: To keep a mirror at the destination, run the same `rsync` command scheduled
    at regular intervals. It will copy only changed files to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the data from remote host to `localhost` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `rsync` command uses SSH to connect to another remote machine. Provide the
    remote machine address in the format [user@host](http://user@host), where user
    is the username and host is the IP address or domain name attached to the remote
    machine. `PATH` is the absolute path address where the data needs to be copied.
    `rsync` will ask for the user password as usual for SSH logic. This can be automated
    (avoid user password probing) by using SSH keys.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the OpenSSH is installed and running on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compressing data while transferring through the network can significantly optimize
    the speed of the transfer. We can use the `rsync` option `–z` to specify to compress
    data while transferring through a network. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the PATH format, if we use `/` at the end of the source, `rsync` will copy
    contents of that end directory specified in the `source_path` to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: If `/` not at the end of the source, `rsync` will copy that end directory itself
    to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command copies the content of the `test` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command copies the `test` directory to the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If `/` is at the end of `destination_path`, `rsync` will copy the source to
    the destination directory.
  prefs: []
  type: TYPE_NORMAL
- en: If `/` is not used at the end of the destination path, `rsync` will create a
    folder, named similar to the source directory, at the end of the destination path
    and copy the source into that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This command copies the source (`/home/test`) to an existing folder called `backups`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This command copies the source (`/home/test`) to a directory named `backups`
    by creating that directory.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `rsync` command has several additional functionalities that can be specified
    using its command-line options. Let's go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding files while archiving with rsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some files need not be updated while archiving to a remote location. It is
    possible to tell `rsync` to exclude certain files from the current operation.
    Files can be excluded by two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can specify a wildcard pattern of files to be excluded. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This command excludes `.txt` files from backing up.
  prefs: []
  type: TYPE_NORMAL
- en: Or, we can specify a list of files to be excluded by providing a list file.
  prefs: []
  type: TYPE_NORMAL
- en: Use `--exclude-from FILEPATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting non-existent files while updating rsync backup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We archive files as tarball and transfer the tarball to the remote backup location.
    When we need to update the backup data, we create a TAR file again and transfer
    the file to the backup location. By default, `rsync` does not remove files from
    the destination if they no longer exist at the source. In order to remove the
    files from the destination that do not exist at the source, use the `rsync --delete`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling backups at intervals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a cron job to schedule backups at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The above `crontab` entry schedules the `rsync` to be executed every 10 hours.
  prefs: []
  type: TYPE_NORMAL
- en: '`*/10` is the hour position of the `crontab` syntax. `/10` specifies to execute
    the backup every 10 hours. If `*/10` is written in the minutes position, it will
    execute every 10 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the *Scheduling with cron* recipe in [Chapter 9](ch09.html "Chapter 9. Administration
    Calls") to understand how to configure `crontab`.
  prefs: []
  type: TYPE_NORMAL
- en: Version control based backup with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People use different strategies in backing up data. Differential backups are
    more efficient than making copies of the entire source directory to a target the
    backup directory with the version number using date or time of a day. It causes
    wastage of space. We only need to copy the changes that occurred to files from
    the second time that the backups occur. This is called incremental backups. We
    can manually create incremental backups using tools like `rsync`. But restoring
    this sort of backup can be difficult. The best way to maintain and restore changes
    is to use version control systems. They are very much used in software development
    and maintenance of code, since coding frequently undergoes changes. Git (GNU it)
    is a very famous and is the most efficient version control systems available.
    Let's use Git for backup of regular files in non-programming context. Git can
    be installed by your distro's package manager. It was written by Linus Torvalds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the problem statement:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a directory that contains several files and subdirectories. We need
    to keep track of changes occurring to the directory contents and back them up.
    If data becomes corrupted or goes missing, we must be able to restore a previous
    copy of that data. We need to backup the data at regular intervals to a remote
    machine. We also need to take the backup at different locations in the same machine
    (localhost). Let's see how to implement it using Git.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the directory which is to be backed up use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Let it be the directory source to be tracked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up and initiate the remote backup directory. In the remote machine, create
    the backup destination directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps are to be performed in the source host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add user details to Git in the source host machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Initiate the source directory to backup from the host machine. In the source
    directory in the host machine whose files are to be backed up, execute the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'In the source directory, execute the following command to add the remote git
    directory and synchronize backup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Add or remove files for Git tracking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command adds all files and folders in the current directory to
    the backup list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We can conditionally add certain files only to the backup list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the files and folders not required to be tracked by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be a folder or even a wildcard as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Check-pointing or marking backup points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can mark checkpoints for the backup with a message using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We need to update the backup at the remote location at regular intervals. Hence,
    set up a cron job (for example, backing up every five hours).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file crontab entry with lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a script `/home/data/backup.sh` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now we have set up the backup system.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring data with Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to view all backup versions use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Update the current directory to the last backup by ignoring any recent changes.
  prefs: []
  type: TYPE_NORMAL
- en: To revert back to any previous state or version, look into the commit ID, which
    is a 32-character hex string. Use the commit ID with `git checkout`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For commit ID 3131f9661ec1739f72c213ec5769bc0abefa85a9 it will be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to view the details about versions again, use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If the working directory is broken due to some issues, we need to fix the directory
    with the backup at the remote location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can recreate the contents from the backup at the remote location as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This will create a directory backup with all contents.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning hard drive and disks with dd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with hard drives and partitions, we may need to create copies
    or make backups of full partitions rather than copying all contents (not only
    hard disk partitions but also copy an entire hard disk without missing any information,
    such as boot record, partition table, and so on). In this situation we can use
    the `dd` command. It can be used to clone any type of disks, such as hard disks,
    flash drives, CDs, DVDs, floppy disks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dd` command expands to Data Definition. Since its improper usage leads
    to loss of data, it is nicknamed as "Data Destroyer". Be careful while using the
    order of arguments. Wrong arguments can lead to loss of entire data or can become
    useless. `dd` is basically a bitstream duplicator that writes the entire bit stream
    from a disk to a file or a file to a disk. Let's see how to use `dd`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax for `dd` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` stands for input file or input device path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of` stands for target file or target device path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bs` stands for block size (usually, it is given in the power of 2, for example,
    512, 1024, 2048, and so on). `COUNT` is the number of blocks to be copied (an
    integer).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total bytes copied = BLOCK_SIZE * COUNT
  prefs: []
  type: TYPE_NORMAL
- en: '`bs` and `count` are optional.'
  prefs: []
  type: TYPE_NORMAL
- en: By specifying `COUNT` we can limit the number of bytes to be copied from input
    file to target. If `COUNT` is not specified, `dd` will copy from input file until
    it reaches the end of file (EOF) marker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to copy a partition into a file use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here `/dev/sda1` is the device path for the partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restore the partition using the backup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: You should be careful about the argument `if` and `of`. Improper usage may lead
    to data loss.
  prefs: []
  type: TYPE_NORMAL
- en: By changing the device path `/dev/sda1` to the appropriate device path, any
    disk can be copied or restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to permanently delete all of the data in a partition, we can make
    `dd` to write zeros into the partition by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '`/dev/zero` is a character device. It always returns infinite zero ''\0'' characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone one hard disk to another hard disk of the same size as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Here `/dev/sdb` is the second hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to take the image of a CD ROM (ISO file) use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a file system is created in a file which is generated using `dd`, we can
    mount it to a mount point. Let's see how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting image files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any file image created using `dd` can be mounted using the loopback method.
    Use the `-o loop` with the `mount` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Now we can access the contents of the image files through the location `/mnt/mount_point`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating ISO files, Hybrid ISO* of [Chapter 3](ch03.html "Chapter 3. File
    In, File Out"), explains how to use dd to create an ISO file from a CD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
