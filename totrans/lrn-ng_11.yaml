- en: Angular Material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you develop an application, you need a clear strategy on how to create
    your UI. The strategy should include using good, contrasting colors; having a
    consistent look and feel; it should work well on different devices, as well as
    browsers; and many more requirements. In short, there are a lot of requirements
    on an application being built for the web platform today when it comes to UI and
    UX. It is no wonder that most developers consider UI/UX to be a daunting task
    and therefore turn to UI frameworks that do a lot of the heavy lifting. There
    are some frameworks that are used more than others, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foundation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 Quickstart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is, however, a new kid on the block, or should we say, a new design language,
    Material Design. This chapter will try to explain what Material Design is and
    will look at what frameworks implement the principles of Material Design, and
    we will especially focus on Angular Material, made especially for Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about what Material Design is and a little bit of its history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about known implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delve deeper into Angular Material and what parts it consists of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an Angular application with Angular Material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Material Design is a design language that was developed by Google in 2014\.
    Google states that its new design language is based on paper and ink. The creators
    of Material Design tried to explain the goal they were trying to reach, with the
    following quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '"We challenged ourselves to create a visual language for our users that synthesises
    the classic principles of good design with the innovation and possibility of technology
    and science."'
  prefs: []
  type: TYPE_NORMAL
- en: 'They explain further the goals as:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop a single underlying system that allows for a unified experience across
    platforms and device sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile precepts are fundamental, but touch, voice, mouse, and keyboard are all
    first-class input methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is clear that the design language wants to have one take, and one take only
    on how the UI and user interaction should look and feel, across devices. Also,
    that input plays a large role on the overall experience of a UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Material Design rests on three principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Material is the metaphor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bold, graphic, intentional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion provides meaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, it can be said that there is a lot of theory behind the design language,
    and there is good documentation on the topic should you wish to delve further
    in, such as at the official documentation site, [https://material.io/.](https://material.io/)
  prefs: []
  type: TYPE_NORMAL
- en: Now, all of this is probably very interesting if you are a designer and care
    about graphical theory. It is our guess that you who is reading this book is a
    developer and that you are asking yourself a question right now. So what, why
    should I care?
  prefs: []
  type: TYPE_NORMAL
- en: Well, every time Google sets out to build something, it becomes big. Not everything
    remains over time, but there is sufficient muscle behind this, and Google have
    paved the way by using this on a lot of their own products such as Firebase, Gmail,
    Google Plus, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, by itself a design language isn't that interesting, at least not
    for a developer, which brings us to our next section on the fact that there does
    exist a number of implementations based on the design principles laid out by Material
    Design. More on this in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Known implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a developer, design is there to make sense of your code and give the user
    a nice experience, both visually and from a usability standpoint. Currently, three
    major implementations exist of Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those are:'
  prefs: []
  type: TYPE_NORMAL
- en: Materialize, [http://materializecss.com/about.html.](http://materializecss.com/about.html)24,000+
    stars on GitHub tells you that this is very well used. It works to be used as
    a standalone, but there are also bindings to frameworks such as AngularJS and
    React. It offers navigation elements, components, and much more, a good choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS Material, [https://material.angularjs.org/latest/](https://material.angularjs.org/latest/), is
    Google's own implementation meant for AngularJS. It is quite capable and comes
    with themes, navigation elements, components, and of course directives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Material, [https://material.angular.io/](https://material.angular.io/), is
    Google's own implementation and is built for Angular specifically. We will focus
    on this one throughout the rest of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are an Angular developer, then AngularJS Material or Materialize are
    both valid options, as the latter has AngularJS bindings, found at [https://krescruz.github.io/angular-materialize/](https://krescruz.github.io/angular-materialize/).
    Materialize can be used by many other application frameworks and is the most generic
    choice of the three. Angular Material is made for Angular alone.
  prefs: []
  type: TYPE_NORMAL
- en: Now the time has come to look at Angular Material in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The library was developed to implement Material Design for the new Angular.
    It's still a work in progress, but it continues to evolve. There are, however,
    enough components in place for it to be adopted already. You should know that
    it is still in Beta, so a certain amount of caution is good if you consider adopting
    it. The official documentation can be found at [https://material.angular.io](https://material.angular.io) and
    the repository can be found at [https://github.com/angular/material2](https://github.com/angular/material2).
    It is a quite popular library with 10,000+ stars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular Material promotes itself with the following bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sprint from zero to app**: The intention is to make it very easy for you
    as an app developer to hit the ground running. The goal is for there to be a minimum
    amount of effort in setting it up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast and consistent**: This is to say that performance has been a major focus
    point and also that it is guaranteed to work well on all major browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatile**: This puts focus on two major points, there should be a multitude
    of themes that should be easy to customize and there is also great support for
    localization and internationalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized for Angular**: The very fact that it is built by the Angular team
    itself means the support for Angular is a big priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The framework consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components**: This means that there are a ton of constructs in place to help
    you be successful, such as different kinds of input, buttons, layout, navigation,
    modals, and different ways to show tabular data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Themes**: The library comes with themes preinstalled, but it''s also easy
    to refer to external themes. There is also a theming guide, if you have your heart
    set on creating a custom theme, at [https://material.angular.io/guide/theming.](https://material.angular.io/guide/theming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icons**: Material Design comes with over 900 icons so you are likely to find
    just the icon you need. For a full display of what those are, go to [https://material.io/icons/.](https://material.io/icons/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gestures**: Not everything in a UI is a button click. As Material Design
    supports mobile, it thereby supports mobile gestures through the use of the library
    HammerJs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I know you are probably itching to try it out, so let''s delay no further.
    First off, we need to install it. Let''s start out by ensuring we have an Angular
    project ready to install it on, by telling the Angular CLI to scaffold a project
    for us, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to install the necessary dependencies for Angular Material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now let us also install support for animations. It isn't strictly necessary
    for it to work but we want some cool animations, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is needed to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Thereby, we are done installing Angular Material and are ready to use it in
    our app. As we have learned from previous chapters, to use external Angular modules,
    we need to import them. Once that is done, we can start using the constructs that
    these modules publicly export. In reality, there are many modules to import, depending
    on what we need, for example, every control has its own module but animation has
    only one.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Angular Material app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you have already scaffolded an Angular application, using the Angular
    CLI. You have installed the necessary node modules and are eagerly waiting to
    use the constructs in Angular Material. We expect two things from our Angular
    Material application, some nice rendering as well as some nice animations to go
    with it. To start using a UI control such as a button or a checkbox, we need to
    import its corresponding module. To get the UI rendering and the animation behavior,
    we need to add the necessary modules and select a theme to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start out with the module we need, which is the `BrowserAnimationsModule`.
    To start using it, we import it and register it with our root module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we haven''t really added UI elements to use, so let''s do that
    as the next order of business. Our first example will be about buttons. To use
    an Angular Material button we need to add the `MatButtonModule` to our root module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need one more thing, namely a theme. If we don't add a theme we will get
    a boring button that just looks grey. If we, however, have a theme, we will get
    all the nice animations that have come to be associated with Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a theme, we need to add an entry to our `styles.css` file. This file
    is used to set CSS styles for the whole application. So let''s add the necessary
    row to `styles.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The tilde operator `~` informs webpack,  the underlying engine that fuels Angular
    CLI, that such a path should be treated as an aliased path handled by webpack,
    and not just a regular field path or URL
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to use our first Angular Material UI element. Our choice for
    this is a Material Design button. To use it, we need to add the `mat-button` attribute
    to an element that we want Material Design rendering and behavior on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start in our root module, `app.module.ts`, adding the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the template, an ordinary button becomes a Material Design button by us adding
    the   `mat-button` attribute. `mat-button`is a directive that gives our button
    a new look as well as associated animations. Clicking the button now should give
    off a nice animation.
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates how simple it is to get started with Angular Material, but
    there is more, much more. Let's talk about most of the components in the upcoming
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Component overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular Material consists of a lot of components of differing types, those
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Form controls**: By form controls, we mean any type of controls that we use
    to collect data from a form, such as autocomplete, checkbox, normal input, radio
    button, select list, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation**: By navigation, we mean things like a menu, a sidenav, or a
    toolbar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout**: By layout, we mean how we can place the data on the page, such
    as using a list, a card, or tabs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buttons**: Those are what they sound like, buttons you can push. But there
    are a number of different ones you can use, such as icon buttons, raised buttons,
    and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Popups and modals**: These are specific windows that block any user interaction
    until you have interacted with the popup or modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data table**: This is simply to show data in a tabular way. What kind of
    table you need depends on whether your data is massive and needs pagination, or
    if it needs to be sorted, or both.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our app has only consisted of a simple button, which we declared in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, however, a lot more button types, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mat-button`, this is a normal looking button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-raised-button`, this is a raised button that is displayed with a shadow,
    to indicate its raised state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-icon-button`, this button is meant to be used with an icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-fab`, this is a rounded button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-button-toggle`, this is a button that indicates if it has been pressed
    or not, having pressed/not pressed as states'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The markup for the buttons is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s worth noting that we need to import the `MatButtonToggleModule` to be
    able to use the `mat-button-toggle` button. The buttons look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2f091e8e-da1a-42c6-ac3c-29dcd738aadf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To use these buttons, we need to make sure we import and register the modules
    they belong to. Let''s update our root module to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we need to register `MatIconModule` to support the use of the `mat-icon`
    directive,  and we also need to register the`MatButtonToggleModule` to use the `<mat-button-toggle>`
    UI element, a toggle button.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form controls are about collecting input data in different ways so that you
    might persist the data by calling an endpoint over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are quite a few controls in Material Design of varying types, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Autocomplete**: This control enables the user to start typing in an input
    field and be presented with a list of suggestions while typing. This helps to
    narrow down the possible values that the input can take.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkbox**: This is a classic checkbox representing a state that is either
    checked or unchecked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Date picker**: This is a control that enables the user to select a date in
    the calendar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input**: This is a classic input control. Material Design enhances the control
    with meaningful animation so you can clearly see when you are typing or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radio button**: This is a classic radio button, and just like with the input
    control, Material Design''s take on this one is to add animations and transitions
    while editing to create a better user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Select**: This is a classic select list where the user is prompted to select
    one or more items from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slider**: The slider enables you to increase or decrease the value by pulling
    a slider button to either the right or the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slide toggle**: This is just a checkbox, but a nicer rendition of it where
    a slider is being slid to the left or to the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The input field is a classic input field, in that you can set different validation
    rules on it. You can however quite easily add the ability to show errors on the
    input field in a nice and reactive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we will need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Associate a `formControl` with our input field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define our input as a `MatInput` and add a validation rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `mat-error` element and a rule for when it should be shown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first bullet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets up an input control for us and a reference to a `formControl` so
    we can listen to changes on the input. This needs to be accompanied with us adding
    a reference in the code to the `app.component.ts` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to add the `matInput` directive to the input and add a validation
    rule, so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add the `mat-error` element and wrap the `mat-input-container`in
    a form element. We need to remember at this point to include the `FormsModule`in
    our root module as well. We also need to set up a rule for when the `mat-error` element
    should be shown, using `*ngIf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous markup sets up the input element and the validation rules of when
    to show, but as mentioned, we need to include the `FormsModule` in our root module
    as a last step, so let''s show what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This all comes together to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e58d9d42-31a6-4bd9-8b72-868ed1a4f978.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the validation error has been triggered, it then looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/680ba77e-ecfa-447b-b21c-b5612739973b.png)'
  prefs: []
  type: TYPE_IMG
- en: We have gone through a subset of all the form controls that Angular Material
    consists of, namely the autocomplete, the checkbox, the date picker, and lastly
    a normal input showcasing a validation error. There are other form controls such
    as radio button, select, slider, and slide toggle that we encourage you to explore
    at your own pace.
  prefs: []
  type: TYPE_NORMAL
- en: Autocomplete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea with autocomplete is to help the user narrow down what possible values
    an input field can have. In a normal input field, you would just type something
    and hope a validation would tell you if what you input is incorrect. With autocomplete,
    you are presented with a list as you type. The list is narrowed down as you type,
    and at any point you can decide to stop typing and instead select an item from
    the list. This is a time saver as you don't have to type the entire item's name,
    and it also enhances correctness as the user is being made to select from a list,
    rather than to type in the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: With this being the complete behavior of autocorrect, it means that we need
    to provide it with a list of possible answers and also an input box in which to
    receive the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set up this control in five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and register all the necessary modules with our root module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `mat-form-field`, containing an input control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `mat-autocomplete` control, this is the list of possible options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the two controls through a view reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a filter that filters down the autocomplete control when the user types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the first step, all our necessary imports. Here we need the
    autocomplete functionality, but as we will be working with forms, and in particular
    reactive forms, we are going to need that module as well. We will also need some
    forms to support the input fields we mean to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to add some markup to the `app.component.html` file template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have defined the input control and added the `matInput`directive.
    We have also added a `formControl`reference. We add that so we can later on listen
    to changes to our input as they happen. Changes to an input are interesting because
    we are able to react to them and filter our list, which is essentially what autocomplete
    does. The next order of business is to define a list of values that we need to
    suggest to the user once they start typing, so let''s do that next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our list, but we lack any connection between the input field and our
    suggestion list. Before we fix that, we first need to look at our component class
    and add some code to it to support the previous markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So far we have defined `matInput` and `mat-autocomplete`separately, now it''s
    time to connect the two. We do that by adding a view reference to `mat-autocomplete` that `matInput` can
    refer to, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And to refer to it in `matInput`, we introduce the `MatAutocomplete` directive,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `matAutocomplete` points to the `auto` view reference, thereby
    the list is triggered when we set focus to the input field and start typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added another useful thing in the preceding code, namely that of hints.
    Adding hints to your input is a great way to convey to the user what should be
    entered in the input field. Adding the attribute `hintLabel`, we are able to tell
    the user what should go into the input field. You can even take it a step further
    by introducing a tip on how they are doing while they are typing by using the `mat-hint`element.
    Let''s zoom in on the preceding code that accomplished what we just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Try to make use of the `hintLabel` and `mat-hint` element where applicable,
    it will help your users greatly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you typed everything in correctly, you should have something that looks
    like this in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc852a3a-8141-4534-80cf-d450dd248db9.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks great! The list is displayed when you put the input in focus. However,
    you notice that the list is not really being filtered down as you type. This is
    because we haven't picked up on the event when you type into the input control.
    So let us do that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listening to input changing means we listen to our form control and its `valueChanges`
    property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look closely, you can see that this is an Observable. This means that
    we can use operators to filter out content we don''t want. Our definition for
    wanted content is `jedis`, that starts with the text we entered in the input box.
    This means we can flesh it out to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need to change our template so the `mat-option` looks at `filteredJedis` instead
    of the `jedis` array, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Testing this out, we see that it seems to work.
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the classic checkbox that holds checked, unchecked, and undetermined
    statuses. It is quite simple to use but you need to import some modules to use
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The markup should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So essentially, just add `<mat-checkbox>` as an element name and make sure to
    bind the `checked` attribute to a property on our component.
  prefs: []
  type: TYPE_NORMAL
- en: Date picker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual with a date picker, you can do a lot more with it than just selecting
    a date from a pop-up calendar. You can disable date ranges, format the date, show
    it on a yearly and monthly basis, and so on. We will only explore how to get up
    and running with it, but we encourage you to explore the documentation for this
    control at [https://material.angular.io/components/datepicker/overview.](https://material.angular.io/components/datepicker/overview)
  prefs: []
  type: TYPE_NORMAL
- en: 'First off we, need to import the necessary modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For the markup, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an input with a `matInput`directive. The selected date will be placed
    here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a `<mat-datepicker>`element. This is the pop-up calendar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a connection between the two controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the first bullet point, we declare it in the markup, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we point out a `formControl` instance called input in our component
    by the use of the `formControl`directive. We also add the `matInput` directive
    to give our input field that nice material look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second task, we define the `<mat-datepicker>` element, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make the connection between them and, just like we did with
    the autocomplete control, we define a view reference, `picker`, in the `<mat-datepicker>` element,
    and refer to that in the input element by assigning the view reference to the `matDatepicker`
    directive, so it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, in summary, we added a view reference to the `mat-datepicker` element, and
    referred to said reference by assigning it to the `[matDatePicker]` directive
    in the input element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added a button that will toggle the visibility of the calendar. We
    made that possible by using the `<mat-datepicker-toggle>` element and assigning
    it the `picker` view reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, your creation should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9294b9d1-4fa6-4045-874f-743306a58984.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigation is how we get around in the application. There are different ways
    for us to do that, such as clicking a link or clicking on a menu item for example.
    Angular Material offers three components for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Menu**: This is a pop-out list where you get to choose from many different
    menu options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sidenav**: This component acts like a menu docked to the left or the right
    of the page and presents itself as an overlay over the application while dimming
    the application content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolbar**: This is typical toolbar that is a way for the user to reach commonly
    used actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will show a full example of using the menu, but we encourage
    you to keep exploring by learning to use the sidenav ([https://material.angular.io/components/sidenav/overview](https://material.angular.io/components/sidenav/overview)),
    as well as the toolbar component ([https://material.angular.io/components/toolbar/overview](https://material.angular.io/components/toolbar/overview)).
  prefs: []
  type: TYPE_NORMAL
- en: Menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The menu component is what it sounds like, it's made for you to easily present
    a menu to the user. It uses three major directives, `mat-menu`, `mat-menu-item`,
    and lastly, `MatMenuTriggerFor`. There is only one `mat-menu` per menu and as
    many `mat-menu-items` as you need. The `MatMenuTriggerFor` is used to trigger
    the menu, you usually attach this one to a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making the menu work can be divided into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `mat-menu` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add as many `mat-menu-items` as you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a trigger to a button by adding the `MatMenuTriggerFor` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we do any of that, we need to import the `MatMenuModule` to be able
    to use the constructs previously mentioned, so let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to define our menu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we add as many items as we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add a trigger by adding a button that will trigger it and the `matMenuTriggerFor` directive,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note how `matMenuTriggerFor` points to the `menu` view reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your finished result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47b0c48c-2f08-4be1-bdac-8f2f5c2be915.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not all menus are this simple of course. Sooner or later you will encounter
    a scenario where you need a menu to be nested. Material UI easily supports this.
    The overall approach to supporting this lies in defining a `mat-menu` definition
    for each menu you need and then connecting them. Then you need to define what
    action leads to what submenu being triggered. Sounds hard? It''s really not. Let''s
    begin with our top-level menu, our root menu. Let''s give the menu items some
    meaningful names, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have two menu items and the last one, `wxport`, begs for
    some suboptions. Imagine we are dealing with tabular data in a program, it would
    make sense to support exporting that data to either CSV or PDF. Let''s add a submenu
    for just that, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so now we have two different menus, but we need to add the connection where
    a `rootMenu` item triggers the `subMenu` to show. Let''s add that by again using
    the `matMenutriggerFor` directive, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This should render a menu that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1817adcb-9507-4b09-8b98-7956462229c8.png)'
  prefs: []
  type: TYPE_IMG
- en: There are more things you can do with a menu than just rendering a few menu
    items and have them triggered by a button. Other things to consider and try out
    are making it more professional looking by adding an icon or catering to accessibility.
    Now that you know the basics of how to create a simple menu as well as nested
    ones, go and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layout is about defining how we place the content on our page. Angular Material
    gives us different components for this purpose, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List**: This is a way to present your content as a list of items. The list
    can be enriched with links, icons, and can even be multiline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grid list**: This is a control that helps you arrange your content in blocks.
    You need to define the number of columns, and the component will make sure to
    fill out the visual space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Card**: This is a component that wraps content and adds a box shadow. You
    can define a header for it as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabs**: This lets you divide up your content between different tabs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stepper**: This is a component that divides up your component in wizard-like
    steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expansion panel**: This component works pretty much like an accordion, in
    that it enables you to lay out your components in a list-like way with a title
    for each item. Each item can be expanded, and only one item can be expanded at
    a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover the list and grid list components. We urge you
    to explore the card component, [https://material.angular.io/components/card/overview](https://material.angular.io/components/card/overview),
    the tabs component, [https://material.angular.io/components/tabs/overview](https://material.angular.io/components/tabs/overview),
    the stepper, [https://material.angular.io/components/stepper/overview](https://material.angular.io/components/stepper/overview),
    and the expansion panel, [https://material.angular.io/components/expansion/overview](https://material.angular.io/components/expansion/overview),
    at your own volition.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list control is built up by a `mat-list` element and a number of `mat-list-items`.
    The markup for this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, that is all there is to it. For your effort, you are awarded with
    a list that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f1291ad9-0f13-4887-a14a-3c56bf2779ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A list can, of course, be a lot more complicated, containing links, icons,
    and more. A more interesting example may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30b2a9f4-790a-4738-b683-c29034da030b.png)'
  prefs: []
  type: TYPE_IMG
- en: I think you get the idea, there are list items and I can put pretty much put
    anything I want in them. To read more about the capabilities, here is the link
    to the list documentation: [https://material.angular.io/components/list/overview.](https://material.angular.io/components/list/overview)
  prefs: []
  type: TYPE_NORMAL
- en: Grid list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The grid list is used to display your content in a list of rows and columns,
    while ensuring that it fills out the viewport. This is a very nice component if
    you want maximum freedom of deciding how to display content. This is a separate
    module called `MatGridListModule`. We need to add this to our list of imported
    modules, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The component consists of a `mat-grid-list` element and a number of `mat-grid-tile`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `mat-grid-list` element first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Worth noting is how we set the number of columns and the height of each row.
    Now it''s time to add the content. We do that by adding a number of `mat-grid-tile`
    instances, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here we are defining an `*ngFor` to point to our list of tiles. We also bind
    to `[colspan]`, that decides how much column space it should take, `[rowspan]`,
    that determines how many rows it should take, and lastly, we bind to the background
    property in our style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We encourage you to explore the card and tabs component to learn more about
    the remaining layout components.
  prefs: []
  type: TYPE_NORMAL
- en: Popups and modals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways that we can capture the user's attention. One way is
    to show a dialog over the content of the page and prompt the user to act. Another
    way is to display information about a part of the page when the user hovers over
    that particular part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular Material offers three different components for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dialog**: This is simply a modal dialog displaying itself on top of the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tooltip**: This displays a piece of text when you hover over a specified
    area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snackbar**: This shows an information message at the bottom of a page. The
    information message is only visible for a short amount of time. It is meant to
    convey to the user that something has happened as a result of an action, such
    as saving a form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dialog component is quite powerful as it helps us create a modal. It can
    be customized to your heart''s content and is a bit tricky to set up. But don''t
    worry, we will guide you through the process. What we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the dialog module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a component that is our dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a component and a button that will trigger the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add our dialog to the `entryComponents` property of our module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First off, we import the necessary module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we create a component that will hold our dialog. It is a normal component
    with a template and a backing class, but it does need to inject a `MatDialogRef`.
    It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done here is define the following general structure in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At a quick glance, we define a title, a content, and an action field, where
    buttons are defined. To send different values back we use `[mat-dialog-close]` and
    assign a value to it.
  prefs: []
  type: TYPE_NORMAL
- en: As for the code part, we inject an instance of `MatDialogRef` that is typed
    to `MyDialog`, which is the very component we are in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third thing we need to do is to set up a host component, in which there
    is a button that, when clicked, will launch a dialog. So let''s do that with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We do two things here, we call `dialog.open()` with a type, which is our dialog
    component. Furthermore, by listening to the Observable we get back when calling 
     `dialogRef.afterClosed()` , we are able to inspect the result coming back from
    the dialog. At this point there isn't much of a result to look at but in the next
    section we will look at a more advanced dialog example where we use this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to go to our `app.module.ts` file and add our`DialogComponent`
    dialog to the`entryComponents` array, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: So, adding things to the `entryComponents`array in an Angular module is a completely
    new concept to us, what does it actually do? When we add a component to that list
    we tell the compiler that this component needs to be compiled and needs a `ComponentFactory`so
    we can create it on the fly. Thus, the criteria for putting any component in here
    is that we want to load a component dynamically or by type. This is exactly the
    case with our `DialogComponent`. It doesn't actually exist before we call   `this.dialog.open(DialogComponent)`.
    At that point, it runs a method under the hood called   `ViewContainerRef.createComponent()`.
    In short, we need to instantiate the `DialogComponent`every time we wish to open
    it. So, don't forget about `entryComponents`or it won't work. You can read more
    on `entryComponents` at[https://angular.io/guide/ngmodule-faq#what-is-an-entry-component.](https://angular.io/guide/ngmodule-faq#what-is-an-entry-component)
  prefs: []
  type: TYPE_NORMAL
- en: 'Your dialog will end up looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68bb581e-a501-4d9f-bb43-fa6c840157fc.png)'
  prefs: []
  type: TYPE_IMG
- en: A more advanced example – sending data to and from your dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we introduced a simple dialog example where we learned to open the
    dialog and close it. That barely scratched the surface. What is really interesting
    is how we would send data to the dialog so it comes prebooted with some data,
    and also how we would send data we gather inside of the dialog back to the host
    component that opened it. We will look at both these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The business case for sending data to the dialog, so it starts with some data,
    is so that we can, for example, show an existing record and make updates to it
    in the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding a second argument to the method `dialog.open()` we are able to send
    data to the dialog component that it can display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'On the dialog component side of things, we need to tell it about the data we
    are sending in. We do that by injecting `MAT_DIALOG_DATA`, the needed changes
    are in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, because we have sent the data bound `jedi`instance from the `host` class,
    any changes we do to it in the `Dialog` class will be reflected in the `host`
    class. That takes care of sending data from the `host` class to the dialog, but
    what if we want to send data from dialog back? We can easily accomplish that by
    sending a parameter in the `dialogRef.close()` method call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To do something with that data, we simply subscribe to the Observable we get
    from calling   `afterClose()`. This is illustrated in bold as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Data table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways we can show the data. Showing it in rows and columns
    is an efficient way of getting a quick overview. You might, however, need to sort
    the data by column to quickly zoom in on the interesting data. Also, the amount
    of data might be so great that it needs to be shown in parts, by page. Angular
    Material addresses these issues by offering the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table**: This lays out the data in rows and columns, with headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sort table**: This allows you to sort your data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paginator**: This allows you to slice up your data in pages while allowing
    you to navigate between pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be said that in most cases when trying to add a table to your app,
    it is expected that a table can be sorted and that the data can be paged so as
    not to completely overwhelm the user. Let's therefore have a look at how to achieve
    all of this step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The table component is able to let us present our data in columns and rows.
    We need to do the following to get a table component up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and register the `MatTableModule` in our root module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the data that we mean to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the markup for our table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first order of business is to import the necessary module, and that is
    easily done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we start constructing our data and create an instance of the
    `MatTableDataSource` class. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Noteworthy here is how we construct a `MatTableDataSource`instance out of an
    array of objects. We will use this instance in the markup and point it out as
    the data source. The next thing to do is construct the markup needed to support
    this table. The code for that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We have pointed out several points of interest in the previous code. Columns
    for the table are constructed by creating an `ng-container` element containing
    in turn a `mat-header-cell`, where the title is defined, and a `mat-cell`where
    we say what data should go in there. The `mat-header-row` element, further down
    in the code, enables us to point out the order in which the columns should appear.
    We can see in our previous code snippet how this is just an array of strings.
    Finally, with the `mat-row` element, we simple display all the rows of our table.
    The end result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/209f1380-8c94-44b2-9f78-02cefb7a73b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous figure constitutes a nice looking table, but it lacks a pretty
    standard functionality, namely that of sorting. We expect that by clicking the
    header it will sort into ascending and descending respectively, and that it is
    able to recognize common data types such as strings and integers, and sort those
    correctly. The good news is that this is very easy to achieve. We need to do the
    following to ensure that our table can be sorted:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and register the `MatSortModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `ViewChild` of type `MatSort` and assign it to the `dataSources` sort
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the directive `matSortHeader` to the headers that should be able to be sorted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We complete the first step by adding the following code to the root module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we go into our component and add the `MatSort ViewChild` and assign
    it to the sort property, as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we need to fix the markup and then sorting should work. The
    changes we need to make to the markup are to simply apply the `matSort` directive
    to the whole table and`mat-sort-header`to each header that should be possible
    to sort. The code for the markup is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The UI should now indicate with an arrow by the column **Name**, the direction
    in which the data is being sorted, as the following image indicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3258351f-45cb-4f1d-9c0d-bdfd5915c036.png)'
  prefs: []
  type: TYPE_IMG
- en: Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our table so far is starting to look quite good. It can even be sorted, besides
    from displaying data. We are aware though that in most cases the data for a table
    is usually quite long, which leads to the user either having to scroll or browse
    the data page by page. We can solve the latter option with the help of the pagination
    element. To use it, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and register the `MatPaginatorModule`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign a `paginator ViewChild` instance to the data source's paginator property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `mat-paginator` element to the markup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Starting with the first item on our list, we need to add the following code
    to our root module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we need to add assign the `paginator` property to our   `tableSource.paginator`,
    as described previously. The code for that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Our remaining part is just to change the markup, which should have the following
    alterations (changes in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here, we clearly show that the only addition to our markup was the `mat-paginator`
    element at the bottom. Here, we specify our view reference, but also the page
    size as well as what pages we should be able to switch to, should we want to.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We set about trying to explain what Material Design is, a design language with
    paper and ink in mind. Thereafter, we mentioned the most well-known implementations
    of Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we put most of our focus on Angular Material, the Material Design implementation
    meant for Angular, and how it consists of different components. We went hands-on
    in explaining how to install it, set it up, and even how to use different form
    controls and input buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Time was also spent covering other aspects of the components, such as layout,
    navigation, modals, and tabular data. Hopefully, you will have read this chapter
    and found that you now have a grasp of Material Design in general and Angular
    Material in particular, and can determine whether it is a good match for your
    next Angular app.
  prefs: []
  type: TYPE_NORMAL
