- en: Chapter 9.  Reactive Extensions in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll talk about Reactive extensions in PHP, a PHP library
    that allows PHP programmers to work with PHP in a reactive manner, and how to
    use in event, also known as publish-subscribe programming. We''ll also discuss
    the idea of functional programming in PHP and how to program in a more succinct
    way. We will also discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reactive extensions in the following use cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data analysis of logs (parsing Apache logs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queueing systems (asynchronously working through a queue of tasks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive extensions are a way to code in a functional way using PHP. They are
    a set of libraries (available on GitHub at [https://github.com/ReactiveX/RxPHP](https://github.com/ReactiveX/RxPHP))
    that can help you compose event-based programs by using observable collections
    and LINQ-style query operators in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, you will be doing event-driven programming, where you will work with
    what's called as the event loop, and attaching (hooking up) events to do your
    bidding.
  prefs: []
  type: TYPE_NORMAL
- en: Installation is a simple composer that is required is all.
  prefs: []
  type: TYPE_NORMAL
- en: How does Reactive PHP work? In PHP, there is no such way to create a server
    except when running the code `php -S localhost:8000`. PHP will treat the current
    directory as the basis of the public directory (in Apache, usually this is `/var/www`
    or `C:/xampp/htdocs` when using  **XAMPP**). This, by the way, has been available
    since PHP 5.4.0 only and also works with PHP 7.x.
  prefs: []
  type: TYPE_NORMAL
- en: There is no programmable way to control how that PHP command-line interface's
    server actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you send a request to that server, PHP server will be in charge of
    handling whether it's a valid request, and handle the event by itself. In short,
    every request is a new request-there's no streaming or events that get involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**RxPHP** works by creating an event loop by creating a PHP stream under the
    hood, which has added functions that help make **Reactive Programming** possible.
    The stream basically has a recursive function (a function that keeps calling itself
    and creates a loop of commands, in essence). An event loop is basically a programming
    construct that runs an infinite loop, which simply waits for events and be able
    to react (in other words, run some function) to each of those events.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to event loop and ReactiveX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to get acquainted with event loop is through a popular library
    in the JavaScript world, that is, jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience working with jQuery, you can simply create (or chain)
    events to a simple DOM selector and then write code to handle those specific events.
    For example, you could create an `onClick` event by attaching it to a specific
    link and then code what will happen when that link is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re familiar with jQuery, the code to control a link that has the ID
    `someLink` would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, every time jQuery finds an element with an ID
    of `someLink`, it will do something on each click event.
  prefs: []
  type: TYPE_NORMAL
- en: As it is in an event loop, it will loop over each *iteration* of the event loop
    and work on what needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is a little bit different in Reactive Programming, which is a form
    of functional programming. Functional programming is about keeping functions as
    pure as possible and does not have side effects. Another aspect of functional
    programming is immutability, but we'll discuss that in another part.
  prefs: []
  type: TYPE_NORMAL
- en: In Reactive Programming, we basically have the concept of **Observables** and
    **Observers**.
  prefs: []
  type: TYPE_NORMAL
- en: An Observable emits events in the form of data, and an Observer subscribes to
    the Observable in order to receive its events.
  prefs: []
  type: TYPE_NORMAL
- en: The point of programming using Reactive extensions is to be able to program
    in a more *functional* manner. Instead of programming a `while`, `for` loop we
    instead invoke an event loop, which will track the Observers and their Observables
    (subscribers). The good thing about programming in this way is that there is a
    way to treat data as data that streams into your program over time. By feeding
    information this way, we can now make event-based or event-driven programs, where
    your code will react.
  prefs: []
  type: TYPE_NORMAL
- en: With this you can create programs that run forever in the background and just
    Reactive extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some available functions of Reactive extensions:'
  prefs: []
  type: TYPE_NORMAL
- en: delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: recursive-scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map` and `flatMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: toArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: merge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: delay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `delay` function in RxPHP is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an `EventLoopScheduler`, which will help us
    schedule the execution of code by an interval of 1,000 milliseconds. The delay
    function is given 500 milliseconds to execute, and a take function will only take
    5 milliseconds before finally subscribing.
  prefs: []
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The  `defer` function waits for *X* number of iterations before doing what
    is to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an Observable object, which will return 42
    when the `defer` function is called. The `defer` function s a type of promise
    and returns an Observable, and the code inside it will be executed in an asynchronous
    manner. When the Observable is subscribed to, the functions are in a way *tied*
    together or *bound* to each other and then get *invoked* or *triggered*.
  prefs: []
  type: TYPE_NORMAL
- en: What is an Observable, you might ask? In ReactiveX, an Observer subscribes to
    an Observable. An Observer then reacts to whatever item or sequence of items that
    the Observable emits.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when you have a bunch of events that are being sent to your
    application, but handle them in an asynchronous manner, meaning not necessarily
    in the order that they may have come in.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `stdoutObserver` is an observer that puts out whatever
    is in the event loop or the Observable into the `stdout` or console log.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Schedulers work with three main components: an execution context, which is
    the ability to *do* the job given to it; the execution policy is *how* it will
    be ordered; and there''s the clock or timer or the underlying system which measures
    time, which is needed to schedule *when* it will be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The scheduler code is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It basically creates an `eventScheduler`, which executes the event loop and
    parameterizes the concurrency level. A simple scheduler within RxPHP is used in
    the preceding delay.
  prefs: []
  type: TYPE_NORMAL
- en: recursive-scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how the recursive-scheduler function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works by adding several scheduler timers, which then recursively
    or repeatedly return an Observable and then subscribe to it afterward. The preceding
    code will generate 21 Observables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what happens after 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, it will dispose the Observables and finally print out the memory
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: map and flatMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `map` is a simple function that takes another function and loops through or
    iterates through a bunch of elements (an Array), and applies or invokes the function
    passed into each of those elements.
  prefs: []
  type: TYPE_NORMAL
- en: A `flatMap`, on the other hand, subscribes to the Observable as well, meaning
    that you no longer have to take care of.
  prefs: []
  type: TYPE_NORMAL
- en: reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `reduce` function simply applies a function to Observables coming in. In
    short, it takes a bunch of Observables and applies a function to all of them in
    a sequential manner, applying one to the next result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use a `reduce` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: toArray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `toArray` function lets you manipulate Observables and create an array
    from them. The code to use `toArray` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first create an Observable based on the Array `[1,2,3,4]`.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to work with the values of an array and subscribe to them using
    the Observer. In ReactiveX programming, every Observer only works with Observables.
    In short, the `toArray` function allows us to create Observers that subscribe
    to a source array.
  prefs: []
  type: TYPE_NORMAL
- en: merge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `merge` function is simply an operator that combines multiple Observables
    into one by merging their emissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any `onError` notification from any of the source Observables will be immediately
    passed through to the Observers. This will terminate the merged Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `do` function simply registers an action to take upon a variety of Observable
    life cycle events. Basically, you will register callbacks that ReactiveX will
    call only when certain events take place in the Observable. The callbacks will
    be called independently from the normal set of notifications. There are various
    operators that RxPHP have designed to allow this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `scan` operator applies a function to each item that an Observable emits.
    It applies this sequentially and emits each successive value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of `scan` without a seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `zip` method returns an Observable and applies a function of your choosing
    to the combination of items emitted in sequence. The results of this function
    will become the items emitted by the returned Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following sample code, we use `zip` without a result selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Parsing logs through a Reactive scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is difficult to just have theoretical knowledge of Reactive extensions and
    functional programming techniques and not be able to know when it can be used.
    In order to apply our knowledge, let's take a look at the following scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we have to read an Apache log file in an asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Apache log line looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's dissect the parts of each line.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have the IP address. It has three dots in between some numbers. Second,
    we have the field that logs the domain of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Third, we have the date and time. Then we get the string, which says what was
    accessed and using what HTTP protocol. The status is 200, followed by the process
    ID and, finally, the name of the requestor, also known as the referrer.
  prefs: []
  type: TYPE_NORMAL
- en: When reading the Apache logs, we just want the IP address, the URL, and the
    date and time of access, and we also want to know what browser was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know we can dissect the data into the spaces between them, so let''s just
    change the logs into arrays split by the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's add an Observable so that we can execute the preceding function asynchronously,
    meaning it will work by reading the log file every hour.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Event queues with ReactiveX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event queue would simply ensure that things that are to be done in a synchronous
    manner or in a first-in first-out manner. Let's define first what a queue is.
  prefs: []
  type: TYPE_NORMAL
- en: A queue is basically a list of things to do, which will get executed one by
    one until all the things in the queue have been finished.
  prefs: []
  type: TYPE_NORMAL
- en: In Laravel, for example, there is already a concept of queues, where we go through
    the elements of the queue. You can find the documentation at [https://laravel.com/docs/5.0/queues](https://laravel.com/docs/5.0/queues)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Queues are usually used in systems that need to do some tasks in order and not
    in an asynchronous function. In PHP, there is already the `SplQueue` class, which
    provides the main functionalities of a queue implemented using a doubly linked
    list.
  prefs: []
  type: TYPE_NORMAL
- en: In general, queues are executed in the order that they come in. In ReactiveX,
    things are more of an asynchronous nature. In this scenario, we will implement
    a priority queue, where each task has corresponding levels of priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a simple `PriorityQueue` code in ReactiveX would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the `PriorityQueue` library of RxPHP. We set
    some schedulers and queued them in a `PriorityQueue`. We gave each scheduled item
    a priority or time to spend in execution with 1 and 2\. In the preceding scenario,
    the first item will execute first because it is the first priority and has the
    shortest time (1). Finally, we remove the `ScheduledItem` just to show what's
    possible with `PriorityQueue` in the RxPHP library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned to work with the Reactive extensions library, RxPHP. Reactive Programming
    is all about using Observables and Observers, which is similar to working with
    subscribers and publishers.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use `delay`, `defer`, `map`, and `flatMap`, among other operators,
    and how to use a scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to read an Apache log file and schedule it to read after
    every hour and how to work with RxPHP's `PriorityQueue` class.
  prefs: []
  type: TYPE_NORMAL
