- en: Chapter 2. Relational Databases with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational databases are the bedrock upon which almost every modern Web application
    is built. Learning to think about your application in terms of tables and relationships
    is one of the keys to a clean, well-designed project. As you will see in this
    chapter, the data model you choose early on will affect almost every facet of
    the code that follows. We will be using SQLAlchemy, a powerful object relational
    mapper that allows us to abstract away the complexities of multiple database engines,
    to work with the database directly from within Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Present a brief overview of the benefits of using a relational database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce SQLAlchemy, the Python SQL Toolkit and Object Relational Mapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure our Flask application to use SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a model class to represent blog entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to save and retrieve blog entries from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform queries – sorting, filtering, and aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a tagging system for blog entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create schema migrations using Alembic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use a relational database?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application's database is much more than a simple record of things that
    we need to save for future retrieval. If all we needed to do was save and retrieve
    data, we could easily use flat text files. The fact is, though, that we want to
    be able to perform interesting queries on our data. What's more, we want to do
    this efficiently and without reinventing the wheel. While non-relational databases
    (sometimes known as NoSQL databases) are very popular and have their place in
    the world of the web, relational databases long ago solved the common problems
    of filtering, sorting, aggregating, and joining tabular data. Relational databases
    allow us to define sets of data in a structured way that maintains the consistency
    of our data. Using relational databases also gives us, the developers, the freedom
    to focus on the parts of our app that matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to efficiently performing ad hoc queries, a relational database
    server will also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that our data conforms to the rules set forth in the schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow multiple people to access the database concurrently, while at the same
    time guaranteeing the consistency of the underlying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that data, once saved, is not lost even in the event of an application
    crash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational databases and SQL, the programming language used with relational
    databases, are topics worthy of an entire book. Because this book is devoted to
    teaching you how to build apps with Flask, I will show you how to use a tool that
    has been widely adopted by the Python community for working with databases, namely,
    SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy abstracts away many of the complications of writing SQL queries,
    but there is no substitute for a deep understanding of SQL and the relational
    model. For that reason, if you are new to SQL, I would recommend that you check
    out the colorful book *Learn SQL the Hard Way*, *Zed Shaw* available online for
    free at [http://sql.learncodethehardway.org/](http://sql.learncodethehardway.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQLAlchemy is an extremely powerful library for working with relational databases
    in Python. Instead of writing SQL queries by hand, we can use normal Python objects
    to represent database tables and execute queries. There are a number of benefits
    to this approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application can be developed entirely in Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtle differences between database engines are abstracted away. This allows
    you to do things just like a lightweight database, for instance, use SQLite for
    local development and testing, then switch to the databases designed for high
    loads (such as PostgreSQL) in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database errors are less common because there are now two layers between your
    application and the database server: the Python interpreter itself (this will
    catch the obvious syntax errors), and SQLAlchemy, which has well-defined APIs
    and its own layer of error-checking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your database code may become more efficient, thanks to SQLAlchemy's unit-of-work
    model that helps reduce unnecessary round-trips to the database. SQLAlchemy also
    has facilities for efficiently pre-fetching related objects known as eager loading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Relational Mapping** (**ORM**) makes your code more maintainable,
    an aspiration known as **don''t repeat yourself**, (**DRY**). Suppose you add
    a column to a model. With SQLAlchemy it will be available whenever you use that
    model. If, on the other hand, you had hand-written SQL queries strewn throughout
    your app, you would need to update each query, one at a time, to ensure that you
    were including the new column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy can help you avoid SQL injection vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Excellent library support: As you will see in later chapters, there are a multitude
    of useful libraries that can work directly with your SQLAlchemy models to provide
    things such as maintenance interfaces and RESTful APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I hope you're excited after reading this list. If all the items in this list
    don't make sense to you right now, don't worry. As you work through this chapter
    and the subsequent ones, these benefits will become more apparent and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed some of the benefits of using SQLAlchemy, let's install
    it and start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you'd like to learn more about SQLAlchemy, there is a chapter devoted entirely
    to its design in *The Architecture of Open-Source Applications*, available online
    for free at [http://aosabook.org/en/sqlalchemy.html](http://aosabook.org/en/sqlalchemy.html).
  prefs: []
  type: TYPE_NORMAL
- en: Installing SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `pip` to install SQLAlchemy into the blog app''s virtualenv. As
    you will recall from the previous chapter, to activate your virtualenv, change
    directories to `source` the `activate` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can check if your installation succeeded by opening a Python interpreter
    and checking the SQLAlchemy version; note that your exact version number is likely
    to differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using SQLAlchemy in our Flask app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLAlchemy works very well with Flask on its own, but the author of Flask has
    released a special Flask extension named **Flask-SQLAlchemy** that provides helpers
    with many common tasks, and can save us from having to re-invent the wheel later
    on. Let''s use `pip` to install this extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Flask provides a standard interface for the developers who are interested in
    building extensions. As the framework has grown in popularity, the number of high-quality
    extensions has increased. If you'd like to take a look at some of the more popular
    extensions, there is a curated list available on the Flask project website at
    [http://flask.pocoo.org/extensions/](http://flask.pocoo.org/extensions/).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a database engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy supports a multitude of popular database dialects, including SQLite,
    MySQL, and PostgreSQL. Depending on the database you would like to use, you may
    need to install an additional Python package containing a database driver. Listed
    next are several popular databases supported by SQLAlchemy and the corresponding
    pip-installable driver. Some databases have multiple driver options, so I have
    listed the most popular one first.
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Driver Package(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite | Not needed, part of the Python standard library since version 2.5
    |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | MySQL-python, PyMySQL (pure Python), OurSQL |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | psycopg2 |'
  prefs: []
  type: TYPE_TB
- en: '| Firebird | fdb |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft SQL Server | pymssql, PyODBC |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle | cx-Oracle |'
  prefs: []
  type: TYPE_TB
- en: SQLite comes as standard with Python and does not require a separate server
    process, so it is perfect for getting up-and-running quickly. For simplicity in
    the examples that follow, I will demonstrate how to configure the blog app for
    use with SQLite. If you have a different database in mind that you would like
    to use for the blog project, feel free to use `pip` to install the necessary driver
    package at this time.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using your favorite text editor, open the `config.py` module for our blog project
    (`~/projects/blog/app/config.py`). We are going to add a SQLAlchemy-specific setting
    to instruct Flask-SQLAlchemy how to connect to our database. The new lines are
    highlighted in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SQLALCHEMY_DATABASE_URI` comprises the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect+driver://username:password@host:port/database`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because SQLite databases are stored in local files, the only information we
    need to provide is the path to the database file. On the other hand, if you wanted
    to connect to PostgreSQL running locally, your URI might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postgresql://postgres:secretpassword@localhost:5432/blog_db`'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you''re having trouble connecting to your database, try consulting the SQLAlchemy
    documentation on database URIs: [http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html](http://docs.sqlalchemy.org/en/rel_0_9/core/engines.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve specified how to connect to the database, let''s create the
    object responsible for actually managing our database connections. This object
    is provided by the Flask-SQLAlchemy extension and is conveniently named `SQLAlchemy`.
    Open `app.py` and make the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These changes instruct our Flask app, and in turn SQLAlchemy, how to communicate
    with our application's database. The next step will be to create a table for storing
    blog entries and, to do so, we will create our first model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Entry model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **model** is the data representation of a table of data that we want to store
    in the database. These models have attributes called **columns** that represent
    the data items in the data. So, if we were creating a `Person` model, we might
    have columns for storing the first and last name, date of birth, home address,
    hair color, and so on. Since we are interested in creating a model to represent
    blog entries, we will have columns for things like the title and body content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't say a `People` model or `Entries` model – models are singular
    even though they commonly represent many different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'With SQLAlchemy, creating a model is as easy as defining a class and specifying
    a number of attributes assigned to that class. Let''s start with a very basic
    model for our blog entries. Create a new file named `models.py` in the blog project''s
    `app/` directory and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot going on, so let's start with the imports and work our way down.
    We begin by importing the standard library `datetime` and `re` modules. We will
    be using `datetime` to get the current date and time, and `re` to do some string
    manipulation. The next import statement brings in the `db` object that we created
    in `app.py`. As you recall, the `db` object is an instance of the `SQLAlchemy`
    class, which is a part of the Flask-SQLAlchemy extension. The `db` object provides
    access to the classes that we need to construct our `Entry` model, which is just
    a few lines ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Before the `Entry` model, we define a helper function `slugify`, which we will
    use to give our blog entries some nice URLs (used in [Chapter 3](ch03.html "Chapter 3. Templates
    and Views"), *Templates and Views*). The `slugify` function takes a string such
    as *A post about Flask* and uses a regular expression to turn a string that is
    human-readable in to a URL, and so returns *a-post-about-flask*.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `Entry` model. Our `Entry` model is a normal class that extends
    `db.Model`. By extending `db.Model`, our `Entry` class will inherit a variety
    of helpers that we'll use to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attributes of the `Entry` model, are a simple mapping of the names and
    data that we wish to store in the database and are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the primary key for our database table. This value is set for
    us automatically by the database when we create a new blog entry, usually an auto-incrementing
    number for each new entry. While we will not explicitly set this value, a primary
    key comes in handy when you want to refer one model to another, as you''ll see
    later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: The title for a blog entry, stored as a `String` column with a maximum
    length of 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: The URL-friendly representation of the title, stored as a `String`
    column with a maximum length of 100\. This column also specifies `unique=True`,
    so that no two entries can share the same slug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: The actual content of the post, stored in a `Text` column. This differs
    from the `String` type of the `Title` and `Slug` as you can store as much text
    as you like in this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_timestamp`: The time a blog entry was created, stored in a `DateTime`
    column. We instruct SQLAlchemy to automatically populate this column with the
    current time by default when an entry is first saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modified_timestamp`: The time a blog entry was last updated. SQLAlchemy will
    automatically update this column with the current time whenever we save an entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For short strings such as titles or names of things, the `String` column is
    appropriate, but when the text may be especially long it is better to use a `Text`
    column, as we did for the entry body.
  prefs: []
  type: TYPE_NORMAL
- en: We've overridden the constructor for the class (`__init__`) so that, when a
    new model is created, it automatically sets the slug for us based on the title.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece is the `__repr__` method that is used to generate a helpful representation
    of instances of our `Entry` class. The specific meaning of `__repr__` is not important
    but allows you to reference the object that the program is working with, when
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final bit of code needs to be added to main.py, the entry-point to our application,
    to ensure that the models are imported. Add the highlighted changes to main.py
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Entry table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to start working with the `Entry` model, we first need to create a
    table for it in our database. Luckily, Flask-SQLAlchemy comes with a nice helper
    for doing just this. Create a new sub-folder named `scripts` in the blog project''s
    `app` directory. Then create a file named `create_db.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `create_db.py` module. This function will automatically
    look at all the code that we have written and create a new table in our database
    for the `Entry` model based on our models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the script from inside the `app/` directory. Make sure the virtualenv
    is active. If everything goes successfully, you should see no output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you encounter errors while creating the database tables, make sure you are
    in the app directory, with the virtualenv activated, when you run the script.
    Next, ensure that there are no typos in your `SQLALCHEMY_DATABASE_URI` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Entry model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's experiment with our new `Entry` model by saving a few blog entries. We
    will be doing this from the Python interactive shell. At this stage let's install
    **IPython**, a sophisticated shell with features such as tab-completion (that
    the default Python shell lacks).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now check whether we are in the `app` directory and let''s start the shell
    and create a couple of entries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with the normal Python shell but not IPython, things may
    look a little different at first. The main thing to be aware of is that `In[]`
    refers to the code you type in, and `Out[]` is the output of the commands you
    put into the shell.
  prefs: []
  type: TYPE_NORMAL
- en: IPython has a neat feature that allows you to print detailed information about
    an object. This is done by typing in the object's name followed by a question-mark
    (?). Introspecting the `Entry` model provides a bit of information, including
    the argument signature and the string representing that object (known as the `docstring`)
    of the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create `Entry` objects by passing column values in as the keyword-arguments.
    In the preceding example, it uses `**kwargs`; this is a shortcut for taking a
    `dict` object and using it as the values for defining the object, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to save our first entry, we will to add it to the database session.
    The session is simply an object that represents our actions on the database. Even
    after adding it to the session, it will not be saved to the database yet. In order
    to save the entry to the database, we need to commit our session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code examples, once we commit the session,
    a unique id will be assigned to our first entry and the `created_timestamp` will
    be set to the current time. Congratulations, you've created your first blog entry!
  prefs: []
  type: TYPE_NORMAL
- en: Try adding a few more on your own. You can add multiple entry objects to the
    same session before committing, so give that a try as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At any point while you are experimenting, feel free to delete the `blog.db`
    file and re-run the `create_db.py` script to start over with a fresh database.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to an existing entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to make changes to an existing `Entry`, simply make your edits and
    then commit. Let''s retrieve our `Entry` using the id that was returned to us
    earlier, make some changes, and commit it. SQLAlchemy will know that it needs
    to be updated. Here is how you might make edits to the first entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And just like that your changes are saved.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting an entry is just as easy as creating one. Instead of calling `db.session.add`,
    we will call `db.session.delete` and pass in the `Entry` instance that we wish
    to remove.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving blog entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While creating, updating, and deleting are fairly straightforward operations,
    the real fun starts when we look at ways to retrieve our entries. We'll start
    with the basics, and then work our way up to more interesting queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a special attribute on our model class to make queries: `Entry.query`.
    This attribute exposes a variety of APIs for working with the collection of entries
    in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s simply retrieve a list of all the entries in the `Entry` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in this example the query returns a list of `Entry` instances
    that we created. When no explicit ordering is specified, the entries are returned
    to us in an arbitrary order chosen by the database. Let''s specify that we want
    the entries returned to us in an alphabetical order by title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Shown next is how you would list your entries in reverse-chronological order,
    based on when they were last updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Filtering the list of entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very useful to be able to retrieve the entire collection of blog entries,
    but what if we want to filter the list? We could always retrieve the entire collection
    and then filter it in Python using a loop, but that would be very inefficient.
    Instead we will rely on the database to do the filtering for us, and simply specify
    the conditions for which entries should be returned. In the following example,
    we will specify that we want to filter by entries where the title equals `'First
    entry'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If this seems somewhat magical to you, it's because it really is! SQLAlchemy
    uses operator overloading to convert expressions such as `<Model>.<column> ==
    <some value>` into an abstracted object called `BinaryExpression`. When you are
    ready to execute your query, these data-structures are then translated into SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `BinaryExpression` is simply an object that represents the logical comparison
    and is produced by over riding the standards methods that are typically called
    on an object when comparing values in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to retrieve a single entry, you have two options: `.first()` and `.one()`.
    Their differences and similarities are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Number of matching rows | first() behavior | one() behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Return the object | Return the object |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Return `None` | Raise `sqlalchemy.orm.exc.NoResultFound` |'
  prefs: []
  type: TYPE_TB
- en: '| 2+ | Return the first object (based on either explicit ordering or the ordering
    chosen by the database) | Raise `sqlalchemy.orm.exc.MultipleResultsFound` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s try the same query as before but, instead of calling `.all(),` we will
    call `.first()` to retrieve a single `Entry` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how previously `.all()` returned a list containing the object, whereas
    `.first()` returned just the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Special lookups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example we tested for equality, but there are many other types
    of lookups possible. In the following table, we have listed some that you may
    find useful. A complete list can be found in the SQLAlchemy documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.title == ''The title'' | Entries where the title is "The title", case-sensitive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.title != ''The title'' | Entries where the title is not "The title".
    |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.created_timestamp < datetime.date(2014, 1, 25) | Entries created before
    January 25, 2014\. For less than or equal, use <=. |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.created_timestamp > datetime.date(2014, 1, 25) | Entries created after
    January 25, 2014\. For greater than or equal, use >=. |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.body.contains(''Python'') | Entries where the body contains the word
    "Python", case-sensitive. |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.title.endswith(''Python'') | Entries where the title ends with the
    string "Python", case-sensitive. Note that this will also match titles that end
    with the word "CPython", for example. |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.title.startswith(''Python'') | Entries where the title starts with
    the string "Python", case-sensitive. Note that this will also match titles such
    as "Pythonistas". |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.body.ilike(''%python%'') | Entries where the body contains the word
    "python" anywhere in the text, case-insensitive. The "%" character is a wild card.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Entry.title.in_([''Title one'', ''Title two'']) | Entries where the title
    is in the given list, either ''Title one'' or ''Title two''. |'
  prefs: []
  type: TYPE_TB
- en: Combining expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The expressions listed in the preceding table can be combined using bitwise
    operators to produce arbitrarily complex expressions. Let''s say we want to retrieve
    all blog entries that have the word `Python` or `Flask` in the title. To accomplish
    this, we will create two `contains` expressions, then combine them using Python''s
    bitwise `OR` operator, which is a pipe `|` character, unlike a lot of other languages
    that use a double pipe `||` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using bitwise operators, we can come up with some pretty complex expressions.
    Try to figure out what the following example is asking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you probably guessed, this query returns all entries where the title contains
    either `Python` or `Flask`, and that were created within the last 30 days. We
    are using Python''s bitwise `OR` and `AND` operators to combine the sub-expressions.
    For any query you produce, you can view the generated SQL by printing the query
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Negation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more piece to discuss, which is **negation**. If we wanted to
    get a list of all blog entries that did not contain `Python` or `Flask` in the
    title, how would we do that? SQLAlchemy provides two ways to create these types
    of expressions, using either Python''s unary negation operator (`~`) or by calling
    `db.not_()`. This is how you would construct this query with SQLAlchemy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using unary negation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `db.not_()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Operator precedence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all operations are considered equal to the Python interpreter. This is
    like in math class, where we learned that expressions such as *2 + 3 * 4* are
    equal to *14* and not *20*, because the multiplication operation occurs first.
    In Python, bitwise operators all have a higher precedence than things such as
    equality tests, so this means that, when you are building your query expression,
    you have to pay attention to the parentheses. Let''s look at some example Python
    expressions and see the corresponding query:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (Entry.title == ''Python'' &#124; Entry.title == ''Flask'') | Wrong! SQLAlchemy
    throws an error because the first thing to be evaluated is actually the ''Python''
    &#124; Entry.title! |'
  prefs: []
  type: TYPE_TB
- en: '| (Entry.title == ''Python'') &#124; (Entry.title == ''Flask'') | Right. Returns
    entries where the title is either "Python" or "Flask". |'
  prefs: []
  type: TYPE_TB
- en: '| ~Entry.title == ''Python'' | Wrong! SQLAlchemy will turn this into a valid
    SQL query, but the results will not be meaningful. |'
  prefs: []
  type: TYPE_TB
- en: '| ~(Entry.title == ''Python'') | Right. Returns entries where the title is
    not equal to "Python". |'
  prefs: []
  type: TYPE_TB
- en: If you find yourself struggling with operator precedence, it's a safe bet to
    put parentheses around any comparison that uses `==`, `!=`, `<`, `<=`, `>`, and
    `>=`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a tagging system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are a lightweight taxonomy system that is perfect for blogs. Tags allow
    you to apply multiple categories to a blog post and allow multiple posts to be
    related to one another outside their category. On my own blog I use tags to organize
    the posts, so that people interested in reading my posts about Flask need only
    look under the "Flask" tag and find all the relevant posts. As per the spec that
    we discussed in [Chapter 1](ch01.html "Chapter 1. Creating Your First Flask Application"),
    *Creating Your First Flask Application*, each blog entry can have as few or as
    many tags as you want, so a post about Flask might be tagged with both Flask and
    Python. Similarly, each tag (for example, Python) can have multiple entries associated
    with it. In database parlance, this is called a many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to model this, we must first create a model to store tags. This model
    will store the names of tags we use, so after we''ve added a few tags the table
    might look something like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| id | tag |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Python |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Flask |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Django |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | random-thoughts |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s open `models.py` and add a definition for the `Tag` model. Add the following
    class at the end of the file, below the `Entry` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You've seen all of this before. We've added a primary key, which will be managed
    by the database, and a single column to store the name of the tag. The `name`
    column is marked as unique, so each tag will only be represented by a single row
    in this table, regardless of how many blog entries it appears on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have models for both blog entries and tags, we need a third model
    to store the relationships between the two. When we wish to signify that a blog
    entry is tagged with a particular tag, we will store a reference in this table.
    The following is a diagram of what is happening at the database table level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a tagging system](img/1709_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we will never be accessing this intermediary table directly (SQLAlchemy
    will handle it for us transparently), we will not create a model for it but will
    simply specify a table to store the mapping. Open `models.py` and add the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating the `entry_tags` table, we have established a link between the
    `Entry` and `Tag` models. SQLAlchemy provides a high-level API for working with
    this relationship, the aptly-named `db.relationship` function. This function creates
    a new property on the `Entry` model that allows us to easily read and write the
    tags for a given blog entry. There is a lot going on in these two lines of code
    so let''s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are setting the tags attribute of the `Entry` class equal to the return value
    of the `db.relationship` function. The first two arguments, `'Tag'` and `secondary=entry_tags`,
    instruct SQLAlchemy that we are going to be querying the `Tag` model via the `entry_tags`
    table. The third argument creates a back-reference, allowing us to go from the
    `Tag` model back to the associated list of blog entries. By specifying `lazy='dynamic',`
    we instruct SQLAlchemy that, instead of it loading all the associated entries
    for us, we want a Query object instead.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing tags from entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s use the IPython shell to see how this works. Close your current shell
    and re-run the `scripts/create_db.py` script. This step is necessary since we
    added two new tables. Now re-open IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are currently no tags in the database, so let''s create a couple of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s load up some example entries. In my database there are four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In IPython, you can use an underscore (`_`) to reference the return-value of
    the previous line.
  prefs: []
  type: TYPE_NORMAL
- en: To add tags to an entry, simply assign them to the entry's `tags` attribute.
    It's that easy!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can work with an entry''s list of tags just like a normal Python list, so
    the usual `.append()` and `.remove()` methods will also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using backrefs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we created the `tags` attribute on the `Entry` model, you will recall we
    passed in a `backref` argument. Let's use IPython to see how the back-reference
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the `Entry.tags` reference, the back-reference is specified as `lazy='dynamic'`.
    This means that, unlike `entry.tags,` which gives us a list of tags, we will not
    receive a list of entries every time we access `tag.entries`. Why is this? Typically,
    when the result-set is larger than a few items, it is more useful to treat the
    `backref` argument as a query, which can be filtered, ordered, and so on. For
    example, what if we wanted to show the latest entry tagged with `python`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLAlchemy documentation contains an excellent overview of the various values
    that you can use for the lazy argument. You can find them online at [http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy](http://docs.sqlalchemy.org/en/rel_0_9/orm/relationships.html#sqlalchemy.orm.relationship.params.lazy)
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final topic we will discuss in this chapter is how to make modifications
    to an existing Model definition. From the project specification, we know we would
    like to be able to save drafts of our blog entries. Right now we don't have any
    way to tell whether an entry is a draft or not, so we will need to add a column
    that lets us store the status of our entry. Unfortunately, while `db.create_all()`
    works perfectly for creating tables, it will not automatically modify an existing
    table; to do this we need to use migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Flask-Migrate to our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use Flask-Migrate to help us automatically update our database whenever
    we change the schema. In the blog virtualenv, install Flask-Migrate using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The author of SQLAlchemy has a project called alembic; Flask-Migrate makes use
    of this and integrates it with Flask directly, making things easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will add a `Migrate` helper to our app. We will also create a script
    manager for our app. The script manager allows us to execute special commands
    within the context of our app, directly from the command-line. We will be using
    the script manager to execute the `migrate` command. Open `app.py` and make the
    following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use the manager, we will add a new file named `manage.py` along
    with `app.py`. Add the following code to `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This looks very similar to `main.py`, the key difference being, instead of calling
    `app.run(),` we are calling `manager.run()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Django has a similar, although auto-generated, `manage.py` file that serves
    a similar function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the initial migration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can start changing our schema, we need to create a record of its current
    state. To do this, run the following commands from inside your blog's `app` directory.
    The first command will create a migrations directory inside the `app` folder that
    will track the changes we make to our schema. The second command `db migrate`
    will create a snapshot of our current schema so that future changes can be compared
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will run `db upgrade` to run the migration that will indicate to
    the migration system that everything is up-to-date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Adding a status column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a snapshot of our current schema, we can start making changes.
    We will be adding a new column, named `status`, that will store an integer value
    corresponding to a particular status. Although there are only two statuses at
    the moment (`PUBLIC` and `DRAFT`), using an integer instead of a Boolean gives
    us the option to easily add more statuses in the future. Open `models.py` and
    make the following additions to the `Entry` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: From the command-line, we will once again be running `db migrate` to generate
    the migration script. You can see from the command's output that it found our
    new column!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have blog entries in the database, we need to make a small modification
    to the auto-generated migration to ensure the statuses for the existing entries
    are initialized to the proper value. To do this, open up the migration file (mine
    is `migrations/versions/2c8e81936cad_.py`) and change the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Replacing `nullable=True` with `server_default='0'` tells the migration script
    to not set the column to null by default, but instead to use `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Finally, run `db upgrade` to run the migration and create the status column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, your `Entry` model now has a status field!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you should be familiar with using SQLAlchemy to work with a relational
    database. We covered the benefits of using a relational database and an ORM, configured
    a Flask application to connect to a relational database, and created SQLAlchemy
    models. All this allowed us to create relationships between our data and perform
    queries. To top it off, we also used a migration tool to handle future database
    schema changes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Templates and Views"), *Templates and Views*
    we will set aside the interactive interpreter and start creating views to display
    blog entries in the web browser. We will put all our SQLAlchemy knowledge to work
    by creating interesting lists of blog entries, as well as a simple search feature.
    We will build a set of templates to make the blogging site visually appealing,
    and learn how to use the Jinja2 templating language to eliminate repetitive HTML
    coding. It will be a fun chapter!
  prefs: []
  type: TYPE_NORMAL
