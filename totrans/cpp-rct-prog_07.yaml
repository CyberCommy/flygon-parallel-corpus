- en: Introduction to Data Flow Computation and the RxCpp Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From this chapter onward, we will get into meat of the reactive programming
    model. You can consider earlier chapters as a kind of prerequisite for understanding
    the reactive programming model, more specifically reactive programming using the
    C++ programming language. If we look back, we covered the necessary prerequisites,
    which includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The event programming models on various GUI platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A whirlwind tour of the Modern C++ language (including functional programming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language-level concurrency in C++ for better concurrent systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock-free programming models (as a step towards declarative programming)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced design patterns and the concept of Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event Stream programming using C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these topics come together in a systematic manner in the case of **functional
    reactive programming** (**FRP**). The FRP acronym is used here in the loose sense
    of programming reactive systems using functional programming constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on streams, we can achieve different
    computational goals. The primary task in a reactive program is to convert data
    into streams, regardless of the source of the data. The Event Streams are typically
    called **Observables** and event Stream subscribers are called **Observers**.
    Between Observables and Observers, there are Stream Operators (filters/transforms).
  prefs: []
  type: TYPE_NORMAL
- en: Since it is implicitly assumed that the data source won't be mutated while data
    is passed through Operators, we can have multiple Operator paths between Observables
    and Observers. Immutability gives options for out-of-order execution, and scheduling
    can be delegated to a special piece of software called a Scheduler. Thus Observables,
    Observers, Stream Operators, and Schedulers form the backbone of the reactive
    programming model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A short discussion about the data flow computing paradigm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the RxCpp library and its programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some basic RxCpp programs to get our feet wet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rx Stream Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marble diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatmap`/`concatmap`  oddities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional  Rx Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data flow computation paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, programmers encode computer programs in terms of control flow.
    That means we encode programs as a series of small statements (sequence, branching,
    iteration) or functions (including recursive), with their associated states. We
    use constructs, such as selection (`if`/`else`), iteration (`while`/`for`), and
    functions (recursive functions as well), to encode our computation. Handling concurrency
    and state management for these types of program are really difficult and they
    lead to subtle bugs while managing state information which are mutable in nature.
    We need to place locks and other synchronization primitives around shared mutable
    states. At the compiler level, the language compiler will parse the source code
    to generate an **abstract syntax tree** (**AST**), do type analysis, and code
    generation. In fact, AST is an information flow graph where you can perform data-flow
    analysis (for data/register level optimization) and control-flow analysis to exploit
    code pipeline optimization at the processor level. Even though programmers encode
    programs in terms of control flow, the compiler (at least some part of it) tries
    to see the program in terms of data flow as well. The bottom line here is the
    fact that there is an implicit data flow graph dormant in every computer program.
  prefs: []
  type: TYPE_NORMAL
- en: The data flow computation organizes computation as an explicit graph, where
    nodes are computations and edges are paths for data to flow between the nodes.
    If we place certain restrictions such as preservation of the data state by working
    on a copy of the input data, (the avoidance of in-place algorithms) on computations
    at the nodes in a computational graph, we can exploit opportunities for parallelism.
    The Scheduler will find opportunities for parallelism by doing a topological sort
    on the graph data structure. We will construct the graph data structure using
    streams (`Path`) and operations on streams (`Node`). This can be done declaratively,
    as Operators can be encoded as lambdas, which do some local computations on  node.
    There is a set of primitive standard (functional/stream) Operators, such as `map`,
    `reduce`, `filter`, `take and so on`, are identified by the functional programming
    community which works on streams. There is a provision in every data flow computation
    framework to convert data into streams. The TensorFlow library for machine learning
    is one library that uses the data flow paradigm. The RxCpp library can also be
    considered as a data flow computation library, even though graph creation  process
    is not fully explicit, as in the case of TensorFlow library. Since functional
    programming constructs support lazy evaluation, we are effectively creating a
    computation flow graph, when we construct a stream pipeline with asynchronous
    data streams and operations. These graphs are executed by a scheduling sub system.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the RxCpp library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the RxCpp library to write our reactive programs for rest
    of the book. The RxCpp library is a header-only C++ library that can be downloaded
    from a GitHub repo: [http://reactive-extensions.github.io/RxCpp/](http://reactive-extensions.github.io/RxCpp/).
    The RxCpp library relies on Modern C++ constructs, such as language-level concurrency,
    lambda functions/expressions, functional composition/transformation, and operator-overloading,
    to implement reactive programming constructs. The RxCpp library is structured
    along the lines of libraries such as `Rx.net` and `Rxjava`. Like any other reactive
    programming framework, there are some key constructs that everyone should understand
    before they write the first line of code. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables (Observable Streams)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observers (who subscribe to the Observables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators (for example, filters, transformations, and reductions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxCpp is a header-only library and most of the computation is based on the notion
    of Observables. The library provides lot of primitives to create Observable Streams
    from various data sources. The data sources can be  Arrays, C++ Ranges, STL containers,
    and so on. We can place Operators between Observables and their consumers (monikered
    as Observers). Since functional programming support composition of functions,
    we can place a chain of operators as a single entity between Observables and Observers
    who subscribe to the Streams. The Scheduler associated with the library will make
    sure that when data is available in Observable Streams, it will be passed through
    the series of Operators and a notification will be issued to subscribers. The
    Observers will get notification through on_next,on_completed or on_error lambdas,
    whenever something significant happens in the pipeline. Thus, Observers can focus
    on tasks for which they are primarily responsible, as data will reach them through
    notification.
  prefs: []
  type: TYPE_NORMAL
- en: The RxCpp library and its programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write some programs that will help the reader to understand
    the programming model of the RxCpp library. The aim of these programs is to elucidate
    Rx concepts and they are mostly trivial in nature. The code will be sufficient
    for a programmer to incorporate them into a production implementation with minor
    tweaks. In this section, Data producers and their Observables will be based on 
    C++ ranges, STL containers, and so on to make the listings simple enough to digest
    the core concepts  outlined here
  prefs: []
  type: TYPE_NORMAL
- en: A simple Observable/Observer interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple program that help us understand the programming model
    of the RxCpp library. In this particular program, we will have an Observable Stream
    and an Observer that subscribes to the Stream. We will generate a series of numbers
    from 1 to 12, using a range object. After creating the range of values and an
    Observable over them, we will attach them together When we execute the program,
    it will print a series of numbers to the console. Finally, a literal string (
    "Oncompleted") will also be printed on the console. :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program will display numbers to the console and the literal string 
    "`OnCompleted` "will also  be displayed  on  the console. This program demonstrates
    how we can create an Observable Stream and connect an Observer to the  the  created 
    Observable Stream using the subscribe method.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and Transformations with Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following program will help us to understand how filter and `map` Operators
    work, besides the usual mechanism of connecting an Observer to Observable Streams
    ,using the subscribe method. The filter method evaluates a predicate on each item
    of the Stream, and if the evaluation happens to produce a positive assertion,
    the item will be present in the output Stream. The `map` operator applies a lambda
    expression on each element of its input Stream and helps produce an output value
    every time (which can be propagated through the pipeline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program generates a series of numbers ( as an Observable) and
    passes content of the Stream through a filter function. The `filter` function
    tries to detect whether the number is even. if the predicate is true , the data
    will be passed to the `map` function, which will square its input. Eventually,
    the contents of the Stream will be displayed on to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming values from C++ containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data in STL containers are considered as the data which exists in space.(data
    which are already captured). Even though Rx streams are  meant for processing
    data varying over time (dynamic), we can convert an STL container into a Rx Stream.
    We need to use Iterate operator to do the conversion. This can be handy at times
    and has been helpful in integrating code from code bases that use STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating Observables from the scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have written code that create an Observable Stream from a range
    object or STL containers. Let''s see how we can create an Observable Stream from
    the scratch. Well, almost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program calls the `on_ext` method to emit a series of numbers
    that are perfect squares. Those numbers (1,4,9) will be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating Observable Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can concatenate two Streams to form a new Stream and this can be handy in
    some cases. Let''s see how this works by writing a simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The concat Operator append the contents of constituent Observable Streams one
    after another by preserving the order. In the preceding code,after creating an
    Observable (values), we did create two additional Observables ( s1 and s2 ) and
    did append the content generated by  second Observable stream (s2) to produce
    a combined Observable Stream (s1.concat(s2)). Finally, we subscribed to the Combined
    Observable.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from Observable Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following program shows how one can subscribe to an Observable and stop
    the subscription, if it is warranted.  in the case of some programs ,this option
    is very useful.  Please consult the Rxcpp documentation to understand more about
    the subscription and how one can use them effectively. In the mean time, following
    program will demonstrate how cone can un-subscribe from a Observable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above program, when the value emitted reaches a thresh hold value, we
    do call unsubscribe (subs.unsubscribe ()) method.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to marble diagrams for visual representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is difficult to visualize Rx Streams, as the data flows asynchronously.
    The designers of Rx systems have created a set of visualization cues called **marble
    diagrams**: Let us write a small program and depict logic of the map Operator
    as a marble diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than giving a description of marble diagrams, let''s look at a marble
    diagram that depicts the `map` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4c71177-6c60-4fa9-aae4-f57b3c7d3b83.png)'
  prefs: []
  type: TYPE_IMG
- en: The top part of the marble diagram shows a timeline where a series of values
    (represented as circles) are displayed. Each of the value will be passing through
    a map Operator, which takes a lambda as parameter. The lambda will be applied
    on each element of the Stream to produce  the output Stream (shown in the bottom
    part of the diagram as a diamond).
  prefs: []
  type: TYPE_NORMAL
- en: RxCpp (Stream) Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary advantage of Stream-oriented processing is the fact that
    we can apply functional programming primitives on them. In RxCpp parlance, the
    processing is done using Operators. They are nothing but filters, transformations,
    aggregations, and reductions on Streams. We have already seen how the `map`, `filter`,
    and `take` operators work in the previous examples. Let us explore them further.
  prefs: []
  type: TYPE_NORMAL
- en: The average Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `average` Operator computes arithmetic mean of values from Observable Streams.
    The other statistical Operators supported include:'
  prefs: []
  type: TYPE_NORMAL
- en: Min
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Max
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following program just demonstrates the `average` Operator. The schema
    is the same for other operators in the preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Scan Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scan` Operator applies a function on each element of a Stream sequentially
    and accumulates the value into a seed value. The following program produces average
    of a series of numbers as and when the values are accumulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The running average will be printed on to the console. `OnNext functor` will
    be called twenty times before `OnCompleted` is called.
  prefs: []
  type: TYPE_NORMAL
- en: Composing Operators through the pipe Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RxCpp library allows devolopers to chain or compose Operators to enable
    Operator composition. The library allows you to use the `pipe` (`|`) Operator
    to compose Operators (instead of the usual fluent interface using the  "." ),
    and programmers can pipe the output of one Operator to another as if they are
    in the command line of a UNIX shell. This assists in comprehension (about what
    a piece of code does ). The following program uses the `|` Operator to map a range.
    The RxCpp samples contain many examples using pipe functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Working with Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already learned about Observables, Operators, and Observers , in the
    above section. We now know that, between Observables and Observers, we can apply
    standard Rx Operators to filter and transform streams. In the case of Functional
    Programming, we write immutable functions (functions without side-effects) and
    a consequence of immutability is the potential for an out-of-order execution.
    The order in which we execute a function/functor does not matter, if we can guarantee
    that the input to an Operator is never modified. Since an Rx program will be manipulating
    multiple Observables  and Observers, we can delegate the task of choosing the
    execution order to a Scheduler module. By default, Rxcpp is single threaded. The
    RxCpp will schedule the execution of Operators in the thread which we called the `subscribe` method.
    It is possible to specify a different thread using the `observe_on` and `subscribe_on`
    operators. Also, some Observable Operators take a Scheduler as a parameter, where
    execution can happen in a thread managed by the Scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RxCpp library supports the following two Scheduler types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImmediateScheduler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventLoopScheduler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The RxCpp library is single-threaded by default. But you can configure it to
    run in multiple threads using certain operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program will produce the following output. We will be using the
    STD C++ thread ID to help us distinguish the items scheduled in the new thread
    (one of which is different from the main thread):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program will demonstrate the usage of the `subscribe_on` method.
    There are subtle differences between the `observe_on` and `subscribe_on` methods
    in terms of behavior. The purpose of the following listing is to show the options
    available for declarative scheduling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A tale of two Operators – flatmap versus concatmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A source of confusion among developers is often centered around the flatmap and
    `concatmap`  Operators. Their differences are really important and we will cover
    them in this section. Let''s take a look at the flatmap  operator and how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous program produces output sequence which are not predictable. The
    output of one run of the program is shown as follows. This need not be what we
    get when we run it again.  The reason for this behavior has to do with the post
    processing of the Stream after the mapping operation: The flatmap uses merge Operator
    for post processing of Streams.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following marble diagram shows schema of the operation. The `flat_map` applies
    the lambda on the Observable Stream and produces a new Observable Stream. The
    Streams produced are merged together to provide the output. In the diagram, the
    red ball gets transformed into a pair of red colored diamonds, whereas the output
    of the green and blue balls produces interleaved diamonds as output in the newly
    created Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/343fddd9-d86e-484b-97e8-15b35584ee34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us look at the `concat_map` operator by going through the listing given
    below. The program listing is identical to the earlier program. The only change
    is the substitution of the `flat_map` with `concat_map`. Even though there is
    no practical difference in the listing, there is a marked difference in the output
    behavior. Maybe `concat_map` produces output that suits the synchronized mental
    model of the programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the output will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following marble diagram shows `concat_map` in operation. Unlike the Flatmap
    marble diagram, the output is synchronized (red, green, and blue balls produce
    the same colored output in the order in which the input is processed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc73749-7bc0-4da9-bfc4-95c0a87e3b28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of `flat_map`, we got the output in an interleaved manner. But
    in the case of `concat_map`, we got the value in the order that we expected the
    output. What is the real difference here? To make the difference clear, let''s
    take a look at two operators: `concat` and `merge`. Let''s look into the way the
    concatenation of the Streams works. It basically appends the contents of the Stream
    one after the another, preserving the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following marble diagram clearly shows what happens when a `concat` Operator
    is applied on two Streams. We create a new Stream by appending contents of the
    second Stream to the contents of the first. This preserves the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2d0a75b-de50-4890-9735-f63cb41d2227.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what happens when two Streams are merged. The following code
    shows how you can merge two Streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following marble diagram clearly shows what happens when we merge two Observable
    Streams. The contents of the output Stream will be an interleaved combination
    of two Streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4d9457c-159e-44d7-9893-64b195484549.png)'
  prefs: []
  type: TYPE_IMG
- en: Both flat_map and concat_map more or less do the same operation. The difference
    lies in the way values are combined together. The `flat_map`  uses the `merge` Operator,
    while the `concact_map ` uses the `concact` Operator for post processing of results.
    In the case of `merge`, the order does not matter. The `concat` operator appends
    Observables one after the another. That is why you got synchronized output with
    concat_map and flat_map produced irregularly ordered results.
  prefs: []
  type: TYPE_NORMAL
- en: Other Important Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now understand the crux of reactive programming model, because we covered
    basic topics such as Observables, Observers, Operators, and Schedulers. There
    are some more Operators we should know about to write our logic better. In this
    section, we will cover the `tap` , `defer` and `buffer` Operators. We will first
    explore the `tap`  Operator, which helps peek into the contents of the Stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the `defer` operator. The `defer` operator takes
    an Observable factory as a parameter to create an Observable for each client that
    subscribes to it. In the following program, we invoke the `observable_factory` lambda
    when somebody tries to connect to the specified Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `buffer` Operator emits an Observable that contains the non-overlapping
    contents of an Observable, each containing at most the number of items specified
    by the count parameter. This will help us to process the items in a manner suitable
    for the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `timer` Operator emits an Observable that takes the interval period as
    a parameter. There is an option to specify the `Scheduler` object as a parameter.
    There are various versions of this function in the library; we have shown one
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A peek into the things we haven't covered yet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Rx programming model can be considered as confluence of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Data-flow computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream processing (event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns and idioms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get a comprehensive view of the whole discipline, you need to work with
    the programming model extensively. Initially, things won''t make much sense. At
    some point, you''ll reach a *click point* where everything will start making sense.
    So far, we have covered the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables and Observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic and intermediate Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic and intermediate scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is just the beginning, and we need to cover many more topics to get familiar
    with the programming model. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Hot and cold Observables ([Chapter 8](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml), 
    *RxCpp - the Key Elements*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed exploration of Rx components ([Chapter 8](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), 
    *RxCpp - the Key Elements*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced scheduling ([Chapter 8](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86),
    *RxCpp - the Key Elements)*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming GUI systems ([Chapter 9](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), *Reactive
    GUI Programming Using Qt/C++*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced operators ([Chapter 10](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86),
    Creating Custom Operators in RxCpp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive design patterns ([Chapter 11](dfe8398d-170d-4ce3-94f0-7ffae409d1e5.xhtml),
    *Design Patterns and Idioms for C++ Rx Programming*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming for robustness (Chapter 13, *Advanced Streams and Handling Errors*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered quite a bit of ground in understanding the Rx programming
    model in general, and  the RxCpp library in particular. We started with a conceptual
    overview of the data flow computing paradigm and moved quickly to writing some
    basic RxCpp programs. After introducing Rx marble diagrams, we learned about the
    set of Operators supported by the RxCpp library. We also introduced the important
    topic of Scheduler, and finally we discussed the difference between the `flatmap` and
    `concatmap`  Operators. In the next chapter, we will cover `hot` and `cold` Observables,
    Advanced scheduling, and some  topics that we have not covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
