- en: Chapter 7. Working with Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will show readers how to use Angular 2 directives related to form
    creation and how to use a code-based form component to the HTML form. The chapter
    will use Bootstrap 4 to enhance the look of the form and to indicate invalid input
    for our web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap 4 forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 form directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-way and two-way data bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add validation to a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining the pieces of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Terminal, create a folder called `ecommercem` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the content of the project from the folder, `chapter_7/1.ecommerce-seed,`
    into the new project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following script to install NPM modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the TypeScript watcher and lite server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This script opens the web browser and navigates to the welcome page of the project.
  prefs: []
  type: TYPE_NORMAL
- en: HTML form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An HTML form is a section of a web document containing:'
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special elements such as controls, like checkboxes, radio buttons, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels on those controls that describe their purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user modifies the controls by entering text or selecting the drop-down
    menu to complete the form and submits it to the backend for processing. Every
    control has a `name` attribute the form uses to collect a specific piece of data.
    Those names are important because:'
  prefs: []
  type: TYPE_NORMAL
- en: On the client side, it tells the browser which names to give each piece of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the server side, it lets the server handle each piece of data by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form defines where and how to send the data to the server via `action` and
    `method` attributes accordingly. The form usually has a submit button to allow
    the user to send data to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bootstrap 4 provides default style form controls and layout options to create
    the customs forms for consistent rendering across browsers and devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For proper rendering, all inputs must have a `type` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bootstrap supports specific classes to customize the following form controls:'
  prefs: []
  type: TYPE_NORMAL
- en: The `form-group` class uses any group of form controls. You can use it with
    any block-level element such as `fieldset` or `div` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `form-control` class uses textual inputs, select menus, and text areas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `form-control-file` is the only one applicable to the file inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are `form-check` and `formcheck-inline` classes we can use with checkboxes
    and radio buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All forms by default are stacked vertically because Bootstrap 4 applies `display:
    block` and `width: 100%` to all form controls. We can use additional classes to
    vary this layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `form-group` class to create the form quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class adds `margin-bottom` around a label and control for optimum spacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard form](Image00108.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inline form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `form-inline` class if you need to lay out the form elements in a single
    horizontal row aligned to the left.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The form aligns controls inline only in viewports wider than 768px.
  prefs: []
  type: TYPE_NORMAL
- en: 'Form controls behave differently because they receive `width:auto` instead
    of `width: 100%` . To provide the vertical alignment with all of them use the
    `display: inline-block` . You may need to manually address the width and alignment
    of individual controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each form control should have the pair `label` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'I only added the `form-inline` class to the form element to lay out the element
    horizontally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inline form](Image00109.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hidden labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can hide away the labels in respect of placeholders for the standard and
    inline forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We just add the `sr-only` class to each label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hidden labels](Image00110.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why can we not remove labels from the form to make them invisible? The answer
    to this question lies in the use of assistive technologies such as screen readers
    for people with limited abilities. The screen readers will render the form incorrectly
    if we do not include a label for every input. The Bootstrap authors intentionally
    designed the `sr-only` class to hide information from the layout of the rendering
    page only for screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: Form control size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two extra sizes of form controls, in addition to the default one,
    that we can use to increase or decrease the size of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `form-control-lg` to increase the size of input control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `form-control-sm` to decrease the size of input control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we need to display the help text for associated form controls. Bootstrap
    4 supports help text for standard and inline forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `form-text` class to create the block level help. It includes
    the `display: block` and adds some top margin for easy spacing from the preceding
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Help text](Image00111.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the `text-muted` class with any typical inline element (like `span` or
    `small` ) to create help text for inline forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Help text](Image00112.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Form grid layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use Bootstrap 4 grids to create more structured layouts for forms. Here
    are some guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the form in an element with the `container` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `row` class to `form-group`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `col-*-*` classes to specify the width of labels and controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `col-form-label` class to all labels to vertically align them to corresponding
    controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `col-form-legend` to legend elements to help them appear similar to regular
    labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update our markup with grids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Form grid layout](Image00113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stacked checkboxes and radios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap 4 improves the layout and behavior of checkboxes and radio buttons
    with the help of `form-check*` classes. There is only one class for both types
    to help vertically stack and space the sibling elements. The labels and inputs
    must have appropriate `form-check-label` and `form-check-input` classes to make
    that magic happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Stacked checkboxes and radios](Image00114.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inline checkboxes and radios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In scenarios when you need checkboxes or radio buttons to be layed out on a
    horizontal row you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `form-check-inline` class to the label element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the `form-check-input` to the input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Inline checkboxes and radios](Image00115.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Static control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the cases when you need to display the plain text instead of input fields
    you can use the paragraph element marked with the `form-control-static` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Static control](Image00116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Disabled states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can disable the input on one or many controls with an attribute of the same
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The disabled input field is shown lighter and with the `not-allowed` cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Disabled states](Image00117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use custom JavaScript code to disable the anchor and fieldset because browsers
    such as IE 11 and below don't fully support this property.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prevent modification of any input field you can use a read-only attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These fields appear lighter with the standard cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Read-only inputs](Image00118.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Validation styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bootstrap supports three validation states and appropriate styles for the form
    controls:'
  prefs: []
  type: TYPE_NORMAL
- en: The `has-success` class defines the success state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `has-danger` class defines the danger state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `has-warning` class defines the warning state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should apply those classes to the parent element, so all `control-label`
    , `form-control` , or `text-muted` elements will inherit the validation styles.
    We can use the feedback icons within the textual inputs such as `form-control-success`
    , `form-control-warning` , and `form-control-danger` . To give extra attention
    to validation, we can use contextual validation text with the help of `form-control-feedback`
    style. It adapts color to the parent `has-*` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Validation styles](Image00119.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Formless search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Look at the markup in the `product-search.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'I didn''t use the `form` tag here. Why? The answer is quite tricky. The form
    tag is required mostly for the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to execute a non-AJAX request or post file to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to programmatically capture the `submit` or `reset` events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to add validation logic to the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For others, we could abandon it. The logic behind the search field is to update
    URL with appropriate information without any request to the server. So this is
    why the search is formless.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search form has one issue; the **Go** button is always enabled even when
    the search field is empty. This results in inappropriate search results. We need
    to add validation to fix this issue and we have two options here:'
  prefs: []
  type: TYPE_NORMAL
- en: Start listening to the key events from search field to manage the `enabled`
    property of the **Go** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add validation and let Angular manage the `enabled` property of the **Go** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do both of them to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: User input from event object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user interacts with the web page, modifying the controls, and this results
    in triggering the DOM events. We use event binding to listen to those events that
    update components and models with the help of some simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The shape of `$event` depends on which element raises the event. When the user
    types something on the input element it triggers the keyboard events and listens
    in the `searchChanged` method of the `ProductSearchComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we find the input element from the event `target` and change the `disabled`
    property of the component bound to the same name attribute of the `submit` button.
    By default, the disabled value equals true and the submit button is grayed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User input from event object](Image00120.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user inputs the text to search, the triggered events enable the button
    to update the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User input from event object](Image00121.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User input from a template reference variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `#search` template reference variable to get value directly
    from the input element like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of the `searchChanged` method becomes a bit smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Opt to use the template reference variable to pass values instead of DOM events
    into the component listening methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_7/2.ecommerce-key-event-listenning`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Product View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The product card component displayed in the products grid has a **More Info**
    button. When the user clicks the button, it navigates to the Product View where
    you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the product information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the availability of the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the quantity of the product by clicking **Add to Cart** or **Remove from
    Cart**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return to the products list by clicking on **Continue Shopping**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Product View](Image00122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe of the Product View
  prefs: []
  type: TYPE_NORMAL
- en: Let's create the `product-view.component.html` . The content of this view is
    quite big, so I will explain it per columns.
  prefs: []
  type: TYPE_NORMAL
- en: Product image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first column, we show the image of the product. The product interface
    has reference to large images, so it is simple to present it on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what this column looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Product image](Image00123.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Product information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second column keeps the information about the product. I decided to use
    a Bootstrap 4 card component to present the information on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have three cards here. The first one contains the product's general information
    such as the `title` and `description` . The following list keeps the product `id`
    and `category` . We use the `categoryTitle` pipe to print out the category title.
    At the end, we print out the availability information with the fake data. We will
    update this block in the next chapter, so leave it as it is for now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Product information](Image00124.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second and third cards work against each other and present information
    depending on the value of the `isSpecial` property of the product. When this property
    is `true` we show the price in an altering color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Product information](Image00125.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CategoryTitle pipe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As was mentioned in [Chapter 4](text00036.html#page "Chapter 4. Creating the
    Template") , *Creating the Template* , the Angular Framework gives us pipes: a
    way to write display-value transformations that we can declare in templates. The
    pipe is a simple function that accepts an input value and returns a transformed
    value. In our case, we keep the category ID in the cart item, but we need to display
    the title of the category. For that reason we created the file `category.pipe.ts`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Plus, we updated the `CategoryModule` to declare and export the `CategoryTitlePipe`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `CategoryTitlePipe` is available across the application.
  prefs: []
  type: TYPE_NORMAL
- en: Cart information in Product View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I used the Bootstrap 4 Form laid out inside the cart component in the last column
    to keep and manage information from the shopping cart as explained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Quantity and amount
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The quantity and amount of the product are crucial for the user doing the shopping.
    To present them on the view, I bound the component properties of the same name
    to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user uses **Add to Cart** and **Remove from Cart** buttons to increase
    and decrease the quantity of the product on the shopping cart. These buttons call
    the appropriate methods of the `CartService` to make the necessary changes in
    the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At the end, we have a **Continue Shopping** button to help the user navigate
    back to the Products View.
  prefs: []
  type: TYPE_NORMAL
- en: '![Actions](Image00126.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every time a user adds or removes a product from the shopping cart, the changes
    happen in the Product View, which updates information in the Cart Menu present
    in the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: Product View component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s create `product-view.component.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two properties, `product` and `cartItem,` available in `ProductViewComponent`
    to get information to the template. We use the `product` property to display information
    in the second column of the Product View. The `cartItem` property keeps the reference
    on the item in the shopping cart linked to the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We need only show `count` and `amount` in the third column of the Product View
    but it is impossible without extra work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first problem is that we cannot show information from the `CartItem` until
    adding the product to the shopping cart. To solve it, we introduced the getter
    methods for `count` and `amount` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another issue happens when the user adds a product to the shopping cart for
    the first time or removes the last one from it. As a solution, we need to reassign
    the `cartItem` from the shopping cart whenever we call the `addToCart` and `removeFromCart`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `ActivatedRoute` service to retrieve the parameters for our route
    in the constructor. Since our parameters are provided as an `Observable` , we
    subscribe to them for the `id` parameter by name and tell `productService` and
    `cartService` to fetch appropriate information. We'll keep a reference to this
    `Subscription` so we can tidy things up later.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ProductView to the ProductModule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `product.module.ts` file to reference the `ProductView` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductView` is now available in the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Product View route definition with a parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must update the router configuration in the `app.routes.ts` so, when a user
    selects the product, Angular navigates to the `ProductViewComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `id` in the third route is a token for a route parameter. In a URL such
    as `/product/123` , the `123` is the value of the `id` parameter. The corresponding
    `ProductViewComponent` uses that value to find and present the product whose `id`
    equals `123` .
  prefs: []
  type: TYPE_NORMAL
- en: Navigation to Product View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks on the **More Info** button on the card in the Products
    View, the router uses information provided as an array to the `routerLink` to
    build the navigation URL to the Product View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are how all three columns of the Product View look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation to Product View](Image00127.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_7/3.ecommerce-product-view` .
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We didn''t use Angular 2 forms in our project before, so now it''s time to
    unveil those predominantly flexible tools. Based on the nature of the information
    of the web application requesting from the user, we can split it into static and
    dynamic forms:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the template-driven approach to build static forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the model-driven approach to build dynamic forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we use the new Angular 2 forms module, we need to install it. Open the
    Terminal window, navigate to the web project, and run the npm package manager
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the forms module is installed, we enable it during the application
    bootstrap. Open the `app.module.ts` file and update it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We registered two different modules in `AppModule` because:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FormsModule` is for template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ReactiveFormsModule` is for reactive or dynamic forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discover both of them shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This way is the simplest one to build forms and requires little to no application
    code. We create the form declaratively in the template with the help of built-in
    Angular 2 directives doing all the magic behind the scene for us. Let's talk about
    the Angular 2 specific directives we can use in the forms.
  prefs: []
  type: TYPE_NORMAL
- en: The NgForm directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgForm` directive creates a top-level `FormGroup` instance, providing
    information about the current state of the form, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The form value in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form validity state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Look at the directive definition of the class `FormGroupDirective` in the `form_group_directive.ts`
    from the source code of Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The property `exportAs` of the directive metadata exposes an instance of `FormGroupDirective`
    to the template via the name `ngForm` so in any template we can use the template
    variable referencing on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The template variable `myForm` has access to the form value, so we can use
    the handle function to manage submitting values like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `ngSubmit` is an event signal where the user triggers a form submission.
  prefs: []
  type: TYPE_NORMAL
- en: The NgModel directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgModel` directive helps register form controls on a `NgForm` instance.
    We must specify the `name` attribute to every form control. With the combination
    of `ngModel` and `name` attributes, the form control will automatically appear
    in the `value` of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print out the `value` of the form in the `handle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is printed in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `ngModel` as an attribute directive with an expression to bind
    the existing model to the form controls. There are two ways we can approach this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **one-way binding** applies an existing value to the form control via property
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `MyForm` class we have properties of the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The **two-way binding** reflects changes on form control to an existing value
    of the property and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Track change-state and validity with NgModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every time we manually or programmatically manipulate form controls, `NgModel`
    tracks the state changes that happen on them. Based on that information, `NgModel`
    updates the control with specific classes. We can use those classes to organize
    visual feedback to reflect the state of components:'
  prefs: []
  type: TYPE_NORMAL
- en: Class `ng-untouched` marks the control that was not visited yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `ng-touched` marks the visited control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `ng-pristine` marks the control with the unchanged value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `ng-dirty` marks the control with the changed value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `ng-invalid` marks an invalid control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class `ng-valid` marks a valid control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we should be able to use the `ng-valid` or `ng-invalid` class for feedback
    to the user about invalid form control. Let''s open the `ecommerce.css` file and
    add the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, all controls marked as required fields will show the green left borders
    while all invalid fields will have the red left borders.
  prefs: []
  type: TYPE_NORMAL
- en: The NgModelGroup directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can group the form controls into the control group. The form itself is a
    control group. It is possible to track the validity state of the controls in the
    group. Like the control uses a `ngModel` directive, the group utilizes a `NgModelGroup`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `fieldset` or `div` elements to group controls. With the help of
    `ngModelGroup,` we semantically group controls into `user` and `contact` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Model-driven forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This approach helps to build forms without DOM requirements and makes them
    easy to test. It doesn''t mean we don''t need the templates. We need them in conjunction
    with the model-driven way. We are creating the form in a template and create the
    form model that represents the DOM structure. We can use two different APIs here:'
  prefs: []
  type: TYPE_NORMAL
- en: The low-level API based on `FormGroup` and `FormControl` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The high-level API based on `FormBuilder` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any form is a `FormGroup` . Any `FormGroup` represents a set of `FormControls`
    . Let''s imagine we have the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a model for our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `myForm` represents our form from the template. We create the `FormControl`
    for every field of the form and `FormGroup` for each group. In the first property,
    we assign the default value to the name. The `FormGroup` can contain another group
    and helps to create the hierarchy to replicate the DOM structure.
  prefs: []
  type: TYPE_NORMAL
- en: The FormGroup directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to bind the model to the form elements with the help of an Angular
    2 `FormGroup` directive. We need to assign the expression evaluations into the
    `FormGroup` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The FormControlName directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next very important step is to associate the model properties with form
    elements. We use the `FormControlName` instead of the name attribute to register
    the controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This directive keeps the `userName` of `FormControl` and `password` from `FormGroup`
    in sync with DOM elements of the same name. Any changes happen programmatically
    and the `FormGroup` properties will immediately be written into the DOM elements
    and vice versa. We use the `get` and `set` methods to access and update the form
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The FormGroupName directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In cases when we have a group of controls, we can use the `FormGroupName` directive
    to associate a group of controls with a parent `FormGroupDirective` (formally
    a `FormGroup` selector). You should specify via the name attribute to which nested
    `FormGroup` element you would like to link, so it might be quite handy to organize
    a validation of sub-group elements separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use the get method of the `FormGroup` to get access to properties. Individual
    controls are available via dot syntax as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The FormBuilder class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FormBuilder` creates an `AbstractControl` form object from a user-specified
    configuration. So, instead of creating `FormGroup` , `FormControl` , and `FormArray`
    elements, we build the configuration to construct the model. We need only inject
    it in the constructor and call the `group` method to create the form group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we have a less verbose code.
  prefs: []
  type: TYPE_NORMAL
- en: A FormControl directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we talked about the formless search form.
    This form has only one element, and we don''t need a `FormGroup` at all. Angular
    has a `FormControl` directive which doesn''t have to be inside `FormGroup` . It
    only adds it to a single form control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated version of the script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Built-in validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I cannot image the form without validators. Angular 2 comes with several built-in
    validators we can use declaratively as directives or imperatively with `FormControl`
    , `FormGroup` , or `FormBuilder` classes. Here is a list of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The form control with a `required` validator must have a non-empty value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form control with a `minLength` must have the value of the minimum length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form control with a `maxLength` must have the value of a maximum length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form control with a `pattern` must have the value to match the given regular
    expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of how to use all of them declaratively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that the `novalidate` is not a part of Angular 2\. It is an HTML5
    Boolean form attribute. The form will not validate input fields on submission
    when it presents.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same validators imperatively with `FormGroup` and `FormControl`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, we can use the `FormBuilder` and less verbose code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In both scenarios, we must use the `formGroup` directive to associate the `myForm`
    model with a form element in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular 2 has an interface `Validator` that can be implemented by classes that
    can act as validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a function to validate the correctness of a ZIP code. Create
    the file `zip.validator.ts` in the `shared` folder with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `validateZip` expects the `FormControl` as an argument and must
    return an error object if the value doesn''t match the regular expression or null
    if the value is valid. Now, we can import the `validateZip` function and use it
    in our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom validator directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use Angular 2 built-in validators imperatively, or declaratively, with
    the help of some internal code to execute the validators on form controls. All
    built-in and custom validators must be registered in a multi-provider dependency
    token, `NG_VALIDATORS` . As you will remember from [Chapter 6](text00058.html#page
    "Chapter 6. Dependency Injection") , *Dependency Injection* , the multi-property
    of the provider allows the injection of multiple values to the same token. Angular
    injects `NG_VALIDATORS` , instantiates the form, and performs validation on the
    form control. Let''s create the custom validation directive we can use in template-driven
    forms. Open `zip.valdator.ts` and copy and paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And now in the form we can use `ZipValidator` as a directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Cart view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cart view lists all items held in the user''s shopping cart. It displays
    product details for each item and, from this page, a user can:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove all goodies from his or her cart by clicking **Clear Cart**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the quantity for any listed item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return to the products list by clicking on **Continue** shopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proceed to checkout by clicking **Checkout**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Cart view](Image00128.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe of the cart view
  prefs: []
  type: TYPE_NORMAL
- en: The significant part of the cart view is formed with dynamic content laid out
    in the grid. Look at the first column of the wireframe. There are rows of similar
    data we can use to display, modify, and validate. For this purpose, we can use
    Angular static forms to present the content of the shopping cart on the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `cart-view.component.html` . In the first column, we need to
    print out information about products added to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the template-driven approach here and assign a form variable to the
    exposed `ngForm` . I split the double-way binding format into two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ngModel]="item.count"` : This is used as property binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(ngModelChange)="item.count = update($event, item)"` : This is used as event
    binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every time a user updates the `count` value, this code calls the `update` method
    to add or remove products from the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have a button, **Clear Cart** , we need to implement the method
    of the same name in `CartService` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Cart view route definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I updated the router configuration in the `app.routes.ts` to reflect the changes
    necessary to apply to navigate to the `CartViewComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Navigation to cart view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Cart** button in the markup of the Cart Menu,
    the router uses information from the link to navigate to the cart view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to update the `CartModule` to add the `CartViewComponent` into the
    `declarations` property of `NgModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of the cart view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation to cart view](Image00129.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_7/4.ecommerce-cart-view` .
  prefs: []
  type: TYPE_NORMAL
- en: The Checkout View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Checkout View displays the customer details form, purchase conditions, and
    the order information. The customer should fill in the form, accept payment, and
    click on the **Submit** button to start the payment process.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Checkout View](Image00130.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wireframe of the Checkout View
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `checkout` folder and `checkout-view.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'I used the model-driven approach here to create the definition of the form.
    When the user clicks on the **Submit** button it shows the message and clears
    the shopping cart. Create the `checkout-view.component.html` and copy the following
    content there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We have several required fields, so when they are empty Angular 2, via `NgModel,`
    turns their bars red. That''s OK to indicate the problem but not enough to say
    what exactly is wrong. We can use the validation error message to display if the
    control is invalid or was not touched. Look at the markup I copied from the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We read information about `FormControl` status directly from the form model.
    We check if the `firstName` field is valid or if it's pristine and show or hide
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, we bind the disabled property of the **Submit** button to the validity
    of the form, so the user will have the chance to send the data to the server only
    if all the fields of the form are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Checkout view route definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Update the router configuration in the `app.routes.ts` to add the `CheckoutViewComponent`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Navigation to Checkout View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Checkout** button in the markup of the Cart Menu,
    the router navigates to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CheckoutViewComponent` does not belongs to any module, so we need to add
    it to the `AppModule` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of the Checkout View with validation error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation to Checkout View](Image00131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_7/5.ecommerce-checkout-view` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to create forms with Bootstrap 4\. We know
    that Bootstrap supports different layouts from simple to complex.
  prefs: []
  type: TYPE_NORMAL
- en: We investigated the Angular 2 forms module and can now create model-driven and
    template-driven forms.
  prefs: []
  type: TYPE_NORMAL
- en: We joined all the pieces of our application, and now it looks very nice.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](text00074.html#page "Chapter 8. Advanced Components") , *Advanced
    Components* , we will talk about the life cycle of a component and the methods
    that can be used at different stages of a component. This chapter also discusses
    how to create a multi-component application. As usual, we will continue to build
    the project we started to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
