- en: '*Chapter 6*: Writing Cypress Tests Using the TDD approach'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've completed *Part 1* of this book – that is, *Cypress as an End-to-End
    Testing Solution for Frontend Applications* – it is time to move on to *Part 2*
    of this book, which will focus on *Automated Tests with a TDD Approach*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start writing Cypress tests using a **TDD** (**TDD**) approach,
    we need to understand how to properly write Cypress tests. This was covered in
    the previous chapters of this book. To excel in this topic, you will need to have
    an understanding of how Cypress tests work, the structure of tests, and the different
    ways in which Cypress tests can be used to make assertions. This background information
    will help you understand how to use TDD in Cypress and the advantages that come
    from using it in the software development life cycle. In this chapter, we will
    utilize a test-driven approach to write tests that will significantly contribute
    to an increased level of trust and confidence in our applications and software
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus in this chapter will be on identifying how Cypress can be utilized
    to help us holistically think about an application, even before we start the process
    of developing it. We will apply the concept of testing our application first before
    we start development. In doing so, we will utilize the Cypress framework as the
    core for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following key topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing TDD tests in Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying TDD tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will be ready to learn
    about element interaction in Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we recommend that you clone this book's GitHub repository, which
    contains the application we will be building and all the tests that we will write
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-06` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the ReactJS library to develop our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the ReactJS application by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd chapter-6/tdd-todo-app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm install` (to install all the required dependencies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm run start` (to start the React application for testing purposes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TDD is a software development process that relies on requirements being turned
    into very specific test cases. After writing these test cases, the code is then
    written and checked against other test cases. The final step in the TDD process
    is to iterate and improve the code to make sure it adheres to the best practices
    required and that the test cases pass. The cycle of a TDD approach consists of
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the functionality that needs to be implemented
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a new test
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the test to check whether the test fails
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing code for the test case to pass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the test against the added functionality to make sure the test passes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeating this process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The purpose of TDD is to visualize the end before development has started. That
    way, it is possible to foresee the problems or hurdles that may arise during the
    development process. Being able to develop a feature using the TDD approach assists
    in critically thinking about the solution, and also helps with scenarios that
    need to be tested as the application is being developed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we are creating a login functionality; from a testing perspective,
    we will need to come up with all the different scenarios for the login feature.
    Thinking about these test scenarios will give us a clear view of what needs to
    take place in the development phase, making the requirements clearer when we are
    developing this application feature.
  prefs: []
  type: TYPE_NORMAL
- en: TDD assists in reducing the chances of scope creep since, from the onset, we
    can understand the goal of the project. With test cases in place, we can determine
    the functionality and limit the scope to only the test cases that have been written.
    Understanding what this feature involves allows developers to formulate how the
    code will be implemented. In the long run, this might lead to reduced development
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Scope creep refers to uncontrolled changes or the scope of a software development
    project growing after the project has begun.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at the advantages of the TDD approach.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at the benefits that come from implementing
    the TDD methodology in a software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Better project design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing using the TDD approach, developers need to think of the goal
    that the piece of code is meant to achieve. Due to this, developers will always
    start with the end in mind. The ability to develop a feature with a specific goal
    ensures that developers only write code that is needed and is necessary, which
    subsequently leads to the application having a clear structure.
  prefs: []
  type: TYPE_NORMAL
- en: Using TDD also ensures higher code quality as TDD strongly emphasizes the use
    of the **Don't Repeat Yourself** (**DRY**) principles, which discourage repetition
    when writing code. Due to this, by using TDD, it is possible to keep functions
    simple and brief, and the code base easy to understand. A cleaner and simple code
    base is easy to maintain and test, which is an added advantage to the developers
    and the code base maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: DRY principles are application development principles that emphasize the non-repetition
    of software patterns and the use of abstraction to avoid or reduce redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD enforces strict documentation that references the feature under development;
    developers need to come up with such specifications, which might well include
    the actions of the users. Understanding the actions and breaking down the steps
    into user stories helps developers implement the features and therefore develop
    features that are very close to the defined goal.
  prefs: []
  type: TYPE_NORMAL
- en: Developing proper documentation at the stage of writing tests also relieves
    other parties of the role of having to understand the features to reproduce documentation,
    since it was already part of the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced development time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to assume that TDD takes more time when developing an application
    and in most cases, this is the truth. From this statement, we can assume that
    TDD will most likely delay the project delivery date, which is not the case.
  prefs: []
  type: TYPE_NORMAL
- en: By taking a TDD approach, it is possible to cover scenarios that would otherwise
    have bugs if a TDD approach was not used in development. While TDD may initially
    consume more time than the non-TDD approach, it significantly reduces the time
    it takes for developers to maintain the project and the work that has to be done
    to test the product and its features.
  prefs: []
  type: TYPE_NORMAL
- en: Since TDD enforces clean code, it goes without saying that even when bugs are
    identified, it is easier to fix them in a project that utilizes TDD than in a
    project that does not utilize TDD. The focus of TDD on high-quality code standards
    and continuous feedback makes the code base of TDD projects maintainable, which
    is not the case for non-TDD projects.
  prefs: []
  type: TYPE_NORMAL
- en: Cost savings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In any project, it is cheaper to find and fix a bug when it is still in development
    than when the bug has already made its way to production. TDD focuses on bug elimination
    as development takes place, which greatly reduces the chances of defects making
    their way through the development and testing phases of a feature. This enforces
    code refactoring principles and bug prevention. The TDD approach greatly saves
    the company's expenditure on actions that are directly related to bugs and defects
    being discovered in production.
  prefs: []
  type: TYPE_NORMAL
- en: Costs that come as a direct result of a defect can include direct loss of revenue,
    additional time and costs to fix the discovered defect, and even loss of trust
    by the stakeholders of the company, such as the customers. Understanding the ability
    of TDD to lower such costs makes the savings in a company worthwhile since developing
    software costs money and fixing the same software costs even more money.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD solutions are reliable as they undergo scrutiny before development kicks
    off. TDD ensures that the concept that was developed is what is achieved. This
    is realized by the test scenarios that are written when the functionality is still
    an idea and are in the form of requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Without the use of TDD, it is not possible for developers to build a robust
    solution without thinking about how different parts of the program will interact
    with the new features. With TDD, however, these test cases help developers understand
    how new features and existing features can be integrated, and therefore have knowledge
    of how the application will behave once the new features have been built. This
    approach gives developers confidence as they know about the solution before they
    have started developing it.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While most of the outcomes of TDD are positive and lead to productivity and
    great development processes, TDD can also be detrimental to teams that are not
    structured to use it. In this section, we will highlight the disadvantages of
    using TDD and why it may not be suitable for some teams.
  prefs: []
  type: TYPE_NORMAL
- en: Organizational preparedness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TDD requires organizations to be present in the process of implementing it.
    TDD requirements need to be defined for the organizations before the implementation
    takes place, so to guarantee success, organizations need to be positioned in such
    a way that TDD will work for them. In some cases, organizations may not have the
    patience to wait for all the requirements before implementation begins, and also
    might not be willing to sacrifice the extra time to critically walk through the
    requirements beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is structural and requires both management and the team of developers to
    align by agreeing to incur costs related to planning beforehand so that they spend
    less on maintenance later. Not all teams might be willing to take on the approach
    of waiting for the benefits of TDD, which means the organization may not be willing
    to pay for the costs that are not currently visible.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test Driven Development focuses on building tests before implementation begins.
    This approach assists the team to better understand the problem and come up with
    solid implementation solutions. The greatest challenge with writing tests is that
    they cannot solve logical errors that have already been introduced in the implementation
    code. Tests can only identify what they are meant to test and may not be able
    to test things that have not been explicitly defined in the code.
  prefs: []
  type: TYPE_NORMAL
- en: With TDD, it is possible to make mistakes due to the understanding of the problem;
    tests might not be in a position to capture situations where the requirements
    were not properly understood by the designer of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – understanding TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about TDD, why we need it, and how it is utilized
    in the software development life cycle. We also learned about the advantages of
    using TDD and how it can prevent costs that arise from bugs and defects being
    discovered in the post-development and testing stages. We also learned about the
    disadvantages of utilizing TDD, some of which may arise from tests being as good
    as the reasoning with which they were written. It is therefore critical to understand
    the problem being developed in order to come up with tests for the problem at
    hand. In the next section, we will focus on writing TDD tests in Cypress and how
    this process assists in coming up with robust solutions and implementations for
    feature code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing TDD tests in Cypress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will focus on writing TDD tests using Cypress. Throughout
    this section, we will build a Todo application and apply the TDD principles. First,
    we need to have a design in mind so that we can write proper tests and also critically
    think about the features of our application. The goal of this chapter will be
    to create an application that will add todo items, delete todo items, show added
    todo items, and show the count of the added todo items. A mockup of the final
    application is shown in the following screenshot. Every step we follow will help
    us achieve the mockup we desire:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Todo application mockup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Todo application mockup
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows a mockup of our Todo application that we will
    be building. We will use a TDD approach with tests written in Cypress. The application
    will have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing added todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing a count of added todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features make up the requirements of our todo application. Throughout
    this chapter, we will be referencing these features as requirements as we develop
    our tests and implement our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid any further complexity in this section, we will not focus on how we
    will build the application but on how we will be implementing the tests as we
    build the application. For background context, the application we will be building
    will be using the ReactJS library, which is written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood what our application looks like, we will take a step-by-step
    approach to writing our tests before we begin the process of developing our application.
    As we mentioned previously, we have written the application features that we will
    be building toward. We will start by writing TDD tests so that we can add new
    todo items.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first TDD tests that we will focus on are tests that will be responsible
    for checking that new todo items have been added to our todo list. To follow these
    steps, navigate to the `tests` directory that you cloned from GitHub with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will navigate you to the TDD `tests` directory that we
    will be using in this chapter. The tests located in this file are the first versions
    of the tests that we will write in our TDD process. Later, we will modify them
    so that they suit the final application features that we will add.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When writing TDD tests for our Todo application, note that the Cypress directory
    is located inside the test application. This ensures that we keep track of and
    identify Cypress tests that belong to the application being developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is a test that checks that we can add a new todo
    item to our application, which is one of the requirements for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we wrote a TDD test to check that after the
    feature is complete, we can add our todo item and check that the added item exists.
    Note that at this stage, the feature for adding todo items has not been built
    yet. If we run this code snippet in Cypress, it should automatically fail. To
    verify this, we can run the following command to run the Cypress tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows a failing TDD test for creating and displaying
    a new todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Running a TDD test on Cypress'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Running a TDD test on Cypress
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we are executing the test to check whether or not
    it fails and whether Cypress can execute it. In this test, Cypress tried to execute
    the test against the locally running Todo application running on port `3000`.
    The test failed because Cypress could not find the input element that is responsible
    for adding todo items to the todo list. From the preceding screenshot, we can
    verify that the application successfully navigated to our application running
    in localhost. To continue building on this feature and ensuring that the tests
    are passing, later, we will add the functionality for adding a todo item and rerun
    our tests again.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Todo item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our Todo application requirements state that we should have the ability to
    delete an added todo item. One of the requirements of a deleted todo item is that
    once it is deleted, it should no longer be visible on the todo list. To write
    our TDD test, we need to ensure that we actually deleted the todo item by verifying
    that the todo item no longer exists once it is deleted from the todo list. We
    will use the following code snippet to achieve the deletion feature test requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we added a todo item and then deleted it. Later,
    we verified that the deleted todo item does not exist anymore and asserted that
    by using a Cypress assertion method. This test snippet not only checks for the
    proper deletion of the todo item, but also checks that after deletion takes place,
    the todo item will no longer be present in the DOM. As shown in the preceding
    screenshot, running this test with Cypress fails as our application has not been
    built yet.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the added todo items
  prefs: []
  type: TYPE_NORMAL
- en: 'As specified by our application requirements, when todo items are added, they
    should be visible in the todo list. The todo items that are added should be identical
    to the todo items in the todo list. To achieve a proper test, we need to ensure
    that our test covers the scenario of ensuring that an added todo item is visible
    on the todo list. We also need to verify that the item that has been added to
    the todo application is the same item that is visible on the todo list. Once again,
    we will curate a TDD test that will aim to cover the scenarios of being able to
    display our todo items. The following code block is a TDD test for displaying
    an added todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, the TDD test will add a new todo item using the input element
    of the application, and then verify that the added element is present in the todo
    list. Having this test in place eliminates the possibility that todo items will
    be added and not be visible on the todo item list.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a count of the added todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the requirements of our application, we need to ensure that we can
    view the number of added todo items. From our mockup, which can also be found
    in our `chapter-06/mockups/todo-mockup.png` directory, the number of todo items
    should correspond to the items inside the todo list. Using the requirement for
    our todo app, our TDD test should test scenarios such as adding more than one
    todo item and checking that the number of todo items increases or decreases, depending
    on whether they are added or removed from our todo list.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Before we write our tests, it is important to understand how Cypress understands
    which element to interact with, which button to click, or where to type on an
    input field. Cypress uses element identifiers, which uniquely identify the elements
    for Cypress to interact with. The unique element identifiers of elements on a
    web page may include unique element ID CSS selectors, XPath locators, or even
    custom element identifiers of our choosing, which will be in the `[data-testid="our-unique-identifier"]`
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test, unlike the test scenarios for adding, deleting, or viewing a todo
    item, will encompass multiple steps and more than one assertion. The following
    code block shows a TDD test for viewing the number of todo items that have been
    added to a todo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet will serve as a template for the final test, which will check
    that the number of todo items increases and decreases as todo items are added
    and deleted. Here, we can see that we added two todo items, then verified that
    both todo items are present. After validating that both items were present in
    the todo list, we deleted one todo item and checked that the count of todo items
    decreases as the number of items decreases.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When writing TDD tests, we are not very concerned about the syntax errors that
    may be present in the tests but rather the scenarios and test coverage. When we
    start modifying the tests once the features have been built, we will fix errors
    as we run our tests again, this time against the added functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time for a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – setting up the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we learned about writing TDD tests and how they help shape
    our thinking as we develop our solutions. We covered the process of writing TDD
    tests for adding a todo item, viewing a todo item, deleting a todo item, and viewing
    the total count of todo items in the todo list. We also learned that TDD tests
    help us understand the process of development and that the tests are not the final
    tests that we will have when the features are completed. In the next section,
    we will look at modifying TDD tests once the features for our application have
    been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying TDD tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at how TDD tests are structured and the rationale
    through which they are developed to suit the application under development. As
    we mentioned earlier, we will not go into the details of how we will develop the
    application. Instead, we will focus on how to integrate testing into the application
    under development. The application being referenced here is available in this
    book's GitHub repository ([https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress/tree/master/chapter-06/](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress/tree/master/chapter-6/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use the TDD tests that we created in the previous
    section. The TDD tests that we will be building on are responsible for testing
    the defined requirements of the application, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing added todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing a count of added todo items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have written the tests, we will add features to the application
    as we modify them. First, we will run the first test since we have already built
    the feature for adding a todo item. To separate the TDD tests and the final tests
    in our application, we will create a new test file named `todo-v2.spec.js` that
    we will add our final tests to. The test file is located in the `chapter-06/tdd-todo-app/integration/todo-v2.spec.js`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we want to verify that the test we wrote earlier to verify the addition
    of a new todo item actually works. To run this test, we will ensure that our application,
    which was built in ReactJS, is running locally. We will run our tests against
    the application, which is locally hosted. Once the feature for adding new todo
    items has been completed, our application will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Adding a new todo item feature'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Adding a new todo item feature
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can verify that our **Add todo item** feature
    is working since we have already added the todo item. Now that our code seems
    to be working okay, it is time to check whether our tests actually pass when they're
    run. To do this, we will use the `todo-v2.spec.js` test file, which is a modified
    version of `todo-v1.spec.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have modified our test from the version 1 test file located in `todo-v1.spec.js`,
    and have also modified the test so that it adapts to the todo item addition feature
    we created in our application. The new test should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in our initial test, the initial scenarios to be tested do not change.
    We begin by navigating to the default URL of our application running locally.
    Then, we add a todo item using Cypress and later verify that the added todo item
    is what we initially added to the input element. We can clearly check the actions
    as they happen in the following screenshot, which shows the successful test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Passing the test for adding a todo item'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Passing the test for adding a todo item
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see that Cypress navigated to the locally
    hosted application and added a todo, then checked to see whether the added todo
    was present in the todo list.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We added element identifiers that are prefixed with `data-testid=*` to our application
    to uniquely identify elements. Element identifiers are very handy when it comes
    to selecting elements in a web application. By adding unique identifiers and not
    using the default CSS selectors for the application, even when the application
    selectors change, our tests will remain unaffected and will continue to run normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have successfully completed our first task in TDD. In this section,
    we achieved the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identified an application that we wanted to develop and prototyped it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrote TDD tests before development started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developed the feature for adding a todo item to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the TDD tests to make them conform to our developed feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a side-by-side comparison of both the TDD version
    and the final feature version of the tests for adding a new todo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – TDD test versus final feature test comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – TDD test versus final feature test comparison
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the second version of the test reveals that while the test structure
    or objective did not change, we had to modify our test so that it suited the developed
    todo addition feature. The ability to identify requirements, develop a feature,
    and then modify the tests to run against the feature is the main goal of TDD,
    which we managed to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a todo item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will learn how to delete an added todo item. Regarding our requirements,
    a deleted todo item is removed from the list of todo items and is not visible
    once the delete button for the todo item is clicked. Again, we will not focus
    on the process of developing the feature but on the tests for this feature. In
    the following screenshot, we can see the delete button for every new todo item
    that is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Delete todo item feature'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.6_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Delete todo item feature
  prefs: []
  type: TYPE_NORMAL
- en: 'The icon that''s highlighted in red is the delete icon that appears for every
    todo item. If the delete button is clicked, the added todo item will disappear
    from our todo list, as described in our requirements. To validate that the feature
    works according to how we had envisioned it, we will now modify our TDD test for
    the delete feature and run the test against this feature. The following code block
    is a test that deletes a todo item that has already been added to the todo list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block shows the modified TDD test for confirming that once a todo
    item has been deleted, it is no longer present in the todo items list. We also
    had to make some minor modifications to the test from the initial TDD test that
    we had written, so that all the selectors and actions matched the feature that
    has been developed. Looking at the following Cypress screenshot, we can see that
    our test passes and that the added todo item is deleted, as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Deleting an added todo item'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.7_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Deleting an added todo item
  prefs: []
  type: TYPE_NORMAL
- en: Here, the Cypress snapshot feature helps us visualize the process of Cypress
    clicking on the delete button of the newly added todo item. We have also written
    an assertion to verify that the deleted todo does not exist on the todo list once
    it has been deleted. Our test has passed, which means that we have used TDD to
    add a todo item to a todo list and have also deleted this todo item and tested
    that it does not exist in our todo list. In our next test, we will focus on viewing
    added todo items.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing added todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Part of the requirements for our application includes viewing added todo items
    in the todo list. While adding todo items, we have been able to see this feature
    in action but have not tested it. To verify this feature, we will add a new todo
    item and check whether the created todo item appears on the todo list. The following
    code block is a test that checks whether the added todo items are visible on the
    application that we have created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have modified our TDD test. Rather than only checking whether we can
    view a single todo item, we have added two items and added an assertion to check
    that both items exist in the todo list. We will run our tests in Cypress and use
    the application preview to verify that both Todo items exist, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Viewing added todo items'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.8_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Viewing added todo items
  prefs: []
  type: TYPE_NORMAL
- en: Hurray! Our test passes!
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows that our requirement of having a feature that adds a todo
    item was correctly built, and that our test requirements for viewing todo items
    in our todo list were also met. Here, we have achieved our goal of viewing our
    todo items feature. We have also used TDD to check for scenarios that needed to
    be tested when viewing our todo items.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the count of added todo items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have modified our TDD tests for adding a todo item, deleting a
    todo item, and viewing todo items in our todo list, we also want to add a feature
    that checks the number of todo items that have been added. The feature for viewing
    the count of our added todo items is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Viewing the count of added todo items'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.9_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Viewing the count of added todo items
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature displays the number of todo items that are currently available
    in our todo list. The count of todo items will increase as more todo items are
    added and decrease when todo items are deleted from the list. Here, we will use
    our TDD test that we wrote for this feature and modify it so that it can be used
    by our application. In our test, we will focus on adding and deleting todo items
    and validating that on addition and deletion, the number of todo items changes
    accordingly. The following code block shows different assertions that check whether
    the feature works as it should, as per our requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet shows us adding new todo items, verifying that an
    item from the list was deleted, and that the count remains consistent through
    the different state changes of the application. Here, we have modified our initial
    TDD tests and have been able to use them to test whether we can actually increment
    or decrement the count of the todo items available. By running the same test on
    Cypress, we can verify that Cypress is happy and that we have a remaining todo
    item that was not deleted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Testing the todo count'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.10_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Testing the todo count
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can verify that as the state of the application
    changes due to actions such as adding and deleting todo items, the count increases
    or decreases accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – modifying TDD tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned how to modify TDD tests once features have been
    developed to make them conform to how our application has been built. We also
    learned how Cypress uniquely identifies what elements to interact with when our
    tests are running. Finally, we learned how to transform already written TDD tests
    into test features that have been developed for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood how the process of TDD works and the importance
    of embracing TDD in any team, and looked at the advantages and disadvantages of
    TDD. We also explored how TDD can be applied to a practical application. By doing
    this, we created requirements for a Todo application that had not been built yet.
    Before developing the application, we wrote TDD tests for the features we thought
    were important, and then used these requirements and TDD tests to develop our
    features. Once we'd finished developing our features, we modified our first TDD
    versions of the tests so that they work for our developed features, hence completing
    the process of showcasing how to utilize TDD in a practical application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should understand what TDD is, how to write TDD tests, and how to modify
    and use TDD tests in a real-world application so that they conform to the developed
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about TDD and how to implement it in our projects, we will
    focus on how to interact with the different elements of the Cypress DOM in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
