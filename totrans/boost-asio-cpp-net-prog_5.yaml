- en: Chapter 5. Delving into the Boost.Asio Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are able to run the `io_service` object and give it some work to
    do, it is time for us to find out more about other objects in the `Boost.Asio`
    library in order to develop the network application. All works of the `io_service`
    object we used before are run asynchronously but not in a serialized order, which
    means we are not able to determine the order of the `io_service` object''s work
    that will be run. Also, we have to consider what we will do if our application
    encounters any errors at runtime and think about time interval in running any
    `io_service` object work. Therefore, in this chapter, we will discuss the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Serially executing the work of the `io_service` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catching the exception(s) and handling them properly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the work in the desired amount of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing the I/O service work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want to queue up the work to be done but the order is important.
    If we just apply the asynchronous method, we won't know the order of work we will
    get. We need to make sure that the order of work is the one we want and have designed
    it to be. For instance, if we post Work A, Work B, and Work C, in that order,
    we want to keep that order at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using the strand function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Strand** is a class in the `io_service` object that provides handler execution
    serialization. It can be used to ensure the work we have will be executed serially.
    Let us examine the following code to understand serializing by using the `strand`
    function. But first, we will start without using the `strand()` and `lock()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `nonstrand.cpp` and compile it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it by typing `nonstrand` in the console window. We will get an output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the strand function](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may get a different output, and running the program several times does,
    in fact, yield different orders of the results. This is because, as we discussed
    in the previous chapter, without the `lock` object, the output will be unsynchronized,
    shown as follows. We can notice that the result looks disordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us apply the `strand` function to synchronize the flow of the program.
    Type the following code and save it as `strand.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the preceding code by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We make just a little modification from `nonstrand.cpp` to `strand.cpp`, but
    the impact is big. Before we run the program, let us distinguish the code between
    `nonstrand.cpp` and `strand.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `post()` function in the `io_service` object to give it work. But
    by using this method, the flow of the program is unpredictable because it is not
    synchronized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `strand` object to give the work to the `io_service` object.
    By using this method, we will ensure that the order of the work is exactly the
    same as what we have stated in the code. To prove it, let''s take a look at the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the strand function](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The order of the work is the same as the sequence of the work in our code.
    We are shown the output of the work in numerical order, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And, if you remember, we continue to omit the `lock()` function from the `Print()`
    function and it still runs properly due to the `strand` object's usage. Now, no
    matter how many times we re-run the program, the results are always in ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a handler through the strand object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a function in `boost::asio::strand` called the `wrap()` method. Based
    on the official Boost documentation, it creates a new handler function object
    that will automatically pass the wrapped handler to the `strand` object''s dispatch
    function when it is called. Let us look at the following code to explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the preceding code the name `strandwrap.cpp,` then compile it by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program and we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping a handler through the strand object](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, if we run the program many times, it might produce a random output
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although the work is guaranteed to be executed serially, it is not guaranteed
    which work's order actually takes place as a result of the built-in handler wrapper.
    And if the order is really important, we have to look at the built-in handler
    wrapper itself when using the `strand` object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions and errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, our code will throw an exception or error at runtime. As you may
    remember in our discussion of the `lexical.cpp` in [Chapter 3](part0025_split_000.html#page
    "Chapter 3. Introducing the Boost C++ Libraries"), *Introducing the Boost C++
    Libraries*, we must sometimes use exception handling in our code, and we will
    now dig it up to delve into exception and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Handling an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An exception is a way of reacting to a situation in which the code has exceptional
    circumstances by transferring control to the handler. To handle the exception,
    we need to use the `try-catch` block in our code; then, if an exceptional circumstance
    arises, an exception will be thrown to the exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look at the following code to see how exception handling is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `exception.cpp` and run the following command to
    compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the program and you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling an exception](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, we are not shown the line from `std::cout << "Thread " << counter
    << " End.\n";` because of the exception. When the work of the `io_service` object
    is run, it always throws an exception by using the `throw` keyword so that the
    exception will be caught by the `catch` block within the `WorkerThread` function,
    since the `iosvc->run()` function is inside the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that although we post work for the `io_service` object five
    times, the exception handling only handle two exceptions because once the thread
    has finished, the `join_all()` function in the thread will finish the thread and
    exit the program. In other words, we can say that once the exception is handled,
    the thread exits to join the call. Additional code that might have thrown an exception
    will never be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about if we put in the `io_service` object''s work invocation recursively?
    Will it lead to an infinitely running program? Let us try to throw the exception
    infinitely. The code will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `exception2.cpp` and compile it by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us examine the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Handling an exception](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fortunately, the program was able to finish successfully. This happened because
    the exception propagated through the `run()` function and the worker threads exited.
    After that, all the threads finished and the `join_all()` function was called.
    That is why the program exits even though there is still work left in the `io_service`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling an error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous example, we used the `run()` function without any parameters,
    but in fact, the function has two overload methods, `std::size_t run()` and `std::size_t
    run(boost::system::error_code & ec)`. The latter method has an error code parameter
    that will be set if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us try to use an error code as an input parameter in the `run()` function.
    Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `errorcode.cpp` and use the following command to
    compile the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program by typing the `errorcode` command in the console. As a
    result of doing so, the program will crash. The following screenshot shows the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling an error](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We intend to retrieve the error code by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can catch the error by using the `if` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: However, in error variable approach, user exceptions translate to `boost::asio`
    exceptions; thus, the error variable `ec` does not interpret the user exception
    as an error so the exception is not caught by the handler. If the `Boost.Asio`
    library needs to throw an error, it will become an exception if there is no error
    variable, or it will be converted into an error variable. It is better if we keep
    using the `try-catch` block to catch any exceptions or errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have to examine the type of exception, which is either system failure
    or context failure. If it is system failure, then we have to invoke the `stop()`
    function in the `io_service` class to ensure the work object has been destroyed
    in order for the program to be able to exit. In contrast, if the exception is
    context failure, we need the worker thread to call the `run()` function once more
    in order to prevent the thread from dying. Now, take a look at the following code
    to understand the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `errorcode2.cpp` and then compile it by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program, we will see that it will not exit, and we have to press
    *Ctrl* + *C* to stop the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling an error](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The worker thread is looping. This is also the case when an exception occurs
    in the output result (indicated by the `Throw Exception` and the `Exception Message:
    The Exception!!!` output). Call the `run()` function again so it will post a new
    event to the queue. Of course, we don''t want this situation to occur in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Timing the work execution using the timer class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a class in the Boost C++ library that provides the ability to conduct
    a blocking or asynchronous wait for a timer until it expires, known as the **deadline
    timer**. A deadline timer indicates one of two states: expired or not expired.'
  prefs: []
  type: TYPE_NORMAL
- en: An expiring timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we are going to create a timer that will expire in 10 seconds. Let us
    take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `timer.cpp` and run the following command to compile
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us distinguish the code before we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the program calls the `TimerHandler` function, it has to wait for 10
    seconds because we use the `expires_from_now` function from the `timer` object.
    The `async_wait()` function will wait until the timer has expired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After the timer has expired, the `TimerHandler` function will be invoked and
    since there is no error, the program will execute the code inside the `else` block.
    Let us run the program to see the complete output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An expiring timer](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And, since we used the `async_wait()` function, we can hit the *Enter* key to
    exit the program before we see the line, **Now press ENTER to exit**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the timer along with the boost::bind function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us try to create a recurring timer. We have to initialize the global timer
    object in order for the object to become a shared object. To achieve this, we
    need help from the `shared_ptr` pointer and the `boost::bind` method to make and
    keep the thread safe since we will use a shared object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `timer2.cpp` and run the following command to compile
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program. We will get a recurring output, which we can stop by
    hitting the *Enter* key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the timer along with the boost::bind function](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see from the output that the timer is ticked every three seconds and the
    work will be stopped after the user presses the *Enter* key. Now, let us see the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::bind` function helps us to use the global timer object. And if we
    look deeper, we can use the `_1` parameter for our `boost::bind` function. If
    we read the documentation of the `boost::bind` function, we will find that the
    `_1` parameter is a placeholder argument that will be substituted by the first
    input argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about binding with a placeholder, check out the official
    Boost documentation at [www.boost.org/doc/libs/1_58_0/libs/bind/doc/html/bind.html](http://www.boost.org/doc/libs/1_58_0/libs/bind/doc/html/bind.html).
  prefs: []
  type: TYPE_NORMAL
- en: And for more information on placeholder arguments, see [en.cppreference.com/w/cpp/utility/functional/placeholders](http://en.cppreference.com/w/cpp/utility/functional/placeholders).
  prefs: []
  type: TYPE_NORMAL
- en: Using the timer along with the boost::strand function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the timer is asynchronously executed, it is possible that the timer execution
    is not in a serialized process. The timer might be executed in one thread while
    another event is executed at the same time. As we have discussed previously, we
    can utilize the `strand` function to serialize the order of execution. Let us
    take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `timer3.cpp` and compile it by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program by typing the `timer3` command in the console and we will
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the timer along with the boost::strand function](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can see that the first five `work` objects are executed
    first because they have to be serially executed and afterwards, the `TimerHandler()`
    functions are executed. The `work` objects have to be completed first before the
    timer thread is executed. If we remove the `strand` wrap, the flow of the program
    will be messy because we do not lock the `std::cout` function inside the `Print()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully serialized the `io_service` object's work by using the
    `strand` object, so we can ensure the order of work we have designed. We can also
    ensure our program will run smoothly without any crashes by using error and exception
    handling. Lastly, in this chapter, we discussed the waiting time, since this is
    important when creating a network application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us move on to the next chapter to talk about creating a server-client
    application that will make communication possible between two parties, the server
    and the client.
  prefs: []
  type: TYPE_NORMAL
