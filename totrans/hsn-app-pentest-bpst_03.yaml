- en: Executing an Application Penetration Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to configure and set up our Burp Proxy across various
    platforms, we can now begin to start with an application pentest. In the present
    world, there are various purposes behind executing a pentest; it could either
    be for a bug bounty or it could be a fully-fledged assessment for a client. The
    initial approach is usually the same; ultimately, however, there is a huge difference.
    Bug bounty hunters aim to find one or a set of particular vulnerabilities that
    could lead to severe adversities if exploited, so they can claim their bounty.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, for a fully-fledged pentest, the job of the pentester does
    not stop there. The pentester will have to perform a complete ...
  prefs: []
  type: TYPE_NORMAL
- en: Differences between a bug bounty and a client-initiated pentest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into the core details, let''s first understand these two mindsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug bounty pentest mindset**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aim is to find vulnerabilities that have an impact and fetch a good bounty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete assessment of the application doesn't need to be done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One bug is enough to qualify for a bounty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the vulnerabilities in the application are not reported, only the ones found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no particular timelines; it can be done at the pentester's convenience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client-initiated pentest mindset**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aim is to ensure that all the application processes and functionalities
    are tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a limited timeline in which the whole application needs to be audited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no bounty or rewards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a need to ensure that all the vulnerabilities found by a scanner are
    validated and reported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a need to also scope the entire application by understanding all the
    inter-dependencies and ensure that endpoints are well protected, since there will
    be times when the backend applications, such as support, will not be made available
    to bug bounty hunters, but will be in a client-initiated assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common points in both the mindsets**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must have the presence of mind to chain multiple vulnerabilities and cause a
    high impact on the underlying application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, ensure that the attacker is aware of all the endpoints of that particular
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoping of the entire application's presence and testing all the endpoints to
    find flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a moment to think about the differences between the two approaches. I'm
    sure you will agree that there needs to be two totally different mindsets while
    performing the pentest.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating a penetration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application penetration test is always said to be incomplete if it does
    not do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Following the standard methodology of performing recon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing individual parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing non-invasive exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a report that talks about the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing steps to reproduce, proof of concept code, and possible mitigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During my career, on numerous occasions, I have come across security consulting
    companies or independent professionals that are known to run an automated scanner
    that detects only a handful of vulnerabilities and almost always does not discover
    logical issues. These vulnerabilities are then exploited with a half-baked exploit
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Types and features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Burp Suite comes with the following set of inbuilt tools to ease the life of
    every penetration tester:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanner**: Helps in testing the website automatically for content and vulnerabilities.
    It has an active and a passive mode, which can be toggled and configured by the
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intruder**: This allows the user to make certain changes in a captured request
    and through certain modifications the user can automate the task with brute force
    by passing different parameter values at every request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeater**: This feature allows the user to modify header values on the go
    and send requests to the application server over and over again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborator client**: This is a very interesting feature provided by Burp.
    It allows the user to check for out-of-band vulnerabilities. These are really
    hot vulnerabilities, as they are not easy to find.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clickbandit**: This feature allows the user to create **clickjacking** pages
    against vulnerable applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequencer**: The sequencer feature enables the user to analyze the randomness
    of the application''s cookie generation mechanism; it gives the user a very detailed
    analysis of the randomness or predictability of the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decoder**: This allows the user to check for any type of encoding and allows
    the user to decode it to clear text and the other way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparer**: This feature allows the user to compare responses for two or
    more requests to find differences in them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following low-level diagram of Burp Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0eb70f80-636b-42a1-972c-fba1af176453.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the tool segregation in the following three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recon and Analysis**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vulnerability Detection and Exploitation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tool Configuration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding diagram gives you a pretty good idea of how the requests can be
    handled. Once the request is parsed, the tool carries out active spidering and
    active discovery, as well as allowing the user to do custom discovery in the recon
    and analysis phase. While this is ongoing, the tool actively puts all the information
    in the HTTP history and sitemap for later use. Once this information is gathered,
    a user can send any particular request to the repeater, intruder, or scanner.
    The scanner can be fed with the entire website post-crawl as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool configuration will allow the user to manage authentication, session
    handling, task scheduling, and various other tasks. The proxy is the core of the
    Burp Suite mechanism.  Burp Suite Scanner is an all-in-one automation kit for
    performing a pentest. It does everything, right from discovering content up to
    finding vulnerabilities. There are many more plugins that you can make use of
    to enhance the scanning results. We will talk about those plugins in later chapters.
    The Burp Scanner comprises mainly the two following parts: one is the crawl for
    content and the other is audit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crawl for content**: The Burp crawler navigates across the application almost
    like a real user; it submits inputs, forms, and also captures the links and creates
    a complete sitemap of the application. It shows what is found and what did not
    return a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audit**: This is the actual scanner that will fuzz all the parameters to
    determine if there is a vulnerability in the application or not. It can be optimized
    by the user for better performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are familiar with the types and features of Burp Suite, we will
    look into the crawling mechanism to catalog the contents of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Crawling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I want to emphasize here that Burp has an amazing crawling mechanism to map
    the site structure with the closest possible accuracy. Crawling may seem to be
    a simple task, but with modern dynamic applications it is not. As pentesters,
    we have always witnessed the scanners going in huge loops in the crawling phase
    due to the URL scheme implementations, and the scan never seems to finish, especially
    when you are testing a shopping cart. It is really frustrating when such things
    happen, because then you have to rely on completely manual strategies. Burp, on
    the other hand, has a very smart approach. The crawler of Burp mimics the way
    a user would browse the application on the browser. It simulates user clicks,
    navigation, and input submissions, ...
  prefs: []
  type: TYPE_NORMAL
- en: Why Burp Suite Scanner?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have established the basic understanding of how robust the Burp
    crawler is, it's time to understand why Burp Scanner is the go-to scanner for
    any pentest. Most traditional scanners usually fuzz the input fields, check the
    response, and determine if there is a vulnerability or not. But what if the application
    has certain rules, like, what if the application has enforced dynamic CSRF for
    every request? What if the application is a very dynamic application that serves
    different content for the same URL/page based on states, or what if the application
    invalidates the user on a malformed request? Worry not, because Burp already treats
    this differently and understands the underlying logic, enabling us with an optimized
    scan.
  prefs: []
  type: TYPE_NORMAL
- en: Auditor/Scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and understand the Burp Audit/Scanner rules and mechanism.
    Burp Auditor is mainly divided into the three following core categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Passive phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript analysis phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows Burp to actively spot and exploit functions that are stored and
    returned to the user in response to input. It also helps to avoid duplication
    by handling frequently occurring issues and insertion points in an optimal manner.
    Also, it effectively makes use of the system resources by executing work in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp Auditor reports tons of issues, widely ranging into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive**: This is a non-intrusive audit that does analysis purely on the
    basis of the request and response received by a normal ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the insertion points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Burp Scanner is a very efficient scanner, as it targets various insertion points.
    It targets the input fields, a set of headers, such as cookie, referrer, user
    agent, and so on. Burp Scanner analyzes the targets individually by sending payloads
    individually to see how the application handles the payloads. A better understanding
    to see the insertion points is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/077432c3-6153-4588-baa0-f6b01ea0bb0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Burp also handles data encoding for various parameters. It understands the
    parameter in use and any encoding if it follows. Once it detects the encoding,
    it fuzzes the parameter by fuzzing the payloads by encoding them as shown in the
    following screenshot. For example, to standard inputs, it passes a normal payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1e06ea7-b1a7-4174-b474-8b94d8adced9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a JSON parameter, it fuzzes with a different payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d90588bc-3595-43d1-b284-be8b42cbe2cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For XML it passes a different payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49559201-30d8-4aa8-83ec-55cf89b60920.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the application is using a different encoding, such as base64, Burp automatically
    tries to detect the encoding being used and modifies the payload accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/220ceb8c-6af1-44b6-b639-067641221ee9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the application is using nested encoding, Burp tries to detect this behavior
    and creates payloads accordingly to help testing for vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c85b5af-8dce-4c66-99b5-481c5f9b80b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also as we discussed earlier, Burp manipulates the location of the parameters
    by trying to pass them in different locations as a `POST`, `GET` request, adding
    the values to the headers, and fuzzing them. This is done in an attempt to bypass
    the web application firewall and to try to send the parameter to the particular
    application function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cec64ad6-fa35-4459-a1fa-75cceb967b30.png)'
  prefs: []
  type: TYPE_IMG
- en: These are all the different styles and mechanisms that Burp follows to help
    perform scanning over the application. The core question here is, how does it
    scan and maintain a valid session if additional security is put in place? Well,
    we have good news; Burp Scanner crawls to every request from the root node and
    then tests the request depending on the context of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp Suite satisfies the following conditions while traversing from node to
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct testing if there are no tokens, same tokens, or CSRF in cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal from the root node to the request path in case of single CSRF tokens
    and single-use tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/17f652e9-b7fb-461f-b220-148c927ff3c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows the heuristic crawl; if you need to reach a particular
    request to pentest, there are three other request pages from the root node, Burp
    will travel through all those pages and reach the target page, just like a simulation
    of a real-world user. How does this help? Well, this helps in testing tight applications
    that use a per request CSRF token. Burp is able to figure out the dependencies
    of the CSRF tokens and perform an efficient scan by traversing to the target request
    right from the root and taking the CSRF from the response and adding it to the
    next request, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6808c27-3efa-4d1c-8991-e1ec0e2fb6ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might also wonder how the session handling is managed if the application
    times out, or the session times out, or even if the session invalidates, right?
    Burp manages a timeline. It makes a timestamp and validates if the session is
    still valid. Once it validates, it sets a marker and proceeds with other tests,
    and then, when it comes to a timeout condition or an invalid session, it goes
    back to the previous marker and begins the test again, so as to give us an exact
    accurate pentest result covering all the parameters. The same reference can be
    understood from the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d80cce4-4cec-4cf1-8da2-ac7e014c73c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To sum it up, Scanner does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: It automatically manages the additional security settings and performs the fuzzing,
    such as handling the CSRF token types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It manages encoding and edits the attack payloads accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It even performs nested fuzzing by double-encoding payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It follows a snapshot-based approach to perform a scan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also ensures that parameters are fuzzed from `POST` to `GET`, or even pushes
    them in the headers in an attempt to execute payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This covers the complete groundwork of the Burp Scanner and crawler, giving
    us a complete idea of how the tool works and performs a scan to give an accurate
    result in different scenarios of web applications. Now, in the next chapter, we
    will start with the stages necessary for an application penetration testing.
  prefs: []
  type: TYPE_NORMAL
