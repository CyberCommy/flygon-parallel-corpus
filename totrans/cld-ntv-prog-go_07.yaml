- en: AWS I – Fundamentals, AWS SDK for Go, and EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to a new step in our journey to learn cloud programming in the Go language.
    In this chapter, we'll start discussing cloud technologies by covering the popular **Amazon
    Web Services** (**AWS**) platform. AWS was among the first cloud platforms to
    be offered for customers to use in their start-ups, their enterprises, and even
    for their personal side projects. AWS was launched by Amazon in 2006 and has been
    growing continuously ever since. Due to the large size of the topic, we will divide
    the material into two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS SDK for Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up and secure EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest definition of AWS is that it's a service provided by Amazon, where
    you can buy virtual machines, databases, message queues, RESTful API endpoints,
    and all kinds of software products hosted on their cloud platform. To fully appreciate
    AWS, we will need to cover some of the major services that are offered on the
    platform. We will then dig deeper to learn how to reap the power of Go to build
    applications capable of utilizing the services AWS provides via its cloud APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic** **Compu****te** **Cloud** (**E****C2**): The **Elastic Compute
    Cloud** (**EC2**) is one of the most popular services provided by AWS. It can
    simply be described as a service to be used when needing to spin new server instances
    on AWS. EC2 is special in that it makes the process of starting servers and allocating
    resources practically easy for users and developers. EC2 allows auto-scaling,
    which means that applications can automatically scale up and down based on the
    user''s needs. The service supports multiple setups and operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Storage Service** (**S3**): S3 allows developers to store different
    types of data for later retrieval and data analysis.S3 is another popular AWS
    service that is used by numerous developers all over the world. Typically, developers
    store images, photos, videos, and similar types of data on S3\. The service is
    reliable, scales well, and easy to use. The use cases for S3 are plentiful; it
    can be used for web sites, mobile applications, IOT sensors, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Queue Service (SQS)**: SQS is a hosted message queue service provided
    by AWS. In a nutshell, we can describe a message queue as a piece of software
    that can reliably receive messages, queue them, and deliver them between other
    applications. SQS is a scalable, reliable, and distributed hosted message queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon API Gateway**: Amazon API gateway is a hosted service that enables
    developers to create secure web APIs at scale. It not only allows you to create
    and publish APIs, but also exposes sophisticated features such as access control,
    authorization, API versioning, and status monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DynamoDB**: DynamoDB is a NoSQL database that is hosted in AWS and provided
    as a service. The database is flexible, reliable, and scalable with a latency
    of only few milliseconds. NoSQL is a term used to describe databases that are
    nonrelational and enjoy high performance. A nonrelational database is a type of
    database that doesn''t use tables with relations to store data. DynamoDB makes
    use of two data models: a document store and a key-value store. A document store
    database stores data in a collection of document files, whereas a key-value store
    puts data in simple key value pairs. In the next chapter, you will learn how to
    build Go applications in AWS that are capable of utilizing the power of DynamoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS SDK for** **Go**: The AWS SDK for Go is a collection of Go libraries
    that empower developers to write applications that can interact with the AWS ecosystem.
    Those libraries are the tools we''ll utilize to make use of the different AWS
    services that we have mentioned so far, such as EC2, S3, DynamoDB, and SQS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter and the next one, we will be covering those technologies
    in deeper detail. Every single topic we will discuss in this chapter is massive
    and can be covered in entire books. So, instead of covering every single aspect
    of each AWS service, we will provide practical insights into each service and
    how to utilize them as a whole to build powerful production grade applications.
    Before diving deep into each AWS service, let's cover some general concepts in
    the AWS world.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS console is the web portal that provides us access to the multitude
    of services and features that AWS offers. To access the portal, you first need
    to navigate to [aws.amazon.com](http://aws.amazon.com), and then choose the Sign
    In to the Console option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/439b8a86-a7fb-4a58-a6f1-d6aa839a59bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you sign in to the console, you will be greeted with a web page that showcases
    the services provided by AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d546f848-b579-4e2c-942b-b3f31811b158.png)'
  prefs: []
  type: TYPE_IMG
- en: AWS command-line interface (CLI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CLI is an open source tool that provides commands to interact with AWS services.
    AWS CLI is cross-platform; it can run on Linux, macOS, and Windows. In this chapter,
    we will use the tool for certain tasks, such as copying files from an `S3` folder
    to an EC2 instance. AWS CLI can perform tasks that are similar to those performed
    by the AWS console; this includes configuration, deployment, and monitoring of
    AWS services. The tool can be found at [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/).
  prefs: []
  type: TYPE_NORMAL
- en: AWS regions and zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS services are hosted on multiple geographical locations around the world.
    In the world of AWS, locations consist of regions and availability zones. Each
    region is an independent geographical location. Each region contains multiple
    isolated internal locations known as availability zones. Some services — such
    as Amazon EC2, for example—give you full power as to which regions to use for
    your service deployment. You can also replicate resources across regions. You
    can find a list of available AWS regions at [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions).
  prefs: []
  type: TYPE_NORMAL
- en: For complex application deployments in AWS, developers typically deploy their
    microservices into multiple regions. This ensures that the application will enjoy
    high availability, even if any Amazon data center in a certain region suffers
    from a failure.
  prefs: []
  type: TYPE_NORMAL
- en: AWS tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS tags is another important concept in the AWS universe. It allows you to
    categorize your different AWS resources properly. This is very useful, especially
    when you use numerous AWS services for different things. For example, you can
    set one or more tags to identify the `S3` storage bucket that you use for your
    mobile application. The same tags can then be used to identify the EC2 instance
    you use for that mobile application backend. A tag is a key value pair; the value
    is optional.
  prefs: []
  type: TYPE_NORMAL
- en: A good resource for better understanding AWS tags can be found at: [https://aws.amazon.com/answers/account-management/aws-tagging-strategies/](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to practically dive into AWS services, it is important to mention
    a useful service in the AWS ecosystem called *Elastic Beanstalk*. The purpose
    of this service is to provide an easy-to-use configuration wizard via the AWS
    console, which allows you to quickly deploy and scale your applications on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: This service is useful in multiple scenarios, and we encourage the reader to
    explore it after reading this chapter and the next chapter of the book. However,
    we will not be focusing on Elastic Beanstalk in this book. That is because the
    purpose of this book when it comes to AWS is to provide you a practical foundational
    knowledge on the inner workings of the main AWS services. This knowledge will
    make it easy for you to not only deploy and run applications on AWS, but also
    to have a good grasp of how things work, and make tweaks when necessary. The foundational
    knowledge is also what you would need to then move your skills to the next level
    beyond this book.
  prefs: []
  type: TYPE_NORMAL
- en: Covering AWS Beanstalk without diving into the key AWS services that make AWS
    a great choice for developers will not be enough for you to obtain enough knowledge
    to be effective in the long run. However, if you take a look at AWS Beanstalk
    after going through this chapter and the next chapter of the book, you will be
    able to understand what happens behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The service can be found at[ https://aws.amazon.com/elasticbeanstalk/](https://aws.amazon.com/elasticbeanstalk/).
  prefs: []
  type: TYPE_NORMAL
- en: AWS services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to learn how to utilize the power of Go to interact with AWS
    and build cloud native applications. In this section, we'll start a practical
    dive into some AWS services needed to build modern production grade cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: AWS SDK for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the AWS SDK for Go is a collection of libraries that enables
    Go to expose the power of AWS. In order to utilize the SDK, there are some key
    concepts we need to cover first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we will need to do is to install the AWS SDK for Go; this is
    done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like any other Go package, this command will deploy the AWS SDK libraries to
    our development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the AWS region
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second step is to specify the AWS region; this helps identify where to
    send the SDK requests when making calls. There is no default region for the SDK,
    which is why we must specify one. There are two ways to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning the region value to an environmental variable called `AWS_REGION`.
    An example of a region value is `us-west-2` or `us-east-2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying it in the code—more to that later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring AWS SDK authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third step is to achieve proper AWS authentication; this step is more involved,
    but very important to ensure the security of our code that is interacting with
    different AWS services. To do this, we will need to provide security credentials
    to our applications in order to make secure calls to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to generate the credentials you need to make your code
    works when talking to AWS via the SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a user, which is simply an identity that represents a person or a
    service. You can assign individual permissions to users directly or assemble multiple
    users into a group that allow users to share permissions. The AWS SDK for Go requires
    users to be secured using AWS access keys to authenticate requests you send to
    AWS. An AWS access key is composed of two pieces: an access key ID and a secret
    access key. This is what we use when running applications from our local servers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next way is to create a role. A role is very similar to a user in that it's
    an identity with specific permissions assigned to it. However, a role is not meant
    to be assigned to people; it instead is assigned to whoever needs it based on
    specific conditions. For example, a role can be attached to an EC2 instance, which
    would allow applications running on this EC2 instance to make secure calls to
    AWS without specifying a distinct user. This is the recommended approach when
    running applications on EC2 instances, where the applications are expected to
    make AWS API calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are running your application from your own local machine, the recommended
    way to create access keys is to create a user that has specific permissions to
    access the AWS services that you would like your code to utilize. This is done
    by creating a user in the **AWS identity and access management** (**IAM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a user in IAM, we will first need to log in to the AWS main web console,
    then click on IAM, which should be under the Security, Identity & Compliance category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd9b3b4-a29c-4430-95c3-736eccb72700.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will need to click on the User option on the right-hand side, then
    click on Add user to create a new IAM user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eebc7730-bb98-494a-9a3c-8e94d4ea0874.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, you will be treated with a user creation wizard to help you create
    a user and generate access keys. In the first step of this wizard, you will get
    to choose a username and select the AWS access type for the user. The AWS access
    type consists of two main types: programmatic access or AWS management console
    access. Obviously, to create users capable of being used by the AWS SDK, we will
    need to select programmatic access, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b021144-db9b-4003-8e25-fb18962a8969.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step will involve attaching permissions to the user being created.
    There are three approaches for assigning permissions to users. However, before
    we discuss the three approaches, we will need first to understand the concept
    of policies. A policy is simply a flexible approach to define permissions. For
    example, a new policy can be created to define a read-only access to a specific
    S3 folder. Any user or group who then get this policy attached to them will only
    be permitted a read-only access to this specific S3 folder. AWS provides a number
    of precreated policies that we can use in our configuration. For example, there
    is a policy called **AmazonS3FullAccess**, which allows full access to S3 to its
    holders. Now, let''s return to the three approaches for assigning permissions
    to users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding the user to a group**: A group is an entity that can have its own
    policies. Multiple users can be added to one or more groups. You can think of
    a group simply as a folder of users. Users under a specific group will enjoy access
    to all permissions allowed by the policies of the said group. The configuration
    wizard in this step will allow you to create a new group and assign policies to
    it, if need be. This is typically the recommended way to assign permissions to
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copying permissions from existing users**: This allows the new user to enjoy
    all groups and policies already configured for a different user. This is good
    to use, for example, to add a user to a new team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attaching existing policies directly**: This allows assigning policies directly
    to the new users without going through groups or copying from other users. The
    disadvantage of this approach is that if each user get assigned individual policies
    without the sense of order provided by groups, it becomes tedious to manage the
    users as they grow in numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the three options being presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce462fe2-dd3a-4a7f-bc32-05af793fdade.png)'
  prefs: []
  type: TYPE_IMG
- en: Once this setting of permissions is done, we get to review our choices and proceed
    to create a new user. Once a new user gets created, we will get an option to download
    the user's access keys as a CSV file. We must do that in order to be able to utilize
    those access keys later in our applications. An access key is composed of the
    access key ID and the secret access key value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your access keys, there are multiple approaches to allow your
    code to use them; we will discuss three of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Utilizing a environmental variables directly**: There are two main environmental
    variables that our AWS SDK code will look for, and a third environmental variable,
    which is optional. We will only discuss the two main environmental variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AWS_ACCESS_KEY_ID`: Where we set the key ID of our access key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AWS_SECRET_ACCESS_KEY`: Where we set the secret key value of our access key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environmental variables are typically checked, by default, by the SDK before
    moving on to the next approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Utilizing a credentials file**: The credentials file is a plain text file
    that will host your access keys. The file must be named `credentials` and needs
    to be located in the `.aws/` folder of the home directory of your computer. The
    home directory will obviously vary depending on your operating system. In Windows,
    you can point out your home directory using the environmental variable `%UserProfile%`.
    In Unix platforms, you use an environmental variable called `$HOME` or just `~`.
    The credentials file is of the `.ini` format and can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The names between the square brackets are called **profiles**. As shown from
    the preceding snippet, your credentials file can specify different access keys
    mapped to different profiles. However, then comes an important question, what
    would be the profile to use for our application? For this, we would need to create
    an environmental variable called `AWS_PROFILE,` which will specify the profile
    name and the name of the application that it is assigned to. For example, let''s
    say our application is called `testAWSapp`, and that we want it to utilize the
    `test-account` profile, we will then set the `AWS_PROFILE` environmental variable
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the `AWS_PROFILE` environmental variable is not set, the *default* profile
    gets picked up by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardcoding the access keys in your application**: This is typically not recommended
    for security reasons. So although it is technically possible, do not try this
    in any production systems since anyone who would have access to your application
    code (maybe in GitHub) will be able to retrieve and use your access keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating IAM Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, IAM roles are recommended if your application is running
    on an Amazon EC2 instance. Creating an IAM role via the AWS console starts similar
    to creating an IAM user:'
  prefs: []
  type: TYPE_NORMAL
- en: We first log in to the AWS console ([aws.amazon.com](http://aws.amazon.com))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then select IAM from under the Security, Identity & Compliance category
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, we will take a different path. This time, we click on Roles on
    the right-hand side, then select Create new role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c9cad36-2933-4b29-b19e-59c49d9f6dca.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After selecting to create a new role, we will get treated with the role creation
    wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first get asked to select a role type. For our case, we will need to select
    the EC2 Service role, then Amazon EC2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c35989d-e81b-4523-8448-190604016ca7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, we will click on Next Step. We will then need to select the policies
    that our new role will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85f26f5d-5d7e-4f21-9493-e92d1cfd1556.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of our application, let''s select the following four policies:'
  prefs: []
  type: TYPE_NORMAL
- en: AmazonS3FullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonSQSFullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonDynamoDBFullAccess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AmazonAPIGatewayAdministrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will click on Next step again, then, we move to the final step where we
    get to set the role name, review our configuration, and then click on Create role to
    create a new role. For our purposes, I created a new role called `EC2_S3_API_SQS_Dynamo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a4276c7-38b6-4ee6-984b-d9b77ebcf165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we click on Create role, a new role with our selected policies gets created.
  prefs: []
  type: TYPE_NORMAL
- en: This role can then be attached on an EC2 instance, where our application code
    will run. We will explore how to do that in the EC2 section.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of the AWS SDK for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to harness the power of the AWS SDK for Go, there are two key concepts
    we will need to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first concept is the idea of sessions. A session is an object from the SDK
    that contains configuration information that we can then use with other objects
    to communicate with AWS services.
  prefs: []
  type: TYPE_NORMAL
- en: The `session` objects can be shared and used by different pieces of code. The
    object should be cached and reused. Creating a new `session` object involves loading
    the configuration data, so reusing it saves resources. `session` objects are safe
    to use concurrently as long as they don't get modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new `session` object, we can simply write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new `session` and store it in a variable called session.
    If we create a new `session` via the preceding code, default configurations would
    be utilized. If we need to override a configuration, we can pass a pointer to
    an object of the `aws.Config` type struct as an argument to the `NewSession()`
    struct. Let''s say we want to set  `Region`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another constructor we can use to create a new session is called `NewSessionWithOptions()`;
    this helps override some of the environmental variables we used to provide information
    needed to create a session. For example, we discussed earlier how we can define
    a profile to host the credentials to be utilized by our application. Here is how
    this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Service clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second concept is the idea of service clients. A service client is an object
    that provides API access to a specific AWS service such as S3 or SQS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service client objects are created from session objects. Here is an example
    of a piece of code that makes use of an S3 service client to obtain a list of
    buckets (an S3 bucket is simply a container of files and folders), then prints
    out the name of each bucket individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Service client objects are typically safe to use concurrently as long as you
    ensure that you don't change the configuration in your concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, service clients make use of Restful API calls to interact with
    AWS. However, they take care of all the tedious code involved with building and
    securing HTTP requests for you.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter and the next chapter, we will create session and
    service client objects to access the different AWS services. Sessions and service
    clients are the building coding blocks that we need to build proper AWS cloud
    native applications. The SDK allows you to dive deep into the underlying requests;
    this is typically helpful if we want to perform some operations on multiple requests
    before they get sent out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the API method calls of the AWS SDK adhere to the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The API method name would typically describe a certain operation. For example,
    let's say that we have an **Simple Queue Service** (**SQS**) service client object,
    and that we need to get the URL address of a certain queue. The method name will
    be `GetQueueUrl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input argument to the API method typically looks like `<method name>Input`;
    so, in case of the `GetQueueUrl` method, it's input type is `GetQueueUrlInput`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output type from the API method is typically similar to <method name>Output;
    so, in case of the `GetQueueURL` method, it's output type is `GetQueueUrlOutput`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Native datatypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important remark regarding the SDK methods is that almost all of the
    datatypes used as arguments or in struct fields are pointers, even if the data
    type is native. For example, instead of using a string datatype for a string value,
    the SDK tends to use `*`string instead, same with ints and other types. In order
    to make life easier for the developer, the AWS SDK for Go provides helper methods
    to convert between native datatypes and their pointers while ensuring nil checks
    are performed to avoid runtime panics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The helper method to convert a native data type into a pointer to the same
    data type follows this pattern: `aws.<datatype>`. For example, if we call `aws.String("hello")`,
    the method will return a pointer to a string where the `Hello` value is stored.
    If we call `aws.Int(1)`, the method returns a pointer to an int of value 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the method to convert a pointer back to its data type while
    doing nil checks follows this pattern: `aws.<datatype>Value`. So, for example,
    if we call `aws.IntValue(p)`, where `p` is a pointer to an int of value 1, the
    result returned is simply an int with value 1\. To clarify further, here is the
    implementation of `aws.IntValue` inside the SDK code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Shared configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since it is likely that different microservices would need to use the same configuration
    settings when interacting with AWS, the AWS provides an option to make use of
    what is called shared configuration. Shared configuration is basically a configuration
    file that is stored locally. The filename and path is `.aws/config`. Remember
    that the `.aws` folder would exist in the home folder of our operating system;
    the folder was covered before when discussing the credentials file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration file should follow an ini-like format similar to the credentials
    file. It also supports profiles in a similar way to what we covered earlier in
    the credentials file. Here is an example of what `.aws/config` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow microservices in a particular server to make use of the AWS configuration
    file of said server, there are two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `AWS_SDK_LOAD_CONFIG` environmental variable to true; this will cause
    the SDK code to use the configuration file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When creating the session object, utilize the `NewSessionWithOptions` constructor
    to enable using shared configuration. Here is what the code would look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the full AWS Go SDK documentation, you can visit [https://docs.aws.amazon.com/sdk-for-go/api/](https://docs.aws.amazon.com/sdk-for-go/api/).
  prefs: []
  type: TYPE_NORMAL
- en: Pagination methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some API operations can return a huge number of results. For example, let's
    say that we need to issue an API call to retrieve a list of items from an S3 bucket.
    Now, let's assume the S3 bucket contains tons of items, and returning all of them
    in one API call is not efficient. The AWS Go SDK provides a feature called **Pagination**
    to help in that scenario. With pagination, you get your results in multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read each page at a time, and then move to the next page of items when
    ready to process new items. API calls that support pagination is similar to <method
    name>Pages. For example, the pagination API method call that corresponds to the
    `ListObjects` S3 method is `ListObjectsPages`. The `ListObjectPages` method will
    iterate over the pages resulted from the `ListObject` operation. It takes two
    arguments—the first argument is of the `ListObjectInput` type, which will tell
    `ListObjectPages` about the name of the S3 bucket we are trying to read as well
    as the maximum number of keys we want per page. The second argument is a function
    that gets called with the response data for each page. Here is what the function
    signature looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This argument function has two arguments of its own. The first argument carries
    the results of our operation; in our case, the results will be hosted in an object
    of type `ListObjectsOutput`. The second argument is of the `bool` type, which
    is basically a flag that is true if we are at the last page. The function return
    type is `bool`; we can use the return value to stop iterating over pages if we
    wish so. This means that whenever we return false, the pagination will stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example from the SDK documentation that showcases Pagination perfectly,
    utilizing the methods we discussed. The following code will use pagination to
    go through a list of items contained in an S3 bucket. We will request a maximum
    of 10 keys per page. We will print object keys per page, then we will exit once
    we go through three pages at most. Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Waiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waiters are API calls that allow us to wait until a certain operation is completed.
    Most waiter methods typically adhere to the WaitUntil<action> format. For example,
    when working with the DynamoDB database, there is an API method call named `WaitUntilTableExists`
    , which will simply wait till a condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS Go SDK returns errors of the `awserr.Error` type, which is a special
    interface type in the AWS SDK that satisfies the generic Go error interface type.
    The `awserr.Error` supports three main methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Code()` : Returns the error code related to the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message()`: Returns a string description of the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrigErr()`: Returns the original error that is wrapped with the `awserr.Error`
    type; for example, if the problem is related to networking, `OrigErr()` returns
    the original error that probably belonged to the Go net package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to expose and make use of the `awserr.Error` type, we will need to
    make use of the type assertion feature in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s showcase how to make use of the `awserr.Error` type with a practical
    example. Let''s assume that in our application, we use a Dynamodb service client
    object to retrieve an item from a Dynamodb table via the item ID. However, we
    made a mistake in the table name and now it doesn''t exist, which will cause the
    call to fail. Code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, if the `dynamodbsvc.GetItem()` method fails and we
    can''t get the item, we capture whether an error occurred, then we use Go''s type
    assertion to obtain the underlying `awserr.Error` type from our error object.
    We then proceed to check the error code and compare it to the error code in our
    SDK that indicates a resource not found problem. If it''s indeed a resource not
    found problem, we print a message indicating as such then return. The following
    is the specific piece of code from the preceding code where we did the error detection
    and handling as described in the current paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Elastic Compute Cloud (EC2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly to any other AWS service, we will start from the AWS console in order
    to be able to initiate and deploy EC2 instances. As mentioned earlier, EC2 can
    simply be described as a service to be used when needing to spin new server instances
    on AWS. Let's explore the steps we will need to take to create, then access EC2
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Creating EC2 instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the AWS console main screen, we will need to choose EC2 in order to start
    a new EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b254480-4e67-4e85-9c40-a7ad48b3e8ba.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen will expose lots of different options to manage EC2 instances.
    For now, what we need to do is to click on the Launch Instance button. You will
    note that the AWS region is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8be8561-3162-45b5-8c30-0915899f8628.png)'
  prefs: []
  type: TYPE_IMG
- en: Afterward, we will get to select the image to use as our virtual server on the
    cloud. An **Amaz****on Machine Image** (**AMI**) is an acronym to describe an
    Amazon virtual server image combined with all the information it needs to be launched.
    An AMI includes a template that describes the operating system, the applications
    in the virtual server, the launch permissions that specify which AWS account can
    use the AMI to launch instances of the virtual server image, and a device mapping
    to specify the volumes to be attached to the instance once it launches. Amazon
    provides a number of premade AMIs that we can use right away. However, you can
    also create your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the AMI selection screen in the AWS console looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d69e094e-1c94-437d-add1-0060b6bf08d1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can tell from the AMI descriptions, an AMI defines operating systems,
    command-line tools, programming language environments such as Python, Ruby, and
    Pert.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's select the Amazon Linux AMI option to proceed to the next step.
    In this step, we get to select our desired server image. Here is where you get
    to select the number of CPU cores, the memory, and network performance among other
    things. You would note the term EBS being under Instance Storage. **Elastic Block
    Store** (**EBS**), which provides cloud hosted storage volumes and offers high
    availability, scalability, and durability. Each EBS gets replicated within its
    availability zone.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51a9e520-77b9-4ad0-9ee7-51de8abda736.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we can click on either the Review and Launch button to launch the AMI
    or the Next: Configure Instance Details button to look deeper into the configuration
    options for the instance. Deeper configuration options include the number of instances,
    the subnet, the network address, among others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring the instance details is also where we assign an IAM role (which
    we discussed earlier) to the EC2\. The IAM role we created earlier in the chapter
    was called EC2_S3_API_SQS_Dynamo, which will allow applications running on this
    EC2 instance to access S3 service, the API gateway service, the SQS service, and
    the Dynamo database. Here is what the configuration page will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb2ab8db-ed50-4cb2-bec9-0f5d60b37301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the purpose of this chapter, we will click on Review and Launch to review
    then launch the instance. Let''s take a look at the review page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca591d91-4d43-445a-89a6-8339e3474ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we are satisfied with all the settings, we can go ahead and click on Launch.
    This will show a dialog requesting a public-private key pair. The concept of public
    key encryption was discussed in Chapter 3 in more detail. In a nutshell, we can
    describe public-private key encryption as a method of encryption, where you can
    share a public key with other people so that they encrypt messages before they
    send them to you. The encrypted message can then only be decrypted via the private
    key that only you possess.
  prefs: []
  type: TYPE_NORMAL
- en: For AWS, in order to allow developers to connect to their services securely,
    AWS requests developers to select a public-private key pair to secure access.
    The public key is stored in AWS, whereas the private key is stored by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ca0b47-18a0-45da-ad3b-5a37710db0e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t already have a public-private key pair with AWS, this is the
    step where we can create one. AWS also allows you to proceed without creating
    a key, which will obviously be less secure and not recommended in production applications.
    So let''s take a look at the three options we get when click on the first list
    box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aeacf13-62ec-47ca-88ac-6bcc7f158ccc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you select the option to create a new key pair, you will get the option
    to name your key pair and to download the private key. You must download the private
    key and store it in a secure location so that you can make use of it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff9d334-940c-4e1c-86fa-c4fc60679122.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, after we download the private key and are ready to launch the instance(s),
    we can click on the Launch Instances button. This will initiate the process of
    starting the instance(s) and show us a status indicating as such. Here is what
    the next screen typically looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/a6e34d0c-cdb9-4f2f-bc98-a0ade1e12ccf.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Perfect; with this step done, we have our own Linux virtual machine running
    in the Amazon Cloud. Let's find out how to connect to it and explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing EC2 instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get access to an EC2 instance that we have already created, we need
    to first log in to the AWS console, then select EC2 as before. This will provide
    you access to the EC2 dashboard. From there, we will need to click on instances
    in order to access the currently created EC2 instances under our account.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fd786ae-a434-4833-9052-c0e58581b0d2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will open up a list of EC2 instances that were already created. The instance
    we just created is the first one; you will note that its instance ID matches with
    the instance ID that was shown when we created the instance earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72ea8a59-0a45-4664-838d-498421c065ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows us that the instance is currently running on
    AWS. We can connect to it like any remote server if we so desire. Let's explore
    how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to select the instance in question, then click on the Connect
    button. This will not connect directly to your instance; however, it will provide
    a list of useful instructions of how to establish the connection to your EC2 instance.
    In order to establish the connection, you will need to utilize the SSH protocol
    combined with the private encryption key that was downloaded earlier to remotely
    log in to the EC2 virtual server. **Secure Shell** (**SSH**) is a protocol mostly
    used to securely login to remote computers by users.
  prefs: []
  type: TYPE_NORMAL
- en: The approach to invoke SSH can be different from one operating system to another.
    For example, if you are using the Windows operating system, then you should use
    the popular PuTTY tool (found at [https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html) )
    to establish the SSH connection to the EC2 instance. If you are using macOS or
    Linux, you can use the SSH command directly.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing EC2 instances from a Linux or macOS machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to access EC2 instances created on AWS from a Linux or a macOS machine,
    we will need to use the SSH command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to ensure that the connection private key—which we downloaded
    earlier when we created the EC2 instance—is secure and cannot be accessed by external
    parties. This is typically done by executing the following command on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`my-super-secret-key-pair.pem` is the name of the file that contains the private
    key. Obviously, if the filename is different, then you will need to ensure that
    the command will target the correct filename. For the preceding command to work,
    we will need to run it from the same folder as where the key is located. Otherwise,
    we will need to specify the path to the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we ensure that the key is protected against public access, we will need
    to make use of the SSH command to connect to our EC2 instance. For this, we will
    need three pieces of information: the private key filename, the EC2 image username,
    and the DNS name of the connection. We already know the key filename, which means
    we now need to figure out the username and the DNS name of the connection. The
    username will depend on the EC2 instance operating system. The following table
    shows the operating system to username mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operating System** | **User Name** |'
  prefs: []
  type: TYPE_TB
- en: '| Amazon Linux | `ec2-user` |'
  prefs: []
  type: TYPE_TB
- en: '| RHEL (Red Hat Enterprise Linux) | `ec2-user` or root |'
  prefs: []
  type: TYPE_TB
- en: '| Ubuntu | ubuntu or root |'
  prefs: []
  type: TYPE_TB
- en: '| Centos | centos |'
  prefs: []
  type: TYPE_TB
- en: '| Fedora | `ec2-user` |'
  prefs: []
  type: TYPE_TB
- en: '| SUSE | `ec2-user` or root |'
  prefs: []
  type: TYPE_TB
- en: For other operating systems, if `ec2-user` or root don't work, check with the
    **Amazon Machine Image** (**AMI**) provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the remaining piece of information we need is the DNS name of the connection
    to the EC2 instance. We can find it by simply looking at the EC2 instance details
    on the status page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad397b79-0039-4abe-bede-8632405a7396.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this, we have all what we need to execute an SSH command to access our
    EC2 instance; the command will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The private key name in the preceding command is `my-super-secret-key-pair.pem`,
    the username is `ec2-user`, whereas the DNS is `ec2-54-193-5-28.us-west-1.compute.amazonaws.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will allow us access to the EC2 instance that we just created;
    here is what the screen will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ff19708-efe2-4851-ac97-938e07d0f6bf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing EC2 from Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access EC2 from Windows, we can either use a Windows version of the SSH
    tool we covered in the preceding section or we can use PuTTY. PuTTY is a very
    popular SSH and telnet client that can run on Windows or Unix. To download PuTTY,
    we need to visit [https://www.chiark.greenend.org.uk/~sgtatham/PuTTY/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html).
    Once we download PuTTY, install and run it, the main screen will look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/207250d6-fde7-4379-9169-0abf6ea8e15c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we can use PuTTY to connect to our EC2 instance, we will need to convert
    the private key file that we obtained earlier into a different file type that
    can be easily consumed by the PuTTY software.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the private key conversion, we will need the help of a tool called
    **PuTTYgen**, which gets installed with PuTTY. PuTTYgen can be found under All
    Programs>PuTTY>PuTTYgen. Here is what PuTTYgen looks like after it starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdff06dc-02fb-4712-8e2f-03c302af006f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Under Parameters, ensure that RSA is selected as the encryption algorithm, with
    2048 as the number of bits in the generated key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, let''s click on the Load button in order to be able to load our
    AWS private key into the tool. The Load button will open a dialog to allow us
    to select the private key file. We will need to select the option to show all
    files in order to make the private key file view-able:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d2982a9-f062-4409-a9a5-1db4a6b3dafa.jpg)![](img/f8583255-4a60-463b-a99f-438c4c5a4202.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can then select the key, then click on Open in order for the key to get loaded
    into the PuTTYgen tool. The next step is to click on Save Private Key to finish
    the key conversion. A warning will show up inquiring whether you are sure you
    want to save this key without a passphrase to protect it; click on Yes. The passphrase
    is supposed to be an extra layer of protection; however, it requires user input
    to work. So, if we want to automate the SSH connection to the EC2 instance, we
    shouldn't have the passphrase enabled. After we click on Yes, we can select the
    filename for the converted file; then, we click on Save to create and save the
    file. The PuTTY private key is of the `*.ppk` type.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c85fbf2-43ae-4a09-aa1b-5d27f808eed9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect; we now have a PuTTY private key ready for our use case. The next step
    is to open the PuTTY tool in order to use this key to connect to the EC2 instance
    via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: After we open PuTTY, we need to go to the SSH option under the Connection category,
    then from there, navigate to the Auth option. At the Auth window, we will search
    for the option to load the PuTTY private key file we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e53ca77-6eab-49df-8f7d-768d851c25e3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will need to click on the Session category on the right-hand side.
    Then, under the Host Name (or IP address) field on the right-hand side, we will
    need to enter the username and the public DNS address in the following format:
    `username@DNS public` name. In our case, it looks like this: `ec2-user@ec2-54-193-5-28.us-west-1.compute.amazonaws.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf2b45f-2151-4049-8945-fde0f0f4e015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From there, we can click on Open to open a session to the EC2 instance. The
    first time we try to open the session, we will get a message asking whether we
    trust the server we are trying to connect to. If we trust it, we need to click
    on Yes, which will cache the server's host key into the registry.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77b9cfd9-072d-4096-921b-496eb7385b4c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open up a secure session to our EC2 instance; we can then use it
    however we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00be9dc3-a3da-4f8d-a8a9-2d4181bfe384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'PuTTY has the ability to save existing session information. After we finish
    our configuration, we can choose a name then click on Save as shown in the following
    figure in order to save the session information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/500c1a98-a1ce-4b03-8708-36d030ee784b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great! This covers enough practical knowledge about how to configure and set
    up an EC2 instance in different operating systems. Now, there is an additional
    topic we need to cover, that is, Security Groups. You can think of a security
    group as a collection of firewall rules around your EC2 instance. For example,
    by adding a security rule, you can allow applications running on your EC2 to accept
    HTTP traffic. You can create rules to allow access to specific TCP or UDP ports,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are expected to deploy web services to our EC2 instances, such as the
    *events microservice*. We need to create a security group that allows HTTP traffic,
    then assign the group to our EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we will need to do is to open up the EC2 dashboard by going
    to the AWS console main screen, then selecting EC2 as we did before. Once we are
    inside the EC2 dashboard, we can click on Security Groups on the left-hand side,
    which will be under the Network & Security category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36d1816b-74f9-4ab2-990c-27c3e84882cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The security groups dashboard will show a list of all the Security Groups that
    have been already created. The dashboard allows us to create new groups or edit
    existing groups. Since, in our case, we are creating a new group, we will need
    to click on Create Security Group on the upper left-hand side of the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1670b49c-b298-42f0-8ee2-c1170abfab72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A form window will come up with fields that we need to fill in order to create
    our security group. First, we will need to provide a name for the security group,
    an optional description, the name of the virtual private cloud where our security
    group will apply. A virtual private cloud is simply defined as a logically isolated
    section in the AWS cloud; we can define our own.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd0cd79-5c5f-499d-834b-4748c570f914.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we named our security group HTTP Access; we described
    it as the security group to enable HTTP access, and then we choose the default
    VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to click on the Add Rule button to start defining the rules
    that will compose our security group. After we click on it, a new row will appear
    inside the Security group rules section. We need to click on the listbox under
    the Type column, then select HTTP. Here is what the result will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9f229e1-0ed8-4178-b573-d739f09ebedd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will note that the protocol, port range, and source fields will be filled
    up for you. TCP is the underlying protocol for HTTP, whereas port 80 is the HTTP
    port.
  prefs: []
  type: TYPE_NORMAL
- en: We can also add an HTTPS rule if we would like; we will follow the same steps,
    except when we choose the Type, where HTTPS will be chosen instead of HTTP. You
    can also explore the rest of the options to discover what other exceptions can
    be created under a security rule.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13c00405-b940-45fc-ba07-6ff2f18c67a4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once a security group is created, we will find it in the list of our security
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f075d6d8-2d43-49d2-b962-408777d5df54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have a security group created, we can attach it to an existing EC2
    instance. This is done by going back to the EC2 Dashboard, then selecting Running
    instances, and then selecting the instance of interest from the list of EC2 instances.
    From there, we click on Actions, then Networking, and then Change Security Groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61cd6d91-ca7e-4826-bd10-8f75bfbc3c8c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, we can choose the Security Groups that we would like to attach
    to our instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98eb077e-f893-4185-8fdb-351b31958231.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect; with this, our EC2 instance now allows HTTP access to applications
    running inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Another important remark is that we can assign security groups to EC2 instances
    at the time of the EC2 instance creation. We access this option by clicking on
    Configure Instance Details while creating a new instance, then following the configuration
    wizard to the Configure Security Group option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started covering AWS, by learning how to configure EC2 and
    how to work with the AWS SDK for Go. In the next chapter, we'll continue to dive
    deeper into AWS, by learning about some of the key AWS services and how to write
    Go code that can make proper use of them.
  prefs: []
  type: TYPE_NORMAL
