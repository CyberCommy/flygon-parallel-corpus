- en: '*Chapter 6*: Setting Up and Pentesting AWS Aurora RDS'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Aurora provides SQL-like database functionality to AWS accounts with simplicity.
    Focused around using PostgreSQL and MySQL, such as querying, Aurora makes interacting
    with high-performance storage systems easy for the user. The side effects can
    have a deadly cost, however, and can lead to data leaks if not adequately secured.
    This chapter is going to discuss the ins and outs of what Aurora has to offer,
    and also take a look at the dangers of **SQL injection** (**SQLi**) – a malicious
    attack against websites that host services such as MySQL. We will also discuss
    mitigation and preventions of **denial of service** (**DoS**) and **distributed
    denial of service** (**DDoS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and setting up the Aurora RDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White box/functional pentesting Aurora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a lab for SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fun with SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding DDoS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the instructions in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Juice Shop will be used to create our lab for SQli. More information can be
    found here: [https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code used in this chapter is available at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/bkimminich/juice-shop](https://github.com/bkimminich/juice-shop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Default-Credentials/mssql-betterdefaultpasslist.txt](https://raw.githubusercontent.com/danielmiessler/SecLists/master/Passwords/Default-Credentials/mssql-betterdefaultpasslist.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2TIx2qz](https://bit.ly/2TIx2qz)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and setting up the Aurora RDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227), *Understanding
    Vulnerable RDS Services*, we took a look at relational databases and set up our
    own RDS database, as well as implemented MySQL as the underlying service running
    on the RDS instance. As you saw, it's relatively straightforward to set up a database,
    so now we are going to start looking at Aurora.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of Aurora is simplicity, something that we are going to take a look
    at when we set up an Aurora cluster. Because Aurora runs on top of RDS, it does
    most of the *heavy lifting* and allows you to interface with everything the same
    as you would before. Another great benefit to Aurora is security. Aurora uses
    encryption of both data at rest and data in transit. Encryption at both levels
    ensures the confidentiality of the data that is either being stored or used. When
    pentesting, data such as **personal identifiable information** (**PII**) is extremely
    sensitive and should be disclosed if found unencrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If PII is found unprotected during a pentest, the pentest should cease to resume
    and managers should immediately be notified.
  prefs: []
  type: TYPE_NORMAL
- en: Aurora is MySQL- and PostgreSQL-compatible. One of the great things about Aurora
    is that tools that require services such as MySQL and PostgreSQL can also run
    within Aurora. Aurora is built with database engines that have the same or similar
    database engines as both MySQL and PostgreSQL
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's set up a database with Aurora and MySQL using some of the knowledge
    that we have.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Aurora
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up Aurora should be relatively less complicated now that we have set
    up databases with RDS. If you haven't already, go to [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227),
    *Understanding Vulnerable RDS Services*, and set up a database so that you understand
    the steps in setting up a database with AWS. Having a database is required to
    move forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, go to the Amazon RDS console and click **Create Database**
    to begin. Next, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Standard Create**:![Figure 6.1 – Selecting Standard Create
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.01_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Selecting Standard Create
  prefs: []
  type: TYPE_NORMAL
- en: Select **Amazon Aurora with MySQL compatibility**:![Figure 6.2 – Aurora selection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.02_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Aurora selection
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Regional Database** location to fit your location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Database features** screen, select **One writer and multiple readers
    - Parallel query**. This is a great approach because it allows a hybrid workload
    that is much more redundant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – One writer and multiple readers - Parallel query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.03_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – One writer and multiple readers - Parallel query
  prefs: []
  type: TYPE_NORMAL
- en: On the **Settings** page, give your cluster a name. Make sure that you remember
    the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the username and password:![Figure 6.4 – Creating a username and password
    for your new instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.04_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Creating a username and password for your new instance
  prefs: []
  type: TYPE_NORMAL
- en: Select **Password Authentication**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Create Database**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – New Aurora cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.05_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – New Aurora cluster
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it – we have set up an Aurora database cluster that we can
    use. Try connecting to it and testing out some of the functionality the same way
    you did with testing MySQL in the previous chapter, [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227),
    *Understanding Vulnerable RDS Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our Aurora instance running, let's dive into a pentesting exercise
    that will demonstrate how an actual pentester would look at some *low-hanging
    fruit* associated with an Aurora pentest.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '*Low-hanging fruit* are easy-to-exploit vulnerabilities found within systems,
    networks, and applications.'
  prefs: []
  type: TYPE_NORMAL
- en: White box/functional pentesting Aurora
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we did before with RDS, we are going to look and see what we can find
    out about Aurora from a pentesting point of view. We know the environment since
    we set it up, but for the sake of the next exercise, let's say we are pentesting
    an Aurora instance. This test involves looking at whether the instance is accessible
    by the public, how strong the password field is, and anything else we may be able
    to do while looking at the instance.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we want to do this is to expose the white box pentesting methodology
    in as many cases as possible. White box pentesting is the most common pentesting
    methodology because it allows pentesters to fully pentest everything for both
    functional purposes and compliance purposes. We are going to apply this to our
    Aurora instance.
  prefs: []
  type: TYPE_NORMAL
- en: Our engagement starts off with scanning the Aurora instance. Remember, we don't
    know anything except the address of the instance!
  prefs: []
  type: TYPE_NORMAL
- en: Recon – scanning for public access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we need to check and see whether the instance is public or not.
    We can do this by running a `no ping` scan using NMAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Scanning Aurora and discovering port 3306'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.06_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Scanning Aurora and discovering port 3306
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding screenshot, it looks like the instance is in fact publicly
    accessible on port `3306`, a port that the MySQL service uses. Now we know the
    following about the target host:'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL is being used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port `3306` is open to the public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information is extremely important because we know that the system is running
    on the default port for MySQL, and we know what database type is being used. Because
    it is using a default port, that could mean that fewer security controls have
    been put in place.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Changing ports to different services adds a bit of security through obscurity.
    However, it can be a sign that more security may be implemented on the target.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can move on to taking a deeper look at getting access to the Aurora
    instance. This will call for some brute-forcing using a username and password
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating the username and password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have some more information on what services are running, we need
    to go ahead and start attacking the services. For this next step in our white
    box pentest methodology, we will start looking to see whether we can find some
    weak passwords. If we discover usernames and passwords, we can get direct access
    to the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good and quick way to discover usernames and passwords is to try using default
    names against services and appliances. In our case, we know that MySQL uses a
    default username of `admin`. Since we know this, we are going to brute-force using
    the `admin` username and use a password list that can be found on GitHub by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the password list, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the file, you''ll notice that the list has both usernames and passwords
    – we only want the passwords. We can use the `awk` command to slice and print
    only the passwords and store them in a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our list of passwords generated, it''s time to take a look
    and see whether we can get the username and password to Aurora. We will use Metasploit
    to execute this. First, you''ll need to start up Metasploit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will load the `mysql` login scanner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your module loaded, you''ll need to set a few parameters. Just
    as before in [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227), *Understanding
    Vulnerable RDS Services*, set the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have all your parameters set, use the `run` command to execute the
    scan against the Aurora host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Brute-forcing for passwords'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.07_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Brute-forcing for passwords
  prefs: []
  type: TYPE_NORMAL
- en: 'We have successfully enumerated the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Using default passwords is extremely dangerous! Ensure default usernames and
    passwords are reported when discovered. Proper remediation is to change the password
    and username to something that falls within the guidelines of **strong** usernames
    and passwords.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we have the credentials that give us access and rights to everything.
    This would allow us to delete databases and tables, as well as add our own backdoors.
    It's extremely important to highlight the issues involved with weak credentials
    when they are discovered because as you can see, we were able to take over the
    database!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of how the backend works, let's take
    a look at how we can hack (ethically) the frontend by setting up our very own
    vulnerable website.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a lab for SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next exercise we are going to go over involves setting up an EC2 instance,
    installing a vulnerable web program, and installing the Docker service on your
    EC2 instance. Once everything is up and running, we'll start looking into some
    actual SQLi and testing vulnerable areas of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerable application we are installing, **Juice Shop**, is a very popular
    web application full of hacking challenges that range from different levels of
    difficulty – it even comes with a hacker dashboard that you can use to track your
    progress. To discover more about this application, OWASP has a page full of useful
    information about the project ([https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: This exercise does not involve Aurora – it involves SQLi and pentesting parameters
    that you may see used with websites using Aurora. The purpose of the exercise
    is to get more familiar with SQLi and how dangerous it can be.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, you will need to set up an EC2 instance. By now, you should be comfortable
    with setting up your instances; however, please reference [*Chapter 1*](B15630_01_Final_ASB_ePub.xhtml#_idTextAnchor025),
    *Building Your AWS Environment*, if you need a refresher!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re on the EC2 dashboard, please take the following steps to get your
    instance up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Launch Instance**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an **Amazon Machine Image** (**AMI**). The AMI we are using is **Amazon
    ECS-Optimized Amazon Linux 2 AMI**:![Figure 6.8 – Selecting the correct image
    for the SQLi lab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_6.08_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – Selecting the correct image for the SQLi lab
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure **Instance Details**, unfold **Advanced Details**, and copy the following
    script into **User Data**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you get to the security groups, ensure that port `80` is open to all for
    both incoming and outgoing traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch your instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a browser and search for the public DNS name of your EC2 instance. The
    easiest way to do that is to right-click on the instance and select `.sh` script
    that contains the script in *step 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may not be able to connect over HTTP. A common issue is misconfiguring
    security groups while setting up EC2\. If you cannot connect over HTTP, ensure
    that your security group allows you to connect. Refer to the following screenshot
    and ensure that your security groups are set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Security group dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.09_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – Security group dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re finished setting up, you should see the main dashboard for Juice
    Shop once you connect to your public DNS in your web browser. To view the application,
    put the public DNS name for the EC2 instance into your browser and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The Juice Shop dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.10_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – The Juice Shop dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Great job, we have successfully stood up our own vulnerable lab in AWS. Before
    we get moving further, let's take a look at some quick clean-up items we can do
    before we start pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Juice Shop autostart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we continue, we want to do a quick **housekeeping** step that will automate
    starting Juice Shop for us anytime our EC2 instance is started up. Having to manually
    start up the service every time we bring the instance up can be a pain, and this
    helps preserve some of our time so that we don't always have to start up the service
    manually whenever we bring the instance online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break it down into the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to make a one-liner script that will initiate on startup. There
    are two different ways we can do this. First, navigate to the `init.d` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re in the directory, make a script that `init` can call at startup.
    In this case, we will call it `juiceShop.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Place the following script in the file and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method is by adding it to the instances'' **cron jobs**. A cron job
    is a time-based job that users can schedule on Unix operating systems. The **job**
    is a task set to run at whatever interval the user sets. In our case, we want
    Juice Shop to run when the instance is started up. To do this, type the following
    command in your EC2 terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an instance with a working version of Juice Shop to start testing
    SQLi! Before moving forward, ensure that your instance automatically starts Juice
    Shop on startup by restarting the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start to perform SQLi and pentest our vulnerable instance.
  prefs: []
  type: TYPE_NORMAL
- en: Fun with SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything set up, let's move forward and do some pentesting
    on the vulnerable web application, Juice Shop. If you need a refresher on what
    SQLi is and how it works, please review [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227),
    *Understanding Vulnerable RDS Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can begin, we need to make sure of a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: Our EC2 instance with Juice Shop is started and accessible via a web browser.
    This will ensure that we can access it for the following exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our *local* Kali Linux virtual machine is started up in a virtual box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have completed both of those steps, proceed to the public DNS of your
    Juice Shop EC2 instance. Next, let's move to the *scoreboard* to see what challenges
    are on the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move to the directory in your web browser: http://<<public dns>>/#/score-board/:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The Juice Shop scoreboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.11_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – The Juice Shop scoreboard
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Finding `/score-board` is a challenge within the web application. If you would
    like to try various ways to find it, I recommend using a directory search tool,
    such as `gobuster`, `dirb`, or `dirbuster`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have quite a few challenges to select from. We are only
    going to focus on the injection challenges; however, feel free to look at the
    other challenges too. Since we only want to do the injection tasks, click **Hide
    all** to remove all the tasks – this should make all the challenges disappear.
    Once all the tasks are gone, click **Injection** – this will make all the injection
    challenges appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The Juice Shop scoreboard with injection only'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.12_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – The Juice Shop scoreboard with injection only
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have an extensive list of challenges to choose from. Each
    challenge has a number of stars next to it – these stars indicate the difficulty
    that each challenge is. The more stars, the more difficult a challenge is. Let's
    use each of these challenges as a task that we would get on an actual pentest.
  prefs: []
  type: TYPE_NORMAL
- en: Our first challenge will be bypassing the admin login prompt and getting admin
    access to the web app.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing the admin login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alright, let's begin with a simple challenge that is quite often an actual "in-scope"
    task during a pentest. An in-scope task is something that is allowed (in-scope)
    and is required during the pentest (task). This means that a client will want
    you to give feedback on a specific task, such as the outcome, manual assessment,
    and areas of concern. In our case, we would need to give feedback on the web application
    and how we tested it, as well as how it can be remediated.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's assume Juice Shop brought up a new store that runs within AWS. They
    want us to test the functionality of the login page and see whether it is vulnerable
    to any injection. Doing so helps give Juice Shop an idea of how secure their web
    application is and what they need to fix. This is a proactive approach because
    they want us to assess for security, not compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Testing for compliance does not mean that you are testing for security. Testing
    for compliance entails following a checklist of items to test what may or may
    not be "secure" in the grand scheme of things.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with pentesting!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we need to go to the login page. The login page can be found
    at the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Login page for Juice Shop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.13_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Login page for Juice Shop
  prefs: []
  type: TYPE_NORMAL
- en: Great, now we have the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s test with some odd parameters to see whether the login page handles
    input correctly or not. To test the login input functionality, put `''` into the
    username field. The password can be anything you want it to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Checking for an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.14_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Checking for an error
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get an error, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Error from input'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.15_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Error from input
  prefs: []
  type: TYPE_NORMAL
- en: You can see that it gives us an error stating an object. This is telling us
    that it isn't handling input validation – however, it isn't really telling us
    what type of syntax error it is. From here, we need to make some educated guesses
    on what type of syntax we need to use to execute injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to try and use a simple `TRUE` statement that may allow us administrator
    access to the website. Just as before, the password, in this case, doesn''t matter.
    What we are focusing on is the input of the email field. In the email field, input
    the following true statement: `''OR ''1''=''1''--`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Testing SQLi'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.16_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – Testing SQLi
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, we have administrator access! That's
    because the input fields do not sanitize input and will execute any input as long
    as the statement is true. In our case, `1=1` is true, so the command was processed.
    Again, if you need a refresher on SQLi, go back to [*Chapter 5*](B15630_05_Final_ASB_ePub.xhtml#_idTextAnchor227),
    *Understanding Vulnerable RDS Services*, for a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we see we can log in as an admin, let's see how this affects a non-admin
    user. Next, we will see what type of users we can log in as.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in as another user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have administrator access, let's see whether we can pivot and log
    in as another user. Being able to show internal movement after post-compromise
    is essential to pentesting and reports. If you're able to pivot throughout the
    network and take ownership of other accounts unnoticed, this tells clients how
    good their detection processes are.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Reporting a lack of detection and alerts is a large part of pentesting. If targets
    don't flag you and send out an alert, then that means they wouldn't see an attacker
    inside their network.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a user named `bender` that may have valuable information on their
    account. For intensive purposes, we will see that we were assigned to find a user
    and found him during recon, using a tool such as `theHarvester`. It''s been requested
    that we see whether we can get a hold of this account. To test for this, we will
    first need to see what the nomenclature is for emails on Juice Shop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Getting the email scheme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.17_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – Getting the email scheme
  prefs: []
  type: TYPE_NORMAL
- en: 'After successful recon, we see that the email address domain is `@juice-sh.op`.
    Now, we can move forward back to the login page and test using the same method
    as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Testing SQLi with benders account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.18_B15630.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Testing SQLi with benders account
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll be prompted with a banner like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*You successfully solved the challenge: Login Bender*'
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully completed the task assigned to us and will be able
    to deliver a report on how we were able to successfully obtain both the administrator
    account and the `bender` user's account.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have performed some SQLi and executed it, let's start understanding
    how we can prevent it and how we would tell clients and businesses how they can
    help mitigate any potential issues within their organization.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing SQLi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a quick discussion based on how we can prevent SQLi. As we saw before,
    SQLi can be a simple tactic that can give attackers the *keys to the kingdom*
    if not mitigated correctly. Now that we have done this first-hand, let's take
    a look at a way to prevent it!
  prefs: []
  type: TYPE_NORMAL
- en: 'When assessing Juice Shop, we were able to exploit the application by putting
    true statements into the **Email** field. SQLi was successful due to the input
    field in the **Email** section not being **parameterized**. The next examples
    illustrate bad querying and good querying statements. These statements are within
    the actual database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Both of these queries would be executed; however, only the **second** query
    uses just the email query, as opposed to the first query, which looks at the whole
    parameter that is being passed and interprets the command as a whole SQL query.
    This is how we were able to get a hold of the administrator account on Juice Shop.
    Instead of the whole string being processed, a statement is constructed using
    the SQL statement, plus the email.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have taken a look at how SQLi works and a way to mitigate it, let''s
    take a look at how we can mitigate one of the most dangerous attacks that can
    happen to your AWS enterprise: **DoS**!'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding DoS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DoS** is a serious web application vulnerability that has the ability to
    disrupt the availability of services and applications. The goal of DoS is to shut
    down the target network, service, or application and make it inaccessible to users
    and administrators – however, ultimately, users are the primary target audience.'
  prefs: []
  type: TYPE_NORMAL
- en: A much more sophisticated and disruptive version of a DoS attack is **DDoS**
    attack – using multiple attacker machines to attack a target host. DDoS attacks
    are often highly skilled and planned attacks that use botnets to unleash large
    volumes of unwanted traffic towards a target.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A botnet is a large cluster of compromised machines used to carry out malicious
    attacks unknown to the owners of those machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'DDoS attacks have two very distinct classifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure-layer attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application-layer attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a quick look at what both of these classifications detail. While
    we won't be able to actually DoS anything in AWS, it's still good to take a dive
    into the classifications and look at how we can minimize the chances of an AWS
    environment becoming a victim to DoS or DDoS.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure-layer attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attacks at this layer are typically attacks such as SYN floods and other attacks
    that exhaust resources on the victim host. They work by sending an overwhelming
    amount of traffic at a target, rendering it unavailable. These types of attacks
    typically aren't used during a pentest, since if successful, they would completely
    shut a client's infrastructure down. However, it is still good practice to look
    for indicators that may indicate that a client's infrastructure is not prepared
    to handle a DoS attack, such as a lack of detected malformed packets from multiple
    hosts or not detecting certain signatures used by DDoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Application-layer attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of attack is a less common attack vector that you will see; however,
    it is something you may actually do during a pentest. Attacks at the application
    layer involve looking at an application, rather than a whole company, and look
    to "break" the application if possible. In pentesting, a DoS attack on an application
    could be fuzzing the application until the application errors out and is not able
    to function anymore. This is an extremely common technique in **buffer overflows**.
  prefs: []
  type: TYPE_NORMAL
- en: While we won't dive into buffer overflows in this book, I highly encourage you
    to look at some beginner-friendly exercises that will help you get familiar with
    the concept ([https://github.com/stephenbradshaw/vulnserver](https://github.com/stephenbradshaw/vulnserver)).
  prefs: []
  type: TYPE_NORMAL
- en: Protection against DDoS in AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the issues that DDoS can bring to a business, it's crucial
    that we understand a few concepts of how we can protect against a disruption-style
    attack. It's important to ensure that you have safeguards around your infrastructure
    that don't allow unsolicited traffic, and that rules are in place that only allow
    needed traffic. Your client business will need to understand what normal traffic
    is and what isn't normal traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Backups and scaling are vital to ensure you are being protected from DDoS. If
    proper scaling has been implemented, another system can pick up the slack if another
    system goes down due to an error or an attack. AWS has an application called **AWS
    Shield** – a fantastic DDoS-managing application ([https://aws.amazon.com/shield/](https://aws.amazon.com/shield/)).
  prefs: []
  type: TYPE_NORMAL
- en: Using **web application firewalls** (**WAFs**) is a great way to protect any
    public web-facing applications you have, especially if they are used for employees
    and customers. AWS WAF provides customizable web security that allows administrators
    to identify and remove targets before they even hit the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Aurora and its uses within AWS. We set up
    our own Aurora instance and learned how to look for misconfigurations by using
    common pentesting techniques. Moving on, we learned how to set up a SQLi lab in
    an EC2 instance and practiced some common injection methods that you would see
    in a real-life pentest. We finished up the chapter by talking about DoS attacks
    and their impact on businesses.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed this chapter, you're able to set up your own labs
    within AWS that allow you to test SQLi attacks in a safe and authorized environment,
    as well as understand the basics of pentesting Amazon Aurora.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at Lambda services and learning
    how to look for misconfigurations within Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queries with Aurora: [https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html](https://docs.aws.amazon.com/AmazonRDS/latest/AuroraUserGuide/aurora-mysql-parallel-query.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up WordPress in AWS: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/php-hawordpress-tutorial.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/php-hawordpress-tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
