- en: '*Chapter 15*:'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematics and Puzzles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers a controversial topic that''s faced in interviews: mathematics
    and puzzle problems. A significant number of companies consider that these kinds
    of problems should not be part of a technical interview, while other companies
    still consider this topic relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: The problems included in this topic are brain-teasing and may require a decent
    level of knowledge in mathematics and logic. You should expect such problems if
    you plan to apply to a company that works in academic fields (mathematics, physics,
    chemistry, and so on). However, big companies such as Amazon and Google are also
    willing to rely on such problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Tips and suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be familiar with these kinds of problems
    and be able to explore more such problems.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code files present in this chapter are available on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Tips and suggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you get a brain-teaser problem, the most important aspect is to not panic.
    Read the problem several times and write down your conclusions in a systematic
    approach. It is mandatory to clearly identify what input, output, and constraints
    it should obey.
  prefs: []
  type: TYPE_NORMAL
- en: Try to take several examples (input data samples), make some sketches, and keep
    talking with the interviewer while analyzing the problem. The interviewer doesn't
    expect you to have the solution immediately, but they are expecting to hear you
    talking while trying to solve the problem. This way, the interviewer can track
    the logic of your ideas and understand how you approach the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is very important to write down any rules or patterns that you noticed
    while developing the solution. With every statement you write down, you are closer
    to the solution. Commonly, if you look from the solution perspective (you know
    the solution), such problems are not extremely hard; they just require a high
    level of observation and increased attention.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try a simple example. Two fathers and two sons sit down and eat eggs.
    They eat exactly three eggs; each person has an egg. How is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time you've seen such a problem, you may think that it
    is illogical or impossible to solve. It is normal to think that there is some
    mistake in the text (there was probably four eggs, not three) and read it again
    and again. These are the most common reactions to brain-teaser problems. Once
    you see the solution, it looks quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's act as a candidate in the presence of the interviewer. The following
    paragraphs follow a *thinking aloud approach*.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem obvious that if each person has an egg and there are three eggs,
    then one of them doesn't have any egg. So, you may think that the answer is that
    three people eat an egg (each of them eats an egg) and that the fourth person
    doesn't eat anything. But the problem says that two fathers and two sons sit down
    and eat eggs, so all four of them eat eggs.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about thinking like this: each person has an egg and they (four people)
    eat exactly three eggs, so it doesn''t say that each person *eats* an egg; they
    only *have* an egg. Maybe one of them shares their egg with another person. Hmmm,
    this doesn''t seem too logical!'
  prefs: []
  type: TYPE_NORMAL
- en: Is it possible to have only three people? If one of the fathers is also a grandfather,
    this means that the other father is a son and a father at the same time. This
    way, we have two fathers and two sons via three people. They eat three eggs and
    each of them has an egg. Problem solved!
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the solution is the result of a cascade of reasoning that eliminates
    the wrong solutions one by one. Trying to solve the problem by eliminating the
    wrong solutions via logical deduction is one of the approaches to solving these
    kinds of problems. Other problems are just about computing. Most of the time,
    there are no complicated computations or a lot of computations, but they require
    mathematical knowledge and/or deductions.
  prefs: []
  type: TYPE_NORMAL
- en: It is quite hard to claim that there are some tricks and tips that will help
    you solve math and logical puzzle problems in seconds. The best approach is to
    practice as much as possible. With that, let's proceed with the *Coding challenges*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following 15 coding challenges, we will focus on the most popular problems
    from the math and logical puzzles category. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – FizzBuzz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a positive integer, *n*. Write a problem
    that prints the numbers from 1 to *n*. For multiples of five, print *fizz*, for
    multiples of seven, print *buzz*, and for multiples of five and seven, print *fizzbuzz*.
    Print a new line after each string or number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This is a simple problem that relies on your knowledge of division
    and the Java modulus (%) operator. When we divide two numbers, the *dividend*
    and the *divisor*, we get a *quotient* and the *remainder*. In Java, we can obtain
    the remainder of a division via the modulus (%) operator. In other words, if *X*
    is the dividend and *Y* is the divisor, then *X* modulus *Y* (written in Java
    as *X* % *Y*) returns the remainder of dividing *X* by *Y*. For example, 11(dividend)
    / 2(divisor) = 5(quotient) 1(remainder), so 11 % 2 = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put another way, if the remainder is 0, then the dividend is a multiple of
    the divisor; otherwise, it''s not. So, a multiple of five must respect that *X*
    % 5 = 0, while a multiple of seven must respect that *X* % 7 = 0\. Based on these
    relations, we can write the solution to this problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *FizzBuzz*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Roman numerals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a positive integer, *n*. Write a snippet
    of code that converts this number into its Roman number representation. For example,
    if *n*=34, then the Roman number is XXXIV. You''ve been given the following constants,
    which contain the Roman number symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Roman numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – Roman numbers
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem relies on the fact that Roman numbers are common
    knowledge. If you''ve never heard about Roman numbers, then it is advisable to
    mention this to the interviewer. They will probably agree to give you another
    coding challenge in place of this one. But if you do know what the Roman numbers
    are, then great – let''s see how we can write an application that solves this
    problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm for this problem can be deduced from several examples. Let''s
    look at several use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* = 73 = 50+10+10+1+1+1 = L+X+X+I+I+I = LXXIII'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* = 558 = 500+50+5+1+1+1 = D+L+V+I+I+I = DLVIII'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* = 145 = 100+(50-10)+5 = C+(L-X)+V = C+XL+V = CXLV'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* = 34 = 10+10+10+(5-1) = X+X+X+(V-I) = X+X+X+IV = XXXIV'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* = 49 = (50-10)+(10-1) = (L-X)+(X-I) = XL+IX = XLIX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Roughly, we take the given number and try to find the Roman symbols corresponding
    to ones, tens, hundreds, or thousands. This algorithm can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the thousand's place and print the corresponding Roman number. For
    example, if the digit at thousand's place is 4, then print the Roman equivalent
    of 4,000, which is MMMM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by dividing the number using digits at hundred's place and print the
    corresponding Roman number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by dividing the number using digits at ten's place and print the corresponding
    Roman number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue by dividing the number using digits at one's place and print the corresponding
    Roman number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, this algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *RomanNumbers*. Another approach relies on
    successive subtractions instead of division. The *RomanNumbers* application contains
    this implementation as well.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Visiting and toggling 100 doors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given 100 doors in a row that are initially
    closed. You have to visit these doors 100 times and each time you do, you start
    from the first door. For each visited door, you toggle it (if it is closed, then
    you open it, and vice versa). At the first visit, you visit all 100 doors. At
    the second visit, you visit every second door (#2, #4, #6 ...). At the third visit,
    you visit every third door (#3, #6, #9, ...). You follow this pattern until you
    visit only the 100th door. Write a snippet of code that reveals the state of the
    doors (closed or opened) after 100 visits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The solution to this problem can be intuited by traversing several
    steps. At the initial state, all 100 doors are closed (in the following image,
    each 0 is a closed door and each 1 is an opened door):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – All the doors are closed (initial state)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – All the doors are closed (initial state)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what we can observe and conclude at each of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the first pass, we open every door (we visit each door, #1, #2, #3, #4,
    ..., #100):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – All the doors are opened (step 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – All the doors are opened (step 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the second pass, we only visit the even doors (#2, #4, #6, #8, #10, #12
    …), so the even doors are closed and the odd ones are opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The even doors are closed and the odd ones are opened (step
    2)](img/Figure_15.4_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – The even doors are closed and the odd ones are opened (step 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the third pass, we only visit doors #3, #6, #9, #12, …. This time, we close
    door #3, which we opened on our first visit, open door #6, which was closed on
    our second visit, and so on and forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – The result of applying the third visit (step 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – The result of applying the third visit (step 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the fourth visit, we only visit doors #4, #8, #12 …. If we continue like
    this, then at the 100th visit, we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The opened doors are all perfect squares (last visit)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – The opened doors are all perfect squares (last visit)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at the last visit (the 100th visit), the opened doors are all perfect squares,
    while the rest of the doors are closed. Obviously, even if we observe this, we
    don''t have the necessary time in an interview to traverse 100 visits. But maybe
    we don''t even need to do all 100 visits to observe this result. Let''s assume
    that we do only 15 steps and we try to see what''s happening to a certain door.
    For example, the following image reveals the state of door #12 over 15 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Door #12 after 15 steps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.7_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.7 – Door #12 after 15 steps'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the steps highlighted in the preceding image. The state of door #12
    has changed at *steps 1, 2, 3, 4, 6*, and *12*. All these steps are divisors of
    12\. Moreover, *step 1* opens the door, *step 2* closes the door, *step 3* opens
    the door, *step 4* closes the door, *step 6* opens the door, and *step 12* closes
    the door. Starting from this observation, we can conclude that for every pair
    of divisors, the door will just end up back in its initial state, which is closed.
    In other words, each door that has an even number of divisors remains closed in
    the end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether this is true for a perfect square, such as 9\. The reason
    for choosing a perfect square relies on the fact that a perfect square always
    has an odd number of positive divisors. For example, the divisors of 9 are 1,
    3, and 9\. This means that door #9 remains open.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these two paragraphs, we can conclude that, after 100 visits, the
    doors that remain opened are those that are perfect squares (#1, #4, #9, #16,
    ..., #100), while the rest of the doors remain closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand the preceding process, it is quite straightforward to write
    an application that confirms the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *VisitToggle100Doors*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – 8 teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider there''s a contest where there''s 8 teams. Each team
    plays twice with other teams. From all these teams, only 4 go to the semi-finals.
    How many matches should a team win to go through to the semi-finals?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s denote the teams as T1, T2, T3, T4, T5, T6, T7, and T8\.
    If T1 plays with T2...T8, they will play 7 matches. Since each team must play
    with the other teams twice, we have 8*7=56 matches. If, at each match, a team
    can win a point, then we have 56 points that are distributed between 8 teams.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the worst-case scenario. T0 loses all their games. This means
    that T0 gets 0 points. On the other hand, T1 wins 2 points against T0 and loses
    all their other matches, T2 wins 4 points against T0 and T1 and loses all their
    other matches, T3 wins 6 points against T0, T1, and T2 and loses all their other
    matches, and so on. T4 wins 8 points, T5 wins 10 points, T6 wins 12 points, and
    T7 wins 14 points. So, a team that wins all their matches wins 14 points. The
    last four teams (those that go through to the semi-finals) have won 8+10+12+14=44
    points. So, a team can be sure that they go through to the semi-finals if they
    obtain a minimum of 44/4=11 points.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Finding the kth number with the prime factors 3, 5, and
    7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Design an algorithm to find the kth number where the only prime
    factors are 3, 5, and 7.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Having a list of numbers whose only prime factors are 3, 5, and
    7 means a list that looks as follows: 1, 3, 5, 7, 9, 15, 21, 25, and so on. Or,
    to be more suggestive, it can be written as follows: 1, 1*3, 1*5, 1*7, 3*3, 3*5,
    3*7, 5*5, 3*3*3, 5*7, 3*3*5, 7*7, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this suggestive representation, we can see that we can initially insert
    the value 1 into a list, while the rest of the elements must be computed. The
    simplest way to understand the algorithm for determining the rest of the elements
    is to look at the implementation itself, so let''s see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide an implementation via three queues as well. The steps of this
    algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an integer, *minElem*=1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize three queues; that is, *queue3*, *queue5*, and *queue7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop from 1 to the given *k*-1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Insert *minElem**3, *minElem**5, and *minElem**7 into *queue3*, *queue5*,
    and *queue7*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: b. Update *minElem* as min(*queue3*.peek, *queue5*.peek, *queue7*.peek).
  prefs: []
  type: TYPE_NORMAL
- en: c. If *minElem* is *queue3*.peek, then do *queue3*.poll.
  prefs: []
  type: TYPE_NORMAL
- en: d. If *minElem* is *queue5*.peek, then do *queue5*.poll.
  prefs: []
  type: TYPE_NORMAL
- en: e. If *minElem* is *queue7*.peek, then do *queue7*.poll.
  prefs: []
  type: TYPE_NORMAL
- en: Return *minElem*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete application is called *KthNumber357*. It contains both solutions
    presented in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Count decoding a digit's sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider that *A* is 1, *B* is 2, *C* is 3, ... *Z* is 26\. For
    any given sequence of digits, write a snippet of code that counts the number of
    possible decodings (for example, 1234 can be decoded as 1 2 3 4, 12 3 4, and 1
    23 4, which means as ABCD, LCD, and AWD). The given sequence of digits is valid
    if it contains digits from 0 to 9\. No leading 0s, no extra trailing 0s, and no
    two or more consecutive 0s are allowed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem can be solved via recursion or via dynamic programming.
    Both techniques were covered in [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*. So, let''s look at the recursive algorithm
    for a sequence of *n* digits:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the total number of decodings with 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start from the end of the given sequence of digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the last digit is not 0, then apply recursion for the (*n*-1) digits and
    use the result to update the total number of decodings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the last two digits represent a number less than 27 (therefore, a valid character),
    then apply recursion to the (*n*-2) digits and use the result to update the total
    number of decodings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code runs in an exponential time. But we can apply dynamic programming
    to reduce the runtime to O(n) via a similar non-recursive algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n) time. The complete application is called *DecodingDigitSequence*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – ABCD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Find a number of types, ABCD, such that when multiplied by 4,
    it gives us DCBA.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: These kinds of problems are usually quite hard. In this case,
    we have to use some math to solve it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some simple inequalities:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 <= A <= 9 (A cannot be zero because ABCD is a four-digit number)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 <= B <= 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 <= C <= 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 <= D <= 9 (D must be at least 4*A, so it should be at least 4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we can assume that our number, ABCD, is written as 1000A + 100B + 10C
    + D. Following the problem statement, we can multiply ABCD by 4 to obtain DCBA,
    which can be written as 1000D + 100C + 10B + A.
  prefs: []
  type: TYPE_NORMAL
- en: Conforming to divisibility by 4, BA is a two-digit number divisible by 4\. Now,
    the larger ABCD is 2499, because a number greater than 2499 multiplied by 4 will
    result in a five-digit number.
  prefs: []
  type: TYPE_NORMAL
- en: Next, A can be 1 and 2\. However, if BA is a two-digit number divisible by 4,
    then A must be even, so it must be 2.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with this logic, this means that D is either 8 or 9\. However, since
    D times 4 would end in 2, D must be 8.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, 4000A + 400B + 40C + 4D = 1000D + 100C + 10B + A. Since A=2 and D=8,
    this can be written as 2C-13B=1\. B and C can only be a single digit integer in
    [1, 7], but B must be odd since BA is a two-digit number divisible by 4\. Since
    the greatest possible number is 2499, this means that B can be 1 or 3.
  prefs: []
  type: TYPE_NORMAL
- en: So, the result is 2178 because 2178*4=8712, so ABCD*4=DCBA.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the brute-force approach to find this number as well. The following
    code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *Abcd*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Rectangles overlapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if these rectangles overlap (also referred to as colliding or intersecting).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: This problem sounds a little bit vague. It is important to discuss
    this with the interviewer and agree about two important aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The two rectangles are parallel to each other and form an angle of 0 degrees
    with the horizontal plane (they are parallel to the coordinate axes) or can they
    be rotated under an angle?*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the given rectangles are parallel to each other and to the
    coordinate axes. If rotation is involved, then the solution requires some geometry
    knowledge that is not so obvious during an interview. Most probably, the interviewer
    wants to test your logic, not your knowledge of geometry, but challenge yourself
    and implement the problem for non-parallel rectangles as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Are the coordinates of the rectangles given in the Cartesian plane?* The answer
    should be affirmative since this is a common coordinates system used in mathematics.
    This means that a rectangle increases its size from left to right and from bottom
    to top.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s denote the rectangles as *r1* and *r2*. Each of them is given via
    the coordinates of the top-left corner and bottom-right corner. The top-left corner
    of *r1* has the coordinates *r1lt.x* and *r1lt.y*, while the bottom-right corner
    has the coordinates *r2rb.x* and *r2rb.y*, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Rectangle coordinates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – Rectangle coordinates
  prefs: []
  type: TYPE_NORMAL
- en: 'We might say that two rectangles are overlapping if they *touch* each other
    (they at least have a common point). In other words, the five pairs of rectangles
    shown in the following diagram overlap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Overlapping rectangles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.9_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – Overlapping rectangles
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can conclude that two rectangles that don''t
    overlap can be in one of the following four cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*r1* is totally to the right of *r2.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally to the left of *r2.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally above *r2.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally below *r2.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram reveals these four cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Non-overlapping rectangles'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 – Non-overlapping rectangles
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express the preceding four bullets in terms of coordinates, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*r1* is totally to the right of *r2* →*r1lt.x>r2rb.x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally to the left of *r2* →*r2lt.x>r1rb.x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally above *r2* →*r1rb.y>r2lt.y*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*r1* is totally below *r2* →*r2rb.y>r1lt.y*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we group these conditions into code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code runs in O(1) time. Alternatively, we can condense these two conditions
    into a single one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The complete applications is called *RectangleOverlap*. Note that the interviewer
    may define *overlapping* in different ways. Based on this problem, you should
    be able to adapt the code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Multiplying large numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` or `long` domains. Write a snippet of code that computes *a*b*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that *a*=4145775 and *b*=771467\. Then, *a*b*=3198328601925\.
    Solving this problem relies on mathematics. The following image depicts the *a*b*
    solution that can be applied on paper and coded as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Multiplying two large numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 – Multiplying two large numbers
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, we rely on the fact that multiplication can be written as a suite of
    additions. So, we can write 771467 as 7+60+400+1000+70000+700000 and we multiply
    each of these numbers by 4145775\. Finally, we add the results to obtain the final
    result, 3198328601925\. Taking this logic one step further, we can take the last
    digit of the first number (5) and multiply it by all the digits of the second
    number (7, 6, 4, 1, 7, 7). Then, we take the second digit of the first number
    (7) and multiply it by all the digits of the second number (7, 6, 4, 1, 7, 7).
    Then, we take the third digit of the first number (7) and multiply it by all the
    digits of the second number (7, 6, 4, 1, 7, 7). We continue this process until
    we've multiplied all the digits of the first number by all the digits of the second
    number. While adding the results, we state that the *t*th multiplication shifted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MultiplyLargeNumbers*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Next greatest number with the same digits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a positive integer. Write a snippet
    of code that returns the next greatest number with the same digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The solution to this problem can be observed via several examples.
    Let''s consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: 6 → Not possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 2: 1234 → 1243'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 3: 1232 → 1322'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 4: 321 → Not possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 5: 621873 → 623178'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the preceding examples we can intuit that the solution can be obtained
    by rearranging the digits of the given number. So, if we can find the set of rules
    for swapping the digits that leads us to the searched number, then we can attempt
    an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try several observations:'
  prefs: []
  type: TYPE_NORMAL
- en: From examples 1 and 4, we can see that if the digits of the given number are
    in descending order, then it is impossible to find a greater number. Every swap
    will lead to a smaller number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From example 2, we can see that if the digits of the given number are in ascending
    order, then the next greater number that has the same digits can be obtained by
    swapping the last two digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From examples 3 and 5, we can see that we need to find the smallest of all the
    greater numbers. For this, we have to process the number from the right-most side.
    The following algorithm clarifies this statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these three observations, we can elaborate the following algorithm,
    which has been exemplified on the number 621873:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by traversing the number digit by digit from the right-most side. We
    keep traversing until we find a digit that is smaller than the previously traversed
    digit. For example, if the given number is 621873, then we traverse the number
    until digit 1 in 621873\. Digit 1 is the first digit that's smaller than the previously
    traversed digit, 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we focus on the digits from the right-hand side of the digit that we found
    at step 1\. We want to find the smallest digit among these digits (let's denote
    it as *t*). Since these digits are sorted in descending order, the smallest digit
    is at the last position. For example, 3 is the smallest digit among the digits
    from the right-hand side of 1, 62**1**87**3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We swap these two digits (1 with 3) and we obtain 62**3**87**1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we sort all the digits to the right-hand side of *t* in ascending order.
    But since we know that all the digits from the right-hand side of *t* are sorted
    in descending order, except for the last digit, we can apply a linear reverse.
    This means that the result is 623**178**. This is the searched number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This algorithm can be easily implemented, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n) time. The complete application is called *NextElementSameDigits*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – A number divisible by its digits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the given number is divisible by its digits.'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` since 412 is divisible by 2, 1, and 4\. On the other hand, if *n*=143,
    then the output should be `false` since 143 is not divisible by 3 and 4.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think that this problem is simple, then you're absolutely right. These
    kinds of problems are used as *warm-up* problems and are useful to quickly filter
    a lot of candidates. Most of the time, you should solve it in a given time (for
    example, 2-3 minutes).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to treat these simple problems with the same degree of seriousness
    as any other problem. A little mistake can prematurely eliminate you from the
    race.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for this problem, the algorithm is comprised of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch all the digits of the given number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each digit, check whether the *given number* *% digit* is 0 (this means
    divisible).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of them are non-zero, return `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, for all the digits the *given number % digit* is 0, return `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *NumberDivisibleDigits*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Breaking chocolate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been a given rectangular bar of chocolate of
    size *width* x *height* and a number of tiles. As usual, the chocolate consists
    of a number of little tiles, so the *width* and *height* give us the number of
    tiles (for example, the chocolate is 4 x 3 in size and contains 12 tiles). Write
    a snippet of code that computes the number of breaks (cuts) we need to apply to
    the given chocolate to obtain a piece that has exactly the required number of
    tiles. You can break (cut) the given chocolate into two rectangular pieces via
    a single vertical or horizontal break (cut) along the tile edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the chocolate shown in the following image (a
    3 x 6 bar of chocolate that has 18 tiles):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – A 3 x 6 chocolate bar](img/Figure_15.12_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – A 3 x 6 chocolate bar
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding image reveals seven cases that can lead us to the solution, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cases 1, 2, and 3: If the number of given tiles is greater than 3 x 6 or we
    cannot arrange the tiles along with the chocolate''s *width* or *height*, then
    it is not possible to attain a solution. For no solution, we return -1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 4: If the number of given tiles is equal to 3 x 6 = 18, then this is the
    solution, so we have 0 cuts. We''ll return 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 5: If the number of given tiles can be arranged along with the chocolate
    bar''s *width*, then there is a single cut. We''ll return 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 6: If the number of given tiles can be arranged along with the chocolate
    bar''s *height*, then there is a single cut. We''ll return 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 7: In all other cases, we need 2 cuts. We''ll return 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BreakChocolate*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Clock angle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given the time in *h:m* format. Write a
    snippet of code that calculates the shorter angle between the hour and the minute
    hand on an analog clock.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Right from the start, we have to take into account several formulas
    that will help us come up with a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, a clock is divided into 12 equal hours (or 12 equals parts) and
    since it is a complete circle, it has 360o. So, 1 hour has 360o/12 = 30o. So,
    at 1:00, the hour hand forms an angle of 300 with the minute hand. At 2:00, the
    hour hand forms an angle of 60o with the minute hand, and so on and so forth.
    The following image clarifies this aspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – 360 degree split at 12 hours'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.13 – 360 degree split at 12 hours
  prefs: []
  type: TYPE_NORMAL
- en: Taking this logic further, an hour has 60 minutes and 30o, so a minute has 30/60
    = 0.5o. So, if we refer only to the hour hand, then at 1:10, we have an angle
    of 30o + 10*0.5o = 30o + 5o = 35o. Or, at 4:17, we have an angle of 4*30o + 17*0.5o
    = 120o + 8.5o = 128.5o.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we know that we can compute the angle of the hour hand for a given *h:m*
    time as *h**300 + *m**0.5o. For computing the angle of the minute hand, we can
    think that, in 1 hour, the minute hand takes a complete 360o tour, so 360o/ 60
    minutes = 6o for each minute. So, at *h*:24, the minute hand forms an angle of
    24 * 6o = 144o. At *h*:35, the minute hand forms an angle of 35 * 6o = 210o, and
    so on and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: So, the angle between the hour and the minute hand is the abs((*h**30o + *m**0.5o)
    - *m**6o). If the returned *result* is greater than 180o, then we have to return
    (360o - *result*) since the problem requires us to calculate the shorter angle
    between the hour and the minute hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to calculate the required angle for the clocks shown in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Three clocks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.14_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.14 – Three clocks
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock 1, 10:10**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hour hand: 10*30o + 10*0.5o = 300o + 5o = 305o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minute hand: 10 * 6o = 60o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: abs(305o - 60o) = abs(245o) = 245o > 180o, so return 360o - 245o =
    115o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock 2, 9:40**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hour hand: 9*30o + 40*0.5o = 270o + 20o = 290o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minute hand: 40 * 6o = 240o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: abs(290o - 240o) = abs(50o) = 50o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clock 3, 4:40**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hour hand: 4*30o + 40*0.5o = 120o + 20o = 140o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minute hand: 40 * 6o = 240o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Result: abs(140o - 240o) = abs(-100o) = 100o'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these statements, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *HourMinuteAngle*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Pythagorean triplets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: A Pythagorean triplet is a set of three positive integers {*a,
    b, c*} such that *a*2 = *b*2 + *c*2\. Consider you''ve been given an array of
    positive integers, *arr*. Write a snippet of code that prints all the Pythagorean
    triplets of this array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The brute-force approach can be implemented via three loops that
    can try all the possible triples in the given array. But this will work in O(n3)
    complexity time. Obviously, the brute-force approach (commonly known as the *naive*
    approach) will not impress the interviewer, so we must do better than this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, in fact, solve the problem in O(n2) time. Let''s see the algorithm''s
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Square every element in the input array (O(n)). This means that we can write
    *a*2 = *b*2 + *c*2 as *a* = *b* + *c*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the given array in ascending order (O(n log n)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *a* = *b* + *c*, then *a* is always the largest value between *a*, *b*, and
    *c*. So, we fix *a* so that it becomes the last element of this sorted array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix *b* so that it becomes the first element of this sorted array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix *c* so that it becomes the element right before element *a*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So far, *b<a* and *c<a*. To find the Pythagorean triplets, execute a loop that
    increases *b* from 1 to *n* and decreases *c* from *n* to 1\. The loop stops when
    *b* and *c* meet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Increase the index of *b* if *b + c < a*.
  prefs: []
  type: TYPE_NORMAL
- en: b. Decrease the index of *c* if *b + c > a*.
  prefs: []
  type: TYPE_NORMAL
- en: c. If *b + c* is equal to *a*, then print the found triplet. Increment the index
    of *b* and decrement the index of *c*.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat from *step 3* for the next *a*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s consider that *arr*={3, 6, 8, 5, 10, 4, 12, 14}. After the first two
    steps, *arr*={9, 16, 25, 36, 64, 100, 144, 196}. After *steps 3*, *4*, and *5*,
    we have *a*=196, *b*=9, and *c*=144, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Setting a, b, and c'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.15_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.15 – Setting a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: Since 9+144 < 196, the index of *b* is increased by 1, conforming to *step 6a*.
    The same step applies for 16+144, 25+144, and 36+144\. Since 64+144 > 196, the
    index of *c* is decreased by 1, conforming to *step 6b*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since 64 +100 < 196, the index of *b* is increased by 1, conforming to *step
    6a*. The loop stops here since *b* and *c* have met, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – b and c at the end of the loop](img/Figure_15.16_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – b and c at the end of the loop
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, conforming to *step 7*, we set *a*=144, *b*=9, and *c*=100\. This process
    is repeated for each *a*. When *a* becomes 100, we find the first Pythagorean
    triplet; that is, *a*=100, *b*=36, and *c*=64, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – A Pythagorean triplet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.17 – A Pythagorean triplet
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this algorithm into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *PythagoreanTriplets*.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Scheduling one elevator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array representing the destination
    floors of *n* people. The elevator has a capacity of the given *k*. Initially,
    the elevator and all the people are on floor 0 (ground floor). It takes 1 unit
    of time for the elevator to reach any consecutive floor (up or down) from the
    current floor. Write a snippet of code that will schedule the elevator in such
    a way that we obtain the minimum total time needed to get all the people to their
    destination floors and then return to the ground floor.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that the given array of destinations is *floors*
    = {4, 2, 1, 2, 4} and *k*=3\. So, we have five people: one person for the first
    floor, two people for the second floor, and two people for the fourth floor. The
    elevator can take three people at a time. So, how can we schedule the elevator
    to take these five people to their floors in the shortest amount of time?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution consists of getting the people to their respective floors in descending
    order. Let''s tackle this scenario based on the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18 – Scheduling an elevator example](img/Figure_15.18_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.18 – Scheduling an elevator example
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s traverse the steps of this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the initial state. The elevator is on the ground floor and five people
    are ready to take it. Let's consider that the minimum time is 0 (so, 0 units of
    time).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the elevator, we take the people who are going to the 4th floor and the one
    person who is going to the 2nd floor. Remember that we can take a maximum of three
    people at a time. So far, the minimum time is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elevator goes up and stops at the 2nd floor. One person gets off. Since
    each floor represents a unit of time, we have a minimum time of 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elevator goes up and stops at the 4th floor. The remaining two people get
    off. The minimum time becomes equal to 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this step, the elevator is empty. It must go down to the ground floor to
    pick up more people. Since it goes down four floors, the minimum time becomes
    8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pick up the remaining two people. The minimum time remains as 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elevator goes up and stops at the 1st floor. One person gets off. The minimum
    time becomes 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The elevator goes up and stops at the 2nd floor. One person gets off. The minimum
    time becomes 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this step, the elevator is empty. It must go down to the ground floor. Since
    it goes down two floors, the minimum time becomes 12.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, the total minimum time is 12\. Based on this scenario, we can elaborate
    the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the given array in descending order of destinations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create groups of *k* persons. The time needed for each group will be 2 * *floors*[*group*].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, sorting our testing data will result in *floors* = {4, 4, 2, 2, 1}. We have
    two groups. One group contains three people (4, 4, 2), while the other group contains
    two people (2, 1). The total minimum time is (2 * *floors*[0]) + (2 * *floors*[3])
    = (2 * 4) + (2 * 2) = 8 + 4 = 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you may end up choosing a better sorting algorithm. The complete
    application is called *ScheduleOneElevator*. This was the last coding challenge
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling multiple elevators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But how do we schedule multiple elevators with an arbitrary number of floors?
    Well, most probably, in an interview, you won't need to implement a solution for
    more than one elevator, but you could be asked how you'd design a solution for
    more.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of scheduling multiple elevators and the algorithm are famous and
    difficult. There is no best algorithm for this problem. In other words, creating
    an algorithm that can be applied to the real-world scheduling of elevators is
    really difficult, and apparently, it is patented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Elevator algorithm (https://en.wikipedia.org/wiki/Elevator_algorithm) is
    a good place to start. Before thinking about how to design a solution for multi-elevators,
    you must make a list of all the assumptions or constraints that you want to consider.
    Every available solution/algorithm has a list of assumptions or constraints referring
    to the number of floors, number of elevators, capacity of each elevator, number
    of average people, rush hour times, elevator speed, load and unload times, and
    so on. Mainly, there are three solutions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sectors**: Each elevator is allocated to a sector (it services a subset of
    floors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nearest elevator**: Each person is assigned to the nearest elevator (it does
    this based on the elevator''s position, the direction of call, and the current
    direction of the elevator).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nearest elevator with capacity considerations**: This is similar to the nearest
    elevator option, but it takes the load in each elevator into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sectors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For example, a building that has eight floors and three elevators can be serviced
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Elevator 1 serves floors 1, 2, and 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator 2 serves floors 1, 4, and 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevator 3 serves floors 1, 6, 7, and 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each elevator services the ground floor since the ground floor has the highest
    arrival rate.
  prefs: []
  type: TYPE_NORMAL
- en: Nearest elevator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Allocate a score to each elevator. This score represents the suitability score
    for an elevator when a new person arrives:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Toward the call, same direction*: *FS* = (*N +* 2) - *d*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Toward the call, opposite direction*: *FS* = (*N*+1) - *d*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Away from the call*: *FS* = 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Where, *N* = #Floors – 1, and *d* = distance between elevator and call.'
  prefs: []
  type: TYPE_NORMAL
- en: Nearest elevator with capacity considerations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is exactly the same as the nearest elevator situation, but it takes into
    account the excess capacity of the elevator:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Toward the call, same direction*: *FS* = (*N* + 2) - *d* + *C*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Toward the call, opposite direction*: *FS* = (*N* + 1) - *d* + *C*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Away from the call*: *FS* = 1 + *C*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, *N* is #Floors – 1, *d* is the distance between the elevator and the
    call, and *C* is the excess capacity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I strongly recommend that you search and study different implementations for
    this problem and try to learn the one that you find the most suitable for you.
    I suggest that you start from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/topics/elevator-simulation](https://github.com/topics/elevator-simulation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://austingwalters.com/everyday-algorithms-elevator-allocation/](https://austingwalters.com/everyday-algorithms-elevator-allocation/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's summarize this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the most popular problems that fit into the mathematics
    and puzzles categories. While many companies avoid such problems, there are still
    major players such as Google and Amazon that rely on these kinds of problems in
    their interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing such problems represents a good exercise for our brains. Besides
    the math knowledge, these problems sustain analytical thinking based on deductions
    and intuition, which means they are great support for any programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll tackle a hot topic in interviews: concurrency (multithreading).'
  prefs: []
  type: TYPE_NORMAL
