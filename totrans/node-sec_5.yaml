- en: Chapter 5. Response Layer Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last interaction you will have with a user request is, of course, the response.
    The discussion here will focus on vulnerabilities and best practices for this
    portion of your application code. This will include **Cross-site Scripting** (**XSS**),
    some vectors for **Denial of Service** (**DoS**) attacks, and even HTTP headers
    that various browsers use for implementing specific security policies.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site Scripting (XSS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-site Scripting (XSS) is one of the more popular topics while dealing with
    web applications, as it is the default behavior of HTML/CSS/JavaScript in many
    respects. Specifically, XSS is an attack vector that is used to inject untrusted
    and likely malicious code into a web page. Usually, this is taken as an opportunity
    to inject JavaScript code into your page that now has access to just about anything
    the client has access to in that particular web page.
  prefs: []
  type: TYPE_NORMAL
- en: By default, JavaScript is executed in a global scope in the browser, including
    code that was injected by an untrusted source. This is the same behavior that
    your own, trusted code has, making it a dangerous vector with many possibilities.
    The malicious script could find the user's session ID (usually in a cookie), and
    use AJAX to send that information to someone that can then hijack the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The injection commonly comes from the user input that is not filtered or sanitized
    before being output to the browser. Consider the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This script creates a server that simply sends an HTML form that is submitted
    (via `GET`) to another page. The second route simply outputs the user's input
    value to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: If the user inputs their name (like Dominic) everything is well, and the user
    sees **"Hello, Dominic"** on the next page. However, what if the user enters something
    else, like raw HTML? In this case, it just outputs the HTML alongside our own
    HTML, and the browser can't tell the difference.
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `<script>alert('hello!');</script>` in that text field instead,
    when you open the next page, you'll see **"Hello,"** and the browser will trigger
    an alert with **"hello!"** in the box. This is a harmless example, but this vulnerability
    has a huge potential for damage. These attacks are accomplished through what is
    known as untrusted data, which could be raw user input, information stored in
    a database, or accessed via a remote data source. The untrusted data is then used
    by your application to construct some sort of command that is then executed. The
    danger comes when the command is manipulated to perform some action that was not
    the original intent of the developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototypical example of this type of attack is a SQL injection, which is
    where the untrusted data is used to alter a SQL command. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume that the username variable comes from the user input, and the point
    is that it is an untrusted data as we have defined it. If the user enters something
    innocuous, like `''Dominic''`, then all is well, and the generated SQL looks like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What if someone enters something less harmless, like: `'''' OR 1=1`, then the
    generated SQL becomes like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the meaning of the query entirely, rather than restricting to
    one user with a matching name, now every row is returned. This could be even more
    disastrous, consider the value: `''''; DROP TABLE users;`, it would generate a
    SQL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Without any additional access, the user has caused a devastating loss of data
    to our application, probably bringing the entire application down for all users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, XSS is another type of injection attack, and the web browser
    and the HTML, CSS, and JavaScript that they execute, are optimized for these types
    of attacks. There are many different contexts within each of these languages that
    we need to be aware of. Consider the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With our untrusted data, we could easily cause trouble by injecting additional
    HTML into this value, such as `<script>alert(''xss'');</script>`, which would
    generate the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution here is to use an HTML escaping on any untrusted data added to
    the page in this context. This technique turns characters that are important in
    HTML, such as angle brackets and quotes, into their corresponding HTML entity;
    preventing them from altering the structure of the HTML they are embedded within.
    The following table is an example of this conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Entity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Less than sign (`<`) | `&lt;` |'
  prefs: []
  type: TYPE_TB
- en: '| Greater than sign (`>`) | `&gt;` |'
  prefs: []
  type: TYPE_TB
- en: '| Double quote (`"`) | `&quot;` |'
  prefs: []
  type: TYPE_TB
- en: '| Single quote (`''`) | `''` `(&apos;` is not a valid HTML and should be avoided)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Ampersand (`&`) | `&amp;` |'
  prefs: []
  type: TYPE_TB
- en: '| Forward slash (`/`) | `/` |'
  prefs: []
  type: TYPE_TB
- en: This method of escaping makes it harder for an attacker to alter the structure
    of your HTML, making this a very important technique for securing your web pages.
    However, different contexts will require further escaping techniques that we will
    address shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many popular templating libraries include automatic HTML escaping by default,
    but some do not. This should be an important factor to you for choosing a template
    framework or library.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML attributes could be injected with other HTML meant to create a new context,
    such as closing the attribute and starting a new attribute. Further still, this
    injected HTML could be used to close the HTML tag, and inject more HTML in another
    context. Consider the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following injected value for height: `100 onload="javascript:alert(''XSS'');"`,
    which would generate the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The result is injected JavaScript code. HTML encoding as we used before is not
    enough in this particular context, as the preceding is still a perfectly valid
    HTML. In addition to HTML escaping as we mentioned before, you should require
    quotes around all HTML attributes, particularly when untrusted data is involved.
    To cover all cases, even unquoted attributes, you could encode all ASCII values
    below 256 to their HTML entity format or an available named entity like `&quot;`,
    if available).
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML attributes that involve URLs, such as `href` and `src`, are another context
    altogether that require their own encoding. Consider the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user enters the following data: `javascript:alert(''XSS'');`, then the
    following HTML is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An HTML encoding is not applicable here, as the preceding is a valid HTML markup.
    Instead, a fully-qualified URL should be checked for unexpected protocols. Here,
    we used `javascript:`, which gets the browser to execute arbitrary code, behaving
    like the `eval()` function. Lastly, the output should be escaped via the built-in
    JavaScript function called `encodeURI()`, which escapes characters that are invalid
    in URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last example I will show here is partial URLs within attributes like the
    ones mentioned previously. Using the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `nextPage` variable is being used as a part of a URL, rather than being
    the URL itself. The `encodeURI()` function we mentioned earlier has a companion
    called `encodeURIComponent()`, which escapes more characters, because it is meant
    to encode a single query-string parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common anti-pattern is injecting JSON data into a page directly to
    share data between the server and client while rendering a page. Consider the
    following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This particular technique, while convenient, can allow for XSS attacks as well.
    Let's assume the `serverData` object has a single property called `username` that
    reflects the current user's name. Let's also assume that this value is able to
    be set by the user without any sort of filtering between the user's input and
    the display on the page (which of course should not happen).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user changes his name to `</script><script>alert(''XSS'')</script>`
    then the output HTML would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: According to the HTML specification, a `</` character (even within a JavaScript
    string, as we have here) will be interpreted as a closed tag, and the attacker
    has just created a brand new script tag that, like any other script tag, has full
    control over the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than simply trying to escape the JSON data directly, the best way to
    mitigate this problem is to inject your JSON data, using another method altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method uses a script tag, with a predefined ID that we can use to retrieve
    it. When a browser encounters a script type it does not understand, it will simply
    not execute it, in addition to leaving it hidden from the user. The contents of
    this script tag will be an HTML-escaped version of our JSON, which ensures we
    have no context boundary crossing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use another script (preferably in an external file, but by no means
    required) with the code that finds the script element we defined, and retrieves
    its text content. By using the `textContent/innerText` property instead of `innerHTML`,
    we get additional escaping that the browser performs for us, just in case. Lastly,
    we run the JSON data through `JSON.parse` to actually perform the JSON decoding.
  prefs: []
  type: TYPE_NORMAL
- en: While this method requires more fanfare, and is going to be a bit slower than
    the first example, it is going to be far more secure, which is a great trade-off
    to make.
  prefs: []
  type: TYPE_NORMAL
- en: These examples are by no means an exhaustive list, but they should illustrate
    the point that HTML, CSS, and JavaScript each have contexts that allow for various
    types of code injection. Never trust your user input, and make sure you use the
    appropriate escaping method depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Web Application Security Project** (**OWASP**) is a foundation that
    maintains a wiki ([http://www.owasp.org/](http://www.owasp.org/)) that specifically
    addresses security considerations for all web applications. They have articles
    on many attack vectors, including a more comprehensive checklist for preventing
    many more varieties of XSS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Denial of Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Denial of Service** (**DoS**) attack can come in a variety of forms, but
    the main intent is to prevent users from having access to your application. One
    method is to flood your server with a large amount of requests, tying up your
    server's resources and preventing legitimate requests from being fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Request flooding typically targets multithreaded servers, like **Apache**. This
    is because the process of spawning a new thread for each request gives an easy-to-reach
    upper limit on the number of simultaneous requests. With Node.js platform's event
    loop, this particular type of attack is not usually as effective, although that's
    not to say that it is impossible.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop can still expose applications if used improperly, I cannot stress
    enough how important it is to understand how it works, while writing any Node.js
    application. The contract your application code has with the event loop is to
    always run as fast as possible. There is only one piece of your application running
    at once, so CPU-intensive can tie up resources as well. This applies in all cases,
    but I mention it in this chapter to specifically address your response handlers.
    Generally, receiving the request itself is less resource-intensive than performing
    the actions necessary to generate the appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, use streams whenever possible, especially while dealing
    with network requests or the filesystem. Dealing with large blobs of data can
    be time-consuming depending on how you are processing that data, the use of streams
    can break those large operations into many small chunks, allowing other requests
    to be satisfied in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Security-related HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some HTTP headers available that can help add some security to our
    web applications. We will be looking at a module called **helmet**, which is written
    as a collection of Connect/Express middleware that adds these headers depending
    on your configuration. We will examine each of the middleware functions that helmet
    includes, as well as a brief explanation of their effects.
  prefs: []
  type: TYPE_NORMAL
- en: Content security policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, helmet supports setting headers for a newer security mechanism for HTML
    and web applications called **Content Security Policy** (**CSP**). XSS attacks
    circumvent the **Same-Origin Policy** (**SOP**) by using other methods to trick
    browsers into delivering harmful content.
  prefs: []
  type: TYPE_NORMAL
- en: For browsers that support this feature, you can restrict resources, such as
    images, frames, or fonts to be loaded via white-listed domains. This limits the
    impact of XSS attacks by hopefully preventing access to untrusted domains for
    loading malicious content.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSP is communicated to a browser via one or more `Content-Security-Policy`
    HTTP headers, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This header will instruct the browser to require that all scripts load from
    the current domain only. Any scripts the browser detects coming from any other
    domains will be blocked outright.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CSP header is constructed as a list of directives separated by semicolons.
    An example of a header that implements multiple CSP restrictions looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This header instructs the browser to restrict scripts to only the current domain
    (like our previous example), and forbids the use of frames (including iframes)
    and objects altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Each directive is named `*-src`, and it is followed by a space-separated list
    of either predefined keywords (which must be wrapped in quotes) or domain URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The available keywords include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''self''`: This restricts script to the current domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''none''`: This restricts all domains (none can be loaded at all)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''unsafe-inline''`: This allows inline code (you are highly advised to avoid
    this, more discussion later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''unsafe-eval''`: This allows text-to-JavaScript mechanisms like `eval()`
    (also highly advised against)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following directives are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect-src`: This restricts the domains that can be connected to via XHR
    and WebSockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-src`: This limits the domains that can be used to download font files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame-src`: This limits the domains that frames (including inline frames)
    can load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`img-src`: This limits the domains that images can be loaded from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media-sr`: This limits the origins for video and audio'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object-src`: This allows control over the origins for objects (for example,
    Flash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script-src`: This restricts the domains that scripts can be loaded from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style-src`: This limits the domains that stylesheets can be loaded from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-src`: This acts as a shorthand for all the directives combined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leaving out a directive leaves its policy wide open, (as is the default behavior)
    unless you specify the `default-src` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helmet can construct the headers for each supported User Agent (for example,
    browser) based on the configuration you pass to the middleware. By default, it
    will give the following CSP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a very strict policy, as it will only allow external resources to be
    loaded from the current domain, and nowhere else. In most cases, this is simply
    too restrictive, particularly if you are going to be using a CDN or allowing external
    services to communicate with your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure helmet via the middleware definition function, by adding
    a property called `defaultPolicy` that contains your directives as an object hash,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will instruct helmet to send the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will restrict scripts and images to the current domain as well as the domain
    [http://example.com/](http://example.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'CSP also includes a reporting capability that you can use for auditing your
    own applications and detect vulnerabilities quickly. There is a `report-uri` directive
    just for this purpose, which tells the browser what URI to send a violation report
    to. Refer the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the report is sent by the browser, it is a JSON document with the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This report includes most of the information you should need to track down
    the violation, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`document-uri`: The page that the violation occurred on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blocked-uri`: The violating resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`violated-directive`: The specific directive that was violated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`original-policy`: The page''s policy (the contents of the CSP header)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When first starting out with CSP, it may not be wise to set up a policy and
    start blocking right away. While you are in the process of detailing your application's
    policy, you can set up CSP to respect report-only mode.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to set up a complete policy, and rather than blocking users
    right away, you can simply receive reports detailing violations. This gives you
    a way to fine-tune your policy before putting it into effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable report-only mode, you simply change the HTTP header name. Instead
    of what we''ve been using, you simply use `Content-Security-Policy-Report-Only`,
    leaving everything else the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In helmet, you enable report-only mode by including the `reportOnly` parameter
    in your configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the same policy we used earlier, just with the addition of report-only
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: CSP is an excellent security mechanism that you should start using right away,
    despite browser support isn't entirely there. As of this writing, it is a **W3C
    Candidate Recommendation**, and browsers are expected to implement this feature
    at a rapid pace.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Strict Transport Security (HSTS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security** (**HSTS**) is a mechanism that communicates
    to a user agent (for example, a web browser) that a particular application should
    only be accessed via HTTPS, because it is an encrypted communication. If your
    application ideally exists only over a secure connection, this allows you to officially
    declare it to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two parameters to this header, the `max-age` directive that
    tells the browser how long (in seconds) to respect the configuration, as well
    as the `includeSubDomains` directive that treats subdomains of the current domain
    in the same fashion. Like CSP, this is communicated via an HTTP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the browser, for around six months, that the current domain from
    now on should be accessed via HTTPS (even if the user accessed it via HTTP). This
    is the default configuration set by helmet, which is the simplest to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets up the middleware for HSTS using the previously stated configuration,
    the middleware definition function also takes two optional parameters. First,
    the `max-age` directive can be set as a number (which should be represented in
    seconds). Second, the `includeSubDomains` directive can be set as a simple Boolean
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will set the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Browser support is not currently as complete as CSP, but is expected to proceed
    down that path. In the meantime, it is worth adding to your application's security
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: X-Frame-Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This header controls whether or not a particular page is allowed to be loaded
    into either a `<frame>` or an `<iframe>` element. This is useful mainly to prevent
    malicious users from hijacking (or "clickjacking") your users, and thereby tricking
    them into performing actions they otherwise had no intention of doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is communicated to the browser via another HTTP header, so when the browser
    loads a URL for a frame/iframe, it will check for this header to determine the
    course of action to take. The header looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the value `DENY`, which is the default when configured via
    helmet. Other available options include `sameorigin`, which only allows the domain
    to be loaded in a frame when on the current domain. The last option is the `allow-from`
    option that allows you to specify a whitelist of URIs that can render the current
    page in a frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, the default should work just fine, and you can set that up via
    helmet like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the header as we saw it previously displayed. To configure using
    the `sameorigin` option, use the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, this sets up the `allow-from` variant, which also gives you the second
    parameter for setting allowed URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Browser support for this security mechanism is quite good, so it's safe to implement
    right away. The `allow-from` header is a caveat, which is not supported evenly,
    so make sure you research the specifics depending on your requirements before
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: X-XSS-Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This next header is specific to Internet Explorer, and it enables the XSS filter.
    Rather than explain it myself, here is an explanation from the **Microsoft Developer
    Network** (**MSDN**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The XSS filter operates as an Internet Explorer 8 component with visibility
    into all requests/responses flowing through the browser. When the filter discovers
    likely XSS in a cross-site request, it identifies and neuters the attack if it
    is replayed in the server''s response. For further information please visit: [http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx](http://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This featured is likely enabled by default, but in case the user has disabled
    it themselves or in some select zones, it can be enabled with a simple header
    that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the header as 0, forces the XSS filter to be disabled, but that
    configuration is not exposed via helmet. In fact, it has no configuration at all,
    so its usage is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: X-Content-Type-Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another header that puts a stop to a specific behavior in certain browsers
    (Internet Explorer and Google Chrome are currently the only browsers that support
    this). In this case, the browser will attempt to "sniff" (for example, guess)
    the MIME type of a returned resource, even if that resource sets a valid `Content-Type`
    header on its own.
  prefs: []
  type: TYPE_NORMAL
- en: This could allow the browser to be fooled into executing or rendering a file
    in a way that was unintended by the developers, causing potential security vulnerabilities
    depending upon a number of factors. The point is that your server's `Content-Type`
    header should be the only consideration the browser makes, rather than trying
    to guess on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the previous example, there is no real configuration available, and the
    following header will simply be added to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This header is configured with helmet via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Cache-Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last middleware that helmet provides is one for setting the `Cache-Control`
    header to `no-store` or `no-cache`. This prevents browsers from caching a given
    response. This middleware also has no configuration, and is included via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You would use this middleware and header to prevent the browser from storing
    and caching pages that may contain sensitive user information. However, the trade-off
    is that you could take a serious performance hit when applying it across the board.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to static files and assets, such as style sheets and images, this
    header will only slow your site down, and likely adding no security benefits while
    doing so. Make sure to be careful how and where you apply this particular middleware
    within your overall application.
  prefs: []
  type: TYPE_NORMAL
- en: The helmet module is a quick way to add these useful security features to your
    application, which is enabled by the powerful middleware architecture that Connect
    has created. There's a lot to many of these security features that cannot be addressed
    here, and will likely change in the future, so it's best to become familiar with
    all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at vulnerabilities that show up in the response phase
    of application processing, such as XSS and DoS. We also looked at ways to mitigate
    those specific problems, whether by defensive coding or using newer security standards
    and policies to our advantage.
  prefs: []
  type: TYPE_NORMAL
