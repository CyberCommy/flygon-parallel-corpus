- en: Chapter 3. Security and Traceability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the era of open platforms, developers can build apps, which can be easily
    and quickly decoupled from the platform's business cycle. This API-based architecture
    enables agile development, easier adoption, prevalence, and scale and integration
    with applications within and outside the enterprise. One of the most important
    considerations for the apps is dealing with security. The developers building
    apps should not be concerned with the user's credentials. Additionally, there
    can be other clients consuming the REST services including but not limited to
    browsers and mobile applications to other services. The clients can be acting
    on behalf of other users and must be authorized to perform actions for them without
    the user having to share his credentials for a username and password. This is
    where the OAuth 2.0 specification comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect to consider when building distributed applications
    is traceability, which will involve logging the data related to requests for debugging
    purposes in an environment encompassing multiple micro services, which can be
    geographically distributed and deal with thousands of requests. Requests to the
    REST resources and status codes must be logged to help debug issues in production
    and can also serve as an audit trail. This chapter will cover advanced details
    in security and traceability in REST programming models. The topics covered are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling with RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Federated identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SAML 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will conclude with what it takes to work with the various building
    blocks for scalable, highly performing RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Logging REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex distributed applications can introduce many points of failure. Problems
    are hard to find and fix, thus delaying incident response and creating costly
    escalations. Application developers and administrators may not have direct access
    to the machine data they need.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is a very important aspect of building RESTful services, especially
    in the case of debugging production issues in distributed nodes running various
    micro services. It helps to link events or transactions between the various components
    that make an application or a business service. A complete sequence of logs can
    help replay the course of events that occurred in a production system. Additionally,
    logs can help index, aggregate, slice the data, analyze the patterns of requests
    coming in, and provide a lot of potentially helpful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code covers how to write a simple logging filter, which can be
    integrated with the REST resources. The filter will log request-related data such
    as timestamp, query string, and inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `LoggingFilter` class is a simple filter that implements a `javax.servlet.Filter`
    interface. The logger will log all messages with the request path and inputs.
    The sample uses Apache Log4j to set up logging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on Apache Log4J, check [http://logging.apache.org/log4j/2.x/](http://logging.apache.org/log4j/2.x/).
  prefs: []
  type: TYPE_NORMAL
- en: These logs can then be collected and mined from a distributed log server application,
    for example, Splunk ([http://www.splunk.com/](http://www.splunk.com/)), which
    can give the developer information and root causes analysis for outages or performance
    issues in production. An example in our coffee shop analogy could be that there
    was a problem processing a coffee order. If the request details were logged in
    a distributed log server application such as Splunk, the developer can query based
    on the time, and see what the client tried to send and why the request failed.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover numerous best practices to keep in mind when logging
    REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for the logging REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a large-scale distributed environment, the log data may be the only information
    that is available to the developer for debugging issues. Auditing and logging,
    if done right, can help tremendously in figuring such production issues and replaying
    the sequence of steps that occurred before an issue. The following sections list
    a few best practices for logging to understand system behavior and reasoning for
    performance and other issues.
  prefs: []
  type: TYPE_NORMAL
- en: Including a detailed consistent pattern across service logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is a good practice for a logging pattern to at least include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Date and current time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simple logger name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The detailed message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obfuscating sensitive data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to mask or obfuscate sensitive data in production logs
    to protect the risk of compromising confidential and critical customer information.
    Password obfuscators can be used in the logging filter, which will mask passwords,
    credit card numbers, and so on from the logs. **Personally identifiable information**
    (**PII** is information that can be used by itself or along with some other information
    to identify a person. Examples of PII can be a person's name, e-mail, credit card
    number, and so on. Data representing PII should be masked using various techniques
    such as substitution, shuffling, encryption, and other techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details, check [http://en.wikipedia.org/wiki/Data_masking](http://en.wikipedia.org/wiki/Data_masking).
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the caller or the initiator as part of the logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to identify the initiator of the call in the logs. The
    API may be called by a variety of clients, for example, mobile, the Web, or other
    services. Adding a way to identify the caller may help debug issues in case the
    problems are specific to a client.
  prefs: []
  type: TYPE_NORMAL
- en: Do not log payloads by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Have a configurable option to log payloads so that by default no payload is
    logged. This will ensure, for resources dealing with sensitive data, the payloads
    do not get logged in the default case.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying meta-information related to the request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every request should have some details on how long it took to execute the request,
    the status of the request, and the size of the request. This will help to identify
    latency issues as well as any other performance issues that may come up with large
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Tying the logging system with a monitoring system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ensure the data from the logs can also be tied to a monitoring system, which
    can collect data related to SLA metrics and other statistics in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Case studies of logging frameworks in distributed environments in various
    platforms**'
  prefs: []
  type: TYPE_NORMAL
- en: Facebook has developed a homegrown solution called Scribe, which is a server
    for aggregating streaming log data. This can handle the large number of requests
    per day across servers distributed globally. The servers send data, which can
    be processed, diagnosed, indexed, summarized, or aggregated. Scribe is designed
    to scale to a very large number of nodes. It is designed to be robust to survive
    network and node failures. There is a scribe server running on every node in the
    system. It is configured to aggregate messages and sends them to a central scribe
    server in larger groups. If the central scribe server goes down, messages are
    written to a file by the local scribe server on the local disk and sends them
    when the central server recovers. For more details, check [https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe).
  prefs: []
  type: TYPE_NORMAL
- en: Dapper is Google's tracing system, which samples data from the thousands of
    requests and provides sufficient information to trace data. Traces are collected
    in local logfiles and then pulled in Google's BigTable database. Google has found
    out that sampling sufficient information for common cases can help trace the details.
    For more details, check [http://research.google.com/pubs/pub36356.html](http://research.google.com/pubs/pub36356.html).
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover how to validate REST API requests and/or response
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: Validating RESTful services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When exposing REST- or HTTP-based service APIs, it is important to validate
    that the API behaves correctly and that the exposed data format is structured
    in an expected manner. For example, it is important to validate an input to a
    RESTful service, such as e-mails sent as part of the request body, must conform
    to the standards, certain values in the payload must be present, the zip code
    must follow a particular format, and so on. This can be done by validations with
    RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX-RS supports the Bean Validation to verify JAX-RS resource classes. This
    support consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraint annotations to resource method parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring entity data is valid when the entity is passed in as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a code snippet of a `CoffeesResource` class, which contains
    the `@Valid` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `javax.validation.executable.ValidateOnExecution` annotation can help specify
    which method or constructor should have their parameters and return values validated
    on execution. The `javax.validation.Valid` annotation on the request body will
    ensure the `Coffee` object will conform to the rules as specified in the POJO.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the snippet of the `Coffee` POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The field name has a `javax.validation.constrains.NotNull` annotation, which
    enforces that the name of the coffee in the order cannot be null. Similarly, we
    have defined custom annotations in the sample, which will verify the type and
    size and check if the values in the request body follow the right format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `Size` can be either of the following values as shown: `Small`,
    `Medium`, `Large`, or `ExtraLarge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `@VerifyValue(Size.class)` annotation is a custom annotation defined in
    the downloadable sample.
  prefs: []
  type: TYPE_NORMAL
- en: Validation exception handling and response codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following table provides a quick summary of the type of response codes when
    various validation-related exceptions are thrown. The type of error code depends
    on the exception thrown as well as whether the validation performed is on the
    request or the response of the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP Response code returned | Type of exception |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `500 Internal Server Error` | This error code is returned when `javax.validation.ValidationException`
    or any subclass of `ValidationException` including `ConstraintValidationException`
    is thrown while validating a method return type |'
  prefs: []
  type: TYPE_TB
- en: '| `400 Error` | When `ConstraintViolationException` is thrown in all other
    cases for validating method |'
  prefs: []
  type: TYPE_TB
- en: The next section covers how the API developers can throw application-specific
    exceptions and map HTTP error codes based on the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling with RESTful services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building RESTful APIs, it is necessary to throw application-specific exceptions
    and provide specific HTTP responses containing the details of these exceptions.
    The following section covers how to deal with user-defined exceptions and map
    them to HTTP responses and status codes. The `javax.ws.rs.ext.ExceptionMapper`
    classes are custom, application provided, components that catch thrown application
    exceptions and write specific HTTP responses. Exception mapper classes are annotated
    with the `@Provider` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippets show how to build your custom exception mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, the `getCoffees()` method returns a
    `Coffee` object with the ID specified in the path parameter. If no coffee is found
    with the ID specified, the code throws a `CoffeeNotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code of an `ExceptionMapper` class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows an implementation of `ExceptionMapper` whose `toResponse()`
    method has been overridden. The code checks if the exception thrown is an instance
    of `CoffeeNotFoundException`, then returns a response whose entity is of the type
    `ResourceError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ResourceError` class is a POJO annotated with `@XMLRootElement` and sent
    as part of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the sample as part of the downloadable bundle and the output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, organizations needed a way to unify the authentication for users
    in an enterprise. Single sign-on is a solution to keep one repository for usernames
    and passwords that can be used across the different applications in an enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: With the evolution of service-oriented architectures, organizations needed a
    way so that the partners and other services could use the APIs and there needed
    to be a way to simplify the sign-on process across the various applications and
    platforms. The need grew with the generation of social media with various platforms
    opening up, the APIs and an ecosystem built with a myriad of applications, and
    a multitude of devices using the platforms such as Twitter, Facebook, and LinkedIn.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it has become increasingly important to decouple the authentication and
    authorization functions from the consumer application. Also, it is not mandatory
    for every application to be aware of the user's credentials. The following section
    will cover SAML 2.0 and OAuth 2.0 for authorization as part of the federated identities
    effort to simplify sign-on and increase security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsections will enumerate over the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh tokens versus Access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jersey and OAuth 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use SAML or OAuth?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is authentication?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authentication is the process of establishing and communicating that the person
    operating a browser or native app is who he/she claims to be.
  prefs: []
  type: TYPE_NORMAL
- en: SAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Security Assertion Markup Language** (**SAML**) is a standard that encompasses
    profiles, bindings, and constructs to achieve **Single sign-on** (**SSO**), federation,
    and identity management.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SAML 2.0 spec provides a web browser SSO profile, which defines how single
    sign-on can be achieved for web applications. It defines three roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Principal**: This is where the user is typically looking to verify his or
    her identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity provider** (**IdP**): This is the entity that is capable of verifying
    the identity of the end user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service provider** (**SP**): This is the entity looking to use the identity
    provider to verify the identity of the end user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following flow shows a simple example of SAML. Say, an employee wants to
    access the corporate travel website. The corporate travel application will request
    the identity provider the employee is associated with to verify his identity and
    then take actions for him.
  prefs: []
  type: TYPE_NORMAL
- en: '![SAML](img/7963OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The flow is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user accesses a corporate application, say, travel application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The travel application will generate a SAML request and redirects the user to
    the employer's **identity provider** (**IdP**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the employer's identity provider to obtain a SAML
    authentication assertion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IdP parses the SAML request, authenticates the user, and generates a SAML
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser sends the SAML response to the travel application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On receiving the access token, the corporate travel app is then able to access
    the web resource by passing the token in the header of the HTTP request. The access
    token acts as a session token that encapsulates the fact that the travel app is
    acting on behalf of the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SAML has binding specifications for web browsers, SSO, SOAP, and WS-Security
    but no formal binding for the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers OAuth, which has been widely used by platforms such
    as Twitter, Facebook, and Google for authorization.
  prefs: []
  type: TYPE_NORMAL
- en: What is authorization?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authorization is the process of checking whether the requestor has permissions
    to perform the requested operation.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth stands for **open authorization** and provides a way for a user to authorize
    an application to access their account-related data without giving out their username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally in client/server authentication, the client uses its credentials
    to access resources on the server. The server does not care if the request comes
    from the client or if the client is requesting the resource for some other entity.
    The entity can be another application or another person and thus the client is
    not accessing its own resource but that of another user. Anyone requesting access
    to a resource that is protected and requires authentication must be authorized
    to do so by the resource owner. OAuth is a way to open up the REST APIs for companies
    such as Twitter, Facebook, Google+, GitHub, and so on, and the myriad of third-party
    applications built on top of them. OAuth 2.0 completely relies on SSL.
  prefs: []
  type: TYPE_NORMAL
- en: The number of legs in an OAuth request refers to the number of parties involved.
    A flow where there is client, server, and resource owner indicates 3-legged OAuth.
    When the client is acting on behalf of itself, it is known as 2-legged OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth achieves this functionality with the help of access tokens. Access tokens
    are like valet keys that give access to limited functionality for a limited period
    of time. Tokens have a limited lifespan from hours to a few days. The following
    diagram shows the flow of OAuth:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OAuth](img/7963OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the authorization code grant flow.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a user has his photos on a service provider site, say, Flickr.
    Now, the user needs to call a print service to print his photos, for example,
    Snapfish, which is a consumer application. Instead of the user sharing his username
    and password to the consumer application, the user can use OAuth to allow the
    print service to access his photos for a limited period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in our example, we have three roles as described:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User or resource owner**: The user is the resource owner who wants to print
    his photos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer application or client**: This is the print service application,
    which will act on behalf of the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service provider or server**: The service provider is the resource server
    that will store the user''s photos'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this example in mind, we can see the steps involved in the OAuth dance:'
  prefs: []
  type: TYPE_NORMAL
- en: User wants to allow an application to do a task on his behalf. In our example,
    the task is to print photos, which are on a server using a consumer application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The consumer application redirects the user to the service provider's authorization
    URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, the provider displays a web page asking the user if they can grant the
    application access to read and update their data.
  prefs: []
  type: TYPE_NORMAL
- en: The user agrees to grant the application access by the print service consumer
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The service provider redirects the user back to the application (via the redirect
    URI), passing an authorization code as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application exchanges the authorization code for an access grant. The service
    provider issues the access grant to the application. The grant includes an access
    token and a refresh token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the connection is established, the consumer application can now obtain
    a reference to the service API and invoke the provider on behalf of the user.
    Thus, the print service can now access the user's photos from the service provider's
    site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of OAuth is that a compromised application will not create much
    havoc as access tokens are used instead of actual credentials. The SAML bearer
    flow is actually very similar to the classic OAuth 3-leg flow covered earlier.
    However, instead of redirecting the user's browser to the authorization server,
    the service provider works with the identity provider to get a simple authentication
    assertion. The service provider application swaps a SAML bearer assertion for
    the user instead of exchanging an authorization code.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between OAuth 2.0 and OAuth 1.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth 2.0 specification clearly lays out how to use OAuth entirely inside a
    browser using JavaScript that has no way to securely store a token. This also
    explains at a high level how to use OAuth on a mobile phone or even on a device
    that has no web browser at all, covering interactions to *apps* and *native applications*
    on both smartphones and traditional computing devices, in addition to websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 defines the following three types of profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: Web application (In this case, the client password is stored on the server,
    and access tokens are used.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web browser client (In this case, the OAuth credentials are not trusted; some
    providers won't issue a client secret. An example is JavaScript in the browser.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native application (In this case, access tokens or refresh tokens that are generated
    can provide an acceptable level of protection. An example includes mobile applications.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth 2.0 does not require encryption and uses HTTPS not HMAC. Additionally,
    OAuth 2.0 allows limiting the lifetime of an access token.
  prefs: []
  type: TYPE_NORMAL
- en: An authorization grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An authorization grant is a credential representing the resource owner or the
    user''s authorization, which allows a client to access its protected resources
    to obtain an access token. The OAuth 2.0 specification defines four grant types
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The authorization code grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implicit grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource owner password credentials grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client credentials grant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, OAuth 2.0 also defines an extensibility mechanism for defining
    additional types.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh tokens versus access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refresh tokens are credentials used to obtain access tokens. Refresh tokens
    are used to obtain the access token when the current access token becomes invalid
    or expires. Issuing a refresh token is optional at the discretion of the server.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike access tokens, refresh tokens are intended for use only with authorization
    servers and are never sent to resource servers to access a resource.
  prefs: []
  type: TYPE_NORMAL
- en: Jersey and OAuth 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though OAuth 2.0 is widely used by various enterprises, OAuth 2.0 RFC is
    a framework to build solutions on top of it. There are numerous gray areas in
    the RFC where the specification leaves it to the implementer. There were indecisions
    in areas where there is no required token type, no agreement on the token expiration,
    or no specific guidance on the token size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read this page for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/)'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Jersey support for OAuth 2.0 is only on the client side. OAuth 2.0
    specification defines many extension points and it is up to service providers
    to implement these details. Additionally, OAuth 2.0 defines more than one authorization
    flow. The Authorization Code Grant Flow is the flow currently supported by Jersey
    and none of the other flows are supported. For more details, check [https://jersey.java.net/documentation/latest/security.html](https://jersey.java.net/documentation/latest/security.html).
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for OAuth in the REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following section lists some of the best practices that can be followed
    by service providers implementing OAuth 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the lifetime for an access token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The protocol parameter `expires_in` allows an authorization server to limit
    the lifetime of an access token and to pass this information to the client. This
    mechanism can be used to issue short-living tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Support providing refresh tokens in the authorization server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A refresh token can be sent along with a short lifetime access token to grant
    longer access to resources without involving user authorization. This offers an
    advantage where resource servers and authorization servers may not be the same
    entity. For example, in a distributed environment, the refresh token is always
    exchanged at the authorization server.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSL and encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OAuth 2.0 heavily relies on HTTPS. This will make the framework simpler but
    less secure.
  prefs: []
  type: TYPE_NORMAL
- en: The following table provides a quick summary of when to use SAML and when to
    use OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: '| Scenario | SAML | OAuth |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| If one of the parties is an enterprise | Use SAML |   |'
  prefs: []
  type: TYPE_TB
- en: '| If the application needs to provide temporary access to some resources |
      | Use OAuth |'
  prefs: []
  type: TYPE_TB
- en: '| If the application needs a custom identity provider | Use SAML |   |'
  prefs: []
  type: TYPE_TB
- en: '| If the application has mobile devices accessing it |   | Use OAuth |'
  prefs: []
  type: TYPE_TB
- en: '| If the application has no restrictions on the transport, for example, SOAP
    and JMS | Use SAML |   |'
  prefs: []
  type: TYPE_TB
- en: OpenID Connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is work going on at the OpenID foundation with OpenID Connect. OpenID
    Connect is a simple REST- and JSON-based interoperable protocol built on top of
    OAuth 2.0\. It is simpler than SAML, easy to maintain, and covers the various
    security levels from social networks to business applications to highly secure
    government applications. OpenID Connect and OAuth are the future for authentication
    and authorization. For more details, check [http://openid.net/connect/](http://openid.net/connect/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Case studies of companies using OAuth 2.0 and OpenID Connect**'
  prefs: []
  type: TYPE_NORMAL
- en: Google+ Sign-In is built on the OAuth 2.0 and OpenID Connect protocols. It supports
    over-the-air installs, social features, and a sign-in widget on top of standardized
    OpenID Connect sign-in flows.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will summarize some of the various components that we have
    covered so far when building RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: REST architecture components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following section will cover the various components that must be considered
    when building RESTful APIs. All of these will be covered in various sections of
    this book. We will also cover best practices for each pitfall to avoid when designing
    and developing the REST API. The REST architecture components are shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REST architecture components](img/7963OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen from the preceding diagram, REST services can be consumed from a variety
    of clients and applications running on different platforms and devices such as
    mobile devices and web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: These requests are sent through a proxy server. The REST architectural components
    in the diagram can be chained one after the other as shown in the preceding diagram.
    For example, there can be a filter chain, consisting of the **Auth**, **Rate limiting**,
    **Caching**, and **Logging** related filters. This will take care of authenticating
    the user, checking if the requests from the client are within rate limits, then
    a caching filter that can check if the request can be served from the cache respectively.
    This can be followed by a logging filter, which can log the details of the request.
  prefs: []
  type: TYPE_NORMAL
- en: On the response side, there can be **Pagination**, to ensure the server sends
    a subset of results. Also, the server can do **Asynchronous processing**, thus
    improving responsiveness and scale. There can be links in the response, which
    deals with HATEOAS.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the REST architectural components we have covered so far:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requests to use the REST API with HTTP verbs for the uniform interface
    constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation to select a representation for a response when there are
    multiple representations available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging to provide traceability to analyze and debug issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling to send application-specific exceptions with HTTP codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization with OAuth 2.0 to give access control to other
    applications and to take actions without the user having to send their credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation to send back detailed messages with error codes to the client as
    well as validations for the inputs received in the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few chapters will focus on advanced topics as well as best practices
    for the following blocks. We will provide code snippets to show how to implement
    these with JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Rate limiting to ensure the server is not burdened with too many requests from
    a single client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching to improve application responsiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous processing so that the server can asynchronously send back the
    responses to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro services that comprise breaking up a monolithic service into fine-grained
    services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HATEOAS to improve usability, understandability, and navigability by returning
    a list of links in the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination to allow clients to specify items in a dataset that they are interested
    in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also cover how major platforms such as Facebook, Google, GitHub, and
    PayPal have approached each of these solutions in their REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links can be useful to get additional information related to
    the topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/oauthplayground/](https://developers.google.com/oauthplayground/):
    Google OAuth playground to create and test signed requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/):
    OAuth 2.0 and road to hell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.google.com/accounts/docs/OAuth2Login](https://developers.google.com/accounts/docs/OAuth2Login):
    Google Accounts Authentication and Authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/facebookarchive/scribe](https://github.com/facebookarchive/scribe):
    Scribe log server for Facebook'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf](http://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/36356.pdf):
    Google Dapper large-scale distributed tracing architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started off with a brief introduction to logging RESTful APIs and
    the key principles were to recognize the importance of logging requests and best
    practices for logging including security compliance. We learned how to validate
    JAX-RS 2.0 resources using Bean Validation. In this chapter, we also saw how to
    write generic exception mappers for application-specific cases.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how federated identities are a necessity in the current era of interconnected
    hybrid systems, protocols, and devices. We covered SAML and OAuth 2.0 similarities
    between SAML and 3-legged OAuth as well as best practices for OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will walk through topics such as caching patterns and asynchronous
    REST API to improve performance and scalability, followed by a closer look at
    how to perform partial updates with HTTP Patch and the newer JSON Patch.
  prefs: []
  type: TYPE_NORMAL
