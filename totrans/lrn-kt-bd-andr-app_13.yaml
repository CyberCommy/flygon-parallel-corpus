- en: Testing and Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the concept of **Continuous Integration **(**CI**)
    and the importance of testing. Never heard of CI? Well, what about testing?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about writing tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the Android Testing Support Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use Crashlytics to track crash reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about beta testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be introduced to the concept of CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about tools such as Jenkins, Bamboo, and Fastlane and how to use them
    for build automation and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software testing is the process of evaluating software, or a piece of it, to
    ensure it works as expected. The product has to satisfy the given requirements
    for which it was built. Therefore, the report from a test gives an indication
    of the quality of the software. Another main reason for testing is to find bugs
    and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: At times, there is the temptation to treat testing as an afterthought. This
    is mostly as a result of issues such as time constraints, but considering the
    importance of testing, it should form a part of the development process. Writing
    tests much later in the life of the software can be a very terrible experience.
    You may have to commit huge amounts of time refactoring it to make it testable
    before you even get to write the tests. The frustration involved in all of these
    factors makes it difficult for most software to have proper tests.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a very broad topic, and you could easily write a book about it.
    The importance of testing cannot be emphasized enough. Here are some reasons why
    all software needs testing:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows the business to appreciate and understand the risks of software implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ensures that quality programs are written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps produce bug-free products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces maintenance costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a sure way of validating and verifying software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It improves performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It confirms that all the declared functional requirements have been implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It instils confidence in clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It exposes bugs quicker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's required to stay in business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ensures that the product can be installed and run in its intended environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Testing Support Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Android Testing Support Library** (**ATSL**) is a set of libraries purposely
    built for testing Android apps. It's just like the usual support libraries you
    use in Android app development, only this one is specifically for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Presenter architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the software needs to be testable. Only then can we write
    efficient tests for them. For this reason, you will architect your app using the **Model-View-Presenter **(**MVP**)
    architecture. This architecture employs some design best practices such as inversion
    of control and dependency injection, thus making it suitable for testing. For
    an app to be testable, it has to have its parts decoupled as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the high-level diagrammatic view of an MVP architecture in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4744851a-ccfd-4477-aec1-471e8558a85e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Very briefly, this is what the various parts mean:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Model: It provides and stores the app''s data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'View: It handles the display of the model''s data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Presenter: It coordinates the UI with the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could also easily swap out other parts and mock them during testing. In
    software testing, mocks are objects which mimic real objects. You will provide
    its behavior instead of relying on the actual implementation of the code. This
    way, you get to focus on the class under test, which is doing exactly as expected.
    You will see them in action in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be building a Notes app using a type of software development known
    as **Test-Driven Development **(**TDD**). Take a look at the following diagram,
    and the following explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14fc8340-e928-4d1b-874f-ddb4f70c3e3b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**TDD** is a software development method where tests are written before the
    actual program code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RED: Red is the first stage of the TDD process. Here, you write tests. Since
    this is the first test, it means you basically have nothing to test. Therefore,
    you must write the minimum piece of code that you can test. Now, since it''s the
    least amount of code required to be able to write a test, it will most likely
    fail when you write the code. But that''s totally fine. In TDD, your tests must
    fail before anything else happens! When your tests fail, that''s the first stage
    of the TDD cycle—the red stage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GREEN: Now, you have to write the minimum piece of code required to pass the
    test. When the test passes, that''s great, you have completed the second phase
    of the TDD cycle. Passing the test means that you have a part of your program
    working just as you expect it to. And as you keep building your app this way,
    at any point in time you will have every part of your code tested. Can you see
    how this works? By the time you have completed a feature, you have sufficient
    tests for testing various parts of that feature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'REFACTOR: The final stage of the TDD process is to refactor the code you wrote
    earlier to pass the test. Here, you remove redundant code, clean up, and write
    the full implementation for mocks. Afterwards, run the tests again. They may likely
    fail. In TDD, failing tests is a good thing. When you write tests and they pass,
    you can be certain a particular requirement or expectation has been met.'
  prefs: []
  type: TYPE_NORMAL
- en: There are other forms of development models built around testing, such as Behavior-Driven
    Testing, black-box testing, and smoke testing. However, they can basically be
    categorized under functional testing and non-functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: Functional versus non-functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With functional tests, you test the application against the given business
    requirements. They don''t require the application to be in full operation. These
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And with non-functional tests, you test the application against its operational
    environment. For instance, the app will connect to a real data source and use
    an HTTP connection. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usability testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start building our Notes app, create a new application and call it notes-app.
    Switch to the Project view using the tab at the top left corner of Android Studio.
    This view allows you to see the full project structure as it exists on your file
    system. It should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2040b167-15e5-4220-975c-59cbb23f4ad1.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit tests test small pieces of code, without any other parts of the product.
    In this case, it means your unit tests will not need a physical device, nor the
    Android jar, database, or network; just the source code you have written. These
    are the kind of tests that are to be written in the `test` directory.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, integration tests include all of the components required
    to run the app, and these tests will go into the `androidTest` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Test dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there is only one testing library, `Junit`, which you will use for
    unit testing. But, since your code will interact with other components, even though
    they may not be the ones under test, you will have to mock them. `Junit` is still
    not enough for writing the test cases. Therefore, you will also need to add `Hamcrest` to
    help with creating assertion matches and more. Let's go ahead and add the libraries
    we will need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your module''s build file, update the dependencies to match the following
    code, and sync the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For now, use the exact library versions as shown in the preceding code. This
    means you will have to ignore suggestions from the IDE to upgrade your library
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Later, you can update to newer, stable versions which are compatible with each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will first work on displaying the notes to the user. The notes presenter
    will provide the logic showing a progress indicator, which displays the notes
    and other note-related views.
  prefs: []
  type: TYPE_NORMAL
- en: Since the **Presenter** coordinates between the **Model** and **View**, you
    will have to mock them so you can focus on the class under test.
  prefs: []
  type: TYPE_NORMAL
- en: In this test, you will verify that asking the `NotesPresenter` to Add a new
    note will trigger a call to the `View` to show the add-note screen. Let's implement
    the ``should display note when button is clicked`()` test method.
  prefs: []
  type: TYPE_NORMAL
- en: You will first add a call to the presenter's `addNewNote()` method. Then, you
    will verify that the View's `showAddNote()` is called. Therefore, you call on
    one method and verify that it, in turn, calls another method (recall how the MVP
    pattern works; the presenter coordinates with the views).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will not worry about what the second call method does; this is
    unit testing, and you test one small thing (unit) at a time. So, you will have
    to mock out the View, and you don''t need to implement it now. A few interfaces
    can achieve this; that is, an API or contract without necessarily implementing
    them. See the following final pieces of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create `NotesContract`, which is the **View** part of the MVP architecture.
    It will be an interface where only the methods are required to make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `Note` class. It represents the **Model** in the MVP architecture.
    It defines the structure of the notes for the notes-app you''re building:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `NotesPresenter`, which represents the **Presenter** in the MVP
    architecture. Let it implement the `UserActionsListener` in the `NotesContract`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s enough for the first test. Are you ready? Okay, now click the right
    arrowhead beside the number on which the test method is defined. Or, you could
    equally right-click in or on the `NotesPresenterTest` file and select Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c8e93b-906f-4bab-9b3e-dde09872b839.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your test should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c50e97d4-36ff-422d-b102-784fb5e1562f.png)'
  prefs: []
  type: TYPE_IMG
- en: It failed because we expected the `showAddNote()` method of the `NotesView`
    class to be called, but it wasn't. This happened because you only implemented
    the interface in the `Presenter` class, but you never called the expected method
    in the `NotesView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and fix that now.
  prefs: []
  type: TYPE_NORMAL
- en: First, update `NotesPresenter` to accept a `NotesContract.View` object in its
    primary constructor. Then, call the expected method, `showAddNote()`, within the
    `addNewNote()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You should always prefer constructor injection to field injection. It is much
    easier to handle, and easier to read and maintain too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `NotesPresenter` class should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`checkNotNull` is a built-in `Kotlin` utility function for verifying whether
    an object is null or not. Its second parameter takes a lambda function which should
    return a default message if the object is null.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `NotesPresenter` now requires a `NotesContract.View` in its primary
    constructor, you''ll have to update the test to cater for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code has been refactored. Now, rerun the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6795a76f-089d-47d4-8190-e1fe3e286a61.png)'
  prefs: []
  type: TYPE_IMG
- en: Hooray! The test passes now; that's awesome. Excellent work.
  prefs: []
  type: TYPE_NORMAL
- en: That's one complete cycle using **TDD**. Now, you need to keep going, and there
    are a few more tests to complete before the feature will be fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Your next test is to validate that the presenter displays the notes as expected.
    In this process, the notes will have to be retrieved from the repository first
    before you update the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will use similar test APIs from the previous test. There is a new one you''ll
    learn here, however, which is called `ArgumentCaptor`. As you may have guessed,
    it captures the arguments passed to a method. You will use these to call another
    method and pass them in as parameters. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's go over this again very briefly.
  prefs: []
  type: TYPE_NORMAL
- en: You first called the method you are testing, which is `loadNotes()`. Then, you
    verified that that action, in turn, gets the notes (`getNotes()`) using the `NotesRepository`
    instance, just like the previous test. You then verified that the instance passed
    to the `getNotes()` method, which is again used to load the notes (`onNotesLoaded()`).
    Afterwards, you verify that `notesView` hides the progress indicator (`setProgressIndicator(false)`)
    and displays the notes (`showNotes()`).
  prefs: []
  type: TYPE_NORMAL
- en: Leverage the Null Safety feature in Kotlin as much as possible. Instead of having
    nullable types for the mocks, use Kotlin's `lateinit` modifier instead.
  prefs: []
  type: TYPE_NORMAL
- en: This results in much cleaner code because then you don't have to have nullability
    checks everywhere, nor do you have to use the `elvis` operator, either.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `NotesRepository` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `NotesContract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You are all set to test your second test case now. Go ahead and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7408b728-8d67-4d75-9de4-e29d76a12448.png)'
  prefs: []
  type: TYPE_IMG
- en: Okay, it fails. And again, with TDD, that's perfect! You realize that this tells
    us exactly what is missing, and thus what needs to be done. You only have the
    contract (interface) implemented, but no further action goes on there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your `NotesPresenter` and refactor the code to make this test pass.
    You will first add the `NotesRepository` as part of the constructor parameters,
    and then you will make the call within the appropriate method. See the following
    code for the full implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You used constructor injection to inject a `NotesRepository` instance into `NotesPresenter`.
    You checked it for nullability just like you did for `NotesContract.View`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `loadNotes()` method, you displayed the progress indicator and refreshed
    the data depending on the `forceUpdate` field.
  prefs: []
  type: TYPE_NORMAL
- en: You then used a utility class, `EspressoIdlingResource`, basically to alert
    Espresso of a possible asynchronous request. On getting the notes, you hide the
    progress indicator and showed the notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a util package to contain `EspressoIdlingResource` and `SimpleCountingIdlingResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And for `SimpleCountingIdlingResource` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to update your app''s build dependencies with the `EspressoIdlingResource`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update the `setUp` method to initialize correctly the `NotesPresenter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything''s set, run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/840cf956-4c61-45d0-bae7-ab5347e41120.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Really awesome stuff. You have successfully written the business logic
    for the NotesApp using a TDD approach.
  prefs: []
  type: TYPE_NORMAL
- en: Crashlytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the official website:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Firebase Crashlytics is a lightweight, real-time crash reporter that helps
    you track, prioritize, and fix stability issues that erode your app quality. Crashlytics
    saves you troubleshooting time by intelligently grouping crashes and highlighting
    the circumstances that lead up to them.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it, that''s basically what Crashlytics is about. It works on
    iOS and Android. Here are some of its primary capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Crash reporting:** Its main purpose is to report crashes, and it does it
    really well. It can be customized to suit your needs. For example, you may not
    want it to report certain kinds of crashes, among other customization options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics:** It gives reports on crashes including data on the users affected,
    their devices, the time the crash occurred, including clean stack traces and logs
    to aid in debugging and fixing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time alerts:** You are automatically alerted about new and recurring
    issues. The real-time alerts are necessary as they help you mitigate issues very
    quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashlytics is used to find out if a particular crash is impacting a lot of
    users. You also get alerts when an issue suddenly increases in severity, and it
    allows you to figure out which lines of code are causing crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for implementation are:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will start by adding Firebase to your app. Firebase is a platform for development
    for both mobile and web applications. It has a lot of tools, of which one is Crashlytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimum requirements are:'
  prefs: []
  type: TYPE_NORMAL
- en: A device running Android 4.0 (Ice Cream Sandwich) or newer, and Google Play
    Services 12.0.1 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Studio 2.2 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will use the Firebase Assistant tool within Android Studio 2.2+ to connect
    your app to Firebase. The Assistant tool will update your existing project or
    create a new one with all the necessary Gradle dependencies. It provides a very
    nice intuitive UI guide which you can follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/257940e6-ea7b-428d-996b-895332131468.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Check out the full guide for adding your project to Firebase in [Chapter 12](4204e9e4-6c78-4bb4-b581-bb3c8b1cb266.xhtml),
    *Setting Reminders for Tasks*. When you are done, log into the Firebase console
    from your browser. On the side menu, select **Crashlytics** from the **STABILITY**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e18fef4d-54eb-4579-9d8d-7a200210c3ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the Crashlytics page opens up, you will be asked if the app is new to
    Crashlytics. Select Yes, this app is new to Crashlytics (it doesn''t have any
    version of the SDK):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2ebfd80-78a0-453b-bb24-981692d48a3e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second step then gives you a link to the documentation page to set up Crashlytics
    for your app. To add Crashlytics to the app, update your project-level `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, update your app module''s `build.gradle` file with the Crashlytics plugin
    and dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, Crashlytics is ready to listen for crashes in your app. This is
    its default behavior, but if you want to control the initialization yourself,
    you will have to disable it in your manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your Activity class, you can enable it, even with a debugger like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure your Gradle Wrapper version is at least 4.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since your app will need to send reports to your console, add the internet
    permissions in your manifest file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As usual, sync Gradle to update your project with the dependency updates you
    just made.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you should see the Fabric plugin integrated with Android Studio.
    Sign up with your email and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a706d43a-a7b2-4047-8200-6465f9d94290.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After confirming your account, the Fabric API key will be generated for you.
    It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now force a crash in your app in order to test it. Create a new blank
    activity and add only one button. Then, set its `clicklistener` to force the crash.
    The Crashlytics SDK has a simple API for doing just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since you're testing, reopen the app after it crashes so the report can be sent
    to your console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and run the app. Your test activity should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e9636e6-0f3f-430c-b472-c232cdbbdb8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the CRASH! button to force the crash. Your app will crash. Click OK
    and reopen the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec06018-156b-4433-9d6a-b51f642381d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Check your inbox, that is, the one you signed up with on Crashlytics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c07f5283-dfce-4fc5-8af9-7f00b6bbe270.png)'
  prefs: []
  type: TYPE_IMG
- en: Click the Learn more button. It will open up the Crashlytics console. From there,
    you can find more details about the crash. From there, you can resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: Stages of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main stages in testing: alpha and beta testing. The main idea
    is to get a set of people to test the app at a stage in the development of the
    app. It usually begins just after the app is beginning to take shape, so that
    the feedback can be harnessed to make the app more stable. Stability is the key
    here. One key thing that distinguishes the various testing stages is the number
    of people involved in the testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Alpha testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alpha testing is considered to be the first phase of testing software. This
    test usually involves very few numbers of testers. At this stage, the app is highly
    unstable, so a few people close to the developers will be involved at this stage
    to test and provide constructive feedback. After the app becomes stabilized, it
    is ready to move into beta testing.
  prefs: []
  type: TYPE_NORMAL
- en: Beta testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beta testing is a phase of software testing where a larger group of people test
    out the application. It could involve 10, 100, or 1,000 people or more, depending
    on the nature of the app and the size of the team working on the app. If an app
    has lots of users worldwide, it'll most likely have a large team working on it
    and thus can afford to have lots of people engaged in beta testing the app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for beta testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can set up and manage beta testing from the **Google Pay Console.** You
    can choose to make your app available to a specific Google group or you can send
    them invitations via email.
  prefs: []
  type: TYPE_NORMAL
- en: Users must have a Google (`@gmail.com`) or a G Suite account to join. After
    publishing, it may take a while for your link to become available to testers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the beta test track
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you will have to create what is called a **track** inside your Google Play
    console. This is basically a setup to manage your testing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will be able to upload your APK, distribute it to a selected group
    of people, and track feedback as they test. You can manage both alpha and beta
    testing stages, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the following steps to set up a beta track:'
  prefs: []
  type: TYPE_NORMAL
- en: Login to your Play Console and select your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate **App releases** under **Release management**and select **Manage** under
    the **Beta track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload your APK in the **Artifacts** section, then expand the **Manage testers** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Choose a testing method**, select **Open Beta Testing**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the **Opt-in URL** and share it with your testers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an email address or URL next to the **Feedback channel** in order to
    collect feedback from testers. Then, click **Save** to, well, save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The opt-in URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are done creating the test, publish it. Then, you will be given the
    test link. Its format is as follows: [https://play.google.com/apps/testing/com.yourpackage.name](https://play.google.com/apps/testing/com.yourpackage.name.).
    Now, you have to share this link with your testers. With that, they can opt-in
    to test your app.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, more than one person (team) works on an app. For instance, person
    A may work on the UI, while person B works on feature 1 and person C works on
    feature 2 in the business logic. Such a project will still have one code base
    along with its tests and everything else. All committers will likely run tests
    locally against what each has worked on before pushing the code. The code in a
    shared repository with different committers has to be unified and built as one
    complete app (integration). The tests have to be run for the whole app as well.
    This has to be done regularly, and in the case of CI, per every commit. So in
    a day, the code in the shared repository will have been built and tested many
    times. This is the concept of Continuous Integration. The following is a very
    simple diagram showing the flow of the CI process. It begins from the left (Development):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdf09475-ece3-4615-9315-760d518fcfea.png)'
  prefs: []
  type: TYPE_IMG
- en: Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is a software development practice where an automated system is set up to build,
    test, and report on a piece of software after it has been checked into version
    control. **Integration** occurs because the various branches are merged into the
    main branch. This means whatever is in the main branch effectively represents
    the current state of the entire app, and since this happens every time code enters
    the main repository, it's **continuous;** hence, **Continuous Integration**.
  prefs: []
  type: TYPE_NORMAL
- en: In CI, whenever code is committed, an automated build system automatically grabs
    the latest code from the shared repository (main branch) and builds, tests, and
    validates the whole branch. By doing this regularly, errors are quickly detected
    and thus can be fixed quickly. Knowing that your commit could cause an unstable
    build, you are forced to commit small changes only. This also makes it easy to
    identify and fix bugs.
  prefs: []
  type: TYPE_NORMAL
- en: This is very important because, though the different parts of the app are tested
    and built individually, it may not be necessary after they have been merged into
    a shared repository. Each check-in is then verified by an automated build, allowing
    teams to detect problems early.
  prefs: []
  type: TYPE_NORMAL
- en: In the same light, there is also Continuous Deployment as well as Continuous
    Delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a wide array of tools available for CI. Some are open source, some
    are self-hosted, some are more suitable for web frontend, some for web backend,
    and some are more suitable for mobile development.
  prefs: []
  type: TYPE_NORMAL
- en: Examples include Jenkins, Bamboo, and Fastlane. You will use Fastlane to integrate
    your app and run your tests. Fastlane is self-hosted, which means that you run
    it on your development machine. Ideally, you should install it on a CI server,
    a dedicated server for CI tasks.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's install it locally and use it to run tests for the Notes app.
  prefs: []
  type: TYPE_NORMAL
- en: Fastlane, at the time of writing this book, runs on MacOS only. There is work
    in progress to get it to work on Linux and Windows as well. Some CI services include
    Jenkins, Bamboo, GitLab CI, Circle CI, and Travis.
  prefs: []
  type: TYPE_NORMAL
- en: Installing fastlane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install fastlane, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should already have **`gem`** on your path in your Terminal since x-code
    uses Ruby and comes bundled with Mac OS X. Run the following command to install
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may need to use `sudo` depending on your user account's privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a successful install, export the path to the `bin` directory to your
    `PATH` environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'While you''re at it, add the following locales as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new session within your Terminal. This new session will load the changes
    you just made to your environment variables. First, ensure that you have `bundler`
    installed. Use the following command if you don''t have it already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, switch to the root of your working directory. There, initialize `fastlane`
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be asked a few questions as part of the process. The first is for
    your package name. A default one will be provided when you leave it blank, so
    enter your package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4101973-7c49-4029-a07a-891247a1ac5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you will be asked to supply the path to a certain service action JSON
    secret file. Just press *Enter*, as we will not be needing it just yet; it can
    be supplied later. Finally, you will be asked whether you want to upload some
    metadata among other things. Humbly decline; you can set it up later with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There will be a few other prompts, for which you will just have to hit the *Enter*
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done, use the following command to run your test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When all goes well, you should see the results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fe3d173-e43b-471f-b080-44b955de79ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have been introduced to the concept of CI and testing.
    You have learned how to use the ATSL to write tests.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the two most popular stages in testing and how to set them
    up in the Google Play console. You tried out Crashlytics and experienced its crash
    reporting feature among others. Then you learned about CI, and as an example,
    you used one of the CI tools called Fastlane.
  prefs: []
  type: TYPE_NORMAL
- en: Wow, this chapter was really packed and here you are—you have made it to the
    end. In the next chapter, you will learn how to "make your app available to the
    world". Interesting, right? Well, let's move on; we'll meet again in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
