- en: Design – If It's Not Testable, It's Not Designed Well
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Simplicity is the ultimate sophistication."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: – Leonardo da Vinci
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In the past, the software industry was focused on developing software at high
    speed, with nothing in mind but cost and time. Quality was a secondary goal, with
    the false feeling that customers were not interested in it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, with the increasing connectivity of all kinds of platforms and devices,
    quality has become a first-class citizen in customer's requirements. Good applications
    offer a good service with a reasonable response-time, without being affected by
    a multitude of concurrent requests from many users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Good applications in terms of quality are those that have been well designed.
    A good design means scalability, security, maintainability, and many other desired
    attributes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore how TDD leads developers to good design and
    best practices by implementing the same application using both the traditional
    and TDD approaches.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Why should we care about design?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design considerations and principles
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The traditional development process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TDD approach using Hamcrest
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should we care about design?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, whether you are an expert or a beginner, there are
    some situations where code seems to be unnatural. You can't avoid the feeling
    that something is wrong with that code when reading it. Occasionally, you even
    wonder why the previous programmer implemented a specific method or a class in
    such a twisted manner. This is because the same functionality can be implemented
    in a vast number of different ways, each of them unique. With this huge number
    of possibilities, which is the best one? What defines a good solution? Why is
    one better than the others? The fact is, all of them are valid so long as the
    goal is achieved. However, it is true that some aspects should be considered when
    choosing the right solution. This is where the design of the solution becomes
    relevant.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **software design principle** is a rule or set of rules that work as a guide
    for software developers and push them towards smart and maintainable solutions.
    In other words, design principles are conditions that code must fulfill to be
    considered objectively well designed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Most senior developers and experienced programmers know about software design
    principles and it's very likely that, independently of whether they practice TDD,
    they are applying them to their daily work. The TDD philosophy encourages programmers—even
    beginners—to follow some principles and good practices that make code cleaner
    and more readable. Those practices are enforced by the Red-Green-Refactor cycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The Red-Green-Refactor cycle advocates for small feature increments by introducing
    one test that fails at a time. Programmers add code fragments, as concise and
    short as possible, so neither the new test or the old ones do not fail anymore.
    And ultimately, they refactor the code, which consists of cleanup and improvement
    tasks such as duplication removal or code optimization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the process, the code becomes easier to understand and safer
    to modify in the future. Let's take a look at some of the most popular software
    design principles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: You Ain't Gonna Need It
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAGNI** is the acronym for the **You Ain''t Gonna Need It** principle. It
    aims to erase all unnecessary code and focuses on the current functionalities,
    not the future ones. The less code you have, the less code you''re going to maintain
    and the lower the probability that bugs will be introduced.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: For more information on YAGNI, visit Martin Fowler's article available at [http://martinfowler.com/bliki/Yagni.html](http://martinfowler.com/bliki/Yagni.html).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Don't Repeat Yourself
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind the **Don't Repeat Yourself** (**DRY**) principle is to reuse
    the code you previously wrote instead of repeating it. The benefits are less code
    to maintain and the use of code that you know that already works, which is a great
    thing. It helps you to discover new abstraction levels inside your code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For additional information, visit [http://en.wikipedia.org/wiki/Don%27t_repeat_yourself](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Keep it simple, stupid
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This principle has the confusing acronym of **keep it simple**, **stupid** (**KISS**) and
    states that things perform their function better if they are kept simple rather
    than complicated. It was coined by Kelly Johnson.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: To read about the story behind this principle, visit [http://en.wikipedia.org/wiki/KISS_principle](http://en.wikipedia.org/wiki/KISS_principle).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Occam's razor
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although **Occam''s razor** is a philosophical principle, not a software engineering
    one, it is still applicable to what we do. It is very similar to the previous
    principle, with the main statement being as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '"When you have two competing solutions to the same problem, the simpler one
    is the better."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: – William of Ockham
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Occam's razor, visit [http://en.wikipedia.org/wiki/Occam%27s_razor](http://en.wikipedia.org/wiki/Occam%27s_razor).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The word **SOLID** is an acronym invented by Robert C. Martin for the five
    basic principles of object-oriented programming. By following these five principles,
    a developer is more likely to create a great, durable, and maintainable application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle**: A class should have only a single reason
    to change.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed Principle**: A class should be open for extension and closed
    for modification. This is attributed to Bertrand Meyer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle**: This was created by Barbara Liskov, and
    she says *a class should be replaceable by others that extend that class*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle**: A few specific interfaces are preferable
    to one general-purpose interface.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle**: A class should depend on abstraction instead
    of implementation. This means that class dependencies must be focused on what
    is done and forget about how it is done.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further information on SOLID or other related principles, visit [http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The first four principles are part of the core of TDD thinking, since they aim
    to simplify the code we write. The last one is focused on classes construction
    and dependency relationships in the application assembly process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: All of these principles are applicable and desirable in both test and non-test
    driven development, because, apart from other benefits, they make our code more
    maintainable. The proper practical application of them is worth a whole book by
    itself. While we won't have time to go deep into it, we encourage you to investigate
    further.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how TDD induces developers to put some of these
    principles into practice effortlessly. We will implement a small but fully functional
    version of the famous game Connect 4 with both the TDD and non-TDD approaches.
    Note that repetitive parts, such as Gradle project creation and so on, are omitted,
    as they are not considered relevant for the purpose of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Connect 4
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect 4 is a popular, very easy-to-play board game. The rules are limited
    and simple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Connect 4 is a two-player connection game in which the players first choose
    a color and then take turns dropping colored discs from the top into a seven column,
    six row, vertically suspended grid. The pieces fall straight down, occupying the
    next available space within the column. The objective of the game is to connect
    four of your own discs of the same color next to one another vertically, horizontally,
    or diagonally, before your opponent connects four of theirs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: For further information on the game, visit Wikipedia ([http://en.wikipedia.org/wiki/Connect_Four](http://en.wikipedia.org/wiki/Connect_Four)).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To code the two implementations of Connect 4, the game rules are transcribed
    as follows in the form of requirements. These requirements are the starting point
    for both the developments. We will go through the code with some explanations
    and compare both implementations at the end:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The board is composed of seven columns and six rows; all positions are empty.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Players introduce discs on the top of the columns. The introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a two-person game, so there is one color for each player. One player uses
    red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board after every move.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When no more discs can be inserted, the game finishes, and it is considered
    a draw.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight vertical line, then that player wins.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same happens in a horizontal line direction.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same happens in a diagonal line direction.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test-last implementation of Connect 4
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the traditional approach, focusing on problem-solving code rather than
    tests. Some people and companies forget about the value of automated testing and
    rely on users in what are called **user acceptance tests**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: This kind of user acceptance test consists of recreating real-world scenarios
    in a controlled environment, ideally identical to production. Some users perform
    a lot of different tasks to verify the correctness of the application. If any
    of these actions fail, then the code is not accepted, as it is breaking some functionality
    or it is not working as expected.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, a great number of these companies also use unit testing as a way
    to perform early regression checks. These unit tests are created after the development
    process and they try to cover as much code as possible. Last of all, code coverage
    analysis is executed to get a trace of what is actually covered by those unit
    tests. These companies follow a single rule of thumb: the bigger the code coverage,
    the better the quality delivered.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The main problem of this approach is that writing tests afterwards does nothing
    but demonstrates that the code behaves the way it has been programmed, which is
    not necessarily the way code is expected to behave. Also, focusing on code coverage
    leads to bad tests that turn our production code into immutable entities. Every
    modification we may want to add may cause several tests from different, unrelated
    parts of the code to fail. That fact means the cost of introducing changes becomes
    really high and performing any slight modification could end up being a nightmare
    and very expensive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate some points described earlier, let's implement the Connect 4
    game using a TDD and not-TDD approach. The relevant code for each of the identified
    requirements is presented as we proceed further. This code isn't written incrementally,
    so some code snippets might contain a few code lines unrelated to the mentioned
    requirement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Requirement 1 – the game's board
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us start with the first requirement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The board is composed of seven horizontal and six vertical empty positions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this requirement is pretty straightforward. We just need
    the representation of an empty position and the data structure to hold the game.
    Note that the colors used by the players are also defined:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Requirement 2 – introducing discs
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This requirement introduces part of the logic of the game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Players introduce discs on the top of the columns. The introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, board bounds become relevant. We need to mark what positions
    are already taken, using `Color.RED` to indicate them. Finally, the first `private`
    method is created. It is a helper method that calculates the number of discs introduced
    in a given column:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Requirement 3 – player shifts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More game logic is introduced with this requirement.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: It is a two-person game, so there is one colour for each player. One player
    uses red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to save the current player to determine which player is playing this
    turn. We also need a function to switch the players to recreate the logic of turns.
    Some lines of code become relevant in the `putDisc` function. Specifically, the
    board position assignment is made using the current player, and it is switched
    after every move, as the game rules say:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Requirement 4 – the game's output
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few outputs should be added to let the players know the current status of
    the game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board after every move.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'No output channel is specified. To make it easier, we decided to use the system
    standard output to print an event when it occurs. A few lines have been added
    on every action to let the user know about the status of the game:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Requirement 5 – win conditions (I)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first game has a finished condition.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: When no more discs can be inserted, the game finishes and it is considered a
    draw.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows one of the possible implementations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Requirement 6 – win condition (II)
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first win condition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his colour
    in a straight vertical line, then that player wins.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `checkWinCondition` private method implements this rule by scanning whether
    or not the last move is a winning one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Requirement 7 – win condition (III)
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the same win condition, but in a different direction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight horizontal line, then that player wins.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'A few lines to implement this rule are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Requirement 8 – win condition (IV)
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last requirement is the last win condition. It is pretty similar to the
    last two; in this case, in a diagonal direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight diagonal line, then that player wins.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a possible implementation for this last requirement. The code is very
    similar to the other win conditions because the same statement must be fulfilled:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we have got is a class with one constructor, three public methods, and
    three private methods. The logic of the application is distributed among all methods.
    The biggest flaw here is that this class is very difficult to maintain. The crucial
    methods, such as `checkWinCondition`, are non-trivial, with potential for bug
    entries in future modifications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: If you want to take a look at the full code, you can find it in the [https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git)
    repository.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We made this small example to demonstrate the common problems with this approach.
    Topics such as the SOLID principle requires a bigger project to become more illustrative.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In large projects with hundreds of classes, the problems become hours wasted
    in a sort of surgical development. Developers spend a lot of their time investigating
    tricky code and understanding how it works, instead of creating new features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The TDD or test-first implementation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this time, we know how TDD works—writing tests before, implementation after
    tests, and refactoring later on. We are going to pass through the process and
    only show the final result for each requirement. It is left to you to figure out
    the iterative Red-Green-Refactor process. Let's make this more interesting, if
    possible, by using a Hamcrest framework in our tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Hamcrest
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [Chapter 2](2b33a0f7-c645-4266-891b-8572251f083e.xhtml), *Tools,
    Frameworks, and Environment*, Hamcrest improves our test's readability. It makes
    assertions more semantic and comprehensive when complexity is reduced by using
    **matchers**. When a test fails, the error shown becomes more expressive by interpreting
    the matchers used in the assertion. A message could also be added by the developer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The `Hamcrest` library is full of different matchers for different object types
    and collections. Let's start coding and get a taste of it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Requirement 1 – the game's board
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with the first requirement.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The board is composed of seven horizontal and six vertical empty positions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: There is no big challenge with this requirement. The board bounds are specified,
    but there's no described behavior in it; just the consideration of an empty board
    when the game starts. That means zero discs when the game begins. However, this
    requirement must be taken into account later on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the test class looks for this requirement. There''s a method to
    initialize the `tested` class to use a completely fresh object in each test. There''s
    also the first test to verify that there''s no disc when we start the game, meaning
    that all board positions are empty:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the TDD implementation of the previous specification. Observe the simplicity
    of the given solution for this first requirement; a simple method returning the
    result in a single line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Requirement 2 – introducing discs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the implementation for the second requirement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Players introduce discs on the top of the columns. An introduced disc drops
    down the board if the column is empty. Future discs introduced in the same column
    will stack over the previous ones.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split this requirement into the following tests:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: When a disc is inserted into an empty column, its position is `0`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a second disc is inserted into the same column, its position is `1`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a disc is inserted into the board, the total number of discs increases
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a disc is put outside the boundaries, a `Runtime Exception` is thrown
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a disc is inserted into a column and there's no room available for it,
    then a `Runtime Exception` is thrown
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, these other tests are derived from the first requirement. They are related
    to the board limits or board behavior.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java implementation of the aforementioned tests is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the necessary code to satisfy the tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Requirement 3 – player shifts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third requirement relates to the game logic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: It is a two-person game, so there is one colour for each player. One player
    uses red (*R*) and the other one uses green (*G*). Players alternate turns, inserting
    one disc every time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'These tests cover the verification of the new functionality. For the sake of
    simplicity, the red player will always start the game:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A couple of methods need to be created to cover this functionality. The `switchPlayer`
    method is called before returning the row in the `putDiscInColumn` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Requirement 4 – the game's output
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we should let the player know the status of the game.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We want feedback when either an event or an error occurs within the game. The
    output shows the status of the board on every move.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are throwing exceptions when an error occurs, this is already covered,
    so we only need to implement these two tests. Furthermore, for the sake of testability,
    we need to introduce a parameter within the constructor. By introducing this parameter,
    the output becomes easier to test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'One possible implementation is to pass the preceding tests. As you can see,
    the class constructor now has one parameter. This parameter is used in several
    methods to print the event or action description:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Requirement 5 – win condition (I)
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This requirement tells the system whether the game is finished.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When no more discs can be inserted, the game finishes and it is considered a
    draw.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two conditions to test. The first condition is that new game must
    be unfinished; the second condition is that full board games must be finished:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An easy and simple solution to these two tests is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Requirement 6 – win condition (II)
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first win condition requirement for players.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight vertical line, then that player wins.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, this requires one single check. If the current inserted disc connects
    other three discs in a vertical line, the current player wins the game:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There are a couple of changes to the `putDiscInColumn` method. Also, a new
    method called `checkWinner` has been created:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Requirement 7 – win condition (III)
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the second win condition, which is pretty similar to the previous one.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight horizontal line, then that player wins.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we are trying to win the game by inserting discs into adjacent columns:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code to pass this test is put into the `checkWinners` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Requirement 8 – win condition (IV)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last requirement is the last win condition.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: If a player inserts a disc and connects more than three discs of his color in
    a straight diagonal line, then that player wins.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to perform valid game movements to achieve the condition. In this case,
    we need to test both diagonals across the board: from top-right to bottom-left
    and from bottom-right to top-left. The following tests use a list of columns to
    recreate a full game to reproduce the scenario under test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, the `checkWinner` method needs to be modified, adding new board verifications:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Final considerations
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using TDD, we got a class with a constructor, five public methods, and six
    private methods. In general, all methods look pretty simple and easy to understand.
    In this approach, we also got a big method to check winner conditions: `checkWinner`.
    The advantage is that with this approach we got a bunch of useful tests to guarantee
    that future modifications do not alter the behavior of the method accidentally,
    allowing for the introduction of new changes painlessly. Code coverage wasn''t
    the goal, but we got a really high percentage.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, for testing purposes, we refactored the constructor of the class
    to accept the output channel as a parameter (**dependency injection**). If we
    need to modify the way the game status is printed, it will be easier that way
    than replacing all the uses in the traditional approach. Hence, it is more extensible.
    In the test-last approach, we have been abusing the `System.println` method and
    it will be really tedious task if we decide to change all the occurrences for
    any other thing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'In large projects, when you detect that a great number of tests must be created
    for a single class, this enables you to split the class following the Single Responsibility
    Principle. As the output printing was delegated to an external class passed in
    a parameter in initialization, a more elegant solution would be to create a class
    with high-level printing methods. That would keep the printing logic separated
    from the game logic. Like the huge code coverage shown in the following image,
    these are a few examples of the benefits of good design using TDD:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3d0f91a-75fd-4966-9fb6-643ac5ea040c.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: The code of this approach is available at [https://bitbucket.org/vfarcic/tdd-java-ch05-design.git](https://bitbucket.org/vfarcic/tdd-java-ch05-design.git).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we briefly talked about software design and a few basic design
    principles. We implemented a fully functional version of the board game Connect
    4 using two approaches—traditional and TDD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: We analyzed both solutions in terms of pros and cons, and used a Hamcrest framework
    to empower our tests.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we concluded that good design and good practices can be performed by
    both approaches, but TDD is a better approach.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'For further information about the topics that this chapter covers, refer to
    two highly recommended books written by Robert C. Martin: *Clean Code: A Handbook
    of Agile Software Craftsmanship* and *Agile Software Development: Principles,
    Patterns, and Practices*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请参考罗伯特·C·马丁所著的两本高度推荐的书籍：《代码整洁之道：敏捷软件工艺》和《敏捷软件开发：原则、模式和实践》。
