- en: Chapter 1. Introduction to CouchDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to CouchDB and PHP Web Development Beginner's Guide. In this book, we
    will learn the ins and outs of building a simple but powerful website using CouchDB
    and PHP. For you to understand why we do certain things in CouchDB, it's first
    important for you to understand the history of NoSQL databases and learn CouchDB's
    place in database history.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Go over a brief history of databases and their place in technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about how databases evolved into the concept of NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define NoSQL databases by understanding different classifications of NoSQL databases,
    the CAP theorem and its avoidance of the ACID model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the history of CouchDB and its main contributors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about what makes CouchDB special
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at the evolution of databases and how NoSQL arrived on
    the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The NoSQL database evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early 1960s, the term **database** was introduced to the world as a simple
    layer that would serve as the backbone behind information systems. The simple
    concept of separating applications from data was new and exciting, and it opened
    up possibilities for applications to become more robust. At this point, databases
    existed first as tape-based devices, but soon became more usable as system direct-access
    storage on disks.
  prefs: []
  type: TYPE_NORMAL
- en: In 1970, Edgar Codd proposed a more efficient way of storing data — the relational
    model. This model would also use SQL to allow the applications to find the data
    stored within its tables. This relational model is nearly identical to what we
    know as traditional relational databases today. While this model was widely accepted,
    it wasn't until the mid 1980s that there was hardware that could actually make
    effective use of it. By 1990, hardware finally caught up, and the relational model
    became the dominant method for storing data.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in any area of technology, competition arose with **Relational Database
    Management Systems (RDBMS)** . Some examples of popular RDMBS systems are Oracle,
    Microsoft SQL Server, MySQL, and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: As we moved past the year 2000, applications began to produce incredible amounts
    of data through more complex applications. Social networks entered the scene.
    Companies wanted to make sense of the vast amounts of data that were available.
    This shift brought up some serious concerns about the datastructure, scalability,
    and availability of data that the relational model didn't seem to handle. With
    the uncertainty of how to manage this large amount of ever-changing data, the
    term NoSQL emerged.
  prefs: []
  type: TYPE_NORMAL
- en: The term **NoSQL** isn't short for "no SQL;" it actually stands for "not only
    SQL". NoSQL databases are a group of persistent solutions, which do not follow
    the relational model and do not use SQL for querying. On top of that, NoSQL wasn't
    introduced to replace relational databases. It was introduced to complement relational
    databases where they fell short.
  prefs: []
  type: TYPE_NORMAL
- en: What makes NoSQL different
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the fact that NoSQL databases do not use SQL to query data, there are
    a few key characteristics of NoSQL databases. In order to understand these characteristics,
    we'll need to cover a lot of terminology and definitions. It's not important that
    you memorize or remember everything here, but it's important for you to know exactly
    what makes up a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that makes NoSQL databases different is their data structure.
    There are a variety of different ways in which NoSQL databases are classified.
  prefs: []
  type: TYPE_NORMAL
- en: Classification of NoSQL databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NoSQL databases (for the most part) fit into four main data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key-value stores:** They save data with a unique key and a value. Their simplicity
    allow them to be incredibly fast and scale to enormous sizes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column stores:** They are similar to relational databases, but instead of
    storing records, they store all of the values for a column together in a stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document stores:** They save data without it being structured in a schema,
    with buckets of key-value pairs inside a self-contained object. This datastructure
    is reminiscent of an associative array in PHP. This is where CouchDB lands on
    the playing field. We''ll go much deeper into this topic in [Chapter 3](ch03.html
    "Chapter 3. Getting Started with CouchDB and Futon"), *Getting Started with CouchDB
    and Futon.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph databases:** They store data in a flexible graph model that contains
    a node for each object. Nodes have properties and relationships to other nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won''t go too deeply into examples of each of these types of databases,
    but it''s important to look at the different options that are out there. By looking
    at databases at this level, it''s relatively easy for us to see (in general) how
    the data will scale to size and complexity, by looking at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classification of NoSQL databases](graphics/3586_01_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at this diagram, you'll see that I've placed a **Typical Relational
    Database** with a crude performance line. This performance line gives you a simple
    idea of how a database might scale in size and complexity. How is it possible
    that NoSQL databases perform so much better in regards to high size and complexity
    of data?
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, NoSQL databases are scalable because they rely on distributed
    systems and ignore the ACID model. Let's talk through what we gain and what we
    give up through a distributed system, and then define the ACID model.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about any distributed system (not just storage or databases), there
    is a concept that defines the limitations of what you can do. This is known as
    the CAP theorem.
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Eric Brewer* introduced the CAP theorem in the year 2000\. It states that
    in any distributed environment, it is impossible for it to provide three guarantees.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency:** All the servers in the system will have the same data. So,
    anyone using the system will get the latest data, regardless of which node they
    talk to in the distributed system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability:** All of the servers will always return data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partition-tolerance:** The system continues to operate as a whole, even if
    an individual server fails or cannot be reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By looking at these choices, you can tell that it would definitely be ideal
    to have all three of these things guaranteed, but it's theoretically impossible.
    In the real world, each NoSQL database picks two of the three options, and usually
    develops some kind of process to mitigate the impact of the third, unhandled property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll talk about which approach CouchDB takes shortly, but there is still
    a bit to learn about another concept that NoSQL databases avoid: ACID.'
  prefs: []
  type: TYPE_NORMAL
- en: ACID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ACID** is a set of properties that apply to database transactions, which
    are the core of traditional relational databases. While transactions are incredibly
    powerful, they are also one of the things that make reading and writing quite
    a bit slower in relational databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ACID is made up of four main properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity:** This is an all or nothing approach to dealing with data. Everything
    in the transaction must happen successfully, or none of the changes are committed.
    This is a key property whenever money or currency is handled in a system, and
    requires a system of checks and balances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency:** Data will only be accepted if it passes all of the validation
    in place on the database, such as triggers, data types, and constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation:** Transactions will not affect other transactions that are occurring,
    and other users won''t see partial results of a transaction in progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability:** Once the data is saved, it is safe against errors, crashes,
    and other software malfunctions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, as you read through the definition of ACID, you are probably thinking
    to yourself, "These are all must haves!" That may be the case, but keep in mind
    that most NoSQL databases do not fully employ ACID, because it's near impossible
    to have all of these restrictions and still have blazing fast writes to data.
  prefs: []
  type: TYPE_NORMAL
- en: So what does all of that mean?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I've given you a lot of definitions now, but let's try to wrap it together into
    a few simple lists. Let's talk through the advantages and disadvantages of NoSQL
    databases, when to use, and when to avoid NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of NoSQL databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the introduction of NoSQL databases, there are lot of advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You can do things that simply weren't possible with the processing and query
    power of traditional relational databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your data is scalable and flexible, allowing it to scale to size and complexity
    faster, right out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are new data models to consider. You don't have to force your data into
    a relational model if it doesn't make sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data is blazing fast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are some clear advantages of NoSQL databases, but as I
    mentioned before, there are still some negatives that we need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Negatives of NoSQL databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'However, along with the good, there''s also some bad:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no common standards; each database does things just a little bit differently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying data does not involve the familiar SQL model to find records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases are still relatively immature and constantly evolving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are new data models to consider; sometimes it can be confusing to make
    your data fit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because a NoSQL database avoids the ACID model, there is no guarantee that all
    of your data will be successfully written
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of those negatives may be pretty easy for you to stomach, except for NoSQL's
    avoidance of the ACID model.
  prefs: []
  type: TYPE_NORMAL
- en: When you should use NoSQL databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have a good take on the advantages and disadvantages, let''s talk
    about some great use cases for using NoSQL databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications that have a lot of writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications where the schema and structure of the data might change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large amount of unstructured or semi-structured data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional relational databases feel restricting, and you want to try something
    new.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That list isn't exclusive, but there are no clear definitions on when you can
    use NoSQL databases. Really, you can use them for just about every project.
  prefs: []
  type: TYPE_NORMAL
- en: When you should avoid NoSQL databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are, however, some pretty clear areas that you should avoid when storing
    data in NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Anything involving money or transactions. What happens if one record doesn't
    save correctly because of NoSQL avoidance of the ACID model or the data isn't
    100 percent available because of the distributed system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business critical data or line of business applications, where missing one row
    of data could mean huge problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heavily-structured data requiring functionality in a relational database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all of these use cases, you should really focus on using relational databases
    that will make sure that your data is safe and sound. Of course, you can always
    include NoSQL databases where it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a database, it's important to remember that "There is no silver
    bullet." This phrase is used a lot when talking about technology, and it means
    that there is no one technology that will solve all of your problems without having
    any side effects or negative consequences. So choose wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to CouchDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this book and for a variety of my own projects and startups, I chose CouchDB.
    Let's take a historical look at CouchDB, then quickly touch on its approach to
    the CAP theorem, and its strengths and weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: The history of CouchDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In April 2005, *Damien Katz* posted a blog entry about a new database engine
    he was working on, later to be called CouchDB, which is an acronym for **Cluster
    Of Unreliable Commodity Hardware**. Katz, a former Lotus Notes developer at IBM,
    was attempting to create a fault-tolerant document database in C++, but soon after,
    shifted to the **Erlang OTP** platform. As months went by, CouchDB started to
    evolve under the self-funding of Damien Katz, and in February 2008, it was introduced
    to the Apache Incubator project. Finally, in November 2008, it graduated as a
    top-level project.
  prefs: []
  type: TYPE_NORMAL
- en: Damien's team, **CouchOne**, merged with the Membase team in 2011 to form a
    new company called **Couchbase**. This company was formed to merge **CouchDB**
    and **Membase** into a new product, and increase the documentation and visibility
    for the product.
  prefs: []
  type: TYPE_NORMAL
- en: In early 2012, Couchbase announced that it would be shifting focus from facilitating
    CouchDB and moving to create Couchbase Server 2.0\. This new database takes a
    different approach to the database, which meant that it would not be contributing
    to the CouchDB community anymore. This news was met with some distress in the
    CouchDB community until Cloudant stepped in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloudant**, the chief CouchDB hosting company and creator of BigCouch, a
    fault tolerant and horizontally scalable clustering frameworking built for CouchDB,
    announced that they would merge their changes back to CouchDB, and take on the
    role of continuing development of CouchDB.'
  prefs: []
  type: TYPE_NORMAL
- en: In early 2012, at the time of writing, CouchDB's most major release was 1.1.1
    in March 31, 2011\. But CouchDB 1.2 is looking to be released just around the
    corner!
  prefs: []
  type: TYPE_NORMAL
- en: Defining CouchDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to [http://couchdb.apache.org/](http://couchdb.apache.org/), CouchDB
    can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: A document database server, accessible via a RESTful JSON API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ad-hoc and schema-free with a flat address space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed, featuring robust, incremental replication with bi-directional conflict
    detection and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query-able and index-able, featuring a table oriented reporting engine that
    uses JavaScript as a query language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be able to read between the lines, but CouchDB chose availability
    and partial-tolerance from the CAP theorem, and focuses on eventual consistency
    using replication.
  prefs: []
  type: TYPE_NORMAL
- en: We could go really deep into what each of these bullet points mean, because
    it will take the rest of the book until we've touched on them in depth. In each
    chapter, we'll begin to build on top of our CouchDB knowledge until we have a
    fully operational application in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you enjoyed this chapter and are ready to take a deep dive into really
    learning the ins and outs of CouchDB. Let's recap everything we learned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the history of databases and the emergence of NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the advantages and disadvantages of using NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We looked at the definition and history of CouchDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it for the history lesson. Fire up your computer. In the next chapter,
    we'll set everything up to develop web applications with CouchDB and PHP, and
    make sure that it's all set up correctly.
  prefs: []
  type: TYPE_NORMAL
