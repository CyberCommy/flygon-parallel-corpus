- en: '*Chapter 11*: Reflection and Dynamic Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at functional programming, lambda expressions,
    and the features they enable, such as **Language Integrated Query (LINQ)**. This
    chapter is focused on reflection services and dynamic programming. You will learn
    what reflection is and how you can get information about types at runtime, as
    well as how code and resources are stored in assemblies and how these can be loaded
    dynamically at runtime both for reflection and code execution.
  prefs: []
  type: TYPE_NORMAL
- en: This is key for building applications that support extension in the form of
    add-ons or plugins. We will see what attributes are and what role they play in
    reflection. Another important topic that we will address in this chapter is dynamic
    programming and the **Dynamic Language Runtime** that enables dynamic languages
    to run on the **Common Language Runtime (CLR**) and to add dynamic features to
    statically typed languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will address in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically loading assemblies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding late binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `dynamic` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a good understanding of reflection,
    attributes, and their use in reflection, as well as assembly loading and code
    execution. On the other hand, you will also learn about the `dynamic` type and
    be able to interoperate with dynamic languages.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The unit of deployment in .NET is the assembly. An assembly is a file (either
    an executable or a dynamic-linked library) that contains `ildasm.exe` (`ilspy.exe`
    (an open-source project); or others allow you to view the content of the assembly.
    The following is a screenshot of `ildasm.exe` that shows the `chapter_11_01.dll`
    assembly, available with the source code of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 - Disassembled source code for chapter 11 assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 â€“ Disassembled source code for chapter_11_01 assembly
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflection** is the process of runtime type discovery and the ability to
    make changes to them. This means that we can retrieve information about types,
    their members, and attributes at runtime. This brings several important benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to load assemblies dynamically during runtime (late binding), inspect
    types, and execute code makes it easy to build extensible applications. An application
    can define functionalities through interfaces and base classes, which would then
    be implemented or extended in separate modules (plugins or add-ons) that could
    be loaded and executed at runtime based on various conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes, which we will later see in this chapter, make it possible to provide
    meta-information about types, methods, properties, and others in a declarative
    way. By being able to read these attributes at runtime, a system can change their
    behavior. Tools, for instance, could warn that a method is used differently than
    intended (such as in the case of obsolete methods) or execute them in a particular
    way. Testing frameworks (we will look at some in the final chapter) use this functionality
    extensively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides the ability to execute types and members that are private or have
    other access levels that make them inaccessible otherwise. This is, again, very
    handy for testing frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows modifying existing types or creating entirely new types at runtime
    and executing code using them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflection also has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: It incurs an overhead that can degrade performance. Loading, discovering, and
    executing code at runtime is slower and may prevent optimizations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It exposes the internals of types because it allows introspection on all types
    and members regardless of their access level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The .NET reflection services allow you to discover, using APIs from the `System.Reflection`
    namespace, the same information that you can see with the tools mentioned earlier.
    The key to this process is the type called `System.Type`, which contains members
    that expose all of a type''s metadata. This is done with the help of other types
    from the `System.Reflection` namespace, some of which are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_11_Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the most important members of the `System.Type` class are listed in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_11_Table_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are several ways to retrieve an instance of `System.Type` to access type
    metadata at runtime; here are a few:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `GetType()` method of the `System.Object` type. Since this is the
    base class for all value and reference types, you can call with an instance of
    any type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `GetType()` static method from `System.Type`. There are many overloads
    that allow you to specify the name and various parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the C# `typeof` operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we can use reflection by looking at an actual example. We will
    consider the following `Engine` type, which has several properties, a constructor,
    and a couple of methods that change the status of the engine (started or stopped):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will build a small program that will read metadata about the `Engine` type
    at runtime and print the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the *type*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of all *properties* as well as the name of their type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of all *declared methods* (excluding the inherited methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of their *return type*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name and type of *each parameter*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the program to read and print metadata about the `Engine` type at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `typeof` operator to retrieve an instance of the
    `System.Type` type to discover the metadata for the `Engine` type. To retrieve
    properties, we used the overload of `GetProperties()` with no parameters, which
    returns all of the public properties of the current type. For methods, however,
    we used an overload of the `GetMethod()` method, which takes as argument a bitmask
    comprised of one or more `BindingFlags` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `BindingFlags` type is an enum with flags that control the binding and
    the way searching for types and methods is performed during reflection. In our
    example, we used `Public`, `Instance`, and `DeclareOnly` to specify public, non-static
    methods declared in this type only, and exclude inherited ones. The output of
    this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Engine` type is located in the assembly where the reflection code was executed.
    However, you can also reflect on types from other assemblies too, whether they
    are referred from the executing assembly or loaded at runtime, which is what we
    will look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading assemblies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reflection services allow you to load an assembly at runtime. This is done
    using the `System.Reflection.Assembly` type, which provides various methods for
    loading assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: Assemblies can be either *public* (also called *shared*) or *private*. A shared
    assembly is intended to be used by several applications and is usually located
    under the **Global Assembly Cache (GAC)**, a system repository for assemblies.
    A private assembly is intended to be used by a single application and is stored
    in the application directory or one of its sub-directories. Shared assemblies
    must be strongly named and enforce version constraints; these requirements are
    not necessary for private assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'An assembly can be loaded in one of three contexts or without any:'
  prefs: []
  type: TYPE_NORMAL
- en: The *load context*, which contains assemblies loaded from the GAC, the application
    directory (`ApplicationBase` of the app domain), or its sub-directories of private
    assemblies (`PrivateBinPath` of the app domain)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *load-from context*, which contains assemblies loaded from paths other than
    the aforementioned ones that are probed by the assembly loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *reflection-only context*, which contains assemblies loaded for reflection
    purposes only and which cannot be used to execute code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No context*, which is used in some particular cases such as assemblies loaded
    from an array of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most important methods used to load assemblies are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_11_Table_3_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will look at several examples of loading assemblies dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, we use `Assembly.Load()` to load an assembly called `EngineLib`
    from the applications directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we only specified the name of the assembly, but we could alternatively
    specify the display name, which is comprised not only of the name but also the
    version, culture, and the public key token used to sign the assembly. For assemblies
    that do not have a strong name, this is `null`. The following line, where we use
    the display name, is equivalent to the one used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to create the display name in a type-safe way by using the `AssemblyName`
    class. This class has various properties and methods that allow you to build the
    display name. This can be done as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Public (or shared) assemblies must have a strong name. This helps to uniquely
    identify the assembly and therefore avoid possible conflicts. Signing is done
    using a public-private key; the private key is used for signing and the public
    key is distributed with the assembly and used to verify the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a cryptographic pair can be generated with the `sn.exe` tool, distributed
    with Visual Studio; this tool can also be used for verifying a signature. For
    strong-name assemblies, `PublicKeyToken` must be specified or loading would fail.
    The following example shows how to load `WindowsBase.dll` from the GAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative to using the assembly name for loading an assembly is to use
    its actual path. However, in this case, you must use one of the `LoadFrom()` overloads.
    This is useful for cases where you must load an assembly that is neither in the
    GAC nor under the application''s folder. An example can be an extensible system
    that can load plugins that may be installed in some custom directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Assembly` class has members that provide information about the assembly
    itself, as well as members that provide information about the types it contains.
    Some of the most important members are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_11_Table_4_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, after loading an assembly using one of the methods
    shown previously, we list the assembly name and the files in the assembly manifest,
    as well as the names of the referenced assemblies. After that, we search for the
    `EngineLib.Engine` type and print the name and the type of all of its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Apart from querying for information about an assembly and its content, it is
    also possible to execute code from it at runtime. This is what we will look at
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding late binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you reference an assembly at compile time, the compiler has full access
    to the types available in that assembly. This is called **early binding**. However,
    if an assembly is only loaded at runtime, the compiler has no access to the content
    of that assembly. This is called **late binding** and is key to building extensible
    applications. Using late binding, you can not only load and query assemblies but
    also execute code. We will see that in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine the `Engine` class, shown earlier, is available in an assembly
    called `EngineLib`. This can be loaded with either `Assembly.Load()` or `Assembly.LoadFrom()`.
    Once loaded, we can get information about the `Engine` type using `Assembly.GetType()`
    and the class methods of `Type`. However, using `Assembly.CreateInstance()`, we
    can instantiate an object of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Assembly.CreateInstance()` method has many parameters, but three of them
    are of the most importance:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `string typeName`, representing the name of the assembly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter, `BindingFlags bindingAttr`, representing binding flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth parameter, `object[]` `args`, representing an array with the parameters
    used to invoke the constructor; for a default constructor, this object can be
    `null.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating an instance of a type, we can invoke its members using instances
    of `PropertyInfo`, `MethodInfo`, and so on. For instance, in the previous example,
    we first retrieve an instance of `PropertyInfo` for the property called `Status`
    and then the value of the property by calling `GetValue()` and passing the engine
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we use `GetMethod()` to retrieve an instance of `MethodInfo` with
    information about the method called `Start()` and then invoke it by calling `Invoke()`.
    This method takes a reference to the object and an array of objects representing
    the arguments; since the `Start()` method has no parameters, `null` is used here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Assembly.CreateInstance()` method has a lot of parameters and can be cumbersome
    to use. Alternatively, a simpler way to create instances of types at runtime is
    provided by the `System.Activator` class. It has an overloaded `CreateInstance()`
    method. This is actually used under the hood by `Assembly.CreateInstance()`. In
    its simplest form, it only takes `Type` and an array of objects representing constructor
    arguments and instantiates an object of that type. An example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Activator.CreateInstance()` is not only simpler to use but can provide benefits
    in some scenarios. For instance, it can create objects in other app domains or
    on another server using Remoting. On the other hand, `Assembly.CreateIntance()`
    will not attempt to load the assembly if it is not already loaded, while `System.Activator`
    will load the assembly into the current app domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Using late binding and invoking code in the manner shown earlier is not necessarily
    practical. In practice, when building an extensible system, you will probably
    have one or more assemblies with interfaces and common types that add-ons (or
    plugins, depending on how you want to call them) rely upon. You will early-bind
    to these base assemblies and then use late binding with the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this, we will demonstrate it with the following example.
    `EngineLibBase` is an assembly that defines an interface called `IEngine` and
    the `EngineStatus` enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This assembly is directly referenced in the `EngineLib` assembly, which provides
    the `Engine` class that implements the `IEngine` interface. This is shown in the
    example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our application, where we instantiated the `Engine` class, we again reference
    the `EngineLibBase` assembly so that we can use the `IEngine` interface. After
    loading the `EngineLib` assembly at runtime, we instantiate an object of the `Engine`
    class and cast it to the `IEngine` interface, which makes it possible to access
    the members of the interface at compile time, even though the actual instance
    is not known until at runtime. This is shown in the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we will see further on in this chapter, this is not the only way to use late
    binding and execute code dynamically at runtime. The other possibility is using
    the DLR and the `dynamic` type. We will look at this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dynamic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have talked about the **CLR**. .NET Framework, however,
    contains another component called the **Dynamic Language Runtime (DLR)**. This
    is another runtime environment that adds a set of services on top of the CLR to
    enable dynamic languages to run on the CLR and to add dynamic features to statically-typed
    languages. C# and Visual Basic are statically-typed languages. By contrast, languages
    such as JavaScript, Python, Ruby, PHP, Smalltalk, Lua, and others are dynamic
    languages. The key characteristic of these languages is that they identify the
    type of an object at runtime and not at compile time as in the case of the statically-typed
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DLR provides C# (and Visual Basic) with dynamic features that enable them
    to interoperate with dynamic languages in a simple manner. As mentioned before,
    the DLR adds a set of services to the CLR. These services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expression trees** are used to present language semantics. These are the
    same expression trees used with LINQ but extended to include control-flow, assignments,
    and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call site caching** is a service that caches information about operations
    and objects (such as the type of an object) so that when the same operation is
    performed again, it can be quickly dispatched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDynamicMetaObjectProvider`, `DynamicMetaObject`, `DynamicObject`, and `ExpandoObject`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DLR provides the infrastructure for the `dynamic` type, introduced in C#
    4\. This is a static type, meaning variables of this type are assigned the `dynamic`
    type at compile time. However, they bypass static type checking. This means that
    the actual type of the object is only known at runtime and the compiler cannot
    know and cannot enforce any checks on operations performed on objects of this
    type. You can actually invoke any methods with any parameters and the compiler
    will not check and complain; however, if the operation is not valid, an exception
    will be thrown at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows several examples of variables of the `dynamic` type.
    Notice that `s` is a string and `l` is `List<int>`. Calling `l.Add()` is a valid
    operation because `List<T>` contains such a method. However, calling `s.Add()`
    is invalid because the `string` type does not have such a method. Therefore, an
    exception of the `RuntimeBinderException` type is thrown at runtime for this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dynamic` type makes it easy to consume objects whose type you do not know
    anything about at compile time. Consider the first example from the previous paragraph,
    where we loaded an assembly using reflection, instantiated an object of the `Engine`
    type and called its methods and properties. That example can be rewritten in a
    simpler way, as follows, using the `dynamic` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An object of the `dynamic` type behaves in many cases as if it had the `object`
    type (except there is no compile-time checking). However, the actual source of
    the object's value is irrelevant. It could be a .NET object, a COM object, an
    HTML DOM object, an object created through reflection, such as in the previous
    example, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of the result of a dynamic operation is also `dynamic` with the exception
    of conversions from `dynamic` to another type and constructor calls that include
    arguments of the `dynamic` type. Implicit conversions from a static type to `dynamic`
    and the other way around are performed. This is shown in the code block here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For static types, the compiler performs overload resolution to figure out what
    is the best match for a function call. Because there is no information about the
    `dynamic` type at compile time, the same cannot be done for methods that have
    at least one argument of the `dynamic` type. Instead, the overload resolution
    is performed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dynamic` type is often used to simplify the consumption of COM objects
    when an interop assembly is not available. The following is an example that creates
    an Excel document with some dummy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What this code does is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It retrieves `System.Type` for the COM object identified by the programmatic
    identifier, `Excel.Application.16`, and creates an instance of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the `Visible` property of the Excel application to `true` so that you
    can see the window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a workbook and adds some data to its active worksheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves the document on a file called `demo.xls`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It closes the workbook and quits the Excel application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will look at how to use attributes with
    reflection services.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes provide meta-information about assemblies, types, and members. This
    meta-information is consumed by the compiler, the CLR, or tools that use reflection
    services to read them. Attributes are actually types that derive from the `System.Attribute`
    abstract class. The .NET frameworks provide a large number of attributes, but
    users can define their own.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are specified in square brackets, such as in `[SerializableAttribute]`.
    The naming convention for attributes is that the type names are always suffixed
    with the word `Attribute`. The C# language provides a syntactic shortcut that
    allows specifying the name of the attribute without the suffix, `Attribute`, such
    as in `[Serializable]`. However, this is only possible as long as the type name
    is properly suffixed according to this convention.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at some widely used system attributes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: System attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET Framework provides hundreds of attributes in different assemblies and
    namespaces. Enumerating them would be not only practically impossible but would
    also make little sense. However, the following table lists several attributes
    that you will often work with; some of them we have already seen in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_11_Table_5_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, it is often necessary or useful to create your own attribute
    classes. In the next section, we will look at user-defined attributes.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create your attributes to mark program elements. What you have to do
    is derive from `System.Attribute` and follow the naming convention of suffixing
    the type with the word `Attribute`. The following is an attribute called `Description`
    that contains a single property, called `Text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This attribute can be used to decorate any program element. In the following
    example, we can see this attribute used on a class, properties, and method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes can have *positional* and *named* parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Positional parameters are defined by the arguments of public instance constructors.
    The arguments of each such constructor define a set of named parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, every non-static public field and property that is read-write
    defines a named parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following sample shows the `Description` attribute introduced earlier,
    modified so that a public property called `Required` is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This property can be used as a named parameter in the declaration of an attribute
    on a program element. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's learn how to use attributes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to use attributes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A program element can be marked with multiple attributes. This can be done
    in two equivalent ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method (which is the most widely used because it is the most descriptive
    and clear) is to declare each attribute separately, inside a pair of square brackets.
    The following example shows how this is done:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative method is to declare multiple attributes inside the same pair
    of square brackets, separated by a comma. The following code is equivalent to
    the earlier one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how to specify an attribute's target in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, an attribute is applied to any program element that it precedes.
    However, it is possible to specify the target, such as a type, a method, and so
    on. This is done by marking the attribute type with another attribute called `AttributeUsage`.
    Apart from specifying the target, this attribute allows specifying whether the
    newly defined attribute can be applied multiple times and whether it can be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modified version of `DescriptionAttribute` indicates that it
    can only be used on classes, structs, methods, properties, and fields. In addition,
    it specifies that the attribute is inherited by derived classes and that it can
    be used multiple times on the same element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As a result of these changes, this attribute can no longer be used for method
    parameters, as shown in an earlier example. That would result in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: The attributes we've used so far target program elements, such as types and
    methods. But assembly-level attributes are also possible. We look at these in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Assembly attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are attributes that can target an assembly and specify information about
    the assembly. This information can be the identity (that is, the name, version,
    and culture) of the assembly, manifest information, the strong name, or others.
    These attributes are specified using the syntax `[assembly : attribute]`. These
    attributes are usually found in the `AssemblyInfo.cs` file generated for every
    .NET Framework project. The following is an example of such attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Attributes are intended for reflection services. Now that we've seen how to
    create and use attributes, let's see how to use them in reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes in reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes have little value by themselves until somebody reflects on them and
    performs specific actions based on the meaning of the attributes and their values.
    The `System.Type` type as well as other types from the `System.Reflection` namespace
    have an overloaded method called `GetCustomAttributes()` that retrieves the attributes
    a particular program element is marked with. One overload takes the type of the
    attribute so that it only returns instances of that type; the other does not and
    returns all the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example retrieves all of the instances of the `Description` attribute,
    first from the `Engine` type and then from all of the properties of the type,
    and displays the description text in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at reflection services, how to load assemblies at
    runtime, and querying meta-information about types. We also learned how to execute
    code dynamically using both system reflection on one hand and the DLR and the
    `dynamic` type on the other hand. The DLR provides dynamic features to C# and
    enables interoperability with dynamic languages in a simple manner. The last topic
    we covered in this chapter was attributes. We learned what the common system attributes
    are and how to create your own types as well as how to use them in reflection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on concurrency and parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the unit of deployment in .NET and what does it contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is reflection? What benefits does it provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What .NET type exposes metadata about types? How can you create an instance
    of this type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between public and private assemblies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In .NET Framework, in what context can an assembly be loaded?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is early binding? What about late binding? What benefits does the latter
    provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Dynamic Language Runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the dynamic type and what are the typical scenarios where it is used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are attributes and how do you specify them in code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create user-defined attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
