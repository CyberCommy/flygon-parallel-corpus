- en: Chapter 22. Particle Systems and Handling Screen Touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have our real-time system that we implemented in the previous chapter
    using a thread. In this chapter, we will create the entities that will exist and
    evolve in this real-time system as if they have a mind of their own.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at how the user can draw these entities to the screen by learning
    how to set up the ability to interact with the screen. This is different than
    interacting with a widget in a UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what is coming up in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom buttons to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the `Particle` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the `ParticleSystem` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling screen touches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by adding a custom UI to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom buttons to the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to let the user control when to start another drawing and clear the
    screen of their previous work. We also need the user to be able to decide whether
    or when to bring the drawing to life. To achieve this, we will add two buttons
    to the screen, one for each of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these new properties to the code after the other properties in the `LiveDrawingView`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We now have two `RectF` instances. These objects hold four `Float` coordinates
    each, one coordinate for each corner of our two proposed buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add an `init` block to the `LiveDrawingView` class and initialize
    the positions when the `LiveDrawingView` instance is first created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have added actual coordinates for the buttons. If you visualize the coordinates
    on screen, then you will see that they are in the top left-hand corner, with the
    pause button just below the reset/clear button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can draw the buttons. Add the following two lines of code to the `draw`
    function of the `LiveDrawingView` class. The preexisting comment shows exactly
    where the new highlighted code should go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The new code uses an overridden version of the `drawRect` function, and we simply
    pass our two `RectF` instances straight in alongside the usual `Paint` instance.
    Our buttons will now appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how the user can interact with these slightly crude buttons later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a particle system effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particle system is a system that controls particles. In our case, `ParticleSystem`
    is a class we will write that will spawn instances (lots of instances) of the
    `Particle` class (also a class we will write) that together will create a simple
    explosion-like effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of some particles controlled by a particle system as it
    may appear by the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a particle system effect](img/B12806_22_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just for clarification, each of the colored squares is an instance of the `Particle`
    class, and all the `Particle` instances are controlled and held by the `ParticleSystem`
    class. In addition, the user will create multiple (hundreds) of `ParticleSystem`
    instances by drawing with their finger. The particle systems will appear as dots
    or blocks until the user taps the Pause button and they come to life. We will
    examine the code closely enough that you will be able to amend in code the size,
    color, speed, and quantities of `Particle` and `ParticleSystem` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is left as an exercise for the reader to add additional buttons to the screen
    to allow the user to change these properties as a feature of the app.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by coding the `Particle` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Particle class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the `import` statement, the member variables, the constructor, and the
    `init` block shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two properties—one for velocity and one for position. They are both
    `PointF` objects. `PointF` holds two `Float` values. The position of a particle
    is simple: it is just a horizontal and vertical value. The velocity is worth explaining
    a little more. Each of the two values in the `velocity` object `PointF` will be
    a speed, one horizontal and the other vertical. It is the combination of these
    two speeds that will create a direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following `update` function; we will look at it in more detail
    in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each `Particle` instance's `update` function will be called for each frame of
    the app by the `ParticleSystem` object's `update` function, which, in turn, will
    be called by the `LiveDrawingView` class (again in the `update` function), which
    we will code later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `update` function, the horizontal and vertical values of `position`
    are updated using the corresponding values of `velocity`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we don't bother using the current frame rate in the update. You could
    amend this if you want to be certain that your particles will all fly at exactly
    the correct speed, but all the speeds are going to be random anyway. There is
    not much to gain from adding this extra calculation (for every particle). As we
    will soon see, however, the `ParticleSystem` class will need to take account of
    the current number of frames per second to measure how long it should run for.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move on to the `ParticleSysytem` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ParticleSystem class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ParticleSystem` class has a few more details than the `Particle` class,
    but it is still reasonably straightforward. Remember what we need to achieve with
    this class: hold, spawn, update, and draw a bunch (quite a big bunch) of `Particle`
    instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following constructor, properties, and import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have four properties: first, a `Float` called `duration` that will be initialized
    to the number of seconds we want the effect to run for; the `ArrayList` instance
    called `particles`, holds `Particle` instances and will hold all the `Particle`
    objects we instantiate for this system.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Random` instance called `random` is created because we need to generate
    so many random values that creating a new object each time would slow us down
    a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Boolean` called `isRunning` will track whether the particle system
    is currently being shown (updating and drawing).
  prefs: []
  type: TYPE_NORMAL
- en: Now we can code the `initParticles` function. This function will be called each
    time we want a new `ParticleSystem`. Note that the one and only parameter is an
    `Int` called `numParticles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `initParticles`, we can have some fun initializing crazy amounts
    of particles. Add the `initParticles` function as follows and then we will look
    more closely at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `initParticles` function consists of just one `for` loop that does all the
    work. The `for` loop runs from zero to `numParticles`.
  prefs: []
  type: TYPE_NORMAL
- en: First, a random number between 0 and 359 is generated and stored in `Float angle`.
    Next, there is a little bit of math where we multiply `angle` by `3.14/180`. This
    turns the angle in degrees to radian-based measurements, which are required by
    the `Math` class that we will use in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Then we generate another random number between 1 and 10 and assign the result
    to a `Float` variable called `speed`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that I have added comments to suggest different options for values in this
    part of the code. I do this in several places in the `ParticleSystem` class, and
    when we get to the end of the chapter, we will have some fun altering these values
    and see what effect this has on the drawing app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a random angle and speed, we can convert and combine them into
    a vector that can be used inside the `update` function in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A vector is a value that determines both the direction and speed. Our vector
    is stored in the `direction` object until it is passed into the `Particle` constructor.
    Vectors can be of many dimensions. Ours consists of two dimensions, and therefore
    defines a heading between 0 and 359 degrees and a speed between 1 and 10\. You
    can read more about vectors, headings, sine and cosine on my website at [http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/).
  prefs: []
  type: TYPE_NORMAL
- en: 'I have decided not to explain the single line of code that uses `Math.sin`
    and `Math.cos` to create a vector in full because the magic occurs partly in the
    following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: Cosine of an angle x `speed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sine of an angle x `speed`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the magic takes place in the hidden calculations within the cosine
    and sine functions provided by the `Math` class. If you want to know their full
    details, then you can look at the previous tip.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a new `Particle` is created and then added to the `particles ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will code the `update` function. Note that the `update` function needs
    the current frame rate as a parameter. Code the `update` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that happens inside the `update` function is that the elapsed
    time is taken off `duration`. Remember that `fps` means frames per second, so
    `1/fps` gives a value of a fraction of a second.
  prefs: []
  type: TYPE_NORMAL
- en: Next, there is a `for` loop, which calls the `update` function for every `Particle`
    instance in the `particles` `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code checks whether the particle effect has run its course with
    `if(duration < 0)` and if it has then `isRunning` is set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can code the `emitParticles` function, which will set each `Particle`
    instance running, and which is not to be confused with `initParticles`, which
    creates all the new particles and gives them their velocities. The `initParticles`
    function will be called once before the user gets to interact with the screen,
    whereas the `emitParticles` function will be called each time the effect needs
    to be started as the user draws on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `emitParticles` function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, note that a `PointF` where all the particles will start is passed in
    as a parameter. All the particles will start at the same position and then fan
    out every frame, based on their individual random velocities.
  prefs: []
  type: TYPE_NORMAL
- en: The `isRunning` `Boolean` is set to `true` and `duration` is set to `30f`, so
    the effect will run for 30 seconds and the `for` loop will set the position of
    every particle to the starting coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The final function for our `ParticleSysytem` is the `draw` function, which will
    reveal the effect in all its glory. The function receives a reference to `Canvas`
    and `Paint` so it can draw to the same `Canvas` instance that `LiveDrawingView`
    has just locked in its `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `draw` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a `for` loop steps through each of the `Particle` instances
    in `particles`. Each `Particle`, in turn, is drawn using `drawRect` after the
    size and color of the rectangle are set.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note again how I have suggested different options for code changes so that we
    can have some fun when we have finished coding.
  prefs: []
  type: TYPE_NORMAL
- en: We can now start to put the particle system to work.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning particle systems in the LiveDrawingView class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add an `ArrayList` instance full of systems and some more members to keep track
    of things. Add the highlighted code in the following code to the positions indicated
    by the existing comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can now keep track of up to 1,000 particle systems with 100 particles in
    each. Feel free to play with these numbers. On a modern device, you can run particles
    into the millions without any trouble, but on the emulator, it will begin to struggle
    with just a few hundred thousand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the systems in the `init` block by adding the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code loops through the `ArrayList`, calling the constructor followed by
    `initParticles` on each of the `ParticleSystem` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can update the systems on each frame of the loop by adding the highlighted
    code to the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous code loops through each of the `ParticleSystem` instances, first
    checking whether they are active and then calling the `update` function and passing
    in the current frames per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can draw the systems in each frame of the loop by adding the highlighted
    code in the following snippet to the `draw` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous code loops through `particleSystems`, calling the `draw` function
    on each. Of course, we haven't actually spawned any instances yet; for that, we
    will need to learn how to respond to screen interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling touches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with screen interaction, add the `OnTouchEvent` function to
    the `LiveDrawingView` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is an overridden function, and it is called by Android every time the user
    interacts with the screen. Look at the one and only parameter of `onTouchEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that `motionEvent` has a whole bunch of data tucked away inside
    it, and this data contains the details of the touch that just occurred. The operating
    system sent it to us because it knows we will probably need some of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that I said *some of it*. The `MotionEvent` class is quite extensive; it
    contains within it dozens of functions and properties.
  prefs: []
  type: TYPE_NORMAL
- en: For now, all we need to know is that the screen responds at the precise moment
    that the player's finger moves, touches the screen, or is removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the variables and functions contained within `motionEvent` that we
    will use include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `action` property, which, unsurprisingly, holds the action that was performed.
    Unfortunately, it supplies this information in a slightly encoded format, which
    explains the need for some of these other variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ACTION_MASK` variable, which provides a value known as a mask, which, with
    the help of a little bit more Kotlin trickery, can be used to filter the data
    from `action`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ACTION_UP` variable, which we can use to see whether the action performed
    (such as removing a finger) is the one we want to respond to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ACTION_DOWN` variable, which we can use to see whether the action performed
    is the one we want to respond to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ACTION_MOVE` variable, which we can use to see whether the action performed
    is a move/drag action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `x` property holds a horizontal floating-point coordinate where the event
    happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `y` property holds a vertical floating-point coordinate where the event
    happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a specific example, say we need to filter the data in `action` using `ACTION_MASK`
    and see whether the result is the same as `ACTION_UP`. If it is, then we know
    that the user has just removed their finger from the screen, perhaps because they
    just tapped a button. Once we are sure that the event is of the correct type,
    we will need to find out where it happened using `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one final complication. The Kotlin trickery I referred to is the `&`
    bitwise operator, not to be confused with the logical `&&` operator we have been
    using in conjunction with the `if` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `&` bitwise operator checks to see whether each corresponding part in two
    values is true. This is the filter that is required when using `ACTION_MASK` with
    `action`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sanity check: I was hesitant to go into detail about `MotionEvent` and bitwise
    operators. It is possible to complete this entire book and even make a professional-quality
    interactive app without ever needing to fully understand them. If you know that
    the line of code we will write in the next section determines the event type the
    player triggers, then that is all you need to know. I just thought that a discerning
    reader such as your would like to know the ins and outs of how the system works.
    In summary, if you understand bitwise operators, then great; you are good to go.
    If you don''t, it doesn''t matter; you are still good to go. If you are curious
    about bitwise operators (there are quite a few), you can read more about them
    at [https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation).'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can code the `onTouchEvent` function and see all the `MotionEvent` stuff
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the onTouchEvent function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Respond to the user moving their finger on the screen by adding the highlighted
    code in the following snippet inside the `onTouchEvent` function to the code we
    already have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `if` condition checks to see whether the type of event was the user moving
    their finger. If it was, then the next particle system in `particleSystems` has
    its `emitParticles` function called. Afterward, the `nextSystem` variable is incremented
    and a test is performed to see whether it was the last particle system. If it
    was, then `nextSystem` is set to zero, ready to start reusing existing particle
    systems the next time one is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can move on to making the system respond to the user pressing one of the
    buttons by adding the highlighted code in the following snippet right after the
    previous code we just discussed and before the `return` statement we have already
    coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The condition of the `if` statement checks to see whether the user has tapped
    the screen. If they have, then the `contains` function of the `RectF` class is
    used in conjunction with `x` and `y` to see whether that press was inside one
    of our custom buttons. If the reset button was pressed, then all the particles
    will disappear when `nextSystem` is set to zero. If the paused button is pressed,
    then the value of `paused` is toggled causing the `update` function to stop/start
    being called inside the thread.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the HUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the code in the `printDebuggingText` function to appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will just print some interesting statistics to the screen
    to tell us how many particles and systems are currently being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we get to see the live drawing app in action and play with some of the different
    options we left commented out in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app with small, round, colorful, fast particles. The following screenshot
    shows a screen that has been tapped in several places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_22_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then resume the drawing, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_22_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Make a kid-style drawing with particles that are small, white, square, slow,
    and of a long duration, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_22_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then resume the drawing and wait for 20 seconds while the drawing comes to
    life and changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_22_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how we can add thousands of self-contained entities
    to our real-time system. The entities were controlled by the `ParticleSystem`
    class, which, in turn, interacted with, and was controlled by, the game loop.
    As the game loop was running in a thread, we learned that the user can still interact
    seamlessly with the screen and the operating system will send us the details of
    these interactions via the `onTouchEvent` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, our apps will finally get a bit noisier when we explore
    how to play sound effects.
  prefs: []
  type: TYPE_NORMAL
