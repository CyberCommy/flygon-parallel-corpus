- en: Getting Started with REST API Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web service is a communication mechanism defined between different computer
    systems. Without web services, custom peer-to-peer communication becomes cumbersome
    and platform specific. It is like a hundred different kinds of things that the
    web needs to understand and interpret. If computer systems align with the protocols
    that the web can understand easily, it is a great help.
  prefs: []
  type: TYPE_NORMAL
- en: A web service is a software system designed to support interoperable machine-to-machine
    interaction over a network, **World Wide Web Consortium** (**W3C**), [https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, in simple words, a web service is a road between two endpoints where messages
    are transferred smoothly. Here, this transfer is usually one way. Two individual
    programmable entities can also communicate with each other through their own APIs.
    Two people communicate through language. Two applications communicate through
    the **Application Programming Interface **(**API**).
  prefs: []
  type: TYPE_NORMAL
- en: The reader might be wondering; what is the importance of the API in the current
    digital world? The rise of the **Internet of Things **(**IoT**) made API usage
    heavier than before. Consciousness about the API is growing day by day, and there
    are hundreds of APIs that are being developed and documented all over the world
    every day. Notable major businesses are seeing futures in the **API as a Service**
    (**AAAS**). A bright example is **Amazon Web Services** (**AWS**). It is a huge
    success in the cloud world. Developers write their own applications using the
    REST API provided by the AWS.
  prefs: []
  type: TYPE_NORMAL
- en: A few more hidden use cases are from travel sites like Ibibo and Expedia, which
    fetch real-time prices by calling the APIs of third-party gateways and data vendors.
    Web services are often charged these days.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics to be covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: The different Web Services available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representational State Transfer (REST) architecture in detail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Single Page Applications (SPA) with REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Go project and running a development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our first service for finding Roman numerals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Gulp to auto-compile Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of web services which have evolved over time. Prominent
    ones are :'
  prefs: []
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UDDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WSDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of these, **SOAP** became popular in the early 2000s, when XML was on the
    top wave. The XML data format is used by various distributed systems to communicate
    with each other. SOAP is too complex to implement. Criticizers of SOAP point out
    how bulky the SOAP HTTP request is.
  prefs: []
  type: TYPE_NORMAL
- en: 'A SOAP request usually consists of these three basic components:'
  prefs: []
  type: TYPE_NORMAL
- en: Envelope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just to perform an HTTP request and response cycle, we have to attach a lot
    of additional data in SOAP. A sample SOAP request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard example of SOAP from the W3C standard ([https://www.w3.org/TR/2000/NOTE-SOAP-20000508/](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/)).
    If we observe carefully, it is in XML format, with special tags specifying the
    envelope and body. Since XML operates on a lot of namespaces to function, additional
    information comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name **Representational state transfer** (**REST**) was coined by Roy Fielding
    from the University of California. It is a very simplified and lightweight web
    service compared to SOAP. Performance, scalability, simplicity, portability, and
    modifiability are the main principles behind the REST design.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API allows different systems to communicate and send/receive data in
    a very simple way. Each and every REST API call has a relation between an HTTP
    verb and the URL. The resources in the database in an application can be mapped
    with an API endpoint in the REST.
  prefs: []
  type: TYPE_NORMAL
- en: When you are using a mobile app on your phone, your phone might be secretly
    talking to many cloud services to retrieve, update, or delete your data. REST
    services have a huge impact on our daily lives.
  prefs: []
  type: TYPE_NORMAL
- en: REST is a stateless, cacheable, and simple architecture that is not a protocol
    but a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the main properties that make REST simple and unique compared to
    its predecessors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server based architecture:** This architecture is most essential for
    the modern web to communicate over HTTP. A single client-server may look naive
    initially, but many hybrid architectures are evolving. We will discuss more of
    these shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless:** This is the most important characteristic of a REST service.
    A REST HTTP request consists of all the data needed by the server to understand
    and give back the response. Once a request is served, the server doesn''t remember
    if the request has arrived after a while. So the operation will be a stateless
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Many developers think a technology stack is blocking their web
    application or API. But in reality, their architecture is the reason. The database
    can be a potential tuning piece in a web application. In order to scale an application
    well, we need to cache content and deliver it as a response. If the cache is not
    valid, it is our responsibility to bust it. REST services should be properly cached
    for scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripts on demand:** Have you ever designed a REST service which serves the
    JavaScript files and you execute them on the fly? This code on demand is also
    the main characteristic REST can provide. It is more common to request scripts
    and data from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple layered system:** The REST API can be served from multiple servers.
    One server can request the other, and so forth. So when a request comes from the
    client, request and response can be passed between many servers to finally supply
    a response back to the client. This easily implementable multi-layered system
    is always a good strategy for keeping the web application loosely coupled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representation of resources:** The REST API provides the uniform interface
    to talk to. It uses a **Uniform Resource Identifier** (**URI**) to map the resources
    (data). It also has the advantage of requesting a specific data format as the
    response. The Internet Media Type(MIME type) can tell the server that the requested
    resource is of that particular type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementational freedom:** REST is just a mechanism to define your web services.
    It is an architectural style that can be implemented in multiple ways. Because
    of this flexibility, you can create REST services in the way you wish to. Until
    it follows the principles of REST, your server has the freedom to choose the platform
    or technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thoughtful caching is essential for the REST services to scale.
  prefs: []
  type: TYPE_NORMAL
- en: REST verbs and status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST verbs specify an action to be performed on a specific resource or a collection
    of resources. When a request is made by the client, it should send this information
    in the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: REST verb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned previously, REST uses the URI to decode its resource to be
    handled. There are quite a few REST verbs available, but six of them are used
    frequently. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are a software developer, you will be dealing with these six most of
    the time. The following table explains the operation, target resource, and what
    happens if the request succeeds or fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **REST Verb** | **Action** | **Success** | **Failure** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Fetches a record or set of resources from the server | 200 | 404
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Fetches all available REST operations  | 200 | - |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Creates a new set of resources or a resource | 201 | 404, 409 |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Updates or replaces the given record | 200, 204 | 404 |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Modifies the given record | 200, 204 | 404 |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Deletes the given resource  | 200 | 404 |'
  prefs: []
  type: TYPE_TB
- en: The numbers in the **Success** and **Failure** columns of the preceding table
    are HTTP status codes. Whenever a client initiates a REST operation, since REST
    is stateless, the client should know a way to find out whether the operation was
    successful or not. For that reason, HTTP has status codes for the response. REST
    defines the preceding status code types for a given operation. This means a REST
    API should strictly follow the preceding rules to achieve client-server communication.
  prefs: []
  type: TYPE_NORMAL
- en: All defined REST services have the following format. It consists of the host
    and API endpoint. The API endpoint is the URL path which is predefined by the
    server. Every REST request should hit that path.
  prefs: []
  type: TYPE_NORMAL
- en: A trivial REST API URI: `http://HostName/API endpoint/Query(optional)`
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at all the verbs in more detail. The REST API design starts with
    the defining of operations and API endpoints. Before implementing the API, the
    design document should list all the endpoints for the given resources. In the
    following section, we carefully observe the REST API endpoints using PayPal's
    REST API as a use case.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `GET` method fetches the given resource from the server. To specify a resource,
    `GET` uses a few types of URI queries:'
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path-based parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you didn't know, all of your browsing of the web is done by performing
    a `GET` request to the server. For example, if you type [www.google.com](http://www.google.com),
    you are actually making a `GET` request to fetch the search page. Here, your browser
    is the client and Google's web server is the backend implementer of web services.
    A successful `GET` operation returns a 200 status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of path parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone knows **PayPal**. PayPal creates billing agreements with companies.
    If you register with PayPal for a payment system, they provide you with a REST
    API for all your billing needs. The sample `GET` request for getting the information
    of a billing agreement looks like this: `/v1/payments/billing-agreements/agreement_id`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the resource query is with the path parameter. When the server sees this
    line, it interprets it as *I got an HTTP request with a need for agreement_id
    from the billing agreements*. Then it searches through the database, goes to the
    `billing-agreements` table, and finds an agreement with the given `agreement_id`.
    If that resource exists it sends the details to copy back in response (200 OK).
    Or else it sends a response saying resource not found (404).
  prefs: []
  type: TYPE_NORMAL
- en: Using `GET`, you can also query a list of resources, instead of a single one
    like the preceding example. PayPal's API for getting billing transactions related
    to an agreement can be fetched with `/v1/payments/billing-agreements/transactions`.
    This line fetches all transactions that occurred on that billing agreement. In
    both, the case's data is retrieved in the form of a JSON response. The response
    format should be designed beforehand so that the client can consume it in the
    agreement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of query parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Query parameters are intended to add detailed information to identify a resource
    from the server. For example, take this sample fictitious API. Let us assume this
    API is created for fetching, creating, and updating the details of the book. A
    query parameter based `GET` request will be in this format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding URI has few query parameters. The URI is requesting a book from
    the book''s resource that satisfies the following conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be a fiction book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book should have been published in the year 2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Get all the fiction books that are released in the year 2017* is the question
    the client is posing to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Path vs Query parameters—When to use them? It is a common rule of thumb that
    `Query` parameters are used to fetch multiple resources based on the query parameters.
    If a client needs a single resource with exact URI information, it can use `Path`
    parameters to specify the resource. For example, a user dashboard can be requested
    with `Path` parameters and fetch data on filtering can be modeled with `Query`
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Use `Path` parameters for a single resource and `Query` parameters for multiple
    resources in a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: POST, PUT, and PATCH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `POST` method is used to create a resource on the server. In the previous
    book's API, this operation creates a new book with the given details. A successful
    `POST` operation returns a 201 status code. The `POST` request can update multiple
    resources: `/v1/books`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` request has a body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This actually creates a new book in the database. An ID is assigned to this
    record so that when we `GET` the resource, the URL is created. So `POST` should
    be done only once, in the beginning. In fact, *Lord of the Rings* was published
    in 1955\. So we entered the published date incorrectly. In order to update the
    resource, let us use the `PUT` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PUT` method is similar to `POST.` It is used to replace the resource that
    already exists. The main difference is that `PUT` is idempotent. A `POST` call
    creates two instances with the same data. But `PUT` updates a single resource
    that already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'with body that is JSON like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`1256` is the ID of the book. It updates the preceding book by `year:1955`.
    Did you observe the drawback of `PUT`? It actually replaced the entire old record
    with the new one. We needed to change a single column. But `PUT` replaced the
    whole record. That is bad. For this reason, the `PATCH` request was introduced.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PATCH` method is similar to `PUT`, except it won''t replace the whole
    record. `PATCH`, as the name suggests, patches the column that is being modified.
    Let us update the book `1256` with a new column called `ISBN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'with the JSON body like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It tells the server, *Search for the book with id 1256\. Then add/modify this
    column with the given value*.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` and `PATCH` both return the 200 status for success and 404 for not found.'
  prefs: []
  type: TYPE_NORMAL
- en: DELETE and OPTIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DELETE` API method is used to delete a resource from the database. It is
    similar to `PUT` but without any body. It just needs an ID of the resource to
    be deleted. Once a resource gets deleted, subsequent `GET` requests return a 404
    not found status.
  prefs: []
  type: TYPE_NORMAL
- en: Responses to this method are *not cacheable* (in case caching is implemented)
    because the `DELETE` method is idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: The `OPTIONS` API method is the most underrated in the API development. Given
    the resource, this method tries to know all possible methods (`GET`, `POST`, and
    so on) defined on the server. It is like looking at the menu card at a restaurant
    and then ordering an item which is available (whereas if you randomly order a
    dish, the waiter will tell you it is not available). It is best practice to implement
    the `OPTIONS` method on the server. From the client, make sure `OPTIONS` is called
    first, and if the method is available, then proceed with it.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important application of this `OPTIONS` method is **Cross-Origin Resource
    Sharing** (**CORS**). Initially, browser security prevented the client from making
    cross-origin requests. It means a site loaded with the URL [www.foo.com](http://www.foo.com)
    can only make API calls to that host. If the client code needs to request files
    or data from [www.bar.com](http://www.bar.com), then the second server, [bar.com,](https://bar.com/)
    should have a mechanism to recognize [foo.com](http://foo.com) to get its resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process explains the CORS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[foo.com](http://foo.com) requests the `OPTIONS` method on [bar.com](http://bar.com).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[bar.com](http://bar.com) sends a header like `Access-Control-Allow-Origin:
    http://foo.com` in response to the client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, [foo.com](http://foo.com) can access the resources on [bar.com](https://bar.com/)
    without any restrictions that call any `REST` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If [bar.com](http://bar.com) feels like supplying resources to any host after
    one initial request, it can set Access control to * (that is, any).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the diagram depicting the process happening one after the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32a06a64-3c6b-4f5d-90da-8c4745a520a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Types of status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few families of status codes. Each family globally explains an operation
    status. Each member of that family may have a deeper meeting. So a REST API should
    strictly tell the client what exactly happened after the operation. There are
    60+ status codes available. But for REST, we concentrate on a few families of
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: 2xx family (successful)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '200 and 201 fall under the success family. They indicate that an operation
    was successful. Plain **200** (**Operation Successful**) is a successful CRUD
    Operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200** (**Successful Operation**) is the most common type of response status
    code in REST'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201** (**Successfully Created**)is returned when a `POST` operation successfully
    creates a resource on the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204** (**No content**) is issued when a client needs a status but not any
    data back'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3xx family (redirection)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These status codes are used to convey redirection messages. The most important
    ones are **301** and **304**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**301** is issued when a resource is moved permanently to a new URL endpoint.
    It is essential when an old API is deprecated. It returns the new endpoint in
    the response with the 301 status. By seeing that, the client should use the new
    URL in response to achieving its target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **304** status code indicates that content is cached and no modification
    happened for the resource on the server. This helps in caching content at the
    client and only requests data when the cache is modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4xx family (client error)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the standard error status codes which the client needs to interpret
    and handle further actions. These have nothing to do with the server. A wrong
    request format or ill-formed REST method can cause these errors. Of these, the
    most frequent status codes API developers use are **400**, **401**, **403**, **404**,
    and **405**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**400** (**Bad Request**) is returned when the server cannot understand the
    client request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401** (**Unauthorized**) is returned when the client is not sending the authorization
    information in the header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403** (**Forbidden**) is returned when the client has no access to a certain
    type of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404** (**Not Found**) is returned when the client request is on a resource
    that is nonexisting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**405** (**Method Not Allowed**) is returned if the server bans a few methods
    on resources. `GET` and `HEAD` are exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5xx family (server error)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the errors from the server. The client request may be perfect, but
    due to a bug in the server code, these errors can arise. The commonly used status
    codes are **500**, **501**, **502**, **503**,  and **504**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**500** (**Internal Server Error**) status code gives the development error
    which is caused by some buggy code or some unexpected condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**501** (**Not Implemented**) is returned when the server is no longer supporting
    the method on a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**502** (**Bad Gateway**) is returned when the server itself got an error response
    from another service vendor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**503** (**Service Unavailable**) is returned when the server is down due to
    multiple reasons, like a heavy load or for maintenance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**504** (**Gateway Timeout**) is returned when the server is waiting a long
    time for a response from another vendor and is taking too much time to serve the
    client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on status codes, visit this link: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
  prefs: []
  type: TYPE_NORMAL
- en: Rise of REST API with Single Page Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to understand why **Single Page Applications **(**SPA**) are the hot
    topic today. Instead of building the UI in a traditional way (request web pages),
    these SPA designs make developers write code in a totally different way. There
    are many MVC frameworks, like AngularJS, Angular2, React JS, Knockout JS, Aurelia,
    and so on, to develop web UIs rapidly, but the essence of each of them is pretty
    simple. All MVC frameworks help us to implement one design pattern. That design
    pattern is *No requesting of web pages, only REST API.*
  prefs: []
  type: TYPE_NORMAL
- en: The modern web frontend development has advanced a lot since 2010\. In order
    to exploit the features of** Model-View-Controller** (**MVC**) architecture, we
    need to consider the frontend as a separate entity which talks to the backend
    only using the REST API (most preferably, REST JSON).
  prefs: []
  type: TYPE_NORMAL
- en: Old and new ways of data flow in SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All websites go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Request a web page from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticate and show the Dashboard UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the user to modify and save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request as many web pages from the server as needed to show individual pages
    on the site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But in the SPA, the flow is quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the HTML template/s to the browser in one single go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, query the JSON REST API to fill a model (data object).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the UI according to the data in the model (JSON).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When users modify the UI, the model (data object) should change automatically.
    For example, in AngularJS, it is possible with two-way data binding. Finally,
    make REST API calls to notify the server about changes whenever you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this way, communication happens only in the form of the REST API. The client
    takes care of logically representing the data. This causes systems to move from
    **Response Oriented Architecture** (**ROA**) to **Service Oriented Architecture**
    (**SOA**). Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19a08895-c507-4a77-b9f1-830361ac0668.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: SPA reduces the bandwidth and improves the site performance.
  prefs: []
  type: TYPE_NORMAL
- en: Why Go for REST API development?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services are trivial in the modern web. SOA (which we discuss in more detail
    later) created an activity space for REST services to take web development to
    the next level. **Go** is a programming language from the house of Google for
    solving the bigger problems they have. It has been eight-plus years since its
    first appearance. It matured along the way with a developer community jumping
    in and creating huge scale systems in it.
  prefs: []
  type: TYPE_NORMAL
- en: Go is the darling of the web. It solves bigger problems in an easy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'One can choose Python or JavaScript (Node) for their REST API development.
    The main advantage of Go lies in its speed and compile-time error detection. Go
    is proved to be faster than dynamic programming languages in terms of computational
    performance by various benchmarks. These are the three reasons why a company should
    write their next API in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: To scale your API for a wider audience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable your developers to build robust systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To invest in the future viability of your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can look at the neverending online debates for more information about REST
    services with Go. In later chapters, we try to build the fundamentals of designing
    and writing the REST services.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and running the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a building series book. It assumes you already know the basics of Go.
    If not, no worries. You can jump start and learn them quickly from Go's official
    site at [https://golang.org/](https://golang.org/). Go uses a different way of
    developing projects. Writing a standalone, simple program doesn't bother you much.
    But after learning the basics, people try to advance a step further. For that
    reason, as a Go developer, you should know how Go projects are laid out and the
    best practices to keep your code clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have done the following things before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Go compiler on your machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `GOROOT` and `GOPATH` environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many online references from which you can get to know the preceding
    details. Depending on your machine type (Windows, Linux, or macOS X), set up a
    working Go compiler. We see more details about `GOPATH` in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying GOPATH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GOPATH` is nothing but the current appointed workspace on your machine. It
    is an environment variable that tells the Go compiler about where your source
    code, binaries, and packages are placed.'
  prefs: []
  type: TYPE_NORMAL
- en: The programmers coming from a Python background may know the Virtualenv tool
    to create multiple projects (with different Python interpreter versions) at the
    same time. But at a given time, one activates the environment and develops his
    project. Similarly,  you can have any number of Go projects on your machine. While
    developing, set the `GOPATH` to one of your projects. The Go compiler now activates
    that project.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a common practice to create a project under the home directory and set
    the `GOPATH` environment variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we install external packages like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Go copies the project called `mux` into the currently activated project `myproject`.
  prefs: []
  type: TYPE_NORMAL
- en: For Go get, use the `-u` flag to install updated dependencies of the external
    package and `-v` to see the verbose details of installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical Go project has the following structure, as mentioned on the official
    Go website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5ae002f-d91f-4d0f-bbb0-e5b366ae3876.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us understand this structure before digging further:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bin`: Stores the binary of our project; a shippable binary which can be run
    directly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pkg`: Contains the package objects; a compiled program which supplies package
    methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: The place for your project source code, tests, and user packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Go, all the packages which you import into your main program have an identical
    structure, `github.com/user/project`. But who creates all these directories? Should
    the developer do that? Nope. It is the developer's responsibility to create directories
    for his/her project. It means he/she only creates the directory `src/github.com/user/hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a developer runs the following command, the directories bin and package
    are created if they did not exist before. `.bin` consists of the binary of our
    project source code and `.pkg` consists of all internal and external packages
    we use in our Go programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Building our first service – finding the Roman numeral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the concepts we have built upto now, let us write our first basic REST
    service. This service takes the number range (1-10) from the client and returns
    its Roman string. Very primitive, but better than Hello World.
  prefs: []
  type: TYPE_NORMAL
- en: '**Design:**'
  prefs: []
  type: TYPE_NORMAL
- en: Our REST API should take an integer number from the client and serve back the
    Roman equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The block of the API design document may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Verb** | **PATH** | **Action** | **Resource** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/roman_number/2` | show | `roman_number` |'
  prefs: []
  type: TYPE_TB
- en: '**Implementation:**'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to implement the preceding simple API step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Code for this project is available at [https://github.com/narenaryan/gorestful](https://github.com/narenaryan/gorestful).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we previously discussed, you should set the `GOPATH` first. Let us assume
    the `GOPATH` is `/home/naren/go`. Create a directory called `romanserver` in the
    following path. Replace *narenaryan* with your GitHub username (this is just a
    namespace for the code belonging to different users):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our project is ready. We don''t have any database configured yet. Create an
    empty file called `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main logic for the API server goes into this file. For now, we can create
    a data file which works as a data service for our main program. Create one more
    directory for packaging the Roman numeral data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an empty file called `data.go` in the `romanNumerals` directory.
     The `src` directory structure so far looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ;![](img/5d36f6b4-c619-4e06-8ddd-9374c32ac864.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us start adding code to the files. Create data for the Roman numerals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are creating a map called **Numerals**. This map holds information for converting
    a given integer to its Roman equivalent. We are going to import this variable
    into our main program to serve the request from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `main.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Always use the Go fmt tool to format your Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Usage example: `go fmt github.com/narenaryan/romanserver`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, install this project with the Go command `install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This step does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiles the package `romanNumerals` and places a copy in the `$GOPATH/pkg`
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Places a binary in the `$GOPATH/bin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can run the preceding API server as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The server is up and running on `http://localhost:8000`. Now we can make a `GET`
    request to the API using a client like `Browser` or the `CURL` command. Let us
    fire a `CURL` command with a proper API `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request one is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let us try a few incorrectly formed requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request two is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Request three is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our little Roman numerals API is doing the right thing. The right status codes
    are being returned. That is the point all API developers should keep in mind.
    The client should be informed why something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just updated the empty files in one single go and started running the server.
    Let me now explain each and every piece of the file `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: Imported a few packages. `github.com/narenaryan/romanNumerals` is the data service
    we created before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http` is the core package we used to handle an HTTP request through its
    `HandleFunc` function. That function''s arguments are `http.Request` and `http.ResponseWriter`.
    Those two deal with the request and response of an HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r.URL.Path` is the URL path of the HTTP request. For the CURL Request one, it
    is `/roman_number/5`*.* We are splitting this path and using the second argument
    as a resource and the third argument as a value to get the Roman numeral. The `Split`
    function is in a core package called `strings`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Atoi` function converts an alphanumeric string to an integer. For the numerals
    map to consume, we need to convert the integer string to an integer. The `Atoi`
    function comes from a core package called `strconv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `http.StatusXXX` to set the status code of the response header. The `WriteHeader`
    and `Write` functions are available on the response object for writing the header
    and body, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we created an HTTP server using `&http` while initializing a few parameters
    like address, port, timeout, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `time` package is used to define seconds in the program. It says, after
    10 seconds of inactivity, automatically return a 408 request timeout back to the
    client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EscapeString` escapes special characters to become valid HTML characters.
    For example, Fran & Freddie''s becomes `Fran &amp; Freddie''s&#34`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, start the server with the****  `ListenAndServe`**** function. It keeps
    your web server running until you kill it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One should write unit tests for their API. In the upcoming chapters, we will
    see how to test an API end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Live reloading the application with supervisord and Gulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gulp is a nice tool for creating workflows. A workflow is a step-by-step process.
    It is nothing but a task streamlining application. You need NPM and Node installed
    on your machine. We use Gulp to watch the files and then update the binary and
    restart the API server. Sounds cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: The supervisor is an application to reload your server whenever the application
    gets killed. A process ID will be assigned to your server. To restart the app
    properly, we need to kill the existing instances and restart the application.
    We can write one such program in Go. But in order to not reinvent the wheel, we
    are using a popular program called supervisord.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring your Go web server with supervisord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes your web application may stop due to operating system restarts or
    crashes. Whenever your web server gets killed, it is supervisor's job to bring
    it back to life. Even the system restart cannot take your web server away from
    the customers. So, strictly use supervisord for your app monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Installing supervisord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily install supervisord on Ubuntu 16.04, with the `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This installs two tools, `supervisor` and `supervisorctl`. `supervisorctl` is
    intended to control the supervisord and add tasks, restart tasks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS X, we can install `supervisor` using the `brew` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a configuration file at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add any number of configuration files, and supervisord treats them
    as separate processes to run. Add the following content to the preceding file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By default, we have a file called `.supervisord.conf` at `/etc/supervisor/`.
    Look at it for more reference. In macOS X, the same file will be located at `/usr/local/etc/supervisord.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to the preceding configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: The `[supervisord]` section tells the location of the log file for supervisord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`[program:myserver]`** is the task block which traverses to the given directory
    and executes the command given'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can ask our `supervisorctl` to re-read the configuration and restart
    the tasks (process). For that, just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '`supervisorctl reread`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`supervisorctl update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, launch `supervisorctl` with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`supervisorctl` is a great tool for controlling supervisor programs.![](img/0719632a-e003-4969-8db2-ab30fffaa133.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Since we named our romanserver `myserver` in the supervisor configuration file,
    we can start, stop, and restart that program from `supervisorctl`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gulp for creating auto code compiling and server reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the little introduction we gave about Gulp in the preceding section, we
    are going to write a gulpfile for telling the computer to execute a few tasks.
  prefs: []
  type: TYPE_NORMAL
- en: I install Gulp and Gulp-shell using `npm`**:**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, create a `gulpfile.js` in the root directory of the project. Here,
    it is `github.com/src/narenaryan/romanserver`. Now add this content to `gulpfile.js`.
    First, whenever a file changes, install binary task gets executed. Then, the supervisor
    will be restarted. The watch task looks for any file change and executes the preceding
    tasks. We are also ordering the tasks so that they occur one after the other synchronously.
    All of these tasks are Gulp tasks and can be defined by the `gulp.task` function.
    It takes two arguments with task name, task. `sell.task` allows Gulp to execute
    system commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the  `gulp` command in the `source` directory, it starts watching
    your source code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we modify the code, then the code is compiled, installed, and the server
    restarted in a flash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b381310c-588c-4a06-af59-74a57019858f.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the gulpfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the gulpfile, we are performing the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Import Gulp and Gulp-shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tasks with `shell.task` as the function to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shell.task` can execute a command-line instruction. Keep your shell commands
    inside that function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a watch task for watching source files. The task list will be executed when
    files are modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a default task for running. Add a watch to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gulp is a great tool for these kinds of use cases. So, please go through the
    official documentation of Gulp at [http://gulpjs.com/](http://gulpjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave an introduction to the REST API. We saw that REST is
    not a protocol, but an architectural pattern. HTTP is the actual protocol on which
    we can implement our REST service. We jumped into the fundamentals of the REST
    API to be clear about what they actually are. Then we explored types of web services.
    Before REST, we have something called SOAP, which uses XML as the data format.
    REST operates on JSON as the primary format. REST has verbs and status codes.
    We saw what a given status code refers to. We built a simple service which serves
    the Roman numerals for given numbers. In this process, we also saw how to package
    a Go project. We understood the GOPATH environment variable. It is a workspace
    defining a variable in Go. All packages and projects reside in that path. We then
    saw how to reload a development project on the fly with the help of supervisord
    and Gulp. These are node tools but can help us to keep our Go project up and running.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we dig deeper into URL routing. Starting from the built-in
    router, we explore Gorilla Mux, a powerful URL routing library.
  prefs: []
  type: TYPE_NORMAL
