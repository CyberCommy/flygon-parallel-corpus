- en: Getting Started with REST API Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用REST API开发
- en: A web service is a communication mechanism defined between different computer
    systems. Without web services, custom peer-to-peer communication becomes cumbersome
    and platform specific. It is like a hundred different kinds of things that the
    web needs to understand and interpret. If computer systems align with the protocols
    that the web can understand easily, it is a great help.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是在不同计算机系统之间定义的通信机制。没有Web服务，自定义的点对点通信变得繁琐且特定于平台。这就像是网络需要理解和解释的一百种不同的东西。如果计算机系统与网络易于理解的协议相一致，那将是一个很大的帮助。
- en: A web service is a software system designed to support interoperable machine-to-machine
    interaction over a network, **World Wide Web Consortium** (**W3C**), [https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务是一种旨在支持网络上可互操作的机器对机器交互的软件系统，**万维网联盟**（**W3C**），[https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/)。
- en: Now, in simple words, a web service is a road between two endpoints where messages
    are transferred smoothly. Here, this transfer is usually one way. Two individual
    programmable entities can also communicate with each other through their own APIs.
    Two people communicate through language. Two applications communicate through
    the **Application Programming Interface **(**API**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，简单来说，Web服务是两个端点之间的通路，消息可以顺利传输。在这里，这种传输通常是单向的。两个独立的可编程实体也可以通过它们自己的API相互通信。两个人通过语言进行交流。两个应用程序通过**应用程序编程接口**（**API**）进行通信。
- en: The reader might be wondering; what is the importance of the API in the current
    digital world? The rise of the **Internet of Things **(**IoT**) made API usage
    heavier than before. Consciousness about the API is growing day by day, and there
    are hundreds of APIs that are being developed and documented all over the world
    every day. Notable major businesses are seeing futures in the **API as a Service**
    (**AAAS**). A bright example is **Amazon Web Services** (**AWS**). It is a huge
    success in the cloud world. Developers write their own applications using the
    REST API provided by the AWS.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会想知道，在当前数字世界中API的重要性是什么？**物联网**（**IoT**）的兴起使API的使用比以往更加重要。对API的认识日益增长，每天都有数百个API在全球各地被开发和记录。一些重要的大型企业正在看到**作为服务的API**（**AAAS**）的未来。一个明显的例子是**亚马逊网络服务**（**AWS**）。它在云世界取得了巨大的成功。开发人员使用AWS提供的REST
    API编写自己的应用程序。
- en: A few more hidden use cases are from travel sites like Ibibo and Expedia, which
    fetch real-time prices by calling the APIs of third-party gateways and data vendors.
    Web services are often charged these days.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更隐秘的用例来自像Ibibo和Expedia这样的旅行网站，它们通过调用第三方网关和数据供应商的API来获取实时价格。如今，Web服务通常会收费。
- en: 'Topics to be covered in this chapter are:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题包括：
- en: The different Web Services available
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同Web服务
- en: Representational State Transfer (REST) architecture in detail
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍表现状态转移（REST）架构
- en: Introduction to Single Page Applications (SPA) with REST
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍使用REST构建单页应用程序（SPA）
- en: Setting up a Go project and running a development server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Go项目并运行开发服务器
- en: Building our first service for finding Roman numerals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为查找罗马数字构建我们的第一个服务
- en: Using Gulp to auto-compile Go code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gulp自动编译Go代码
- en: Types of web services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务的类型
- en: 'There are many types of web services which have evolved over time. Prominent
    ones are :'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，出现了许多类型的Web服务。其中一些主要的是：
- en: SOAP
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP
- en: UDDI
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDDI
- en: WSDL
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WSDL
- en: REST
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: Out of these, **SOAP** became popular in the early 2000s, when XML was on the
    top wave. The XML data format is used by various distributed systems to communicate
    with each other. SOAP is too complex to implement. Criticizers of SOAP point out
    how bulky the SOAP HTTP request is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，**SOAP**在2000年代初变得流行，当时XML处于风口浪尖。各种分布式系统使用XML数据格式进行通信。SOAP的实现过于复杂。SOAP的批评者指出了SOAP
    HTTP请求的臃肿。
- en: 'A SOAP request usually consists of these three basic components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP请求通常由以下三个基本组件组成：
- en: Envelope
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信封
- en: Header
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部
- en: Body
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: 'Just to perform an HTTP request and response cycle, we have to attach a lot
    of additional data in SOAP. A sample SOAP request looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅执行一个HTTP请求和响应周期，我们就必须在SOAP中附加大量额外的数据。一个示例SOAP请求如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a standard example of SOAP from the W3C standard ([https://www.w3.org/TR/2000/NOTE-SOAP-20000508/](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/)).
    If we observe carefully, it is in XML format, with special tags specifying the
    envelope and body. Since XML operates on a lot of namespaces to function, additional
    information comes into play.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自W3C标准的SOAP的标准示例（[https://www.w3.org/TR/2000/NOTE-SOAP-20000508/](https://www.w3.org/TR/2000/NOTE-SOAP-20000508/)）。如果我们仔细观察，它是以XML格式呈现的，其中特殊标签指定了信封和主体。由于XML操作需要大量的命名空间来运行，额外的信息也会起作用。
- en: REST API
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: The name **Representational state transfer** (**REST**) was coined by Roy Fielding
    from the University of California. It is a very simplified and lightweight web
    service compared to SOAP. Performance, scalability, simplicity, portability, and
    modifiability are the main principles behind the REST design.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**表现状态转移**（**REST**）这个名字是由加利福尼亚大学的Roy Fielding创造的。与SOAP相比，它是一个非常简化和轻量级的Web服务。性能、可伸缩性、简单性、可移植性和可修改性是REST设计的主要原则。'
- en: The REST API allows different systems to communicate and send/receive data in
    a very simple way. Each and every REST API call has a relation between an HTTP
    verb and the URL. The resources in the database in an application can be mapped
    with an API endpoint in the REST.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: REST API允许不同的系统以非常简单的方式进行通信和发送/接收数据。每个REST API调用都与HTTP动词和URL之间存在关系。应用程序中的数据库资源可以与REST中的API端点进行映射。
- en: When you are using a mobile app on your phone, your phone might be secretly
    talking to many cloud services to retrieve, update, or delete your data. REST
    services have a huge impact on our daily lives.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在手机上使用移动应用时，您的手机可能会秘密地与许多云服务进行通信，以检索、更新或删除您的数据。REST服务对我们的日常生活有着巨大的影响。
- en: REST is a stateless, cacheable, and simple architecture that is not a protocol
    but a pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of REST services
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the main properties that make REST simple and unique compared to
    its predecessors:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-server based architecture:** This architecture is most essential for
    the modern web to communicate over HTTP. A single client-server may look naive
    initially, but many hybrid architectures are evolving. We will discuss more of
    these shortly.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless:** This is the most important characteristic of a REST service.
    A REST HTTP request consists of all the data needed by the server to understand
    and give back the response. Once a request is served, the server doesn''t remember
    if the request has arrived after a while. So the operation will be a stateless
    one.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cacheable**: Many developers think a technology stack is blocking their web
    application or API. But in reality, their architecture is the reason. The database
    can be a potential tuning piece in a web application. In order to scale an application
    well, we need to cache content and deliver it as a response. If the cache is not
    valid, it is our responsibility to bust it. REST services should be properly cached
    for scaling.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripts on demand:** Have you ever designed a REST service which serves the
    JavaScript files and you execute them on the fly? This code on demand is also
    the main characteristic REST can provide. It is more common to request scripts
    and data from the server.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple layered system:** The REST API can be served from multiple servers.
    One server can request the other, and so forth. So when a request comes from the
    client, request and response can be passed between many servers to finally supply
    a response back to the client. This easily implementable multi-layered system
    is always a good strategy for keeping the web application loosely coupled.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Representation of resources:** The REST API provides the uniform interface
    to talk to. It uses a **Uniform Resource Identifier** (**URI**) to map the resources
    (data). It also has the advantage of requesting a specific data format as the
    response. The Internet Media Type(MIME type) can tell the server that the requested
    resource is of that particular type.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementational freedom:** REST is just a mechanism to define your web services.
    It is an architectural style that can be implemented in multiple ways. Because
    of this flexibility, you can create REST services in the way you wish to. Until
    it follows the principles of REST, your server has the freedom to choose the platform
    or technology.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thoughtful caching is essential for the REST services to scale.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: REST verbs and status codes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'REST verbs specify an action to be performed on a specific resource or a collection
    of resources. When a request is made by the client, it should send this information
    in the HTTP request:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: REST verb
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header information
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body (optional)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned previously, REST uses the URI to decode its resource to be
    handled. There are quite a few REST verbs available, but six of them are used
    frequently. They are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are a software developer, you will be dealing with these six most of
    the time. The following table explains the operation, target resource, and what
    happens if the request succeeds or fails:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '| **REST Verb** | **Action** | **Success** | **Failure** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Fetches a record or set of resources from the server | 200 | 404
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Fetches all available REST operations  | 200 | - |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Creates a new set of resources or a resource | 201 | 404, 409 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Updates or replaces the given record | 200, 204 | 404 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Modifies the given record | 200, 204 | 404 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Deletes the given resource  | 200 | 404 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: The numbers in the **Success** and **Failure** columns of the preceding table
    are HTTP status codes. Whenever a client initiates a REST operation, since REST
    is stateless, the client should know a way to find out whether the operation was
    successful or not. For that reason, HTTP has status codes for the response. REST
    defines the preceding status code types for a given operation. This means a REST
    API should strictly follow the preceding rules to achieve client-server communication.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: All defined REST services have the following format. It consists of the host
    and API endpoint. The API endpoint is the URL path which is predefined by the
    server. Every REST request should hit that path.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A trivial REST API URI: `http://HostName/API endpoint/Query(optional)`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at all the verbs in more detail. The REST API design starts with
    the defining of operations and API endpoints. Before implementing the API, the
    design document should list all the endpoints for the given resources. In the
    following section, we carefully observe the REST API endpoints using PayPal's
    REST API as a use case.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: GET
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `GET` method fetches the given resource from the server. To specify a resource,
    `GET` uses a few types of URI queries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path-based parameters
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you didn't know, all of your browsing of the web is done by performing
    a `GET` request to the server. For example, if you type [www.google.com](http://www.google.com),
    you are actually making a `GET` request to fetch the search page. Here, your browser
    is the client and Google's web server is the backend implementer of web services.
    A successful `GET` operation returns a 200 status code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of path parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Everyone knows **PayPal**. PayPal creates billing agreements with companies.
    If you register with PayPal for a payment system, they provide you with a REST
    API for all your billing needs. The sample `GET` request for getting the information
    of a billing agreement looks like this: `/v1/payments/billing-agreements/agreement_id`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Here, the resource query is with the path parameter. When the server sees this
    line, it interprets it as *I got an HTTP request with a need for agreement_id
    from the billing agreements*. Then it searches through the database, goes to the
    `billing-agreements` table, and finds an agreement with the given `agreement_id`.
    If that resource exists it sends the details to copy back in response (200 OK).
    Or else it sends a response saying resource not found (404).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Using `GET`, you can also query a list of resources, instead of a single one
    like the preceding example. PayPal's API for getting billing transactions related
    to an agreement can be fetched with `/v1/payments/billing-agreements/transactions`.
    This line fetches all transactions that occurred on that billing agreement. In
    both, the case's data is retrieved in the form of a JSON response. The response
    format should be designed beforehand so that the client can consume it in the
    agreement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of query parameters are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Query parameters are intended to add detailed information to identify a resource
    from the server. For example, take this sample fictitious API. Let us assume this
    API is created for fetching, creating, and updating the details of the book. A
    query parameter based `GET` request will be in this format:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding URI has few query parameters. The URI is requesting a book from
    the book''s resource that satisfies the following conditions:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be a fiction book
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book should have been published in the year 2017
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Get all the fiction books that are released in the year 2017* is the question
    the client is posing to the server.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Path vs Query parameters—When to use them? It is a common rule of thumb that
    `Query` parameters are used to fetch multiple resources based on the query parameters.
    If a client needs a single resource with exact URI information, it can use `Path`
    parameters to specify the resource. For example, a user dashboard can be requested
    with `Path` parameters and fetch data on filtering can be modeled with `Query`
    parameters.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Use `Path` parameters for a single resource and `Query` parameters for multiple
    resources in a `GET` request.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: POST, PUT, and PATCH
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `POST` method is used to create a resource on the server. In the previous
    book's API, this operation creates a new book with the given details. A successful
    `POST` operation returns a 201 status code. The `POST` request can update multiple
    resources: `/v1/books`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The `POST` request has a body like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This actually creates a new book in the database. An ID is assigned to this
    record so that when we `GET` the resource, the URL is created. So `POST` should
    be done only once, in the beginning. In fact, *Lord of the Rings* was published
    in 1955\. So we entered the published date incorrectly. In order to update the
    resource, let us use the `PUT` request.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PUT` method is similar to `POST.` It is used to replace the resource that
    already exists. The main difference is that `PUT` is idempotent. A `POST` call
    creates two instances with the same data. But `PUT` updates a single resource
    that already exists:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'with body that is JSON like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`1256` is the ID of the book. It updates the preceding book by `year:1955`.
    Did you observe the drawback of `PUT`? It actually replaced the entire old record
    with the new one. We needed to change a single column. But `PUT` replaced the
    whole record. That is bad. For this reason, the `PATCH` request was introduced.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PATCH` method is similar to `PUT`, except it won''t replace the whole
    record. `PATCH`, as the name suggests, patches the column that is being modified.
    Let us update the book `1256` with a new column called `ISBN`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'with the JSON body like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It tells the server, *Search for the book with id 1256\. Then add/modify this
    column with the given value*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` and `PATCH` both return the 200 status for success and 404 for not found.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: DELETE and OPTIONS
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DELETE` API method is used to delete a resource from the database. It is
    similar to `PUT` but without any body. It just needs an ID of the resource to
    be deleted. Once a resource gets deleted, subsequent `GET` requests return a 404
    not found status.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Responses to this method are *not cacheable* (in case caching is implemented)
    because the `DELETE` method is idempotent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `OPTIONS` API method is the most underrated in the API development. Given
    the resource, this method tries to know all possible methods (`GET`, `POST`, and
    so on) defined on the server. It is like looking at the menu card at a restaurant
    and then ordering an item which is available (whereas if you randomly order a
    dish, the waiter will tell you it is not available). It is best practice to implement
    the `OPTIONS` method on the server. From the client, make sure `OPTIONS` is called
    first, and if the method is available, then proceed with it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important application of this `OPTIONS` method is **Cross-Origin Resource
    Sharing** (**CORS**). Initially, browser security prevented the client from making
    cross-origin requests. It means a site loaded with the URL [www.foo.com](http://www.foo.com)
    can only make API calls to that host. If the client code needs to request files
    or data from [www.bar.com](http://www.bar.com), then the second server, [bar.com,](https://bar.com/)
    should have a mechanism to recognize [foo.com](http://foo.com) to get its resources.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'This process explains the CORS:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[foo.com](http://foo.com) requests the `OPTIONS` method on [bar.com](http://bar.com).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[bar.com](http://bar.com) sends a header like `Access-Control-Allow-Origin:
    http://foo.com` in response to the client.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, [foo.com](http://foo.com) can access the resources on [bar.com](https://bar.com/)
    without any restrictions that call any `REST` method.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If [bar.com](http://bar.com) feels like supplying resources to any host after
    one initial request, it can set Access control to * (that is, any).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the diagram depicting the process happening one after the
    other:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32a06a64-3c6b-4f5d-90da-8c4745a520a1.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Types of status codes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few families of status codes. Each family globally explains an operation
    status. Each member of that family may have a deeper meeting. So a REST API should
    strictly tell the client what exactly happened after the operation. There are
    60+ status codes available. But for REST, we concentrate on a few families of
    codes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 2xx family (successful)
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '200 and 201 fall under the success family. They indicate that an operation
    was successful. Plain **200** (**Operation Successful**) is a successful CRUD
    Operation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**200** (**Successful Operation**) is the most common type of response status
    code in REST'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201** (**Successfully Created**)is returned when a `POST` operation successfully
    creates a resource on the server'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204** (**No content**) is issued when a client needs a status but not any
    data back'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3xx family (redirection)
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These status codes are used to convey redirection messages. The most important
    ones are **301** and **304**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**301** is issued when a resource is moved permanently to a new URL endpoint.
    It is essential when an old API is deprecated. It returns the new endpoint in
    the response with the 301 status. By seeing that, the client should use the new
    URL in response to achieving its target.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **304** status code indicates that content is cached and no modification
    happened for the resource on the server. This helps in caching content at the
    client and only requests data when the cache is modified.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4xx family (client error)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the standard error status codes which the client needs to interpret
    and handle further actions. These have nothing to do with the server. A wrong
    request format or ill-formed REST method can cause these errors. Of these, the
    most frequent status codes API developers use are **400**, **401**, **403**, **404**,
    and **405**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**400** (**Bad Request**) is returned when the server cannot understand the
    client request.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401** (**Unauthorized**) is returned when the client is not sending the authorization
    information in the header.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403** (**Forbidden**) is returned when the client has no access to a certain
    type of resources.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404** (**Not Found**) is returned when the client request is on a resource
    that is nonexisting.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**405** (**Method Not Allowed**) is returned if the server bans a few methods
    on resources. `GET` and `HEAD` are exceptions.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5xx family (server error)
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the errors from the server. The client request may be perfect, but
    due to a bug in the server code, these errors can arise. The commonly used status
    codes are **500**, **501**, **502**, **503**,  and **504**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**500** (**Internal Server Error**) status code gives the development error
    which is caused by some buggy code or some unexpected condition'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**501** (**Not Implemented**) is returned when the server is no longer supporting
    the method on a resource'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**502** (**Bad Gateway**) is returned when the server itself got an error response
    from another service vendor'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**503** (**Service Unavailable**) is returned when the server is down due to
    multiple reasons, like a heavy load or for maintenance'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**504** (**Gateway Timeout**) is returned when the server is waiting a long
    time for a response from another vendor and is taking too much time to serve the
    client'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details on status codes, visit this link: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Rise of REST API with Single Page Applications
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to understand why **Single Page Applications **(**SPA**) are the hot
    topic today. Instead of building the UI in a traditional way (request web pages),
    these SPA designs make developers write code in a totally different way. There
    are many MVC frameworks, like AngularJS, Angular2, React JS, Knockout JS, Aurelia,
    and so on, to develop web UIs rapidly, but the essence of each of them is pretty
    simple. All MVC frameworks help us to implement one design pattern. That design
    pattern is *No requesting of web pages, only REST API.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The modern web frontend development has advanced a lot since 2010\. In order
    to exploit the features of** Model-View-Controller** (**MVC**) architecture, we
    need to consider the frontend as a separate entity which talks to the backend
    only using the REST API (most preferably, REST JSON).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Old and new ways of data flow in SPA
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All websites go through the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Request a web page from the server.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authenticate and show the Dashboard UI.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow the user to modify and save.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request as many web pages from the server as needed to show individual pages
    on the site.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But in the SPA, the flow is quite different:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Request the HTML template/s to the browser in one single go.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, query the JSON REST API to fill a model (data object).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the UI according to the data in the model (JSON).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When users modify the UI, the model (data object) should change automatically.
    For example, in AngularJS, it is possible with two-way data binding. Finally,
    make REST API calls to notify the server about changes whenever you want.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this way, communication happens only in the form of the REST API. The client
    takes care of logically representing the data. This causes systems to move from
    **Response Oriented Architecture** (**ROA**) to **Service Oriented Architecture**
    (**SOA**). Take a look at the following diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19a08895-c507-4a77-b9f1-830361ac0668.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: SPA reduces the bandwidth and improves the site performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Why Go for REST API development?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services are trivial in the modern web. SOA (which we discuss in more detail
    later) created an activity space for REST services to take web development to
    the next level. **Go** is a programming language from the house of Google for
    solving the bigger problems they have. It has been eight-plus years since its
    first appearance. It matured along the way with a developer community jumping
    in and creating huge scale systems in it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Go is the darling of the web. It solves bigger problems in an easy way.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'One can choose Python or JavaScript (Node) for their REST API development.
    The main advantage of Go lies in its speed and compile-time error detection. Go
    is proved to be faster than dynamic programming languages in terms of computational
    performance by various benchmarks. These are the three reasons why a company should
    write their next API in Go:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To scale your API for a wider audience
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable your developers to build robust systems
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To invest in the future viability of your projects
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can look at the neverending online debates for more information about REST
    services with Go. In later chapters, we try to build the fundamentals of designing
    and writing the REST services.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and running the development server
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a building series book. It assumes you already know the basics of Go.
    If not, no worries. You can jump start and learn them quickly from Go's official
    site at [https://golang.org/](https://golang.org/). Go uses a different way of
    developing projects. Writing a standalone, simple program doesn't bother you much.
    But after learning the basics, people try to advance a step further. For that
    reason, as a Go developer, you should know how Go projects are laid out and the
    best practices to keep your code clean.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have done the following things before proceeding:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Install Go compiler on your machine
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `GOROOT` and `GOPATH` environment variables
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many online references from which you can get to know the preceding
    details. Depending on your machine type (Windows, Linux, or macOS X), set up a
    working Go compiler. We see more details about `GOPATH` in the following section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线参考资料可以了解到前面的细节。根据你的机器类型（Windows、Linux或macOS X），设置一个可用的Go编译器。我们将在下一节中看到有关`GOPATH`的更多细节。
- en: Demystifying GOPATH
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密GOPATH
- en: '`GOPATH` is nothing but the current appointed workspace on your machine. It
    is an environment variable that tells the Go compiler about where your source
    code, binaries, and packages are placed.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH`只是你的机器上当前指定的工作空间。它是一个环境变量，告诉Go编译器你的源代码、二进制文件和包的位置。'
- en: The programmers coming from a Python background may know the Virtualenv tool
    to create multiple projects (with different Python interpreter versions) at the
    same time. But at a given time, one activates the environment and develops his
    project. Similarly,  you can have any number of Go projects on your machine. While
    developing, set the `GOPATH` to one of your projects. The Go compiler now activates
    that project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Python背景的程序员可能知道Virtualenv工具，可以同时创建多个项目（使用不同的Python解释器版本）。但在某个时间点，只能激活一个环境并开发自己的项目。同样，你可以在你的机器上有任意数量的Go项目。在开发时，将`GOPATH`设置为你的一个项目。Go编译器现在激活了该项目。
- en: 'It is a common practice to create a project under the home directory and set
    the `GOPATH` environment variable like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在家目录下创建一个项目并设置`GOPATH`环境变量是一种常见的做法，就像这样：
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we install external packages like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们这样安装外部包：
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go copies the project called `mux` into the currently activated project `myproject`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go将名为`mux`的项目复制到当前激活的项目`myproject`中。
- en: For Go get, use the `-u` flag to install updated dependencies of the external
    package and `-v` to see the verbose details of installation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go get，使用`-u`标志来安装外部包的更新依赖项，使用`-v`来查看安装的详细信息。
- en: 'A typical Go project has the following structure, as mentioned on the official
    Go website:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Go项目具有以下结构，正如官方Go网站上所述：
- en: '![](img/b5ae002f-d91f-4d0f-bbb0-e5b366ae3876.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5ae002f-d91f-4d0f-bbb0-e5b366ae3876.png)'
- en: 'Let us understand this structure before digging further:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在深入研究之前先了解这个结构：
- en: '`bin`: Stores the binary of our project; a shippable binary which can be run
    directly'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`：存储我们项目的可运行二进制文件'
- en: '`pkg`: Contains the package objects; a compiled program which supplies package
    methods'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`：包含包对象的目录；一个提供包方法的编译程序'
- en: '`src`: The place for your project source code, tests, and user packages'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：项目源代码、测试和用户包的位置'
- en: In Go, all the packages which you import into your main program have an identical
    structure, `github.com/user/project`. But who creates all these directories? Should
    the developer do that? Nope. It is the developer's responsibility to create directories
    for his/her project. It means he/she only creates the directory `src/github.com/user/hello`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你导入到你的主程序中的所有包都有一个相同的结构，`github.com/user/project`。但是谁创建所有这些目录？开发者需要做吗？不需要。开发者的责任是为他/她的项目创建目录。这意味着他/她只创建`src/github.com/user/hello`目录。
- en: 'When a developer runs the following command, the directories bin and package
    are created if they did not exist before. `.bin` consists of the binary of our
    project source code and `.pkg` consists of all internal and external packages
    we use in our Go programs:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者运行以下命令时，如果之前不存在，将创建`bin`和`package`目录。`.bin`包含我们项目源代码的二进制文件，`.pkg`包含我们在Go程序中使用的所有内部和外部包：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Building our first service – finding the Roman numeral
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个服务-查找罗马数字
- en: With the concepts we have built upto now, let us write our first basic REST
    service. This service takes the number range (1-10) from the client and returns
    its Roman string. Very primitive, but better than Hello World.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们到目前为止建立的概念，让我们编写我们的第一个基本REST服务。这个服务从客户端获取数字范围（1-10），并返回其罗马字符串。非常原始，但比Hello
    World好。
- en: '**Design:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计：**'
- en: Our REST API should take an integer number from the client and serve back the
    Roman equivalent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST API应该从客户端获取一个整数，并返回罗马数字等价物。
- en: 'The block of the API design document may look like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: API设计文档的块可能是这样的：
- en: '| **HTTP Verb** | **PATH** | **Action** | **Resource** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **路径** | **操作** | **资源** |'
- en: '| `GET` | `/roman_number/2` | show | `roman_number` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/roman_number/2` | 显示 | `roman_number` |'
- en: '**Implementation:**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施：**'
- en: Now we are going to implement the preceding simple API step-by-step.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步实现前面的简单API。
- en: Code for this project is available at [https://github.com/narenaryan/gorestful](https://github.com/narenaryan/gorestful).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在[https://github.com/narenaryan/gorestful](https://github.com/narenaryan/gorestful)上找到。
- en: 'As we previously discussed, you should set the `GOPATH` first. Let us assume
    the `GOPATH` is `/home/naren/go`. Create a directory called `romanserver` in the
    following path. Replace *narenaryan* with your GitHub username (this is just a
    namespace for the code belonging to different users):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，你应该首先设置`GOPATH`。假设`GOPATH`是`/home/naren/go`。在以下路径中创建一个名为`romanserver`的目录。用你的GitHub用户名替换*narenaryan*（这只是属于不同用户的代码的命名空间）：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project is ready. We don''t have any database configured yet. Create an
    empty file called `main.go`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经准备好了。我们还没有配置任何数据库。创建一个名为`main.go`的空文件：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our main logic for the API server goes into this file. For now, we can create
    a data file which works as a data service for our main program. Create one more
    directory for packaging the Roman numeral data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API服务器的主要逻辑放在这个文件中。现在，我们可以创建一个作为我们主程序的数据服务的数据文件。再创建一个目录来打包罗马数字数据：
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create an empty file called `data.go` in the `romanNumerals` directory.
     The `src` directory structure so far looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`romanNumerals`目录中创建一个名为`data.go`的空文件。到目前为止，`src`目录结构看起来是这样的：
- en: ;![](img/5d36f6b4-c619-4e06-8ddd-9374c32ac864.png)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/5d36f6b4-c619-4e06-8ddd-9374c32ac864.png)'
- en: 'Now let us start adding code to the files. Create data for the Roman numerals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始向文件添加代码。为罗马数字创建数据：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are creating a map called **Numerals**. This map holds information for converting
    a given integer to its Roman equivalent. We are going to import this variable
    into our main program to serve the request from the client.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为**Numerals**的映射。这个映射保存了将给定整数转换为其罗马等价物的信息。我们将把这个变量导入到我们的主程序中，以便为客户端的请求提供服务。
- en: 'Open `main.go` and add the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main.go`并添加以下代码：
- en: '[PRE14]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Always use the Go fmt tool to format your Go code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用Go fmt工具格式化你的Go代码。
- en: Usage example: `go fmt github.com/narenaryan/romanserver`
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用法示例：`go fmt github.com/narenaryan/romanserver`
- en: 'Now, install this project with the Go command `install`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Go命令`install`安装这个项目：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This step does two things:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步做了两件事：
- en: Compiles the package `romanNumerals` and places a copy in the `$GOPATH/pkg`
    directory
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译包`romanNumerals`并将副本放在`$GOPATH/pkg`目录中
- en: Places a binary in the `$GOPATH/bin`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件放入`$GOPATH/bin`
- en: 'We can run the preceding API server as this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样运行前面的API服务器：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The server is up and running on `http://localhost:8000`. Now we can make a `GET`
    request to the API using a client like `Browser` or the `CURL` command. Let us
    fire a `CURL` command with a proper API `GET` request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器正在`http://localhost:8000`上运行。现在我们可以使用像`浏览器`或`CURL`命令这样的客户端发出`GET`请求到API。让我们用一个合适的API`GET`请求来发出一个`CURL`命令。
- en: 'Request one is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请求一如下：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The response is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let us try a few incorrectly formed requests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些格式不正确的请求。
- en: 'Request two is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请求二如下：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Request three is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请求三如下：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our little Roman numerals API is doing the right thing. The right status codes
    are being returned. That is the point all API developers should keep in mind.
    The client should be informed why something went wrong.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小罗马数字API正在做正确的事情。正确的状态码正在被返回。这是所有API开发者应该牢记的要点。客户端应该被告知为什么出了问题。
- en: Breaking down the code
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分解
- en: 'We just updated the empty files in one single go and started running the server.
    Let me now explain each and every piece of the file `main.go`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一次性更新了空文件并启动了服务器。现在让我解释一下`main.go`文件的每一部分：
- en: Imported a few packages. `github.com/narenaryan/romanNumerals` is the data service
    we created before.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入了一些包。`github.com/narenaryan/romanNumerals`是我们之前创建的数据服务。
- en: '`net/http` is the core package we used to handle an HTTP request through its
    `HandleFunc` function. That function''s arguments are `http.Request` and `http.ResponseWriter`.
    Those two deal with the request and response of an HTTP request.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`是我们用来处理HTTP请求的核心包，通过它的`HandleFunc`函数。该函数的参数是`http.Request`和`http.ResponseWriter`。这两个处理HTTP请求的请求和响应。'
- en: '`r.URL.Path` is the URL path of the HTTP request. For the CURL Request one, it
    is `/roman_number/5`*.* We are splitting this path and using the second argument
    as a resource and the third argument as a value to get the Roman numeral. The `Split`
    function is in a core package called `strings`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r.URL.Path`是HTTP请求的URL路径。对于CURL请求，它是`/roman_number/5`。我们正在拆分这个路径，并使用第二个参数作为资源，第三个参数作为值来获取罗马数字。`Split`函数在一个名为`strings`的核心包中。'
- en: The `Atoi` function converts an alphanumeric string to an integer. For the numerals
    map to consume, we need to convert the integer string to an integer. The `Atoi`
    function comes from a core package called `strconv`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Atoi`函数将字母数字字符串转换为整数。为了使用数字映射，我们需要将整数字符串转换为整数。`Atoi`函数来自一个名为`strconv`的核心包。'
- en: We use `http.StatusXXX` to set the status code of the response header. The `WriteHeader`
    and `Write` functions are available on the response object for writing the header
    and body, respectively.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`http.StatusXXX`来设置响应头的状态码。`WriteHeader`和`Write`函数可用于在响应对象上分别写入头部和正文。
- en: Next, we created an HTTP server using `&http` while initializing a few parameters
    like address, port, timeout, and so on.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`&http`创建了一个HTTP服务器，同时初始化了一些参数，如地址、端口、超时等。
- en: The `time` package is used to define seconds in the program. It says, after
    10 seconds of inactivity, automatically return a 408 request timeout back to the
    client.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`包用于在程序中定义秒。它说，在10秒的不活动后，自动向客户端返回408请求超时。'
- en: '`EscapeString` escapes special characters to become valid HTML characters.
    For example, Fran & Freddie''s becomes `Fran &amp; Freddie''s&#34`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EscapeString`将特殊字符转义为有效的HTML字符。例如，Fran & Freddie''s变成了`Fran &amp; Freddie''s&#34`。'
- en: Finally, start the server with the****  `ListenAndServe`**** function. It keeps
    your web server running until you kill it.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`ListenAndServe`函数启动服务器。它会一直运行你的Web服务器，直到你关闭它。
- en: One should write unit tests for their API. In the upcoming chapters, we will
    see how to test an API end to end.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 应该为API编写单元测试。在接下来的章节中，我们将看到如何对API进行端到端测试。
- en: Live reloading the application with supervisord and Gulp
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用supervisord和Gulp实时重新加载应用程序
- en: Gulp is a nice tool for creating workflows. A workflow is a step-by-step process.
    It is nothing but a task streamlining application. You need NPM and Node installed
    on your machine. We use Gulp to watch the files and then update the binary and
    restart the API server. Sounds cool, right?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp是一个用于创建工作流的好工具。工作流是一个逐步的过程。它只是一个任务流程应用程序。你需要在你的机器上安装NPM和Node。我们使用Gulp来监视文件，然后更新二进制文件并重新启动API服务器。听起来很酷，对吧？
- en: The supervisor is an application to reload your server whenever the application
    gets killed. A process ID will be assigned to your server. To restart the app
    properly, we need to kill the existing instances and restart the application.
    We can write one such program in Go. But in order to not reinvent the wheel, we
    are using a popular program called supervisord.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 监督程序是一个在应用程序被杀死时重新加载服务器的应用程序。一个进程ID将被分配给你的服务器。为了正确重新启动应用程序，我们需要杀死现有的实例并重新启动应用程序。我们可以用Go编写一个这样的程序。但为了不重复造轮子，我们使用一个叫做supervisord的流行程序。
- en: Monitoring your Go web server with supervisord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用supervisord监控你的Go Web服务器
- en: Sometimes your web application may stop due to operating system restarts or
    crashes. Whenever your web server gets killed, it is supervisor's job to bring
    it back to life. Even the system restart cannot take your web server away from
    the customers. So, strictly use supervisord for your app monitoring.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Installing supervisord
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can easily install supervisord on Ubuntu 16.04, with the `apt-get` command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This installs two tools, `supervisor` and `supervisorctl`. `supervisorctl` is
    intended to control the supervisord and add tasks, restart tasks, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS X, we can install `supervisor` using the `brew` command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, create a configuration file at:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can add any number of configuration files, and supervisord treats them
    as separate processes to run. Add the following content to the preceding file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By default, we have a file called `.supervisord.conf` at `/etc/supervisor/`.
    Look at it for more reference. In macOS X, the same file will be located at `/usr/local/etc/supervisord.ini`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to the preceding configuration:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The `[supervisord]` section tells the location of the log file for supervisord
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`[program:myserver]`** is the task block which traverses to the given directory
    and executes the command given'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can ask our `supervisorctl` to re-read the configuration and restart
    the tasks (process). For that, just say:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '`supervisorctl reread`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`supervisorctl update`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, launch `supervisorctl` with the command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will see something like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '`supervisorctl` is a great tool for controlling supervisor programs.![](img/0719632a-e003-4969-8db2-ab30fffaa133.png)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Since we named our romanserver `myserver` in the supervisor configuration file,
    we can start, stop, and restart that program from `supervisorctl`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Using Gulp for creating auto code compiling and server reloading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the little introduction we gave about Gulp in the preceding section, we
    are going to write a gulpfile for telling the computer to execute a few tasks.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: I install Gulp and Gulp-shell using `npm`**:**
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After this, create a `gulpfile.js` in the root directory of the project. Here,
    it is `github.com/src/narenaryan/romanserver`. Now add this content to `gulpfile.js`.
    First, whenever a file changes, install binary task gets executed. Then, the supervisor
    will be restarted. The watch task looks for any file change and executes the preceding
    tasks. We are also ordering the tasks so that they occur one after the other synchronously.
    All of these tasks are Gulp tasks and can be defined by the `gulp.task` function.
    It takes two arguments with task name, task. `sell.task` allows Gulp to execute
    system commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if you run the  `gulp` command in the `source` directory, it starts watching
    your source code changes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, if we modify the code, then the code is compiled, installed, and the server
    restarted in a flash:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b381310c-588c-4a06-af59-74a57019858f.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Understanding the gulpfile
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the gulpfile, we are performing the following instructions:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Import Gulp and Gulp-shell.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tasks with `shell.task` as the function to execute.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shell.task` can execute a command-line instruction. Keep your shell commands
    inside that function.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a watch task for watching source files. The task list will be executed when
    files are modified.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a default task for running. Add a watch to it.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gulp is a great tool for these kinds of use cases. So, please go through the
    official documentation of Gulp at [http://gulpjs.com/](http://gulpjs.com/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gave an introduction to the REST API. We saw that REST is
    not a protocol, but an architectural pattern. HTTP is the actual protocol on which
    we can implement our REST service. We jumped into the fundamentals of the REST
    API to be clear about what they actually are. Then we explored types of web services.
    Before REST, we have something called SOAP, which uses XML as the data format.
    REST operates on JSON as the primary format. REST has verbs and status codes.
    We saw what a given status code refers to. We built a simple service which serves
    the Roman numerals for given numbers. In this process, we also saw how to package
    a Go project. We understood the GOPATH environment variable. It is a workspace
    defining a variable in Go. All packages and projects reside in that path. We then
    saw how to reload a development project on the fly with the help of supervisord
    and Gulp. These are node tools but can help us to keep our Go project up and running.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了REST API。我们看到REST不是一个协议，而是一种架构模式。HTTP是我们可以实现REST服务的实际协议。我们深入了解了REST
    API的基本原理，以便清楚地了解它们实际上是什么。然后我们探讨了Web服务的类型。在REST之前，我们有一个叫做SOAP的东西，它使用XML作为数据格式。REST使用JSON作为主要格式。REST有动词和状态码。我们了解了给定状态码指的是什么。我们构建了一个简单的服务，为给定的数字提供罗马数字。在这个过程中，我们还看到了如何打包一个Go项目。我们了解了GOPATH环境变量。它是Go中定义变量的工作空间。所有的包和项目都驻留在这个路径中。然后我们看到了如何使用supervisord和Gulp来实时重新加载开发项目。这些都是Node工具，但可以帮助我们保持我们的Go项目正常运行。
- en: In the next chapter, we dig deeper into URL routing. Starting from the built-in
    router, we explore Gorilla Mux, a powerful URL routing library.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究URL路由。从内置路由器开始，我们将探索Gorilla Mux，一个强大的URL路由库。
