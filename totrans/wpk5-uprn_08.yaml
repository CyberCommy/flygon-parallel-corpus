- en: Authoring Tutorials and Live Coding Hacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the final chapter of this book for Webpack 5.0\. By now, you may feel
    like an expert, but proof of your mastery comes both from your ability to take
    ownership of the code itself and to customize the platform, and even to hack into
    it. A purist might shy away from terms such as *hacking* in favor of workarounds
    or patching, but we are essentially talking about the same subject (except explaining
    to the layperson that you have hacked Webpack during live production would certainly
    impress the most ardent skeptic of your coding superpowers).
  prefs: []
  type: TYPE_NORMAL
- en: That being said, this chapter is a compilation of the hardest things to do in
    Webpack and the easiest ways to accomplish them. We will begin with authoring
    libraries and move on to custom loaders, something discussed in this guide already,
    particularly with the use of Babel's **application programming interface** (**API**).
    This chapter will, however, discuss a more native approach to customization without
    the need for an API.
  prefs: []
  type: TYPE_NORMAL
- en: We will, naturally, cover some topics already discussed in some detail in this
    guide, such as testing and shimming, but this guide will offer a little more salience
    and relevance to customization.
  prefs: []
  type: TYPE_NORMAL
- en: From there, we will cover some very interesting hacks, specifically when working
    with live publications in a **Hot Module Replacement** (**HMR**)-enabled environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics covered in this final chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Authoring libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live coding hacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authoring libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section of this chapter will be of great use to anyone hoping to streamline
    their bundling strategy. It is not very well known that Webpack can be used for
    bundling both libraries and applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin with a hypothetical custom library project, which we'll call `numbers-to-text`.
    It will work by converting numerals from, say, `1` to `5` to a textual representation
    of the number, such as `3` to `three`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss each task in detail and explain what is happening in the code,
    with examples to help us understand with greater clarity exactly what is happening
    and how the code behaves. We will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by getting our project structure in line. The basic project structure
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the structure may look different from the previous tutorial—namely,
    the presence of the `ref.json` file. You will need to create those extra files
    if you don't have them before we go any further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we come back to the **command-line interface** (**CLI**), and we first
    need to initialize `npm`, then make sure we have installed Webpack and `lodash`.
    If you have already installed this by following the example in previous chapters,
    then don''t worry—duplicate installation attempts will only overwrite the last
    and shouldn''t cause any harm at all. Run the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That being done, we avert our attention to the newly built `src/ref.json` **JSON** file.
    This is the essential data of the custom library. It should look like the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this constitutes a simple list of options representing a number,
    with a corresponding written word version of that number. This will form the backbone
    of our very simple library structure, to demonstrate the concept in principle.
    Once the tutorial is complete, you should naturally see how you can adapt the
    library to your needs, no matter how complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make an index file (such as `src/index.js`). You should follow
    the coding displayed in this block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding code how the index file essentially contains
    a series of `export` and `return` functions related to the **JSON** file contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define the usage specification. This is done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ES2015 module import:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'CommonJS module require:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following snippet of code, in the same file, to set the functions when
    using `AMD`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can also use the library by loading it via a `script` tag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the most common way in which a library is loaded, and, as a JavaScript
    developer, it's something that should be second nature to follow. That being said,
    it can be configured to expose a property in the global object for Node.js or
    as a property in a `this` object.
  prefs: []
  type: TYPE_NORMAL
- en: This takes us to the basic configuration for the library. There is more than
    one level of configuration for authorizing this library, so this is just the first
    step.
  prefs: []
  type: TYPE_NORMAL
- en: The basic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with any Webpack project, we need to configure it. This requires some extra
    attention when dealing with a custom library. Several unusual things must be achieved
    with this configuration as opposed to a typical one. Let''s consider these objectives
    now. The library should be bundled in a way that achieves the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of externals to avoid bundling `lodash` so the user is required to load
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the external limitations of the library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing the library as a variable called `numbersToText`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the library name to `numbers-to-text`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permitting the access to the **Node.js** library indie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, note that the user must be able to access and have use of the library
    in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Through importing `numbersToText` from `numbers-to-text` as an **ECMAScript
    2015** (**ES 2015**) module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the CommonJS module, such as using the `require('webpack-numbers')`method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through a global variable when included through such methods as a script tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all that in mind, the first thing to do is set up the Webpack configuration
    through the normal files we use for this `webpack.config.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That is the basic configuration, but we''ll now move on to the next goal identified:
    the externalizing of `lodash`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using externals to avoid bundling lodash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you now perform a build, you will see that quite a large bundle is created.
    Inspecting the file reveals that `lodash` has been bundled alongside it. For the
    sake of this tutorial, `lodash` is better treated as a peer dependency. This essentially
    means that the user would have `lodash` installed, effectively giving control
    of this external library to the user of this library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done through the configuration of externals, as in `webpack.config.js`,asfollows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means that the library expects a dependency named `lodash`
    to be available in the user's environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note that externals may be specified as an array if the plan is to use the library
    as a dependency in a parallel Webpack bundle.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to specify a limitation on the externals, and we will discuss
    this now.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying external limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may work with libraries that use several files from a dependency, such
    as in the following descriptive block:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import A from ''library/one'';`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import B from ''library/two'';`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, they can''t be excluded from the bundle by specifying the library
    in the externals. They would need to be excluded one at a time or by using a regular
    expression,* s*uch as with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once that is accomplished, we need to expose the library or allow it to be loaded
    into our frontend. This is covered in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exposing a library is something already discussed in this guide, but if you''re
    jumping into this chapter, you may be puzzled. We are simply allowing our application
    to load the library from an external source, as with any library externally loading
    into a web page, for example. The library should be compatible with different
    environments, such as **CommonJS**, **MD**, or **Node.js** to ensure the widespread
    usability of the library. To ensure this, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `library` property should be added inside the output in the `webpack.config.js` 
    configuration file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The library setup is related to configuration. In most cases, specifying one
    entry point is enough. Multiple-part libraries are possible; however, it is simpler
    to expose partial exports through an index script, serving as the entry point.
  prefs: []
  type: TYPE_NORMAL
- en: It is unwise to attempt to use an array to a library entry point, as it won't
    compile very well.
  prefs: []
  type: TYPE_NORMAL
- en: This achieves the exposure of the library bundle as a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your library compatible with other environments by adding a `libraryTarget`
    property to the configuration file, adding different options on how they expose
    the library, using `webpack.config.js`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the configuration set, we now need to expose the library. Note that this
    can be done in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As a variable—as a global variable made available by a script tag, such as `libraryTarget:'var'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an object—available through a `this` object, such as `libraryTarget:'this'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window—this is available through the `window` object, such as `libraryTarget:'window'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Module Definition** (**UMD**)—available after CommonJS or AMD `require`
    statements, such as `libraryTarget:''umd''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you set the library but don't do this for the `libraryTarget` function, the
    latter will default to a variable, as specified in the output configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the library and working with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As explained, we are now in the last steps of this authoring. The optimization
    of the output should be made by following the guide as we proceed. While we do
    this, we will add in the path to the bundle output as the package''s main field
    with the `package.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The option key named `"main"` in the preceding code block refers to the standard
    we retrieve from the `package.json` file. The `"module"` key refers to a proposal
    that allows the JavaScript environment to upgrade, to be able to use ES2015 modules
    without harming any backward-compatibility capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `"module"` property, this should point to a script that uses
    ES2015 module syntax throughout, but no other syntax that is not yet supported
    by browsers or Node.js. This will enable Webpack to parse module syntax and allow
    lighter bundles through tree shaking, as users are likely only consuming certain
    parts of any given library.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, the bundle can be published as an `npm` package.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to set up and configure your first custom library using
    a JSON file with corresponding numbers and text, including exposing the new library
    in your frontend and specifying the limitations in scope for the library.
  prefs: []
  type: TYPE_NORMAL
- en: In a related sphere, let's now talk about custom loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Custom loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders have been discussed in detail in previous chapters of this guide. However,
    we have only alluded to the customization or authoring of them. This will be increasingly
    important to at least demonstrate your mastery of Webpack, so we should discuss
    it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tutorial will be structured like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Guidelines* section will itself be subcategorized, but for now, let's begin
    with the setup.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to start this section is to look at how we can develop and test
    a loader locally. This is a nice and palatable way to begin, and we will proceed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When testing a single loader, you can simply use a path to resolve to a local
    file within a rule object in **`webpack.config.js`**,as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To test multiple loaders, you can utilize the `resolveLoader.modules` configuration,
    whereby Webpack will search for loaders in `webpack.config.js`. For example, if
    you had a local directory in your project with a loader inside of it, the code
    would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That should be all you need to begin. However, if you've already created a separate
    repository for your loader, you could use an `npm` link to the project in which
    you'd like to run the test.
  prefs: []
  type: TYPE_NORMAL
- en: There's more than one methodology depending on the usage of the loader, so—naturally—we
    will begin with simple usage.
  prefs: []
  type: TYPE_NORMAL
- en: Simple usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of simple loaders has already been alluded to, this being that a loader
    is more useful when it performs a very simple and specific task. This will make
    testing easier and, as there are so many, they can be *chained* to others in a
    more complex usage to perform a greater variety of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When a single loader is applied to the resource, the loader is called with only
    one parameter. This is a string containing the content of the resource being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous loaders can return a single value representing the transformed module.
    In more complex cases, the loader can return any number of values by using the
    following function: `this.callback(err, values...)`.
  prefs: []
  type: TYPE_NORMAL
- en: Errors are then either passed to the function or thrown in a synchronized loader.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the loader is expected to give back one or two values. The first
    value is some resulting JavaScript code as a string. The second value is optional
    and results in a `SourceMap` and JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders tend to get more complex in situations where they are chained. When
    discussing complex usage of custom loaders, that would be a good place to start,
    so let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Complex usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous subsection, *Simple usage*, complex usage generally
    refers to the use of a loader in context with another or a set of loaders in a
    chained pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple loaders are chained, it is important to remember that they are
    executed in reverse order!
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be either right to left or bottom to top, depending on the array
    format you use. For instance, the following will apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The last loader, which is called by the script first, will be passed the contents
    of the raw resource (the data or script being run by the loader).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first loader, called last, is expected to return JavaScript and an optional
    source map.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loaders in between will be executed with the result(s) of the previous loader
    in the chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in the following common example, `foo-loader` would be passed the raw resource,
    and `bar-loader` would receive the output of `foo-loader` and return the final
    transformed module and a source map, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To chain loaders this way, start with the `webpack.config.js` configuration
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's the configurations, but as chained loaders are complex by nature, it's
    good to follow a standard. What follows is a set of guidelines that will help
    your project come together without fraying at the edges.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following guidelines should be followed when writing a loader. They are
    ordered in terms of importance, and some only apply in certain scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the purpose of the loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular outputting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring statelessness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing loader utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking loader dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving module dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting common code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding absolute paths at all costs!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using peer dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through each one in more detail, starting with simplification.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the purpose of the loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders work best when they perform a simple and clear task. This can make the
    job of maintaining each loader simpler, and also permits chaining for use in more
    complex tasks. This is because there may be many different loaders specific to
    the different tasks; so, to allow versatility, they are often used in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, much as with Webpack bundles, they should be modular. Therefore,
    the specific task they perform can be isolated and refined, which will also allow
    more ubiquitous application when used in a chain with other loaders. This brings
    us to the next concept: the chaining of a loader.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take advantage of the fact that loaders can be chained together. Instead of
    writing a single loader that tackles many tasks, write multiple loaders. Isolating
    them not only keeps each loader simple but may also allow them to be used for
    something more varied.
  prefs: []
  type: TYPE_NORMAL
- en: 'When rendering a template file with data specified via loader options or query
    parameters, for example, it could be written as a single loader that compiles
    the template from source, executes it, and returns a module that exports a string
    containing the HTML code. However, in the following guidelines, a simple `apply-loader`
    exists that can be chained with other open source loaders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jade-loader`: This converts the template to a module that exports a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply-loader`: This executes the function with loader options and returns
    basic HTML code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e idea HTML-loader`: This accepts the HTML code and outputs a valid JavaScript
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that loaders can be chained also means they don't necessarily have
    to output JavaScript, as long as the next loader in the chain can handle its output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack is always modular, so let's look at the advice concerning that when
    working with chained loaders.
  prefs: []
  type: TYPE_NORMAL
- en: Modular outputting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should always, and in the best of circumstances, keep output modular. Loader-generated
    modules should adhere to the same design heuristics as normal modules.
  prefs: []
  type: TYPE_NORMAL
- en: This may be for obvious reasons, but compatibility with existing projects would
    mean that this standard should be followed. It will also be of increasing importance
    for the chaining of loaders, as discussed previously. Loaders are often used in
    sequence with each other, and many Webpack projects require the installation and
    usage of many of them.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the adherence to a modular output convention will prevent projects
    from becoming overly complicated and, in fact, possibly cause a reversal in the
    purpose of Webpack bundling, which is making a smaller, more succinct, and optimized
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This conventional adherence or standard formatting is something that will be
    second nature to most developers, but when working with Webpack, there may be
    some compatibility considerations you have overlooked as they are so peculiar
    to bundling. One of these considerations is the "state" of the loader.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring statelessness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure the loader does not retain a state between module transformations.
    Each run should always be independent of other compiled modules.
  prefs: []
  type: TYPE_NORMAL
- en: During the compilation process, you may end up running several builds as you
    fine-tune your bundle, and you don't want to correct each run, but rather retain
    each build in its original state.
  prefs: []
  type: TYPE_NORMAL
- en: This will make things much easier to keep track of should things go wrong, as
    you can always start again with the source files without starting at the very
    beginning of your command-line session.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to consider compatibility with other loaders. As this is
    a convention among loaders, you should maintain that same convention unless it
    is fundamentally necessary for your loader to perform its specific task, and,
    if so, this should be made clear to the developer so that no mistakes are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the passing of a state is necessary for the functionality of your loader,
    then there is a convenient solution to provide adherence to conventions: the loader
    utilities package.'
  prefs: []
  type: TYPE_NORMAL
- en: Employing loader utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why not take advantage of the `loader-utils` package? It provides a variety
    of useful tools, but one of the most common of these is the ability to retrieve
    the options being passed to any loader in use. Along with `loader-utils`, the
    `schema-utils` package should be used for consistent JSON Schema-based validation.
    The following code block shows an example that utilizes both packages, using `loader.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can apply some transformations to the source, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This transformation will **stringify** the code—essentially, outputting the
    contents into a single line of code that is difficult to read by humans but ideal
    for computers. This also often helps with privacy issues, should anyone wish to
    manually copy the code. With that understood, let's move on to loader dependency
    guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Marking loader dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a loader uses external resources, such as when reading from a filesystem,
    the loader must indicate this. This information is used to invalidate "cacheable"
    loaders and recompile them in watch mode. What follows is a brief example of how
    to accomplish this, using the `addDependency` method inside of `loader.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are some differences between the loader and modular dependencies. Let's
    now discuss the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving module dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the type of module you are using, there may be a different schema
    in use to specify any dependency. In **Cascading Style Sheets** (**CSS**), for
    example, the `@import` and `URL(...)` statements are used. When doing this, these
    dependencies should be resolved by the module system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By transforming the statements to `require` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `this.resolve` function to resolve a path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `css-loader` is a good example of the first approach. It transforms dependencies
    to `require` statements, by replacing `@import` statements with a request to the
    other style sheet and `url(...)` with a request to the file being referenced.
  prefs: []
  type: TYPE_NORMAL
- en: In respect to the LESS loader, each `@import` statement is unable to transform
    to a `require` statement because **fewer** files must be compiled in a single
    iteration. As a result, the LESS loader will use custom path-resolving logic to
    extend the LESS compiler. It will then use the `this.resolve` method to resolve
    the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using language that only accepts relative **Uniform Resource Locators**
    (**URLs**), the *~* tilde convention can be used to specify references to the
    installing modules. An example would be `url('~some-library/image.png')`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting common code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of best practice here, the generating of common code in every module
    of the loader process should be avoided. A better approach is to use a runtime
    file in the loader and generate a `require` statement process to any shared module.
    This better suits how Webpack parses code.
  prefs: []
  type: TYPE_NORMAL
- en: It is the essential purpose of Webpack to compile a project so that code is
    not duplicated, so this may go without saying, but the loaders themselves should
    do this and not leave it to the Webpack core processing. Otherwise, applications
    would be needlessly large or have needlessly long compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: If you have experience in programming plugins, you may overlook this very obvious
    precept, but it is worth mentioning here as it is so essential to the operation
    and processes of Webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding absolute paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As alluded to, inserting absolute paths into any code related to a module should
    not be done, as hashing will break if the root directory is ever moved. Also,
    note that there is a `stringifyRequest` method in the `loader-utils` loader, which
    can be used to an absolute path to a relative one to help automate your process.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 2](3307482e-bfac-4ad6-8d58-767063722dda.xhtml), *Working with
    Modules and Code Splitting, *to get a refresher on absolute paths if you think
    you need it.
  prefs: []
  type: TYPE_NORMAL
- en: As with common code, this is something very fundamental to how Webpack works,
    and if you don't have that in mind during your authoring you may overlook it,
    so it is certainly worth mentioning. Relative paths are the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: One last point on standards relates to peer dependencies. Let's look at these
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Using peer dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the event of developing a loader that is a simple wrapper (essentially, code
    that acts as a shell for more operational code within), the operational code—or
    package—should be included as `peerDependency`. This is because it will allow
    you to specify the exact version of the package using the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `sass-loader` specifies `node-sass` as a peer
    dependency. Take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This can be invaluable for compatibility issues, especially on complex programming
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far, we have written a custom loader, followed the guidelines, and even
    got it running locally. The next step is testing. The following example is a simple
    unit testing procedure. It makes use of the `babel-jest` **Jest** framework and
    some other presets to allow the use of the `import/export` and `async/await` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by installing and saving these as something called `devDependencies`,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous command-line entry installs the **Jest** framework and **Babel**
    with **Jest** in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must look at the configuration used in `webpack.config.js` concerning
    this particular unit testing procedure, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The function of the loader in the example is to process a text file and replace
    any instance of `[name]` with the option given to the loader. It then outputs
    a valid **JavaScript** module containing the text as its default export, as seen
    in the following example inside of **`src/loader.js`**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This loader will be used to process the following text file, called `test/example.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is a little more complicated. It uses the **Node.js** API and
    `memory-fs` to execute Webpack. This will avoid content being output to the local
    hard drive (very handy to know) and gives us access to statistical data that can
    be used to take hold of our transformed module. It begins with the following command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s installed, there''s some work we need to do on its associated compiler
    script. Use the following **`test/compiler.js` **file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we inlined our configuration, but a configuration as
    a parameter to the `export` function can also be accepted. This allows the testing
    of multiple setups using the same compiler module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This being done, we can now write our test and add an `npm` script to run it. Let''s
    begin by adding the following code to our `test/loader.test.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code block shows the testing function that loads in the example
    text, should the program work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Everything should now be in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can now be run, and we''ll check whether the new loader has passed
    the test by running an `npm` build in the command line and viewing the command-line
    window, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you see something like the preceding text in the corresponding file, then
    it passed. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be able to develop, test, and deploy your loaders.
    Don't forget to share your creations with the rest of the Webpack community and
    help expand the capabilities of developers everywhere, and make your mark at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered a huge amount in this guide and I suppose you feel like an expert,
    having built custom libraries and loaders, but making live coding hacks would
    make your skillset even more impressive. These are useful to know, especially
    on custom jobs where workarounds and makeshift approaches are more likely than
    tried-and-tested code, so let's dive right in!
  prefs: []
  type: TYPE_NORMAL
- en: Live coding hacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will get to see some very intriguing stuff that will leave
    an expert feeling like a superhero, should he or she ever get into hot water or
    simply wish to show off. We will discuss loaders that work well with **HMR**, such
    as `monkey-hot-loader` and `react-hot-loader`, as well as the various uses of `eval`
    and `__Eval`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, you should note that there is a side effect with **HMR**. It
    always evaluates the entire module again when it updates. This includes the dependency
    chain, which updates to point to new modules. However, we may just want the original
    module to evaluate the new code, not the entire module. Thankfully, there is a
    hack around this: using `monkey-hot-loader`!'
  prefs: []
  type: TYPE_NORMAL
- en: Monkey Hot Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This will also mean that if your module has side effects, such as starting a
    server, then `monkey-hot-loader` won't work that well with it. That won't be the
    case if there is a global state, but there really shouldn't be one if it's coded
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that when we change a module by taking `monkey-patch` and patch the
    original module with the updates.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore how patching top-level functions works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`monkey-hot-loader` is a Webpack loader that parses the JavaScript file and
    extracts all the names of the top-level functions in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following code, which we are placing in the
    `app.js` file but can be placed anywhere, as the code works globally and will
    affect top-level functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In respect to the previous example, the latest version of `monkey-hot-loader` currently
    only extracts the function names `foo` and `bar`, as only these functions can
    be patched. A few other types of functions could be made patchable, but let's
    keep things simple for now for the sake of explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The `foo` and `bar` functions can be patched by setting them to new functions.
    This is because they are top-level functions. When updated, the functions will
    be created in the same scope. It's then easy to inject new code there.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one real problem with that, concerning exporting the function:
    modules using the exported function would still be referencing the old variation. Quite
    a bit of work needs to be done to get around that, which we will go over now.'
  prefs: []
  type: TYPE_NORMAL
- en: The names of these functions are given to the runtime code that `monkey-hot-loader`
    appends to each module.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the module runs initially, it will iterate over these names and make each
    function patchable, and we do this by replacing it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `f` variable would reference the name `foo` if we were patching it.
    Note that the semantics of `patched` should be the same as the `f` variable. Any
    call to the `patched` variable should produce the same result as a call to `f`.
  prefs: []
  type: TYPE_NORMAL
- en: With the initial semantics of `foo` intact, we have installed a "hook" to perform
    a check to see whether there's a new version of the function to call. After all
    top-level functions are replaced with this variation, we can simply override any
    of them by loading a function into `patchedBindings`. Even exported functions
    will call the new variation.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the `monkey-hot-loader` implements this top-level function patching
    as an initial experiment. You may consider playing with it by using the `backend-with-webpack` project to
    see how to integrate it with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the context, a different heuristic may need to be adopted for patching.
    For instance, if your frontend uses **React**, most of your code will exist inside
    the **React** library components. The `react-hot-loader` works fantastically well
    for that. However, concerning your backend code, most of it might be classed with
    methods, in which case patching the method on the prototype works best for that.
  prefs: []
  type: TYPE_NORMAL
- en: React Hot Patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`react-hot-loader` works by binding the original module to any new code, whether
    it be functions, classes, or methods. It will patch all of the methods of **React**
    components to use the new methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question this leaves is how to patch the original module. Things will get
    extremely complicated if you try to accept an update. For instance, if you change
    code inside a closure, it becomes hard to patch the closure without losing the
    existing state. It may be achievable to use the **React** engine''s debugger API
    but to make this change throughout may be difficult: how difficult will depend
    greatly on your specific context.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when patching closures, only allowing very basic patching is best
    as it's intuitively easy to keep track of how everything works.
  prefs: []
  type: TYPE_NORMAL
- en: We often have to patch code when it's a complex and custom project. One tool
    that is very common with Webpack is an innate patching tool called `eval`. We
    will take a closer look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Eval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether it''s React Hot Patching or Monkey Hot Loader, we can install all these
    patch versions throughout the module''s scope using `eval`. After that, we save
    the scope of the module. This will only happen when the module runs for the first
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need the ability to alter code in this specific scope, we can do that
    by creating an `eval` proxy to maintain any state in the `app.js` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function is later passed to future variations of this module through the
    dispose handler.
  prefs: []
  type: TYPE_NORMAL
- en: While all of the aforementioned happened on the initial run of the module in
    question, consecutive updates through a different route. In this case, the entire
    module is evaluated again except iterating over each top-level binding, then a
    call is made to `func.toString()` to return the function code, then the code is
    reevaluated in the scope of the original module using `moduleEval`—to reference
    the original state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, this `eval` function is installed in `patchedBindings` so that it is
    used in any future calls made by the system, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In an ideal situation, we might get the source code of the module updated and
    avoid running the module since we just want the code in the form of a string anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, it is possible to avoid the whole `func.toString()` and `moduleEval`
    process and simply not support any global state, although the global state is
    very useful for debugging operations. This is especially true for interactions
    that are simple to **REPL** (**Read–Eval–Print Loop**). Classes, however, don't
    have this issue, insomuch that all of their states are part of the instance, which
    is why `react-hot-loader` works just fine without this hack.
  prefs: []
  type: TYPE_NORMAL
- en: For the uninitiated, a REPL is also known as an interactive top-level or language
    shell, which takes single user inputs and evaluates them.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that in Webpack 5, there are currently known problems with `eval()` that
    relate to `optimization.innerGraph` when in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: There is a hack available for `_eval`, and it's very useful to know. Let's get
    to that part now.
  prefs: []
  type: TYPE_NORMAL
- en: The __Eval hack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time for one last hack, and it is probably the biggest trick in this whole book! The
    `_eval()` function evaluates a string as an expression of a function. This can
    be used in conjunction with hot loading to allow an immediate evaluation of your
    code right across your project. This is essentially what the `_Eval` hack is.
    Let's explore it a little more now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want a REPL that evaluates code inside a module and to be able to open
    modules to choose which context to evaluate in, then we can''t do that with this
    infrastructure, but we can get most of the way there with the following example
    in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done and you define a function named  `__eval`, `monkey-hot-loader`
    will execute it every time the module updates. This is highly useful for instant
    feedback. With this approach, you could call some APIs and log the results, then
    work on those APIs on the fly until you see the results you want. That way, all
    you have to do is make some coding alterations, save the file, and then instantly
    see the updated output.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can use the code form `__eval` as a globally used script and allow
    the typical **HMR** system to run the module every time it's updated. This being
    said, any module with side effects will need specialist code. What's more, you
    can build a state across evaluations to play with or debug.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the old **Lisp** style of doing things (that is, select code and press
    *Ctrl *+ *E* to run), this technique is done per module, and you have the latitude
    to select a context to run the code in.
  prefs: []
  type: TYPE_NORMAL
- en: One consideration is that new variables cannot be introduced, such as changing
    a variable's value, using the `_eval` function in `strict` mode. This will also
    apply to `__eval`, so it's worth bearing in mind before you begin.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has taken you through some of the more advanced features that are
    possible with Webpack, such as library authoring and live coding hacks, using
    the `_Eval` technique with hot loading to allow instant feedback across your project.
    This has included detailed explanations and examples of how to customize loaders,
    and even patch top-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have an understanding of manual bundling and live coding, deep
    enough to parallel any expert. Why not demonstrate this know-how to yourself by
    taking the quiz at the very end of this chapter? It should stand you in good stead
    if you are ever put on the spot at job interviews or even presentations to major
    clients, to be able to quickly express your expertise.
  prefs: []
  type: TYPE_NORMAL
- en: This book as a whole has given extensive and comprehensive detail on both how
    to use Webpack competently and take your application development to completely
    new levels. This particular chapter will be increasingly important as your Webpack
    bundling develops, and you can be sure that this chapter specifically will be
    one bookmarked for many projects to come.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have tried the practice quiz questions, you may want to flip back to
    the start of the book and test yourself on each chapter. You will find the assessment
    answers in a separate chapter at the back of this guide. Successful completion
    will result in your expertise being beyond doubt, so give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can Webpack be used to bundle libraries as well as applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are external libraries excluded from the bundle when authoring libraries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Webpack offers four ways to expose a custom library. What are they?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why shouldn't absolute paths be used when building a custom module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the function prefix of `__eval` help with instant feedback?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why must a developer indicate the reading of external resources such as a filesystem
    by a loader?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are loaders executed when they are chained?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
