- en: Chapter 6. Cross-platform Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft platforms are not the only platforms that can execute C# code. With
    the Mono framework, you can target other platforms, such as Linux, Mac OS, iOS,
    and Android. In this chapter, we will explore the tools and frameworks needed
    to build a Mac app. Some of the tools we will look at here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MonoDevelop**: This is a C# IDE that lets you write C# on other non-Windows
    platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MonoMac**: This provides bindings to the Mac libraries so you can use native
    APIs from C#'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cocoa**: This is the framework used to create Mac apps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application we are going to build in this chapter is a utility that you
    can use to look for text on a website. Given a URL, the application will look
    for links and will follow them to look for specific trigger text. We will take
    a look at displaying the results using Mac OS' UI SDK, AppKit.
  prefs: []
  type: TYPE_NORMAL
- en: Building a web scraper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have C# experience and need to build an application or utility, Mono
    can give you a head start at creating it quickly, using existing skillsets. Let's
    say you have a need to keep an eye on a website so that you can act when a new
    post containing a given piece of text shows up. Rather than sitting there and
    refreshing the page manually all day, you want to build an automated system to
    do this. If the website does not provide an RSS feed or other API to give you
    programmatic access, you can always fall back on a tried and true method of getting
    remote data—writing an HTTP scraper.
  prefs: []
  type: TYPE_NORMAL
- en: It sounds more complex than it is, all that this utility will do is let you
    put in a URL and some parameters, so the app knows what to search for. Then, it
    will take care of going out to the website, requesting all of the relevant pages,
    and searching for your target text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the project. Open MonoDevelop and create a new project from
    the **File** | **New** | **Solution** menu item which brings up the **New Solution**
    dialog. In that dialog, choose **MonoMac Project** from the **C#** | **MonoMac**
    list on the left-hand panel. When you create the solution, the project template
    initializes it with the basics of a Mac application, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a web scraper](img/6761_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As with the web app we built in the previous chapter, Mac applications use the
    Model-View-Controller pattern to organize themselves. The project template has
    created the controller (`MainWindowControl`) and the view (`MainWindow.xib`);
    it is up to you to create the model.
  prefs: []
  type: TYPE_NORMAL
- en: Building the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary benefits of using something like MonoMac is the ability to
    share code across platforms, especially if you are already familiar with C#. Because
    we are writing C#, any common logic and data structures can be reused if we want
    to build a part of the same app for a different platform. By way of example, a
    popular app named iCircuit ([http://icircuitapp.com](http://icircuitapp.com)),
    which was written using the Mono framework, has been published for iOS, Android,
    Mac, and also Windows Phone. The iCircuit app achieved nearly 90 percent code
    reuse on some of the platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that this figure was not 100 percent is that one of the guiding principles
    that the Mono framework has been focusing on recently is building applications
    using native frameworks and interfaces. One of the main points of contention with
    cross platform toolkits in the past has been that they never feel particularly
    native because they are forced to settle for the lowest common denominator to
    maintain compatibility. With Mono, you are encouraged to use a platform's native
    APIs through C# so that you can take advantage of all of the strengths of that
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: The model is where you will be able to find the most reuse, as long as you take
    care to keep all platform-specific dependencies out of the model where possible.
    To keep things organized, create a folder, named `models`, in your project, which
    we will use to store all of our model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the Windows 8 application that we built in [Chapter 4](ch04.html "Chapter 4. Creating
    a Windows Store App"), *Creating a Windows Store App*, the first thing we want
    to do is provide the ability to connect to a URL and download data from a remote
    server. In this case, though, we just want access to the HTML text so that we
    can parse it and look for various attributes. Add a class, named `WebHelper`,
    to the `/Models` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the `WebRequest` class that we built in [Chapter 4](ch04.html
    "Chapter 4. Creating a Windows Store App"), *Creating a Windows Store App*, except
    that it simply returns the HTML string that we want to parse instead of deserializing
    a JSON object; and because the `Get` method will be carrying out remote I/O, we
    use the `async` keyword. As a rule of thumb, any I/O bound method that could potentially
    take more than 50 milliseconds to complete should be asynchronous. 50 milliseconds
    is the threshold used by Microsoft when deciding which OS-level APIs will be asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to build the backing storage model for the data that the user
    enters in the user interface. One of the things we want to be able to do for the
    user is save their input so that they don't have to re-enter it the next time
    they launch the application. Thankfully, we can take advantage of one of the built-in
    classes on Mac OS and the dynamic object features of C# 5 to do this in an easy
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The `NSUserDefaults` class is a simple key/value storage API that persists the
    settings that you put into it across application sessions. But while programming
    against "property bags" can provide you with a very flexible API, it can be verbose
    and difficult to understand at a glance. To mitigate that, we are going to build
    a nice dynamic wrapper around `NSUserDefaults` so that our code at least looks
    strongly typed.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure that your project has a reference to the `Microsoft.CSharp.dll`
    assembly; if not, add it. Then, add a new class file, named `UserSettings.cs`,
    to your `Models` folder and inherit from the `DynamicObject` class. Take note
    of the `MonoMac.Foundation` namespace being used in this class, as this is where
    the Mono bindings to the Mac's Core Foundation APIs reside.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We only need to override two methods, `TryGetMember` and `TrySetMember`. In
    those methods, we will use the `NSUserDefaults` class, which is a native Mac API,
    to get and set the given value. This is a great example of how we can bridge the
    native platform that we are running on while still having a C# friendly API surface
    to program against.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the astute reader will remember that, at the beginning of this chapter,
    I said that we should keep platform-specific code out of the model where possible.
    That is, as these things usually are, more of a guideline. If we wanted to port
    this program to another platform, we could just replace the internal implementation
    of this class to something appropriate for the platform, such as using `SharedSettings`
    on Android, or `ApplicationDataContainer` on Windows RT.
  prefs: []
  type: TYPE_NORMAL
- en: Making a DataSource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we are going to build the class that will encapsulate most of our primary
    business logic. When we talk about cross-platform development, this would be a
    primary candidate for code that would be shared across all platforms; and the
    better you are able to abstract your code into self-sustained classes such as
    these, the higher the likelihood that it will be reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, called `WebDataSource.cs`, in the `Models` folder. This
    class will be responsible for going out over the Web and parsing the results.
    Once the class has been created, add the two following members to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This list of strings will be what drives the user interface whenever we find
    a match in the website's source. In order to parse the HTML to get those results,
    we can take advantage of a great open source library called the **HTML Agility
    Pack**, which you can find on the CodePlex site ([http://htmlagilitypack.codeplex.com/](http://htmlagilitypack.codeplex.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: When you download the package and unzip it, look in the `Net45` folder for the
    file named `HtmlAgilityPack.dll`. This assembly will work on all CLR platforms,
    so you can take it and copy it right into your project. Add the assembly as a
    reference by right-clicking on the `References` node in the solution explorer,
    and choosing **Edit References** | **.NET Assembly**. Browse to the `HtmlAgilityPack.dll`
    assembly from the .NET Assembly table and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added this dependency, we can start writing the primary logic
    for the application. Remember, our goal is to make an interface that allows us
    to spider a website looking for a particular piece of text. Add the following
    method to the `WebDataSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Retrieve` method, which has the `async` keyword to enable you to wait an
    asynchronous operation, starts by instantiating the `UserSettings` class as a
    dynamic object so that we can pull out the values from the UI. Next, we retrieve
    the initial URL and load the results into an `HtmlDocument` class, which lets
    us parse out all of the links that we are looking for. Here is where it gets interesting,
    for each link, we retrieve that URL's content asynchronously and process it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might assume that, because you are waiting in the loop (with the `await`
    keyword), each iteration of the loop will execute concurrently. But remember that
    asynchrony does not necessarily mean concurrency. In this case, the compiler will
    rewrite the code so that the main thread is not held up while waiting for the
    HTTP calls to complete, but the loop will not continue iterating while waiting
    either, so each iteration of the loop will be completed in the correct sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implement the `ProcessPost` method, which takes the contents of
    a single URL and searches it using the regular expression provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the `WebDataSource` class completed, we have everything we need to start
    working on the user interface. This goes to show how a few good abstractions (`WebHelper`
    and `UserSettings`) and new features such as `async` and `await` can be combined
    to produce relatively complex functionality, all while maintaining a great performance
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: Building the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will build the second and third legs of the MVC triangle, the view,
    and the controller. Starting with the view is the next logical step. When developing
    Mac applications, the easiest way to build the UI is to use Xcode's interface
    builder, which you can install from the Mac App Store. MonoDevelop on the Mac
    is built to specifically interoperate with Xcode for building the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening `MainWindow.xib` from MonoDevelop by double-clicking on it.
    It will automatically open XCode with the file in the interface builder editor.
    The form will initially just be a blank window, but we are going to start adding
    views. Initially, the experience will be very familiar for anyone who has used
    Visual Studio's WYSIWYG editors for WinForms or XAML, but those similarities soon
    diverge.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not already displayed, bring up the **Utilities** panel on the right-hand
    side of the screen by clicking on the button shown in the following screenshot,
    which you can find in the top-right corner of Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/6761_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the object library and browse through the list of user interface elements
    that are available to you. For now, look for a Vertical Split View in the object
    library and drag it out to the editor surface, making sure to stretch it across
    the whole window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/6761_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This lets us build a simple UI that lets the user resize the various elements
    to whatever makes sense for him/her. Next, we will add the user-provided options
    as text field elements, with accompanying labels, of course, to the left-hand
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: This is the URL of the website that you want to scrape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Item Link XPath**: This is on the page retrieved with the URL. This XPath
    query should return a list of links that you are interested in scanning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content XPath**: For each item, we will retrieve the HTML contents based
    on the URL retrieved from **Item Link XPath**. In that new HTML document, we want
    to pick a content element that we will look at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trigger Regex**: This is a regular expression that we will use to indicate
    a match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also going to want a way to display the results of any matches. In order
    to do so, add a table view from the object library into the second right-hand
    panel. This table view, which is analogous to the grid controls of the regular
    .NET/Windows world, will give us a place to display our results in list format.
    Also add a push button that we will use to initiate our web call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once completed, your interface should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/6761_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the interface defined, we start looking to the controller. Exposing the
    individual view elements to the controller is something unique if you have never
    worked with Xcode before. Where other tools for other platforms tend to automatically
    generate code references to textboxes and buttons, in Xcode you must manually
    link them up to properties in your controller. You will be exposed to some Objective-C
    code for this, but only very briefly, and you don''t really have to do anything
    with it aside from the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the assistant editor and make sure that `MainWindowController.h` is
    showing in the editor. This is the header file for the controller that will interact
    with the view in our program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to add what are called **outlets** to the controller and connect them
    with the UI elements, so you can get references to them from code. This is accomplished
    by holding the *Ctrl* key on your keyboard, and clicking-and-dragging from the
    control textbox into the header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A small dialog, shown in the following screenshot, will be displayed, it lets
    you change a few options before the code is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/6761_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do that for all of the text views and give them appropriate names such as `urlTextView`,
    `linkXPathTextView`, `contentXPathTextView`, `regexTextView`, and `resultsTableView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you go to add the button, you will notice that you have an option to change
    the connection type to an **Action** connection instead of an **Outlet** connection.
    This is how you can wire up the button''s click event. When you have completed
    this, the header file should have the following elements defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Close Xcode and go back to MonoDevelop and take a look at the `MainWindow.designer.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that all of the outlets and actions that you added will be represented
    in the C# code. MonoDevelop watches the files on the file system, and when Xcode
    makes changes to them, it regenerates this code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we want the user's settings to persist between sessions. So when
    the window loads, we want to initialize the textboxes with whatever values were
    entered previously. We will use the `UserSettings` class that we created earlier
    in the chapter to provide those values. Override the `WindowDidLoad` method (as
    shown in the following code), which is executed when the program first runs, and
    set the values from the user's settings to the text views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we turn our attention to the displaying of data. Our primary output in
    this application is `NSTableView`, which we are going to use to display any matching
    links in the target URL. In order to bind data to the table, we create a custom
    class that inherits from `NSTableViewSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The table view will request a row's data in the `GetObjectValue` method whenever
    it needs to render a given table cell. So this just takes an array of strings
    and returns the appropriate index from the array when requested.
  prefs: []
  type: TYPE_NORMAL
- en: Now we define the method that quite literally puts everything together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the `GetData` method, the first thing we do is pull the values from the textboxes
    and store them in the `UserSettings` object. Next, we retrieve the data from `WebDataSource`,
    asynchronously of course. Now, pass the results to `TableViewSource` so that it
    can be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, implement the `buttonClicked` action that you wired up in Xcode.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now run the program and put in some values for a web page you want to search
    through. You should see results like those shown in the following screenshot,
    you can try to use the same values as well, but please note that it will not work
    if Hacker News has updated their HTML structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the view](img/6761_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we created a small utility application for Mac OS, using MonoMac
    and MonoDevelop. Some ideas that you can use to extend or improve this application
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Persist results across app sessions (look at Core Data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build better user experience by giving the user feedback while processing (look
    at `NSProgressIndicator`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the application's performance by parallelizing URL requests (look at
    `Parallel.ForEach`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try porting the application to different platforms. For iOS, look at MonoTouch
    ([http://ios.xamarin.com](http://ios.xamarin.com)), and for Android, look at Mono
    for Android ([http://android.xamarin.com](http://android.xamarin.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# is an incredibly expressive and powerful language. With the ability to target
    every mainstream computing platform, you have an incredible array of opportunities
    available to you as a developer, all while using a consistent programming language
    where you can re-use code easily across platforms.
  prefs: []
  type: TYPE_NORMAL
