- en: Chapter 9. Bootstrap your Application with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we shall see another Spring package—Spring Boot, which allows
    users to quickly get started with the Spring Framework. Applications that make
    use of **Spring Boot Abstraction Layer** are called **Spring Boot Applications**.
    Spring has come up with a Spring intializer web application, which has a web interface,
    in which we can select the kind of application we would need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever run with different application servers, new developers typically
    have to configure many settings just to get up and run. The Spring Boot approach
    allows developers to get up and run right out of the box, allowing them to focus
    on developing code and not configuring application servers.
  prefs: []
  type: TYPE_NORMAL
- en: Spring has also come up with a command line interface to help us quickly start
    with Spring development. In this chapter, let's dive into Spring Boot and see
    what it offers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Boot application can be set up in the following mentioned ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use [http://start.spring.io/](http://start.spring.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Maven to download the dependency from repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download source code from Spring guide repo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download Spring STS and use the starter project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Gradle MVC application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gradle** is similar to Maven; it helps in building the applications. We need
    to provide all the dependency information in the `build.gradle` file. Spring boot
    also has a Gradle plugin. The Gradle plugin helps in placing all the dependencies
    JAR files on the classpath and finally builds into a single runnable JAR file.
    The runnable JAR file will have an `application.java` file; this class will have
    a `public static void main()` method. This class will be flagged as a runnable
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample Gradle file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you are using an Eclipse as IDE, STS has come up with Gradle pulgins for
    Eclipse ([http://gradle.org/docs/current/userguide/eclipse_plugin.html](http://gradle.org/docs/current/userguide/eclipse_plugin.html))
    which can be downloaded and installed from [https://www.gradle.org/tooling](https://www.gradle.org/tooling).
    Gradle also comes with a similar set up to clean and build the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to define the application context root in the properties file.
    A Gradle project structure is similar to a Maven project structure. Place the
    `application.properties` file in the `resources` folder. We need to provide the
    server context path and server context port. Following is the sample properties
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a simple package: `com.packt.controller`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple Spring controller class in the package and use the @ Controller
    annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us create a method with `@Request` mapping annotations. The `@RequestMapping`
    annotations maps send a request to a JSP page. In this method, we are mapping
    the request to the methods. The methods return a string variable or a model view
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Create a Spring MVC configuration file as follows using `@Configuration` and
    `@WebMVC` `annotation`. We have also configured the internal view resolver for
    the application file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a simple JSP page named `greet.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next create a simple application class with annotations `@EnableAutoConfiguration`
    and `@ComponentScan` annotations. The `@ComponenetScan` annotation indicates that
    the Spring Framework core should search for all of the classes under the package.
    The `@EnableAutoConfiguration` annotation is used instead of configuring dispatcher
    servlet in `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the sample file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Access the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/PacktSpringBootMVCDemo/saygoodmorning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/PacktSpringBootMVCDemo/saygoodafternoon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/PacktSpringBootMVCDemo/saygoodnight`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot swapping with Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hot swapping or hot deployment means that you can make changes to the class
    file or any file in the application, and see the changes reflected in the running
    application immediately. We may need to reload the application on the web browser
    or just refresh the page. Spring Loaded is a dependency JAR file that supports
    hot deployment. Let us look at hot swapping in the Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple Spring MVC application with the Thymeleaf template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to download the Spring Loaded JAR from GitHub repositories.
    Check the following URL for the latest version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/spring-projects/spring-loaded](https://github.com/spring-projects/spring-loaded).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you have all the mentioned dependencies in a `pom.xml` file or
    explicitly add them to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the downloaded Spring loaded JAR to the Eclipse or
    Eclipse STS environment. Follow the given steps to add Spring loaded JAR as a
    run time configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `PacktSpringBootThymeLeafExample` project in Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right Click on your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for **Run As**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Run Configuration**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Java Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Project Name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Arguments** in the **VM Argument** section; add the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Click on **Apply** and **Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need to configure the `application.properties` file, so that any modifications
    done to **Thymeleaf** pages don''t need a server restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the Spring STS starter project and create a Spring Boot class. Spring
    Eclipse STS will give us the following two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationTest.java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Application.java` is the main class for Spring Boot, as it has the public
    static void main method in it. In this method, `ApplicationContext` is initialized
    in it using `SpringApplication` class. The `SpringApplication` class has some
    of the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ConditionalOnClass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ConditionalOnMissingBean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are executed to check the list of beans available on the classpath. If
    you would like to see the beans placed under the classpath by the framework, make
    a slight modification to the generated `Application.java` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `SpringApplication` class is found in the package `org.springframework.boot.SpringApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple illustration of `SpringApplication` class is shown here, where the
    static run method of the `SpringApplication` class is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at another illustration here, where a `SpringApplication` class is first
    initialized and then the `.run` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the constructors available for the `SpringApplication` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SpringApplication(Object... sources)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SpringApplication(ResourceLoader resourceLoader, Object... sources)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us create a Simple Controller class with the `@RestController` annotation
    that is available in Spring's latest version 4.x.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we shall configure Spring Boot to process JSP pages; by default Spring
    Boot doesn''t configure the JSP, so we shall create a JSP controller as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the properties files as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let us create a JSP file `myjsp:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Following is the implementation class of `EmbededServletContainerCustomizer`,
    which actually embeds the web server container in the application. It invokes
    the server and deploys the application into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Integrating Spring Boot with Spring Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we shall see how we can integrate Spring boot with Spring security
    using annotations. We can easily integrate Spring security with Spring boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first embed a tomcat server in Spring boot to accept a request; following
    is the code we need to create a key store file to make it more secure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let us also create a Simple Security Configuration file in java using `@Configuration`
    and `@EnableWebMVCSecurity` annotations. The security configuration file extends
    `WebSecurityConfigurerAdapter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Cloud Foundry support for Eclipse Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's see how we can develop applications on Cloud Foundry
    using Spring boot. **Cloud Foundry** is a platform that is used as a service cloud
    application. It is an open Paas. Paas makes it feasible to run deploy, and run
    an application on cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the following link, which gives the complete information of the Spring
    platform that is available as service and how we can configure Spring to work
    with Cloud Foundry. You will see that it offers Platform as a service from MongoDB
    to RabbitMQ Messaging Server.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.cloudfoundry.org/buildpacks/java/spring-service-bindings.html](http://docs.cloudfoundry.org/buildpacks/java/spring-service-bindings.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse has also come up with a plugin for cloud foundry which can be downloaded
    and installed from the following given location. The plugin supports Spring boot
    and grails application. You can also create a server instance to a private cloud
    that uses a self signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/cloudfoundry/eclipse-integration-cloudfoundry](https://github.com/cloudfoundry/eclipse-integration-cloudfoundry)'
  prefs: []
  type: TYPE_NORMAL
- en: All that we need to do is develop a simple boot application, and drag and drop
    it into the cloud foundry server, then restart the server.
  prefs: []
  type: TYPE_NORMAL
- en: RestfulWebService using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's develop a simple restful service and bootstrap the application
    using `SpringBoot`. We will also create a simple restful service that will store
    the product information into the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Product creation scenario should satisfy the following mentioned use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Given that no product with the same `Product_id` exists, it should store a new
    product in the database and immediately return the stored object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given there exist a product with the same `Product_id`, it should not store,
    but return an error status with the relevant message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given there are previously stored products, it should be able to retrieve the
    list of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following is the of `pom.xml` file, for the dependency reference used in the
    application. You can see that we have used the parent Spring boot reference here,
    so that we can resolve all the dependency references. We have also set that Java
    version as 1.7 in the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's see the dependencies used in the `pom.xml` file. Following is the Spring
    boot dependencies used. Also, observe that the version information is not specified,
    since it is managed by the previously mentioned `spring-boot-starter-parent`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall also see why these dependencies are used for Spring boot. When it
    comes to Spring boot, its functions are spread between the starter modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-boot-starter`: This is the main core module of Spring boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-test`: This has some tools for unit testing, including
    JUnit4 and Mockito'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-web`: This pulls Spring MVC dependencies, but also Jackson
    which will be used for JSON, and most importantly Tomcat, which acts as an embedded
    Servlet container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-boot-starter-data-jpa`: This is used for setting up Spring Data JPA,
    and comes bundled with Hibernate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Guava`: It uses `@Inject` annotation instead of `@Autowired`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, add a Spring boot Maven plugin as follows. The functionalities of the
    `spring-boot-maven` plugin are, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a `spring-boot:run` goal for Maven, so the application can be easily
    run without packaging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It hooks into a package goal to produce an executable JAR file with all the
    dependencies included, similar to a `maven-shade` plugin, but in a less messy
    way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have looked at the dependencies and its functions, now let us start
    framing the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bean Class or Entity Class**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a simple `Product.java` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next create a `Jparepository` subinterface; we do not need to provide any implementation
    for this, since it gets handled by Spring JPA data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Service class**:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a service interface which handles the save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also create an implementation class for the service interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we shall also create a test class for the service `Impl`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a controller using the `@RestController` annotations; also observe
    that we used the `@Inject` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@RestController`: The difference between this and the `@Controller` annotation
    is that the former also implies `@ResponseBody` on every method, which means that
    there is less to write, since from a restful web service we are returning JSON
    objects anyway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@RequestMapping`: This maps the `createProduct()` to the `POST` request on
    the `/Product` URL. The method takes the product object as a parameter. It is
    created from the body of the request thanks to `@RequestBody` annotation. It is
    then validated, which is enforced by `@Valid`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Inject:` The `ProductService` will be injected to the constructor, and the
    product object is passed to its `save()` method for storage. After storing, the
    stored product object will be returned. Spring will convert it back to JSON automatically,
    even without `@ResponseBody` annotation, which is default for `@RestController`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a `Main` class with `public static void main()`. Let us also
    use these annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Configuration` - This tells the Spring Framework that it is a configuration
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan` - This enables the scanning of packages and subpackages for
    Spring Components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class further extends `SpringBootServletInitializer`, which will configure
    the dispatcher servlet for us and override the `configure` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the application using Maven and Bootstrap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that now you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And see whether the response from http://localhost:8080/ will be like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have demonstrated the process of using Spring boot to Bootstarp
    applications. We started with setting up a simple Spring boot project. We have
    also created a simple MVC application with Gradle support. Next, we discussed
    hot swapping java files using Spring boot.
  prefs: []
  type: TYPE_NORMAL
- en: We have also given information as to how Spring boot supports the cloud foundry
    server and helps to deploy applications on cloud. Lastly, we have demonstrated
    a restful application with Spring boot.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about Spring caching.
  prefs: []
  type: TYPE_NORMAL
