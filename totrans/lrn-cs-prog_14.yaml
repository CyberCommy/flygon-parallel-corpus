- en: '*Chapter 14*: Error Handling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, managing runtime errors has always been a hard problem to solve
    because of their complex and different natures, spanning from hardware failures
    to business logic errors.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these errors, such as *division by zero* and *null dereferencing*, are
    generated by the CPU itself as an exception, while others are generated at the
    software level and propagated either as an exception or as an error code, depending
    on the runtime and programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET platform has been designed to manage an error condition through an
    exception strategy, which has the big advantage of dramatically simplifying the
    handling code. This means that any property or method may throw an exception and
    communicate the error condition through exception objects.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions raises an important question—*is the exception part of the
    contract between the library implementor and its consumer, or is it, rather, an
    implementation detail?*
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will start analyzing the language syntax needed to participate
    in the exception model either from a producer or consumer perspective. However,
    we will also need to go beyond the syntax, analyzing the implications for the
    developer seeking to debug the causes and the design problems related to both
    the error-throwing and error-handling sides. The following three sections of this
    chapter will cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and monitoring exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this chapter, you will be able to catch exceptions from existing
    libraries, understand whether a method should return a failure code or throw an
    exception, and create custom exception types whenever it makes sense to.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, the two strategies used to manage errors are `winerror.h`
    file, even if they are both parts of the Windows operating system. In other words,
    error codes are not part of a standard and they need to be translated when the
    call traverses a boundary, such as a different operating system or runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect of error codes is that they are part of the method
    declaration. For example, it feels very natural defining the division method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the denominator is `0`, we should communicate the invalid parameter
    error to the caller. Adopting error codes has a direct impact on the method signature,
    which in this case would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This last signature (which returns an error code of type integer) is not as
    neat as any library user would expect. Also, the calling code has the responsibility
    of determining whether the operation was successful or not, which opens up multiple
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first problem is the complexity of the code checking for the error code,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that `0` is the success code, the code inside each block must be indented,
    creating an annoying and confusing triangle as large as the number of called methods.
    Even by reversing the logic and checking the failure condition, the situation
    does not improve because of the number of `if` statements that must be in place
    to avoid nasty bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code also shows a common situation where the `api.End()` method
    returns an apparently useless error code as it *ends* the sequence of calls while
    it could be required to handle it. This problem arises because the error codes
    leave the caller the responsibility to decide on the importance of the error severity.
    One of the advantages of the exceptions model is that it instead gives this power
    to the called method, which can *enforce* the severity of the error. This definitely
    makes more sense, as the severity is likely to be implementation-specific.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code also hides a potential performance issue due to the characteristic
    of modern CPUs providing a feature known as **branch prediction**, which is a
    sort of guess made by the CPU when pre-loading the instructions following a jump.
    Depending on many factors, the CPU may pre-load *one* path, making the others
    run slower because their code was not prefetched.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as far as the type member properties are designed in all modern languages,
    they don't fit with the error codes because there is no syntax allowing the caller
    to be made aware of the error and so using an exception is the only way to communicate
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: For all these reasons, when the .NET runtime was initially designed, the team
    decided to embrace the exception paradigm, which treats any error condition as
    *out-of-band information* and not a part of the method signature.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are a mechanism provided by the runtime to make the execution suddenly
    interrupt and jump to the code handling the error. Since the handler may have
    been declared by any caller in the calling path, the runtime takes care of restoring
    the stack and any other outstanding `finally` block, which we will examine in
    the *The finally block* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The calling code may want to handle the exception and if it does, it may decide
    to resume normal execution or just let the exception continue to the other handlers
    (if any). Whenever no handling code is provided by the application, the runtime
    catches the error condition and does the only reasonable thing—it terminates the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us back to the original question that we asked in the introduction—*is
    the exception part of the contract between the library implementor and its consumer,
    or is it rather an implementation detail?*
  prefs: []
  type: TYPE_NORMAL
- en: Since the implementor communicates an anomaly to its callers through exceptions,
    it looks like the exception is a part of the contract. At least this has been
    the conclusion of other languages' implementors, including Java and C++, which
    gave the ability to specify the list of possible exceptions generated in the method.
    Anyway, the most recent C++ standards deprecated and later removed the exception
    specification in the declaration, leaving just the ability to specify whether
    a method may throw an exception or not.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET platform decided not to tie exceptions to the method signature because
    it is considered an implementation detail. In fact, multiple implementations of
    the same interface or base class may use different technologies throwing different
    exceptions. For example, when you create a proxy to an object, you may require
    different types of exceptions to be thrown in addition to the ones declared in
    the proxied object.
  prefs: []
  type: TYPE_NORMAL
- en: Since exceptions are not a part of the signature, the .NET platform defines
    a base class called `System.Exception` for all the possible exceptions. This type
    is effectively part of the contract bounding the consumers (the callers) to the
    producers (the called methods).
  prefs: []
  type: TYPE_NORMAL
- en: The .NET runtime is, of course, the subject hooking the exception and taking
    care of executing the matching handler. For this reason, the exceptions are only
    valid in the .NET context and every time you cross the boundary, either with a
    `Win32Exception` and `COMException`, derived from `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, the exception model is the universal panacea for managing errors,
    but there's still a very important aspect to consider—the *performance aspect*.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process of capturing the exception, unwinding the stack, calling the
    relevant `finally` block, and the execution of other necessary infrastructural
    code takes time. From this perspective, there is no doubt the error codes are
    far more performant, but this is payback for all the advantages we already mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about performance, it must be measured, which in turn depends on
    whether the given performance-impacting code is run often or not. In other words,
    if the use of exceptions is *exceptional*, it will not affect the overall performance.
    For example, the `System.IO.File.Exists` method returns a Boolean telling us whether
    the file exists on the filesystem. However, this does not throw an exception because
    not finding a file is not an exceptional case and throwing an exception could
    severely hit performance when called repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now get our hands on the code by examining the statements needed to handle
    exceptions. As you go through the following sections, you will notice that we
    briefly introduced some of these concepts in [*Chapter 3*](B12346_03_Final_JC_ePub.xhtml#_idTextAnchor074),
    *Control Statements and Exceptions*, when we talked about exception handling.
    In this chapter, we will cover these topics in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a general rule, it is always better to avoid errors before an exception gets
    thrown. For example, validating input parameters from the presentation layer is
    your best chance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before trying to open and read a file, you may want to check for its existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But this check does not protect the code from other possible errors because
    the filename may contain a forward slash (`/`), which is forbidden in both Windows
    and Linux operating systems. It would not make sense to try sanitizing the filename
    because other errors may happen while accessing the filesystem, such as a wrong
    path or damaged media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever the error occurs and cannot be easily prevented, the code must be
    protected with the proposition offered by the C# language: the `try` and `catch`
    block statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet demonstrates how to protect `File.ReadAllText` from any
    possible error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `try` block surrounds the code we want to protect. Therefore, any exception
    thrown by `File.ReadAllText` would cause the execution to immediately stop (`content.Length`
    would not be executed) and jump to the matching catch handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `catch` block must immediately follow a `try` block and specify the code
    that must be executed only in case the exception being thrown matches the type
    specified inside the round brackets.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is able to catch any error in the `catch` block since
    `Exception` is the *base class for the hierarchy* of all the exceptions. But this
    is not necessarily a good thing because you may want to recover from specific
    exceptions while leaving the responsibility for other failures to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: Most of the problems related to the filename can be avoided by adding a check
    with `File.Exists`, but we omitted it on purpose in order to have a wider choice
    of possible exceptions in our sample.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet may fail with providing different values for the filename.
    For example, if `filename` is null, `ArgumentNullException` is thrown from the
    `File.ReadAllText` method. If instead `filename` is `/`, then it gets interpreted
    as an access to the root drive, which requires administrative privileges and so
    the exception would be `System.UnauthorizedAccessException`. When the value is
    `//`, then `System.IO.IOException` is thrown because the path is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it can be useful for making different decisions depending on the exception
    types, the C# syntax provides the ability to specify multiple `catch` blocks,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The official .NET class library documentation contains an *Exceptions* section
    for any member that can throw an exception. If you use Visual Studio and hover
    over an API with your mouse cursor, you will see a tooltip showing a list of all
    the possible exceptions. The following screenshot shows the tooltip for the `File.ReadAllText`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – A tooltip showing the exceptions for the File.ReadAllText method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – A tooltip showing the exceptions for the File.ReadAllText method
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now imagine that `filename` specifies a nonexistent file: what is going
    to happen in this code? According to the tooltip exception list, we can easily
    guess that a `FileNotFoundException` exception will be thrown. The class hierarchy
    for this exception is `IOException`, `SystemException`, and of course `Exception`,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two catch blocks satisfying the match—`IOException` and `Exception`—but
    the first wins because the `catch` block order is very important. If you try to
    reverse the order of those blocks, you will get a compilation error and get feedback
    in the editor because this would result in unreachable `catch` blocks. The following
    example shows the red squiggle generated by the Visual Studio editor when a `catch(Exception)`
    is specified as the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – The editor complains when catch (Exception) is the first exception
    used'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – The editor complains when catch (Exception) is the first exception
    used
  prefs: []
  type: TYPE_NORMAL
- en: 'The error emitted by the compiler is `CS0160`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The examples we have seen show how to catch an exception in the same method.
    But the power of the exception model is its ability to walk back through the call
    chain to find the most appropriate handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we have two different methods where we appropriately
    handled `ArgumentNullException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Even if the `try..catch` blocks are already declared in these two methods, whenever
    `IOException` occurs, those handlers are not invoked. The runtime instead starts
    looking for a compatible handler in the caller chain. This process, entirely managed
    by the .NET runtime, is called **stack unwinding** and consists of jumping away
    from the call to the first compatible handler in the callers, whose return address
    is retrieved from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `try..catch` blocks intercept `IOException`,
    which could be thrown by the `ReadAllText` or `WriteAllText` APIs used by the
    `ReadTextFile` and `WriteTextFile` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of how deep the call stack is, the `try..catch` blocks will protect
    this code from any case of `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: Through all the preceding examples, we have learned how to distinguish the exception
    type, but the `catch` block receives an object of that type providing contextual
    information about the nature of the exception. Let's now take a look at the exception
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The exception objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the exception type, the `catch` block syntax may specify the
    name of the variable, referencing the caught exception. The following example
    shows a method for computing the length of the content string for all the specified
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Every time we open a file without previously using `File.Exists` to avoid the
    exception, we may receive `FileNotFoundException`. This object is a specialization
    of `IOException` and exposes a `Filename` property, providing the filename that
    can't be found. I cannot even remember the number of times I wished to get such
    feedback from faulty applications!
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: We will see in more detail the base exception members in the *Debugging and
    monitoring* section, but you can already start investigating the properties exposed
    by the multitude of exceptions thrown in the base class library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows another interesting example while catching `ArgumentException`—an
    exception occurring when the argument fails the validation from the method that
    is using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `catch` block intercepts the fault for both the `source` and `target` parameters.
    Any error related to the `source` parameter validation should bounce back to the
    caller, while the `target` parameter is computed locally.
  prefs: []
  type: TYPE_NORMAL
- en: How can we just catch the ones we are interested in? The answer lies in a language
    feature that was introduced in C# 6.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `catch` block may optionally specify a `when` clause to restrict the scope
    of the handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is very similar to the previous one, but it restricts
    the `catch` block to just hook `ArgumentException`, whose `ParamName` is `"destFileName"`,
    which is the name of the second parameter of the `File.Copy` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `when` clause accepts any valid Boolean expression and should not necessarily
    use the exception object specified in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that in this example, we have used the `"destFileName"` string
    to specify the second argument of `File.Copy`. If you use Visual Studio, you can
    see the argument names by positioning the caret over the desired parameter and
    using the shortcut *Ctrl* + *Shift* + *spacebar*, which shows the following suggestion
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – The suggestion window shown by the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – The suggestion window shown by the editor
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to jump to the producer side to see how we can throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use an API that already provides the required parameter''s validation,
    you may decide not to validate the parameter and eventually throw an exception.
    In the following example, we open a log file, giving its name specified by `logName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The decision to validate `logName` for a null or empty string does not provide
    any value because the called method already provides a validation that takes into
    consideration more cases, such as invalid paths or nonexistent files.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `logName` parameter may express different semantics, specifying the
    name of the log rather than the filename to write on disk (if any). The solution
    for reconciling the two possible meanings is to add the `".log"` extension if
    it is not already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This makes more sense, but `logName` can be `null`, causing a `NullReferenceException`
    exception on the highlighted code, which would make troubleshooting harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this problem, we can add the `null` parameter validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `throw` statement accepts any object derived from an exception and immediately
    interrupts the execution of the method. The runtime hooks the exception and dispatches
    it to the appropriate handler, as we have already investigated in the previous
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please note the use of `nameof(logName)` to specify the name of the offending
    argument. We used this parameter in the previous section while catching the exceptions
    from the `File.Copy` method. Make sure to never specify the name of the argument
    as a literal. Using `nameof()` guarantees that the name is always *valid* and
    avoids problems during refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `throw` statement is very simple but please remember to use it only for
    exceptional cases; otherwise, you may incur performance problems. In the following
    example, we compare two loops using the popular `Benchmark.NET` micro-benchmark
    library. The one in the `LoopNop` method executes code that never throws while
    the other one inside `LoopEx` throws at each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `LoopNop` method just loops over the `Nop` empty method 1,000 times. The
    `Nop` method is marked as `NoInlining` to avoid any compiler optimization in removing
    the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method performs the same loop 1,000 times, but calls the `Crash`
    method, which just throws at each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Crash` method creates a new exception every time, which is a realistic
    usage of the exception object. But even when reusing the same object every time,
    the performance hit of the exception model is huge.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of the benchmark is to get an idea about the *orders of magnitude*
    affecting the use of exceptions, which in our example is four orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output shows the outcome of the benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This benchmark just demonstrated that throwing exceptions must be only used
    for exceptional cases and should not raise any doubts on the validity of the exception
    model.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen some of the exception types provided in the base class library.
    Now, we will take a look at the most common exceptions and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Common exception types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The exceptions available in the base class library express the semantics for
    the most popular categories of faults. Among all the exceptions provided in the
    base class library, it is worth mentioning the ones that are most often used by
    developers. Throughout this chapter, we have already seen other popular exceptions,
    such as `NullReferenceException`, but they are generally only thrown by the runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArgumentNullException`: This is generally used at the beginning of a method
    when validating the method parameters. Since reference types may assume the null
    value, it is used to inform the caller that null is not an acceptable value for
    the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ArgumentException`: This is another exception used at the beginning of a method.
    Its meaning is wider and is thrown when the parameter value is not valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvalidOperationException`: This is commonly used to reject the method invocation
    every time the state of the object is not valid for the action requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormatException`: This is used by the class library to signal a badly formatted
    string. It can also be used in user code that is parsing text for any other purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IndexOutOfRangeException`: This is used every time a parameter points outside
    of the expected range of a container, such as an array or a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotImplementedException`: This is used to inform the caller that no implementation
    is available for the called method. For example, when you ask Visual Studio to
    implement an interface inside the class body, the code generator generates the
    properties and methods throwing this exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeLoadException`: You may rarely need to throw this exception. It usually
    occurs when a type cannot be loaded in memory. It is common whenever an exception
    occurs inside a static constructor and, unless you happen to remember this note,
    you may have a hard time diagnosing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exhaustive list of all the exceptions of the base class library can be found
    in the `Exception` class documentation ([https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1)).
  prefs: []
  type: TYPE_NORMAL
- en: When deciding to throw an exception, it is very important to use one that fully
    expresses the semantics of the error. Every time you cannot find an appropriate
    class in .NET, it is more appropriate to define a custom exception type.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom exception type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining an exception type is as easy as writing a simple class; the only requirement
    is inheriting from an exception type such as `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code declares a custom exception used to express a failure in
    the data layer of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding custom exception class defines three constructors because they
    are meant to provide a homogeneous experience when the developer constructs them:'
  prefs: []
  type: TYPE_NORMAL
- en: The default constructor might exist whenever you don't need to build an exception
    with additional parameters. In our case, we allow the building of the exception
    object with a null `QueryKeyword` by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor taking the `message` parameter is important in expressing any
    human information that may simplify the diagnostics. The message should provide
    diagnostic information only and is never intended to be shown to the end user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor taking the inner exception is valuable in providing additional
    information about the underlying exception, if any, that caused the current error
    situation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the new custom exception is defined, it can be used in conjunction with
    the `throw` statement. In the following example, we see some hypothetical code
    making a query to a repository and converting the underlying error condition into
    our custom exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The exception being caught is passed to the constructor as an argument in order
    to preserve the original cause of the error, while still throwing the custom exception
    that better represents the nature of the error.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing inside the `catch` block brings to light an architectural issue on
    the semantics of the error. In the previous example, we can't recover the error,
    but we still want to catch it because the repository being queried may be very
    different depending on the installation of our application. For example, if the
    repository is a database, the inner exception would be related to *SQL Server*,
    while if it was the filesystem, it would be `IOException`.
  prefs: []
  type: TYPE_NORMAL
- en: If we want the higher levels of the application to be able to treat the error
    appropriately and give them a chance to recover the error, we need to abstract
    the underlying error and provide a business-logic exception such as the `DataLayerException`
    that we defined.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Framework originally defined `ApplicationException` as the base class
    for all the custom exceptions. Since there was no enforcing, the base class library
    itself never adopted this best practice widely. For this reason, the current best
    practice is deriving all the custom exceptions from `Exception`, as you can read
    in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1)'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to throw from inside the `catch` block is not limited to custom
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just seen how to throw a new exception within a `catch` block, but there
    is an important shortcut that rethrows the same exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `catch` block is typically used to try to recover the error or just to
    log it. In both cases, we may want to let the exception continue as if it were
    not caught at all. The C# language provides a simple use of the `throw` statement
    for this case, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `throw` statement is not followed by any parameter, but it is the equivalent
    of specifying the same exception received in the `catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unless the `err` reference is changed to point to a different object, the two
    statements are equivalent and have the big advantage of preserving the original
    stack that caused the error. Anyway, we are still able to add more information
    to that exception object (the `HelpLink` property is a typical example).
  prefs: []
  type: TYPE_NORMAL
- en: If we throw a different exception object, the original stack is not a part of
    the exception being thrown, and this is the reason why `innerException` exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain cases, you may want to save the exception captured by the `catch`
    block and rethrow it later. By simply throwing the captured exception, the captured
    stack would be different and less useful. If you need to preserve the stack where
    the exception was initially captured, you can use the `ExceptionDispatchInfo`
    class, which provides two simple methods. The `Capture` static method takes an
    exception and returns an instance of `ExceptionDispatchInfo` that includes all
    the stack information at the moment of the `Capture` call. You can save this object
    and later throw the exception along with the original stack information using
    its `Throw` method. This pattern is shown in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling a method that throws an exception, which is then caught
    in the `catch` clause. We store a reference to this exception captured with a
    call to the static `ExceptionDispatchInfo.Capture` method, which helps preserve
    the call stack. At the end of the method, we rethrow the exception with a call
    to the `Throw` method of `ExceptionDispatchInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: The finally block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `finally` block is the last C# statement related to *exception management*.
    It is extremely important because it allows expression of the portion of code
    that must be invoked after the `try` block, regardless of whether an exception
    has occurred or not.
  prefs: []
  type: TYPE_NORMAL
- en: Over the previous sections, we have seen how the execution of code behaves depending
    on whether an exception occurs or not. The execution of the code inside a `try`
    block may be interrupted by an outstanding exception skipping portions of that
    code. As soon as an error occurs, we have the guarantee that a matching `catch`
    block will be executed, giving it the opportunity to write the problem to the
    log and maybe execute some recovery logic.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` block can be specified even without any `catch` block, meaning
    that any exception will be bounced back to the call chain, but the code specified
    inside the `finally` block will be executed in any case right after the `try`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows three methods whose calls are *nested*. The first
    method, `M1`, calls `M2`, which calls `M3`, which calls `Crash`, which finally
    throws an exception, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we invoke `M1` and the call chain reaches `Crash`, there is no `catch`
    block in `M3` to handle the exception, but its `finally` block is invoked *before*
    leaving the method. At this point, the runtime bounces back to the `M2` caller,
    which catches the exception but also invokes its `finally` code. Lastly, as the
    exception has been handled, `M2` naturally returns the control to `M1` and its
    `finally` code is executed as well, as in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can repeat this experiment by adding extra-verbose logging to the `try`
    blocks if you wish, but the point here is that the `finally` block is *always
    executed* right *before leaving* the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common use for the `try..finally` combo is to ensure that a resource
    has been correctly disposed, and C# has made of this pattern a keyword, which
    is the `using` statement. The following example shows two equivalent snippets.
    The IL code generated by the C# compiler is substantially the same, as you can
    test for yourself using the `ILSpy` tool by decompiling in IL language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the `using` statement limits its usage to objects implementing the
    `IDisposable` interface, but it generates the same pattern. This is a topic that
    we looked at in depth in [*Chapter 9*](B12346_09_Final_JC_ePub.xhtml#_idTextAnchor173),
    *Resource Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen all the aspects of exceptions, both from a consumer and
    producer perspective, we will discuss the diagnostic investigation of problems
    related to exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and monitoring exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging exceptions is a bit different compared to debugging normal code because
    the natural flow gets interrupted and handled by the runtime. Unless you put a
    breakpoint on the code that handles the exception, there is a risk of not understanding
    where exactly the problem started. This can happen when an exception is caught
    and not re-thrown or if the method does not re-throw within the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem like an important downside of the exception model, but the .NET
    runtime provides all the necessary support to overcome this issue. In fact, the
    runtime has built-in support for the debuggers, providing valuable hooks to the
    debugger willing to intercept the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a debugger perspective, you have two possibilities, or *chances*, to intercept
    any exception being thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First-chance** **exceptions** represent the exceptions at a very early stage,
    as soon as they are thrown and before jumping to their handlers, if any. The advantage
    of intercepting an exception (in a first-chance state) is that we can identify
    precisely which code has caused an exception. Conversely, the intercepted exception
    may be legitimate and handled correctly. In other words, the debugger will stop
    any exception occurring, even those that are not causing any trouble. By default,
    the debugger never stops when a first-chance exception occurs, but it prints a
    trace in the debugger output window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second-chance** or **unhandled** **exceptions** are the fatal ones. These
    mean that the .NET runtime did not find any suitable handler to manage them and
    calls the debugger before forcibly closing the application that is crashing. The
    debugger always stops when a second-chance exception occurs, which always represents
    a bug condition. Second-chance exceptions are printed in the output window and
    presented in the exception dialog as unhandled exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the default settings, the Visual Studio debugger will break, showing the
    last line of code that could run before crashing the application. This code is
    not necessarily responsible for crashing the application; therefore, you may need
    to modify those settings to get a better understanding of the cause.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging second-chance exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the exception being thrown is available in our source code, the default
    settings of the debugger are sufficient to understand the cause of the problem,
    as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Visual Studio debugger will stop at the highlighted code showing the infamous
    exception dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – The dialog showing the exception type, message, and links to
    get more information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – The dialog showing the exception type, message, and links to get
    more information
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional information is also provided in the output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The Visual Studio debugger keeps improving the diagnostic output version after
    version. In many cases, it is able to print a message that fully represents the
    origin of the problem. In the following example code, the exception is caused
    by a `null` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The dialog shows an **str was null** message, which tells us precisely what
    happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – The exception dialog showing the details seen before the variable
    is null'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – The exception dialog showing the details seen before the variable
    is null
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the output window shows a similar message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen the default behavior of the debugger, let's take into
    consideration a scenario that's a bit more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging first-chance exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we have underlined the value of trying to recover from an
    exception or rethrowing a different exception in order to give the calling code
    better semantics. There are cases where this adds some difficulty in debugging,
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since the `catch` block does not rethrow, the exception is simply swallowed
    and so the debugger will not break at all. But this situation may reveal the real
    cause of the issue. *How can we ask the debugger to stop at this exception?*
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in the exception window of Visual Studio (or other debuggers
    exposing the same feature). From the **Debug** | **Window** | **Exception Settings**
    menu, Visual Studio will show the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – The Exception Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.6_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – The Exception Settings window
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant exceptions for the .NET runtime are those under the **Common Language
    Runtime Exceptions** item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – A portion of the Exception Settings window showing the selectable
    exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_14.7_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.7 – A portion of the Exception Settings window showing the selectable
    exceptions
  prefs: []
  type: TYPE_NORMAL
- en: Most of those exceptions are unchecked, meaning that, as we already said, the
    debugger will *not* stop at a first-chance exception unless that checkbox is selected.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to break on the `throw` statement of the last example,
    we just select `System.Exception` from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please note that every exception in this list only includes the exact type and
    not the hierarchy of the derived types. In other words, `System.Exception` will
    not hook the whole hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: By scrolling through the list, you may notice that `System.NullReferenceException`
    and others are checked by default as those exceptions are reasonably considered
    bugs that should always be avoided by validating the arguments in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Since the list of exceptions is very long, the **Common Language Runtime Exceptions**
    root item is a three-state toggle that selects either all items, none, or resets
    to the default settings.
  prefs: []
  type: TYPE_NORMAL
- en: AppDomain exception events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first- and second-chance exceptions can also be monitored, but not intercepted,
    thanks to two events provided by the `AppDomain` object. You can subscribe to
    those events by using the following code in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you will not want to monitor the first-chance exceptions as
    they may not cause any trouble to the application. Anyway, it can be useful to
    get rid of them any time you believe they might cause performance issues due to
    legitimately handled exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The second-chance (unhandled) exceptions are useful for providing a log for
    any exceptions that could not be caught or that were unexpected. Beyond that,
    in a desktop-application context, the typical use case is showing a custom crash
    dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that .NET Core always has a single app domain while .NET Framework
    may have more than one, which is often true in ASP.NET applications when **Internet
    Information** **Services** (**IIS**) recycles the host process.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we can get detailed information about the exception to happen
    during a debugging session and what the best options are to log them. We will
    now see the kind of debugging information provided in the exception object that
    can be used after the application has crashed.
  prefs: []
  type: TYPE_NORMAL
- en: Logging exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating the exception object, the runtime enriches its state in order
    to provide the most detailed diagnostic information that can be used to identify
    the fault. Regardless of the way you get access to the exception object, either
    from the `catch` block or the `AppDomain` events, there is additional information
    that you can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already discussed the `InnerException` property, which recursively provides
    access to all the inner exceptions of the chain. The following example shows how
    to iterate the whole chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the inner exceptions to create a dump is not really needed when creating
    a log because the `ToString` method of the exception object provides the dump
    of the whole chain even if it is very verbose.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToString` method prints the `StackTrace` string property provided by the
    runtime to capture the whole method chain where the exception happened.
  prefs: []
  type: TYPE_NORMAL
- en: Since `StackTrace` is a string assembled from the runtime, the exception object
    also provides the `TargetSite` property of the `MethodBase` type, which is the
    reflection object representing the faulting method. This object exposes, among
    others, the `Name` property with the method name.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `GetBaseException` method returns the first exception that originally
    generated the fault, provided that any re-throw statement preserves the inner
    exception or specifies no argument, as we have already discussed in the *Rethrowing
    an exception* section. If you instead need to know whether there has been an exception
    that has been swallowed by some handler, you will need to hook the first-chance
    exceptions event.
  prefs: []
  type: TYPE_NORMAL
- en: There are more advanced debugging techniques that you may want to investigate
    using the links provided in the *Further reading* section. They include the creation
    of a dump, which is a binary file containing the memory of the application process
    at the moment of the crash. The dump can be investigated with the debugging tools
    at a later moment. Another powerful and very advanced tool is the `dotnet-dump
    analyze` .NET Core tool.
  prefs: []
  type: TYPE_NORMAL
- en: These are low-level tools, typically used in so-called `dotnet-dump` is to provide
    .NET-specific information in addition to the standard elements offered by the
    native debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with these tools, you may get information on the current stack
    state for each thread, the most recent exception data, how each object in memory
    is referenced or references other objects, the memory used by each object, and
    other information related to the application metadata and the .NET runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first understood why .NET embraced the exception model,
    in contrast to the error codes used by many other technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The exception model has demonstrated that it is very powerful, providing an
    efficient and clean way to report errors to the call chain. It avoids polluting
    the code with additional parameters and error-checking conditionals, which may
    cause a loss of efficiency in certain cases. We also verified with a benchmark
    that the exception model must only be used for exceptional cases because otherwise,
    it may severely affect the application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen in detail the syntax of the `try`, `catch`, and `finally`
    statements that allow us to intercept and handle the exceptions and provide a
    deterministic disposal of any outstanding resource.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined the diagnostics and logging options, which are extremely
    useful in providing all the necessary information to fix the bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning about the new features of C# 8, which
    enhance the language by giving us more expressivity and power in terms of performance
    and robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which `block` statement can be used to surround some code that may potentially
    throw an exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the typical task inside any `catch` block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When specifying multiple `catch` blocks, what order should be respected and
    why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should we specify the exception variable name in the `catch` statement? Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You just caught an exception in a `catch` block. Why should you want to rethrow
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the `finally` block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you specify a `finally` block without a `catch` block?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are first-chance exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you break the Visual Studio debugger into a first-chance exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you want to hook the `UnhandledException` event of the AppDomain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The** **dotnet-dump** **tool** (**only** **for** **.NET** **Core**): [https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** **WinDbg** **debugger**: [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using** **the** **SOS** **debugging** **extension** **in** **WinDbg** (**only**
    **for** **.NET** **Framework**): [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
