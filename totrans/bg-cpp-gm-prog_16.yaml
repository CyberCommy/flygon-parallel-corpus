- en: Chapter 16.  Extending SFML Classes, Particle Systems, and Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we will explore the C++ concept of extending other people's
    classes. More specifically, we will look at the SFML `Drawable` class and the
    benefits of using it as a base class for our own classes. We will also scratch
    the surface of the topic of OpenGL shaders and see how writing code in another
    language **OpenGL Shading Language** (**GLSL**), which can be run directly on
    the graphics card, can lead to smooth graphical effects that might otherwise be
    impossible. As usual, we will also use our new skills and knowledge to enhance
    the current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics in the order we will cover them:'
  prefs: []
  type: TYPE_NORMAL
- en: The SFML Drawable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenGl shaders and GLSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shaders in the Thomas Was Late game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SFML Drawable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "The `Drawable` class has just one function. It has no variables either. Furthermore,\
    \ its one and only function is pure virtual. This means that if we inherit from\
    \ `Drawable`, we must implement its one and only function. The purpose of this,\
    \ which you may remember from [Chapter 12](ch12.html \"Chapter 12. Abstraction\
    \ and Code Management – Making Better Use of OOP\"), *Abstraction and Code Management â\x80\
    \x94 Making Better Use of OOP*, is that we can then use our class, which inherits\
    \ from `drawable`, as a polymorphic type. Put more simply, anything that SFML\
    \ allows us to do with a `Drawable` object, we will be able to do with our class\
    \ that inherits from it. The only requirement is that we must provide a definition\
    \ for the pure virtual function, `draw`."
  prefs: []
  type: TYPE_NORMAL
- en: Some classes that inherit from `Drawable` already include `Sprite` and `VertexArray`
    (among others). Whenever we have used `Sprite` or `VertexArray`, we have passed
    them to the `draw` function of the `RenderWindow` class.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that we have been able to draw every object we have drawn in this
    book is that they have all inherited from `Drawable`. We can use this knowledge
    to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inherit from `Drawable` with any object we like, as long as we implement
    the pure virtual `draw` function. This is also a straightforward process. The
    header file (`SpaceShip.h`) of a hypothetical `SpaceShip` class that inherits
    from `Drawable` would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we can see the pure virtual `draw` function and a Sprite.
    Notice there is no way to access the private `Sprite` outside of the class, not
    even a `getSprite` function!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SpaceShip.cpp` file would then look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, notice the simple implementation of the `draw` function.
    The parameters are beyond the scope of the book. Just note that the `target` parameter
    is used to call `draw` and passes in `m_Sprite` as well as `states`, the other
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While it is not necessary to understand the parameters to take full advantage
    of `Drawable`, in the context of the book, you might be intrigued. You can read
    more about the SFML `Drawable` class on the SFML website: [http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity](http://www.sfml-dev.org/tutorials/2.3/graphics-vertex-array.php#creating-an-sfml-like-entity)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main game loop, we could now treat a `SpaceShip` instance as if it were
    a `Sprite`, or any other class that inherits from `Drawable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is because `SpaceShip` is a `Drawable` that we can treat it like a `Sprite`
    or `VertexArray`, and because we overrode the pure virtual `draw` function, everything
    just works as we want it to. Let's look at an alternative way of encapsulating
    the drawing code into the game object.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to inheriting from Drawable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to keep all the drawing functionality within the class
    that is the object to be drawn by implementing our own function, within our class,
    perhaps like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code assumes that `m_Sprite` represents the visual appearance
    of the current class we are drawing, as it has throughout this and the previous
    project. Assuming that the instance of the class that contains the `drawThisObject`
    function is called `playerHero`, and further assuming we have an instance of `RenderWindow`
    called `m_Window`, we could then draw the object from the main game loop with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this solution, we pass the `RenderWindow`, `m_Window`, into the `drawThisObject`
    function as a parameter. The `drawThisObject` function then uses the `RenderWindow`
    to draw the `Sprite`, `m_Sprite`.
  prefs: []
  type: TYPE_NORMAL
- en: This solution certainly seems simpler than extending `Drawable`. The reason
    we do things the way suggested (extending Drawable) isn't really of any great
    benefit, in its own right, for this project. The actual reason we will soon draw
    a neat explosion using this method is because it is a good technique to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Why it is best to inherit from Drawable?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With each project we have completed throughout the book, we have learned more
    about games, C++, and SFML. Possibly the biggest improvements we have made from
    one game to the next is in the structure of our code–the programming **patterns**
    that we have used.
  prefs: []
  type: TYPE_NORMAL
- en: If there were a fourth project to this book, we could take things even further.
    Unfortunately, there isn't, but have a think about the following idea for improving
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine every object in our game is derived from a single, simple, abstract
    base class. Let's call it `GameObject`. Game object would probably have concrete
    functions for `getPosition` and others. It would likely have a pure virtual `update`
    function (because every object updates differently). Furthermore, consider that
    `GameObject` inherits from `Drawable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at this hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a big step up in terms of encapsulation, code manageability,
    and elegance when compared to even this final project. If you look at the previous
    code, you will notice there are, however, unanswered questions, such as where
    collision detection fits in, for example. Hopefully, however, you can see that
    further study (by building lots of games) will be necessary to master C++.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not be implementing an entire game in this manner, we will
    see how we can design a class (`ParticleSystem`) and pass it directly to `m_Window.draw(m_MyParticleSystemInstance)`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a particle system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start coding, it will be helpful to see exactly what it is we are
    trying to achieve. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a particle system](img/image_16_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a screenshot of the particle effect on a plain background. We will use
    the effect in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we achieve the effect is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn 1,000 dots (particles), one on top of the other, at a chosen pixel position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each frame of the game, move each of the 1,000 particles outward at a predetermined,
    but random, speed and angle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step two for two seconds and then make the particles disappear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use a `VertexArray` to draw all the dots and the primitive type of `Point`
    to represent each particle visually. Furthermore, we will inherit from `Drawable`
    so that our particle system can take care of drawing itself.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Particle class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Particle` class will be a simple class that represents just one of the
    1,000 particles. Let's get coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding Particle.h
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `Particle.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `Particle`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Particle.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have two `Vector2f` objects. One will represent the
    horizontal and vertical coordinates of the particle and the other will represent
    the horizontal and vertical speed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have a rate of change (speed) in more than one direction, the combined
    values also define a direction. This is called **velocity**; hence, the Vector2f
    is called `m_Velocity`.
  prefs: []
  type: TYPE_NORMAL
- en: We also have a number of public functions. First is the constructor. It takes
    a `Vector2f`, which will be used to let it know what direction/velocity this particle
    will have. This implies that the system, not the particle itself, will be choosing
    the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `update` function, which takes the time the previous frame has taken.
    We will use this to move the particle by precisely the correct amount.
  prefs: []
  type: TYPE_NORMAL
- en: The final two functions, `setPosition` and `getPosition`, are used to move the
    particle into position and find out its position, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: All these functions will make complete sense when we code them.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Particle.cpp file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `Particle.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `Particle`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Particle.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All these functions use concepts we have seen before. The constructor sets up
    the `m_Velocity.x` and `m_Velocity.y` values using the passed-in `Vector2f` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function moves the horizontal and vertical positions of the particle
    by multiplying `m_Velocity` by the elapsed time (`dtAsSeconds`). Notice that to
    achieve this, we simply add the two `Vector2f` objects together. There is no need
    to perform calculations for both the *x* and *y* members separately.
  prefs: []
  type: TYPE_NORMAL
- en: The `setPosition` function, as previously explained, initializes the `m_Position`
    object with the passed-in values. The `getPosition` function returns `m_Position`
    to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fully functioning `Particle` class. Next, we will code a `ParticleSystem`
    class to spawn and control the particles.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ParticleSystem class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ParticleSystem` class does most of the work for our particle effects. It
    is this class that we will create an instance of in the `Engine` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding ParticleSystem.h
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `ParticleSystem.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `ParticleSystem` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code for the `ParticleSystem` class to `ParticleSystem.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's go through this a bit at a time. Firstly, notice that we are inheriting
    from `Drawable`. This is what will enable us to pass our `ParticleSystem` instance
    to `m_Window.draw`, because `ParticleSystem` is a `Drawable`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a vector named `m_Particles`, of type `Particle`. This vector will
    hold each and every instance of `Particle`. Next we have a `VertexArray` called
    `m_Vertices`. This will be used to draw all the particles in the form of a whole
    bunch of `Point` primitives.
  prefs: []
  type: TYPE_NORMAL
- en: The `m_Duration`, `float` variable is how long each effect will last. We will
    initialize it in the constructor function.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean  `m_IsRunning` variable will be used to indicate whether the particle
    system is currently in use or not.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the public section, we have the pure virtual function, `draw`, that
    we will soon implement to handle what happens when we pass our instance of `ParticleSystem`
    to `m_Window.draw`.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function will prepare the `VertexArray` and the `vector`. It will
    also initialize all the `Particle` objects (held by the `vector`) with their velocities
    and initial positions.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function will loop through each and every `Particle` instance in
    the `vector` and call their individual `update` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `running` function provides access to the `m_IsRunning` variable so that
    the game engine can query whether or not the `ParticleSystem` is currently in
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Let's code the function definitions to see what goes on inside `ParticleSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ParticleSystem.cpp file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `ParticleSystem.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `ParticleSystem` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will split this file into five sections to code and discuss it better. Add
    the first section of code as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the necessary `includes`, we have the definition of the `init` function.
    We call `setPrimitiveType` with `Points` as the argument so that `m_VertexArray`
    knows what types of primitive it will be dealing with. We resize `m_Vertices`
    with `numParticles`, which was passed in to the `init` function when it was called.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop creates random values for speed and angle. It then uses trigonometric
    functions to convert those values into a vector, which is stored in the `Vector2f`,
    `direction`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to know more about how the trigonometric functions (`cos`, `sin`,
    and `tan`) convert angles and speeds into a vector, you can take a look at this
    article series: [http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that happens in the `for` loop (and the `init` function) is that
    the vector is passed in to the `Particle` constructor. The new `Particle` instance
    is stored in `m_Particles` using the `push_back` function. Therefore, a call to
    `init` with a value of `1000` would mean we have one thousand instances of `Particle`,
    with random velocity, stashed away in `m_Particles` just waiting to blow!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `update` function to `ParticleSysytem.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `update` function is simpler than it looks at first glance. First of all,
    `m_Duration` is reduced by the passed-in time, `dt`. This is so we know when the
    two seconds have elapsed. A vector iterator, `i`, is declared for use with `m_Particles`.
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop goes through each of the `Particle` instances in `m_Particles`.
    For each and every one it calls its `update` function and passes in `dt`. Each
    particle will update its position. After the particle has updated itself, the
    appropriate vertex in `m_Vertices` is updated by using the particle's `getPosition`
    function. At the end of each pass through, the `for` loop `currentVertex` is incremented,
    ready for the next vertex.
  prefs: []
  type: TYPE_NORMAL
- en: After the `for` loop has completed, `if(m_Duration < 0)` checks whether it is
    time to switch off the effect. If two seconds have elapsed, `m_IsRunning` is set
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `emitParticles` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is the function we will call to start the particle system running. So,
    predictably, we set `m_IsRunning` to `true` and `m_Duration` to `2`. We declare
    an `iterator`, `i`, to iterate through all the `Particle` objects in `m_Particles`,
    and then we do so in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop, we set each particle in the vertex array to yellow and
    set each position to `startPosition`, which was passed in as a parameter. Remember
    that each particle starts life in exactly the same position, but they are each
    assigned a different velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the pure virtual draw function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we simply use `target` to call `draw`, passing in `m_Vertices`
    and `states`. This is exactly as we discussed when talking about `Drawable` earlier
    in the chapter, except we pass in our `VertexArray`, which holds 1,000 point primitives
    instead of the hypothetical spaceship Sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the running function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `running` function is a simple getter function that returns the value of
    `m_IsRunning`. We will see where this is useful to determine the current state
    of the particle system.
  prefs: []
  type: TYPE_NORMAL
- en: Using ParticleSystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put our particle system to work is very straightforward, especially because
    we inherited from `Drawable`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a ParticleSystem object to the Engine class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open `Engine.h` and add a `ParticleSystem` object, as shown in the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, initialize the system.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing ParticleSystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `Engine.cpp` file and add the short highlighted code right at the
    end of the `Engine` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `VertexArray` and the `vector` of `Particle` instances are ready for action.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the particle system in each frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `Update.cpp` file and add the following highlighted code. It can go
    right at the end of the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: All that is needed in the previous code is the call to `update`. Notice that
    it is wrapped in a check to make sure the system is currently running. If it isn't
    running, there is no point updating it.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the particle system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the `DetectCollisions.cpp` file, which has the `detectCollisions` function
    in it. We left a comment in it when we originally coded it back in [Chapter 15](ch14.html
    "Chapter 14. Building Playable Levels and Collision Detection"), *Building Playable
    Levels and Collision Detection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the correct place from the context and add the highlighted code, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First the code checks if the particle system is already running. If it isn't,
    it checks if the current tile being checked is either a water or a fire tile.
    If either is the case, it checks whether the character's feet are in contact.
    When each of these `if` statements is `true`, the particle system is started by
    calling the `emitParticles` function and passing in the location of the center
    of the character as the coordinates to start the effect.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the particle system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the best bit. See how easy it is to draw the `ParticleSystem`. We pass
    our instance directly to the `m_Window.draw` function after checking that the
    particle system is actually running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Draw.cpp` file and add the highlighted code in all the places shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the previous code that we have to draw the particle system in all
    of the left, right, and full-screen code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and move one of the character''s feet over the edge of a fire
    tile. Notice the particle system burst into life:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing the particle system](img/image_16_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now for something else that is new.
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL, shaders, and GLSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Open Graphics Library **(**OpenGL**) is a programming library that handles
    2D and 3D graphics. OpenGL works on all major desktop operating systems and there
    is also a version, OpenGL ES, that works on mobile devices.'
  prefs: []
  type: TYPE_NORMAL
- en: OpenGL was originally released in 1992\. It has been refined and improved over
    more than twenty years. Furthermore, graphics cards manufacturers design their
    hardware to make it work well with OpenGL. The point of telling you this is not
    for the history lesson, but to explain that it would be a fool's errand to try
    and improve upon OpenGL, and using it in 2D (and 3D) games on the desktop, especially
    if you want your game to run on more than just Windows, is the obvious choice.
    We are already using OpenGL because SFML uses OpenGL. Shaders are programs that
    run on the GPU itself, so let's find out more about them next.
  prefs: []
  type: TYPE_NORMAL
- en: The programmable pipeline and shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Through OpenGL we have access to what is called a **programmable pipeline**.
    We can send our graphics off to be drawn, each frame, with the `RenderWindow` `draw`
    function. We can also write code that runs on the GPU, which is capable of manipulating
    each and every pixel independently**,** after the call to `draw`. This is a very
    powerful feature.
  prefs: []
  type: TYPE_NORMAL
- en: This extra code that runs on the GPU is called a **shader program**. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually, in code called a **fragment shader**.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not be exploring shaders in any great depth, we will write
    some shader code using GLSL and we will get a glimpse of the possibilities offered.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and we can also combine these
    elements to make the complex graphics that we see in today's modern games. These
    are collectively known as **primitives**. We have access to OpenGL primitives
    through the SFML primitives and `VertexArray`, as well as the `Sprite` and `Shape`
    classes we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to primitives, OpenGL uses matrices. Matrices are a method and structure
    for performing arithmetic. This arithmetic can range from extremely simple high
    school-level calculations to move (translate) a coordinate, or it can be quite
    complex, to perform more advanced mathematics; such as, converting our game world
    coordinates into OpenGL screen coordinates that the GPU can use. Fortunately,
    it is this complexity that SFML handles for us behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SFML also allows us to handle OpenGL directly. If you want to find out more
    about OpenGL, you can get started here: [http://learnopengl.com/#!Introduction](http://learnopengl.com/#!Introduction).
    If you want to use OpenGL directly alongside SFML, you can read the following
    article: [http://www.sfml-dev.org/tutorials/2.3/window-opengl.php](http://www.sfml-dev.org/tutorials/2.3/window-opengl.php).'
  prefs: []
  type: TYPE_NORMAL
- en: An application can have many shaders. We can then *attach* different shaders
    to different game objects to create the desired effects. We will only have one
    vertex and one fragment shader in this game. We will apply it, each frame, to
    the background.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you see how to attach a shader to a `draw` call, it will be plain
    that it is trivial to add more shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need the code for the shader that will be executed on the GPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we need to compile that code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to attach the shader to the appropriate draw call in the draw
    function of our game engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be declared and utilized. Furthermore, we can interact with
    the shader program's variables from our C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If gaining further knowledge about the power of programmable graphics pipelines
    and shaders is just too exciting to leave for another day, then I can highly recommend
    GLSL Essentials by Jacobo RodrÃ­guez: [https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials).
    The book explores OpenGL shaders on the desktop and is highly accessible to any
    reader with decent C++ programming knowledge and a willingness to learn a different
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, GLSL has some syntax similarities to C++.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a fragment shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code from the `rippleShader.frag` file in the `shaders` folder.
    You don''t need to code this as it was in the assets we added back in [Chapter
    12](ch12.html "Chapter 12. Abstraction and Code Management – Making Better Use
    of OOP"), *Abstraction and Code Management – Making Better Use of OOP*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first four lines (excluding comments) are the variables that the fragment
    shader will use. However, they are not ordinary variables. The first type we see
    is `varying`. These are variables which are in scope between both `shaders`. Next,
    we have the `uniform` variables. These variables can be manipulated directly from
    our C++ code. We will see how we do this soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `varying` and `uniform` types, each of the variables also
    has a more conventional type, which defines the actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vec4` is a vector with four values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vec2` is a vector with two values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sampler2d` will hold a texture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` is just like a `float` in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code inside the `main` function is what is actually executed. If you look
    closely at the code in `main`, you will see each of the variables in use. Exactly
    what this code does is beyond the scope of this book. In summary, however, the
    texture coordinates (`vTexCoord`) and the color of the pixels/fragments (`glFragColor`)
    are manipulated by a number of mathematical functions and operations. Remember
    that this executes for each and every pixel involved in the draw call, on each
    and every frame of our game. Furthermore, be aware that `uTime` is passed in as
    a different value, each and every frame. The result, as we will soon see, will
    be a rippling effect.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a vertex shader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code from the `vertShader.vert` file. You don''t need to code this
    as it was in the assets we added back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    – Making Better Use of OOP*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First of all, notice the two `varying` variables. These are the very same variables
    that we manipulated back in the fragment shader. In the `main` function, the code
    manipulates the position of each and every vertex. How the code works is beyond
    the scope of this book, but there is some quite in-depth math going on behind
    the scenes and if it interests you, then exploring GLSL will be fascinating (see
    the previous tip).
  prefs: []
  type: TYPE_NORMAL
- en: Now we have two shaders (one fragment and one vertex). We can use them in our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding shaders to the Engine class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `Engine.h` file. Add the highlighted line of code, which adds an SFML
    `Shader` instance called `m_RippleShader` to the `Engine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The engine object and all its functions now have access to `m_RippleShadder`.
    Note that an SFML `Shader` object will be comprised of both shader code files.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add the following code, which checks whether the player's GPU can handle shaders.
    The game will quit if it can't.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will have to have an exceptionally old PC for this not to work. If you do
    have a GPU that doesn't handle shaders, please accept my apologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will add an else clause that actually loads the shaders if the system
    can handle them. Open the `Engine.cpp` file and add the following code to the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we are nearly ready to see our ripple effect in action.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and drawing the shader in each frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `Draw.cpp` file. As we discussed when we coded the shaders, we will
    update the uTime variable directly from our C++ code each frame. We do so with
    the `Uniform` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted code to update the shader''s `uTime` variable and change
    the call to `draw` for `m_BackgroundSprite` in each of the possible drawing scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It would be best to actually delete the lines of code that I have shown commented
    out. I just did it this way to make it clear which lines of code are being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game, and you get an eerie kind of molten-rock effect. Experiment with
    changing the background image if you want to have some fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating and drawing the shader in each frame](img/image_16_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! Our third and final game is done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the grand finale, we explored the concepts of particle systems and shaders.
    Although we looked at probably the simplest possible case for each, we still managed
    to create a simple explosion and an eerie molten-rock effect.
  prefs: []
  type: TYPE_NORMAL
- en: Please take a look at the final, short chapter, which discusses what to do next.
  prefs: []
  type: TYPE_NORMAL
