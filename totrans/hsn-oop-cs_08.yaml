- en: Modeling and Designing Software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As civil engineering emerged and large structures were created, the practice
    of modeling and designing became really important. The same happened with software
    development. Nowadays, software is everywhere: in your computer, mobile phone,
    TV, car, and so on. As the uses of software expanded, software development became
    increasingly complex and expensive, requiring both time and money.'
  prefs: []
  type: TYPE_NORMAL
- en: Software modeling and design are important parts of the software development
    life cycle. If you have an idea and you are planning to start a software project,
    the first thing you should do is design and model the software, not just jump
    into writing the code. This will give you a high-level view of the software and
    the opportunity to architect it in such a way that it will be easy to extend and
    modify. If you don't carry out modeling beforehand, you might end up in a situation
    where you have to restructure your software architecture, which could be very
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of design diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different **Unified Modeling Language** (**UML**) diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of design diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UML is a design language that is the standard language that is used for
    software modeling and design. It was first developed by Grady Booch, Ivar Jacobson,
    and James Rumbaugh at Rational Software between 1994–1995\. In 1997, the **Object
    Management Group** (**OMG**) adopted it as the standard language for modeling.
    Later, in 2005, the **International Organization for Standardization** (**ISO**)
    approved UML as an ISO standard, and since then, it has been adopted by every
    software community.
  prefs: []
  type: TYPE_NORMAL
- en: UML diagrams allow developers to convey software design to other people. It
    is a language that has a set of rules that encourages easy communication. If you
    learn to read UML, you can understand any software model that is written in UML.
    Explaining a software model in plain English would be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Different UML diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of UML diagrams, but we will only discuss the most important
    ones in this chapter. UML diagrams fall into the following two major categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Structural diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list shows the diagrams that come under the category of structural
    diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite structure diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Behavioral diagrams include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Activity diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction overview diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timing diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class diagram is a structural diagram that is mainly used to provide the design
    of a piece of object-oriented software. This diagram demonstrates the structure
    of a software, the attributes and methods of a class, and the relationship between
    classes in the system. It can be used for development as well as for documentation;
    software developers frequently use this diagram to get a quick idea of the code
    and to help fellow developers understand the system. It is also occasionally used
    by employees involved in the business side of a company.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the three main parts of a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: The class name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attribute section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class diagram consists of different classes that are represented as boxes
    or rectangles. A rectangle is normally divided into the aforementioned sections.
    The first part holds the name of the class, the second portion holds the attributes,
    and the third section contains the methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef5d873d-d509-4bac-9c81-2c9cbd5ab909.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that we have a class called `Car`, as indicated by the top
    box. Below that, we have the attributes of that class. We can see that `color` is
    the name of an attribute, which has a `+` sign in front of it, indicating that
    it is a public variable. We can also see that there is a `:` (colon) next to the
    variable name, which is a separator. Whatever is given after the colon represents
    the type of the variable. In this case, we can see that the `color` variable is
    of the `string` type. The next attribute is `company`, which is also a variable
    of the `string` type. This has a `-` sign in front of it, which means that it
    is a private variable. The third attribute is `fuel`, and we can see that this
    is a private variable of the `integer` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look below the attributes, we will see the methods of the `Car` class.
    We can see that it has three methods: `move(direction: string)`, `IsFuelEmpty()`,
    and `RefilFuel(litre: int)`. Like the attributes, we can see that the methods
    have a `:` (colon). In this case, the type that is given after the colon is the
    return type of the method. The first method, `move`, doesn''t return anything,
    so the type is void. In the `IsFuelEmpty()` method, the return type is Boolean,
    and this is also the case for the third method. Another thing to note here is
    the parameters of the methods, which are placed in parentheses after the method
    name. For example, the `move` method has a parameter called `direction`, which
    is a `string` type. The `RefilFuel(litre: int)` method has an `int` type parameter,
    which is `litre`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we saw how a class is represented in a class diagram.
    Normally, a system has multiple classes that are related to each other in some
    way. A class diagram demonstrates the relationships of the classes as well, which
    gives the viewer a full picture of the system's object relationships. In [Chapter
    4](eabd28cc-8e8c-49dc-9b63-8f86d0356ad5.xhtml), *Object Collaboration*, we learned
    about the different relationships between classes and objects in object-oriented
    software. Let's now take a look at how we can represent these different object
    relationships using class diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inheritance** is a relationship in which one class is like another class,
    in the same way that a BMW i8 Roadster is a kind of car. This type of relationship
    is shown using a line and a hollow arrow. The arrow points from the class to the
    super class, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d761b9e-3e8e-4ac7-928b-22d8608d8bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An association relationship is the most basic relationship between objects.
    When one object has some kind of logic or physical relationship with another object
    it is called **association relationship**. It is represented by a line and an
    arrow. If there is an arrow on both sides, this represents a bidirectional relationship.
    An example of an association could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b837ef58-3cb9-42eb-ae29-7f9946b74e7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **aggregation** **relationship** is a special type of association relationship.
    This relationship is usually known as a **has-a** **relationship**. When one class
    has another class/object in it, this is an aggregation relationship. This is represented using
    a line and a hollow diamond. For example, a car has a tire. A tire and a car have
    an aggregation relationship, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99938797-f7b0-452b-931f-267d243a720d.png)'
  prefs: []
  type: TYPE_IMG
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When one class has another class in it and the dependent class can''t exist
    without the super class, this is a **composition relationship**. For example,
    a bank account can''t exist without a bank, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5383a622-97ff-488d-8ae1-4a4f5f3e561e.png)'
  prefs: []
  type: TYPE_IMG
- en: Dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class has a dependent class, but the class itself is not dependent on
    its own dependent class, the relationship between those classes is called a **dependency**
    **relationship**. In a dependency relationship, any change in the dependent class
    doesn't have any effect on the class it is dependent on. But the dependent class
    will be affected if the class that it is dependent on changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This relationship is represented by a dashed line with an arrow at the end.
    For example, let''s imagine that we have a theme on our mobile phone. If we change
    the theme, the phone''s icons will change, so the icons have a dependency on the
    theme. This relationship is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73fabc73-d7d4-44ae-9f17-4af0a2b5a0b4.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a class diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a class diagram of a project. Here, we
    have some grade management software that is used by the teachers and students
    of a school. The software allows teachers to update the grades of particular students
    for different subjects. It also allows the students to view their grade. For this
    software, we have the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7f2d8fd2-4b2a-450e-ae7b-4d32f334715c.png)'
  prefs: []
  type: TYPE_IMG
- en: Person class diagram
  prefs: []
  type: TYPE_NORMAL
- en: '`Teacher`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f38bc1d5-dbe2-471f-b2f3-a82ee2b8f65b.png)'
  prefs: []
  type: TYPE_IMG
- en: Teacher class diagram
  prefs: []
  type: TYPE_NORMAL
- en: '`Student`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4488335c-873e-4021-b3a9-064096d3331f.png)'
  prefs: []
  type: TYPE_IMG
- en: Student class diagram
  prefs: []
  type: TYPE_NORMAL
- en: '`Subject`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/479eb717-fadd-421e-b87c-8efd0e87dbd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Subject class diagram
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have used Visual Studio to generate our class diagram, so the arrows
    might not match the arrows that are given in the previous sections. If you are
    drawing your class diagrams using other drawing software, or if you are drawing
    by hand, then use the arrows specified in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following complete class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec3d0186-abb9-4525-ab2e-8d22d3571048.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that we have a `Person` class that has two attributes, a `FirstName`
    and a `LastName`. The `Student` and `Teacher` classes inherit the `Person` class,
    so we can see that the arrow is hollow. The `Student` class has two attributes,
    `email` and `studentId`. It also has a method called `GetExamGrade` (string subject),
    which takes the name of the subject and returns the grade in `char` type. We can
    see that another class, `Subject`, has a composition relationship with `Student`.
    `Student` has a list of subjects and the `Subject` class has three attributes, `grade`,
    `name`, and `subjectId`. The `Teacher` class has an `email`, `phoneNumber`, and
    `teacherId`, which are `string`, `string`, and `int` types respectively. The `Teacher`
    class has an association relationship with the `Student` class, as a teacher has
    a group of students under them. The `Teacher` class also has a method called `GiveExamGrade`,
    which takes three parameters, `studentId`, `subject`, and `grade`. This method
    will set the grades on the students' subjects.
  prefs: []
  type: TYPE_NORMAL
- en: Just by looking at the class diagram, we get a clear idea of the system. We
    know how the subject is related to the student and how students are related to
    teachers. We also know that a subject's object can't exist without a student object,
    as they have a composition relationship. This is the beauty of the class diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Use case diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **use case diagram** is a behavioral diagram that is very commonly used in
    software development. The main purpose of this diagram is to illustrate the functional
    usage of a piece of software. It holds the use cases of a system and can be used
    to provide a high-level view of the functionality or even a very specific low-level
    module of a software. Normally for a system, there are multiple use case diagrams
    that focus on the different levels of the system. Use case diagrams shouldn't
    be used to display the implementation details of a system; they were developed
    to show only the functional requirements of a system. Use case diagrams are very
    good diagrams for business people to convey what they need from a system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main parts of a use case diagram, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: The actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The actor in a use case diagram is not necessarily a person—it is rather the
    user of the system. It could be a person, another system, or even another module
    of the system. A visual representation of an actor is given in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e846aec-8451-4299-a724-68d343e6b723.png)'
  prefs: []
  type: TYPE_IMG
- en: An actor is responsible for providing an input. It gives instructions to the
    system and the system works accordingly. Every action an actor does has a purpose.
    A use case diagram shows us what an actor can do and what the expectations of
    the actor are.
  prefs: []
  type: TYPE_NORMAL
- en: The use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The visual part or representation of a use case diagram is known as the **use
    case**. This represents the functionality of the system. An actor will execute
    a use case to achieve a goal. A use case is represented by an oval with the name
    of the functionality. For example, in a restaurant app, *placing an order* could
    be a use case. We can represent this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f866bf-55e6-476f-b4f4-63a353931cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: The communication link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **communication link** is a simple line from an actor to a use case. This
    link is used to show that an actor has a relationship with a particular use case.
    An actor won''t have access to all use cases, so communication links are very
    important when displaying which use cases are accessible by which actor. Let''s
    take a look at an example of a communication link, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37f21476-f699-4702-bc50-b4c79ff2f693.png)'
  prefs: []
  type: TYPE_IMG
- en: The system boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**System boundaries** are mainly used to show the scope of a system. It is
    important to be able to identify which use cases fall in our system and which
    don''t. In a use case diagram, we only focus on the use cases in our system. In
    large systems, each module of the system is sometimes treated as a boundary if
    those modules are independent enough to function without each other. This is normally
    shown with a rectangular box that holds the use cases. An actor is not a part
    of the system, so the actor will be outside of the system boundary, as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2849c139-5649-4c82-85ca-af90ca198e15.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a use case diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now imagine that we have a restaurant system in which a customer can
    order food. The chef prepares the food and the manager keeps track of the sales,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60d6aaf7-dcfb-47d0-b532-0e16b2895a3c.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding diagram, we can see that we have three actors (the Customer,
    the Chef, and the Manager). We also have different use cases—Check Menu, Order
    Food, Cook Food, Serve Food, Pay, and Sales Report, which are connected to one
    or more actors. The **Customer** actor is involved in the Check Menu, Order Food, and
    Pay use cases. The Chef has to access Order Food in order to find out about the
    orders. The Chef is also involved in the Cook Food and Serve Food use cases. Unlike
    the Chef and the Customer, the Manager is able to see the Sales Report of the
    restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this use case diagram, we are able to identify the functionalities
    of the system. It doesn't give you any implementation details, but we can easily
    see an overview of the system.
  prefs: []
  type: TYPE_NORMAL
- en: A sequence diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sequence diagram is an interaction diagram that falls under the category of
    behavioral diagrams. As the name suggests, it shows the sequence of the activities
    of a system. By looking at a sequence diagram, you can identify which activities
    happen during a particular time frame and which activities come next. It allows
    us to understand the flow of a system. The activities it represents might be an
    interaction between a user and a system, between two systems, or between a system
    and a subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: The horizontal axis of a sequence diagram shows time passing from left to right,
    while the vertical axis shows the flow of activity. Different activities are placed
    in the diagram in a sequential manner. A sequence diagram doesn't necessarily
    show the duration of time passing but rather the steps from one activity to another.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll take a look at the notations that are used
    in a sequence diagram.
  prefs: []
  type: TYPE_NORMAL
- en: An actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An actor in a sequence diagram is very similar to an actor in a use case diagram.
    It could be a user, another system, or even a user group. An actor is not part
    of the system and executes commands externally. Different operations are executed
    upon receiving commands from users. The actor is denoted with a stick figure,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c3a3caf-1da0-424c-a660-ccc90aaaf83f.png)'
  prefs: []
  type: TYPE_IMG
- en: A lifeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lifeline in sequence diagram is an entity or element of a system. Every lifeline
    has its own logic and tasks to do. Normally, a system has multiple lifelines,
    and commands are passed from one lifeline to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lifeline is denoted by a box with a vertical line issuing from the bottom,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8de10e9a-0fe9-4c81-9cb4-cb91fa71807d.png)'
  prefs: []
  type: TYPE_IMG
- en: An activation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An activation is a small rectangular box on a lifeline. This activation box
    represents the point when an activity was active. The top of the box represents
    the start of the activity and the end of the box represents the end of the activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it looks in a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/106cb923-d43a-4443-b318-47964cdeb963.png)'
  prefs: []
  type: TYPE_IMG
- en: A call message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A call message indicates an interaction between lifelines. It flows from left
    to right and is denoted by an arrow at the end of a line, as shown in the following
    diagram. A message call represents some kind of information or a trigger to the
    next lifeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b2892f6-8979-431c-a7d8-e21a6ab4ea85.png)'
  prefs: []
  type: TYPE_IMG
- en: A return message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The normal message flow in a sequence diagram is from left to right, as this
    represents the action commands; however, sometimes messages are returned to the
    caller. A return message flows from right to left and is denoted by a dotted line
    with an arrow head at the end, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2e819bf-6312-4869-937c-197f934da53f.png)'
  prefs: []
  type: TYPE_IMG
- en: A self message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, messages are passed from a lifeline to itself, such as an internal
    communication. It will be denoted in a similar way to a message call, but instead
    of pointing to another activity of another lifeline, it returns to the same activity
    of the same lifeline, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/650a7243-f3f6-4234-9079-8478e204619b.png)'
  prefs: []
  type: TYPE_IMG
- en: A recursive message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a self message is sent for recursive purposes, it is called a recursive
    message. Another small activity on the same timeline is drawn for this purpose,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08ca0a1f-f656-4487-9a85-fe267efadec5.png)'
  prefs: []
  type: TYPE_IMG
- en: A create message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This type of message is not a normal message, such as a call message. A create
    message is used when a lifeline is created by another lifeline, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a01993e4-ef74-4d0f-95b2-1a0b6048300f.png)'
  prefs: []
  type: TYPE_IMG
- en: A destroy message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a destroy message is sent from an activity to a lifeline, it means that
    the following lifeline is not going to be executed and the flow will be stopped,
    as shown in the following diagram. It is called a destroy message because it destroys
    the activity flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2684c59-cf70-4fa6-a275-e4187b4cd873.png)'
  prefs: []
  type: TYPE_IMG
- en: A duration message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use a duration message to show when there is a time duration between when
    an activity passes a message to the next activity and when the next activity receives
    it. It is similar to a call message, but is angled down, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63b79c11-31e7-40da-8cc0-bfa999315e34.png)'
  prefs: []
  type: TYPE_IMG
- en: A note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A note is used to include any necessary remarks to do with an element or an
    action. It has no particular rules. It can be placed anywhere that is suitable
    to represent the event clearly. Any type of information can be written in a note. A
    note is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26eabc06-08ee-442a-809e-1de6752d45d9.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a sequence diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to learn anything is by looking at an example of it. Let''s take
    a look at the following sequence diagram of a simple restaurant system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab1d8615-8507-4288-a0ec-873e7b6bdc13.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that a customer first asks for the menu from the UI. The UI
    passes the request to the Controller and then the Controller passes the request
    to the Manager. The Manager gets the menu and responds to the Controller. The
    Controller responds to the UI and the UI displays the menu in the display.
  prefs: []
  type: TYPE_NORMAL
- en: After the Customer chooses an item, the order goes step by step to the Manager.
    The Manager calls another method to prepare the food and sends a response to the
    Customer notifying them that the order has been received. When the food is ready,
    it is served to the Customer. Upon receiving the food, the Customer pays the bill
    and collects a Payment Receipt.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the sequence diagram, we can see the different activities involved
    in the process. It's pretty clear how the system is working step by step. This
    kind of diagram is very useful in showing the flow of a system, and is very popular.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of how to model and design your software
    using UML diagrams. This is very important for every software developer, because
    we need to be able to communicate with businesses and vice versa. You will also
    find that these diagrams are useful when discussing systems with other developers
    or software architects. We haven't covered all the different diagrams that are
    available for modeling and designing software in this chapter, because this is
    beyond the scope of this book. We covered class diagrams, use case diagrams, and
    sequence diagrams in this chapter. We saw an example of each of these diagrams
    and looked at how to draw them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to work with Visual Studio. We will
    see some tips and tricks that will help you increase your productivity while working
    with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
