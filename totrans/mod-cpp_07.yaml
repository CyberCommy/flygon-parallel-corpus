- en: Diagnostics and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断和调试
- en: Software is complex; however, well you design your code, at some point you'll
    have to debug it, whether during the normal testing phases of developing your
    code, or when a bug report has been issued. It's prudent to design your code to
    make testing and debugging as straightforward as possible. This means adding tracing
    and reporting code, determining invariants and pre- and post-conditions, so that
    you have a starting point to test your code, and writing functions with understandable
    and meaningful error codes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件是复杂的；无论您设计代码有多好，都会有一些时候需要调试它，无论是在开发代码的正常测试阶段还是在发出错误报告时。最好设计代码以尽可能简单地进行测试和调试。这意味着添加跟踪和报告代码，确定不变量和前后条件，以便您有一个测试代码的起点，并编写具有可理解和有意义的错误代码的函数。
- en: Preparing your code
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备您的代码
- en: The C++ and C Standard Libraries have a wide range of functions that allow you
    to apply tracing and reporting functions so that you can test if code is handling
    data in expected ways. Much of these facilities use conditional compilation so
    that the reporting only occurs in debug builds, but if you provide the traces
    with meaningful messages they will form part of the documentation of your code.
    Before you can report on the behavior of your code, you first have to know what
    to expect from it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++和C标准库有许多函数，允许您应用跟踪和报告函数，以便测试代码是否以预期方式处理数据。许多这些设施使用条件编译，以便报告仅在调试构建中发生，但如果您提供了有意义的跟踪消息，它们将成为您的代码文档的一部分。在您可以报告代码行为之前，您首先必须知道对其有何期望。
- en: Invariants and conditions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变量和条件
- en: 'Class invariants are conditions, the object state, that you know remain true.
    During a method call the object state will change, possibly to something that
    invalidates the object, but once a public method has completed, the object state
    must be left in a consistent state. There is no guarantee what order the user
    will call methods on a class, or even if they call methods at all, so an object
    must be usable whatever methods the user calls. The invariant aspects of an object
    applies on a method calls level: between method calls the object must be consistent
    and usable.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类不变量是您知道保持不变的对象状态的条件。在调用方法期间，对象状态将发生变化，可能变为使对象无效的状态，但一旦公共方法完成，对象状态必须保持一致。用户调用类的方法的顺序没有保证，甚至他们是否调用方法都不确定，因此对象必须在用户调用任何方法时都可用。对象的不变方面适用于方法调用级别：在方法调用之间，对象必须保持一致和可用。
- en: 'For example, imagine you have a class that represents a date: it holds a day
    number between 1 and 31, a month number between 1 and 12, and a year number. The
    class invariant is that, whatever you do to objects of the date class, it will
    always hold a valid date. This means that users can safely use objects of your
    date class. It also means that other methods on the class (say, a method to determine
    how many days between two dates, `operator-`) can assume that the values in the
    date objects are valid, so those methods do not have to check the validity of
    the data they act upon.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下您有一个表示日期的类：它保存了1到31之间的日期号，1到12之间的月份号和年份号。类不变条件是，无论您对日期类的对象做什么，它始终保持有效日期。这意味着用户可以安全地使用您的日期类的对象。这也意味着类的其他方法（比如，确定两个日期之间有多少天的方法，`operator-`）可以假定日期对象中的值是有效的，因此这些方法不必检查它们作用的数据的有效性。
- en: 'However, a valid date is more than the ranges 1 to 31 for days and 1 to 12
    for months, because not every month has 31 days. So, if you have a valid date,
    say 5 April 1997, and you call a `set_day` method to set the day number to 31,
    the class invariant condition has been violated since 31 April is not a valid
    date. If you want to change the values in a date object, the only safe way to
    do this is to change all the values: the day, month, and year--at the same time,
    because this is the only way to maintain the class invariance.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有效日期不仅仅是1到31的范围，因为并非每个月都有31天。因此，如果您有一个有效日期，比如1997年4月5日，并调用`set_day`方法将日期号设置为31，那么类不变条件就被违反了，因为4月31日不是有效日期。如果您想更改日期对象中的值，唯一安全的方法是同时更改所有值：日期、月份和年份，因为这是保持类不变性的唯一方法。
- en: One approach is to define a private method in debug builds that tests the invariant
    conditions for the class and ensures with asserts (see later) that the invariants
    are maintained. You can call such a method before a publicly-accessible method
    leaves to ensure that the object remains in a consistent state. Methods should
    also have defined pre- and post-conditions. Pre-conditions are conditions that
    you mandate are true before the method is called, and post-conditions are conditions
    that you guarantee are true after the method has completed. For the methods on
    a class, the class invariants are pre-conditions (because the state of the object
    should be consistent before the method is called) and the invariants are also
    a post-condition (because after the method has finished the object state should
    be consistent).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在调试构建中定义一个私有方法，测试类的不变条件，并确保使用断言（见后文）来维护不变量。您可以在公开可访问的方法离开之前调用此类方法，以确保对象保持一致状态。方法还应该具有定义的前后条件。前置条件是您要求在调用方法之前为真的条件，后置条件是您保证在方法完成后为真的条件。对于类的方法，类不变量是前置条件（因为在调用方法之前对象的状态应该是一致的），不变量也是后置条件（因为在方法完成后对象状态应该是一致的）。
- en: There are also pre-conditions that are the responsibility of the caller of a
    method. The pre-condition is a documented responsibility that the caller ensures.
    For example, the date class will have a pre-condition that day numbers are between
    1 and 31\. This simplifies the class code because methods that take a day number
    can assume that values passed are never out of range (although, because some months
    have fewer than 31 days, values may still not be valid). Again, in debug builds
    you can use asserts to check that such pre-conditions are true, and the tests
    in the assert will be compiled away in the release build. At the end of a method
    there will be post-conditions, that is, the class invariants will be maintained
    (and the state of the object will be valid), and the return value will be valid.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些是方法的调用者的先决条件。先决条件是调用者确保的已记录的责任。例如，日期类将有一个先决条件，即日期数字在1和31之间。这简化了类代码，因为接受日期数字的方法可以假定传递的值永远不会超出范围（尽管由于某些月份少于31天，值可能仍然无效）。同样，在调试构建中，您可以使用断言来检查这些先决条件是否为真，并且断言中的测试将在发布构建中被编译掉。在方法的末尾将有后置条件，即将保持类不变式（对象的状态将有效），并且返回值将有效。
- en: Conditional compilation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编译
- en: As explained in [Chapter 1](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Starting
    with C++*, when your C++ program is compiled there is a pre-compilation step that
    collates all the file included in a C++ source file into a single file, which
    is then compiled. The pre-processor also expands macros and, depending on the
    value of symbols, includes some code and exclude others code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)中所述，*从C++开始*，当编译您的C++程序时，会有一个预编译步骤，将包含在C++源文件中的所有文件汇总到一个单个文件中，然后进行编译。预处理器还会展开宏，并根据符号的值包含一些代码和排除其他代码。
- en: In its simplest form, conditional compilation brackets code with `#ifdef` and
    `#endif` (and optionally using `#else`), so that the code between these directives
    is only compiled if the specified symbol has been defined.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，条件编译用`#ifdef`和`#endif`括起代码（可选地使用`#else`），因此只有在指定的符号已定义时才编译这些指令之间的代码。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are guaranteed that only one of these lines will be compiled, and you are
    guaranteed that at least one of them will be compiled. If the symbol `TEST` is
    defined then the first line will be compiled and, as far as the compiler is concerned,
    the second line does not exist. If the symbol `TEST` is not defined, then the
    second line will be compiled. If you want to type these lines in the opposite
    order, you can use the `#ifndef` directive. The text provided through the conditional
    compilation can be C++ code, or it can be defined using other symbols in the current
    translation unit with `#define` or undefined existing symbols with `#undef`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以确保只有这些行中的一行将被编译，并且至少有一行将被编译。如果定义了符号`TEST`，则将编译第一行，并且对于编译器而言，第二行不存在。如果未定义符号`TEST`，则将编译第二行。如果要以相反的顺序输入这些行，可以使用`#ifndef`指令。通过条件编译提供的文本可以是C++代码，也可以使用当前翻译单元中的其他符号使用`#define`定义，或使用`#undef`未定义现有符号。
- en: 'The `#ifdef` directive simply determines if the symbol exists: it does not
    test its value. The `#if` directive allows you to test an expression. You can
    set a symbol to have a value and compile specific code depending on the value.
    The expression must be integral, so a single `#if` block can test for several
    values using `#if` and multiple `#elif` directives and (at most) one `#else`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`#ifdef`指令只是确定符号是否存在：它不测试其值。`#if`指令允许您测试表达式。您可以设置一个符号具有一个值，并根据该值编译特定的代码。表达式必须是整数，因此单个`#if`块可以使用`#if`和多个`#elif`指令测试多个值，并且（最多）一个`#else`：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the symbol is not defined then the `#if` directive treats the symbol as having
    a value of `0`; if you want to distinguish between these cases you can use the
    `defined` operator to test if a symbol is defined. At most, only one of the sections
    in the `#if`/`#endif` block will be compiled, and if a value is not matched then
    no code will be compiled. The expression can be a macro, in which case the macro
    will be expanded before the condition is tested.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义符号，则`#if`指令将该符号视为具有值`0`；如果要区分这些情况，可以使用`defined`运算符测试符号是否已定义。最多，`#if`/`#endif`块中的部分将被编译，如果值不匹配，则不会编译任何代码。表达式可以是宏，此时在测试条件之前将展开该宏。
- en: 'There are three ways to define a symbol. The first way is out of your control:
    the compiler will define some symbols (typically with the `__` or `_` prefix)
    that give you information about the compiler and the compilation process. Some
    of these symbols will be described in a later section. The other two ways are
    entirely under your control--you can define symbols in a source file (or header
    file) using `#define` or you can define them on the command line using the `/D`
    switch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义符号有三种方式。第一种方式是无法控制的：编译器会定义一些符号（通常带有`__`或`_`前缀），这些符号提供关于编译器和编译过程的信息。其中一些符号将在后面的部分中描述。另外两种方式完全由您控制
    - 您可以在源文件（或头文件）中使用`#define`定义符号，也可以使用`/D`开关在命令行上定义它们：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will compile the source code with the symbol `TEST` set to a value of `1`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用符号`TEST`设置为`1`的值编译源代码。
- en: 'You will typically use conditional compilation to provide code that should
    not be used in production code, for example, extra tracing code to use in debug
    mode or when you are testing code. For example, imagine you have library code
    to return data from a database, but you suspect that the SQL statement in the
    library function is faulty and returning too many values. Here, you may decide
    to test, add code to log the number of values returned:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用条件编译来提供不应在生产代码中使用的代码，例如，在调试模式下使用的额外跟踪代码或测试代码。例如，假设您有一个库代码用于从数据库返回数据，但您怀疑库函数中的SQL语句有问题并返回了太多的值。在这种情况下，您可能决定测试，添加代码来记录返回的值的数量：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Trace messages like this pollute your user interface and you will want to avoid
    them in production code. However, in debugging they can be invaluable in determining
    where problems are occurring.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的跟踪消息会污染您的用户界面，并且您希望在生产代码中避免它们。然而，在调试中，它们可以帮助您确定问题发生的位置。
- en: Any code that you call in debug mode, conditional code should be `const` methods
    (here `vector::size`), that is, they should not affect the state of any objects
    or the application data. You must ensure that the logic of your code is *exactly*
    the same in debug mode as in release mode.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下调用的任何代码，条件代码应该是`const`方法（这里是`vector::size`），也就是说，它们不应该影响任何对象或应用程序数据的状态。您必须确保您的代码在调试模式和发布模式下的逻辑*完全*相同。
- en: Using pragmas
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pragma
- en: Pragmas are compiler-specific and often are concerned with the technical details
    about the code sections in the object files. There are a couple of Visual C++
    pragmas that are useful in debugging code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pragma是特定于编译器的，通常涉及到目标文件中代码部分的技术细节。在调试代码中，有几个Visual C++的pragma是有用的。
- en: In general, you will want your code to compile with as few warnings as possible.
    The default warning for the Visual C++ compiler is `/W1`, which means that only
    the most severe warnings are listed. Increasing the value to 2, 3, or the highest
    value of 4 progressively increases the number of warnings that are given during
    a compilation. Using `/Wall` will give level-4 warnings and warnings that have
    been disabled by default. This last option, even for the simplest code, will produce
    a screen full of warnings. When you have hundreds of warnings useful error messages
    will be hidden between the reams of unimportant warnings. Since the C++ Standard
    Library is complex and uses some code that is decades old, there are some constructs
    that the compiler will warn you about. To prevent these warnings polluting the
    output from your builds, specific warnings in selective files have been disabled.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您希望您的代码尽可能少地产生警告。Visual C++编译器的默认警告是`/W1`，这意味着只列出最严重的警告。将值增加到2、3或最高值4会逐渐增加编译过程中产生的警告数量。使用`/Wall`将会产生4级警告和默认情况下被禁用的警告。即使对于最简单的代码，这个选项也会产生一屏幕的警告。当您有数百个警告时，有用的错误消息将被隐藏在大量不重要的警告之间。由于C++标准库非常复杂，并且使用了一些几十年前的代码，编译器会对一些构造发出警告。为了防止这些警告污染您的构建输出，特定文件中的特定警告已被禁用。
- en: If you are supporting older library code, you may find that the code compiles
    with warnings. You may be tempted to reduce the warning levels using the compiler
    `/W` switch, but that will suppress all warnings higher than the ones you enable,
    and it applies equally to your code as to the library code that you may be including
    into your project. The `warning` pragma gives you a lot more flexibility. There
    are two ways to call this--you can reset the warning level to override the compiler
    `/W` switch and you can change the warning level of a particular warning or disable
    the warning reporting altogether.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您支持旧的库代码，您可能会发现代码编译时会产生警告。您可能会想要使用编译器的`/W`开关来降低警告级别，但这将抑制所有高于您启用的警告，并且同样适用于您的代码以及您可能包含到项目中的库代码。`warning`
    pragma给了您更多的灵活性。有两种调用方式--您可以重置警告级别以覆盖编译器的`/W`开关，也可以更改特定警告的警告级别或完全禁用警告报告。
- en: 'For example, at the top of the `<iostream>` header is the line:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`<iostream>`头文件的顶部是这样一行：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This says store the current warning level and, for the rest of this file (or
    until it is changed), make the warning level 3\. At the bottom of the file is
    the line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示存储当前的警告级别，并在本文件的其余部分（或直到它被更改）中将警告级别设置为3。文件底部是这样一行：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This restores the warning level to that stored earlier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将恢复到之前存储的警告级别。
- en: 'You can also change how one or more warnings are reported. For example, at
    the top of `<istream>` is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以更改一个或多个警告的报告方式。例如，在`<istream>`的顶部是：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first part of this `pragma` is the specifier `disable`, which indicates
    that reporting of a warning type (in this case, 4189) is disabled. If you choose,
    you can change the warning level of a warning by using the warning level (`1`,
    `2`, `3`, or `4`) as the specifier. One use for this is to lower the warning level
    just for a piece of code that you are working on and then return it to its default
    level after the code. For example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pragma`的第一部分是指定符`disable`，表示禁用了某种警告类型的报告（在本例中是4189）。如果您愿意，您可以通过使用警告级别（`1`、`2`、`3`或`4`）作为指定符来改变警告的级别。其中一个用途是在您正在处理的代码片段中降低警告级别，然后在代码完成后将其恢复到默认级别。例如：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function shifts a char right by 8 bits, which will generate the level-1
    warning 4333 (*right shift by too large amount, data loss*). This is a problem
    and needs to be fixed, but for the time being, you want to compile the code without
    warnings from this code and so the warning level is changed to level 2\. Using
    the default warning level (`/W1`) the warning will not be shown. However, if you
    compile with a more sensitive warning level (for example, `/W2`) then this warning
    will be reported. This change in the warning level is only temporary because the
    last line resets the warning level back to its default (which is 1). In this case,
    the warning level is increased, meaning that you will only see it with a more
    sensitive warning level on the compiler. You can also reduce the warning level,
    which means that the warning is more likely to be reported. You can even change
    a warning level to `error` so the code will not compile while warnings of this
    type exist in the code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将char右移8位，这将生成级别1警告4333（*右移位数过大，数据丢失*）。这是一个问题，需要修复，但暂时，您希望编译代码时不会收到来自此代码的警告，因此将警告级别更改为级别2。使用默认警告级别（`/W1`）时，不会显示警告。但是，如果使用更敏感的警告级别（例如，`/W2`）进行编译，则会报告此警告。警告级别的更改仅是临时的，因为最后一行将警告级别重置为其默认值（即1）。在这种情况下，警告级别增加，这意味着只有在编译器上使用更敏感的警告级别时才会看到它。您还可以降低警告级别，这意味着更有可能报告警告。您甚至可以将警告级别更改为`error`，以便在代码中存在此类型的警告时无法编译。
- en: Adding informational messages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加信息性消息
- en: As you test and debug code you will inevitably come across places where you
    can see a potential problem but it has low priority compared to what you are working
    on. It is important to make a note of the issue so that you can address the problem
    at a later stage. In Visual C++, there are two ways to do this in a benign way
    and two ways that will generate an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试和调试代码时，您不可避免地会遇到一些潜在问题，但与您正在处理的问题相比，它的优先级较低。重要的是要记录下问题，以便以后解决问题。在Visual C++中，有两种以温和方式记录问题的方法，还有两种会生成错误的方法。
- en: 'The first way is to add a `TODO:` comment, shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是添加一个`TODO:`注释，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Visual Studio editor has a tool window called the **Task List**. This lists
    the comments in the project that start with one of the predetermined tasks (the
    defaults are `TODO`, `HACK`, and `UNDONE`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio编辑器有一个名为**任务列表**的工具窗口。这列出了项目中以预定任务之一开头的注释（默认为`TODO`、`HACK`和`UNDONE`）。
- en: If the Task List window is not visible, enable it via the View menu. The default
    setting in Visual Studio 2015 is to enable tasks in C++. This is not the case
    for earlier versions, but it can be enabled through the Tools menu, Options dialog
    and then Text Editor, C/C++, Formatting, View by setting Enumerate Comment Tasks
    to Yes. The list of task labels can be found on the Options dialog under the Environment,
    Task List item.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务列表窗口不可见，请通过“视图”菜单启用它。在Visual Studio 2015中，默认设置为启用C++中的任务。对于早期版本来说并非如此，但可以通过“工具”菜单、“选项”对话框，然后“文本编辑器”、“C/C++”、“格式”、“查看”设置“枚举注释任务”为“是”来启用它。任务标签列表可以在“选项”对话框的“环境”、“任务列表”项目下找到。
- en: The Task List lists the tasks with the file and line number, and you can open
    the file and locate the comment by double-clicking on an entry.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表会列出文件和行号，您可以通过双击条目来打开文件并定位注释。
- en: 'The second way to identify code that needs attention is the `message` pragma.
    As the name suggests, this simply allows you to place an informational message
    in your code. When the compiler comes across this pragma it simply puts the message
    on the output stream. Consider the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 识别需要关注的代码的第二种方法是`message`编译指示。顾名思义，这只是允许您在代码中放置信息性消息。当编译器遇到此编译指示时，它只是将消息放在输出流中。考虑以下代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the `test.cpp` file is compiled with this code and `/W1` (the default) warning
    level, the output will be something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此代码编译`test.cpp`文件并且使用默认的`/W1`警告级别，则输出将类似于以下内容：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the string is printed just as the compiler sees it, and there
    is no indication of the file or line number in contrast to the warning message.
    There are ways to address this using compiler symbols.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，字符串会按照编译器看到的方式打印出来，与警告消息相比，没有文件或行号的指示。有办法使用编译器符号来解决这个问题。
- en: 'If the condition is important, you''ll want to issue an error and one way to
    do this is with the `#error` directive. When the compiler reaches this directive,
    it will issue an error. This is a serious action, so you will only use it when
    there is another option. You''ll most likely want to use it with a conditional
    compilation. A typical use is for code that can only be compiled with a C++ compiler:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件很重要，您将希望发出错误，一种方法是使用`#error`指令。当编译器到达此指令时，它将发出一个错误。这是一个严重的操作，因此只有在没有其他选项时才会使用它。您很可能希望将其与条件编译一起使用。典型用法是只能使用C++编译器编译的代码：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you compile a file with this code using the `/Tc` switch to compile code
    as C then the `__cplusplus` preprocessor symbol will not be defined and an error
    will be generated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`/Tc`开关编译此代码文件作为C代码，则`__cplusplus`预处理符号将不会被定义，并且会生成错误。
- en: 'C++11 adds a new directive called `static_assert`. This is called like a function
    (and *calls* are terminated with a semicolon), but it is not a function because
    it is only used at compile time. Further, the directive can be used in places
    where function calls are not used. The directive has two parameters: an expression
    and a string literal. If the expression is `false` then the string literal will
    be outputted at compile time with the source file and line number and an error
    will be generated. At the simplest level, you could use this to issue a message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C++11添加了一个名为`static_assert`的新指令。这类似于函数调用（*调用*以分号结束），但它不是函数，因为它只在编译时使用。此外，该指令可以用于不使用函数调用的地方。该指令有两个参数：一个表达式和一个字符串字面值。如果表达式为`false`，则字符串字面值将在编译时与源文件和行号一起输出，并生成错误。在最简单的级别上，您可以使用它来发出消息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the first parameter is `false`, the directive will issue the error message
    during compilation. The same thing could be achieved with the `#error` directive.
    The `<type_traits>` library has various predicates for testing the properties
    of types. For example, the `is_class` template class has a simple template parameter
    that is a type, and if the type is a `class` then the `static` member `value`
    is set to `true`. If you have a templated function that should only be instantiated
    for classes, you could add this `static_assert`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个参数是`false`，指令将在编译期间发出错误消息。使用`#error`指令也可以实现相同的效果。`<type_traits>`库具有用于测试类型属性的各种谓词。例如，`is_class`模板类具有一个简单的模板参数，即类型，如果该类型是`class`，则`static`成员`value`设置为`true`。如果您有一个应该只对类进行实例化的模板函数，您可以添加这个`static_assert`：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At compile time, the compiler will attempt to instantiate the function and
    instantiate `is_class` on that type using `value` to determine if the compilation
    should continue. For example, the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，编译器将尝试实例化函数并使用`value`在该类型上实例化`is_class`来确定是否应该继续编译。例如，以下代码：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first line will compile correctly because the compiler will instantiate
    a function, `func<string>,` and the parameter is a `class`. However, the second
    line will not compile because the function instantiated is `func<const char*>`
    and `const char*` is not a `class`. The output is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将正确编译，因为编译器将实例化一个函数`func<string>`，参数是一个`class`。然而，第二行将无法编译，因为实例化的函数是`func<const
    char*>`，而`const char*`不是一个`class`。输出是：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `static_assert` is on *line 25*, and hence this generates the error that
    `T must be a class`. *Line 39* is the first call to `func<const char*>` and gives
    context to the error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert`在*第25行*，因此会生成`T must be a class`的错误。*第39行*是对`func<const char*>`的第一个调用，并为错误提供了上下文。'
- en: Compiler switches for debugging
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试的编译器开关
- en: To allow you to single-step through a program with a debugger, you have to provide
    information to allow the debugger to associate machine code with source code.
    At the very least, this means switching off all optimizations, since in an attempt
    to optimize code the C++ compiler will rearrange code. Optimizations are switched
    off by default (so the using the `/Od` switch is redundant), but clearly, to be
    able to debug a process and single-step through C++ code you need to remove all
    the `/O` optimization switches.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让调试器能够逐步执行程序，您必须提供信息，以便调试器将机器代码与源代码关联起来。至少，这意味着关闭所有优化，因为C++编译器在尝试优化代码时会重新排列代码。优化默认关闭（因此使用`/Od`开关是多余的），但显然，为了能够调试进程并逐步执行C++代码，您需要删除所有`/O`优化开关。
- en: Since the C++ Standard Library uses the C Runtime, you will need to compile
    your code to use the latter's debug builds. The switch you use depends on whether
    you are building a process or **Dynamic Link Library** (**DLL**), and whether
    you will statically link the C runtime or access it through a DLL. If you are
    compiling a process, you use `/MDd` to get the debug version of the C runtime
    in a DLL, and if you use `/MTd` you will get the debug version of the static linked
    C runtime. If you are writing a dynamic linked library, you have to use `/LDd`
    in addition to one of the C runtime switches (`/MTd` is the default). These switches
    will define a pre-processor symbol called `_DEBUG`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++标准库使用C运行时，您需要编译您的代码以使用后者的调试版本。您使用的开关取决于您是构建进程还是**动态链接库**（**DLL**），以及您是静态链接C运行时还是通过DLL访问它。如果您正在编译一个进程，您可以使用`/MDd`来获取C运行时的调试版本在DLL中，如果您使用`/MTd`，您将获得静态链接C运行时的调试版本。如果您正在编写一个动态链接库，您必须使用`/LDd`以及一个C运行时开关（`/MTd`是默认值）。这些开关将定义一个名为`_DEBUG`的预处理器符号。
- en: 'A debugger will need to know debugger symbolic information--the names and types
    of variables and the names of functions and line numbers associated with code.
    The accepted way to do this is through a file called a **program database**, with
    an extension of `pdb`. You use one of the `/Z` switches to generate a `pdb` file:
    the `/Zi` or `/ZI` switch will create two files, one with a name starting with
    `VC` (for example `VC140.pdb`) that contains the debugging information for all
    of the `obj` files, and a file with the name of the project that contains debugging
    for the process. If you compile without linking (`/c`) then only the first file
    is created. The Visual C++ project wizard will use `/Od /MDd /ZI` by default for
    debug builds. The `/ZI` switch means that a program database is created in a format
    that allows the Visual C++ debugger to perform `Edit` and `Continue`, that is,
    you can change some code and continue to single-step through the code without
    recompiling. When you compile for a release build, the wizard will use the `/O2
    /MD /Zi` switches, which means that the code is optimized for speed but a program
    database (without `Edit` and `Continue` support) will still be created. The code
    does not need the program database to run (in fact, you should not distribute
    it with your code), but it is useful if you have a crash report and need to run
    the release build code under the debugger.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器需要知道调试器符号信息--变量的名称和类型，函数的名称和与代码相关联的行号。通过名为**程序数据库**的文件来完成这一点，扩展名为`pdb`。您可以使用`/Z`开关之一来生成`pdb`文件：`/Zi`或`/ZI`开关将创建两个文件，一个文件名以`VC`开头（例如`VC140.pdb`），其中包含所有`obj`文件的调试信息，以及一个文件名为项目名称，其中包含进程的调试信息。如果您编译而不链接（`/c`），那么只会创建第一个文件。Visual
    C++项目向导默认使用`/Od /MDd /ZI`进行调试构建。`/ZI`开关意味着以一种允许Visual C++调试器执行`编辑`和`继续`的格式创建程序数据库，也就是说，您可以更改一些代码并继续逐步执行代码而无需重新编译。当您为发布构建编译时，向导将使用`/O2
    /MD /Zi`开关，这意味着代码经过了速度优化，但仍将创建一个程序数据库（不支持`编辑`和`继续`）。代码不需要程序数据库来运行（实际上，您不应该将其与代码一起分发），但如果您有崩溃报告并需要在调试器下运行发布构建代码，它将非常有用。
- en: These `/Z` compiler switches assume the linker is run with the `/debug` switch
    (and if the compiler invokes the linker it will pass this switch). The linker
    will create the project program database from the debug information in the `VC`
    program database file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`/Z`编译器开关假定链接器使用`/debug`开关运行（如果编译器调用链接器，它将传递这个开关）。链接器将从`VC`程序数据库文件中的调试信息创建项目程序数据库。
- en: This raises the question of why a release build file will need a program database.
    If you run a program under the debugger and look at the call stack, you will often
    see a long list of stack frames in operating system files. These usually have
    fairly meaningless names made up of the DLL name and some numbers and characters.
    It is possible to install the symbols (the `pdb` files) for Windows or, if they
    are not installed, instruct the Visual C++ debugger to download the symbols for
    a library being used from a computer on the network called a **symbol server**.
    These symbols are not the source code for the library, but they do give you the
    names of the functions and the types of the parameters, which gives you additional
    information about the state of the call stack at the point where you are single
    stepping.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个问题，为什么发布构建文件需要一个程序数据库。如果你在调试器下运行程序并查看调用堆栈，你经常会看到操作系统文件中的一长串堆栈帧。这些通常有着由DLL名称和一些数字和字符组成的相当无意义的名称。可以安装Windows的符号（`pdb`文件），或者如果它们没有安装，可以指示Visual
    C++调试器从网络上的一台计算机上下载正在使用的库的符号，这被称为**符号服务器**。这些符号不是库的源代码，但它们确实给出了函数的名称和参数的类型，这为你提供了有关在你单步执行时调用堆栈状态的额外信息。
- en: Pre-processor symbols
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理符号
- en: To get access to the tracing, asserts, and reporting facilities in your code,
    you have to enable the debugging runtime library, and this is done by using the
    `/MDd`, `/MTd`, or `/LDd` compiler switches, which will define the `_DEBUG` pre-processor
    symbol. The `_DEBUG` pre-processor symbol enables a lot of facilities, and conversely,
    not defining this symbol will help in optimizing your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用跟踪、断言和报告功能，你必须启用调试运行库，这可以通过使用`/MDd`、`/MTd`或`/LDd`编译器开关来实现，这将定义`_DEBUG`预处理符号。`_DEBUG`预处理符号启用了许多功能，相反，不定义这个符号将有助于优化你的代码。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The C++ compiler will also provide information through some standard pre-processor
    symbols. Most of these are useful only for library writers, but there are some
    that you may want to use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器还将通过一些标准预处理符号提供信息。其中大多数只对库编写者有用，但也有一些你可能想要使用的。
- en: 'The ANSI standard says that the `__cplusplus` symbol should be defined when
    the compiler is compiling code as C++ (rather than C), and it also specifies that
    the `__FILE__` symbol should contain the name of the file and that `__LINE__`
    symbol will have the line number at the point where you access it. The `__func__`
    symbol will have the current function name. This means that you can create tracing
    code like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI标准规定，当编译器编译代码为C++（而不是C）时，应该定义`__cplusplus`符号，它还指定`__FILE__`符号应该包含文件名，`__LINE__`符号将包含你访问它的地方的行号。`__func__`符号将包含当前函数名。这意味着你可以创建如下的跟踪代码：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If this code is compiled for debugging (for example, `/MTd`) then the `cout`
    line will be put inline whenever `TRACE` is used; if the code is not compiled
    for debugging then `TRACE` will do nothing. The `__func__` symbol is simply the
    function name, it is not qualified, so if you use it in a class method it will
    provide no information about the class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码是为调试而编译的（例如，`/MTd`），那么`cout`行将在使用`TRACE`时被内联；如果代码不是为调试而编译的，那么`TRACE`将不起作用。`__func__`符号只是函数名，它没有限定，所以如果你在类方法中使用它，它将不提供关于类的任何信息。
- en: Visual C++ also defines Microsoft-specific symbols. The `__FUNCSIG__` symbol
    gives the complete signature including the class name (and any `namespace` names),
    the return type, and parameters. If you just want the fully qualified name, then
    you can use the `__FUNCTION__` symbol. A symbol that you will see frequently in
    the Windows header files is `_MSC_VER`. This has a number that is the version
    of the current C++ compiler, and it is used with a conditional compilation so
    that newer language features are only compiled with a compiler that supports them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++还定义了微软特定的符号。`__FUNCSIG__`符号提供了完整的签名，包括类名（和任何`namespace`名称）、返回类型和参数。如果你只想要完全限定的名称，那么你可以使用`__FUNCTION__`符号。在Windows头文件中经常看到的一个符号是`_MSC_VER`。这是当前C++编译器版本的数字，它与条件编译一起使用，以便只有支持它们的编译器才能编译新的语言特性。
- en: The Visual C++ project pages define *build macros* with names like `$(ProjectDir)`
    and `$(Configuration)`. These are used only by the MSBuild tool so they are not
    automatically available in a source file during compilation, however, if you set
    a pre-processor symbol to the value of a build macro, the value will be available
    through that symbol at compile time. The system environment variables are also
    available as build macros, so it is possible to use them to influence the build.
    For example, on Windows the system environment variable `USERNAME` has the name
    of the current logged on user so you could use it to set a symbol and then access
    that at compile time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++项目页面定义了类似`$(ProjectDir)`和`$(Configuration)`的*构建宏*。这些只被MSBuild工具使用，因此在编译期间在源文件中它们不会自动可用，但是，如果你将一个预处理器符号设置为构建宏的值，那么该值将在编译时通过该符号可用。系统环境变量也可以作为构建宏使用，因此可以使用它们来影响构建。例如，在Windows上，系统环境变量`USERNAME`包含当前登录用户的名称，因此你可以使用它来设置一个符号，然后在编译时访问它。
- en: 'In the Visual C++ project pages, you can add a **Preprocessor Definition**
    on the C/C++ preprocessor project page called:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual C++项目页面上，你可以在C/C++预处理器项目页面上添加一个**预处理器定义**，名为：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in your code, you could add a line using this symbol:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的代码中，你可以添加一行使用这个符号：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you are using a make file, or just invoking `cl` from the command line,
    you can add a switch to define the symbol like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用一个make文件，或者只是从命令行调用`cl`，您可以添加一个开关来定义符号，如下所示：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Escaping the double quotes here is important because without them the quotes
    are eaten by the compiler.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里转义双引号很重要，因为没有它们，引号会被编译器吞掉。
- en: 'Earlier, you saw how the `#pragma message` and `#error` directives can be used
    to put messages into the output stream of the compiler. When you compile code
    in Visual Studio the compiler and linker outputs will appear in the output window.
    If the message is in the form:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您已经看到了如何使用`#pragma message`和`#error`指令将消息放入编译器的输出流中。在Visual Studio中编译代码时，编译器和链接器的输出将显示在输出窗口中。如果消息的形式是：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: where `path_to_source_file` is the full path to the file, `line` is the line
    number where the `message` appears. Then, when you double click on this line in
    the output window, the file will be loaded (if not already) and the insertion
    point placed on the line.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`path_to_source_file`是文件的完整路径，`line`是`message`出现的行号。然后，当您在输出窗口中双击此行时，文件将被加载（如果尚未加载），并且插入点将放在该行上。
- en: 'The `__FILE__` and `__LINE__` symbols provide you with the information that
    you need to make `#pragma message` and `#error` directives more useful. Outputting
    `__FILE__` is simple because it is a string and C++ will concatenate string literals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__FILE__`和`__LINE__`符号为您提供了使`#pragma message`和`#error`指令更有用的信息。输出`__FILE__`很简单，因为它是一个字符串，C++会连接字符串文字：'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The macro is called as part of the pragma to format the message correctly;
    however, you cannot call the pragma from a macro because the `#` has a special
    purpose (that will be of use in a moment). The result of this code will be something
    like:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 宏作为`#pragma`的一部分来调用以正确格式化消息；但是，您不能从宏中调用`#pragma`，因为`#`有特殊用途（稍后将会用到）。这段代码的结果将类似于：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Outputting `__LINE__` via a macro requires a bit more work because it holds
    a number. This issue is a common one in C, so there is a standard solution using
    two macros and the stringing operator, `#`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过宏输出`__LINE__`需要更多的工作，因为它保存一个数字。这个问题在C中很常见，因此有一个使用两个宏和字符串化运算符`#`的标准解决方案。
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `STRING` macro is used to expand the `__LINE__` symbol to a number and the
    `STRING2` macro to stringify the number. The `AT_FILE` macro formats the entire
    string in the correct format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRING`宏用于将`__LINE__`符号扩展为数字，`STRING2`宏用于将数字字符串化。`AT_FILE`宏以正确的格式格式化整个字符串。'
- en: Producing diagnostic messages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成诊断消息
- en: The effective use of diagnostic messages is a broad topic, so this section will
    just give you the basics. When you design your code, you should make it easy to
    write diagnostic messages, for example, providing mechanisms to dump the contents
    of an object and providing access to the code that tests for class invariants
    and pre- and post-conditions. You should also analyze the code to make sure that
    appropriate messages are logged. For example, issuing a diagnostic message in
    a loop will often fill up your log files, making it difficult to read the other
    messages in the log file. However, the fact that something is consistently failing
    in a loop may in itself be an important diagnostic, as may be the number of attempts
    to carry out a failing act, so you may want to record that.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用诊断消息是一个广泛的话题，所以本节只会给出基础知识。当设计代码时，应该使编写诊断消息变得容易，例如，提供转储对象内容的机制，并提供访问测试类不变量和前后条件的代码。您还应该分析代码，以确保记录适当的消息。例如，在循环中发出诊断消息通常会填满日志文件，使得难以阅读日志文件中的其他消息。然而，循环中一直出现故障可能本身就是一个重要的诊断，尝试执行失败操作的次数也可能是一个重要的诊断，因此您可能希望记录下来。
- en: Using `cout` for diagnostic messages has the advantage of integrating these
    messages with your user output, so that you can see the final effects of the intermediate
    results. The disadvantage is that the diagnostic messages are integrated with
    the user output, and since there are usually a large number of diagnostic messages,
    these will completely swamp the user output of your program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cout`输出诊断消息的优点是将这些消息与用户输出集成在一起，这样您可以看到中间结果的最终效果。缺点是诊断消息与用户输出集成在一起，而且通常有大量的诊断消息，这些消息将完全淹没程序的用户输出。
- en: C++ has two stream objects that you can use instead of `cout`. The `clog` and
    `cerr` stream objects will write character data to the standard error stream (the
    C stream pointer `stderr`), which will usually show on the console as if you are
    using `cout` (which outputs to the standard output stream, the C stream pointer
    `stdout`), but you can redirect it elsewhere. The difference between `clog` and
    `cerr` is that `clog` uses buffered output, which is potentially better-performing
    than the unbuffered `cerr`. However, there is the danger that the data may be
    lost if the application stops unexpectedly without flushing the buffer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++有两个流对象可以代替`cout`。`clog`和`cerr`流对象将字符数据写入标准错误流（C流指针`stderr`），通常会显示在控制台上，就好像您使用`cout`（输出到标准输出流，C流指针`stdout`），但您可以将其重定向到其他地方。`clog`和`cerr`之间的区别在于`clog`使用缓冲输出，这可能比未缓冲的`cerr`性能更好。但是，如果应用程序在没有刷新缓冲区的情况下意外停止，数据可能会丢失。
- en: Since the `clog` and `cerr` stream objects are available in release builds as
    well as debug builds, you should use them only for messages that you are happy
    that your end user will see. This makes them inappropriate for trace messages
    (which will be covered shortly). Instead, you should use them for diagnostic messages
    that the user will be in a position to address (perhaps a file cannot be found
    or the process does not have the security access to perform an action).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`clog`和`cerr`流对象在发布版本和调试版本中都可用，因此应该仅用于您希望最终用户看到的消息。这使它们不适合用于跟踪消息（稍后将介绍）。相反，您应该将它们用于用户能够解决的诊断消息（例如，找不到文件或进程没有安全访问权限执行操作）。
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code opens a file in two steps (rather than using the constructor) and
    the `open` method will return `false` if the file cannot be opened. The code checks
    to see if opening the file was successful, and if it fails, it will tell the user
    via the `clog` object and then return from whatever function contains the code,
    as the `file` object is now invalid and cannot be used. The `clog` object is buffered
    but in this case we want to inform the user immediately, and this is performed
    by the `endl` manipulator, which inserts a newline in the stream and then flushes
    the stream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码以两个步骤打开文件（而不是使用构造函数），`open`方法如果文件无法打开将返回`false`。代码检查是否成功打开文件，如果失败，它将通过`clog`对象告知用户，然后从包含代码的任何函数返回，因为`file`对象现在无效且无法使用。`clog`对象是缓冲的，但在这种情况下，我们希望立即通知用户，这是通过`endl`操作器执行的，它在流中插入一个换行符，然后刷新流。
- en: 'By default, the `clog` and `cerr` stream objects will output to the standard
    error stream and this means that for a console application you can separate out
    the output stream and error stream by redirecting the streams. On the command-line,
    the standard streams can be redirected by using a value of 0 for `stdin`, 1 for
    `stdout,` and 2 for `stderr` and the redirection operator `>`. For example, an
    application `app.exe` could have this code in the `main` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`clog`和`cerr`流对象将输出到标准错误流，这意味着对于控制台应用程序，您可以通过重定向流来分离输出流和错误流。在命令行上，可以使用`stdin`的值为0，`stdout`的值为1，`stderr`的值为2以及重定向操作符`>`来重定向标准流。例如，应用程序`app.exe`可以在`main`函数中包含以下代码：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `cerr` object is not buffered so whether you use `n` or `endl` for a newline
    is irrelevant. When you run this on the command line, you''ll see something like
    this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`cerr`对象不是缓冲的，因此无论您使用`n`还是`endl`进行换行都无关紧要。当您在命令行上运行此代码时，您将看到类似以下的内容：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To redirect a stream to a file, redirect the stream handle (1 for `stdout`,
    2 for `stderr`) to the file; the console will open the file and write the stream
    to the file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将流重定向到文件，请将流句柄（`stdout`的值为1，`stderr`的值为2）重定向到文件；控制台将打开文件并将流写入文件。
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the last chapter showed, C++ stream objects are layered so that calls to
    insert data into a stream will write the data to the underlying stream object,
    depending on the type of stream, with or without buffering. This stream buffer
    object is obtained, and replaced, using the `rdbuf` method. If you want the `clog`
    object redirected to a file by the application, you can write code like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一章所示，C++流对象是分层的，因此向流中插入数据的调用将根据流的类型将数据写入底层流对象，有或没有缓冲。使用`rdbuf`方法获取和替换此流缓冲对象。如果要将`clog`对象重定向到应用程序的文件中，可以编写以下代码：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code the application code will be in the `run_code` function, and the
    rest of the code sets up the `clog` object to redirect to files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，应用程序代码将位于`run_code`函数中，其余代码设置`clog`对象以重定向到文件。
- en: Note that the file is explicitly closed when the `run_code` function returns
    (the application has finished); this is not entirely necessarily because the `ofstream`
    destructor will close the file, and in this case this will happen when the `main`
    function returns. The last line is important. The standard stream objects are
    created before the `main` function is called, and they will be destroyed sometime
    after the `main` function returns, that is, well after the file objects have been
    destroyed. To prevent the `clog` object accessing the destroyed file object, the
    `rdbuf` method is called passing `nullptr` to indicate that there is no buffer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`run_code`函数返回（应用程序已完成）时，文件会被显式关闭；这并不完全必要，因为`ofstream`析构函数将关闭文件，在这种情况下，当`main`函数返回时将会发生。最后一行很重要。标准流对象是在调用`main`函数之前创建的，并且它们将在`main`函数返回后的某个时候被销毁，也就是说，在文件对象被销毁之后。为了防止`clog`对象访问已销毁的文件对象，调用`rdbuf`方法并传递`nullptr`来指示没有缓冲区。
- en: Trace messages with the C runtime
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C运行时的跟踪消息
- en: Often you will want to test your code by running the application in real time
    and output the *trace messages* to test that your algorithms work. Sometimes you
    will want to test the order that functions are called (for example, that correct
    branching occurs in a `switch` statement or in an `if` statement), and in other
    cases you'll want to test intermediate values to see that the input data is correct
    and the calculations on that data are correct.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望通过实时运行应用程序并输出*跟踪消息*来测试您的代码，以测试您的算法是否有效。有时，您会希望测试函数的调用顺序（例如，在`switch`语句或`if`语句中正确分支的发生），在其他情况下，您会希望测试中间值，以确保输入数据正确并且对该数据的计算正确。
- en: Trace messages can produce a lot of data, so it is unwise to send these to the
    console. It is extremely important that trace messages are only produced in debug
    builds. If you leave trace messages in product code, it could seriously impact
    the performance of your application (as will be explained later). Further, trace
    messages are unlikely to be localized, nor will they be checked to see if they
    contain information that could be used to reverse-engineer your algorithms. One
    final issue with trace messages in release builds is that your client will think
    that you are providing them with code that has not been completely tested. It
    is important, then, that trace messages are only generated in debug builds, when
    the `_DEBUG` symbol is defined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪消息可能会产生大量数据，因此将这些消息发送到控制台是不明智的。跟踪消息仅在调试构建中生成非常重要。如果在产品代码中保留跟踪消息，可能会严重影响应用程序的性能（稍后将进行解释）。此外，跟踪消息不太可能被本地化，也不会被检查以查看它们是否包含可用于反向工程您的算法的信息。在发布构建中跟踪消息的另一个问题是，您的客户将认为您正在为他们提供尚未完全测试的代码。因此，非常重要的是，只有在调试构建中定义了`_DEBUG`符号时，才会生成跟踪消息。
- en: The C Runtime provides a series of macros with names starting with `_RPT` that
    can be used to trace messages when `_DEBUG` is defined. There are `char` and wide
    char versions of these macros, and there are versions that will report just the
    trace messages and others that will report the message and the location (source
    file and line number) of the message. Ultimately these macros will call a function
    called `_CrtDbgReport` that will generate the message with the settings that have
    been determined elsewhere.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时提供了一系列以`_RPT`开头的宏，当定义了`_DEBUG`时可以用于跟踪消息。这些宏有`char`和宽字符版本，还有一些版本只报告跟踪消息，另一些版本报告消息和消息的位置（源文件和行号）。最终，这些宏将调用一个名为`_CrtDbgReport`的函数，该函数将使用在其他地方确定的设置生成消息。
- en: 'The `_RPTn` macros (where `n` is `0`, `1`, `2`, `3`, `4`, or `5`) will take
    a format string and 0 to 5 parameters that will be put into the string before
    being reported. The first parameter of the macros indicates the type of message
    to report: `_CRT_WARN`, `_CRT_ERROR`, or `_CRT_ASSERT`. The last two of these
    categories are the same and refer to asserts, which will be covered in a later
    section. The second parameter of the report macros is a format string, which will
    then be followed by the required number of parameters. The `_RPTFn` macros are
    the same format but will report the source file and line number as well as the
    formatted message.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`_RPTn`宏（其中`n`为`0`、`1`、`2`、`3`、`4`或`5`）将接受一个格式字符串和0到5个参数，这些参数将在报告之前放入字符串中。宏的第一个参数表示要报告的消息类型：`_CRT_WARN`、`_CRT_ERROR`或`_CRT_ASSERT`。这些类别中的最后两个是相同的，指的是断言，这将在后面的部分中介绍。报告宏的第二个参数是格式字符串，然后是所需数量的参数。`_RPTFn`宏的格式相同，但还会报告源文件和行号以及格式化的消息。'
- en: 'The default action is that `_CRT_WARN` messages will produce no output and
    the `_CRT_ERROR` and `_CRT_ASSERT` messages will generate a popup window to allow
    you to abort or debug the application. You can change the response to any of these
    message categories by calling the `_CrtSetReportMode` function and providing the
    category and a value indicating the action to take. If you use `_CRTDBG_MODE_DEBUG`
    then the message will be written to the debugger output window. If you use `_CRTDBG_MODE_FILE`
    then the message will be written to a file that you can open and pass the handle
    to the `_CrtSetReportFile` function. (You can also use `_CRTDBG_FILE_STDERR` or
    `_CRTDBG_FILE_STDOUT` as the file handle to send the message to the standard output
    or the error output.) If you use `_CRTDBG_MODE_WNDW` as the report mode then the
    message will be displayed using the Abort/Retry/Ignore dialog box. Since this
    will pause the current thread of execution, it should only be used for assert
    messages (the default action):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认操作是`_CRT_WARN`消息不会产生输出，而`_CRT_ERROR`和`_CRT_ASSERT`消息将生成一个弹出窗口，允许您中止或调试应用程序。您可以通过调用`_CrtSetReportMode`函数并提供类别和指示要采取的操作的值来更改这些消息类别的响应。如果使用`_CRTDBG_MODE_DEBUG`，则消息将写入调试器输出窗口。如果使用`_CRTDBG_MODE_FILE`，则消息将写入一个文件，您可以打开并将句柄传递给`_CrtSetReportFile`函数。（您还可以使用`_CRTDBG_FILE_STDERR`或`_CRTDBG_FILE_STDOUT`作为文件句柄，将消息发送到标准输出或错误输出。）如果将`_CRTDBG_MODE_WNDW`作为报告模式，则消息将使用中止/重试/忽略对话框显示。由于这将暂停当前的执行线程，因此应仅用于断言消息（默认操作）：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you do not provide the `n` in the messages then the next message will be
    appended to the end of your message, and in most cases this is not what you want
    (although you could justify this for a series of calls to the `_RPTn` macros,
    where the last one is terminated with `n`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在消息中不提供`n`，则下一条消息将附加到您的消息末尾，在大多数情况下，这不是您想要的（尽管您可以为对`_RPTn`宏的一系列调用辩解，最后一个使用`n`终止）。
- en: The Visual Studio output window is shown when you compile a project (to show
    it at debug time select the Output option in the View menu), and at the top is
    a combo box labelled Show output from, which will be usually set to Build. If
    you set this to Debug then you will see the debugging messages generated during
    a debugging session. These will include messages about loading debugging symbols
    and messages redirected from the `_RPTn` macros to the output window.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译项目时，Visual Studio输出窗口会显示（在View菜单中选择Output选项以在调试时显示），顶部有一个标有“显示输出来自”的组合框，通常设置为Build。如果将其设置为Debug，则将在调试会话期间看到生成的调试消息。这些消息将包括有关加载调试符号的消息以及从`_RPTn`宏重定向到输出窗口的消息。
- en: 'If you prefer the messages to be directed to a file then you need to open the
    file with the Win32 `CreateFile` function and use the handle from that function
    in a call to the `_CrtSetReportFile` function. To do this, you will need to include
    the Windows header files:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将消息定向到文件，则需要使用Win32的`CreateFile`函数打开文件，并在调用`_CrtSetReportFile`函数时使用该函数的句柄。为此，您需要包含Windows头文件：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `WIN32_LEAN_AND_MEAN` macro will reduce the size of the Windows files included.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIN32_LEAN_AND_MEAN`宏将减小包含的Windows文件的大小。'
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code will direct the warning messages to the text file `log.txt` which
    will be created new every time the application is run.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将警告消息定向到文本文件`log.txt`，每次应用程序运行时都会创建新的文件。
- en: Tracing messages with Windows
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Windows跟踪消息
- en: The `OutputDebugString` function is used to send messages to a debugger. The
    function does this through a *shared memory section* called `DBWIN_BUFFER`. Shared
    memory means that any process can access this memory, and so Windows provides
    two *event objects* called `DBWIN_BUFFER_READY` and `DBWIN_DATA_READY` that control
    read and write access to this memory. These event objects are shared between processes
    and can be in a signalled or unsignalled state. A debugger will indicate that
    it is no longer using the shared memory by signalling the `DBWIN_BUFFER_READY`
    event, at which point the `OutputDebugString` function can write the data to the
    shared memory. The debugger will wait on the `DBWIN_DATA_READY` event, which will
    be signalled by the `OutputDebugString` function when it has finished writing
    to the memory and it is safe to read the buffer. The data written to the memory
    section will be the process ID of the process that called the `OutputDebugString`
    function, followed by a string of up to 4 KB of data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that when you call the `OutputDebugString` function it will
    wait on the `DBWIN_BUFFER_READY` event, which means that when you use this function
    you are coupling the performance of your application to the performance of another
    process, which is usually a debugger (but may not be). It is very easy to write
    a process to access the `DBWIN_BUFFER` shared memory section and get access to
    the associated event objects, so it may be possible that your production code
    will run on a machine where someone has such an application running. For this
    reason, it is vitally important that you use conditional compilation so that the
    `OutputDebugString` function is only used in debug builds--code that will never
    be released to your customers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will need to include the `windows.h` header file to compile this code. As
    for the `_RPT` example, you will have to run this code under a debugger to see
    the output, or have an application like **DebugView** (available from Microsoft's
    Technet website) running.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Windows provides the `DBWinMutex` mutex object to act as an overall *key* to
    accessing this shared memory and event objects. As the name suggests, when you
    have a handle to a mutex you will have mutually exclusive access to the resource.
    The problem is that processes do not have to have a handle to this mutex to use
    these resources and consequently you have no guarantee that, if your application
    thinks it has exclusive access that it will really have exclusive access.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Using asserts
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An assert checks that a condition is true. The assertion means just that: the
    program should not continue if the condition is not true. Clearly asserts should
    not be called in release code and hence conditional compilation must be used.
    Asserts should be used to check for conditions that should never happen: never
    events. Since the conditions do not happen there should be no need for asserts
    in release builds.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime provides the `assert` macro that is available through the `<cassert>`
    header file. The macro, and any functions called in the expression passed as its
    only parameter, will be called unless the `NDEBUG` symbol is defined. That is,
    you do not have to define the `_DEBUG` symbol to use asserts and you should have
    taken extra action to explicitly prevent `assert` from being called.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: It is worth re-iterating this. The `assert` macro is defined even if `_DEBUG`
    is not defined, so an assert could be called in release code. To prevent this
    from happening you must define the `NDEBUG` symbol in a release build. Conversely,
    you can define the `NDEBUG` symbol in a debug build so that you can use tracing
    but do not have to use asserting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you will use asserts in debug builds to check that pre- and post-conditions
    are met in a function and that class invariant conditions are fulfilled. For example,
    you may have a binary buffer that has a special value at the tenth byte position
    and so have written a function to extract that byte:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the calls to `assert` are used to check that the pointer is not `nullptr`
    and that the buffer is big enough. If these asserts are true, then it means that
    it is safe to access the tenth byte through the pointer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not strictly necessary in this code, the assertion expressions
    are given in parentheses. It is good to get into the habit of doing this because
    `assert` is a macro and so a comma in the expression will be treated as a macro
    parameter separator; the parentheses protected against this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `assert` macro will be defined in release builds by default, you
    will have to disable them by defining `NDEBUG` on the compiler command line, in
    your make file, or you may want to use conditional compilation explicitly:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If an assert is called and it fails, then an assert message is printed at the
    console along with source file and line number information and then the process
    is terminated with a call to `abort`. If the process is built with release build
    standard libraries then the process `abort` is straightforward, however, if the
    debug builds are used then the user will see the standard Abort/Retry/Ignore message
    box where the Abort and Ignore options abort the process. The Retry option will
    use **Just-in-Time** (**JIT**) debugging to attach the registered debugger to
    the process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `_ASSERT` and `_ASSERTE` macros are only defined when `_DEBUG`
    is defined, so these macros will not be available in release builds. Both macros
    take an expression and generate an assert message when the expression is `false`.
    The message for the `_ASSERT` macro will include the source file and line number
    and a message stating that the assertion failed. The message for the `_ASSERTE`
    macro is similar but includes the expression that failed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code sets the reporting mode so that the failed assert will be a message
    printed on the console (rather than the default, which is the Abort/Retry/Ignore
    dialog). Since the variable is clearly less than 100, the assert will fail and
    so the process will terminate and the following message will be printed on the
    console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Abort/Retry/Ignore dialog gives the person, testing the application, the
    option of attaching the debugger to the process. If you decide that the failure
    of the assertion is heinous you can force the debugger to attach to the process
    by calling `_CrtDbgBreak`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You do not need to use conditional compilation because in release builds the
    `_CrtDbgBreak` function is a no-operation. In a debug build, this code will trigger
    JIT debugging, which gives you the option to close the application or launch the
    debugger, and if you choose the latter, the registered JIT debugger will be started.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Application termination
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function is the entry point for your application. However, this isn't
    called directly by the operating system because C++ will perform initialization
    before `main` is called. This includes constructing the Standard Library global
    objects (`cin`, `cout`, `cerr`, `clog,` and the wide character versions) and there
    is a whole host of initialization that is performed for the C Runtime Library
    that underpins C++ libraries. Further, there are the global and static objects
    that your code creates. When the `main` function returns, the destructors of global
    and static objects will have to be called and a clean-up performed on the C runtime.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to stop a process deliberately. The simplest is to return
    from the `main` function, but this assumes that there is a simple route back to
    the `main` function from the point that your code wants to finish the process.
    Of course, process termination must be ordered and you should avoid writing code
    where it is normal to stop the process anywhere in the code. However, if you have
    a situation where data is corrupted and unrecoverable and any other action could
    damage more data, you may have no option other than to terminate the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The `<cstdlib>` header file provides access to the header files to the functions
    that allow you to terminate and to handle the termination of an application. When
    a C++ program closes down normally, the C++ infrastructure will call the destructors
    of the objects created in the `main` function (in the reverse order to their construction)
    and the destructors of `static` objects (which may have been created in functions
    other than the `main` function). The `atexit` function allows you to register
    functions (that have no parameters and no return value) that will be called after
    the `main` function completes and `static` object destructors have been called.
    You can register more than one function by calling this function several times,
    and at termination the functions will be called in reverse order to their registering.
    After the functions registered with the `atexit` function have been called, the
    destructors of any global objects will be called.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Microsoft function called `_onexit` that also allows you to
    register functions to be called during normal termination.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The `exit` and `_exit` functions perform a normal exit of a process, that is,
    they clean up the C runtime and flush any open files before shutting down the
    process. The `exit` function does additional work by calling any registered termination
    functions; the `_exit` function does not call these termination functions and
    so is a quick exit. These functions will not call the destructors of temporary
    or automatic objects, so if you use stack objects to manage resources, you will
    have to explicitly call the destructor code before calling `exit`. However, the
    destructors of static and global objects will be called.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The `quick_exit` function causes normal shutdown, but it does not call any destructors
    nor flush any streams, so there is no resource clean up. The functions registered
    with `atexit` are not called, but you can register that termination functions
    are called by registering them with the `at_quick_exit` function. After calling
    these termination functions, the `quick_exit` function calls the `_Exit` function
    that shuts down the process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: You can also call the `terminate` function to close down a process with no clean
    up. This process will call a function that has been registered with the `set_terminate`
    function and then calls the `abort` function. If an exception occurs in the program
    and is not caught--and hence propagates to the `main` function - the C++ infrastructure
    will call the `terminate` function. The `abort` function is the most severe of
    mechanisms that terminate a process. This function will exit the process without
    calling the destructors of objects or performing any other clean up. The function
    raises the `SIGABORT` signal and so it is possible to register a function with
    the `signal` function, which will be called before the process terminates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Error values
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functions are designed to perform an action and return a value based on
    that action, for example, `sqrt` will return the square root of a number. Other
    functions perform more complex operations and use the return value to indicate
    whether the function was successful. There is no common convention about such
    error values, so if a function returns a simple integer there is no guarantee
    that the values one library uses have the same meaning as values returned from
    functions in another library. This means that you have to examine carefully the
    documentation for any library code that you use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Windows does provide common error values, which can be found in the `winerror.h`
    header file, and the functions in the Windows **Software Development Kit** (**SDK**)
    only return values in this file. If you write library code that will be used exclusively
    in Windows applications, consider using the error values in this file because
    you can use the Win32 `FormatMessage` function to obtain a description of the
    error, as explained in the next section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime Library provides a global variable called `errno` (in fact it
    is a macro that you can treat as a variable). C functions will return a value
    to indicate that they have failed and you access the `errno` value to determine
    what the error was. The `<errno.h>` header file defines the standard POSIX error
    values. The `errno` variable does not indicate success, it only indicates errors,
    so you should only access it when a function has indicated that there is an error.
    The `strerror` function will return a C string with a description of the error
    value that you pass as a parameter; these messages are localized according to
    the current C locale set through a call to the `setlocale` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining message descriptions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To obtain the description at runtime for a Win32 error code you use the Win32
    `FormatMessage` function. This will get the description for a system message or
    for a custom message (described in the next section). If you want to use a custom
    message you have to load the executable (or DLL) that has the message resource
    bound to it and pass the `HMODULE` handle to the `FormatMessage` function. If
    you want to get the description of a system message you do not need to load a
    module because Windows will do this for you. For example, if you call the Win32
    `CreateFile` function to open a file and the file cannot be found, the function
    will return a value of `INVALID_HANDLE_VALUE,` indicating that there is an error.
    To get details of the error you call the `GetLastError` function (which returns
    a 32-bit unsigned value sometimes called `DWORD` or `HRESULT`). You can then pass
    the error value to `FormatMessage`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code tries to open a file that does not exist and obtains the error value
    associated with the failure (this will be a value of `ERROR_FILE_NOT_FOUND`).
    The code then calls the `FormatMessage` function to get the string describing
    the error. The first parameter of the function is a flag that indicates how the
    function should work; in this case, the `FORMAT_MESSAGE_FROM_SYSTEM` flag says
    that the error is a system error and the `FORMAT_MESSAGE_ALLOCATE_BUFFER` flag
    says that the function should allocate a buffer large enough to hold the string
    using the Win32 `LocalAlloc` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If the error is a custom value that you have defined then you should use the
    `FORMAT_MESSAGE_FROM_HMODULE` flag, open the file with `LoadLibrary` and use the
    resulting `HMODULE` as the parameter passed in through the second parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter is the error message number (from `GetLastError`) and the
    fourth is a `LANGID` that indicates the language ID to use (in this case `LANG_USER_DEFAULT`
    to get the language ID for the current logged on user). The `FormatMessage` function
    will generate a formatted for the error value, and this string may have replacement
    parameters. The formatted string is returned in a buffer and you have two options:
    you can allocate a character buffer and pass the pointer in as the fifth and the
    length as the sixth parameter, or you can request the function to allocate a buffer
    using the `LocalAlloc` function as in this example. To get access to a function
    allocated buffer you pass the *address* of a pointer variable via the fifth parameter.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Note that the fifth parameter is used to either take a pointer to a user allocated
    buffer, or returns the address of system allocated buffer, and this is why in
    this case the pointer to pointer has to be cast.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Some format strings may have parameters, and if so, the values are passed in
    through an array in the seventh parameter (in this case, no array is passed).
    The result of the preceding code is the string:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using the message compiler, resource files, and the `FormatMessage`, you can
    provide a mechanism to return error values from your functions and then convert
    these to localized strings according to the current locale.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Using the Message Compiler
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example showed that you can obtain localized strings for Win32
    errors, but that you can also create your own errors and provide localized strings
    that are bound as resources to your process or library. If you intend to report
    errors to the end user, you have to make sure that the descriptions are localized.
    Windows provides a tool called the Message Compiler (`mc.exe`) that will take
    a text file with entries for messages in various languages and compile them into
    binary resources that can be bound to a module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This defines three localized strings for the same message. The messages here
    are simple strings, but you can define format messages with placeholders that
    can be provided at runtime. The *neutral* language is US English, and in addition
    we define strings for British English, and French. The names used for the languages
    are defined in the `LanguageNames` lines at the top of the file. These entries
    have the name that will be used later in the file, the code page for the language,
    and the name of the binary resource that will contain the message resource.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MessageId` is the identifier that will be used by the `FormatMessage`
    function, and the `SymbolicName` is a pre-processor symbol that will be defined
    in a header file, so that you can use this message in your C++ code rather than
    the number. This file is compiled by passing it to the command line utility `mc.exe`,
    which will create five files: a header file with the definition of the symbol,
    three binary sources (`MSG00001.bin`, which is created by default for the neutral
    language, and `MSG00409.bin` and `MSG0040C.bin,` which are created because of
    the `LanguageNames` lines), and a resource compiler file.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, the resource compiler file (with extension `.rc`) will contain:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a standard resource file that can be compiled by the Windows SDK resource
    compiler (`rc.exe`), which will compile the message resources into a `.res` file
    that can be bound to an executable or DLL. A process or DLL that has a resource
    of type `11` bound to it can be used by the `FormatMessage` function as a source
    of descriptive error strings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you will not use a message ID of 1 because it is unlikely to be unique
    and you are likely to want to take advantage of the *facility code* and *severity
    code* (for details of facility code, look in the `winerror.h` header file). Further,
    to indicate that the message is not Windows you can set the customer bit of the
    error code using the `/c` switch when you run `mc.exe`. This will mean that your
    error code will not be a simple value like 1, but this should not matter because
    your code will use the symbol defined in the header file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: C++ exceptions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, exceptions are for exceptional conditions. They are not
    normal conditions. They are not conditions that you want to occur but they are
    conditions that may happen. Any exceptional condition will often mean that your
    data will be in an inconsistent state, so using exceptions means that you need
    to think in transactional terms, that is, an operation either succeeds, or the
    state of an object should remain the same as it was before the operation was attempted.
    When an exception occurs in a code block, everything that happened in the code
    block will be invalid. If the code block is part of a wider code block (say, a
    function that is a series of function calls by another function) then the work
    in that other code block will be invalid. This means that the exception may propagate
    out to other code blocks further up the call stack, invalidating the objects that
    depend on the operation being successful. At some point, the exceptional condition
    will be recoverable, so you will want to prevent the exception going further.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Exception specifications
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception specifications are deprecated in C++11 but you may see them in earlier
    code. A specification is through the `throw` expression applied to a function
    declaration giving the exceptions that can be thrown from the function. The `throw`
    specification can be an ellipsis, which means that the function can throw exceptions
    but the type is not specified. If the specification is empty then it means the
    function won't throw exceptions, and this is the same as using the `noexcept`
    specifier in C++11.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The `noexcept` specifier tells the compiler that exception handling is not required,
    so if an exception does occur in the function the exception will not be bubbled
    out of the function and the `terminate` function will be called immediately. In
    this situation, there is no guarantee that the destructors of the automatic objects
    are called.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: C++ exception syntax
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, an exceptional situation is generated by throwing an exception object.
    That exception object can be anything you like: an object, a pointer, or a built-in
    type, but because exceptions may be handled by code written by other people it
    is best to standardize the objects that are used to represent exceptions. For
    this, the Standard Library provides the `exception` class, which can be used as
    a base class.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code tests the parameter and if it is zero then it throws an exception.
    Four examples are given and all are valid C++, but only the last version is acceptable
    because it uses a Standard Library class (or one derived from the Standard Library
    classes) and it follows the convention that exceptions are thrown by value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is thrown, the exception handling infrastructure takes over.
    Execution will stop in the current code block and the exception will be propagated
    up the call stack. As the exception propagates through a code block, all the automatic
    objects will be destroyed, but objects created on the heap in the code black will
    not be destroyed. This is a process called **stack unwinding,** whereby each stack
    frame is cleaned up as much as possible before the exception moves to the stack
    frame above it in the call stack. If the exception is not caught, it will propagate
    up to the `main` function, at which point the `terminate` function will be called
    to handle the exception (and hence it will terminate the process).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'You can protect code to handle propagated exceptions. Code is protected with
    a `try` block and it is caught with an associated `catch` block:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unlike other code blocks in C++, braces are mandatory even if the `try` and
    `catch` blocks contain single lines of code. In the preceding code the second
    call to the `reciprocal` function will throw an exception. The exception will
    halt the execution of any more code in the block, so the third call to the `reciprocal`
    function will not occur. Instead, the exception propagates out of the code block.
    The `try` block is the scope of the objects defined between the braces, and this
    means that the destructors of these objects will be called (`s` and `v`). Control
    is then passed to the associated `catch` blocks, and in this case, there is just
    one handler. The `catch` block is a separate block to the `try` block, so you
    cannot access any variables defined in the `try` block. This makes sense because
    when an exception is generated the entire code block is *tainted* so you cannot
    trust any object created in that block. This code uses the accepted convention,
    that is, exceptions are caught by reference, so that the actual exception object,
    and not a copy, is caught.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention is: throw my value, catch-by-reference.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The Standard Library provides a function called `uncaught_exception`, which
    returns `true` if an exception has been thrown but not yet handled. It may seem
    odd to be able to test for this since no code other than the exception infrastructure
    will be called when an exception has occurred (for example the `catch` handlers)
    and you should put exception code there. However, there *is* other code that is
    called when an exception is thrown: the destructors of automatic objects that
    are destroyed during the stack clear up. The `uncaught_exception` function should
    be used in a destructor to determine if the object is being destroyed due to an
    exception rather than normal object destruction due to an object going out of
    scope or being deleted. For example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This simple object indicates if it is being destroyed because of exception
    stack unwinding. It can be tested like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `f` function will throw an exception only if it is called with a `true`
    value. The `main` function calls `f` twice, once with a value of `false` (so the
    exception is not thrown in `f`) and a second time with `true`. The output is:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first-time `f` is called, the `test` object is destroyed normally, so `uncaught_exception`
    will return `false`. The second-time `f` is called the `test` object in the function
    is being destroyed before the exception has been caught, so `uncaught_exception`
    will return `true`. Since an exception is thrown, the execution leaves the `try`
    block and so the `test` object in the `try` block is destroyed and `uncaught_exception`
    will return `true`. Finally, when the exception has been handled and control returns
    to code after the `catch` block, the `test` object created on the stack in the
    `main` function will be destroyed when the `main` function returns and so `uncaught_exception`
    will return `false`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Standard exception classes
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `exception` class is a simple container for a C string: the string is passed
    as a constructor parameter and is available through the `what` accessor. The Standard
    Library declares the exception class in the `<exception>` library, and you are
    encouraged to derive your own exception classes from this. The Standard Library
    provides the following derived classes; most are defined in `<stdexcept>`.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Thrown** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| `bad_alloc` | When the `new` operator has been unable to allocate memory
    (in `<new>`) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `bad_array_new_length` | When the `new` operator has been asked to create
    an array with an invalid length (in `<new>`) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `bad_cast` | When `dynamic_cast` to a reference type fails (in `<typeinfo>`)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| `bad_exception` | An unexpected condition has occurred (in `<exception>`)
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| `bad_function_call` | Invoked an empty `function` object (in `<functional>`)
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| `bad_typeid` | When the argument of `typeid` is null (in `<typeinfo>`) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `bad_weak_ptr` | When accessing a weak pointer, which refers to an already
    destroyed object (in `<memory>`) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `domain_error` | When an attempt is made to perform an operation outside
    the domain on which the operation is defined |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `invalid_argument` | When an invalid value has been used for a parameter
    |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `length_error` | When an attempt has been made to exceed the length defined
    for an object |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `logic_error` | When there is a logic error, for example, class invariants
    or pre-conditions |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `out_of_range` | When an attempt has been made to access elements outside
    of the range defined for the object |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `overflow_error` | When a calculation results in a value bigger than the
    destination type |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `range_error` | When a calculation results in a value outside the range for
    the type |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `runtime_error` | When an error occurs outside the scope of the code |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `system_error` | Base class to wrap operating system errors (in `<system_error>`)
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `underflow_error` | When a calculation results in an underflow |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: All the classes, mentioned in the preceding table, have a constructor that takes
    a `const char*` or a `const string&` parameter, in contrast to the `exception`
    class that takes a C string (hence the base class is constructed using the `c_str`
    method if the description is passed through a `string` object). There are no wide
    character versions, so if you want to construct an exception description from
    a wide character string you have to convert it. Also, note that the standard exception
    classes only have one constructor parameter, and this is available through the
    inherited `what` accessor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: There is no absolute rule about the data that an exception can hold. You can
    derive a class from `exception` and construct it with whatever values you want
    to make available to the exception handler.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions by type
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There can be more than one `catch` block with each `try` block, which means
    that you can tailor the exception handling according to the exception type. The
    types of the parameters in the `catch` clauses will be tested against the type
    of the exception in the order that they are declared. The exception will be handled
    by the first handler that matches the exception type, or is a base class. This
    highlights the convention to catch the exception object via a reference. If you
    catch as a base class object a copy will be made, slicing the derived class object.
    In many cases code, will throw objects of a type derived from the `exception`
    class so it means that a catch handler for `exception` will catch all exceptions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Since code can throw any object, it is possible that an exception will propagate
    out of the handler. C++ allows you to catch everything by using an ellipses in
    the `catch` clause. Clearly, you should order the `catch` handlers from the most
    derived to the least derived and (if you use it) with the ellipses handler at
    the end:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the guarded code does not throw an exception, then the `catch` blocks are
    not executed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: When your handler examines the exception, it may decide that it does not want
    to suppress the exception; this is called rethrowing the exception. To do this,
    you can use the `throw` statement without an operand (this is only allowed in
    a `catch` handler), which will rethrow the actual exception object that was caught,
    and not a copy.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are thread-based and so it is difficult to propagate an exception
    to another thread. The `exception_ptr` class (in `<exception>`) provides shared
    ownership semantics for an exception object of any type. You can get a shared
    copy of an exception object by calling the `make_exception_ptr` object, or you
    can even get a shared copy of the exception being handled in a `catch` block using
    `current_exception`. Both functions return an `exception_ptr` object. An `exception_ptr`
    object can hold an exception of any kind, not just those derived from the `exception`
    class, so getting information from the wrapped exception is specific to the exception
    type. The `exception_ptr` object knows nothing about these details, so instead
    you can pass it to `rethrow_exception` in the context where you want to use the
    shared exception (another thread) and then catch the appropriate exception object.
    In the following code, there are two threads running. The `first_thread` function
    runs on one thread and the `second_thread` function on the other:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding code looks like it is using `exception_ptr` as a pointer. In fact,
    `eptr` is created as a global object and the assignment to `nullptr` uses the
    copy constructor to create an empty object (where the wrapped exception is `nullptr`).
    Similarly, the comparison with `nullptr` actually tests the wrapped exception.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: This book is not about C++ threading, so we won't go into the details of the
    signalling between two threads. This code shows that a shared copy of an exception,
    *any exception*, can be stored in one context and then rethrown and processed
    in another context.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Function try blocks
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may decide that you want to protect an entire function with a `try` block,
    in which case you could write code like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This uses the `reciprocal` function, as defined earlier, that will throw an
    `exception` if the parameter is zero. An alternative syntax for this is:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This looks rather odd because the function prototype is followed immediately
    by the `try... catch` block and there is no outer set of braces. The function
    body is the code in the `try` block; when this code completes the function returns.
    If the function returns a value, it must do it in the `try` block. In most cases,
    you will find that this syntax makes your code less readable, but there is one
    situation where it may be useful--for initializer lists in constructors.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this code, we wrap a `double` value that is simply the reciprocal of the
    parameter passed to the constructor. The data member is initialized by calling
    the `reciprocal` function in the initializer list. Since this is outside of the
    constructor body, an exception that occurs here will be passed straight to the
    code that calls the constructor. If you want to do some additional processing,
    then you could call the reciprocal function inside the constructor body:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is important to note that the exception will be automatically rethrown because
    any exception in a constructor means that the object is invalid. However, this
    does allow you to do some additional processing, if necessary. This solution will
    not work for exceptions thrown in a base object constructor because, although
    you can call a base constructor in the derived constructor body, the compiler
    will call the default constructor automatically. If you want the compiler to call
    a constructor other than the default constructor you have to call it in the initializer
    list. An alternative syntax to providing exception code in the `inverse` constructor
    is to use function `try` blocks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This looks a little cluttered, but the constructor body is still after the initializer
    list giving an initial value to the `recip` data member. Any exception from the
    call to `reciprocal` will be caught and automatically rethrown after processing.
    The initializer list can contain calls to the base class and any of the data members
    and all will be protected with the `try` block.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: System errors
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<system_error>` library defines a series of classes to encapsulate system
    errors. The `error_category` class provides a mechanism to convert numeric error
    values into localized descriptive strings. Two objects are available through the
    `generic_category` and `system_category` functions in `<system_error>`, and `<ios>`
    has a function called `isostream_category`; all of these functions return an `error_category`
    object. The `error_category` class has a method called `message` that returns
    a string description of the error number you pass as the parameter. The object
    returned from the `generic_category` function will return the descriptive string
    for a POSIX error, so you can use it to get a description for an `errno` value.
    The object returned from the `system_category` function will return an error description
    via the Win32 `FormatMessage` function using `FORMAT_MESSAGE_FROM_SYSTEM` for
    the flags parameter, and hence this can be used to get the descriptive message
    for a Windows error message in a `string` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Note that `message` has no extra parameters to pass in values for a Win32 error
    message that takes parameters. Consequently, in those situations you will get
    back a message that has formatting placeholders.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In spite of the name, the `isostream_category` object essentially returns the
    same descriptions as the `generic_category` object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The `system_error` exception is a class that reports one of the values described
    by one of the `error_category` objects. For example, this is the example used
    earlier for `FormatMessage` but re-written using `system_error`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `system_error` constructor used here has the error value as the first parameter
    (a `ulong` returned from the Win32 function `GetLastError`) and a `system_category`
    object used to convert the error value to a descriptive string when the `system_error::what`
    method is called.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Nested exceptions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `catch` block may rethrow the current exception by calling `throw` without
    any operand, and there will be stack unwinding until the next `try` block is reached
    in the call stack. You can also rethrow the current exception *nested inside*
    another exception. This is achieved by calling the `throw_with_nested` function
    (in `<exception>`) and passing the new exception. The function calls `current_exception`
    and wraps the exception object in a nested exception along with the parameter,
    which is then thrown. A `try` block further up the call stack can catch this exception,
    but it can only access the outer exception; it has no direct access to the inner
    exception. Instead, the inner exception can be thrown with a call to `rethrow_if_nested`.
    For example, here is another version of code to open a file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The code opens a file, and if the file does not exist then a state bit is set
    (you can test the bits later with a call to the `rdstat` method). The next line
    indicates the values of the state bits that should be handled by the class throwing
    an exception, and in this case the `ios_base::failbit` is provided. If the constructor
    failed to open the file then this bit will be set, so the `exceptions` method
    will respond by throwing an exception. In this example, the exception is caught
    and wrapped into a nested exception. The outer exception is a `system_error` exception,
    which is initialized with an error value of `ENOENT` (which means that the file
    does not exist) and an `error_category` object to interpret it, passing the name
    of the file as additional information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'This function can be called like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The exception caught here can be accessed, but it just gives information about
    the outer object:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This message is constructed by the `system_error` object using the additional
    information passed to its constructor and the description from the category object.
    To get the inner object in a nested exception you have to tell the system to throw
    the inner exception with a call to `rethrow_if_nested`. So, instead of printing
    out the outer exception, you call a function like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This prints the description for the outer exception and then calls `rethrow_if_nested,`
    which will only throw the exception if it is nested. If so, it throws the inner
    exception, which is then caught and recursively calls the `print_exception` function.
    The result is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The last line is the inner exception which was thrown when the `ifstream::exception`
    method was called.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Structured Exception Handling
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native exceptions in Windows are **Structured Exceptions Handling** (**SEH**)
    and Visual C++ has a language extension to allow you to catch these exceptions.
    It is important to understand that they are not the same as C++ exceptions, which
    are considered by the compiler to be *synchronous*, that is, the compiler knows
    if a method may (or specifically, will not) throw a C++ exception, and it uses
    this information when analysing code. C++ exceptions are also caught by type.
    SEH is not a C++ concept, so the compiler treats structured exceptions as being
    *asynchronous*, meaning it treats any code within an SEH protected block as potentially
    raising a structured exception, and hence the compiler cannot perform optimizations.
    SEH exceptions are also caught by exception code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The language extensions for SEH are extensions to Microsoft C/C++, that is,
    they can be used in C as well as C++ so the handling infrastructure does not know
    about object destructors. Additionally, when you catch an SEH exception, no assumptions
    are made about the state of the stack or any other part of your process.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Although most Windows functions will catch the SEH exceptions generated by the
    kernel in an appropriate way, some purposely allow them to propagate (for example,
    the **Remote Procedure Calls** (**RPC**) functions, or those used for memory management).
    With some Windows functions you can explicitly request that errors are handled
    with SEH exceptions. For example, the `HeapCreate` set of functions will allow
    a Windows application to create a private heap, and you can pass the `HEAP_GENERATE_EXCEPTIONS`
    flag to indicate that errors in creating the heap, and allocating, or reallocating
    memory in a private heap, will generate an SEH exception. This is because the
    developer calling these functions may regard the failure to be so serious that
    it is not recoverable, and hence the process should terminate. Since an SEH is
    such a serious situation, you should review carefully whether it is appropriate
    (which is not entirely impossible) to do much more than report details of the
    exception and terminate the process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'SEH exceptions are essentially low-level operating system exceptions, but it
    is important to be familiar with the syntax because it looks similar to C++ exceptions.
    For example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The SEH exception code is highlighted here. This code uses the Windows `VirtualAlloc`
    function to reserve a number of pages of memory. Reserving does not allocate the
    memory, that action has to be carried out in a separate operation called **committing
    the memory**. Windows will reserve (and commit) memory in blocks called **pages**
    and on most systems a page is 4096 bytes, as assumed here. The call to the `VirtualAlloc`
    function indicates that it should reserve ten pages of 4096 bytes, which will
    be committed (and used) later.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter to `VirtualAlloc` indicates the location of the memory,
    but since we are reserving memory, this is unimportant so `nullptr` is passed.
    If the reserving succeeds, then a pointer is returned to the memory. The `for`
    loop simply writes data to the memory one byte at a time. The highlighted code
    protects this memory access with structured exception handling. The protected
    block starts with the `__try` keyword. When an SEH is raised, execution passes
    to the `__except` block. This is very different to the `catch` block in C++ exceptions.
    Firstly, `__except` exception handler receives one of three values to indicate
    how it should behave. Only if this is `EXCEPTION_EXECUTE_HANDLER` will the code
    in the handler block be run (in this code, to shut down the process abruptly).
    If the value is `EXCEPTION_CONTINUE_SEARCH` then the exception is not recognized
    and the search will continue up the stack, *but without C++ stack unwinding*.
    The surprising value is `EXCEPTION_CONTINUE_EXECUTION,` because this dismisses
    the exception and execution in the `__try` block will continue. *You cannot do
    this with C++ exceptions*. Typically, SEH code will use an exception filter function
    to determine what action is required of the `__except` handler. In this code,
    this filter is called `exception_filter,` which is passed the exception code obtained
    by calling the Windows function `GetExceptionCode`. This syntax is important because
    this function can only be called in the `__except` context.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The first time the loop runs no memory will have been committed and so the
    code that writes to the memory will raise an exception: a page fault. Execution
    will pass to the exception handler and through to `exception_filter`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It is important in SEH code to only handle exceptions that you know about, and
    only consume the exception if you know that the condition has been completely
    addressed. If you access Windows memory that has not been committed, the operating
    system generates an exception called a page fault. In this code, the exception
    code is tested to see if it is a page fault, and if not, the filter returns telling
    the exception handler to run the code in the exception handler block that terminates
    the process. If the exception is a page fault then we can commit the next page.
    First, there is a test to see if the page number is within the range that we will
    use (if not, then close down the process). Then, the next page is committed with
    another call to `VirtualAlloc` to identify the page to commit and the number of
    bytes in that page. If the function succeeds, it will return a pointer to the
    committed page or a null value. Only if committing the page has succeeded will
    the filter return a value of `EXCEPTION_CONTINUE_EXECUTION`, indicating that the
    exception has been handled and execution can continue at the point the exception
    was raised. This code is a standard way to use `VirtualAlloc` because it means
    that memory pages are only committed when, and if, they are needed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: SEH also has the concept of termination handlers. When execution leaves the
    `__try` block of code through a call to `return`, or by completing all of the
    code in the block, or by calling the Microsoft extension `__leave` instruction,
    or has raised an SEH, then the termination handler block of code marked with `__finally`
    is called. Since the termination handler is always called, regardless of how the
    `__try` block is exited, it is possible to use this as a way to release resources.
    However, because SEH does not do C++ stack unwinding (nor call destructors), this
    means that you cannot use this code in a function that has C++ objects. In fact,
    the compiler will refuse to compile a function that has SEH and created C++ objects,
    either on the function stack or allocated on the heap. (You can, however, use
    global objects or objects allocated in calling functions and passed in as parameters.)
    The `__try`/`__finally` construct looks useful, but is constrained by the requirement
    that you cannot use it with code that creates C++ objects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Compiler exception switches
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it is worth explaining why you have compiled your code with the
    `/EHsc` switch. The simple answer is, if you do not use this switch the compiler
    will issue a warning from the Standard Library code, and as the Standard Library
    uses exceptions you must use the `/EHsc` switch. The warning tells you to do this,
    so that is what you do.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: The long answer is that the `/EH` switch has three arguments that you can use
    to influence how exceptions are handled. Using the `s` argument tells the compiler
    to provide the infrastructure for synchronous exceptions, that is, C++ exceptions
    that may be thrown in a `try` block and handled in a `catch` block, and that have
    stack unwinding that calls the destructors of automatic C++ objects. The `c` argument
    indicates that `extern C` functions (that is, all the Windows SDK functions) never
    throw C++ exceptions (and hence the compiler can do an additional level of optimization).
    Hence, you can compile Standard Library code with either `/EHs` or `/EHsc`, but
    the latter will generate more optimized code. There is an additional argument,
    where `/EHa` indicates that the code will catch *both* synchronous and asynchronous
    exceptions (SEH) with `try`/`catch` blocks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Mixing C++ and SEH exception handling
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RaiseException` Windows function will throw an SEH exception. The first
    parameter is the exception code and the second indicates if the process can continue
    after this exception is handled (`0` means it can). The third and fourth parameters
    give additional information about the exception. The fourth parameter is a pointer
    to an array with these additional parameters and the number of parameters is given
    in the third parameter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'With `/EHa`, you can write code like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The problem with this code is that it handles all SEH exceptions. This is quite
    dangerous because some SEH exceptions may indicate that the process state is corrupted,
    so it is dangerous for the process to continue. The C Runtime Library provides
    a function called `_set_se_translator` that provides a mechanism to indicate which
    SEH exceptions are handled by `try`. This function is passed a pointer by a function
    that you write with this prototype:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first parameter is the exception code (which will be returned from the
    `GetExceptionCode` function) and the second parameter is the return from the `GetExceptionInformation`
    function and has any additional parameters associated with the exception (for
    example, those passed through the third and fourth parameters in `RaiseException`).
    You can use these values to throw a C++ exception in place of the SEH. If you
    provide this function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can now register the function before handling an SEH exception:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this code, the `RaiseException` function is raising a custom SEH with a
    value of 1\. This translation is perhaps not the most useful, but it illustrates
    the point. The `winnt.h` header file defines the exception code for the standard
    SEH exceptions that can be raised in Windows code. A more useful translation function
    would be:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This allows you to call the reciprocal function as following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Writing exception-safe classes
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, when you write classes, you should ensure that you protect the users
    of your classes from exceptions. Exceptions are not an error propagation mechanism.
    If a method on your class fails but is recoverable (the object state is left consistent)
    then you should use the return value (most likely an error code) to indicate this.
    Exceptions are for exceptional situations, those that have invalidated data and
    where, at the point where the exception is raised, the situation is unrecoverable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: When an exception occurs in your code, you have three options. Firstly, you
    can allow the exception to propagate up the call stack and put the responsibility
    of handling the exception on the calling code. This means that you call code without
    guarding by `try` blocks, even though the code is documented as being able to
    throw exceptions. In this situation, you must be reassured that the exception
    makes sense to the calling code. For example, if your class is documented as a
    network class and uses a temporary file to buffer some data received from the
    network, if the file access code throws an exception, the exception object will
    not make sense to code that calls your code, because that client code thinks that
    your class is about accessing network data, not file data. If, however, the network
    code throws an error, it may make sense to allow those exceptions to propagate
    to calling code, especially if they refer to errors that require external action
    (say, a network cable is unplugged or there is a security issue).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you can apply your second option, which is to protect code that
    can throw exceptions with a `try` block, catch known exceptions, and throw a more
    appropriate exception, perhaps nesting the original exception so that the calling
    code can do more detailed analysis. If the exception is one that makes sense to
    your calling code, you may allow it to propagate out, but catching the original
    exception allows you to take additional action before you rethrow it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Using the buffered network data example, you could decide that since there is
    an error in the file buffering, it means that you cannot read any more network
    data, so your exception handling code should shut down the network access in a
    graceful way. The error occurred in the file code, not the network code, so an
    abrupt shutdown of the network is not justified, and it makes more sense to allow
    the current network action to complete (but ignore the data), so that no errors
    are propagated back to the network code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The final option is to protect all code with a `try` block, and catch and consume
    exceptions, so that calling code completes without throwing an exception. There
    are two main situations where this is appropriate. Firstly, the error may be recoverable,
    and so in the `catch` clause you can take steps to address the issue. In the buffered
    network data example, when opening a temporary file, if you get an error that
    a file with the requested name already exists, you can simply use another name
    and try again. The user of your code does not need to know that this problem occurred
    (although, it may make sense to trace this error so that you can investigate the
    issue in the testing phase of your code). If the error is not recoverable, it
    may make more sense to invalidate the state of your object and return an error
    code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Your code should utilize the behavior of the C++ exception infrastructure, which
    guarantees that automatic objects are destroyed. Therefore, when you use memory
    or other appropriate resources, you should wrap them in smart pointers whenever
    possible so that if an exception is thrown then the resource is released by the
    smart pointer destructor. Classes that use Resource Acquisition Is Initialization
    (RAII) are `vector`, `string`, `fstream,` and the `make_shared` function, so if
    the object construction (or the function call) is successful, it means that the
    resource has been acquired, and you can use the resource through these objects.
    These classes are also **Resource Release Destruction** (**RRD**), which means
    that the resource is released when the object is destroyed. The smart pointer
    classes, `unique_ptr` and `shared_ptr`, are not RAII because they simply wrap
    the resource and the allocation of resources is carried out separately by other
    code. However, these classes are RRD, so you can be assured that if an exception
    is thrown the resource is released.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling can offer three levels of exception safety. At the safest
    level of the scale is the *no-fail* method and function. This is the code that
    does not throw exceptions and does not allow exceptions to propagate. Such code
    will guarantee that class invariants are maintained and that the object state
    will be consistent. No-fail code is not achieved by simply catching all exceptions
    and consuming them, instead, you have to protect all code and catch, and handle,
    all exceptions to ensure that the object is left in a consistent state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: All built-in C++ types are no-fail. You also have a guarantee that all Standard
    Library types have no-fail destructors, but since containers will call the contained
    object destructors when instances are destroyed, this means that you have to ensure
    that the types you write to put in containers also have a no-fail destructor.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing no-fail types can involve quite detailed code, so another option is
    the *strong guarantee*. Such code will throw exceptions, but they ensure that
    no memory is leaked and that when an exception is thrown the object will be in
    the same state as when the method was called. This is essentially a transactional
    operation: either the object is modified or it is left unmodified, as if no attempt
    was made to perform the operation. In most cases methods, this will offer a *basic
    guarantee* of exception safety. In this case, there is a guarantee that whatever
    happens no memory is leaked, but when an exception is thrown, the object may be
    left in an inconsistent state, so the calling code should handle the exception
    by discarding the object.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is important. If the object methods are marked with `throw` or
    `noexcept` then you know it is no-fail. You should only assume the strong guarantee
    if the documentation says so. Otherwise, you can assume that objects will have
    the basic guarantee of exception safety, and if an exception is thrown the object
    is invalid.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write your C++ code you should always have one eye looking towards
    the testing and debugging of your code. The ideal way to prevent the need to debug
    code is to write robust, well-designed code. Ideals are difficult to achieve,
    so it is better to write code that is easy for you to diagnose issues and easy
    to debug with. The C Runtime and the C++ Standard Library provides a wide range
    of facilities to enable you to trace and report issues, and through error code
    handling and exceptions you have a rich collection of tools to report and handle
    the failure of functions.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book you should be aware that the C++ language and Standard
    Library provide a rich, flexible, and powerful way to write code. What's more,
    once you know how to use the language and its libraries, C++ is a pleasure to
    use.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
