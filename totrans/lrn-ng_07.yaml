- en: Asynchronous Data Services with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to data services and APIs and handling asynchronous information is
    a common task in our everyday lives as developers. In this sense, Angular provides
    an unparalleled tool set to help its enthusiastic developers when it comes to
    consuming, digesting, and transforming all kinds of data fetched from data services.
  prefs: []
  type: TYPE_NORMAL
- en: There are so many possibilities that it would require an entire book to describe
    all that you can do to connect to APIs or to consume information from the filesystem
    asynchronously through HTTP. In this book, we will only scratch the surface, but
    the insights covered in this chapter about the HTTP API and its companion classes
    and tools will give you all that you need to connect your applications to HTTP
    services in no time, leaving all that you can do with them up to your creativity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the different strategies for handling asynchronous data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce Observables and Observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss functional reactive programming and RxJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the HTTP class and its API and learn some nice service patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about Firebase and how to connect it to your Angular app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See all of the preceding points in action through actual code examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies for handling asynchronous information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming information from an API is a common operation in our daily practice.
    We consume information over HTTP all the time—when authenticating users by sending
    out credentials to an authentication service, or when fetching the latest tweets
    in our favorite Twitter widget. Modern mobile devices have introduced an unparalleled
    way of consuming remote services by deferring requests and response consumption
    until mobile connectivity is available. Responsivity and availability have become
    a big deal. Although modern internet connections are ultra-fast, there is always
    a response time involved when serving such information that forces us to put in
    place mechanisms to handle states in our applications in a transparent way for
    the end user.
  prefs: []
  type: TYPE_NORMAL
- en: This is not specific to scenarios where we need to consume information from
    an external resource.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous response - from callbacks to promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might need to build functionalities that depend on time as a parameter
    of something, and we need to introduce code patterns that handle this deferred
    change in the application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all these scenarios, we have always used code patterns, such as the callback
    pattern, where the function that triggers the asynchronous action expects another
    function in its signature, which will emit a sort of notification as soon as the
    asynchronous operation is completed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this pattern is that code can become quite confusing and cumbersome
    as the application grows and more and more nested callbacks are introduced. In
    order to avoid this scenario, `Promises`introduced a new way of envisioning asynchronous
    data management by conforming to a neater and more solid interface, in which different
    asynchronous operations can be chained at the same level and even be split and
    returned from other functions. The following code introduces how to construct
    a `Promise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code example is perhaps a bit more verbose, but it definitely
    produces a more expressive and elegant interface for our function. As for chaining
    data, we need to understand what problem we are solving. We are solving something
    called callback hell, looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen in the preceding code, we have a situation where we are dependent
    on the previous async call and the data it brings back before we are able to do
    the next async call. This leads to us having to execute a method inside of a callback
    inside of a callback, and so on and so forth. You get the idea—the code quickly
    ends up looking horrible, also known as *callback hell*. Continuing with the subject
    of chaining async calls, chaining is the answer to *callback hell* and `Promises` allows
    us to chain them, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The chaining of the `.then()`method calls in the preceding code shows how we
    can clearly line up one async call after another, and that the previous async
    call has input its result in the upcoming `async` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `Promises` take over the coding arena by storm and no developer out there
    seems to question the great value they bring to the game. So, why do we need another
    paradigm? Well, because sometimes we might need to produce a response output that
    follows a more complex digest process as it is being returned, or even cancel
    the whole process. This cannot be done with `Promises`, because they are triggered
    as soon as they''re being instantiated. In other words, `Promises` are not lazy.
    On the other hand, the possibility of tearing down an asynchronous operation after
    it has been fired but not completed yet can become quite handy in certain scenarios.
    `Promises` only allow us to resolve or reject an asynchronous operation, but sometimes
    we might want to abort everything before getting to that point. On top of that,
    `Promises` behave as one-time operations. Once they are resolved, we cannot expect
    to receive any further information or state change notification unless we run
    everything again from scratch. Moreover, we sometimes need a more proactive implementation
    of async data handling. This is where Observables come into the game. To summarize
    the limitations of promises:'
  prefs: []
  type: TYPE_NORMAL
- en: They cannot be cancelled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are  immediately executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are one-time operations only; there is no easy way to retry them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They respond with only one value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Observable is basically an async event emitter that informs another element,
    called the Observer, that the state has changed. In order to do so, the Observable
    implements all of the machinery that it needs to produce and emit such async events,
    and it can be fired and canceled at any time regardless of whether it has emitted
    the expected data events already or not.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern allows concurrent operations and more advanced logic since the
    Observers that subscribe to the Observable async events will react to reflect
    the state change of the Observable they subscribe to.
  prefs: []
  type: TYPE_NORMAL
- en: These subscribers, which are the Observers we mentioned earlier, will keep listening
    to whatever happens in the Observable until the Observable is disposed, if that
    happens eventually. In the meantime, information will be updated throughout the
    application with no intention whatsoever of triggering routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can probably see all this with more transparency in an actual example. Let''s
    refactor the example we covered when assessing promise-based async operations
    and replace the `setTimeout` command with `setInterval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Copy and paste the preceding snippet in your browser's console window and see
    what happens. The text `Our asynchronous operation has been completed` will show
    up at the dev tools' console only once after 2 seconds and will never be rendered
    again. The promise resolved itself and the entire async event was terminated at
    that very moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, point your browser to an online JavaScript code playground such as JSBIN
    ([https://jsbin.com/](https://jsbin.com/)), and create a new code snippet enabling
    just the JavaScript and the Console tabs. Then, make sure you add the RxJS library
    from the Add library option dropdown (we will need this library to create Observables,
    but don''t panic; we will cover this later in this chapter) and insert the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run it and expect a message to appear on the right pane. 2 seconds later, we
    will see the same message showing up, and then again and again. In this simple
    example, we created an `observable` and then subscribed to its changes, throwing
    to the console whatever it emitted (a simple message, in this example) as a sort
    of push notification.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable returns a stream of events and our subscribers receive prompt
    notification of those streamed events, so they can act accordingly. This is what
    the magic of Observables relies on—Observables do not perform an async operation
    and die (although we can configure them to do so), but start a stream of continuous
    events we can subscribe our subscribers to.
  prefs: []
  type: TYPE_NORMAL
- en: If we comment out the last line, nothing will happen. The console pane will
    remain silent and all the magic will begin only when we subscribe our source object.
  prefs: []
  type: TYPE_NORMAL
- en: That's not all, however. This stream can be the subject of many operations before
    they hit the Observers subscribed to them. Just as we can grab a collection object,
    such as an array, and apply functional methods over it such as `map()` or `filter()`in
    order to transform and play around with the array items, we can do the same with
    the stream of events that are emitted by our Observables. This is what is known
    as reactive functional programming, and Angular makes the most of this paradigm
    to handle asynchronous information.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive functional programming in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Observable pattern stands at the core of what we know as reactive functional
    programming. Basically, the most basic implementation of a reactive functional
    script encompasses several concepts that we need to become familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: An Observable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stream of events featuring the same behavior as an object's collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of composable operators, also known as Reactive Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounds daunting? It's not. Believe us when we tell you that all of the code
    you have gone through so far is much more complex than this. The big challenge
    here is to change your mindset and learn to think in a reactive fashion, and that
    is the main goal of this section.
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, we can just say that reactive programming entails applying
    asynchronous subscriptions and transformations to Observable streams of events.
    We can imagine your poker face right now, so let's put together a more descriptive
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about an interaction device such as a keyboard. A keyboard has keys that
    the user presses. Each one of those key strokes triggers a key press event. That
    key press event features a wide range of metadata, including—but not limited to—the
    numeric code of the specific key the user pressed at a given moment. As the user
    continues hitting keys, more **keyUp** events are triggered and piped through
    an imaginary timeline. The timeline of keyUp events should look like the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/980af034-ac9f-4795-bf54-820c5e6674c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What you can see from the preceding timeline of keyUps is that it is a continuous
    stream of data where the keyUp event can happen at any time; after all, the user
    decides when to press those keys. Remember the Observable code we wrote, containing
    the `setTimeout`? That code was able to tell a concept Observer that every time
    2 seconds passed, another value should be emitted. What''s the difference between
    that code and our keyUps? Nothing. Well, we know how often a timer interval is
    triggered, and with keyUps, we don''t really know because it is not in our hands.
    But that is really the only difference, which means keyUps can be thought of as
    an Observable as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, what I am really telling you is that timeout as well as keyUps can be thought
    as one and the same concept, the Observable. That makes it easier to understand
    all things async. There is, however, another observation we need to make, namely
    that whatever async concept occurs, it occurs in a list-like way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the time might differ, it''s still a series of events, like a list.
    A list usually has a bunch of methods on it to project, filter, or in other ways
    manipulate its element, and guess what, so do Observables. A list can perform
    tricks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So can Observables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The difference is just in the naming at this point. For a list, `.map()` and `.filter()`are
    called methods. For an Observable, the same methods are called Reactive Extensions
    or operators. Imagine at this point that `keyUps`and timeouts can be described
    as Observables and that we have operators to manipulate data. Now, take the bigger
    leap of realizing that anything async, even HTTP calls, can be thought of as Observables.
    This means that we can suddenly mix and match anything async. This enables something
    called **rich composition**. Whatever the async concept is, it and its data can
    be thought of as a stream, and you are a wizard that can bend it to your will.
    Feel empowered—you can now turn your application into a reactive architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The RxJS library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, Angular comes with a peer dependency on RxJS, the
    JavaScript flavor of the ReactiveX library that allows us to create Observables
    and Observable sequences out of a large variety of scenarios, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Interaction events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this sense, reactive programming does not aim to replace asynchronous patterns
    such as promises or callbacks. All the way around, it can leverage them as well
    to create Observable sequences.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS comes with built-in support for a wide range of composable operators to
    transform, filter, and combine the resulting event streams. Its API provides convenient
    methods to subscribe Observers to these streams so that our scripts and components
    can respond accordingly to state changes or interaction input. While its API is
    so massive that covering it in detail is out of the scope of this book, we will
    highlight some bits of its most basic implementation in order for you to better
    understand how HTTP connections are handled by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into the HTTP API provided by Angular, let's create a simple
    example of an Observable event stream that we can transform with Reactive Extensions
    and subscribe observers to. To do so, let's use the scenario described in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We envisioned how a user interacting with our application through the keyboard
    can''t turn it into a timeline of keystrokes and, therefore, an event stream.
    Go back to JSBIN, delete the contents of the JavaScript pane, and then write down
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty self-descriptive. We leverage the `Rx.Observable`
    class and its `fromEvent` method to create an event emitter that streams the `keyup`
    events that take place in the scope of the document object. Each of the event
    objects emitted is a complex object. So, we simplify the streamed objects by mapping
    the event stream onto a new stream that contains only the key codes pertaining
    to each keystroke. The map method is a Reactive Extension that features the same
    behavior as the JavaScript map functional method. This is why we usually refer
    to this code style as reactive functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right, so now we have an event stream of numeric keystrokes, but we are
    only interested in observing those events that inform us of hits on the cursor
    keys. We can build a new stream out of an existing stream by applying more Reactive
    Extensions. So, let''s do it with `keyboardStream` by filtering such a stream
    and returning only those events that are related to cursor keys. We will also
    map those events to their text correspondence for the sake of clarity. Append
    the following chunk of code, following the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We could have done all of this in a single action by chaining the filter and
    map methods to the `keyboardStream` Observable and then subscribing to its output,
    but it's generally a good idea to separate concerns. By shaping our code in this
    way, we have a generic keyboard events stream that we can reuse later on for something
    completely different. So, our application can scale up while keeping the code
    footprint to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have mentioned subscribers, let''s subscribe to our cursor moves
    stream and print the `move` commands to the console. We type the following statement
    at the end of our script, then clear the console pane, and click on the Output
    tab so that we can have surface to input code in so we can try different code
    statements out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Click anywhere on the Output pane to put the focus on it and start typing random
    keyboard keys and cursor keys.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably wondering how we can apply this pattern to an asynchronous
    scenario such as consuming information from an HTTP service. Basically, you have
    so far become used to submitting async requests to AJAX services and then delegating
    the response handling a callback function or just piping it through a promise.
    Now, we will handle the call by returning an Observable. This Observable will
    emit the server response as an event in the context of a stream, which will be
    funneled through the Reactive Extensions to better digest the response.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the HTTP API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we dive into describing what the Angular framework has given us
    in terms of   `HttpClient` service implementation, let''s talk about how we can
    wrap an `XmlHttpRequest` into an Observable. To do that, we first need to realize
    that there is a contract that we need to fulfill to consider it a successful wrapping.
    The contract is made up of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Emit any arrived data using `observer.next(data)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we don't expect any more data we should call `observer.complete()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emit any errors using `observer.error(error)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s it; its pretty simple really. Let''s see what a `XmlHttpRequest` call
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, so we have a typical callback pattern where the `onreadystatechange` property
    points to a method that is being invoked once the data arrives. That''s all we
    need to know to wrap the following code, so let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's it, the wrapping is complete; you have now built your own HTTP service.
    Of course, this isn't much, there are a lot of cases we are not handling, POST,
    PUT, DELETE, caching, and so on. It was, however, important for you to realize
    all the heavy lifting the HTTP service in Angular was doing for you. Another important
    lesson here was how easy it is to take any kind of async API and turn that into
    an Observable that fits in nicely with the rest of our async concepts. So, let's
    continue with Angular's implementation of a HTTP service. We will use the `HttpClient` service
    from this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpClient` class provides a powerful API that abstracts all the operations
    required to handle asynchronous connections through a variety of HTTP methods,
    handling the responses in an easy and comfortable way. Its implementation was
    considered with a lot of care to ensure that programmers feel at ease while developing
    solutions that take advantage of this class to connect to an API or a data resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, instances of the `HttpClient` class (which has been implemented
    as an `Injectable` resource and can therefore be used in our class constructors
    just by injecting it as a dependency provider) expose a connection method named
    `request()`   to perform any type of HTTP connection. The Angular team has created
    some syntax shortcuts for the most common request operations, such as GET, POST,
    PUT, and every existing HTTP verb. So, creating an async HTTP request is as easy
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, all of this can be simplified into a single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `HttpClient` class connection methods operate by returning
    an Observable stream. This allows us to subscribe Observers to the stream, which
    will process the information accordingly once it is returned, as many times as
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we give the `get()`method a templated type that does
    the type conversion for us. Let''s highlight this bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This very fact saves us from having to deal with a response object directly
    and performing a map operation to turn our JSON into a list of Jedi objects. All
    we have to remember is the URL to our resource and specify a type and what you
    subscribe to is instantly usable for the subscribe of our service.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, we can respawn the HTTP request as many times as we need, and
    the rest of our machinery will react accordingly. We can even merge the event
    stream represented by the HTTP call with other related calls, and compose more
    complex Observable streams and data threads. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Working with headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned the   `HttpRequest` classes while introducing the `HttpClient`
    class. On a regular basis, you will not need to make use of low-level classes,
    mostly because of the shortcut methods provided by the `HttpClient` class abstract
    and the need to declare the HTTP verb in use (GET, POST, and so on) and the URL
    you want to consume. With that being said, you will sometimes want to introduce
    special HTTP headers in your requests or append query string parameters automatically
    to each request, for argument's sake. That is why these classes can become quite
    handy in certain scenarios. Think of a use case where you want to add an authentication
    token to each request in order to prevent unauthorized users from reading data
    from one of your API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we read an authentication token and append it as
    a header to our request to a data service. Contrary to our example, we will inject
    the `options` hash object straight into the `HttpRequest` constructor, skipping
    the step of creating an object instance. Angular provides a wrapper class for
    defining custom headers as well, and we will take advantage of it in this scenario.
    Let''s suppose we do have an API that expects all requests to include a custom
    header named `Authorization`, attaching the `authToken` that is received when
    logging into the system, which is then persisted in the browser''s local storage
    layer, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, we would like to note that apart from this scenario, you will seldom
    need to create custom request configurations, unless you want to delegate the
    creation of request configurations in a factory class or method and reuse the
    same `Http` wrapper all the time. Angular gives you all the flexibility to go
    as far as you wish when abstracting your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors when performing HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling errors raised in our requests by inspecting the information returned
    in the `Response` object is actually quite simple. We just need to inspect the
    value of its `Boolean` property, which will return `false` if the HTTP status
    of the response falls somewhere outside of the 2xx range, clearly indicating that
    our request could not be accomplished successfully. We can double-check that by
    inspecting the `status` property to understand the error code or the   `type` 
     property, which can assume the following values: `basic`, `cors`, `default`, `error`,
    or `opaque`. Inspecting the response headers and the `statusText` property of
    the `HttpResponse` object will provide insightful information about the origin
    of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, we are not meant to inspect those properties on every response
    message we get. Angular provides an Observable operator to catch errors, injecting
    in its signature the `HttpResponse` object we require, to inspect the previous
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Worth noting is that we capture our error by using the `catch()` operator and
    return a new operator by calling `Observable.of(error)` and letting our error
    serve as input for the new Observable we create. This is a week for us to not
    crash the stream, but let it live on. Of course, in a more real scenario, we would
    probably not just create a new Observable, but maybe log the error and return
    something completely different potentially or add some retry logic. The point
    is that with the `catch()` operator, we have a way of capturing the error; how
    you handle it depends on your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal scenario, you would want to inspect more data than the error properties,
    aside from logging that information in a more solid exception tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the HttpClient service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HttpClient` service can be injected into our own components and custom
    classes by leveraging Angular''s unique dependency injection system. So, if we
    ever need to implement HTTP calls, we need to import the `HttpClientModule`and
    import the `HttpClient` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the code provided, we just follow up with the `bio` example that we pointed
    out in the previous section. Note how we are importing the `HttpClient` type and
    injecting it as a dependency in the `Biography` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we need to perform multiple HTTP calls in different parts of our application,
    so it's usually recommended to create a `DataService` and a `DataModule` that
    wraps the `HttpClientModule` and the `HttpClient` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of creating such a `DataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding `DataModule` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you want to add your own caching or authorization logic for calling the backend,
    this is the place to do it. Another way is to use `HttpInterceptors`, an example
    of using `HttpInterceptors` will be provided in an upcoming section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, any module that wanted to use this `DataModule` would need to import
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And any construct in our `FeatureModule` can now inject the `DataService`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A real case study – serving Observable data through HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we refactored our entire app into models, services,
    pipes, directives, and component files. One of those services was the `TaskService` class,
    which is the bread and butter of our app since it delivers the data that we need
    to build our task list and other related components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `TaskService`class was contained within the information
    we wanted to deliver. In a real-world scenario, you need to fetch that information
    from a server API or backend service. Let''s update our example to emulate this
    scenario. First, we will remove the task information from the `TaskService` class
    and wrap it into an actual JSON file. Let''s create a new JSON file inside the
    shared folder and populate it with the task information that we had hardcoded
    in the original `TaskService.ts` file, now in JSON format, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the data properly wrapped in its own file, we can consume it as if it
    were an actual backend service from our `TaskService`client class. However, we
    will need to conduct relevant changes in our main.ts file for that. The reason
    is that despite installing the RxJS bundle when installing all the Angular peer
    dependencies, the reactive functional operators, such as`map()`, do not become
    available straight away. We could import all of them at once by inserting the
    following line of code in some step at the beginning of our application initialisation
    flow, such as the bootstrapping stage in `main.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that would import all the reactive functional operators, which will
    not be used at all and will consume an unnecessarily huge amount of bandwidth
    and resources. Instead, the convention is to import only what is needed, so append
    the following import line at the top of the `main.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When a reactive operator is imported this way, it gets automatically added to
    the Observable prototype, being then available for use throughout the entire application.
    It should be said that the concept of lettable operators was just introduced per
    RxJS 5.5\. At the time of this book's writing we are just in the shift of patching
    the Operator prototype, as described above and moving into the lettable operator
    space. For the interested reader, please have a look at this article that describes
    in detail what this will mean for your code. The changes are not that big, but
    there is still change: [https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3 ](https://blog.angularindepth.com/rxjs-understanding-lettable-operators-fe74dda186d3)
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging HTTP – refactoring our TaskService to use HTTP service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the dependencies properly in place, the time has come to refactor
  prefs: []
  type: TYPE_NORMAL
- en: 'our `TaskService.ts` file. Open the service file and let''s update the import
    statements block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import in the `HttpClient` and `Response` symbols so that we can
    annotate our objects later on. The Observable symbol is imported from the RxJS
    library so that we can properly annotate the return types of our async HTTP requests.
    We also import `Task` as a model (it is an interface) from the file `task.model.ts`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will refactor this service using two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the service to use the HTTP service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a store/feed pattern and give the service a state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Angular HTTP service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will replace the existing implementation using static data inside of
    the service to one using the HTTP service. To do this, we call the `http.get()` method
    on the HTTP service to fetch data, but we also need to use the map operator to
    get a result we can display outwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the previously defined service, we just need to tell the module about
    it. We do so by adding it to the `providers` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Thereafter, we need to inject the `TaskService` in a consumer component and
    display it in a suitable way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A stateful TaskService for most scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered how to inject an HTTP service into a service constructor
    and have been able to subscribe to such a service from a component. In some cases,
    a component might want to deal with the data directly and not with Observables.
    In fact, most of our cases are like that. So, we don''t have to use Observables
    much; HTTP services are utilizing Observables, right? We are talking about the
    component layer. Currently, we have this happening inside of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that we assign `taskService.getTasks()` to a stream called `tasks$`.
    What is the `$` at the end of the`tasks$`variable? This is a naming convention
    that we use for streams; let's try to follow that for any future streams/Observable
    fields that we declare. We use the words Observable and stream interchangeably,
    as they come to mean the same thing in the context of Angular. We also let the `|
    async` async pipe handle it with `*ngFor` and display our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in an even simpler way, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the following changes took place:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnInit()` and the assigning to the `tasks$` stream was removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The async pipe was removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We replaced the `tasks$` stream with a `tasks` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can this still work? The answer lies in how we define our service. Our service
    needs to expose an array of items and we need to ensure the array is changed when
    we get some data back from HTTP, or when we receive data from elsewhere, such
    as from a web socket or a product like Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: We just mentioned two interesting methods, sockets and Firebase. Let's explain
    what those are and how they relate to our service. A web socket is a technique
    that establishes a two-way communication, a so-called *full duplex connection*,
    with the help of the TCP protocol. So, why is it interesting to mention it in
    the context of HTTP? Most of the time, you have simple scenarios where you fetch
    data over HTTP, and you can leverage Angular's HTTP service. Sometimes, the data
    might come from a full duplex connection in addition to it coming from HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: What about Firebase? Firebase is a product by Google that allows us to create
    a database in the cloud. As can be expected, we can perform CRUD operations on
    the database, but the strength lies in the fact that we can set up subscriptions
    to it and thereby listen to changes when they occur. This means we can easily
    create collaboration apps, where a number of clients are operating on the same
    data source. This is a very interesting topic. This means you can quickly supply
    your Angular app with a backend, so for that reason, it deserves its own chapter.
    It also happens to be the next chapter of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the point we were trying to make. On paper, it sounds like the addition
    of sockets or Firebase would complicate our service a whole lot. In practice,
    they don't. The only thing you need to keep in mind is that when such data arrives,
    it needs to be added to our `tasks`array. We make the assumption here that it
    is interesting to deal with tasks from a HTTP service as well as from full duplex
    connections like Firebase or web sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at what it would look like to involve an HTTP service and
    sockets in our code. You can easily leverage sockets by using a library that wraps
    its API.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets are supported natively by most browsers, but it is considered experimental
    still. With that said, it still makes sense to rely on a library that helps us
    work with sockets, but it's worth keeping track of when WebSockets are becoming
    less experimental as we would no longer consider using a library. For the interested
    reader, please check the official documentation at [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
  prefs: []
  type: TYPE_NORMAL
- en: 'One such library is the `socket.io` library; it can be installed in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To start using this in Angular, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `socket.io-client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish a connection by calling `io(url)`; this will return a socket that
    you can add subscriptions to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for incoming events that will contain a payload that we want to display
    in our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate events and send the possible payload when you want to talk to a backend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code will only show you how to do these steps. There is more
    to socket implementation, though, such as creating a backend. To see what a full
    example with Angular and `socket.io` looks like, the interested reader is encouraged
    to have a look at the following article by Torgeir Helgwold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0](http://www.syntaxsuccess.com/viewarticle/socket.io-with-rxjs-in-angular-2.0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t really an HTTP topic, which is why we settle for only showing the
    points of interest in the code, which is where we would receive the data and add
    it to our tasks array. We also highlight the setting up and tearing down of the
    socket. Highlighting is done in bold, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple example that works well for showing data in a template,
    as well updating the template when the `tasks`array changes. As you can see, if
    we involve a `socket`, it won't matter; our template will still be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of doing it also comprises another scenario—how do two sibling components
    or more communicate? The answer is quite simple: they use the `TaskService`. If
    you want the other components template to be updated, then simply change the contents
    of the tasks array and it will be reflected in the UI. The code for this follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we also need to add a `addTask()` method to our service, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The other component would look pretty much identical in terms of the parts
    that relate to setting up the `taskService`, exposing a `tasks` property and manipulating
    the `tasks`list. Regardless of which one of the components takes the initiative
    to change the task list through user interaction, the other component would be
    notified. I want to highlight what makes this general approach work, though. For
    this approach to work, you need to expose the tasks array through a getter in
    the component, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the changes to it won't be picked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one drawback, though. What if we wanted to know exactly when an item
    was added and, say, display some CSS based on that? In that case, you have two
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the socket connection in the component and listen for the data changes
    there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a behavior subject inside of the task service instead of a task array. Any
    changes from HTTP or socket will write to the subject through `subject.next()`.
    If you do this, then you can simply subscribe to the subject when a change happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last alternative is a bit complicated to explain in a few words, so the
    whole next section is dedicated to explaining how you can use a `BehaviourSubject` over
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements – turning TaskService into a stateful, more robust service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RxJS and Observables didn''t arrive just to be a one-to-one match to Promises.
    RxJS and reactive programming arrived to promote a different kind of architecture,
    as well. From such an architecture emerged a store pattern suitable for services.
    The store pattern is about ensuring our service is stateful and can deal with
    data coming from more places than HTTP. The potential places where data can arrive
    from could be, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling service calls when network connection intermittently goes offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, you owe it to the application users to ensure that your application
    still works if the network connection goes down, at least when it comes to reading
    data. For that situation, it would be nice if we could answer with `localStorage`
    if the HTTP response fails to deliver. This, however, means we need logic in our
    service that works in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take our service and modify it slightly to account for being offline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `.do()` operator to carry out a side effect; in this case, we write
    the response to `localStorage`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the `catch()` operator and respond with a new Observable that contains
    previously stored data or an empty array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is nothing wrong with solving it this way, and in a lot of cases, it might
    even be good enough. What happens when data arrives from many different directions,
    though, as suggested earlier? If that is the case, then we must have the ability
    to push data into the stream. Normally, it's only Observers that can push data
    with `observer.next()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another construct, though, the `Subject`. The `Subject`has a dual
    nature. It has the ability to both push data to the stream and it can also be
    subscribed to. Let''s rewrite our service to account for the external arrival
    of data and then add `Sock.io` library support so you will see how this is scaled.
    We start by making the service stateful. It would be tempting to just code it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding changes we propose are bolded and entail creating a `tasks`array
    field and doing an assignment to the tasks field with the arriving data. This
    works, but it might be more than we need.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the store/feed pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do better than this, though. We can do better in the sense that we really
    don''t need to create that last array. You might think at this point, let me get
    this straight; you want my service to be stateful without a backing field? Well,
    kind of, and it is possible using something called a `BehaviourSubject`. A `BehaviourSubject` has
    the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is able to act as an `Observer` and `Observable`, so it can push data and
    be subscribed to at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can have an initial value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will remember the last value that it emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, with the `BehaviourSubject`, we essentially kill two birds with one stone.
    It can remember things that were last emitted and it can push out data, making
    it ideal to use when connecting to other data sources such as web sockets. Let''s
    add it first to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are instantiating the `BehaviourSubject`and as we can see its default
    constructor takes a parameter, an initial value. We give it an empty array. This
    initial value is the first thing to be presented to a subscriber. It makes sense
    from an application standpoint to showcase a first value while waiting for that
    first HTTP call to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also define a `store()` property that ensures that when we expose the `BehaviourSubject` to
    the world, we do so as an `Observable`. This is defensive coding. As the subject
    has a `next()` method on it that allows us to push values into it; we want to
    take that ability away from anyone that is not in our service. We do this because
    we want to make sure that anything added to it is handled through the public API
    of the `TaskService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change was the addition made to the `.do()` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that any subscribers to our service will always get the last
    emitted data. Try it yourself with a code like this in a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have made sure it doesn't matter when you start subscribing
    to `taskService.store`. Whether it's immediately or after 3 seconds, as the preceding
    code shows, we will still get the last emitted data.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we need to persist what is coming from a form in a component? Well
    then, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose an `add()` method on our service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do an `http.post()` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poke the `getTasks()` to ensure it refetches the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the simpler case of adding a task from a component. We assume
    the user has entered all the necessary data needed to create a `Task`in the application
    UI. An `addTask()` method has been invoked from the component, which in turn invokes
    a similar `addTask()`method on the service. We need to add the last method to
    our service and also in that method call an endpoint with a POST request so our
    task gets persisted, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we assume the calling component is responsible for doing all
    sorts of CRUD operations on a component, including showing a list of tasks. By
    adding a task and persisting it, the mentioned list would now lack a member, which
    is why it makes sense to do a fresh call to `getTasks()`. So, if we had a simple
    service with just a `getTasks()` method, then that would just return a list of
    tasks, including our newly persisted task, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: OK, so this works if we have a simplified `TaskService`that lacks our pretty
    store/feed pattern. There is a problem, though—we are using RxJS wrong. What do
    we mean by wrong? Every time we use `addTask()`, we set up a new subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you want is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One subscription to a stream of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cleanup phase where the subscription is being unsubscribed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by tackling the first problem; one stream. We assume that we will
    need to use the stateful version of our `TaskService`instead. We change the component
    code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are now subscribing to the store property instead, but we
    have removed the refetch behavior inside of the `taskService.addTask()` method
    to read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will instead place this refresh logic in the `taskService`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything works as intended. We have one subscription to our task stream
    in the component and the refresh logic is being pushed back to the service by
    us poking the `fetchTasks()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more order of business. How do we deal with subscriptions, and
    more to the point, how do we deal with unsubscribing? Remember how we added a `subscription`member
    to our component? That took us halfway there. Let''s implement an `OnDestroy` interface
    to our component and implement the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: By implementing the `OnDestroy` interface, we have a way to call `unsubscribe()` on
    the subscription and we do that in the `ngOnDestroy()` method that the `OnDestroy`interface
    makes us implement. Thus, we clean up after ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern of implementing the `OnInit` interface and the `OnDestroy`interface
    is something that you should be doing when creating a component. It is a good
    practice to set up subscriptions and anything else the component needs in the `ngOnInit()` method
    and conversely tear down subscriptions and other type of constructs in the `ngOnDestroy()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an even better way, though, and that is using the `async |`async pipe.
    The async pipe will remove the need to save a reference to a subscription and
    call `.unsubscribe()`on it, as this is handled internally in the async pipe. We
    will talk more about the async pipe in the upcoming sections in this chapter,
    but here is what the component would look like leveraging it instead of the `OnDestroy` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Our code just removed a lot of boilerplate, and the best part is that it is
    still working. As long as all your data is being displayed in a component, then
    the async pipe is the way to go; however, if you fetch up data that is shared
    between other services or used as a precondition to fetching other data, then
    it might not be so clear-cut as to be using the async pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing at the end of the day is that you resort to using one of
    these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing our service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost done describing our `TaskService`, but there is one more aspect
    we need to cover. Our service doesn''t take into account that a third party might
    make changes to the endpoint database. We will see those changes if we move away
    from the component or reload the entire application. If we want to see those changes
    when they happen, we need to have some kind of behavior that tells us when data
    has changed. It is tempting to think of a polling solution and just refresh the
    data at certain intervals. This might be a painful approach, though, as the data
    we fetch might consist of a large object graph. Ideally, we only want to fetch
    what really changed and amend that to our application. Why do we care so much
    about this in the age of broadband connections? Here is the problem—an application
    should be able to be used on a mobile app and both speed as well as mobile data
    contracts might be an issue, so we need to consider the mobile user. Here are
    some things we should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The polling interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the expected size of the data is really big, then it might be a good idea
    to poke an endpoint and ask it for everything that changed after a certain time;
    this would change the size of the payload drastically. We could also just ask
    for a partial object graph back. The polling interval is another thing to consider.
    We need to ask ourselves: how often do we really need to refetch all the data?
    The answer could be never.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we opt for an approach where we ask for the delta (the change after
    a certain time); it could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of what approach and considerations you take here, remember that
    not all users are on a broadband connection. It's also worth nothing that more
    and more of theses refresh scenarios tend to be solved with Web Sockets nowadays
    so you create an open connection between server and client, and the server can
    decide when it's time to send the client some new data. We will leave it to you,
    dear reader, to refactor this example using Sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a service which is:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to handle offline connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to cater for other data services such as sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to refresh its data at a certain interval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this was made possible through the `BehaviourSubject` and `localStorage`.
    Don't just treat RxJS as an add-on to a `Promise`, but use its constructs and
    operators to craft robust services and architecture patterns.
  prefs: []
  type: TYPE_NORMAL
- en: HttpInterceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interceptor is a piece of code that can be executed between your HTTP calls
    and the rest of the application. It can be hooked up when you are about to send
    a request as well as when receiving a response. So, what do we use it for? There
    many areas of application, but some might be:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom token for all outgoing requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping all incoming error responses in a business exception; this can also
    be done on the backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting a request somewhere else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An `HttpInterceptor`is an interface imported from `@angular/common/http`. To
    create an interceptor, you need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and implement the `HttpInterceptor` interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the interceptor in the root module provider
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the business logic for what is to happen to the request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a mock interceptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take all, the earlier mentioned steps and create a real interceptor service. Imagine
    that all calls to a certain endpoint are directed to a JSON file or a dictionary.
    Doing so will create a mock behavior where you are able to ensure that all outgoing
    calls are intercepted, and in their place, you answer with suitable mock data.
    This will allow you to develop the API at your own pace while relying on mocked
    data. Let's dig a little deeper into this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by creating our service. Let''s call it `MockInterceptor`.
    It will need to implement the `HttpInterceptor` interface like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To fulfil the contract of the interface, we need to have the method `intercept()` that
    takes a request and a `next()`handler as parameters. Thereafter, we need to ensure
    we return an Observable of `HttpEvent` type from the `intercept()`method. We have
    yet to write any logic in there, so this won''t actually compile. Let''s add some
    basic code in the `intercept()` method just to make it work, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We added a call to `next.handle(request)`, which means we take the incoming
    request and just pass it further in the pipeline. This code doesn't do anything
    useful, but it does compile and does teach us that whatever we do inside the `intercept()` method,
    we need to call `next.handle()` with a request object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to what we were trying to achieve in the first place—mocking
    an outgoing request. This means we want to replace the outgoing request with `our`
    request. To accomplish our mocking behavior, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Investigate our outgoing request and determine whether we want to answer with
    a mock or let it through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct a mock response if we want to mock it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register our new interceptor with the `providers` for a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add some code to our `intercept()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What we are essentially saying here is that we are trying to perform a GET request
    to something. `/starwars`will intercept it and instead respond with a JSON file.
    So, `/starwars/ships` would instead lead to us respond with `ships.json` and `/starwars/planets`
    would lead to `planets.json`. You get the idea; all other requests would be let
    through.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more thing to do—tell our module this interceptor exists. We open
    up our module file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Some best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some best practices to follow when dealing with data services in
    Angular, especially when Observables are involved, and those are:'
  prefs: []
  type: TYPE_NORMAL
- en: Handle your errors. This one goes without saying and hopefully this is not something
    new on your radar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that any manually created Observables have a cleanup method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe to your streams/Observables, or else you might have resource leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the async pipe to manage the subscribe/unsubscribe process for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have so far not discussed how to create a cleanup method when manually creating
    Observables, which is why we will cover that in a subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The async pipe has been mentioned a couple of times in the Firebase section,
    but it's worth mentioning again and building on that knowledge by explaining its
    role in the subscribe/unsubscribe process to streams.
  prefs: []
  type: TYPE_NORMAL
- en: Async operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The async pipe is an Angular pipe, and as such it is used in a template. It
    is used in conjunction with streams/Observables. It plays two roles: it helps
    us to type less, and secondly, it saves us the whole ceremony of having to set
    up and tear down a subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it did not exist, it would be tempting to type the following when trying
    to display data from a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have to subscribe and unsubscribe to the data. We also need
    to introduce a data property to assign it to. The async pipe saves us a few keystrokes,
    so we instead can type our component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a lot less code. We removed:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDestroy` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subscription` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any call to subscribe/unsubscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did need to add `{{ data | async }}`, which is a quite a small addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if what we get back is a more complicated object and we would like
    to display its properties, we have to type something like this in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this as the data is not yet set, and accessing a property at that point
    would lead to a runtime error, hence our `?` operator. Now, this looks a bit verbose,
    and we can fix that with the `-` operator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now it's looking a lot better. Using the async pipe will reduce a lot of boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Being a good citizen – cleaning up after yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so I''ve told you the importance of calling `.unsubscribe()`, and you
    have taken my word for it at this point that if it is not called, resources won''t
    be cleaned up. It is important to know about this mostly when you deal with streams
    that have a never-ending stream of data, such as scroll events, or in cases where
    you need to create your own Observables. I will now demonstrate a little bit of
    the internals of an Observable to make things clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of creating our own Observable. You think you are safe now
    just because you called `.unsubscribe()`like you were told? Wrong. The interval
    will keep on ticking because you didn''t tell it stop. In panic, you close the
    browser tab and wish the Observable away—you are safe for now. The correct approach
    to this is to add a cleanup function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Upon calling `subscription.unsubscribe()`, it will call the `cleanUp()`function
    internally. Most of, if not all, factory methods out there used to create Observables
    will have their own `cleanUp()`function defined. It is important for you to know
    that should you venture down that rabbit hole of creating your own Observable,
    refer to this section, be a good citizen, and implement a `cleanUp()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we pointed out at the beginning of this chapter, it takes much more than
    a single chapter to cover in detail all the great things that can be done with
    the Angular HTTP connection functionalities, but the good news is that we have
    covered pretty much all the tools and classes we need.
  prefs: []
  type: TYPE_NORMAL
- en: The rest is just left to your imagination, so feel free to go the extra mile
    and put all of this knowledge into practice by creating brand new Twitter reader
    clients, newsfeed widgets, or blog engines, and assembling all kinds of components
    of your choice. The possibilities are endless, and you have assorted strategies
    to choose from, ranging from Promises to Observables. You can leverage the incredible
    functionalities of the Reactive Functional extensions and the tiny but powerful
    `Http` class.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already highlighted, the sky is the limit. But, we still have a long
    and exciting road ahead. Now that we know how to consume asynchronous data in
    our components, let's discover how we can provide a broader user experience in
    our applications by routing users into different components. We will cover this
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
