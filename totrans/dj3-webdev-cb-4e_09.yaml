- en: Importing and Exporting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing paginated sitemaps for search engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Django REST framework to create an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once in a while, your data needs to be transported from a local format to the
    database, imported from external resources, or provided to third parties. In this
    chapter, we will take a look at some practical examples of how to write management
    commands and APIs to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For working with the code of this chapter, you will need the latest stable version
    of Python, MySQL, or PostgreSQL database and a Django project with a virtual environment.
    Also, make sure to install Django, Pillow, and database bindings into your virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all of the code for this chapter in the `ch09` directory of the
    GitHub repository: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Importing data from a local CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Comma-Separated Values** (**CSV**) format is probably the simplest way
    to store tabular data in a text file. In this recipe, we will create a management
    command that imports data from a CSV file to a Django database. We will need a
    CSV list of songs. You can easily create such a file with Excel, Calc, or another
    spreadsheet application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `music` app that we''ll be using throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `music` app itself and put it under `INSTALLED_APPS` in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Song` model there should contain the `uuid`, `artist`, `title`, `url`,
    and `image` fields. We''ll also extend `CreationModificationDateBase` to add creation
    and modification timestamps, as well as `UrlBase` to add methods to work with
    the model''s detail URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make and run migrations with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s add a simple administration for the `Song` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need a form for validating and creating `Song` models in the import
    scripts. It''s the most straightforward model form, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports songs
    from a local CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a CSV file with the column names, `artist`, `title`, and `url`, in the
    first row. Add some song data to it in the next rows matching the columns. For
    example, it could be a `data/music.csv` file with content like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the `music` app, create a `management` directory and then a `commands` directory
    in the new `management` directory. Put empty `__init__.py` files in both new directories
    to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_music_from_csv.py` file there with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should create the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll finish the class with the `finalize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django management commands are scripts with `Command` classes deriving from
    `BaseCommand` and overwriting the `add_arguments()` and `handle()` methods. The `help`
    attribute defines the help text for the management command. It can be seen when
    you type the following in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Django management commands use the built-in `argparse` module to parse the passed
    arguments. The `add_arguments()` method defines what positional or named arguments
    should be passed to the management command. In our case, we will add a positional
    `file_path` argument of the Unicode type. By having the `nargs` variable set to
    the `1` attribute, we allow only one value.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the other arguments that you can define and how to do this, refer
    to the official `argparse` documentation at [https://docs.python.org/3/library/argparse.html#adding-arguments](https://docs.python.org/3/library/argparse.html#adding-arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `handle()` method, the `verbosity` argument is checked.
    Verbosity defines how much Terminal output the command should provide from 0,
    not giving any logging, to 3, providing extensive logging. You can pass this named
    argument to the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We also expect the filename as the first positional argument. `options["file_path"]`
    returns a list of the values with the length defined in `nargs`. In our case, `nargs`
    equals one; therefore, `options["file_path"]` will be equal to a list of one element.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a good practice to split the logics of your management command into multiple
    smaller methods, for example, like we use in this script with `prepare()`, `main()`,
    and `finalize()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare()` method sets import counters to zero. It could also be used for
    any other setup that is necessary for the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main()` method, we execute the main logic of the management command.
    At first, we open the given file for reading and pass its pointer to `csv.DictReader`.
    The first line in the file is assumed to contain headings for each of the columns.
    `DictReader` uses them as keys for the dictionaries for each row. When we iterate
    through the rows, we pass the dictionaries to the model form and try to validate
    it. If validation passes, a song is saved and `imported_counter` is incremented.
    If validation fails, because of too long values, missing required values, wrong
    types, or other validation errors, `skipped_counter` is incremented. If verbosity
    is equal or greater than `NORMAL` (which is number 1), each imported or skipped
    song is also printed out together with possible validation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finalize()` method prints out how many songs were imported and how many
    were skipped because of validation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to debug the errors of a management command while developing it,
    pass the `--traceback` parameter to it. When an error occurs, you will see the
    full stack trace of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we invoked the command twice with `--verbosity=1` or higher, the output
    we could expect might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/669d9ec1-88f7-4d11-922c-f42b822c335f.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when a song is being imported a second time, it doesn't pass
    the `unique_together` constraint and therefore is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Importing data from a local Excel file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external JSON file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external XML file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from a local Excel file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular format for storing tabular data is an Excel spreadsheet. In
    this recipe, we will import songs from a file of this format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the `music` app that we created in the previous recipe. To
    read Excel files, you will need to install the `openpyxl` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create and use a management command that imports songs
    from a local XLSX file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an XLSX file with the column names Artist, Title, and URL in the first
    row. Add some song data to it in the next rows matching the columns. You can do
    this in a spreadsheet application, by saving the CSV file from the previous recipe
    as an XLSX file, `data/music.xlsx`. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/593e1328-3062-435a-8fa8-c186382cc759.png)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't done so, in the `music` app, create a `management` directory
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_music_from_xlsx.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `main()` method there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll finish the class with the `finalize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principle of importing from an XLSX file is the same as with CSV. We open
    the file, read it row by row, form data dictionaries, validate them via a model
    form, and create the `Song` objects from the provided data.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we are using the `prepare()`, `main()`, and `finalize()` methods to split
    the logic into more atomic parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a detailed explanation of the `main()` method as it is probably the
    only different part of the management command:'
  prefs: []
  type: TYPE_NORMAL
- en: Excel files are workbooks containing sheets as different tabs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the `openpyxl` library to open a file passed as a positional argument
    to the command. Then, we read the first sheet from the workbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first row contains the column captions. We skip it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterward, we will read the rows one by one as lists of values, use the `zip()`
    function to create dictionaries, pass them to a model form, validate, and create
    the `Song` objects from them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are any validation errors and verbosity is greater than or equal to `NORMAL`,
    then we output the validation errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, the management command will print out the imported songs to the
    console, unless you set `--verbosity=0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run the command twice with `--verbosity=1` or higher, the output would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48543c7a-7dce-4d37-90fd-a1626e570c48.png)'
  prefs: []
  type: TYPE_IMG
- en: You can learn more about how to work with Excel files at [http://www.python-excel.org/](http://www.python-excel.org/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external JSON file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external XML file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external JSON file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [Last.fm](http://last.fm) music website has an API under the [https://ws.audioscrobbler.com/](https://ws.audioscrobbler.com/)
    domain that you can use to read the albums, artists, tracks, events, and more.
    The API allows you to either use the JSON or XML format. In this recipe, we will
    import the top tracks tagged `indie` using the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to import data in the JSON format from `Last.fm`:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `music` app that we created in the *Importing data from
    a local CSV file* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use [Last.fm](http://last.fm), you need to register and get an API key. The
    API key can be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: created at [https://www.last.fm/api/account/create](https://www.last.fm/api/account/create).
  prefs: []
  type: TYPE_NORMAL
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`. We recommend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'providing it from the secrets file or an environment variable and drawing that
    into your settings, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install the `requests` library in your virtual environment using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the structure of the JSON endpoint for the top indie tracks (`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=json`),
    which should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We want to read the track `name`, `artist`, `URL`, and medium-sized images.
    In addition, we are interested in how many pages there exist in total, which is
    provided as meta information at the end of the JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a `Song` model and a management command, which
    imports the top tracks from [Last.fm](http://last.fm) to the database in JSON
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so, in the `music` app, create a `management` directory,
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_music_from_lastfm_json.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `main()` method there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each page from the paginated feed will be saved by the `save_page()` method
    that we should create, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll finish the class with the `finalize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, the arguments for scripts can be **positional** if they
    just list a sequence of strings, or **named** if they start with a `--` and a
    variable name. The named `--max_pages` argument limits the imported data to three
    pages. Just skip it, or explicitly pass 0 (zero) if you want to download all of
    the available top tracks.
  prefs: []
  type: TYPE_NORMAL
- en: Beware that there are around 4,500 pages as detailed in the `totalPages` value,
    and this will take a long time and a lot of processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of our script is similar to the previous import scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `prepare()` method is for the setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main()` method handles the requests and processes the responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save_page()` method saves songs from a single pagination page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finalize()` method prints out the import statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main()` method, we use `requests.get()` to read the data from [Last.fm](http://last.fm),
    passing the `params` query parameters. The response object has a built-in method
    called `json()`, which converts a JSON string into a parsed dictionary object.
    From the first request, we learn about the total number of pages and then read
    each of them and call the `save_page()` method to parse information and save the
    songs.
  prefs: []
  type: TYPE_NORMAL
- en: In the `save_page()` method, we read the values from the tracks and build a
    dictionary necessary for the model form. We validate the form. If the data is
    valid, the `Song` object is created.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting part of the import is downloading and saving the image. Here,
    we also use `requests.get()` to retrieve the image data and then we pass it to
    `File` through `BytesIO`, which is accordingly used in the `image.save()` method.
    The first parameter of `image.save()` is a filename that will be overwritten anyway
    by the value from the `upload_to` function and is necessary only for the file
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: If the command is invoked with a `--verbosity=1` or higher, we will see detailed
    information about the import just like in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about how to work with [Last.fm](http://last.fm) at [https://www.last.fm/api/](https://www.last.fm/api/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from a local Excel file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external XML file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing data from an external XML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we showed what could be done with JSON in the preceding recipe, the
    [Last.fm](http://last.fm) file also allows you to take data from its services
    in XML format. In this recipe, we will show you how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to import data in the XML format from [Last.fm](http://last.fm):'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `music` app that we created in the *Importing data from
    a local CSV file* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use [Last.fm](http://last.fm), you need to register and get an API key. The
    API key can be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: created at [https://www.last.fm/api/account/create](https://www.last.fm/api/account/create).
  prefs: []
  type: TYPE_NORMAL
- en: The API key has to be set in the settings as `LAST_FM_API_KEY`. We recommend
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'providing it from the secrets file or an environment variable and drawing that
    into your settings, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, install the `requests` and `defusedxml` libraries in your virtual environment
    using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the structure of the JSON endpoint for the top indie tracks (`https://ws.audioscrobbler.com/2.0/?method=tag.gettoptracks&tag=indie&api_key=YOUR_API_KEY&format=xml`),
    which should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to create a `Song` model and a management command, which
    imports the top tracks from [Last.fm](http://last.fm) to the database in XML format:'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so, in the `music` app, create a `management` directory
    and then a `commands` subdirectory beneath it. Add empty `__init__.py` files in
    both of the new directories to make them Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `import_music_from_lastfm_xml.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the same file for the `Command` class, create a `prepare()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `main()` method there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Each page from the paginated feed will be saved by the `save_page()` method
    that we should create, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll finish the class with the `finalize()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the import, call the following in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process is analogous to the JSON approach. Using the `requests.get()` method,
    we read the data from [Last.fm](http://last.fm), passing the query parameters
    as `params`. The XML content of the response is passed to the `ElementTree` parser
    from the `defusedxml` module, and the `root` node is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `defusedxml` module is a safer replacement for the `xml` module. It prevents
    XML bombs—a vulnerability allowing the attacker to use a few hundred bytes of
    XML data to occupy Gigabytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementTree` nodes have the `find()` and `findall()` methods, where you
    can pass `XPath` queries to filter out specific subnodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table of the available XPath syntax supported by `ElementTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **XPath syntax component** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `tag` | This selects all of the child elements with the given tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | This selects all of the child elements. |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | This selects the current node. |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | This selects all of the subelements on all of the levels beneath the
    current element. |'
  prefs: []
  type: TYPE_TB
- en: '| `..` | This selects the parent element. |'
  prefs: []
  type: TYPE_TB
- en: '| `[@attrib]` | This selects all of the elements that have the given attribute.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[@attrib=''value'']` | This selects all of the elements for which the given
    attribute has the given value. |'
  prefs: []
  type: TYPE_TB
- en: '| `[tag]` | This selects all of the elements that have a child named tag. Only
    immediate children are supported. |'
  prefs: []
  type: TYPE_TB
- en: '| `[position]` | This selects all of the elements that are located at the given
    position. The position can either be an integer (`1` is the first position), the
    `last()` expression (for the last position), or a position relative to the last
    position (for example, `last()-1`). |'
  prefs: []
  type: TYPE_TB
- en: Therefore, in the `main()` method, using `root.find("tracks").attrib.get("totalPages",
    1)`, we read the total amount of pages, defaulting to one if the data is missing
    somehow. We will save the first page and then go through the other pages one by
    one and save them too.
  prefs: []
  type: TYPE_NORMAL
- en: In the `save_page()` method, `root.findall("tracks/track")` returns an iterator
    through the `<track>` nodes under the `<tracks>` node. With `track_node.find("image[@size='medium']")`,
    we get the medium-sized image. Again, `Song` creation happens through the model
    form which is used to validate the incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: If we call the command with `--verbosity=1` or higher, we will see detailed
    information about the imported songs just like in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can learn more from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Read about how to work with [Last.fm](http://last.fm) at [https://www.last.fm/api/](https://www.last.fm/api/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read about XPath at [https://en.wikipedia.org/wiki/XPath](https://en.wikipedia.org/wiki/XPath).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full documentation of `ElementTree` can be found at [https://docs.python.org/3/library/xml.etree.elementtree.html](https://docs.python.org/3/library/xml.etree.elementtree.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from a local Excel file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Importing data from an external JSON file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing paginated sitemaps for search engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sitemaps** protocol tells search engines about all different pages on your
    website. Usually, it''s a single `sitemap.xml` file that informs what can be indexed
    and how often. If you have lots of different pages on your website, you can also
    split and paginate the XML file to render each list of resources faster.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to create a paginated sitemap to use in
    your Django website.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this and further recipes, we need to extend the `music` app and add list
    and detail views there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `views.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `urls.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Include that URL configuration into the project''s URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template for the song list view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create one for the song detail view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the paginated sitemap, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `django.contrib.sitemaps` in `INSTALLED_APPS` in the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `urls.py` of your project as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at `http://127.0.0.1:8000/sitemap.xml`, you will see the index
    with paginated sitemaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here each page will display up to 50 entries with a URL, its last modification,
    and priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When your site is ready and published to production, you can inform **Google
    Search Engine** about your pages with the `ping_google` management command provided
    by the sitemap framework. Execute this command at the production server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can learn more from the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Read about the sitemaps protocol at [https://www.sitemaps.org/](https://www.sitemaps.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about Django sitemap framework at
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/3.0/ref/contrib/sitemaps/)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating filterable RSS feeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a **syndication feed framework** that allows you to create
    **Really Simple Syndication** (**RSS**) and **Atom** feeds. RSS and Atom feeds
    are XML documents with specific semantics. They can be subscribed to an RSS reader,
    such as Feedly, or they can be aggregated in other websites, mobile applications,
    or desktop applications. In this recipe, we will create an RSS feed that provides
    information about songs. Moreover, the results will be filterable by URL query
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by creating the `music` app from the *Importing data from a local CSV
    file* and *Preparing paginated sitemaps for search engines* recipes. Specifically,
    follow the steps in the *Getting ready* section to set up the models, forms, 
    views, URL configurations, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To the view listing songs, we will add filtering by artist that later will
    be used by the RSS feed too:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a filter form to `forms.py`. It will have the `artist` choice field with
    all artist names sorted alphabetically with letter case ignored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Enhance the `SongList` view with the methods to manage the filtering: the `get()`
    method will handle the filtering and display results, the `get_form_kwargs()`
    method will prepare the keyword arguments for the filter form, and the `get_queryset()`
    method will filter songs by artist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the song list template to add the form for filtering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now check the song list view in the browser and filter songs by, let''s
    say, Lana Del Rey, you would see results like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfefc603-0bcb-4f52-9c22-eceda7cd8df6.png)'
  prefs: []
  type: TYPE_IMG
- en: The URL of the filtered song list will be `http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will add the RSS feed to the music app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `music` app, create the `feeds.py` file and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a template for the song descriptions in the RSS feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Plug in the RSS feed in the URL configuration of the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template of the song list view, add a link to the RSS feed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you refresh the filtered list view at `http://127.0.0.1:8000/en/songs/?artist=Lana+Del+Rey`,
    you will see the Subscribe to RSS feed link that leads to `http://127.0.0.1:8000/en/songs/rss/?artist=Lana+Del+Rey`.
    This will be the RSS feed of up to 30 songs filtered by the artist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SongFeed` class takes care of automatically generating the XML markup
    for the RSS feed. We specified the following methods there:'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_object()` method defines the context dictionary for the `Feed` class
    that will be used by other methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title()` method defines the title of the feed depending on whether the
    results are filtered or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `link()` method returns the URL of the list view, whereas `feed_url()` returns
    the URL of the feed. Both of them are using a helper method, `get_named_url()`,
    which forms a URL by pathname and query parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `items()` method returns the `queryset` of songs, optionally filtered by
    artist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `item_pubdate()` method returns the creation date of the song.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see all of the available methods and properties of the `Feed` class that
    we are extending, refer to the following documentation at [https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference](https://docs.djangoproject.com/en/3.0/ref/contrib/syndication/#feed-class-reference).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Importing data from a local CSV file* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Preparing paginated sitemaps for search engines* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Django REST framework to create an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to create a RESTful API for your models to transfer data to and
    from third parties, the **Django REST framework** is probably the best tool you
    can use. This framework has extensive documentation and a Django-centric implementation,
    helping to make it more maintainable. In this recipe, you will learn how to use
    the Django REST framework to allow your project partners, mobile clients, or Ajax-based
    website to access data on your site to create, read, update, and delete content
    as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, install the Django REST Framework in your virtual environment
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Add `"rest_framework"` to `INSTALLED_APPS` in the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, enhance the `music` app that we defined in the *Importing data from a
    local CSV file* recipe. You will also want to collect the static files provided
    by the Django REST framework for the pages it provides to be as nicely styled
    as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate a new RESTful API in our `music` app, execute the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add configurations for the Django REST framework to the settings, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `music` app, create the `serializers.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two new class-based views to the `views.py` file in the `music` app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, plug in the new views to the project URL configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we created here is an API for the music, where you can read a paginated
    song list, create a new song, and read, change, or delete a single song by ID.
    Reading is allowed without authentication, but you have to have a user account
    with the appropriate permissions to add, change, or delete a song. The Django
    REST framework provides you with web-based API documentation that is shown when
    you access the API endpoints in a browser via `GET`. Without logging in, the framework
    would display something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd2daa28-8624-4711-a718-076ef523be69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s how you can approach the created API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **HTTP Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/rest-api/songs/` | `GET` | List songs paginated by 50. |'
  prefs: []
  type: TYPE_TB
- en: '| `/rest-api/songs/` | `POST` | Create a new song if the requesting user is
    authenticated and authorized to create songs. |'
  prefs: []
  type: TYPE_TB
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `GET` | Get a
    song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c`. |'
  prefs: []
  type: TYPE_TB
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `PUT` | Update
    a song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c` if the user is authenticated
    and authorized to change songs. |'
  prefs: []
  type: TYPE_TB
- en: '| `/rest-api/songs/b328109b-``5ec0-4124-b6a9-e963c62d212c/` | `DELETE` | Delete
    the song with the ID `b328109b-5ec0-4124-b6a9-e963c62d212c` if the user is authenticated
    and authorized to delete songs. |'
  prefs: []
  type: TYPE_TB
- en: 'You might ask how you would use the API practically. For example, we might
    use the `requests` library to create a new song from a Python script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The same could be done via **Postman** app, which provides a user-friendly
    interface for submitting requests, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0605f718-271f-428b-a134-5e1a8cbbe6a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also try out the APIs via integrated forms under the framework-generated
    API documentation when logged in, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63df3efe-5bfc-4179-9916-e2c4fd7aada4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a quick look at how the code that we wrote works. In the settings,
    we have set the access to be dependent on the permissions of the Django system.
    For anonymous requests, only reading is allowed. Other access options include
    allowing any permission to everyone, any permission only to authenticated users,
    any permission to staff users, and so on. The full list can be found at [https://www.django-rest-framework.org/api-guide/permissions/](https://www.django-rest-framework.org/api-guide/permissions/).
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the settings, pagination is set. The current option is to have the
    limit and offset parameters as in an SQL query. Other options are to have either
    the pagination by page numbers for rather static content or cursor pagination
    for real-time data. We set the default pagination to 50 items per page.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we define a serializer for the songs. It controls the data that will
    be shown in the output and validates the input. There are various ways to serialize
    relations in the Django REST framework, and we chose the most verbose one in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about how to serialize relations, refer to the documentation at
    [https://www.django-rest-framework.org/api-guide/relations/](https://www.django-rest-framework.org/api-guide/relations/).
  prefs: []
  type: TYPE_NORMAL
- en: After defining the serializers, we created two class-based views to handle the
    API endpoints and plugged them into the URL configuration. In the URL configuration,
    we also have a rule (`/api-auth/`) for browsable API pages, login, and logout.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Preparing paginated sitemaps for search engines* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating filterable RSS feeds* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing an API created using Django REST framework* recipe in [Chapter
    11](f22676ec-495d-430d-a535-06a7c9001e61.xhtml)*, Testing*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
