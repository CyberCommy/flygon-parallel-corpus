- en: Finding and Exploiting Cross-Site Scripting (XSS) Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web browser is a code interpreter that takes HTML and script code to present
    a document to the user in an attractive and useful format, including text, images,
    and video clips. It allows the user to interact with dynamic elements including
    search fields, hyperlinks, forms, video and audio controls, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways for an application to manage this dynamic interaction with
    users. The one way that is most common in today's web applications is the use
    of client-side script code. This means that the server sends code to the client
    that will be executed by the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: When user input is used to determine the script code behavior, and this input
    is not properly validated and sanitized in order to prevent it from containing
    code, rather than information, the injected code will be executed by the browser
    and you will have a **Cross-Site Scripting** (**XSS**) vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: XSS is a type of code injection that happens when script code is added to the
    user's input and processed as code instead of data by the web browser, which then
    executes it, altering the way the user sees the page and/or its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name, Cross-Site Scripting, may not intuitively relate to its current definition.
    This is because the term originally referred to a related, but different attack.
    In the late 1990s and early 2000s, it was possible to read data from web pages
    loaded in adjacent windows or frames using JavaScript code. Thus, a malicious
    website could cross the boundary between the two and interact with contents loaded
    on an entirely different web page not related to its domain. This was later fixed
    by browser developers, but the attack name was inherited by the technique that
    makes web pages load and execute malicious scripts in the browser rather than
    reading contents from adjacent frames.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, an XSS attack allows the attacker to execute malicious script
    code in another user's browser. It could be JavaScript, VBScript, or any other
    script code, although JavaScript is by far the one used most commonly. The malicious
    script is delivered to the client via a website that is vulnerable to XSS. On
    the client side, the web browser sees the scripts as a legitimate part of the
    website and executes them. When the script runs in the victim's browser, it can
    force it to perform actions similar to the ones a user could do. The script can
    also make the browser execute fraudulent transactions, steal cookies, or redirect
    the browser to another website.
  prefs: []
  type: TYPE_NORMAL
- en: 'An XSS attack typically involves the following participants:'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker who is executing the attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vulnerable web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The victim using a web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A third-party website to which the attacker wants to redirect the browser or
    attack through the victim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example of an attacker executing an XSS attack:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker first tests the various input fields for the XSS flaw using legitimate
    data. Input fields that reflect the data back to the browser might be candidates
    for an XSS flaw. The following screenshot shows an example, where the website
    passes the input using the `GET` method and displays it back to the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the attacker finds a parameter to inject on which insufficient or no input
    validation has been done, they will have to devise a way to deliver the malicious
    URL containing the JavaScript to the victim. The attacker could use an email as
    a delivery mechanism, or entice the victim into viewing the email by through a
    phishing attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The email would contain a URL to the vulnerable web application along with
    the injected JavaScript. When the victim clicks on it, the browser parses the
    URL and also sends the JavaScript to the website. The input, in the form of JavaScript,
    is reflected in browser; consider the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The complete URL is `http://example.org/hello.php?name=<script>alert('Pwned!!')</script>`.
  prefs: []
  type: TYPE_NORMAL
- en: The alert method is often used for demonstration purpose and to test if the
    application is vulnerable. We will explore other JavaScript methods that attackers
    often use, later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the web application is vulnerable, a dialog box will pop up in the victim''s
    browser, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The main objective of XSS is to execute JavaScript in the victim''s browser,
    but there are different ways to achieve it depending on the design and purpose
    of the website. Here are the three major categories of XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM-based XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An XSS flaw is called **persistent** or **stored** when the injected data is
    stored on the web server or the database, and the application serves it back to
    one or all users of the application without validation. An attacker whose goal
    is to infect every visitor to the website would use a persistent XSS attack. This
    enables the attacker to exploit the website on a large scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical targets of persistent XSS flaws are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Web-based discussion forums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social networking websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: News websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent XSS** is considered to be more serious than other XSS flaws, as
    the attacker''s malicious script is injected into the victim''s browser automatically.
    It does not require a phishing attack to lure the user into clicking on a link.
    The attacker uploads the malicious script onto a vulnerable website, and it is
    then delivered to the victim''s browser as part of their normal browsing activity.
    As XSS can also be used to load scripts from an external site. This is especially
    damaging in stored XSS. When injected, the following code will query the remote
    server for the JavaScript to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of a web application vulnerable to persistent XSS is shown in the
    following diagram. The application is an online forum where users can create accounts
    and interact with others. The application stores the user''s profile in a database
    along with other details. The attacker determines that the application fails to
    sanitize the data kept in the comments section and uses this opportunity to add
    a malicious JavaScript to that field. This JavaScript gets stored in the database
    of the web application. During normal browsing, when an innocent victim views
    these comments, the JavaScript gets executed in the victim''s browser, which then
    grabs the cookie and delivers it to a remote server under the control of the attacker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Recently, persistent XSS has been used on multiple sites across the internet
    to exploit user's websites as workers for cryptocurrency mining or to form botnets
    of browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **reflected XSS** is a nonpersistent form of attack. The malicious script
    is part of the victim's request to the web application, which is then reflected
    back by the application in form of the response. This may appear difficult to
    exploit, as a user won't willingly send a malicious script to a server, but there
    are several ways to trick the user into launching a reflected XSS attack against
    their own browser.
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS is mostly used in targeted attacks where the hacker deploys a
    phishing email containing the malicious script along with the URL. Alternatively,
    the attack could involve publishing a link on a public website and enticing the
    user to click on it. These methods, combined with a URL-shortening service that
    abridges the URL and hides the long, odd-looking script that would raise doubts
    in the mind of the victim, can be used to execute a reflected XSS attack with
    a high success rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following diagram, the victim is tricked into clicking a URL
    that delivers the script to the application, which is then reflected back without
    proper validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DOM-based XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third type of XSS is local and directly affects the victim's browser. This
    attack does not rely on malicious content being sent to the server, but it uses
    the **Document Object Model** (**DOM**), which is the browser's API in order to
    manipulate and present the web pages. In persistent and reflected XSS, the script
    is included in the response by the server. The victim's browser accepts it, assuming
    it to be a legitimate part of the web page, and executes it as the page loads.
    In **DOM-based XSS**, only the legitimate script that is provided by the server
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: An increasing number of HTML pages are generated by downloading JavaScript on
    the client side and using configuration parameters to adjust what the user sees,
    rather than being sent by the server as they should be shown. Any time an element
    of the page is to be changed without refreshing the entire page, it is done using
    JavaScript. A typical example is a website that allows a user to change the pages'
    language or colors, or resize the elements within it.
  prefs: []
  type: TYPE_NORMAL
- en: DOM-based XSS makes use of this legitimate client-side code to execute a scripting
    attack. The most important part of DOM-based XSS is that the legitimate script
    is using a user-supplied input to add HTML content to the web page displayed on
    the user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss an example of DOM-based XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose a web page is created to display customized content depending on the
    city name passed in the URL, the city name in the URL is also displayed in the
    HTML web page on the user''s browser, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the browser receives the preceding URL, it sends a request to `http://www.cityguide.test`
    to receive the web page. On the user's browser, a legitimate JavaScript is downloaded
    and run, which edits the HTML page to add the city name on the top in the heading
    of the loaded page as a heading. The city name is taken from the URL (in this
    case, `Mumbai`). So, the city name is the parameter the user can control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As discussed earlier, the malicious script in DOM-based XSS is not sent to the
    server. To achieve this, the `#` sign is used to prevent any content that comes
    after the sign from being sent to the server. Therefore, the server-side code
    has no access to it, even though the client-side code can access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The malicious URL may look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the page is being loaded, the browser hits the legitimate script that uses
    the city name from the URL to generate the HTML content. In this case, the legitimate
    script encounters a malicious script and writes the script to the HTML body instead
    of the city name. When the web page is rendered, the script gets executed, resulting
    in a DOM-based XSS attack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates DOM-based XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: XSS using the POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, you have seen the use of the `GET` method to deliver
    a malicious link to the victim or to store the payload in the server. Although
    it may require a more elaborate setup to attack in real life, XSS attacks using
    `POST` requests are also possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `POST` parameters are sent in the body of the request and not in the
    URL, an XSS attack using this method would require the attacker to convince the
    victim to browse to a site controlled by the attacker. This will be the one sending
    the malicious request to the vulnerable server, which will thus respond to the
    user, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Other XSS attack vectors
  prefs: []
  type: TYPE_NORMAL
- en: Form parameters sent by the `POST` or `GET` methods are not the only ones used
    for XSS attacks. Header values such as `User-Agent`, `Cookie`, `Host`, and any
    other header whose information is reflected to the client are also vulnerable
    and susceptible to XSS attacks, even through the `OPTIONS` or `TRACE` methods.
    As penetration testers, you need to test completely all components of the request
    that are processed by the server and reflected back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hackers have been very creative when exploiting the XSS flaw, and with the
    capabilities of JavaScript in current browsers, the attack possibilities have
    increased. XSS combined with JavaScript can be used for the following types of
    attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Account hijacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defacing websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a port scan from the victim's machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging key strokes and monitoring a user's activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealing browser information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting browser vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many different ways of triggering an XSS vulnerability, not only
    the `<script></script>` tag. Refer to OWASP''s cheat sheet at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at some practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Cookie stealing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the immediate implications of an XSS vulnerability is the possibility
    of an attacker using script code to steal a valid session cookie and use it to
    hijack a user's session if the cookie's parameters are not well configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gather session cookies, an attacker needs to have a web server
    running and listening for requests sent by the injected applications. In the most
    basic case, this can be done with anything from a basic Python HTTP server, up
    to a proper Apache or nginx server running an application receiving and storing
    the IDs and even using them to perform further attacks automatically. For the
    sake of demonstration, we will use the basic Python server. Execute the following
    command in a Terminal session in Kali Linux to run the server on port `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is running, you will exploit a persistent XSS in the WackoPicko
    web application included in the OWASP BWA virtual machine. Browse to WackoPicko
    in Kali Linux, and in the Guestbook form, submit a comment with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `127.0.0.1` is Kali Linux''s local IP address. It should be replaced
    by the address of the server set up to receive the cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Every time the Guestbook page loads, it will execute the script and attempt
    to get an image from an external server. The request made to get such an image
    includes the session cookie in the URL, which will be recorded on the receiving
    server, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Website defacing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using XSS to deface a website (change its visual appearance) is not a very common
    attack. Nonetheless, it can be done, especially for persistent vulnerabilities,
    and it can cause serious reputation damage for a company whose website has been
    defaced, even if no change is made to the server's files.
  prefs: []
  type: TYPE_NORMAL
- en: You can change a website's appearance with JavaScript in many ways. For example,
    inserting HTML elements such as `div` or `iframe`, replacing style values, changing
    image sources, and many other techniques can alter a website's appearance. You
    can also use the `innerHTML` property of the document's body to replace the entire
    HTML code of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutillidae II has a DOM XSS test form that will help us test this. In the menu,
    go to OWASP 2013 | A3 - Cross-Site Scripting (XSS) | DOM Injection | HTML5 Storage.
    This demo application saves information to the browser''s HTML5 storage, and it
    contains a number of vulnerabilities. Here we will focus on the fact that it reflects
    the key when an element is added to storage, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The form has some level of sanitization, as the `script` tags don''t get reflected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After some trial and error with different injection strings, you will find
    that an `img` tag with a nonexistent source (for example, the `src` parameter)
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting that code as the key of the new element and clicking on Add New displays
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As mentioned earlier, an attack like this will not change the files on the web
    server, and the changes will be noticeable only to those users that run the malicious
    script. When a persistent XSS is exploited, the defacement may affect a large
    number of users as the attacker doesn't need to target every victim individually,
    as is the case with reflected and DOM-based XSS. Either way, this may lead users
    into giving sensitive information to attackers while thinking that they are submitting
    it to a legitimate website.
  prefs: []
  type: TYPE_NORMAL
- en: Key loggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to take advantage of XSS's ability to gather users' sensitive information
    is by turning the browser into a key logger that captures every keystroke and
    sends it to a server controlled by the attacker. These keystrokes may include
    sensitive information that the user enters in the page, such as names, addresses,
    passwords, secret questions and responses, credit card information, and other
    types, depending on the purpose of the vulnerable page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the Apache web server, which is preinstalled in Kali Linux, in
    order to store the keystrokes in a file so that we can check the keys sent by
    the vulnerable application once we exploit the XSS. The server will have two files:
    `klog.php` and `klog.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `klog.php` file will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the `klog.js` file will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `10.7.7.4` is the address of the Kali Linux machine, so that the victims
    will send the buffer to that server. Also, depending on the system''s configuration,
    you may have to create the `keys.txt` file in the path specified in the code.
    In this example, it is the web root (`/var/www/html/`). Also, add write permissions
    or set the ownership to the Apache''s user to prevent permission errors when the
    web server tries to update a local file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest version of a key logger. A more sophisticated version
    could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamp of the capture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifier of the user or machine sending the information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving keys to a database to facilitate queries, grouping, and sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling functionality, such as starting and stopping key loggers, triggering
    actions on certain keys or combinations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing information from clients or users during a penetration test should
    be avoided when possible, although sometimes it's necessary for correct coverage
    of certain attack vectors. If this is the case, proper security measures must
    be taken on the transmission, storage, and handling of such information. If any
    information is sent to a server controlled by the penetration tester, communication
    must be encrypted using HTTPS, SSH, or other secure protocol. The storage must
    also be encrypted. Full disk encryption is recommended, but database and file
    encryption on top of it is also required. Furthermore, depending on the rules
    of engagement, secure erase of all information may be requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using WackoPicko''s Guestbook again, submit the following comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will load the external JavaScript file in the page every time a user accesses
    the Guestbook page and capture all of the keystrokes issued by them. You can now
    type anything while in the page, and it will be sent to your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to check what has been recorded so far, you just need to see the
    `keys.txt` file in Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see that as keys are buffered in the client and sent at regular intervals,
    there are groups of varying lengths separated by commas and the nonprintable keys
    are written by name: `ArrowLeft`, `ArrowRight`, `Backspace`, `Home`, `End`, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Taking control of the user's browser with BeEF-XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An attack known as **Man-in-the-Browser** (**MITB**) uses JavaScript to hook
    the user''s browser to a **Command and Control** (**C2**) server that uses a script
    to issue orders to the browser and gathers information from it. XSS can be used
    as the vehicle to make a user load such a script while accessing a vulnerable
    application. Among the actions that an attacker could perform are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading keystrokes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting passwords saved in the browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading cookies and HTML5 storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling microphone and webcam (may require user interaction)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting browser vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the browser as pivot to the internal network of an organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the behavior of browser's tabs and windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing malicious browser extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux includes **Browser Exploitation Framework** (**BeEF**), which is
    a tool that sets up a web server hosting a C2 center as well as the hook code
    to be called by the victims in a MITB attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will demonstrate how an attacker can use XSS to get a client (user''s
    browser) to call that hook file and how to use that to execute actions remotely
    on such a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to start the `beef-xss` service in Kali Linux. This can be
    done through the Applications menu: Applications | 13 - Social Engineering Tools
    | beef xss framework, or through Terminal as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the service starts correctly, you should be able to browse to the control
    panel. By default, BeEF runs on port `3000`, so browse to [`http://127.0.0.1:3000/ui/panel`](http://127.0.0.1:3000/ui/panel)
    and log in with the default username and password: `beef`/`beef`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next step for an attacker would be to exploit a persistent XSS or to trick
    a user into clicking on a link to a malicious site or to a site vulnerable to
    XSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, as the victim, go to Mutillidae (OWASP 2013 | A3 - Cross Site Scripting
    (XSS) | Reflected (first order) | DNS Lookup) and submit the following in the
    Hostname/IP textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, `10.7.7.4` is the address of the server running BeEF. In this case,
    your Kali Linux machine. You can see that the result appears to be empty, but
    if you browse to your BeEF control panel, you will see that you have a new browser
    connected. In the Details tab, you can see all of the information about this browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you go to the Logs tab inside Current Browser, you will see that the hook
    registers everything the user does in the browser, from clicks and keystrokes
    to changes of windows or tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Commands tab, you can issue commands to the victim browser. For example,
    in the following screenshot, a cookie was requested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scanning for XSS flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With hundreds of possible payload variants, and being one of the most common
    vulnerabilities in web applications, XSS can sometimes be difficult to find or,
    if found, difficult to generate a convincing proof of concept exploit that motivates
    the client's team to dedicate the time and effort to fix it. Additionally, big
    applications with hundreds or thousands of input parameters are nearly impossible
    to cover completely in time-boxed tests.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, you may need to make use of automation to be able to generate
    results faster, even when some degree of precision may be sacrificed and with
    an increased risk of triggering some service disruption in the application. There
    are many web vulnerability scanners, both free and paid, with a wide range of
    degrees of accuracy, stability, and safety. We will now review a couple of specialized
    scanners for XSS vulnerabilities that have proven to be efficient and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: XSSer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross Site "Scripter"** (**XSSer**) is an automatic framework designed to
    detect, exploit, and report XSS vulnerabilities in web-based applications. It
    is included in Kali Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: XSSer can detect persistent, reflected, and DOM-based XSS, scan an indicated
    URL or search Google for potential targets based on a given query, authenticate
    through different mechanisms, and perform many other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a simple scan using BodgeIt''s search request as a target. To do
    that, issue the following command in Kali Linux''s Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, XSSer is running over the URL indicated by the `-u` parameter and scanning
    using the `GET` method and the `q` (`-g ?q=`) parameter. This means that the scanner
    will append its payloads to the string specified after `-g`, and the result of
    that will be appended to the URL, as it is using `GET`. After running the command,
    you''ll see the result indicating that the URL tested is vulnerable to XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is also the option of using a GUI using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the GUI looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: XSS-Sniper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS-Sniper is not included in Kali Linux, but is definitely worth trying. It
    is an open source tool by Gianluca Brindisi that can search for XSS vulnerabilities,
    including DOM-based XSS in a specific URL, or it can crawl an entire site. Although
    not as feature-rich as XSSer, it is a good option when XSSer is not available
    or to verify results.
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS-Sniper can be downloaded from its GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To run a basic scan over a `GET` request, use only the `-u` parameter followed
    by the full URL including a test value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00189.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Burp Suite Professional and OWASP ZAP include a vulnerability scan functionality
    that can detect many XSS instances with good accuracy. Scanners such as W3af,
    Skipfish, and Wapiti can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing and mitigating Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other injection vulnerability, a proper input validation is the
    first line of defense in order to prevent XSS. Also, if possible, avoid using
    user inputs as output information. Sanitization and encoding are key aspects of
    preventing XSS.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sanitization** means removing inadmissible characters from the string. This
    is useful when no special characters should exist in input strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding converts special characters to their HTML code representation. For
    example, `&` to `&amp;` or `<` to `&lt;`. Some types of applications may need
    to allow the use of special characters in input strings. For those applications,
    sanitization is not an option. Thus, they should encode the output data before
    inserting it into the page and storing it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The validation, sanitization, and encoding processes must be done on both the
    client side and the server side in order to prevent all types of XSS and other
    code injections.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about prevention of Cross-Site Scripting can be found at the
    following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet](https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting](https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.acunetix.com/blog/articles/preventing-xss-attacks/](https://www.acunetix.com/blog/articles/preventing-xss-attacks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the XSS flaw in detail. We began by looking at
    the origin of the vulnerability and how it evolved over the years. You then learned
    about the different forms of XSS and their attack potential. We also analyzed
    how an attacker can make use of different JavaScript capabilities to perform a
    variety of actions in the victim's browser, such as stealing session cookies,
    logging key presses, defacing websites, and remotely controlling a web browser.
    Kali Linux has several tools to test and exploit the XSS flaw. We used XSSer and
    XSS-Sniper to detect vulnerabilities in a web application. In the last section,
    we reviewed the general measures that should be taken in order to prevent or fix
    a XSS vulnerability in a web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we describe Cross-Site Request Forgery and show how it can
    be exploited to trick an authenticated user into performing undesired actions,
    recommendation on how to prevent such flaws is also given.
  prefs: []
  type: TYPE_NORMAL
