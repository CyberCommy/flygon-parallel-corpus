- en: 6\. Updating with Aggregation Pipelines and Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用聚合管道和数组进行更新
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to two additional features of update operations
    in MongoDB. You will first learn how to perform some complex update operations
    using pipeline support. Using pipeline support, you will be able to write a multi-step
    update expression and also refer to the values of other fields. Next, the chapter
    covers the updating of array fields in documents, which involves adding elements
    to an array, updating or deleting all or specific elements, creating arrays as
    a set, and sorting array elements. You will practice pushing unique elements to
    an array and sorting its elements as part of the final activity. By the end of
    this chapter, you will be able to derive update expressions based on the values
    of other fields and manipulate array fields in the documents of a collection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了MongoDB中更新操作的另外两个特性。您将首先学习如何使用管道支持执行一些复杂的更新操作。使用管道支持，您将能够编写多步更新表达式，并引用其他字段的值。接下来，本章涵盖了文档中数组字段的更新，其中包括向数组添加元素、更新或删除所有或特定元素、创建数组作为集合以及对数组元素进行排序。您将练习将唯一元素推送到数组中，并对其元素进行排序作为最终活动的一部分。通过本章结束时，您将能够根据其他字段的值推导出更新表达式，并操作集合中文档的数组字段。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have covered querying using various operators to prepare query expressions.
    We have also learned how to create, delete, and modify documents in the collection,
    used various delete and update functions, and considered their differences and
    usability. We have also covered how to replace documents and how to perform upsert
    operations using a number of update operators. Now it is time to practice more
    complex update operations using the aggregation pipeline support, and learn how
    to modify arrays in a document.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了使用各种运算符来准备查询表达式的查询。我们还学习了如何在集合中创建、删除和修改文档，使用了各种删除和更新函数，并考虑了它们的差异和可用性。我们还涵盖了如何替换文档以及如何使用多个更新运算符执行upsert操作。现在是时候通过使用聚合管道支持来练习更复杂的更新操作，并学习如何修改文档中的数组。
- en: We will begin this chapter with MongoDB pipeline support, where we will briefly
    introduce the aggregation pipeline and how it helps you to perform more complex
    update operations. We will then cover how to update array fields, how to add and
    sort elements of an existing array, and use an array as a set of unique elements.
    Next, you will learn how to remove the first, last, or another specific element
    from an array. Finally, you will learn how to prepare an array filter with a query
    criterion and use it to modify only specific elements in an array.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从MongoDB管道支持开始这一章，我们将简要介绍聚合管道以及它如何帮助您执行更复杂的更新操作。然后我们将介绍如何更新数组字段，如何添加和排序现有数组的元素，并使用数组作为唯一元素集。接下来，您将学习如何从数组中删除第一个、最后一个或另一个特定元素。最后，您将学习如何准备一个带有查询条件的数组过滤器，并使用它来仅修改数组中的特定元素。
- en: Updating with an Aggregation Pipeline (MongoDB 4.2)
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用聚合管道进行更新（MongoDB 4.2）
- en: In the previous chapter, we covered update functions that are used to modify
    fields from one or more documents. We also wrote a lot of update operations using
    various operators. As you have seen in the examples, where we assigned a field
    with a new value, we either used hardcoded values (for example, while updating
    `num_mflix_comments`) or dynamically derived values using operators such as `$inc`.
    However, in more complex update operations, you may need to use dynamically derived
    fields that are based on the values of other fields. Or, the update operation
    may involve multiple steps of update expressions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了用于修改一个或多个文档中字段的更新函数。我们还使用了各种运算符编写了许多更新操作。正如您在示例中所看到的，我们在分配新值给字段时，要么使用硬编码的值（例如，在更新`num_mflix_comments`时），要么使用诸如`$inc`之类的运算符动态派生的值。然而，在更复杂的更新操作中，您可能需要使用基于其他字段的值动态派生的字段。或者，更新操作可能涉及多步更新表达式。
- en: In the previous versions of MongoDB, referring to other fields' values or writing
    multi-step update operations was not possible, but, with the release of MongoDB
    4.2, all of its update functions have started supporting aggregation pipelines.
    The aggregation pipelines and various aggregation operators will be covered in
    `detail` in *Chapter 7*, *Aggregation Pipelines*. For now, we will limit the discussion
    to writing update expressions using pipeline support.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的MongoDB版本中，引用其他字段的值或编写多步更新操作是不可能的，但是，随着MongoDB 4.2的发布，它的所有更新函数都开始支持聚合管道。聚合管道和各种聚合运算符将在第7章“聚合管道”中详细介绍。现在，我们将限制讨论使用管道支持编写更新表达式。
- en: A pipeline is composed of multiple update expressions called stages. When an
    update operation containing multiple stages of update expressions is executed,
    each of the matched documents is processed and transformed through each stage
    sequentially. The output of the first stage is input for the next stage, until
    the last stage in the pipeline produces the final output. Apart from writing multi-stage
    update expressions, pipeline support also allows the use of field references in
    the update expressions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 管道由多个称为阶段的更新表达式组成。当执行包含多个阶段的更新表达式的更新操作时，每个匹配的文档都会按顺序经过每个阶段进行处理和转换。第一个阶段的输出是下一个阶段的输入，直到管道中的最后一个阶段产生最终输出。除了编写多阶段更新表达式外，管道支持还允许在更新表达式中使用字段引用。
- en: In previous update expressions, we have either set hardcoded values on the fields,
    or for numeric fields, we have used various operators to manipulate their existing
    values. However, using pipeline support, we can read and use the values of other
    fields in an update expression.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的更新表达式中，我们要么在字段上设置硬编码的值，要么对数字字段使用各种运算符来操作其现有值。然而，使用管道支持，我们可以在更新表达式中读取并使用其他字段的值。
- en: 'The following code snippet shows the syntax for using aggregation pipelines
    in `updateMany()`. It is the same for all other update functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may have noticed that the second argument to the function, which specifies
    an update expression, is now an array of multiple update expressions or stages.
    As stated, the syntax is only valid if your MongoDB version is 4.2 or later. Instead
    of passing an array, if a document with a single update expression is provided,
    it will be executed as a normal update command.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider how the aggregation pipeline allows us to write complex update
    queries and enables us to use field expressions and aggregation operations with
    an example. We have been using the *CH05* database in the previous chapter's examples
    and will continue using it here. If you already have the `users` collection, delete
    all of its elements before we insert two records into it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following records to the collection:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both documents have an `_id` and `full_name` field, composed of first and last
    names separated by a white space. We will write an update command to split the
    full name into the respective fields of first name and last name, and update the
    `full_name` field so that only the first name appears in uppercase:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `updateMany()` operation is updating all the documents in the `users`
    collection. The second argument to the function is an array containing three stages
    (`$set`, `$set`, and `$project`). Now, we will go through each of these stages
    and explore the pipeline.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Operators such as `$project`, `$arrayElemAt`, and `$concat` are aggregation
    operators. These operators cannot be used on versions older than MongoDB 4.2 or
    in an update expression that is not part of the aggregation pipeline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Stage 1 ($set)
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, we are using the `$split` operator to split the full name with
    a white space. This gives us a two-element array containing the first name and
    the last name. We are also creating a new field of `name_array` using the `$set`
    operator and assigning the newly created array to it. `name_array` is a temporary
    field for us.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Stage 2 ($set)
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this stage, we refer to the array stored in `name_array` and create new fields
    for the first name and last name. To do so, we use `$arrayElemAt` on the name
    array to fetch its element from a specific index position. A new field called
    `first_name` is created using the zeroth position element, and the `last_name`
    field is created using the first index position element. At the end of this stage,
    each user's documents will have `first_name`, `last_name`, `name_array`, and the
    original `full_name` field.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Stage 3 ($project)
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last stage, we project fields. We explicitly include the `first_name`
    and `last_name` fields and rewrite `full_name` by concatenating `first_name` in
    uppercase and `last_name`; note that we will not change the case for `last_name`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The `$toUpper` operator refers to the value of `first_name` and returns the
    same string in uppercase. The `$concat` operator accepts an array of strings and
    returns a single string by concatenating all the elements in the same order. Here,
    we were concatenating `first_name` in uppercase, a white space, and `last_name`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$project` operator is used to project fields and to assign them. In this
    stage, we project `first_name`, `last_name`, and `full_name`, meaning that `name_array`
    will be omitted automatically:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: Updating using pipeline support'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Updating using pipeline support'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output shows that the operation was successful. It matched two
    documents and both of them were modified. We will now query the documents and
    see whether they have updated correctly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the `find` query and the output shows that the documents are modified
    correctly. The original full name is correctly split into a first and a last name.
    Also, the first name in the `full_name` field is in uppercase.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we studied how to write complex update commands using pipeline
    stages and aggregation operator support provided by MongoDB 4.2\. We also learned
    that the stages are executed in sequence and the output of a stage becomes the
    input of the next stage.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用MongoDB 4.2提供的管道阶段和聚合运算符支持编写复杂的更新命令。我们还了解到阶段是按顺序执行的，一个阶段的输出成为下一个阶段的输入。
- en: Updating Array Fields
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数组字段
- en: In the previous sections, we learned about updating fields in one or more MongoDB
    documents. We also learned how to write update expressions using various operators
    and how to use MongoDB pipeline support. In this section, we will learn about
    updating array fields from a document.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何更新一个或多个MongoDB文档中的字段。我们还学习了如何使用各种运算符编写更新表达式以及如何使用MongoDB管道支持。在本节中，我们将学习如何从文档中更新数组字段。
- en: 'To try some basic update operations on array fields, we will insert the following
    document into the `movies` collection:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试一些基本的数组字段更新操作，我们将向`movies`集合中插入以下文档：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The document only has a `title` field and does not contain an array, so let''s
    try creating one:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文档只有一个`title`字段，不包含数组，所以让我们尝试创建一个：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding operation uses `$set` in the `genre` field. The value of `genre`
    is a single-element array—`["unknown"]`. The output can be seen here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作在`genre`字段中使用了`$set`。`genre`的值是一个单元素数组—`["unknown"]`。输出如下所示：
- en: '![Figure 6.2: Updating value of an array field'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：更新数组字段的值'
- en: '](img/B15507_06_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_02.jpg)'
- en: 'Figure 6.2: Updating value of an array field'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：更新数组字段的值
- en: 'The output shows that the `genre` field is created and assigned the value of
    the given array. Next, we will remove the fields from the document, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`genre`字段已创建并分配了给定数组的值。接下来，我们将从文档中删除字段，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding update command uses `$unset` to remove the `genre` field. You
    can see the output here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新命令使用`$unset`来删除`genre`字段。您可以在这里看到输出：
- en: '![Figure 6.3: Removing an array field'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：删除数组字段'
- en: '](img/B15507_06_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_03.jpg)'
- en: 'Figure 6.3: Removing an array field'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：删除数组字段
- en: The output indicates that the field is correctly removed from the document.
    From these two examples, it is clear that when an array field is being updated
    using the array as a value, it is treated like any other field. Next, we will
    see how we can manipulate array elements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明该字段已从文档中正确删除。从这两个示例中可以清楚地看出，当使用数组作为值更新数组字段时，它会像其他字段一样对待。接下来，我们将看到如何操作数组元素。
- en: We have seen how we can update fields with array values. It is useful when we
    want to fully replace an array value. However, to add more elements to an array,
    an operator called `$push` can be used. The operator pushes a given element to
    the end of an array, and if the given field is not present, it is created. Let's
    use this in the next exercise.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用数组值更新字段。当我们想要完全替换数组值时，这是有用的。但是，要向数组添加更多元素，可以使用一个叫做`$push`的运算符。该运算符将给定元素推送到数组的末尾，如果给定字段不存在，则创建它。让我们在下一个练习中使用它。
- en: 'Exercise 6.01: Adding Elements to Arrays'
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01：向数组添加元素
- en: 'In this exercise, you will add elements to arrays using the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用以下步骤向数组添加元素：
- en: 'To insert a single document, add the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要插入单个文档，请添加以下命令：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The update operation in the preceding snippet finds a document by its `_id`
    value and pushes an element to the `genre` array. This field is currently absent
    in the document. You should see the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中的更新操作通过其`_id`值找到文档，并将一个元素推送到`genre`数组中。该字段目前不存在于文档中。您应该看到以下输出：
- en: '![Figure 6.4: Adding one element into an array'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：向数组添加一个元素'
- en: '](img/B15507_06_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_04.jpg)'
- en: 'Figure 6.4: Adding one element into an array'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：向数组添加一个元素
- en: 'As shown here, the `genre` array field is created successfully, and the given
    element is added to the array. Now add one more genre, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如图所示，`genre`数组字段成功创建，并且给定元素已添加到数组中。现在再添加一个流派，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command inserts another genre, `Drama`. You can see the output
    here, which shows that the `Drama` element has been added to the end of the existing
    array:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令插入了另一个流派，`Drama`。您可以在这里看到输出，显示`Drama`元素已添加到现有数组的末尾：
- en: '![Figure 6.5: Adding another element into the array'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5：向数组添加另一个元素'
- en: '](img/B15507_06_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_05.jpg)'
- en: 'Figure 6.5: Adding another element into the array'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：向数组添加另一个元素
- en: We dealt with adding single elements in this exercise. In the next section,
    we will add multiple elements at once.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们处理了添加单个元素。在下一节中，我们将一次添加多个元素。
- en: Adding Multiple Elements
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加多个元素
- en: 'As we have seen, `$push` can add one element at a time. To add multiple elements
    to an array in a single update command, we have to use `$push` along with `$each`.
    The following is the syntax for this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`$push`可以一次添加一个元素。要在单个更新命令中向数组添加多个元素，我们必须使用`$push`和`$each`。以下是此操作的语法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The elements that need to be appended to the array are provided to the `$each`
    operator in the form of an array. When such an update expression is executed,
    `$each` iterates through each element, and the element is pushed to the array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 需要附加到数组的元素以数组的形式提供给`$each`运算符。当执行这样的更新表达式时，`$each`会迭代每个元素，并将元素推送到数组中：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding update operation finds and updates a document by its `_id` field
    and uses `$push` to add elements to the `genre` field. We add two elements to
    the array by providing those two elements to `$each`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的更新操作通过其`_id`字段找到并更新文档，并使用`$push`向`genre`字段添加元素。我们通过将这两个元素提供给`$each`来向数组添加两个元素：
- en: '![Figure 6.6: Pushing multiple elements into an array'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6：向数组推送多个元素'
- en: '](img/B15507_06_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_06.jpg)'
- en: 'Figure 6.6: Pushing multiple elements into an array'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：向数组推送多个元素
- en: The document in the response (see the preceding screenshot) indicates that both
    the elements are correctly appended to the end of the array and are added in the
    same order.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Sort Array
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays in MongoDB, and in general, are an ordered but unsorted collection of
    elements. In other words, the elements of the array will always remain in the
    order in which they were inserted. However, while executing an update command
    with `$push`, we can also sort an array. To do that, we must use the `$sort` operator
    with `$each`. In the previous examples, we added four elements to the `genre`
    array. Now, we will try to sort the array alphabetically:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding command, we use `$push` in the `genre` field. One thing to
    note is that this query is not pushing any element to the array because there
    are no elements provided to the `$each` operator. The new `$sort` operator is
    assigned the value `1`, which denotes ascending order:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Sorting an array'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Sorting an array'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown, the `genre` array is now alphabetically sorted in ascending order
    of the elements. In the previous example, we sorted an array without adding an
    element to it, but we can also perform the sort while inserting one or more elements
    into an array. In that case, the new elements will be added to the array, and
    the array will be sorted based on the given sort order. Consider the following
    snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this update command, we pass a new element, `Crime`, to the genre. Note
    that the `$sort` operator has a value of `-1`. When we execute this command, the
    new element will be added to the array, and the array will be sorted in descending
    alphabetical order. This results in the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Sorting an array and pushing elements into it'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Sorting an array and pushing elements into it'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the response, the array is sorted in descending order and
    the new element, `Crime`, is part of the `genre` array. Without providing the
    `$sort` operator, the new element would be appended to the end of the array. In
    both the previous examples, the `genre` array contains plain string elements.
    However, if we have an array of objects that contains multiple fields, sorting
    can be performed based on the fields of nested objects. Consider the following
    record in an `items` collection:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `items` field is an array of four objects, each containing three fields.
    We will sort the array by price now:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The update command finds one document and sorts the array field. Unlike the
    previous examples, this time we want to sort the elements based on their nested field:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Sorting an array based on a value of a nested field'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Sorting an array based on a value of a nested field'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Note the array field in the modified document. All the elements are now sorted
    in descending order by price. In the next section, we will learn about using arrays
    in MongoDB as sets.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: An Array as a Set
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is an ordered collection of elements that can be iterated over or accessed
    using its specific index position. A set is a collection of unique elements whose
    order is not guaranteed. MongoDB supports only plain arrays and no other types
    of collections. However, you may want your array to contain unique elements only.
    MongoDB provides a way to do that by using the `$addToSet` operator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$addToSet` operator is like `$push`, with the only difference being that
    an element will be pushed only if it is not present already. This operator does
    not change the underlying array, but it ensures that only unique elements are
    pushed into it. Currently, the document for the movie `Macbeth` in our `movies`
    collection looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `genre` array is a really good example, wherein you want your array to
    have unique elements because duplicate genres for a movie do not make sense. Consider
    the following snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the update operation uses `$addToSet` to push an element of `Action`
    in the `genres` array. Note that the element is already part of the array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Adding element into an array as a set'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Adding element into an array as a set'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding screenshot, the `Action` element was not pushed
    to the array because the array already contains it. The same behavior is evident
    even when we use `$each` to push multiple elements into an array. For example,
    consider this snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we use `$each` to add three genres to the array, of which only the middle
    one is new:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Adding multiple elements into an array as a set'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Adding multiple elements into an array as a set'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The modified document confirms that only the new genre, `Thriller`, has been
    added to the array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.02: New Category of Classic Movies'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recently, due to the re-release of `Casablanca`, there has been quite an upsurge
    in demand for classic movies. The analytics department at your company found that,
    not surprisingly, classics are the only movies that both critics and viewers have
    rated above 95\. So, your company wants to assign all those movies in the database
    to a new genre, called "Classic." In your movie documents, a sample tomato rating
    looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Your task is to put a filter on the meter field in both the `viewer` and `critic`
    sub-objects to find classic movies and assign them the new genre. The following
    steps will help you to complete this exercise:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a text editor and start writing a query. You will have to prepare an update
    command to update multiple documents, so use `updateMany()`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first criterion in finding movies is that the tomato meter rating from
    viewers needs to be more than `95`. Type in the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you have added a filter to the viewer meter. As the field is nested within
    a nested field, you used the dot notations accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the second criterion, you need to put the same filter on the `critic`
    ratings. Add the second criterion to the query, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding command, you have added the same filter to the critic meter.
    The command now has all the required filters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create an update expression to add a new genre called `Classic` to all
    the matching movies:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You have now added the update expression. Note that the genres in the array
    should always be unique and so you would use `$addToSet` instead of `$push` to
    add the `Classic` element to the `genres` array.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a MongoDB shell and connect to the Mongo Atlas cluster, and then
    go to the `sample_mflix` database. Execute the preceding command on the database.
    The output should be as follows:![Figure 6.12: Adding the new genre'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_06_12.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Adding the new genre'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: You can see that all 30 records have been updated successfully.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify this, write a `find` query using the same condition and project the
    essential fields with the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `find` query here uses the same filter and displays only the `title` and
    `genres` fields. You can see the output as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Output showing the movies belonging to the Classic genre'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Output showing the movies belonging to the Classic genre'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The output indicates that all of the movies now have the new genre, `Classic`.
    In this exercise, you used the concept of sets for a business use case. In the
    next section, let's look at the deletion of array elements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Removing Array Elements
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have studied the various means of adding elements to an array and
    sorting an array using various operators. MongoDB also provides the means of removing
    elements from arrays. In this section, we will go through different operators
    that allow you to remove all or specific elements from an array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Removing the First or Last Element ($pop)
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `$pop` operator, when used in an update command, allows you to remove the
    first or last element in an array. It removes one element at a time and can only
    be used with the values `1` (for the last element) or `-1` (for the first element):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`$pop`运算符在更新命令中使用时，允许您删除数组中的第一个或最后一个元素。它一次删除一个元素，只能与值`1`（最后一个元素）或`-1`（第一个元素）一起使用：'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output in the preceding snippet shows the movie record as having six elements
    in the `genre` array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，输出显示电影记录的`genre`数组中有六个元素：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding `findOneAndUpdate` operation makes use of `$pop` on the `genre`
    field with the value `1`, which will remove the last element from the array. All
    other aspects of the command are the same as we have seen in the previous examples:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`findOneAndUpdate`操作在`genre`字段上使用了`$pop`，值为`1`，这将从数组中删除最后一个元素。命令的所有其他方面与我们在先前的示例中看到的一样：
- en: '![Figure 6.14: Removing the last element from an array'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：从数组中删除最后一个元素'
- en: '](img/B15507_06_14.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_14.jpg)'
- en: 'Figure 6.14: Removing the last element from an array'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：从数组中删除最后一个元素
- en: 'The modified document indicates that the last element (`Thriller`) has been
    successfully removed from the array. Now, use the following command with the value
    of `$pop` as `-1`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的文档表明最后一个元素（“惊悚”）已成功从数组中删除。现在，使用以下命令，将`$pop`的值设为`-1`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s see what happens when we execute this command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行此命令会发生什么：
- en: '![Figure 6.15: Removing the first element from an array'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.15：从数组中删除第一个元素'
- en: '](img/B15507_06_15.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_15.jpg)'
- en: 'Figure 6.15: Removing the first element from an array'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：从数组中删除第一个元素
- en: The output shows that the first element of the array (`'Unknown'`) has now been
    removed. Remember that `$pop` only allows `1` or `-1` as a value and that providing
    any other number, including a zero, results in an error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，数组的第一个元素（'未知'）现在已被删除。请记住，`$pop`只允许`1`或`-1`作为值，提供任何其他数字，包括零，都会导致错误。
- en: Removing All Elements
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除所有元素
- en: 'When you only need to remove certain elements from an array, you can use the
    `$pullAll` operator. To do so, you provide one or more elements to the operator,
    which then removes all occurrences of those elements from the array. For instance,
    consider the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只需要从数组中删除某些元素时，可以使用`$pullAll`运算符。为此，您向运算符提供一个或多个元素，然后它将从数组中删除所有这些元素的出现。例如，考虑以下命令：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this update operation, we use `$pullAll` in the `genre` field. We provide
    two elements, `Action` and `Crime`, in the form of an array. The output for this
    is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新操作中，我们在`genre`字段中使用了`$pullAll`。我们以数组的形式提供了两个元素`动作`和`犯罪`。这个的输出如下：
- en: '![Figure 6.16: Removing all elements of an array'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.16：删除数组的所有元素'
- en: '](img/B15507_06_16.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_16.jpg)'
- en: 'Figure 6.16: Removing all elements of an array'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：删除数组的所有元素
- en: We can see that the specified genres, `Action` and `Crime`, are now removed
    from the underlying array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，指定的流派`动作`和`犯罪`现在已从底层数组中删除。
- en: Removing Matched Elements
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除匹配的元素
- en: 'In the previous example, we saw how we can use `$pullAll` to remove specific
    elements from an array. In this example, we will use another operator, called
    `$pull`, to write a query condition, using various logical and conditional operators,
    and the array elements that match the query will then be removed. As an example,
    consider the following snippet, in which an array named `items` contains four
    objects:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何使用`$pullAll`从数组中删除特定元素。在这个例子中，我们将使用另一个名为`$pull`的运算符，编写一个查询条件，使用各种逻辑和条件运算符，并且与查询匹配的数组元素将被删除。例如，考虑以下片段，其中名为`items`的数组包含四个对象：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will write a query to update the array with `$pull`. Remember that
    it allows us to use combinations of logical and conditional operators to prepare
    a query condition, just like any `find` query:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个使用`$pull`更新数组的查询。请记住，它允许我们使用逻辑和条件运算符的组合来准备查询条件，就像任何`find`查询一样：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this update command, the `$pull` operator is provided with a query condition
    in the array field `items`. The conditions filter the array elements, where the
    `quantity` is `3` and the `name` ends with ''ck''. The output should be as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更新命令中，`$pull`运算符在数组字段`items`中提供了一个查询条件。条件过滤了数组元素，其中`quantity`为`3`且`name`以'ck'结尾。输出应该如下所示：
- en: '![Figure 6.17: Removing elements that matched the given regular expression'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：删除与给定正则表达式匹配的元素'
- en: '](img/B15507_06_17.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_17.jpg)'
- en: 'Figure 6.17: Removing elements that matched the given regular expression'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：删除与给定正则表达式匹配的元素
- en: The document in response shows that an element where the quantity was `3` and
    name ends with 'ck' is removed, as expected. Let's now look at updating array elements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中的文档显示，已删除了一个数量为`3`且名称以'ck'结尾的元素，正如预期的那样。现在让我们来看看如何更新数组元素。
- en: Updating Array Elements
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数组元素
- en: 'In an array, each element is bound to a specific index position. These index
    positions start at zero, and we can use a pair of square brackets (`[`, `]`) with
    the respective index position to refer to an element from the array. Using such
    a pair of square brackets with `$` allows you to update elements of an array.
    Consider the following snippet, which shows how the `genres` array looks currently:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中，每个元素都绑定到特定的索引位置。这些索引位置从零开始，我们可以使用一对方括号（`[`，`]`）和相应的索引位置来引用数组中的元素。使用带有`$`的这样一对方括号可以更新数组的元素。考虑以��片段，它显示了当前`genres`数组的外观：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `genres` array has two elements, and we will update both of them using
    the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`genres`数组有两个元素，我们将使用以下命令更新它们：'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this operation, we use `$set` in the `genres` field. The field is referred
    to by using the expression `"genre.$[]"` expression and provided with the value
    `Action` value. The `$[]` operator refers to all the elements contained by the
    given array and the update expression will be applied to all of them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18: Replacing all elements from an array'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_18.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.18: Replacing all elements from an array'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The document, in response, indicates that `genre` is still a two-element array.
    However, both elements are now changed to `Action`. Therefore, we can use `$[]`
    to update all elements of an array with the same value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can also update specific elements from an array. To do so, we
    first need to find such elements and identify them. To derive an element identifier,
    we can use the update option of `arrayFilters` to provide a query condition and
    assign it a variable (known as an identifier) to the matching elements. We then
    use the identifier along with `$[]` to update the values of those specific elements.
    To see an example of this, we will use the document from our `items` collection
    and add one more element to its array, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the preceding `update` command, we have added a new element to the array.
    Notice that the newly added element does not have the `price` and `quantity` fields.
    In the following update command, we will find and update elements from this array:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding update operation, we use `$set` to update the elements of
    the `items` array. The array element to be updated is referred to by an expression
    of `$[myElements]` and assigned a new value, which is a nested object. The identifier
    of `myElements` is defined using `arrayFilters` based on a query condition. All
    of the elements that match the given condition are identified by `myElements`,
    which are then updated using `$set`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19: Replacing elements that match given filters'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_06_19.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Replacing elements that match given filters'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'The query condition of `{quantity: null}` is matched by the last element of
    the array and has been updated with the new document.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Updating the Director''s Name'
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On your movie website, people can find movies by their title or by names of
    actors or directors. Your task for this exercise is to connect to update the name
    of one of these directors from `H. C. Potter` to `H. C. Potter (Henry Codman Potter)`,
    so that users don''t confuse him with another director who has a similar name.
    Remember, a movie or a series can be directed by multiple people. The `directors`
    field in your database is an array, and a person from the directors'' team can
    appear at any index position:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This `find` command finds all the movies by the director''s abbreviated name
    and prints the movie title, followed by the director''s name:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Open the mongo shell and connect to the `sample_mflix` database on your Mongo
    Atlas cluster.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As all six movies need to be updated, use the `updateMany()` update function.
    Open any text editor and write the following command:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, use the director''s abbreviated name in the query condition, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command is still incomplete and syntactically invalid. So far, you have
    only added the query condition to the command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the update expression. As you are changing a field here, use the
    `$set` operator in the array field. Also, to change only a specific element in
    an array, use an element identifier:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding (and still incomplete) command, you have added an update expression
    that uses the `$set` operator on the array. Notice that the array element to which
    the `hcPotter` identifier refers is being assigned with the new value—that is,
    `Henry Codman Potter`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have used an element identifier in the update expression, define
    the identifier using `arrayFilters` as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As can be seen from the preceding snippet, you have added an option of `arrayFilters`.
    The identifier of `hcPotter` is given a value of `H.C. Potter`—the value that
    currently exists in the arrays.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的片段中可以看出，您已经添加了`arrayFilters`的选项。`hcPotter`的标识符被赋予了`H.C. Potter`的值，这个值目前存在于数组中。
- en: 'Now, open the mongo shell and connect to the MongoDB Atlas cluster. Use the
    database of `sample_mflix` and execute the preceding command.![Figure 6.20: Updating
    the name of the director'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开mongo shell并连接到MongoDB Atlas集群。使用`sample_mflix`数据库并执行上述命令。![图6.20：更新导演的名字
- en: '](img/B15507_06_20.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_20.jpg)'
- en: 'Figure 6.20: Updating the name of the director'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：更新导演的名字
- en: The output indicates that all six records were found and updated correctly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明所有六条记录都被正确找到和更新了。
- en: 'Now, find the director''s movies with his full name using a regular expression
    in the `directors` field:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用正则表达式在`directors`字段中找到导演的全名电影：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The query uses a regular expression to find the movies of the director according
    to his full name:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查询使用正则表达式根据导演的全名找到电影：
- en: '![Figure 6.21: Output showing the director''s correct name'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.21：显示导演的正确姓名'
- en: '](img/B15507_06_21.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_21.jpg)'
- en: 'Figure 6.21: Output showing the director''s correct name'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：显示导演的正确姓名
- en: The output indicates that you have correctly updated the director's name in
    all the records. In this exercise, you practiced using array filters to modify
    only the matching elements in an array.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明您已正确更新了所有记录中的导演姓名。在这个练习中，您练习了使用数组过滤器来修改数组中的匹配元素。
- en: In this section, we studied how to update array fields in a document. We learned
    to add new elements, remove elements from an array, and update specific elements
    in an array. We also learned how to treat an array as a set and sort existing
    or new elements in an array.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何更新文档中的数组字段。我们学会了添加新元素，从数组中删除元素，并更新数组中的特定元素。我们还学会了如何将数组视为集合，并对数组中的现有或新元素进行排序。
- en: 'Activity 6.01: Adding an Actor''s Name to the Cast'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：向演员阵容中添加演员的名字
- en: 'Recently, an error in the database came to your attention. The actor Nick Robinson
    played the character of `Zach` in the 2015 movie, `Jurassic World`. However, the
    `cast` field in the movie record does not attribute this actor to this movie:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，您注意到了数据库中的一个错误。演员Nick Robinson在2015年的电影《侏罗纪世界》中扮演了`Zach`的角色。然而，电影记录中的`cast`字段没有将这位演员归属于这部电影：
- en: '![Figure 6.22: Showing only casts of the movie'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.22：仅显示电影的演员阵容'
- en: '](img/B15507_06_22.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15507_06_22.jpg)'
- en: 'Figure 6.22: Showing only casts of the movie'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：仅显示电影的演员阵容
- en: 'The output, as shown in the preceding screenshot, confirms that the actor''s
    name is missing. Your task for this activity is to add `Nick Robinson` to the
    cast of this movie and sort this array by actor names. As a best practice, you
    should also ensure that the `cast` array has unique values. The following steps
    will help you to complete this activity:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，输出确认了演员的名字丢失了。您在这个活动中的任务是将`Nick Robinson`添加到这部电影的演员阵容中，并按演员名字对这个数组进行排序。作为最佳实践，您还应确保`cast`数组具有唯一值。以下步骤将帮助您完成这个活动：
- en: Prepare a query expression based on the movie title and add an update expression
    to it. As you have to avoid duplicate insertions, you should treat the array as
    a set by using the `$addToSet` operator.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据电影标题准备一个查询表达式，并向其添加一个更新表达式。由于您必须避免重复插入，因此应使用`$addToSet`运算符将数组视为集合。
- en: Next, you need to sort the array. Since sets are considered to be collections
    of unique and unordered elements, you cannot sort the elements while using `$addToSet`.
    So, first push the element in the array of unique elements.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要对数组进行排序。由于集合被认为是唯一且无序元素的集合，因此在使用`$addToSet`时无法对元素进行排序。因此，首先将唯一元素的元素推入数组。
- en: Lastly, create another update command and sort all the arrays.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建另一个更新命令并对所有数组进行排序。
- en: In this activity, you added unique elements to an array and sorted them. You
    also verified that it isn't possible to add elements to an array as a set and
    sort it at the same time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您向数组添加了唯一元素并对它们进行了排序。您还验证了不可能同时将元素添加到数组中并对其进行排序。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor471).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor471)找到。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by learning how to update documents using aggregation
    pipeline support. Pipeline support, which was introduced in MongoDB version 4.2,
    helps us to perform some complex updates. Using pipeline support, we can write
    multi-stage update expressions, where the output of a stage is provided as input
    to the next stage. It also allows us to use field references and aggregation operators.
    We also learned how to manipulate elements in array fields, how to add, remove,
    and update elements in an array, how to sort an array, and how to add only unique
    elements to an array.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习如何使用聚合管道支持来更新文档来开始本章。聚合管道支持是在MongoDB 4.2版本中引入的，它帮助我们执行一些复杂的更新。使用聚合管道支持，我们可以编写多阶段的更新表达式，其中一个阶段的输出作为下一个阶段的输入。它还允许我们使用字段引用和聚合运算符。我们还学会了如何操作数组字段中的元素，如何向数组中添加、删除和更新元素，如何对数组进行排序，以及如何向数组中添加唯一元素。
- en: In the next chapter, we will learn about MongoDB aggregation framework and pipeline
    in detail.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细学习MongoDB聚合框架和管道。
