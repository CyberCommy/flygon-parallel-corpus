- en: Build a SSR-Based Community Feed Using React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've learned how React applications are typically **Single-Page Applications**
    (**SPAs**) that can be used as a **Progressive Web App** (**PWA**). This means
    the application is rendered client-side, making it load in the browser when the
    user visits your application. But did you know React also supports **Server-Side
    Rendering** (**SSR**), as you might remember from back in the old days when code
    only rendered from a server?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll add declarative routing to a Create React App using
    `react-router` and have components dynamically loaded from the server instead
    of the browser. To enable SSR, the React feature, Suspense, will be used with `ReactDOMServer`.
    If you're interested in **Search Engine Optimization** (**SEO**), this chapter
    will use React Helmet to add metadata to the page so your application can be better
    indexed by search engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-side rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEO in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a PWA with declarative routing using `react-router` that
    supports SSR and therefore is loaded from the server rather than the browser.
    Also, the application is optimized for search engines using React Helmet.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch4-initial](https://github.com/PacktPublishing/React-Projects/tree/ch4-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch4](https://github.com/PacktPublishing/React-Projects/tree/ch4).
    Also, this project uses the publicly available Stack Overflow API to fill the
    application with data. This is done by fetching questions that are posted to Stack
    Overflow. More information about this API can be found at: [https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true](https://api.stackexchange.com/docs/questions#order=desc&sort=hot&tagged=reactjs&filter=default&site=stackoverflow&run=true).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the initial project from GitHub, you need to move into the
    root directory for this project and run `npm install`. As this project is built
    on top of Create React App, running this command will install `react`, `react-dom`, and `react-scripts`.
    Also, `styled-components` is used to handle the styling of all of the components
    in the application. When the installation process has finished, you can execute
    the `npm` command start to be able to visit the project in the browser at `http://localhost:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: As the project is set up as a PWA, the service workers are registered to make
    it possible to visit the application even when there is no internet connection.
    You can check this by running `npm run build` first and `serve -s build` once
    the build process is completed. The build version of the application can now be
    visited at `http://localhost:5000`. As mentioned in a previous chapter, you can
    check whether the application is still available when there is no internet connection
    by visiting the Application tab in the Developer Tools of your browser. Inside
    this tab, you can find Service Workers in the menu on the left; after clicking
    this link, you can select the Offline checkbox on the page that appears.
  prefs: []
  type: TYPE_NORMAL
- en: You may see a different application than when you ran the project locally if
    you've built and served a Create React App PWA before. You can delete any previous
    application from the browser cache by opening the browser's Developer Tools and
    open the Application tab where you can click on the Clear site data button on
    the Clear Storage section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial application that is available at `http://localhost:3000` consists
    of a simple header and a list of cards—as seen in the following screenshot. These
    cards have a title and meta information such as view count, answer count, and
    information about the user who asked this question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea99accb-4a72-4c9c-852e-7cce404f51c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the project''s structure, it uses the same structure as the
    projects you''ve created before. The entry point of this application is a file
    called `src/index.js`, which renders a container component called `App` that contains
    the `Header` and `Feed` components. The `Header` component only displays the title
    of the project, while `Feed` is a class component that has life cycle methods,
    calls the Stack Overflow API, and renders the `Card` components containing the
    Stack Overflow questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Community feed application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll build a community feed application with declarative
    routing that has SSR enabled. For SEO, a package called React Helmet will be used.
    In this community feed, you can see an overview of recent questions on Stack Overflow
    that have the `reactjs` tag, and click on them to see more information and the
    answers. The starting point will be a project that is created using Create React
    App.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `react-router` package, you can add declarative routing to a React
    application, just by adding components. These components can be divided into three
    types: router components, route matching components, and navigation components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up routing with `react-router` consists of multiple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these components, you need to install the web package of `react-router`,
    called `react-router-dom`, by executing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `react-router-dom`, the next step is to import the routing
    and route matching components from this package in the component that is the entry
    point of your application. In this case, that is the `App` component, which is
    inside the `src/containers` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual routes must be added to the `return` function of this component,
    where all of the route matching components (`Route`) must be wrapped in a routing
    component, `Router`. When your URL matches a route defined in any of the iterations
    of  `Route`, this component will render the JSX component that is added as a `component`
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now visit the project in the browser again at `http://localhost:3000`,
    the `Feed` component showing all the questions will be rendered. Also, if you
    type `http://localhost:3000/feed` in the browser, the `Feed` component will still
    be rendered. This is because the `/` route matches every possible URL, as you
    didn''t define that an exact match should be made. Therefore, add the `exact` attribute to `Route`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, you shouldn't be able to see the `Feed` component being rendered if you
    visit any route other than `/`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want these routes to display, for example, a specific question, you'd
    need to send parameters to a route. How you can do this is shown in the next part
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Routes with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the first route in place, other routes can be added to the router component.
    A logical one is having a route for individual questions, that has an extra parameter
    that specifies which question should be displayed. Therefore, a new container
    component called `Question` must be created, which contains the logic for fetching
    a question from the Stack Overflow API. This component is rendered when the path
    matches `/question/:id`, where `id` stands for the ID of the question that is
    clicked on from the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class component called `Question` in the `src/containers` directory,
    and add a `constructor` and  `render` method to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this route available, you need to import this component inside the
    `App` component and define a route for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now visit `http://localhost:3000/questions/55366474`, the `Loading...` message will
    be displayed as no data fetching is implemented yet. The `Route` component passes
    props to the component that it renders, in this case, `Question`; these props
    are `match`, `location`, and `history`.  You can see this by opening the React
    Developer Tools and searching for the `Question` component, which will return
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f5161ba8-f886-4949-87e7-0d3e8b2a9492.png)'
  prefs: []
  type: TYPE_IMG
- en: The `match` prop is the most interesting, as this contains the value of the `id` parameter.
    The `location` and `history` props have information about the current and past
    location of your application.
  prefs: []
  type: TYPE_NORMAL
- en: You can also access the `react-router` props by using the `withRouter` **Higher-Order
    Component** (**HOC**), which passes the `match`, `location`, and `history` props to
    the wrapped component each time it renders. That way, you can use methods such
    as `history.goBack` or `history.push` from anywhere in your application. In [Chapter
    3](7d187482-3a85-42f1-a583-77d150c373a4.xhtml), *Build a Dynamic Project Management
    Board with React and Suspense*, you've seen an example of using a HOC; the `withRouter` HOC
    is implemented in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement data fetching on the `Question` component, you need to check for
    the `id` parameter and fetch the corresponding question from the Stack Overflow
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, a `componentDidMount` method should be added to `Question`, which
    fetches the API using this parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The data that is being fetched can then be displayed inside a `Card` component.
    Bear in mind that the Stack Overflow API returns an array instead of a single
    object when making this request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now refresh `http://localhost:3000/questions/55366474`, a `Card` component
    showing information about this specific question is displayed. To be able to navigate
    to this page from the `Feed` component, a `Link` navigation should be added to
    wrap `Card`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might notice when visiting `http://localhost:3000/`, the `Card` components
    are now clickable and link to a new page showing the question you''ve just clicked
    on. The styling for the `Card` components has also changed, as the `Link` navigation
    component is an `a` element; it adds an underline and changes the padding. You
    must make the following changes to fix these styling changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the styling should be restored and you're able to navigate to the question
    routes to view individual questions. But next to parameters, there are other ways
    to use the routes for filtering or pass data to it, which are query strings. These
    are investigated in the next part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Handling query strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to navigate to individual questions is only one piece of the cake
    when you want to add routing a project, and pagination could be another one. 
    For this, it would be a good idea to move the overview of all of the questions
    to another route that is called `/questions`. To do this, you need to add another
    `Route` that refers to the `Feed` component within `Router` in your `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you now visit the project and try clicking on any of the questions,
    you will see both the rendered component and URL haven''t changed. Because of
    the way `react-router` is set up, it will navigate to any route that matches the
    current URL. To solve this problem, you need to add a `Switch` route matching
    component, which works as a switch statement and will render the first `Route` that
    matches the current location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can import `Switch` from the `react-router-dom` package in the `scr/containers/App.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And place this `Switch` within `Router`, where the order of the routes must
    be changed to make sure that, whenever there is an `id` parameter, this route
    will be rendered first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both the `/questions` and `/questions/:id` routes will now return the correct
    component, which is either the `Feed` or `Question` component. With this in place,
    the next step is to add the pagination. If you look at the API response, the object
    that is being returned has a field called `has_more`. If this field has the value
    `true`, which means you can request more questions by adding the `page` query
    string to the API request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try and add this query string to the URL in the browser, by visiting 
    `http://localhost:3000/questions?page=2`. This query string is now available as
    a prop on the `Feed` component in the `location` object under the `search` field,
    which you can see in the output of the React Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa4a5765-277c-4b01-85ff-1d6cfe2a8d1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, `react-router` doesn''t come with a standard solution to easily
    grasp the value of the `location.search` prop. Therefore, you need to install
    the `query-string` package using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This package is created to parse a query string, in this case, `location.search`,
    to an object you can use in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by importing the package in the `Feed` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can parse the value for the `page` query string in the `constructor` method,
    and add this parsed value to `state`. Make sure to use the JavaScript `parseInt` function,
    so the page will become an integer and not a string. If there is no page query
    string available, it''s assumed you''re visiting the first page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And if there is a value for the `page` query string in `state`, you can send
    this to the API to get the questions for the page number you specify:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can test whether this is working by changing the query string for `page`
    with different numbers, such as `http://localhost:3000/questions?page=1` or `http://localhost:3000/questions?page=3`.
    To make the application more user-friendly, let's add pagination buttons to the
    bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `PaginationBar` component, which holds two `Button` components that
    are styled `Link` components from `react-router`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add these to the bottom of `FeedWrapper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These `PaginationLink` components should link to somewhere for the user to
    be able to navigate to different pages. For this, the current URL can be taken
    from the `match` prop and the current page number is available in `state`. Be
    aware that the previous button should only be shown when the page number is above
    1, and the next button only when the API response indicates that there are more
    results than the ones that are returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, if you now try and click on the next (or previous) button the URL will
    change, the questions that are being displayed don't change. By using the `componentDidMount` method,
    the API will only be called after your application mounts for the first time.
    To watch for any changes to `props` or `state` when your application is already
    mounted, you need to use another life cycle method called `componentDidUpdate`.
    This method can watch for changes to `props` or `state`, as it can access the
    values of `props` and `state` before they were updated. They are scoped within
    the `componendDidUpdate` method as the `prevProps` and `prevState` parameters,
    which you can compare to check whether you need to fetch the API again when any
    `props` or `state` have changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in achieving this is creating a function that fetches the API
    and that can also be used outside of the `componentDidMount` method. This function
    should take the `page` number as a parameter, so it can fetch the correct page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating this function, it can be called in the `componentDidMount` method,
    which no longer needs to be an asynchronous function as this is already handled
    by the new `fetchAPI` function. Therefore, the method can be deleted and replaced
    by the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly after the `componentDidMount` method, you need to add the new `componentDidUpdate` life
    cycle method. As mentioned before, this can take `prevProps` and `prevState` as
    parameters, but as navigating to a new URL only changes `props`, the prior is
    used. Here, you need to check whether the query strings have changed. If they
    have changed, you need to update `state` with the new parsed value for the `page` query
    string and call the `fetchAPI` function to get the results for this page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When using the `componentDidUpdate` life cycle method, you should always make
    sure to compare either `prevProps` or `prevState` to the current `props` or `state`.
    The `componentDidUpdate` method is invoked continuously and when you don't compare
    any values, you could end up with an infinite loop that crashes your application.
  prefs: []
  type: TYPE_NORMAL
- en: You have now implemented the parsing of the query string to dynamically change
    the route for your application. In the next section, you'll explore another thing
    you can do with React, which is SRR that enables you to serve your application
    from the server instead of rendering it in runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Enable SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using SSR can be helpful if you're building an application that needs to render
    very quickly or when you want certain information to be loaded before the web
    page is visible. Although most search engines are now able to render SPA, this
    can still be an improvement if you want users to share your page on social media.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an express server with react-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no standard pattern to enable SSR for your React application, but
    the starting point is to create a Node.js server that''s serving the entry for
    running the build version for your application. For this, you''ll use a minimal
    API framework for Node.js called `express`. Also, the packets that you''ve already
    used, such as `react-router` and `styled-components`, can work with SSR as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start by installing `express` by running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you must create a new directory called `server` in the projects'' root
    directory and place a new file called `server.js` inside. In this file, you can
    place the following code block to import packages you need to run the Node.js
    server, `react`, and `react-dom/server`—which is used to render your application
    from a server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Directly below these imports, you need to import the entry point of the application
    that should be rendered by the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After having defined the entry point, the code to set up the Node.js server
    with `express` and have it listen to all of the endpoints on the server can be
    added. First, you need to set a port on which `express` will be running, after
    which, you define that all of the routes matching the `/*` wildcard should return
    a static version of your application that is being rendered by `ReactDOMServer`
    as a string. That is done by getting the contents of the `index.html` build file
    and replacing the `<div id="root"></div>` tags with new tags that contain the
    server-rendered version of the `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And have this `express` server listen to the `8080` port you''ve defined, by
    adding this code block to the bottom of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to change the way your `App` component is rendered from the
    entry point of the application in `src/index.js`. In this file, `ReactDOM.render` needs
    to be replaced by `ReactDOM.hydrate` as the Node.js server tries to change the
    markup of the `index.html` build file by injecting the server-rendered version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this Node.js server isn''t able to use any of the webpack configuration
    that is being used by your React application, as its code isn''t placed in the
    `src` directory. To be able to run this Node.js server, you need to configure
    Babel for the `server` directory and install some of the Babel packages. This
    is something you''ve done before in the first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Babel packages that should be installed are `@babel/polyfill`, which compiles
    functions such as `async`/`await`; `@babel/register` to tell Babel it should transform
    files with the `.js` extension; and `@babel/preset-env` and `@babel/preset-react`
    to configure Babel to work with React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new file called `index.js` inside the `server` directory, you can now
    require these packages and have this file serve as an entry point to the `server.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to run the `server/index.js` file with Node.js, by executing
    the `node server/index.js` command. So, let''s make a shortcut for this command
    in `package.json` within the scripts field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the `npm run ssr` command, you should always execute `npm run
    build` before as the Node.js server is using the build version. If you run the
    `npm run ssr` command now, though, you will receive an error saying `BrowserRouter
    needs to a DOM to render`. Because of the way `react-router` is set up, you need
    to use the `StaticRouter` component when using SSR instead of `BrowserRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is running client-side (using `npm start`), it will still
    need to use `BrowserRouter`, so therefore the wrapping of the `Route` components
    should be moved from `App` to the `src/index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, it''s deleted from the `App` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the Node.js server to now use the `StaticRouter` component from `react-router`,
    you need to add this in `server/index.js` and wrap the `App` component that is
    being rendered by `ReactDOMServer` with `StaticRouter`. For `react-router` to
    know which route to load, you must pass the current URL as a `location` prop,
    and (in this case) an empty `context` prop as `StaticRouter` should always have
    this to handle redirects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this last step done, you can go and execute `npm run build` again. After
    the build has finished, you can start the Node.js server by running `npm run ssr`
    to view your server-rendered React application on `http://localhost:8080`. This
    application looks the same, as SSR doesn't change anything to the appearance of
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of SSR is that your application can be discovered by search
    engines more effectively. In the next part of this section, you'll add the tags
    that make your application discoverable by these engines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding head tags using React Helmet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you want your application to be indexed by search engines, you need
    to set head tags for the crawlers to identify the content on your page. This is
    something you want to do dynamically for each route route, as each route will
    have different content. A popular package for setting these head tags in React
    applications is React Helmet, which has support for SSR. You can install React
    Helmet with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'React Helmet can define the head tags in any component that is rendered by
    your application, and if nested, the lowest definition of a `Helmet` component
    in the component tree will be used. That''s why you can create a `Helmet` component
    in your `Header` component for all routes and in each of the components that are
    being rendered on a route, you can overwrite these tags:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `react-helmet` package in the `src/components/App/Header.js` file,
    and create a `Helmet` component that sets `title` and meta `description`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create a `Helmet` component in `src/containers/Feed.js` that only sets
    a title for this route, so it will use the meta `description` of `Header`. This
    component is placed within Fragments before the `Alert` component as this is available
    when the application first renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for the `src/containers/Question.js` file, where you can also take
    the ID of the question from the `match` props to make the page title more dynamic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'These head tags will now be used when you''re running your application client-side
    by executing the `npm start` command. But to support SSR, React Helmet should
    also be configured on the Node.js server. For this, you can use the `Helmet.renderStatic` method,
    which transforms the `Helmet` components in your code the same way as `ReactDOMserver.renderToString` does
    for other components. Open the `server/server.js` file and add the following lines
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'On one of the last lines of this file, you''ve now defined that the `<meta
    name="helmet" />` element should be replaced by the `title` and `meta` tags created
    by React Helmet. To make it possible to replace this element with these tags,
    add this element to `index.html` in the `public` directory. Also, you must delete
    the `title` element that is already being created by React Helmet now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With these last changes, you can now run `npm run build` again to create a new
    build version of your application. After this process has finished, you execute
    the `npm run ssr` command to start the Node.js server and visit your React SSR
    application in the browser on `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've added dynamic routing to a Create React App using `react-router`,
    making it possible for users to open your application on a specific page. By using
    the React feature Suspense, components are loaded dynamically on the client-side.
    This way, you lower the amount of time before your user first gets in contact
    with your application. The project you created in this chapter also supports SSR,
    and React Helmet is used to add dynamic head tags to the application for SEO purposes.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you must already feel like an expert with React!
    The next chapter will for sure take your skill to the next level as you'll learn
    how to handle state management using the context API. With the context API, you
    can share state and data between multiple components in your application, no matter
    whether they're direct children of the parent component or not.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Helmet: [https://github.com/nfl/react-helmet](https://github.com/nfl/react-helmet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactDOMServer: [https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
