- en: Building Microservices in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, since you understand what microservices are and, hopefully, have a sense
    of their key benefits, I'm sure you are eager to begin building them. In this
    chapter, we will immediately start writing REST APIs, which collectively work
    as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first understand a few concepts of Python, which we will use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module basically allows you to logically organize your programming code. It
    is similar to any other Python program. They are needed in scenarios where we
    need only a bit of code to be imported instead of the entire program. A **module**
    can be a combination of one or multiple functions classes, and many more. We will
    use a couple of inbuilt functions, which are a part of the Python library. Also,
    wherever needed, we will create our own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code showcases the structure of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can import the preceding module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function is a block of organized, self-contained programs that perform a
    specific task, which you can incorporate into your own larger programs. They are
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These are a few points to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Indentation is very important in Python programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, parameters have a positional behavior, and you need to inform them
    in the same order that they were defined in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please see the following code snippet example, which showcases functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the preceding function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the execution of the preceding `display` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if you have more than one Python version installed on your system,
    you need to use Python 3 instead of Python, which uses the default version of
    Python (generally, 2.7.x).
  prefs: []
  type: TYPE_NORMAL
- en: Modeling microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will develop a full-fledged working web app that works independently.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since we have a basic understanding of Python, let's get started with modeling
    our microservices and understanding the application workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the microservices architecture and application
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we will use Flask as a web framework to build our microservices.
    **Flask** is a powerful web framework, which is easy to learn and simple to use.
    Additionally, in Flask, we need a little boilerplate code to get a simple app
    up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will create our application using the twelve-factor app concept, we
    will begin by ensuring that we have a centralized code base. By now, you should
    know how to create a GitHub repository. If not, make sure you create it as per
    the blogpost link provided in [Chapter 1](part0023.html#LTSU0-4022ecb0f8ea4b719ffb742bf2a6a072),
    *Introducing Cloud Native Architecture and Microservices*. We will be pushing
    the code regularly to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have created the repository during the course of this book, we
    will use the GitHub repository ([https://github.com/PacktPublishing/Cloud-Native-Python.git](https://github.com/PacktPublishing/Cloud-Native-Python.git)).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s set up our local directory in sync with the remote repository. To
    ensure that we are in the app directory, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully pushed our first commit to the remote repository; we will
    keep doing so in a similar fashion till we reach a certain milestone in building
    microservices, as well as the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to install a file-based database, such as SQLite version 3, which
    will work as the datastore for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install SQLite 3, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create and use (source) a `virtualenv` environment, which will isolate
    the local app''s environment from the global `site-packages` installations. If
    `virtualenv` is not installed, you can install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create `virtualenv` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the output of the preceding command as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the `virtualenv` setup, currently, we need one dependency in our virtualenv
    environment that needs to be installed. Use the following command to add one package
    dependency into `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the future, if any more dependencies are needed as part of the application,
    they will go inside the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the requirements file to install the dependencies into the `virtualenv`
    environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the dependencies installed, let''s create a file, `app.py`,
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the basic structure to run an application using Flask.
    It basically initializes the `Flask` variable and runs on port `5000`, which is
    accessible from anywhere (`0.0.0.0`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's test the preceding code and see if everything is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the output of the preceding command as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point in time, before we start building RESTful APIs, we need to decide
    what will be our root URL to access the service, which will further decide the
    sub URI for the different methods. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://[hostname]/api/v1/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since, in our case, we will be using a local machine, `hostname` can be `localhost`
    with port, which is, by default, `5000` for a Flask application. So, our root
    URL will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5000/api/v1/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s decide the resources on which different actions will be performed,
    and which will be exposed by this service. In this case, we will create two resources:
    users and tweets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our users and info resource will use the HTTP methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Method** | **URI** | **Actions** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://localhost:5000/api/v1/info` | This responds back with the
    version |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://localhost:5000/api/v1/users` | This responds with the user
    list |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://localhost:5000/api/v1/users/[user_id]` | The response will
    be the user details of the specified `user_id` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `http://localhost:5000/api/v1/users` | This resource will create
    new users in the backend server with values from the object passed |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `http://localhost:5000/api/v1/users` | This resource will delete
    the user with the specified username passed in JSON format |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `http://localhost:5000/api/v1/users/[user_id]` | This resource updates
    the user information of the specific `user_id` based on the JSON object passed
    as part of the API call. |'
  prefs: []
  type: TYPE_TB
- en: Using the client, we will perform actions against resources such as `add`, `remove`,
    `modify`, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: For the scope of this chapter, we will take a file-based database, such as SQLite
    3, which we already installed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go and create our first resource, which is `/api/v1/info`, and show the
    available versions and their release details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that, we need to create an `apirelease` table schema, as defined in
    SQLite 3, which will contain information about the API version release. This can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is created, you can add records into SQLite 3 for our first version
    (`v1`) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the route `/api/v1/info` and function in `app.py`, which will
    basically handle the RESTful call on the `/api/v1/info` route. This is done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added a route and the handle for it, let''s make a RESTful
    call on `http://localhost:5000/api/v1/info`, as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! It works!!
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the `/api/v1/users` resource, which will help us perform various
    actions on the user's records.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a user as having the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is a unique identifier for users (Numeric type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: This is a unique identifier or `handler` for users for authentication
    (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emailid`: This is the user''s email (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: This is the user''s password (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`full_name`: This is the full name of the user (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to create the user''s table schema in SQLite, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building resource user methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's define our `GET` methods for user resources.
  prefs: []
  type: TYPE_NORMAL
- en: GET /api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GET/api/v1/users` method shows the list of all users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the route, we need to define the `list_users()` function,
    which will connect with the database to get you the complete list of users. Add
    the following code to `app.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the route and the handle for it, let''s test check the
    `http://localhost:5000/api/v1/users` URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: GET /api/v1/users/[user_id]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GET/api/v1/users/[user_id]` method shows the user details defined by `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the route for preceding a `GET` request into the `app.py` file
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we call the `list_user(user_id)` route
    into the `list_user(user)` function, which is not yet defined in `app.py`. Let''s
    define it to get the details of the specified user, as follows, in the `app.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve added the `list_user(user_id)` function, let''s test it out
    and see if everything is working fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Oops! It seems the ID is not present; usually, Flask applications respond with
    an HTML message with a `404` error if the ID is not present. Since this is a web
    service application, and we are getting a response in JSON for other APIs, we
    need to write `handler` for the `404` error so that, instead of the HTML response,
    it should respond back in JSON, even for errors. For example, see the following
    code for `404` error handling. Now, the server will respond with proper messages
    which are part of the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Additionally, you can add the `abort` library from Flask, which is basically
    for calling exceptions. Similarly, you can create multiple error handlers for
    different HTTP error codes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `GET` methods are working fine, we will go forward and write the
    `POST` method, which is similar to adding new users to the users list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods to pass the data into the `POST` method, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON**: In this approach, we pass the JSON record in the form of an object
    as part of the request. The RESTful API call would look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Parameterized**: In this approach, we pass the values of the record as parameters,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the JSON method, we provide the input data in the form of `json`, and we
    read it in the same way. On the other hand, in the parameterized method, we provide
    the input data (that is, `username`, and so on) in the form of URL parameters,
    and read data in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the API creation at the backend will vary with the type of API
    call being made.
  prefs: []
  type: TYPE_NORMAL
- en: POST /api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we go with the first approach to the `POST` method. So, let''s
    define our route for the `post` method in `app.py`, and call the function to update
    the user record to the database file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the preceding method, we called the exception with error
    code `400`; let''s write its handler now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to define the `add_user(user)` function, which will update the
    new user record. Let''s define it in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added `handler`, as well as the route for the `POST` method
    of the user, let''s test it by adding a new user using the following API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, validate the user''s list curl, `http://localhost:5000/api/v1/users`,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DELETE /api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `delete` method helps remove a specific record, which is defined by a username.
    We will pass `username` as the JSON object that needs to be deleted from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We have added the route `/handler` for the `DELETE` method for the user
    resource; let''s test it using the following `test` API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, hit the user list API (`curl http://localhost:5000/api/v1/users`) to
    see if the changes have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! User deletion is successful.
  prefs: []
  type: TYPE_NORMAL
- en: PUT /api/v1/users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PUT API basically helps us update a user's record specified by `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a route with the `PUT` method to update the `user` records
    defined in the `app.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s specify the definition of the `upd_user(user)` function, which basically
    updates the information in the database with the check that the user `id` exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have added the API handle for the `PUT` method for the user resource,
    let''s test it out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have defined our resources that are a part of version `v1`. Now, let''s
    define our next version release, `v2`, which will add a tweet resource to our
    microservices. Users who are defined in users resources are allowed to perform
    actions on their tweets. Now, `/api/info` will be shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our tweets resource will use the `HTTP` methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP Method** | **URI** | **Actions** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://localhost:5000/api/v2/tweets` | This retrieves the tweets
    list |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `http://localhost:5000/api/v2/users/[user_id]` | This retrieves a
    tweet that is given a specific ID |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `http://localhost:5000/api/v2/tweets` | This resource will register
    new tweets with the JSON data passed as part of the API call into the backend
    database |'
  prefs: []
  type: TYPE_TB
- en: 'We can define a tweet as having the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: This is the unique identifier for each tweet (Numeric type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: This should exist as a user in the users resources (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: This is the content of the tweet (String type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tweet_time`: (Specify type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define the preceding tweets resource schema in SQLite 3 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Great! The tweets resource schema is ready; let's create our `GET` methods for
    the tweets resource.
  prefs: []
  type: TYPE_NORMAL
- en: Building resource tweets methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be creating APIs for the tweet resource with a different
    method which will help us perform different operations on the backend database
    for tweets.
  prefs: []
  type: TYPE_NORMAL
- en: GET /api/v2/tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method lists all the tweets from all the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `app.py` to add the route for the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now that we''ve added a function to get the complete tweets list, let''s
    test out the preceding code by making a RESTful API call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Currently, we haven't added any tweet, that's why it returned the empty set.
    Let's add a few tweets.
  prefs: []
  type: TYPE_NORMAL
- en: POST /api/v2/tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The POST method adds new tweets by a specified user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `app.py` to add the route for the `POST` method for
    the tweets resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the definition of `add_tweet(user_tweet)` to add tweets by a specified
    user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now that we''ve added the function to add the tweets list to the database,
    let''s test out the preceding code by making a RESTful API call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the output of the preceding API call similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check whether the tweet was added successfully or not by checking the
    tweets status using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have added our first tweet, what if we need to see only a tweet
    with a certain ID? In that case, we go for the `GET` method with `user_id`.
  prefs: []
  type: TYPE_NORMAL
- en: GET /api/v2/tweets/[id]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GET` method lists the tweets made by the specified ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `app.py` to add a route for the `GET` method with
    a specified ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the `list_tweet()` function, which connects to the database,
    gets us the tweets with the specified ID, and responds with the JSON data. This
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve added the function to get a tweet with the specified ID, let''s
    test out the preceding code by making a RESTful API call at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this addition of tweets, we have successfully built the RESTful API that
    collectively works as the microservices needed to access data and perform various
    actions around it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been building the RESTful API and hitting the URL for the root
    URL to see the response and to understand whether the different methods are working
    properly in the backend or not. Since it's new code, everything should be tested
    100% to make sure it works fine in the production environment. In this section,
    we will write the test cases, which should work individually, and also as a system,
    to make sure that the complete backend service is good to go for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of testing, which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: This is basically used to test the functionality of
    a component or a system. We do this test against the functional specification
    of a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-function testing**: This kind of testing is done against the quality
    characteristics of a component, which includes efficiency testing, reliability
    testing, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural testing**: This type of testing is used to test the structure
    of the system. To write test cases, testers are required to have a knowledge of
    the internal implementations of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will write the test cases, specifically, unit test cases,
    against our application. We will write Python code which will run automatically,
    test out all the API calls, and respond back with the test results.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unit test is a piece of code that tests a unit of work or the logical unit
    in the tested system. The following are the characteristics of unit test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated**: They should be executed automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent**: They shouldn''t have any dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent and repeatable**: They should maintain idempotency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainable**: They should be easy enough to understand and update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use a unit testing framework called **nose**. As an alternative, we
    can use docstest (`https://docs.python.org/2/library/doctest.html`) for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s install nose using `pip` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can put it in `requirement.txt`, and use the following command to install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have installed the nose test framework, let''s begin writing the
    initial test cases on a separate file, say, `flask_test.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will test the app and initialize `self.app` with our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our test case to get the response code for `GET` `/api/v1/users`
    and add it to our FlaskappTest class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will test whether we get the response on `/api/v1/users`
    as `200`; if not, it will throw an error and our test will fail. As you can see,
    as this code doesn't have any dependency from any other code, we will call it
    as a unit test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how to run this code? Since we have installed the nose testing framework,
    simply execute the following command from the current working directory of the
    test case file (in this case, `flask_test.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Great! Similarly, let's write more test cases for the RESTful API for the different
    methods of the resources that we created earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GET `/api/v2/tweets` test case is given as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The GET `/api/v1/info` test case is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The POST `/api/v1/users` test case is written like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The PUT `/api/v1/users` test case is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The POST `/api/v1/tweets` test case is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The DELETE `/api/v1/users` test case is given as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can write more test cases based on your thinking to make these
    RESTful APIs more reliable and bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute all of them together and check whether all the tests have passed.
    The following screenshot shows the test result to the `flask_test.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! Now that all our tests have passed, we are good to go for the next
    level of creating web pages around these RESTful API's.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on writing lots of code to build our microservices.
    We basically got an understanding of how the RESTful APIs work. We also saw how
    we can extend these APIs and make sure that we understand the `HTTP` response
    by the response given by these APIs. Moreover, you learned how to write test cases,
    which are most important to ensure that our code works well and is good to go
    for the production environment.
  prefs: []
  type: TYPE_NORMAL
