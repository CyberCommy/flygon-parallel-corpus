- en: '*Chapter 10*: Improving Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 8.x introduces a number of new features that have a positive effect on performance.
    Also, a number of internal improvements, especially in array handling and managing
    object references, lead to a substantive performance increase over earlier PHP
    versions. In addition, many of the PHP 8 best practices covered in this chapter
    lead to greater efficiency and lower memory usage. In this chapter, you'll discover
    how to optimize your PHP 8 code to achieve maximum performance.
  prefs: []
  type: TYPE_NORMAL
- en: PHP 8 includes a technology referred to as weak references. By mastering this
    technology, discussed in the last section of this chapter, your applications will
    use far less memory. By carefully reviewing the material covered in this chapter
    and by studying the code examples, you will be able to write faster and more efficient
    code. Such mastery will vastly improve your standing as a PHP developer and result
    in satisfied customers, as well as improving your career potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the **Just-In-Time** (**JIT**) compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeding up array handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing stable sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using weak references to improve efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: x86_64 based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 gigabyte (GB) free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 kilobits per second (Kbps) or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features*, for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. In this book, we refer to the directory in which
    you stored the sample code for this book as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located here: https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices.
    We can now begin our discussion by having a look at the long-awaited JIT compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the JIT compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 8 introduces the long-awaited **JIT compiler**. This is an important step
    and has important ramifications for the long-term viability of the PHP language.
    Although PHP already had the ability to produce and cache **bytecode**, before
    the introduction of the JIT compiler, PHP did not have the ability to directly
    cache **machine code**.
  prefs: []
  type: TYPE_NORMAL
- en: There have actually been several attempts to add JIT compiler capabilities to
    PHP, dating back to 2011\. The performance boost seen in PHP 7 was a direct result
    of these early efforts. None of the earlier JIT compiler efforts were proposed
    as **RFCs** (**Requests for Comments**) as they didn't significantly improve performance.
    The core team now feels that any further performance gains can now only be achieved
    using JIT. As a side benefit, this opens the possibility of PHP being used as
    a language for non-web environments. Another benefit is that the JIT compiler
    opens the possibility to develop PHP extensions in languages other than C.
  prefs: []
  type: TYPE_NORMAL
- en: It's extremely important to pay close attention to the details given in this
    chapter as proper use of the new JIT compiler has the potential to greatly improve
    the performance of your PHP applications. Before we get into implementation details,
    it's first necessary to explain how PHP executes bytecode without the JIT compiler.
    We'll then show you how the JIT compiler works. After this, you will be in a better
    position to understand the various settings and how they can be fine-tuned to
    produce the best possible performance for your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to how PHP works without the JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering how PHP works without JIT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When PHP is installed on a server (or in a Docker container), in addition to
    the core extensions, the main component installed is actually a **virtual machine**
    (**VM**) often referred to as the **Zend Engine**. This VM operates in a manner
    quite different from virtualization technologies such as *VMware* or *Docker*.
    The Zend Engine is closer in nature to the **Java Virtual Machine** (**JVM**)
    in that it accepts *bytecode* and produces *machine code*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This begs the question: *what is bytecode* and *what is machine code*? Let''s
    have a look at this question now.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bytecode and machine code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Machine code, or **machine language**, is a set of hardware instructions understood
    by the CPU directly. Each piece of machine code is an instruction that causes
    the CPU to perform a specific operation. These low-level operations include moving
    information between registers, moving a given number of bytes in or out of memory,
    adding, subtracting, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Machine code is often rendered somewhat human-readable by using **assembly
    language**. Here is an example of machine code rendered in assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although, for the most part, the commands are not easily understood, you can
    see from the assembly language representation that the instructions include commands
    to compare (`cmp`), move information between registers and/or memory (`mov`),
    and jump to another point in the instruction set (`jmp`).
  prefs: []
  type: TYPE_NORMAL
- en: Bytecode, also called **opcode**, is a greatly reduced symbolic representation
    of the original program code. Bytecode is produced by a parsing process (often
    called the **interpreter**) that breaks human-readable program code into symbols
    known as **tokens**, along with values. Values would be any string, integer, float,
    and Boolean data used in the program code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a fragment of the bytecode produced based upon the example
    code (shown later) used to create a Mandelbrot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Bytecode fragment produced by the PHP parsing process'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16992_Figure_10.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Bytecode fragment produced by the PHP parsing process
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the conventional execution flow of a PHP program.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding conventional PHP program execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a conventional PHP program run cycle, the PHP program code is evaluated and
    broken down into bytecode by an operation known as **parsing**. The bytecode is
    then passed to the Zend Engine, which in turn converts the bytecode into machine
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When PHP is first installed on a server, the installation process kicks in the
    necessary logic that tailors the Zend Engine to the specific CPU and hardware
    (or virtual CPU and hardware) for that particular server. Thus, when you write
    PHP code, you have no awareness of the particulars of the actual CPU that eventually
    runs your code. It is the Zend Engine that provides hardware-specific awareness.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.2*, shown next, illustrates conventional PHP execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Conventional PHP program execution flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16992_Figure_10.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Conventional PHP program execution flow
  prefs: []
  type: TYPE_NORMAL
- en: Although PHP, especially PHP 7, is quite fast, it's still of interest to gain
    additional speed. For this purpose, most installations also enable the PHP **OPcache**
    extension. Let's have a quick look at OPcache before moving on to the JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the operation of PHP OPcache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name implies, the PHP OPcache extension *caches* opcode (bytecode) the
    first time a PHP program is run. On subsequent program runs, the bytecode is drawn
    from the cache, eliminating the parsing phase. This saves a significant amount
    of time and is a highly desirable feature to enable on a production site. The
    PHP OPcache extension is part of the set of core extensions; however, it's not
    enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before enabling this extension, you must first confirm that your version of
    PHP has been compiled with the `--enable-opcache` configure option. You can check
    this by executing the `phpinfo()` command from inside PHP code running on your
    web server. From the command line, enter the `php -i` command. Here is an example
    running `php -i` from the Docker container used for this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, OPcache was included in the configuration for
    this PHP installation. To enable OPcache, add or uncomment the following `php.ini`
    file settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zend_extension=opcache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.enable=1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opcache.enable_cli=1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last setting is optional. It determines whether or not PHP commands executed
    from the command line are also processed by OPcache. Once enabled, there are a
    number of other `php.ini` file settings that affect performance, however, these
    are beyond the scope of this discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on PHP `php.ini` file settings that affect OPcache, have
    a look here: https://www.php.net/manual/en/opcache.configuration.php.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at how the JIT compiler operates, and how it differs from
    OPcache.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering PHP program execution with the JIT compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problem with the current approach is that whether or not the bytecode is
    cached, it''s still necessary for the Zend Engine to convert the bytecode into
    machine code each and every time the program request is made. What the JIT compiler
    offers is the ability to not only compile bytecode into machine code but to *cache
    machine code* as well. The process is facilitated by a tracing mechanism that
    creates traces of requests. The trace allows the JIT compiler to determine which
    blocks of machine code need to be optimized and cached. The execution flow using
    the JIT compiler is summarized in *Figure 10.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – PHP execution flow with the JIT compiler'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16992_Figure_10.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – PHP execution flow with the JIT compiler
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the diagram, the normal execution flow incorporating OPcache
    is still present. The main difference is that a request might invoke a trace,
    causing the program flow to shift immediately to the JIT compiler, effectively
    bypassing not only the parsing process but the Zend Engine as well. Both the JIT
    compiler and the Zend Engine can produce machine code ready for direct execution.
  prefs: []
  type: TYPE_NORMAL
- en: The JIT compiler did not evolve out of thin air. The PHP core team elected to
    port the highly performant and well-tested **DynASM** preprocessing assembler.
    Although DynASM was primarily developed for the JIT compiler used by the **Lua**
    programming language, its design is such that it's perfectly suited to form the
    basis of a JIT compiler for any C-based language (such as PHP!).
  prefs: []
  type: TYPE_NORMAL
- en: Another favorable aspect of the PHP JIT implementation is that it doesn't produce
    any **Intermediate Representation** (**IR**) code. In contrast, the **PyPy VM**
    used to run Python code using JIT compiler technology, has to first produce IR
    code in a **graph structure**, used for flow analysis and optimization, before
    the actual machine code is produced. The DynASM core in the PHP JIT doesn't require
    this extra step, resulting in greater performance than is possible in other interpreted
    programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on DynASM, have a look at this website: https://luajit.org/dynasm.html.
    Here''s an excellent overview of how the PHP 8 JIT operates: https://www.zend.com/blog/exploring-new-php-jit-compiler.
    You can also read the official JIT RFC here: https://wiki.php.net/rfc/jit.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of how the JIT compiler fits into the general flow
    of a PHP program execution cycle, it's time to learn how to enable it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the JIT compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the primary function of the JIT compiler is to cache machine code, it
    operates as an independent part of the OPcache extension. OPcache serves as a
    gateway to both enable JIT functionality as well as to allocate memory to the
    JIT compiler from its own allotment. Therefore, in order to enable the JIT compiler,
    you must first enable OPcache (see the previous section, *Understanding the operation
    of PHP OPcache*).
  prefs: []
  type: TYPE_NORMAL
- en: In order to enable the JIT compiler, you must first confirm that PHP has been
    compiled with the `--enable-opcache-jit` configuration option. You are then in
    a position to enable or disable the JIT compiler by simply assigning a non-zero
    value to the `php.ini` file's `opcache.jit_buffer_size` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Values are specified either as an integer – in which case, the value represents
    the number of bytes; a value of zero (the default), which disables the JIT compiler;
    or you can assign a number followed by any of the following letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`K`: Kilobytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: Megabytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G`: Gigabytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value you specify for the JIT compiler buffer size must be less than the
    memory allocation you assigned to OPcache because the JIT buffer is taken out
    of the OPcache buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that sets the OPcache memory consumption to 256 M and the
    JIT buffer to 64 M. These values can be placed anywhere in the `php.ini` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an idea of how the JIT compiler works, and how it can be enabled,
    it's extremely important that you know how to properly set the tracing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the tracing mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `php.ini` setting `opcache.jit` controls the JIT tracer operation. For
    convenience, one of the following four preset strings can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.jit=disable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completely disables the JIT compiler (regardless of other settings).
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.jit=off`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disables the JIT compiler but (in most cases) you can enable it at runtime using
    `ini_set()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.jit=function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the JIT compiler tracer to function mode. This mode corresponds to the
    **CPU Register Trigger Optimization (CRTO)** digits 1205 (explained next).
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.jit=tracing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the JIT compiler tracer to tracing mode. This mode corresponds to the CRTO
    digits 1254 (explained next). In most cases, this setting gives you the best performance.
  prefs: []
  type: TYPE_NORMAL
- en: '`opcache.jit=on`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an alias for tracing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Relying upon runtime JIT activation is risky and can produce inconsistent application
    behavior. The best practice is to use either the `tracing` or the `function` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four convenience strings actually resolve into a four-digit number. Each
    digit corresponds to a different aspect of the JIT compiler tracer. The four digits
    are not bitmasks unlike other `php.ini` file settings and are specified in this
    order: `CRTO`. Here is a summary of each of the four digits.'
  prefs: []
  type: TYPE_NORMAL
- en: C (CPU opt flags)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first digit represents CPU optimization settings. If you set this digit
    to 0, no CPU optimization takes place. A value of 1 enables the generation of
    **Advanced Vector Extensions** (**AVX**) **instructions**. AVX are extensions
    to the x86 instruction set architecture for microprocessors from Intel and AMD.
    AVX has been supported on Intel and AMD processors since 2011\. AVX2 is available
    on most server-type processors such as Intel Xeon.
  prefs: []
  type: TYPE_NORMAL
- en: R (register allocation)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second digit controls how the JIT compiler deals with **registers**. Registers
    are like RAM, except that they reside directly inside the CPU itself. The CPU
    constantly moves information in and out of registers in order to perform operations
    (for example, adding, subtracting, performing logical AND, OR, and NOT operations,
    and so forth). The options associated with this setting allow you to disable register
    allocation optimization or allow it at either the local or global level.
  prefs: []
  type: TYPE_NORMAL
- en: T (JIT trigger)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third digit dictates when the JIT compiler should trigger. Options include
    having the JIT compiler operate the first time a script is loaded or upon first
    execution. Alternatively, you can instruct the JIT when to compile **hot functions**.
    Hot functions are ones that are called the most frequently. There is also a setting
    that tells JIT to only compile functions marked with the `@jit docblock` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: O (optimization level)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fourth digit corresponds to the optimization level. Options include disabling
    optimization, minimal, and selective. You can also instruct the JIT compiler to
    optimize based upon individual functions, call trees, or the results of inner
    procedure analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete breakdown of the four JIT compiler tracer settings, have a look
    at this documentation reference page: https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the JIT compiler in action.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JIT compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we use a classic benchmark program that produces a **Mandelbrot**.
    This is an excellent test as it''s extremely computation-intensive. The implementation
    we use here is drawn from the implementation code produced by **Dmitry Stogov**,
    one of the PHP core development team members. You can view the original implementation
    here: [https://gist.github.com/dstogov/12323ad13d3240aee8f1](https://gist.github.com/dstogov/12323ad13d3240aee8f1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the Mandelbrot parameters. Especially important is the number
    of iterations (`MAX_LOOPS`). A large number spawns more calculations and slows
    down overall production. We also capture the start time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to facilitate multiple program runs, we add an option to capture a
    command line param, `-n`. If this parameter is present, the Mandelbrot output
    is suppressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We then define a function, `iterate()`, drawn directly from the Mandelbrot implementation
    by Dmitry Stogov. The actual code, not shown here, can be viewed at the URL mentioned
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we produce the ASCII image by running through the X/Y coordinates determined
    by `EDGE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we produce output. If running through a web request, the output is
    wrapped in `<pre>` tags. If the `-n` flag is present, only the elapsed time is
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We first run the program in the PHP 7 Docker container three times using the
    `-n` flag. Here is the result. Please note that the elapsed time was easily over
    10 seconds in the demo Docker container used in conjunction with this book:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We now turn to the PHP 8 Docker container. To start, we adjust the `php.ini`
    file to disable the JIT compiler. Here are the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of running the program three times in PHP 8 using the `-n`
    flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away, you can see a great reason to switch to PHP 8! Even without the
    JIT compiler, PHP 8 was able to perform the same program in a little over 1 second:
    1/10 of the amount of time!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we modify the `php.ini` file settings to use the JIT compiler `function`
    tracer mode. Here are the settings used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run the same program again using the `-n` flag. Here are the results
    running in PHP 8 using the JIT compiler `function` tracer mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! We managed to speed up processing by a factor of 3\. The speed is now
    less than 1/3 of a second! But what happens if we try the recommended JIT compiler
    `tracing` mode? Here are the settings to invoke that mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of our last set of program runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last result, as shown in the output, is truly staggering. Not only can we
    run the same program 10x faster than PHP 8 without the JIT compiler, but we are
    running *100x faster* than PHP 7!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that times will vary depending on the host computer you
    are using to run the Docker containers associated with this book. You will not
    see exactly the same times as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at JIT compiler debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with the JIT compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normal debugging using **XDebug** or other tools will not work effectively when
    using the JIT compiler. Accordingly, the PHP core team added an additional `php.ini`
    file option, `opcache.jit_debug`, which produces additional debugging information.
    In this case, the settings available take the form of bit flags, which means you
    can combine them using bitwise operators such as `AND`, `OR`, `XOR`, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 10.1* summarizes values that can be assigned as an `opcache.jit_debug`
    setting. Please note that the column labeled **Internal Constant** does not show
    PHP predefined constants. These values are internal C code references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – opcache.jit_debug settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_10.1_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – opcache.jit_debug settings
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, if you wish to enable debugging for `ZEND_JIT_DEBUG_ASM`,
    `ZEND_JIT_DEBUG_PERF`, and `ZEND_JIT_DEBUG_EXIT`, you could make the assignment
    in the `php.ini` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to add up the values you wish to set. In this example, we would
    add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1 + 16 + 32768`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You then apply the sum to the `php.ini` setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`opcache.jit_debug=32725`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, alternatively, represent the values using bitwise `OR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`opcache.jit_debug=1|16|32768`'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the debug setting, you are now in a position to debug the JIT compiler
    using tools such as the Linux `perf` command, or Intel `VTune`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a partial example of debug output when running the Mandelbrot test
    program discussed in the previous section. For the purposes of illustration, we
    are using the `php.ini` file setting `opcache.jit_debug=32725`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What the output shows you is machine code rendered in assembly language. If
    you experience problems with your program code when using the JIT compiler, the
    assembly language dump might assist you in locating the source of the error.
  prefs: []
  type: TYPE_NORMAL
- en: However, please be aware that assembly language is not portable, and is completely
    oriented toward the CPU being used. Accordingly, you might have to obtain the
    hardware reference manual for that CPU and look up the assembly language code
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the other `php.ini` file settings that affect the operation
    of the JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering additional JIT compiler settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 10.2* provides a summary of all other `opcache.jit*` settings in the
    `php.ini` file that have not already been covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.2 – Additional opcache.jit* php.ini file settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_10.2_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.2 – Additional opcache.jit* php.ini file settings
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the table, you have a high degree of control over how the
    JIT compiler operates. Collectively, these settings represent thresholds that
    control decisions the JIT compiler makes. These settings, if properly configured,
    allow the JIT compiler to ignore infrequently used loops and function calls. We'll
    now leave the exciting world of the JIT compiler and have a look at how to improve
    array performance.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up array handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are a vital part of any PHP program. Indeed, dealing with arrays is unavoidable
    as much of the real-world data your program handles day to day arrives in the
    form of an array. One example is data from an HTML form posting. The data ends
    up in either `$_GET` or `$_POST` as an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll introduce you to a little-known class included with
    the SPL: the `SplFixedArray` class. Migrating your data from a standard array
    over to a `SplFixedArray` instance will not only improve performance but requires
    significantly less memory as well. Learning how to take advantage of the techniques
    covered in this chapter can have a substantial impact on the speed and efficiency
    of any program code currently using arrays with a massive amount of data.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with SplFixedArray in PHP 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SplFixedArray` class, introduced in PHP 5.3, is literally an object that
    acts like an array. Unlike `ArrayObject`, however, this class requires you to
    place a hard limit on the array size, and only allows integer indices. The reason
    why you might want to use `SplFixedArray` rather than `ArrayObject` is `SplFixedArray`
    takes significantly less memory and is highly performant. In fact, `SplFixedArray`
    actually takes *less memory* than a standard array with the same data!
  prefs: []
  type: TYPE_NORMAL
- en: Comparing SplFixedArray with array and ArrayObject
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simple benchmark program illustrates the differences between a standard array,
    `ArrayObject`, and `SplFixedArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a couple of constants used later in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a function that adds 1 million elements comprised of a string
    64 bytes long:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call the function three times, supplying `array`, `ArrayObject`, and
    `SplFixedArray` respectively as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results from our PHP 7.1 Docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the amount of time taken is significantly less, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the results, PHP 8 handles arrays 10 times faster than PHP
    7.1\. The amount of memory used is identical between the two versions. What stands
    out, using either version of PHP, is that `SplFixedArray` uses significantly less
    memory than either a standard array or `ArrayObject`. Let's now have a look at
    how `SplFixedArray` usage has changed in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SplFixedArray changes in PHP 8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might recall a brief discussion on the `Traversable` interface in [*Chapter
    7*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162), *Avoiding Traps When Using
    PHP 8 Extensions*, in the *Traversable to IteratorAggregate migration* section.
    The same considerations brought out in that section also apply to `SplFixedArray`.
    Although `SplFixedArray` does not implement `Traversable`, it does implement `Iterator`,
    which in turn extends `Traversable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, `SplFixedArray` no longer implements `Iterator`. Instead, it implements
    `IteratorAggregate`. The benefit of this change is that `SplFixedArray` in PHP
    8 is faster, more efficient, and also safe to use in nested loops. The downside,
    and also a potential code break, is if you are using `SplFixedArray` along with
    any of these methods: `current()`, `key()`, `next()`, `rewind()`, or `valid()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need access to array navigation methods, you now must use the `SplFixedArray::getIterator()`
    method to access the inner iterator, from which all of the navigation methods
    are available. A simple code example, shown here, illustrates the potential code
    break:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by building an `SplFixedArray` instance from an array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use array navigation methods to iterate through the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, the output is the five words in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, the result is quite different, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get the example working in PHP 8, all you need to do is to use
    the `SplFixedArray::getIterator()` method to access the inner iterator. The remainder
    of the code does not need to be rewritten. Here is the revised code example rewritten
    for PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is now the five words, without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have an idea of how to improve array handling performance, we''ll
    turn our attention to yet another aspect of array performance: sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stable sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing the logic for array sorting, the original PHP developers sacrificed
    stability for speed. At the time, this was considered a reasonable sacrifice.
    However, if complex objects are involved in the sorting process, a **stable sort**
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discuss what stable sort is, and why it's important. If
    you can ensure that data is stably sorted, your application code will produce
    more accurate output, which results in greater customer satisfaction. Before we
    get into the details of how PHP 8 enables stable sorting, we first need to define
    what a stable sort is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding stable sorts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the values of properties used for the purposes of a sort are equal, in
    a *stable sort* the original order of elements is guaranteed. Such a result is
    closer to user expectations. Let''s have a look at a simple dataset and determine
    what would comprise a stable sort. For the sake of illustration, let''s assume
    our dataset includes entries for access time and username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to sort by time, you will note right away that there are duplications
    for `2021-06-01 11:11:11`. If we were to perform a stable sort on this dataset,
    the expected outcome would appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice from the sorted dataset that entries for the duplicate time of
    `2021-06-01 11:11:11` appear in the order they were originally entered. Thus,
    we can say that this result represents a stable sort.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, the same principle should also apply to a sort that retains
    the key/value association. One additional criterion for a stable sort is that
    it should offer no difference in performance compared to an unregulated sort.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on PHP 8 stable sorts, have a look at the official RFC
    here: https://wiki.php.net/rfc/stable_sorting.'
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 8, the core `*sort*()` functions and `ArrayObject::*sort*()` methods
    have been rewritten to achieve a stable sort. Let's have a look at a code example
    that illustrates the issue that may arise in earlier versions of PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Contrasting stable and non-stable sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we wish to sort an array of `Access` instances by time. Each
    `Access` instance has two properties, `$name` and `$time`. The sample dataset
    contains duplicate access times, but with different usernames:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the `Access` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a sample dataset that consists of a CSV file, `/repo/sample_data/access.csv`,
    with 21 rows. Each row represents a different name and access time combination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You will note, scanning the sample data, that all of the dates that have `11:11:11`
    as an entry time are duplicates, however, you will also note that the original
    order for any given date is always users `Fred`, `Betty`, `Barney`, and `Wilma`.
    Additionally, note that for dates with a time of `03:33:33`, entries for `Betty`
    always precede `Barney`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a calling program. The first thing to do in this program is
    to configure autoloading and `use` the `Access` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load the sample data into the `$access` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then execute `usort()`. Note that the user-defined callback function performs
    a comparison of the `time` properties of each instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we loop through the newly sorted array and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, note that although the times are in order, the names do not reflect
    the expected order `Fred`, `Betty`, `Barney`, and `Wilma`. Here is the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, in the first set of `11:11:11` dates, the final
    order is `Fred`, `Wilma`, `Betty`, and `Barney`, whereas the original order of
    entry was `Fred`, `Betty`, `Barney`, and `Wilma`. You'll also notice that for
    the date and time `2021-06-13 03:33:33`, `Barney` precedes `Betty` whereas the
    original order of entry is the reverse. According to our definition, PHP 7 does
    not implement a stable sort!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the same code example running in PHP 8\. Here is
    the PHP 8 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the PHP 8 output, for all of the `11:11:11` entries, the
    original order of entry `Fred`, `Betty`, `Barney`, and `Wilma` is respected. You'll
    also notice that for the date and time `2021-06-13 03:33:33`, `Betty` precedes
    `Barney` consistently. Thus, we can conclude that PHP 8 performs a stable sort.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can see the issue in PHP 7, and are now aware that PHP 8 addresses
    and resolves this issue, let's have a look at the effect on keys in stable sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the effect of stable sorting on keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of stable sorting also affects key/value pairs when using `asort()`,
    `uasort()`, or the equivalent `ArrayIterator` methods. In the example shown next,
    `ArrayIterator` is populated with 20 elements, every other element being a duplicate.
    The key is a hexadecimal number that increments sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a function to produce random 3-letter combinations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we load an `ArrayIterator` instance with sample data. Every other element
    is a duplicate. We also capture the starting time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We then perform `ArrayIterator::asort()` and display the resulting order along
    with the elapsed time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of this code example running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, although the values are in order, in the case
    of duplicate values, the keys appear in chaotic order. In contrast, have a look
    at the output from the same program code running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the keys for any duplicate entries appear in the output
    in their original order. The output demonstrates that PHP 8 implements stable
    sorting for not only values but for keys as well. Further, as the elapsed time
    results show, PHP 8 has managed to retain the same (or better) performance as
    before. Let''s now turn our attention to another difference in PHP 8 that directly
    affects array sorting: the handling of illegal sort functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling illegal sort functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP 7 and earlier allows developers to get away with an **illegal function**
    when using `usort()` or `uasort()` (or the equivalent `ArrayIterator` methods).
    It's extremely important for you to be aware of this bad practice. Otherwise,
    when you migrate your code to PHP 8, a potential backward-compatibility break
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown next, the same array is created as in the example described
    in the *Contrasting stable and non-stable sorting* section. The *illegal* sort
    function returns a Boolean value, whereas the `u*sort()` callback needs to return
    the *relative position* between the two elements. In literal terms, the user-defined
    function, or callback, needs to return `-1` if the first operand is less than
    the second, `0` if equal, and `1` if the first operand is greater than the second.
    If we rewrite the line of code the defines the `usort()` callback, an illegal
    function might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, instead of using the spaceship operator (`<=>`), which
    would return `-1`, `0`, or `1`, we use a less-than symbol (`<`). In PHP 7 and
    below, a callback that returns a boolean return value is acceptable and produces
    the desired results. But what actually happens is that the PHP interpreter needs
    to add an additional operation to make up the missing operation. Thus, if the
    callback only performs this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op1 > op2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP interpreter adds an additional operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`op1 <= op2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, illegal sort functions spawn a deprecation notice. Here is the rewritten
    code running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, PHP 8 allows the operation to continue, and
    the results are consistent when using the proper callback. However, you can also
    see that a `Deprecation` notice is issued.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the arrow function in PHP 8\. The callback shown previously
    might be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`usort($array, fn($a, $b) => $a <=> $b)`.'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a greater understanding of what a stable sort is, and why it's
    important. You also are able to spot potential problems due to differences in
    handling between PHP 8 and earlier versions. We'll now have a look at other performance
    improvements introduced in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Using weak references to improve efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As PHP continues to grow and mature, more and more developers are turning to
    PHP frameworks to facilitate rapid application development. A necessary by-product
    of this practice, however, is ever larger and more complex objects occupying memory.
    Large objects that contain many properties, other objects, or sizeable arrays
    are often referred to as **expensive objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Compounding the potential memory issues caused by this trend is the fact that
    all PHP object assignments are automatically made by reference. Without references,
    the use of third-party frameworks would become cumbersome in the extreme. When
    you assign an object by reference, however, the object must remain in memory,
    in its entirety, until all references are destroyed. Only then, after unsetting
    or overwriting the object, is it entirely destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 7.4, a potential solution to this problem was introduced in the form
    of weak reference support. PHP 8 expanded upon this new ability by adding a weak
    map class. In this section, you'll learn how this new technology works, and how
    it can prove advantageous to development. Let's first have a look at weak references.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of weak references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Weak references** were first introduced in PHP 7.4, and have been refined
    in PHP 8\. This class serves as a wrapper for object creation that allows the
    developer to use references to objects in such a manner whereby out-of-scope (for
    example, `unset()`) objects are not protected from garbage collection.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of PHP extensions currently residing on [pecl.php.net](http://pecl.php.net)
    that provide support for weak references. Most of the implementations hack into
    the C language structures of the PHP language core, and either overload object
    handlers, or manipulate the stack and various C pointers. The net result, in most
    cases, is a loss of portability and lots of segmentation faults. The PHP 8 implementation
    avoids these problems.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to master the use of PHP 8 weak references if you are working
    on program code that involves large objects and where the program code might run
    for a long time. Before getting into usage details, let's have a look at the class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the WeakReference class definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The formal definition for the `WeakReference` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the class definition is quite simple. The class can be used
    to provide a wrapper around any object. The wrapper makes it easier to completely
    destroy an object without fear there may be a lingering reference causing the
    object to still reside in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the background and nature of weak references, have
    a look here: https://wiki.php.net/rfc/weakrefs. The documentation reference is
    here: [https://www.php.net/manual/en/class.weakreference.php](https://www.php.net/manual/en/class.weakreference.php).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at a simple example to help your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Using weak references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example demonstrates how weak references could be used. You will see in
    this example that when a normal object assignment by reference is made, even if
    the original object is unset, it still remains loaded in memory. On the other
    hand, if you assign the object reference using `WeakReference`, once the original
    object is unset, it''s completely removed from memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define four objects. Note that `$obj2` is a normal reference to `$obj1`,
    whereas `$obj4` is a weak reference to `$obj3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We then display the contents of `$obj2` before and after `$obj1` is unset.
    Because the connection between `$obj1` and `$obj2` is a normal PHP reference,
    `$obj1` remains in memory due to the strong reference created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then do the same for `$obj3` and `$obj4`. Note that we need to use `WeakReference::get()`
    to obtain the associated object. Once `$obj3` is unset, all information pertaining
    to both `$obj3` and `$obj4` is removed from memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from this code example running in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The output tells us an interesting story! The second `var_dump()` operation
    shows us that even though `$obj1` has been unset, it still lives on like a zombie
    because of the strong reference created with `$obj2`. If you are dealing with
    expensive objects and complex application code, in order to free up memory, you'll
    need to first hunt down and destroy all the references before memory is freed!
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you really need the memory, instead of making a direct
    object assignment, which in PHP is automatically by reference, create the reference
    using the `WeakReference::create()` method. A weak reference has all the power
    of a normal reference. The only difference is that if the object it refers to
    is destroyed or goes out of scope, the weak reference is automatically destroyed
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the output, the result of the last `var_dump()` operation
    was `NULL`. This tells us that the object has truly been destroyed. When the main
    object is unset, all of its weak references go away automatically. Now that you
    have an idea of how to use weak references, and the potential problem they solve,
    it's time to take a look at a new class, `WeakMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with WeakMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP 8, a new class, `WeakMap`, has been added that leverages weak reference
    support. The new class is similar to `SplObjectStorage` in functionality. Here
    is the official class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Just like `SplObjectStorage`, this new class appears as an array of objects.
    Because it implements `IteratorAggregate`, you can use the `getIterator()` method,
    to gain access to the inner iterator. Thus, the new class offers not only traditional
    array access, but OOP iterator access as well, the best of both worlds! Before
    getting into the details of how to use `WeakMap`, it's important for you to understand
    typical usage for `SplObjectStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a container class using SplObjectStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A potential use for the `SplObjectStorage` class is to use it to form the basis
    of a **dependency injection** (**DI**) container (also referred to as a **service
    locator** or **inversion of control** container). DI container classes are designed
    to create and hold instances of objects for easy retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we load a container class with an array of expensive objects
    drawn from the `Laminas\Filter\*` classes. We then use the container to sanitize
    sample data, after which we unset the array of filters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a container class based on `SplObjectStorage`. (Later, in
    the next section, we develop another container class that does the same thing
    and is based upon `WeakMap`.) Here is the `UsesSplObjectStorage` class. In the
    `__construct()` method, we attach configured filters to the `SplObjectStorage`
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `get()` method that iterates through the `SplObjectStorage`
    container and returns the filter if found. If not found, a default class that
    simply passes the data straight through is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using a `foreach()` loop to iterate a `SplObjectStorage` instance,
    we return the *value* (`$obj`), not the key. If we're using a `WeakMap` instance,
    on the other hand, we need to return the *key* and not the value!
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a calling program that uses our newly created `UsesSplObjectStorage`
    class to contain the filter set:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define autoloading and use the appropriate classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define an array of sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We then assign filters that are required for all fields (`$required`) and filters
    specific to certain fields (`$added`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we create an array of filter instances, used to populate our service
    container, `UseSplObjectStorage`. Please bear in mind that each filter class carries
    a lot of overhead and can be considered an *expensive* object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We now cycle through the data files using our container class to retrieve filter
    instances. The `filter()` method produces a sanitized value specific to that filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we grab memory statistics to form the basis of comparison between
    `SplObjectStorage` and `WeakMap` usage. We also unset `$filters`, which should
    theoretically release a sizeable amount of memory. We run `gc_collect_cycles()`
    to force the PHP garbage collection process, releasing freed memory back into
    the pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result, running in PHP 8, of the calling program just shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, our container class works perfectly, giving
    us access to any of the stored filter classes. What is also of interest is that
    the memory released following the `unset($filters)` command is `264` bytes: not
    very much!'
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea of the typical usage of the `SplObjectStorage` class. Let's
    now have a look at a potential problem with the `SplObjectStorage` class, and
    how `WeakMap` solves it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of WeakMap over SplObjectStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main problem with `SplObjectStorage` is that when an assigned object gets
    unset or otherwise goes out of scope, it still remains in memory. The reason for
    this is when the object is attached to the `SplObjectStorage` instance, it's done
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: If you're only dealing with a small number of objects, you'll probably not experience
    any serious issues. If you use `SplObjectStorage` and assign a large number of
    expensive objects for storage, this could eventually cause memory leaks in long-running
    programs. If, on the other hand, you use a `WeakMap` instance for storage, garbage
    collection is allowed to remove the object, which in turn frees up memory. When
    you start to integrate `WeakMap` instances into your regular programming practice,
    you end up with more efficient code that takes up much less memory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about `WeakMap`, have a look at the original RFC here:
    https://wiki.php.net/rfc/weak_maps. Also have a look at the documentation: https://www.php.net/weakMap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now rewrite the example from the previous section (`/repo/ch010/php7_weak_map_problem.php`),
    but this time using `WeakMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As described in the previous code example, we define a container class called
    `UsesWeakMap` that holds our expensive filter classes. The main difference between
    this class and the one shown in the previous section is that `UsesWeakMap` uses
    `WeakMap` instead of `SplObjectStorage` for storage. Here is the class setup and
    `__construct()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Another difference between the two classes is that `WeakMap` implements `IteratorAggregate`.
    However, this still allows us to use a simple `foreach()` loop in the `get()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using a `foreach()` loop to iterate a `WeakMap` instance, we
    return the *key* (`$idx`) and not the value!
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a calling program that invokes the autoloader and uses the appropriate
    filter classes. The biggest difference between this calling program and the one
    from the previous section is that we use our new container class that''s based
    upon `WeakMap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous example, we define an array of sample data and assign filters.
    This code is not shown as it's identical to *steps 2* and *3* of the previous
    example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create filter instances in an array that serves as an argument to our
    new container class. We use the array of filters as an argument to create the
    container class instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Finally, exactly as shown in *step 6* from the previous example, we cycle through
    the data and apply filters from the container class. We also collect and display
    memory statistics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the output, running in PHP 8, for the revised program using `WeakMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, overall memory usage is slightly lower. The biggest difference,
    however, is the difference in memory after unsetting `$filters`. In the previous
    example, the difference was `264` bytes. In this example, using `WeakMap` produced
    a difference of `800` bytes. This means that using `WeakMap` has the potential
    to free up more than three times the amount of memory compared with using `SplObjectStorage`!
  prefs: []
  type: TYPE_NORMAL
- en: This ends our discussion of weak references and weak maps. You are now in a
    position to write code that is more efficient and uses less memory. The larger
    the objects being stored, the greater the potential for memory saving.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned not only how the new JIT compiler works, but you
    gained an understanding of the traditional PHP interpret-compile-execute cycle.
    Using PHP 8 and enabling the JIT compiler has the potential to speed up your PHP
    application anywhere from three times faster and up.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you learned what a stable sort is, and how PHP 8 implements
    this vital technology. By mastering the stable sort, your code will produce data
    in a rational manner, resulting in greater customer satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: The section following introduced you to a technique that can vastly improve
    performance and reduce memory consumption by taking advantage of the `SplFixedArray`
    class. After that, you learned about PHP 8 support for weak references as well
    as the new `WeakMap` class. Using the techniques covered in this chapter will
    cause your applications to execute much quicker, run more efficiently, and use
    less memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to perform a successful migration to PHP
    8.
  prefs: []
  type: TYPE_NORMAL
