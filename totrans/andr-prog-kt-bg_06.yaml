- en: Chapter 6. The Android Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will familiarize ourselves with the lifecycle of an Android
    app. The idea that a computer program has a lifecycle might sound strange at first,
    but it will soon make sense.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle is the way that all Android apps interact with the Android OS.
    In the same way that the lifecycle of humans enables them to interact with the
    world around them, we have no choice but to interact with the Android lifecycle
    and we must be prepared to handle numerous unpredictable events if we want our
    apps to survive.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the phases of the lifecycle that an app goes through, from creation
    to destruction, and how this helps us know *where* to put our Kotlin code, depending
    on what we are trying to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The life and times of an Android app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of overriding and the `override` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phases of the Android lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly we need to know and do to code our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lifecycle demonstration app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Android code is structured, and preparation for going deeper into Kotlin
    coding in the next chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start learning about the Android lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The life and times of an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked a bit about the structure of our code; we know that we can write
    classes, and within those classes we have functions, and these functions contain
    our code, which gets things done. We also know that when we want the code within
    a function to run (that is, be **executed**), we **call** that function by using
    its name.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI Designer"),
    *Kotlin, XML, and the UI Designer*, we learned that Android itself calls the `onCreate`
    function just before the app is ready to start. We saw this when we output to
    the logcat window and used the `Toast` class to send a pop-up message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine what happens throughout the lifecycle of every
    app that we write; that is, when it starts, ends, and the stages in between. What
    we will see is that Android interacts with our app on numerous occasions each
    time that it is run.
  prefs: []
  type: TYPE_NORMAL
- en: How Android interacts with our apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android interacts with our apps by calling functions that are contained within
    the `Activity` class. Even if the function is not visible within our Kotlin code,
    it is still being called by Android at the appropriate time. If this doesn't appear
    to make any sense, then read on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever wondered why the `onCreate` function has the unusual `override`
    keyword just before it? Consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we override a function such as `onCreate`, we are saying to Android that
    when you call `onCreate`, please use our overridden version because we have some
    code in it that we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you might remember the unusual-looking first line of code in the
    `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is telling Android to call the original version of `onCreate` before proceeding
    with our overridden version.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many other functions that we can optionally override, and they
    allow us to add our code at appropriate times within the lifecycle of our Android
    app. In the same way that `onCreate` is called just before the app is shown to
    the user, there are also other functions that are called at other times. We haven't
    seen them or overridden them yet, but they are there, they are called, and their
    code executes.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we need to know and understand the functions of *our* app that Android
    calls whenever it wants is because these functions control the very life and death
    of our code. For instance, what if our app allows the user to type an important
    reminder, then, halfway through typing the reminder, their phone rings, our app
    disappears, and the data (that is, the user's important reminder) is gone?
  prefs: []
  type: TYPE_NORMAL
- en: It is vital and, thankfully, quite straightforward to learn when, why, and which
    functions Android will call as part of the lifecycle of our app. We can then understand
    where we need to override functions to add our own code, and where to add the
    real functionality (code) that defines our app.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the Android lifecycle. We can then move on to the ins and outs
    of Kotlin and gain an understanding of exactly where to put the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: A simplified explanation of the Android lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever used an Android device, you have probably noticed that it works
    quite differently to many other operating systems. For example, you can be using
    an app on your device, perhaps checking what people are doing on Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you get an email notification and you tap the notification to read it.
    Halfway through reading the email, you might get a Twitter notification and, because
    you are waiting on important news from someone you follow, you interrupt your
    email reading and change apps to Twitter with a touch.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the tweet, you fancy a game of *Angry Birds*; however, halfway
    through the first fling, you suddenly remember the Facebook post. So, you quit
    *Angry Birds* and tap on the Facebook icon.
  prefs: []
  type: TYPE_NORMAL
- en: You will likely resume Facebook at the exact same point that you left it. Afterward,
    you could then go back to reading the email, decide to reply to the tweet, or
    start an entirely new app.
  prefs: []
  type: TYPE_NORMAL
- en: All this toing and froing takes quite a lot of management on the part of the
    operating system, and is independent from the individual apps themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between, for example, a Windows PC and Android in the context
    of what we have just discussed is notable. With Android, although the user decides
    which app they are using, the OS decides when to close down (or destroy) an application
    and our user's data (such as the hypothetical note) along with it. We need to
    consider this when coding our apps; just because we might write code to do something
    interesting with our user's input doesn't mean that Android will let the code
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle phases demystified
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android system has a number of distinct phasesthat any given app can be
    in. Depending upon the phase, the Android system decides how the app is viewed
    by the user, or whether it is viewed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Android has these phases so that it can decide which app is in current use,
    and can then allocate the correct amount of resources, such as memory and processing
    power, to the app.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, as the user interacts with the device (for example, touches the
    screen), Android must give the details of that interaction to the correct app.
    For instance, a drag-and-release movement in *Angry Birds* means take a shot,
    but in a messaging app, it might mean delete a text message.
  prefs: []
  type: TYPE_NORMAL
- en: We have already raised the issue of when the user quits our app to answer a
    phone call; will they lose their progress, data, or important note?
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a system that, when simplified a little for the purposes of explanation,
    means that every app on an Android device is in one of the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Being created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resuming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being destroyed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of phases will hopefully appear logical. As an example, the user presses
    the Facebook app icon and the app is **being created**; then, it is **started**.
    This is all straightforward so far, but the next phase in the list is **resuming**.
  prefs: []
  type: TYPE_NORMAL
- en: This is not as illogical as it might first appear. If, for a moment, we can
    just accept that the app resumes after it starts, then all will become clear as
    we continue.
  prefs: []
  type: TYPE_NORMAL
- en: After **resuming,** the app is **running**. This is when the Facebook app has
    control of the screen and has the greater share of system memory and processing
    power, and is receiving the details of the user's input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about our example where we switch from the Facebook app to the email
    app?
  prefs: []
  type: TYPE_NORMAL
- en: As we tap to go to read our email, the Facebook app will have entered the **paused**
    phase, followed by the **stopping** phase, and the email app will enter the **being**
    **created** phase, followed by **resuming**, and then **running**.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide to revisit Facebook, as in the previous scenario, the Facebook
    app will probably skip **being created** and go straight to **resume** and then
    be **running** again (most likely at the exact same place that we left it).
  prefs: []
  type: TYPE_NORMAL
- en: Note that at any time, Android can decide to **stop** and then **destroy** an
    app, in which case, when we run the app again, it will need to be **created**
    at the first phase all over again.
  prefs: []
  type: TYPE_NORMAL
- en: So, had the Facebook app been inactive long enough, or perhaps *Angry Birds*
    had needed so many system resources that Android had **destroyed** the Facebook
    app, then our experience of finding the exact post that we were previously reading
    might have been different. The point is that it is within the control of the app
    and how it interacts with the lifecycle to determine the user's experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all this is starting to get confusing, then you will be pleased to know
    that the only reason to mention these phases is due to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You know they exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will occasionally need to interact with them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take things step by step when we do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we handle the lifecycle phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are programming an app, how do we interact with this complexity? The
    good news is that the Android code that was autogenerated when we created our
    first project does most of it for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed, we just don't see the functions that handle this interaction,
    but we do have the opportunity to override them and add our own code to that phase
    ifwe need to.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can get on with learning Kotlin and making Android apps until
    we come to one of the occasional instances where we need to do something in one
    of the phases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our app has more than one activity, they will each have their own lifecycle.
    This doesn't have to complicate things and, overall, it will make things easier
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The following list offers a quick explanation of the functions provided by Android
    to manage the lifecycle phases. To clarify our discussion of lifecycle functions,
    they are listed next to their corresponding phases that we have been discussing.
    However, as you will see, the function names make it clear on their own where
    they fit in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the list, there is also a brief explanation or suggestion for why we might
    use each function to interact during each phase. We will meet most of these functions
    as we progress through the book; we have, of course, already seen `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCreate`: This function is executed when the Activity is *being created*.
    Here, we get everything ready for the app, including the UI (such as calling `setContentView`),
    graphics, and sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStart`: This function is executed when the app is in the *starting* phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onResume`: This function runs after `onStart`, but can also be entered (most
    logically) after our Activity is resuming after being previously paused. We might
    reload the previously saved user data (such as an important note) from when the
    app had been interrupted, perhaps by a phone call or the user running another
    app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause`: This occurs when our app is *pausing*. Here, we might save unsaved
    data (such as the note) that could be reloaded in `onResume`. Activities always
    transition into a paused state when another UI element is displayed on top of
    the current Activity (for example, a pop-up dialog) or when the Activity is about
    to stopped (for example, when the user navigates to a different Activity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onStop`: This relates to the *stopping* phase. This is where we might undo
    everything we did in `onCreate`, such as releasing system resources or writing
    information to a database. If we reach here, the Activity is probably going to
    get destroyed sometime soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroy`: This is when our Activity is finally being *destroyed*. There
    is no turning back at this phase. This is our last chance to dismantle our app
    in an orderly manner. If the Activity reaches this stage, it will need to go through
    the lifecycle phases from the beginning the next time the app is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the likely flows of execution between the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How we handle the lifecycle phases](img/B12806_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All the function descriptions and their related phases should appear straightforward.
    The only real question is: what about the running phase? As you will see when
    we write our code in the other functions and phases, the `onCreate`, `onStart`,
    and `onResume` functions will prepare the app, which then persists, forming the
    running phase. Then, the `onPause`, `onStop`, and `onDestroy` functions will occur
    afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at these lifecycle functions in action with a mini-app. We will
    do so by overriding them all and adding a `Log` message and a `Toast` message
    to each. This will visually demonstrate the phases that our app passes through.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle demo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will do a quick experiment that will help to familiarize
    us with the lifecycle functions that our app uses and give us a chance to play
    around with a bit more Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to start a new project and then we can add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project and choose the **Basic Activity** project template; this
    is because during this project, we will also look at the functions that control
    the app menu and the **Empty Activity** option doesn't generate a menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call it **Lifecycle Demo**. The code is in the download bundle in the `Chapter06/Lifecycle
    Demo` folder, should you wish to refer to it or copy and paste it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep the other settings as they have been in all our example apps so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for Android Studio to generate the project files and then open the `MainActivity.kt`
    file in the code editor (if it is not opened for you by default) by left-clicking
    on the **MainActivity** tab above the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will only need the `MainActivity.kt` file for this demonstration as we will
    not be building a UI.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the lifecycle demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `MainActivity.kt` file, find the `onCreate` function and add two lines
    of code just before the closing curly brace (`}`), which marks the end of the
    `onCreate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you will need to use the *Alt* + *Enter* keyboard combination
    twice to import the classes needed for `Toast` and `Log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the closing curly brace (`}`) of the `onCreate` function, leave one clear
    line and add the following five lifecycle functions and their contained code.
    Note that it doesn''t matter in what order we add our overridden functions; Android
    will call them in the correct order, regardless of the order in which we type
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, let's talk about the code itself. Notice that the function names all
    correspond to the lifecycle functions and their related phases, which we discussed
    earlier in this chapter. Notice that all the function declarations are preceded
    by the `override` keyword. Also, see that the first line of code inside each function
    is `super.on...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following explains exactly what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: Android calls our functions at the various times that we have already discussed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `override` keyword shows that these functions replace or override the original
    version of the function that is provided as part of the Android API. Note that
    we don't see these replaced functions, but they are there, and if we didn't override
    them, these original versions will be called by Android instead of ours.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `super.on...` code, which is the first line of code within each of the overridden
    functions, then calls these original versions. So, we don't simply override these
    original functions in order to add our own code; we also call them, and their
    code is executed too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the eager reader, the `super` keyword is for super-class. We will explore
    function overriding and super-classes more as we progress through this book.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the code that you added will make each of the functions output one
    `Toast` message and one `Log` message. However, the messages that are output vary,
    as can be seen with the text that is in between the double speech marks (`""`).
    The messages that are output will make it clear which function produced them.
  prefs: []
  type: TYPE_NORMAL
- en: Running the lifecycle demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have looked at the code, we can play with our app and learn about
    the lifecycle from what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the app on either a device or an emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Watch the screen of the emulator and you will see the following appear one
    after the other as `Toast` messages: **In onCreate**, **In onStart**, and **In
    onResume**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice the following messages in the logcat window; if there are too many messages,
    remember that you can filter them by setting the **Log level** dropdown to **Info**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now tap the back button on the emulator or the device. Notice that you get
    the following three `Toast` messages in this exact order: **In onPause**, **In
    onStop**, and **In onDestroy**. Verify that we have matching output in the logcat
    window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, run a different app. Perhaps run the Hello World app from [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Android and Kotlin"), *Getting Started with Android
    and Kotlin* (but any app will do), by tapping its icon on the emulator or device
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now try opening the task manager on the emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can refer to [Chapter 3](ch03.html "Chapter 3. Exploring Android Studio
    and the Project Structure"), *Exploring Android Studio and the Project Structure*,
    and the Using the emulator as a real device section for how to do this on the
    emulator if you are unsure.
  prefs: []
  type: TYPE_NORMAL
- en: You should now see all the recently run apps on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the lifecycle demo app and notice that the usual three starting messages
    are shown; this is because our app was previously destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now tap the task manager button again and switch to the Hello Worldapp. Notice
    that this time, only the **In onPause** and **In onStop** messages are shown.
    Verify that we have matching output in the logcat window; this should tell us
    that the app has **not** been destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, again using the task manager button, switch to the lifecycle demo app.
    You will see that only the **In onStart** and **In onResume** messages are shown,
    indicating that `onCreate` was not required to get the app running again. This
    is as expected because the app was not previously destroyed, but merely stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's talk about what we saw when we ran the app.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the lifecycle demo app output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we started the lifecycle demo app for the first time, we saw that the `onCreate`,
    `onStart`, and `onResume` functions were called. Then, when we closed the app
    using the back button, the `onPause`, `onStop`, and `onDestroy` functions were
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we know from our code that the original versions of all these functions
    are also called because we are calling them ourselves with the `super.on...` code,
    which is the first thing we do in each of our overridden functions.
  prefs: []
  type: TYPE_NORMAL
- en: The quirk in our app's behavior came when we used the task manager to switch
    between apps and, when switching away from the lifecycle demo app, it was not
    destroyed and, subsequently, when switching back, it was not necessary to run
    `onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where''s my Toast?**'
  prefs: []
  type: TYPE_NORMAL
- en: The opening three and closing three `Toast` messages are queued by the operating
    system and the functions have already completed by the time they are shown. You
    can verify this by running the experiments again and see that all three starting
    and closing log messages are output before the second `Toast` message is even
    shown. However, the `Toast` messages do reinforce our knowledge about the order,
    if not the timing.
  prefs: []
  type: TYPE_NORMAL
- en: It is entirely possible (but not that likely) that you got slightly different
    results when you followed the preceding steps. What is for sure is that when our
    apps are run on thousands of different devices by millions of different users
    who have different preferences for interacting with their devices, Android will
    be calling the lifecycle functions at unpredictable times.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what happens when the user exits the app by pressing the home button?
    If we open two apps one after the other, and then use the back button to switch
    to the earlier app, will that destroy or just stop the app? What happens when
    the user has a dozen apps in their task manager and the operating system needs
    to destroy some apps that were previously only stopped; will our app be one of
    the victims?
  prefs: []
  type: TYPE_NORMAL
- en: You can, of course, test out all the preceding scenarios on the emulator. But
    the results will only be true for the one time you test it. It is not guaranteed
    that the same behavior will be exhibited every time, and certainly not on every
    different Android device.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, there is some good news; the solution to all of this complexity is
    to follow a few simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your app so that it is ready to run in the `onCreate` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load your user's data in the `onResume` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save your user's data in the `onPause` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tidy up your app and make it a good Android citizen in the `onDestroy` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watch out for a couple of occasions in this book where we might like to use
    `onStart` and `onStop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we follow the preceding rules, we will see that, over the course of the book,
    we can simply stop worrying about the lifecycle and let Android handle it.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more functions that we can override as well; so, let's take
    a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: Some other overridden functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that there are two other autogenerated functions in the
    code of all our projects using the Basic Activity template. They are `onCreateOptionsMenu`
    and `onOptionsItemSelected`. Many Android apps have a pop-up menu, so Android
    Studio generates one by default when using the Basic Activity template, including
    the outline of the code to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the XML that describes the menu in `res/menu/menu_main.xml` from
    the project explorer. The key lines of XML code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This describes a menu **item** with the **Settings** text. If you run any of
    our apps built with the Basic Activity template, you will see the button as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Some other overridden functions](img/B12806_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you tap the button, you can see it in action as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Some other overridden functions](img/B12806_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, how do the `onCreateOptionsMenu` and `onOptionsItemSelected` functions produce
    these results?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onCreateOptionsMenu` function loads the menu from the `menu_main.xml`
    file with this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is called by the default version of the `onCreate` function, which is why
    we don't see it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the pop-up menu in [Chapter 17](ch17.html "Chapter 17. Data Persistence
    and Sharing"), *Data Persistence and Sharing*, to switch between the different
    screens of our app.
  prefs: []
  type: TYPE_NORMAL
- en: The `onOptionsItemSelected` function is called when the user taps on the menu
    button. This function handles what will happen when an item is selected. Now,
    nothing happens; it just returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add `Toast` and `Log` messages to these functions to test out the
    order and timing I have just described.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how the Android lifecycle works and have been introduced
    to a number of overridable functions to interact with this lifecycle, we had better
    learn the fundamentals of Kotlin so that we can write some more useful code to
    go in these functions and write our own functions too.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Kotlin code – revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that each time we create a new Android project, we also
    create a new **package**; this is a kind of container for the code that we write.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about and played around with **classes**. We have imported
    and taken direct advantage of classes from the Android API, such as `Log` and
    `Toast`. We have also used the `AppCompatActivity` class but in a different manner
    to that of `Log` and `Toast`. You might recall that the first line of code in
    all our projects so far, after the `import` statements, used the `:` notation
    to inherit from a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we inherit from a class, as opposed to just importing it, we are making
    it our own. In fact, if you take another look at the line of code, you can see
    that we are making a new class, with a new name, `MainActivity`, but basing it
    on the `AppCompatActivity` class from the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AppCompatActivity` is a modified version of `Activity`. It gives extra features
    for older versions of Android that would otherwise not be present. Everything
    we have discussed about `Activity`, such as the lifecycle, is equally true for
    `AppCompatActivity`. If the name ends in `...Activity`, it doesn''t matter because
    everything we have discussed and will discuss is equally true. I will usually
    just refer to this class simply as `Activity`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize our use of classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can import classes to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can inherit from classes to use them and to extend their functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can eventually make our own classes (and will do so soon)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our own classes, and those that are written by others, are the building blocks
    of our code, and the functions within the classes wrap the functional code – that
    is, the code that does the work.
  prefs: []
  type: TYPE_NORMAL
- en: We can write functions within the classes that we extend as we did with `topClick`
    and `bottomClick` in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI
    Designer"), *Kotlin, XML, and the UI Designer*. Furthermore, we overrode functions
    that are already part of classes written by others, such as `onCreate` and `onPause`.
  prefs: []
  type: TYPE_NORMAL
- en: The only code, however, that we put in these functions was a few calls using
    `Toast` and `Log`. Now we are ready to take some more steps with Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned that it is not only us that can call our code;
    the operating system can also call the code contained within the functions that
    we have overridden. By adding the appropriate code to the various overridden lifecycle
    functions, we can be sure that the right code will be executed at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do now is to learn how to write some more Kotlin code. In the
    next chapter, we will start to focus on Kotlin and, because we have such a good
    grounding already in Android, we will have no problem practicing and using everything
    we learn.
  prefs: []
  type: TYPE_NORMAL
