- en: '*Chapter 5*: React Development with Hooks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about development with React Hooks. We'll compare
    and contrast Hook development with the older class-based style and see why development
    with Hooks is a better way of developing in React. We'll also learn about best
    practices when coding with Hooks so that we can have the best quality code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the limitations of class-style components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about React Hooks and understanding the benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing and contrasting the class-style and the Hooks style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of web development and the SPA style of
    coding. We will once again be using Node and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap5` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the [*Chapter 5*](B15508_05_Final_JC_ePub.xhtml#_idTextAnchor081)
    code folder, go to your `HandsOnTypescript` folder and create a new folder called
    `Chap5`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the limitations and issues with the old class-style components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll review what class-style components are. We'll see why
    inheritance-style code reuse and lifecycle methods, although well intentioned,
    ultimately did not provide good code reuse and component structure capabilities.
    Although we will not write our code with class components, it is very important
    to understand class-based components because most existing React code uses classes,
    since Hooks are still somewhat new. So, as a professional developer, you will
    have to read and maintain this code base until it uses Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the limitations of class-style components, we first need
    to review what they are. A React application is made up of many individual structures
    called components. When using a class-based style, these components are JavaScript
    ES6 classes that inherit from `React.Component`. A component is basically a machine
    that may contain data, called state, and the component will emit HTML via a language
    called JSX based upon changes to this data. Although components can become quite
    complex, at a basic level this is what they are.
  prefs: []
  type: TYPE_NORMAL
- en: A class component usually has state of its own, although this is not a requirement.
    In addition, a class-based component can have child components. Child components
    are simply other React components that have been embedded into the render function
    of a parent component and therefore will be rendered out when the parent is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: A class component must inherit from the `React.Component` object. By doing this,
    it receives all the capabilities of a React component, including the lifecycle
    functions. These functions are event handlers that React provides that allow developers
    to hook into events that occur at specific times during the lifetime of a React
    component. In other words, these functions allow us as developers to inject our
    own code and logic into a React component at the desired time.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We touched upon state in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*,
    Learning Single-Page Application Concepts and How React Enables Them*. Let's dive
    a little deeper before we learn more about React components. React uses JSX to
    render HTML to the browser. However, the thing that triggers these renders is
    component state or, more accurately, any change to component state. So, what is
    component state? In a React class component, there is a single field called `state`.
    This field is an object that can contain any number of properties that describe
    the associated component. Functions should not be applied to state, but you can
    have as many functions as you require as members of your class component.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, changing state causes the React system to re-render your component.
    State changes are what drive renders in React and components contain only the
    UI elements for themselves, which is a good way of maintaining a separation of
    concerns and clean coding practices. State changes in class-based components are
    triggered by the `setState` function. This function takes a parameter that is
    your new state and React will later asynchronously update your state. This means
    the actual state change does not happen immediately but is controlled by the React
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to state there is the ability to share the state of a component
    using props. Props are state properties that have been passed down to child components
    of a component. Just like when state changes, if props change, a re-render on
    the child is also triggered. A re-render of a parent will also trigger a re-render
    to a child. Note that a re-render does not mean the entire UI is updated. The
    reconciliation process will still run and will only change what is needed based
    upon what state has changed and what is already on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following image is a good overview of the lifecycle calls in a class-based
    React component. As you can see, it''s quite complicated. In addition, there are
    also several deprecated functions that are not mentioned in the diagram, such
    as `componentWillReceiveProps`, which have been completely eliminated as they
    were causing issues such as unwanted renders and infinite loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – React class component lifecycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – React class component lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: 'Image source: [http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's review this diagram starting at a high level. First off, you can see we
    have **Mounting**, **Updating**, and **Unmounting**. Mounting is simply the instantiation
    and initialization of a component, and then the addition of the initialized component
    into the virtual React DOM. We discussed the virtual DOM that React uses to reconcile
    components between itself and the real browser DOM in [*Chapter 4*](B15508_04_Final_JC_ePub.xhtml#_idTextAnchor072)*,
    Learning Single-Page Application Concepts and How React Enables Them*. Updating
    refers to re-renders. That is when state changes and the UI must be updated. Unmounting
    is when a component is no longer used and is to be removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll go over the lifecycle methods. Since there are many, let's list them.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Under mounting, we have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Constructor`: This is not a lifecycle method but the built-in class constructor.
    It is traditionally used to initialize state and bind any custom event functions.
    You may recall from [*Chapter 3*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052)*,
    Building Better Apps with ES6+ Features*, `bind` is used to switch the `this`
    object of a function. This is done in the constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDerivedStateFromProps(props, state)`: If you are basing your local state
    on props from a parent you would use this function. This is a static function.
    It should be used sparingly as it triggers additional renders. It can also be
    used in updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render`: This can also run during updating for re-renders. This function is
    what triggers the reconciliation process for React. It should only render out
    JSX, which could also be inside arrays or plain text. If due to state or props
    you decide there is nothing to render you should return `null`. It is possible
    to return a boolean, but outside of testing I see little value in doing this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount`: This function is triggered after a component is finished
    mounting (being initialized). You can place network API calls here. You can also
    add event handler subscriptions here, but you must remember to unsubscribe them
    in the `componentWillUnmount` function or it can cause a memory leak. You can
    call `setState` to change local state data here, but you are then triggering a
    second call to render so it should be used sparingly. `SetState` is used to update
    local state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSAFE` deprecated methods (do not use) are `UNSAFE_componentWillMount`, `UNSAFE_componentWillReceiveProps`,
    and `UNSAFE_componentWillUpdate`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the methods under updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate(nextProps, nextState)`: This is used to decide whether
    a re-render should be done or not. It usually compares the previous props to the
    current props.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSnapshotBeforeUpdate(prevProps, prevState)`: This runs immediately before
    the render to DOM occurs so you can capture the DOM state just before React changes
    it. If you return something from this function, it is given as a parameter to
    the `componentDidUpdate` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate(prevProps, prevState, snapshot)`: This function runs immediately
    after a re-render is complete. You can make changes to the finished DOM here,
    or you can call to `setState`, but you must have a condition so that you do not
    cause an infinite loop error. The snapshot state comes from the `getSnapshotBeforeUpdate`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unmounting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following method is used at this level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`componentWillUnmount`: This is similar to `dispose` functions in languages
    such as C# and can be used to do cleanup work, for example, removing event listeners
    or other subscriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main concern in dealing with any of these lifecycle methods is to prevent
    unnecessary or unwanted re-renders. We must select the one that is less likely
    to trigger unnecessary re-renders, or if we need to use a specific method so our
    code runs at a specific time, we should add prop and state checks in order to
    reduce unneeded re-renders. It is paramount that you get renders until control
    or your user experience will suffer because of a slow and buggy application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over some of the main calls. Let's start with `getDerivedStateFromProps`.
    In general, it is a good idea to avoid using this function, or just use it sparingly.
    From experience, it makes it very difficult to figure out when a component will
    re-render. In general, it tends to trigger unwanted re-renders, which can cause
    unintended behavior that's again difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The React team recommends some alternatives, and we should always prefer these
    as they are almost always easier to reason about and more consistent in behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to trigger behavior based upon a prop value that changed. For
    example, getting network data or triggering some other action. Use `componentDidUpdate`
    instead. It is less likely to trigger an infinite loop as long as you do a check
    before causing anything that changes state. For example, you can use the `prevProps`
    parameter and compare it to your local state values before calling `setState`
    to change your state data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `memoization` technique (note this idea is not a part of React necessarily;
    it's just a programming technique). `Memoization` is basically like caching, except
    instead of having a cache expiration you would use a variable change to update
    the cache. So, in React, this simply means use a property or function that first
    checks whether a props value is different from last time, and only if it is different
    does it trigger a state update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a built-in component wrapper in React called `React.memo`. It will
    trigger a re-render only when a child's props change, not when the parent component
    re-renders.
  prefs: []
  type: TYPE_NORMAL
- en: Make your component fully controlled, which simply means that it will have no
    state of its own and will render under the direction of its parent whenever props
    change or the parent renders. Facebook also recommends using uncontrolled components
    as well by changing their key (a key is a unique identifier for the component),
    which then triggers a re-render. However, I disagree with this suggestion. As
    you recall, we discussed encapsulation and abstraction in [*Chapter 1*](B15508_01_Final_JC_ePub.xhtml#_idTextAnchor017)*,
    Understanding TypeScript*, and this means that the uncontrolled component's behavior
    should be unknown to the parent. This also means that it is not entirely controllable
    by the parent, and it shouldn't be. Therefore to get an uncontrolled component
    to do what the parent wants may make it tempting to add implementation changes
    inside that component, which will then tie it more closely to the parent. At times
    this may be unavoidable, but if it can be avoided it should be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your component's rendered state depends on network data you can use `componentDidMount`
    to make your network call there, and then update state (assuming you need this
    data only once on load). Note `componentDidMount` only runs once on the component's
    first load. Also, if you use this function you will be doing one additional render,
    but that's still better than the potential for causing additional unwanted renders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComponentDidUpdate` can be used to handle scenarios where state needs to change
    due to prop changes. Since this method is called after the render, it is less
    likely to cause infinite render loops as long as you compare your props to state
    before triggering any state changes. Having said that, it is better to avoid derived
    state entirely if at all possible and keep your state in a single parent root
    component and share that state via props. To be honest, this is tedious work as
    you will need to pass down your state via props to children that may be several
    layers deep. It also means you need to structure your state schema well so that
    you can cleanly separate state bound for a specific child. When we use Hooks later,
    you''ll see that this is much easier to do with Hooks than with a single state
    object. Nevertheless, having as little local component state as possible is a
    best practice for React development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a small project where we can try out a class component and discuss
    its features:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch your command line or terminal to the `Chap5` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command within that folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open Visual Studio in the folder you just created, `class-components`,
    and also open a terminal or command line in that same folder. Let''s create a
    new file called `Greeting.tsx` in the `src` folder. It should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we create our class we also need to remember to export it so that it can
    be accessed by whatever component will be using it. This is done with the `React.Component<GreetingProps>`.
    This type declaration is indicating not only that this class is a React component
    but also that it takes a prop of the `GreetingProps` type. Once the declaration
    is set we define the constructor, which takes a prop of the same type, `GreetingProps`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If your component takes props, it is important that the first call you make
    inside the constructor is the call to the base class constructor, `super(props)`.
    This ensures that React is aware of your incoming props and so can react when
    props change (no pun intended). Inside the constructor, we don't need to use `this.props`
    to reference the `props` object since it is being passed in as a constructor parameter.
    Anywhere else, `this.props` is required.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see that `state` is instantiated in `constructor`, and the variable
    and its type are declared in the line below as being the `GreetingState` type.
    Then, finally, we have our `render` function, which declares JSX that will eventually
    be converted into HTML. Notice that the `render` function has a logical `if`/`else`
    statement to show a different UI depending on the value of `this.props.name`.
    `render` functions should try and control the proper UI and not render anything
    when there is no reason to. This can improve performance and memory when done
    consistently. Just return `null` if there is nothing to `render`, as React understands
    this value is indicating not to render anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now all we need to do is update the `App.tsx` file so that it includes our
    `Greeting.tsx` component. Open the `App.tsx` file and update it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `Greeting` component to replace some of the JSX
    that was already there. Notice that we did not pass the `name` property to `Greeting`.
    Let''s see what happens when we run the app. Execute this command in your terminal,
    making sure you are in the `class-components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go to our `App.tsx` file and update `Greeting` to add a `name` value.
    Replace the `Greeting` component inside `App.tsx` with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.3 – Updated screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.3_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Updated screen
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so we''ve created a simple class-based component. Let''s now start making
    use of some of the lifecycle methods and see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `Greeting.tsx` to include the `getDerivedStateFromProps` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is virtually identical except we will now add the `getDerivedStateFromProps`
    function just above the `render` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s leave this code as is for now and update our `App.tsx` file so that
    it can accept an input, which takes the name of the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `onChangeName`, we are then setting the `state` property `enteredName` to
    the value of the user input by using the `setState` function. You must never modify
    state in your class components without using this function or else your state
    will lose synchronization with the React runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have added a `console.log` statement to see when the `App.tsx` `render`
    function is called. Also, we have defined a new `input` control whose value is
    `this.state.enteredName` and its `onChange` event is tied to our `onChangeName`
    function. If you save this code and open the Chrome dev tools, you will see this:![Figure
    5.4 – Rendering Greeting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.4_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Rendering Greeting
  prefs: []
  type: TYPE_NORMAL
- en: You can see our render logging messages and also the `Greeting` `name` prop
    and `message` state values. Additionally, since we did not enter a value in the
    `input`, the `name` prop is blank and therefore the `name` property of our `Greeting`
    component and the end of the `message` string are also blank. You're probably
    wondering why the logs for `Greeting` run twice. It's because we are running in
    StrictMode for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly remove that so we don''t get confused. Go to your `index.tsx`
    file and replace the code with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you save and look at your browser debug console, you will see this:![Figure
    5.5 – Browser debug console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.5_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Browser debug console
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for all this work is to show what specifically can trigger calls
    to render and how we can be more careful about this.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's type our name into the input, and you'll see this:![Figure 5.6 – App.tsx
    input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.6_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – App.tsx input
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is, why does my message end with "Hello from, "? If you look at
    the code in `Greeting`, you can see that we only set the `message` state property
    once during the constructor run (which is effectively like using `componentDidMount`).
    So, since this event runs only once when the screen first loads, at that time
    `this.props.name` is blank as we''ve not entered a value yet. So, what can we
    do? Well, let''s try using the `getDerivedStateFromProps` function and see what
    happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m only showing the `Greeting` class as that''s the only thing I want to
    change for this example. So, in the following code, take a look at the updated
    `getDerivedStateFromProps`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, that function has now become more complex and I am doing a comparison
    against the new prop and our existing state. Then we clone our `state` object.
    It is very important to make sure you do this so that you do not accidentally
    edit your state directly. Then we update the `state.message` value using a new
    static function, `getNewMessage` (since I'm setting the message in multiple places).
    Now let's try adding our name. If you do this, you'll see that our name gets added
    to the message, but also we get a `Greeting` and `App` render for each letter
    we type. Right now this isn't too bad as we don't have much code, but you can
    imagine if we keep adding new properties to our local state on our `Greeting`
    component and we have a much more complex application, things can get very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s refactor this code and see if we can improve things a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `App.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: render() {
  prefs: []
  type: TYPE_NORMAL
- en: console.log("rendering App");
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div className="App">
  prefs: []
  type: TYPE_NORMAL
- en: <header className="App-header">
  prefs: []
  type: TYPE_NORMAL
- en: <img src={logo} className="App-logo" alt="logo"          />
  prefs: []
  type: TYPE_NORMAL
- en: <input value={this.state.enteredName}
  prefs: []
  type: TYPE_NORMAL
- en: onChange={this.onChangeName} />
  prefs: []
  type: TYPE_NORMAL
- en: <Greeting message state property to our Greeting component as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll look at our `Greeting` component, but to keep things clean, let''s
    create a new file called `GreetingFunctional.tsx` and put the following code inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added this file, you''ll also need to update your `App.tsx` file
    import of `Greeting` to refer to this file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Greeting` has been drastically shortened and made simpler.
    It is now a functional component because it is a best practice to make components
    that have no local state to be functions instead of classes. We weren't able to
    reduce the re-renders, since changing the message necessarily triggers a re-render,
    but even this shortening and reducing of code is worth this change. Also, even
    though we moved some code into `App.tsx`, you'll notice that this code is also
    less involved than the code that was in our original `Greeting` component.
  prefs: []
  type: TYPE_NORMAL
- en: There is one issue with this style of component building, where most of the
    state is inside a single parent component and child components get props passed
    down to them, which is that for complex multi-level component hierarchies there
    can be a lot of boilerplate code to pass the props through multiple levels of
    components. It is for these scenarios that we could use React Context to bypass
    the hierarchy and send parent state directly to a child. However, I don't like
    using Context because bypassing the natural component hierarchy to arbitrarily
    inject state to some component feels like an anti-pattern (a design method you
    should not be using). It's bound to cause confusion and make it more difficult
    to refactor code later. I'll get into Context more later in [*Chapter 7*](B15508_07_Final_JC_ePub.xhtml#_idTextAnchor110)*,
    Learning Redux and React Router*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about class-based React components. Since Hooks
    are still relatively new, most existing React apps are still using class-based
    components, therefore having an understanding of this style of coding is still
    important. In the next section, we will explore Hook-based components and then
    later compare the two styles.
  prefs: []
  type: TYPE_NORMAL
- en: Learning React Hooks and understanding how it is an improvement over class-style
    components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about React Hooks. We'll take a look at an example
    project and see how it works. Since this book is primarily about Hooks, at least
    with regard to React, it will help us write our code later.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss some of the reasons for Hooks. We saw in the class components
    section that classes have lifecycle methods that allow you to handle certain events
    that occur while a component is alive. With React Hooks, we don't have those lifecycle
    methods, because with Hooks all components are functional components. We created
    a functional component in the class-components sample app called `GreetingFunctional`
    in the previous section. A functional component is a component that is a JavaScript
    function and returns JSX. The reason for this change is that the entire design
    is attempting to move away from **Object Oriented Programming** (**OOP**) inheritance
    models and instead use composition as its primary code reuse model. We covered
    OOP inheritance models in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025)*,
    Exploring TypeScript*, but composition means that instead of receiving functionality
    as an inheritance from some parent class we are simply combining functional components,
    sort of like Lego pieces, to design our screens.
  prefs: []
  type: TYPE_NORMAL
- en: Along with these functional components we have Hooks. Hooks are just JavaScript
    functions that provide certain capabilities to the component. These include the
    creation of state, access to network data, and just about anything else a component
    needs. Additionally, Hooks are not component specific, and therefore any Hook
    can be used in any component—assuming it's useful and makes sense. If you look
    back at our class-component project, you will see that there's really no way of
    sharing the logic in our lifecycle event methods. We cannot easily extract it
    out and then reuse it in some other class component. This is one of the primary
    reasons for the creation of the Hooks model in React. Therefore, these two pieces,
    functional components and reusable functions (Hooks), are the key to understanding
    React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s list some of the more important Hooks that we will be using
    in our code. We will give examples of their use in code soon, but for now, we''ll
    discuss them at a high level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useState`: This function is the bread and butter of development with Hooks.
    It replaces the `state` and `setState` calls within class components. `useState`
    takes a value as a parameter that represents the initial state of the state property
    it is trying to represent. It also returns an array. The first item is the actual
    state property and the second is a function that can update that property. In
    general, it is used to update a single value, as opposed to a more complex object
    that has multiple properties. A better Hook for that type of state may be `useReducer`,
    which is explained later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect`: This function triggers after components have finished being drawn
    on the screen. It is similar to `componentDidMount` and `componentDidUpdate`.
    However, they run before drawing onto the screen happens. It is intended to be
    used to update state objects. So if, for example, you need to get network data
    and then update state, you can do it here. You can also subscribe to events here,
    but you should also unsubscribe by returning a function that does the unsubscribing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have multiple separate implementations of `useEffect`, each responsible
    for doing something unique. This function usually runs after every completed screen
    draw. So, if any component state or props change, this will run. You can force
    it to run only once, like `componentDidMount`, by passing an empty array as a
    parameter. You can also force it to run only when specific props or state changes
    by passing those as arrays into the `useEffect` array parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This function runs asynchronously, but if you need to know some element values
    on the screen, such as scroll position, you may need to use `useLayoutEffect`.
    This function runs synchronously, allowing you to get certain element values as
    they currently are on the screen and then do something with them in a synchronous
    manner. But, of course, this blocks your UI, so you need to only do things that
    are very fast or the user experience will suffer.
  prefs: []
  type: TYPE_NORMAL
- en: '`useCallback`: This function will create an instance of a function once a set
    of parameters has been changed. This function exists to try and save memory, because
    otherwise an instance of the function would be recreated on each render. It takes
    a handler function as its first parameter and then an array of items that may
    change as its second. If the items don''t change, the callback doesn''t get a
    new instance. Therefore any properties used inside this function will be the prior
    values. When I first learned about this function, I found it difficult to understand,
    so I''ll give an example of it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useMemo`: This function is intended to save the result of a long-running task.
    It''s a bit like caching, but it only runs if the array of parameters has changed,
    so in this sense it''s similar to `useCallback`. However, `useMemo` returns a
    value that is the result of some heavy computation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useReducer`: This function works similarly to `React Redux`. It takes two
    parameters, `reducer` and `initial state`, and returns two objects: a `state`
    object that will be updated by the `reducer` and a dispatcher that receives updated
    state data, called an `action`, and passes it to the `reducer`. The `reducer`
    acts as a filtering mechanism and determines how action data will be used to update
    the state. We will show an example later in code. This method works well when
    you want to have a single complex state object with multiple properties that may
    need to be updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useContext`: This function is a way of having global state data that can be
    shared across components. It is better to use it sparingly as it gives the ability
    to arbitrarily inject state into any child without regard to hierarchy. We will
    use `React Redux` rather than `Context`, but it is good to know it exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useRef`: This can be used to hold any value in its current property. This
    value does not trigger a re-render if it changes, and the value lives as long
    as the component it was created in lives. It''s a way of holding state that has
    no effect on renders. One of its use cases is to hold a DOM element. You may want
    to do this because under certain circumstances it is necessary to opt out of the
    standard state-driven React model and access HTML elements directly. For this
    purpose, `useRef` is used to access an instance of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are, of course, many other Hooks out there, both from the React team and
    third parties. But once you are comfortable, you'll be able to see what else you
    may need or, even better, be able to create your own Hooks. We will also be creating
    our own Hooks for our project as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some examples of using Hooks. We''ll create a new project
    in `Chap5` to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch your command line or terminal to the `Chap5` folder and run the following
    command within that folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last example for the class-components project, we created a class component
    called `Greeting.tsx` that had its own state. For demonstration purposes, let''s
    create the same component as a React Hooks functional component. In the `src`
    folder of your `hooks-components` project, create a new file called `Greeting.tsx`
    and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is the version of the code where we get a name as a prop and have our own
    local state. We should try and avoid local state, but I'm doing this for demonstration
    purposes. As you can see, it's way shorter than the class version. In addition,
    we have no lifecycle functions to override. We are using an arrow function because
    it's shorter than using a regular function and we don't need a function's features.
    As you can see, we do have a declaration for the `Greeting` component. It uses
    `FC`, `GreetingProps` interface. The state is stored in the `message` property
    by using the `useState` function, which is a small one-line statement with no
    constructor since this is a function and not a class. Note `GreetingProps` next
    to the parameter is not necessary; I only included it for completeness. Notice
    also that we are using parameter deconstruction by passing `{ name }` instead
    of `props`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have our `useEffect` function. As stated, this is sort of similar to
    `componentDidMount` or `componentDidUpdate`, but runs after drawing to the screen
    finishes. It will update the `message` state property whenever our `name` prop
    updates because we pass it as a `parameter` to the `useEffect` function. Since
    this is not a class, we have no render function. The return value of the function
    is the call to render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll refactor a bit by placing our state into the `App.tsx` component.
    Let''s make `GreetingFunctional.tsx` like we did in the class version of our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s refactor `App.tsx` as a functional component and use the `useReducer`
    Hook we learned about in this section. We''ll leave out the imports since they''re
    the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We define our reducer and an initial state object called `initialState`. The
    default signature for reducers is parameters of the `any` type because both the
    state and action objects can technically be of any type. If you look at the `reducer`
    function, you''ll notice it tries to handle different types of actions by returning
    a new state object and an appropriate updated member (again, it is very important
    you do not modify the original state object directly. Copy it and then do your
    update on the new object and return that). So, this is the intended usage of `useReducer`.
    If your state objects are complex and the logic to change the properties is complex,
    you would use a `useReducer` function. You can think of it as a form of containment
    for related logic on your state object. Next, you can see the actual call to `useReducer`
    in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function returns an object and a `dispatch` function. The
    object is the entire state object after the reducer runs, but in our case we do
    deconstruction so we can directly call the `message` and `enteredName` properties.
    So after this setup, the `onChangeName` event is defined, which, when triggered,
    runs the `useReducer` dispatcher, `dispatch`, to trigger the actual change by
    sending over the appropriate action. If you run this code, you'll see it runs
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the nice thing about all this is that, as you can see, we can take our
    `reducer` function and reuse it in other functional components. We can also take
    our dispatcher and pass it down to child components so that the child can trigger
    updates to our state as well. Let''s try that out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `GreetingFunctional.tsx` component with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have passed down `enteredName` and `greetingDispatcher` to
    our `Greeting` component as props. Then we also brought over the `input` and `onChangeName`
    events in order to use them in our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update our `App.tsx` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have removed `onChangeName` and the input so that we can
    use it in our `GreetingFunctional.tsx` component. We are also passing `enteredName`,
    `message`, and `dispatch` as parameters to the `Greeting` component. If you run
    this you should see that it is our child `GreetingFunctional.tsx` that is triggering
    the `reducer` updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s look at the `useCallback` function. Update `App.tsx` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing is having an input that will take the user''s initial number
    value, using `startCount`. Then we will increment that number by clicking `setCountCallback`.
    But make note of how `useCallback` is having the `count` state as a parameter.
    This means that when `count` changes, `setCountCallback` will be reinitialized
    with current values. The remaining code is returning the desired JSX that will
    generate the final HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The return is providing the UI for this incrementation ability.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code and click the **Increment count** button, you will see
    that it increments, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Increment count clicked 8 times'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.7_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Increment count clicked 8 times
  prefs: []
  type: TYPE_NORMAL
- en: 'However, try changing the passed-in array, `[count, startCount]`, and remove
    the `count` variable so it just says `[startCount]`. Now, it does not keep incrementing
    because there is no dependency on `count`. It only counts once, on the first run,
    no matter how many times we click:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – After removing count'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.8_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – After removing count
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even if you click many times, it will always be incremented by one,
    since the function is cached in memory and it always runs with the same initial
    value of `count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one more example for performance. We''ll use the memo wrapper
    on this example to reduce re-renders. It''s not a Hook, but it is a new capability
    added recently to React. Let''s look at the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `ListCreator.tsx` and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This component will take a list of items and render them as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s update our `App.tsx` file to send new list items based on the increment
    count. Again, I''ve only included the `App` function. Please note there is a new
    import called `ListCreator` that is needed as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: const onWelcomeBtnClick = () => {
  prefs: []
  type: TYPE_NORMAL
- en: setCountCallback();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'const onChangeStartCount = (e:'
  prefs: []
  type: TYPE_NORMAL
- en: React.ChangeEvent<HTMLInputElement>) => {
  prefs: []
  type: TYPE_NORMAL
- en: setStartCount(Number(e.target.value));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: console.log("App.tsx render");
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div className="App">
  prefs: []
  type: TYPE_NORMAL
- en: <header className="App-header">
  prefs: []
  type: TYPE_NORMAL
- en: <img src={logo} className="App-logo" alt="logo" />
  prefs: []
  type: TYPE_NORMAL
- en: <Greeting
  prefs: []
  type: TYPE_NORMAL
- en: message={message}
  prefs: []
  type: TYPE_NORMAL
- en: enteredName={enteredName}
  prefs: []
  type: TYPE_NORMAL
- en: greetingDispatcher={ dispatch } />
  prefs: []
  type: TYPE_NORMAL
- en: '<div style={{marginTop: ''10px''}}>'
  prefs: []
  type: TYPE_NORMAL
- en: <label>Enter a number and we'll increment           it</label>
  prefs: []
  type: TYPE_NORMAL
- en: <br/>
  prefs: []
  type: TYPE_NORMAL
- en: <input value={startCount}           onChange={onChangeStartCount}
  prefs: []
  type: TYPE_NORMAL
- en: 'style={{width: ''.75rem''}} />&nbsp;'
  prefs: []
  type: TYPE_NORMAL
- en: <label>{count}</label>
  prefs: []
  type: TYPE_NORMAL
- en: <br/>
  prefs: []
  type: TYPE_NORMAL
- en: <button onClick={onWelcomeBtnClick}>Increment
  prefs: []
  type: TYPE_NORMAL
- en: count</button>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <ListCreator listItems={listItems} />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </header>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a small update to `ListCreator` to reduce our renders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I only showed the `ListCreator` component, but as you can see we added a wrapper
    called `React.memo`. This wrapper only allows component updates if the props passed
    in have changed. Therefore we get a small performance benefit. If this was a complex
    object with lots of elements it could make a big difference.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see throughout these examples, for any given Hook, we can reuse that
    same Hook in different components and with different parameters. This is the key
    takeaway of Hooks. Code reuse is now much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Please note `useState` and `useReducer` are just reusable functions that allow
    you to use functions across multiple components. So using `useState` in component
    A and then `useState` in component B will not allow you to share the state across
    both components, even if the state names are the same. You're just reusing capability,
    that's all.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about React Hooks. We reviewed some of the main
    Hooks available in the library as well as how to use some of them. We will cover
    more Hooks later and also begin building our app in future chapters. This coverage
    of Hooks is going to help us to start building our components later.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing and contrasting the class way versus the Hooks way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some of the differences between the class way
    and the Hooks way of writing code in React. We will see why the React team decided
    Hooks was the way forward. Learning these details will give us confidence in using
    Hooks in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at the class-based lifecycle methods, not only are there many to
    remember and understand, you can also see that for each class component you would
    have a pretty much unique implementation of lifecycle functions. This makes code
    reuse difficult to do with classes. With Hooks, we also have many different built-in
    Hooks we can use and need to know. However, they are not component specific and
    can be reused for different components at will. This is the key motivator for
    using Hooks. Code reuse is much easier because the Hooks are not tied to any specific
    class. Each Hook is focused on providing a specific capability or functionality,
    regardless of where it's used. Additionally, if we do the work of building our
    own Hooks, we can reuse them when appropriate as well.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at `Greeting` in the class-component project. How could we reuse
    the code in this component? Even if we could do this, it adds no real value or
    benefit. In addition to this, `getDerivedStateFromProps` adds complexity that
    may trigger a re-render. And we haven't even used any of the other lifecycle methods
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Hook components and React in general prioritize componentization over inheritance.
    In fact, the React team states that it is a best practice to use components within
    other components as a means of sharing code instead of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: So, to reiterate, lifecycle components are generally tied to a specific component,
    but Hooks can be used across components with a little work to properly generalize
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you recall how large `Greeting` became once we added the `getDerivedStateFromProps`
    call into it? In addition, we always need a constructor to instantiate our state
    and use `bind` for all of our components. Since our components are simple, it
    didn't matter. But for production code, you'll see components with many functions
    that will all need `bind` calls put on them.
  prefs: []
  type: TYPE_NORMAL
- en: '`Greeting` in the hooks-component project was much simpler. Even when that
    component grows, the Hooks being called will mostly repeat, additionally making
    code easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a very large amount of information. We learned about class-based
    components and what makes them difficult to work with. We also learned about Hook-based
    components, which are simpler and easier to reuse.
  prefs: []
  type: TYPE_NORMAL
- en: We now know the fundamentals of React programming. We can now create our own
    React components and begin building our application!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the tooling around React. We'll combine
    the knowledge we gained here with the tooling information, and it will help us
    write clean, responsive code.
  prefs: []
  type: TYPE_NORMAL
