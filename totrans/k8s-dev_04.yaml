- en: Declarative Infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is inherently a declarative system. In prior chapters, we have explored
    Kubernetes and some of its key concepts using commands such as `kubectl run` and
    `kubectl expose`. These commands are all imperative: do this thing now. Kubernetes
    does this by managing these resources as objects themselves. `kubectl` and the
    API server translate these requests into resource representations, and then store
    them, and it is the job of the various controllers to understand the current state
    and make it as requested.'
  prefs: []
  type: TYPE_NORMAL
- en: We can take advantage of the declarative structures directly—all the Services,
    Pods, and more can be represented by either JSON or YAML files. In this chapter,
    we will move to define your applications as a declarative infrastructure. We will
    take the existing simple Kubernetes Pods and put them into declarations that you
    can manage alongside your code; stored in source control and deployed to run your
    software. We will also introduce ConfigMaps and Secrets, to allow you to define
    your configuration as well as your application structure, and explore how to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sections for this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative versus declarative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring your first application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes resource—Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes resource—ConfigMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes resource—Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python example with ConfigMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative versus declarative commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our examples thus far have focused on quick and imperative commands such as
    `kubectl run` to create a deployment that in turn runs our software. This is convenient
    for something quick, but does not easily expose the full flexibility of the API.
    To leverage all the options available via Kubernetes, it is often more effective
    to manage files that describe the deployment you want.
  prefs: []
  type: TYPE_NORMAL
- en: When using these files, you can use commands such as `kubectl create`, `kubectl
    delete`, and `kubectl replace` along with the `-f` option to specify the file
    to use. The imperative commands are easy and effective for simple setups, but
    you quickly need a sequence of commands that you repeat again and again to take
    full advantage of all the capabilities. You might be storing sets of these commands
    in a cheatsheet, but that can get cumbersome and isn't always clear.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes offers a declarative mechanism as well, leveraging the `kubectl apply` command,
    which takes in files, reviews the current state, and manages the updates—creating,
    removing, and so on—as needed, while also keeping a simple audit log of the changes.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using the `kubectl apply` command for anything more complex than
    running a single process, which will likely be most of your developed services.
    You may not need the audit trails in development. You probably would in a staging/canary
    environment or in production, so being familiar and comfortable with them is advantageous
    to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Best of all, but keeping the description of your application in files, you can
    include them in source control, treating them like code. This gives you a consistent
    means of sharing that application structure among your team members, all of which
    can use it to provide a consistent environment.
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl apply` command has an `-f` option to specify a file or directory
    of files, as well as an `-R` option that will recursively descend directories
    if you are establishing a complex deployment.
  prefs: []
  type: TYPE_NORMAL
- en: As we go forward in this book, I will use declarative commands and configurations
    in YAML format (with comments) to describe and manipulate the Kubernetes resources.
    JSON can be used as well if you have a strong preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If you would like a command-line tool to parse YAML, there is an equivalent
    to `jq` for JSON: `yq`. Our examples won''t go into that much detail, but if you
    want to use the tool you can find more information about it at [https://yq.readthedocs.io](https://yq.readthedocs.io).'
  prefs: []
  type: TYPE_NORMAL
- en: A wall of YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do these configurations look like? The vast majority of them are managed
    in YAML format, and the options and configurations can seem overwhelming. Each
    resource in Kubernetes has its own format, and some of those formats are changing
    and under active development. You will notice that some of the APIs and object
    structures will actively reference either `alpha` or `beta` to indicate the state
    of maturity of those resources in the project. The project tends to use these
    terms in a very conservative manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alpha` tends to mean it is an early experiment and the data format may change,
    but something achieving the end goal will likely exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`beta` is more solid than purely experimental, and can likely be used in production
    loads, although the specific resource format hasn''t been entirely locked down
    and may change slightly over Kubernetes releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that alpha and beta APIs evolve as new releases of Kubernetes are made
    available. If you use an earlier version, it may become deprecated and ultimately
    unavailable. You will need to track these updates with the version of Kubernetes
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: The formal documentation for the resources, their options, and formats, are
    hosted at [https://kubernetes.io](https://kubernetes.io) under reference documentation.
    As I write this, the current released version is 1.8, and the reference documentation
    for that is available at [https://kubernetes.io/docs/api-reference/v1.8/](https://kubernetes.io/docs/api-reference/v1.8/).
    This documentation is generated from the Kubernetes project source and updated
    each release, which generally comes out approximately every three months.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to wading through the reference documentation, you can get the declaration
    from existing Kubernetes objects. When you request the Kubernetes resource using
    the `kubectl get` command you can add the `-o yaml --export` option.
  prefs: []
  type: TYPE_NORMAL
- en: The `-o yaml` option could instead be `-o json` if you prefer that format. `--export`
    will strip out some extraneous information that is specific to the current state
    and identity of the resource within Kubernetes, and won't benefit you to store
    externally.
  prefs: []
  type: TYPE_NORMAL
- en: Although the capability isn’t quite complete with version 1.8, you should be
    able to ask for all resources in a namespace, store those configurations, and
    use those files to reproduce it exactly. In practice, there are a few bumps along
    the way, as the exported versions don't always have exactly what you want. At
    this point, it is far better to manage your own declaration files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I recommend using YAML as the format for these declarations. You could
    use JSON, but YAML allows you to add comments into the declarations, which are
    immensely useful for others reading those files—a capability that the JSON format
    doesn't share.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by looking at what `kubectl run` created for us, and work from
    there. We created the earlier simple deployments with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the examples, we dumped the state of the declaration with the `kubectl get
    deployment flask -o json` command. Let''s repeat that except using the `-o yaml
    --export` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The general format of any Kubernetes resource will have the same top four objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kind`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are retrieving information from Kubernetes, you will see a fifth key:
    `status`. Status isn''t expected to be defined by a user, and is provided by Kubernetes
    when retrieving objects to share their current state. If you miss the `--export`
    option on a `kubectl get` command, it will include status.'
  prefs: []
  type: TYPE_NORMAL
- en: You will see metadata scattered throughout the objects, as the objects are related
    to each other and build conceptually on each other. The metadata is included per
    resource, even though it may be combined (as shown previously) into a single reference.
    For the deployment we created, it is using a declarative reference for a deployment,
    which wraps a ReplicaSet, which wraps a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the formal definition of each of these at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployment: [https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deployment-v1beta2-apps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ReplicaSet : [https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#replicaset-v1beta2-apps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pod: [https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#pod-v1-core)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may notice that ReplicaSet and Deployment are nearly identical. Deployment
    extends ReplicaSet and every instance of Deployment will have at least one ReplicaSet. Deployment
    includes declarative options (and the responsibility) for how to perform updates
    on running software. Kubernetes recommends that when you’re deploying code, you
    use a Deployment over a ReplicaSet directly, in order to specify exactly how you
    want it to react as you update it.
  prefs: []
  type: TYPE_NORMAL
- en: Within the deployment `spec` ([https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps](https://kubernetes.io/docs/api-reference/v1.8/#deploymentspec-v1beta2-apps)),
    all the items under the key template are defined from the Pod template specification.
    You can view the details of the Pod template specification at [https://kubernetes.io/docs/api-reference/v1.8/#podtemplatespec-v1-core](https://kubernetes.io/docs/api-reference/v1.8/#podtemplate-v1-core).
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at the online documentation, you will see a large number
    of options that we’re not specifying. When they aren’t specified, Kubernetes will
    still fill in values using the defaults defined in the specification.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify as completely, or as lightly, as you desire. The number of required
    fields is quite small. You typically only need to define the optional fields when
    you want a different value than the default. As an example, for a deployment,
    the required fields are a name and the image to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend keeping to a minimal set of declarations in YAML as you create them
    for your own code. This will support easier understanding of your resource declarations,
    and along with the liberal use of comments, should make the resulting files easy
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring your first application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go ahead and pick one of the examples and create a deployment declaration, and
    try creating one using the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend making a directory called `deploy`, and putting your declaration
    file within that. This is using the `flask` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the existing deployment before you try out your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a good practice to use the `--validate` option to have `kubectl` check
    the files, and you can use it with `--dry-run` to compare the file to anything
    existing in Kubernetes to let you know specifically what it will be doing.  YAML
    is easy to read, and unfortunately even easier to make formatting mistakes due
    to its use of whitespace to define the structure. Using the `--validate` option,
    `kubectl` will warn you of missing fields or other problems. Without it, `kubectl`
    will often fail quietly, simply ignoring what it doesn’t understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see results that look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you happened to make a typo, you''ll see an error reported in the output.
    I made an intentional typo in one of the keys, `metadata`, and the result was
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are happy that the data validates and will work as you expect, you
    can create the object with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is still easy to make minor mistakes that aren''t immediately apparent,
    but become clear when you try and run the code. You can use the `kubectl get`
    command to inspect specific resources. I would encourage you to also use the `kubectl
    describe` command to see not only the state of the resources, but all related
    events from Kubernetes about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once you are comfortable with the declaration working as expected, store it
    in source control along with your code. The example sections of this book will
    move to using stored configurations, and the Python and Node.js examples will
    be updated in this and future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create Kubernetes resources and then later manage them with
    the `kubectl apply` command, you should use the `--save-config` option when running
    the `kubectl run` or `kubectl create` commands. This will explicitly add in the
    annotations that `kubectl apply` expects to be there when it''s run. If they aren''t
    there, the commands will still operate correctly, but you''ll get a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ImagePullPolicy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you use `:latest` tags in your code while trying things, you may have noticed
    that the value of `imagePullPolicy` was set to `Always`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This tells Kubernetes to always attempt to load new Docker images from container
    repositories. If you use a tag other than `:latest`, then the default (`IfNotPresent`)
    will only attempt to reload the container images if it can't find them in its
    local cache.
  prefs: []
  type: TYPE_NORMAL
- en: This is a technique that can be very useful while you are frequently updating
    your code. I recommend only using this when you are working by yourself, as sharing
    the knowledge of what exactly `:latest` means can be difficult and lead to a great
    deal of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: It is generally considered a bad practice to use the `:latest` tag in any staging
    or production deployment, simply because of the uncertainty of what it references.
  prefs: []
  type: TYPE_NORMAL
- en: Audit trail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use the `kubectl apply` command, it automatically maintains an audit
    trail for you in the Kubernetes resources as annotations. If you use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see fairly readable output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The audit trail I mentioned is contained in the annotation `kubectl.kubernetes.io/last-applied-configuration`—which
    includes the last applied configuration. Because that annotation is fairly lengthy,
    it is clipped a bit in this output. You can see the full details if you dump the
    entire object with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The information we''re interested in here is `metadata` | `annotations`  `kubectl.kubernetes.io/last-applied-configuration`.
    The full detail in that annotation might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/caa72445-4fd3-45c6-82a8-c5b25d63efaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes resource – Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where labels and selectors are used for grouping and selecting sets of Kubernetes
    resources, Annotations provide a means of adding resource-specific metadata that
    can be accessed by either Kubernetes or in the containers it runs.
  prefs: []
  type: TYPE_NORMAL
- en: As you just saw, `kubectl apply` automatically applies an annotation to track
    the last applied configuration state of a resource when it is invoked. In the
    last chapter, you might have noticed the annotation that the deployment controllers
    used to track revision, `deployment.kubernetes.io/revision`, and we spoke of the `kubernetes.io/change-cause` annotation
    that was used by `kubectl` to display the change history of deployment rollouts.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations can be simple values or complex blocks (as in the case of `kubectl.kubernetes.io/last-applied-configuration`).
    The examples so far are Kubernetes tools using annotations to share information,
    although annotations are also used to share information in a container for an
    application to use.
  prefs: []
  type: TYPE_NORMAL
- en: You might use them to include information such as adding version control revision
    information, a build number, relevant human-readable contact information, and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like labels, annotations can be added using an imperative `kubectl` command:
    `kubectl annotate`. In general, annotations use the same key mechanism that labels
    use, so any annotation that includes `kubernetes.io` in its prefix is something
    from the Kubernetes project.'
  prefs: []
  type: TYPE_NORMAL
- en: Labels are intended to group and organize Kubernetes objects – Pods, Deployments,
    Services, and so on. Annotations are intended to provide additional information
    specific to an instance (or a couple of instances) generally as additional data
    within the annotation itself.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing labels and annotations in Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes can expose data about a Pod in a container directly, typically as
    files in a specific filesystem, which your code can read and use. Labels, annotations,
    and more can be made available as files in your container through the container
    specification, and using what Kubernetes calls the `downwardAPI`.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a convenient way to expose annotation information such as build
    time, source code reference hash, and so forth in a container so that your runtime
    code can read and reference the information.
  prefs: []
  type: TYPE_NORMAL
- en: To make the Pods labels and annotations available, you define a volume mount
    for the container, and then specify the `downwardAPI` and items from it for the
    volume mount point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `flask` deployment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The details in the lower section identify a mount point—a directory structure
    that will be created inside the container. It also specifies that the volume should
    be using the `downwardAPI` with specific metadata; in this case, the labels and
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify a volume mount location, take care not to specify a location
    that already exists and has files (such as/and so on) or the container may have
    trouble operating as expected. The mount point doesn't throw an error—it just
    overlays on whatever might already exist in the container at that location.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply this updated declaration with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can open a shell to that running Pod, with a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And in that active shell, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare this to the annotations on the Pod itself through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A variety of data about the Pods can be exposed in the Pods, and the same data
    can be exposed to Pods via environment variables. The full set of data that can
    be exposed is detailed in the Kubernetes documentation ([https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/](https://kubernetes.io/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)).
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem convenient and obvious to use this mechanism to provide a
    means of passing in configuration data, Kubernetes provides additional capabilities
    specifically for providing configuration to code within containers, including
    the private configuration needed for passwords, access tokens, and other secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes resource – ConfigMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create containers as read-only instances of your code, you quickly
    want a means to provide small changes in the form of flags or configuration. Perhaps,
    more importantly, you do not want to include private details such as API keys,
    passwords, or authentication tokens in your container images.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes supports two resources to help and link in exactly this kind of information.
    The first is a ConfigMap, which can be used individually or across Pods for your
    application deployment, providing a single place to update and propagate configuration
    for your application. Kubernetes also supports the concept of a Secret, a far
    more locked down type of configuration that is more tightly controlled and exposed
    only where you need it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one might use a ConfigMap to control basic configuration of the
    example Redis deployment, and a Secret to distribute sensitive authentication
    credentials for clients to connect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConfigMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create a ConfigMap using the `kubectl` create `configmap` command, with
    the data for the configuration set on the command line, or coming from one or
    more files that you have stored. It also supports loading a directory of files
    for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating from single key/value pairs on the command line is very simple, but
    probably the least convenient for managing configuration. For example, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a ConfigMap named `example-config` with a single key/value
    pair. You can see the list of all configurations loaded with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And view that ConfigMap using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can also request the raw data in YAML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can also request the raw data in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The values for configurations created from literals will generally be strings.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create configuration values that your code can parse as a different
    type (number, Boolean, and so on), then you will want to either specify those
    configurations as files or define them as blobs inside the ConfigMap objects in
    YAML or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: If you would prefer to manage the configuration in separate files, they can
    have multiple lines in a simple `key=value` format, one configuration per line.
    The `kubectl create configmap <name> --from-file <filename>` command will load
    those, creating a `configmap` name based on the filename, each with all the relevant
    data from the files included within it. If you already have configuration files
    that you're working with, you can use this option to make ConfigMaps based on
    those files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted a configuration file, `config.ini`, that you wanted
    to load into a ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use the following command to create an `iniconfig` ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Dumping that data back out as a ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Should return you something akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The pipe symbol  (`|`) in the YAML output defines a multiline input. These kinds
    of configurations won't be directly available as environment variables, as they
    are invalid for that format. They can be made available as files once you add
    them to your Pod specification. Adding them to your Pod specification is very
    similar to using the downward API to expose labels or annotations in a Pod's containers
    as files.
  prefs: []
  type: TYPE_NORMAL
- en: Managing ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created a ConfigMap, you can’t overwrite it with another ConfigMap
    using the `kubectl create` command. You can delete it and recreate it, although
    a more effective option would be managing the configuration declarations like
    other Kubernetes resources, updating it with the `kubectl apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you created an initial ConfigMap using the `kubectl create` command while
    you’re trying out some ideas, you can start managing that configuration using
    the `kubectl apply` command in the same fashion we used previously with deployments:
    exporting the YAML and then using `kubectl apply` from within that file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to get and store the configuration we created earlier in a deploy
    directory, you might use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the 1.7 release of Kubernetes, there are a few fields added in the export
    that aren''t strictly needed, but also won’t hurt anything if you leave them in.
    Looking at the file, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The keys of `data`, `apiVersion`, `kind`, and metadata are all critical, but
    some of the subkeys under metadata aren’t required. For instance, you could delete
    `metadata.creationTimestamp` and `metadata.selfLink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now still have the ConfigMap resource in Kubernetes, so the first time
    you run `kubectl apply`, it will alert you that you’re doing something a bit unexpected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can get rid of this warning by using the `--save-config` option with your
    `kubectl create` commands, which will include the annotations that `kubectl apply`
    expects to be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, `kubectl apply` has applied its diff and made the relevant updates.
    If you now retrieve the data from Kubernetes, it will have the annotations that
    `kubectl apply` adds when updating resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Exposing the configuration into your container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two primary ways to expose configuration data into your container:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the keys from one or more ConfigMaps into environment variables that
    are set for your Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes can map the data from one or more ConfigMaps into volumes that are
    mounted in your Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary difference is that environment variables are typically set once
    at the start of invoking your container and are generally simple string values,
    where as ConfigMaps mounted as data in volumes can be more complex and will get
    updated if you update the ConfigMap resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note that no mechanism exists to explicitly tells your container that a ConfigMap
    value has been updated. As of version 1.9, Kubernetes does not include any means
    to signal to Pods and Containers that something has updated.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, configuration data exposed as file mounts isn't updated immediately.
    There is a lag between updating the ConfigMap resource and seeing the changes
    reflected in the relevant Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining a Pod specification, in addition to the mandatory name and image
    key, you can specify an `env` key. The environment key requires a name, and you
    can add a key that makes a reference using `valueFrom:` to get data from a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to expose our example configuration as an environment variable,
    you could add the following stanza to a Pod specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can include multiple environment variables in the Pod specification, and
    each can reference a different ConfigMap if you have your configuration split
    up into multiple pieces to make it easier (or more sensible) to administer.
  prefs: []
  type: TYPE_NORMAL
- en: You can also map the entirety of a ConfigMap that are all key/values into environment
    variables as a single block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using individual keys under `env`, you can use `envFrom` and specify
    the ConfigMap, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, every configuration data key/value will be loaded as an environment
    variable when the Pod starts.
  prefs: []
  type: TYPE_NORMAL
- en: You can create keys in ConfigMap that are not legal to be environment variables,
    such as keys starting with a number. In those cases, Kubernetes will load all
    the other keys and record the failed keys in the event log, but otherwise not
    throw an error. You can use `kubectl get events` to see the failed messages, where
    it will show each key that it skipped because it was invalid.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use one of the ConfigMap values that the arguments passed to
    the command to run within a container, you can also do that. When you specify
    the environment variables by `env` and name, you can reference that variable elsewhere
    in the Pod specification using `$(ENVIRONMENT_VARIABLE_NAME)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `spec` snippet uses the environment variable in
    the invocation of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Exposing ConfigMap as files inside the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exposing ConfigMap data into files within a container is very similar to how
    annotations and labels are exposed into a container. There are two parts to the
    specification on a Pod. The first is defining a volume for the container, including
    a name for it, and the location for where it should be mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is a volume description that references the same name for the
    volume and lists ConfigMap as a property to indicate where to get the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that specification is applied, the values will be available as files within
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can use either environment variables or config files to provide the configuration
    data to your application, just depending on which is easier or more comfortable
    for your needs. We will update the examples to use ConfigMaps and adding ConfigMaps
    to deployments as well as reference the values within the code for the sample
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies on ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you start referencing a ConfigMap in a Pod specification, you are creating
    a dependency on that ConfigMap for your resources. For example, if you added some
    of the preceding examples to expose `example-data` as an environment variable,
    but hadn’t added the `example-config` ConfigMap to Kubernetes, when you try to
    deploy or update the Pod, it will report an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this happens, the error will generally be reported in `kubectl get pods`
    or will be visible in the event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If you add the ConfigMap after the fact, the Pod will start when the resource
    it needs is available.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes resource – Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ConfigMaps are great for general configuration, but are easily visible—which
    may not be desired. For some configuration, such as passwords, authorization tokens,
    or API keys, you often want a more controlled mechanism to protect those values.
    That’s what the resource Secrets are designed to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets are generally created (and managed) individually, and internally Kubernetes
    stores this data using `base64` encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a secret on the command line by first writing the values into
    one or more files, and then specifying those files in the `create` command. Kubernetes
    will take care of doing all the relevant `base64` encoding and storing them away.
    For example, if you wanted to store a database username and password, you might
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that in naming the secret's name, you can use any alphanumeric character,
    a `-` or `.`, but an underscore is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the Secret we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You see the secret reported as type `Opaque` and just the number of bytes associated
    with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can still get the secret using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This will reveal the `base64` encoded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you `base64` decode the value, you will see the original version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that anyone with access to your Kubernetes cluster resources can retrieve
    and view these secrets. Additionally, I do not recommend that you manage secrets
    like the rest of the declaration, stored in source control. Doing so exposes those
    secrets (in `base64` form) in your source control system.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Secrets into a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can expose Secrets to a Pod in a very similar fashion to exposing ConfigMaps.
    Like ConfigMaps, you can choose to expose a Secret as an environment variable,
    or as a file mounted within a volume, specified by the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: The format for exposing a secret looks identical to exposing a ConfigMap value,
    except that it uses `secretKeyRef` instead of `configMapRef` in the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to expose the preceding example secret password as an environment
    variable, you might use the following in a Pod specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then looking within the container, the environment variables container `DB_PASSWORD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: A better path is to leverage the capability that Kubernetes includes for mounting
    secrets to be exposed as files inside the container. The configuration is very
    similar to exposing ConfigMap values, only defining the Secret as a volume property
    in the spec rather than ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the specification, you need to define a `volumeMount` for the container,
    which indicates its location in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And then define how the contents of that volume get populated from secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'After deploying with this configuration, the container has a `/secrets/db_password`
    file with the contents from our secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Secrets and security – how secret are the secrets?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reasonably so, but not cryptographically secure, at least in Kubernetes 1.8\.
    If you are looking at the secrets from a security perspective, the constraints
    on secrets are better than leaving values in ConfigMap, but the security profile
    has significant limits.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart, the data for secrets is stored in plain-text (albiet encoded text)
    in etcd 3.0, which underpins Kubernetes 1.8\. It does not use encryption at rest,
    or symmetric keys to preserve (and access) the secrets. If you are running your
    own Kubernetes cluster, be aware that an unsecured etcd represents a significant
    weakness in the overall security of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: For many applications and use cases, this is perfectly acceptable, but if you
    need to accommodate a higher security profile in your development and production
    environments, then you will want to look at tooling to work in conjunction with
    Kubernetes. The most commonly discussed alternative/extension is Vault, an open
    source project from HashiCorp. You can find more details about Vault at [https://www.vaultproject.io](https://www.vaultproject.io).
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes project also isn’t standing still in regards to secrets and secret
    management, improving on their features as well. With the 1.7 release, Kubernetes
    included **Role-Based Access Control** (**RBAC**), and the project is maintaining
    and developing against a roadmap that will improve Kubernetes, capabilities around
    its security profile, as well as supporting easier coordination with external
    sources of secrets management (such as Vault) in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Python/Flask deployment with ConfigMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example builds on our earlier Python/Flask example. This extension will
    add a ConfigMap that uses both environment variables and structured files, as
    well as code updates to consume and use those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, add a ConfigMap with both top-level values and a deeper configuration.
    The top values will be exposed as environment variables, and the multiline YAML
    will be exposed as a file inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This ConfigMap is mapped with updates to the Pod specification of the deployment
    with the `envFrom` key and as a volume to provide the file mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This update makes a dependency on having a ConfigMap named `flask-config` on
    the Deployment. If the ConfigMap isn’t loaded and we try to load just that updated
    Deployment, it will not update the Deployment until that ConfigMap is available.
    To avoid the situation of accidentally missing a file, you can put both the ConfigMap
    and Deployment Spec in the same YAML file, separated by `---` on a new line. Then,
    you can deploy multiple resources in the order you specify when using the `kubectl
    apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: You may also keep each resource in a separate file, if that is easier to understand
    or manage, primarily depending on your preference. The `kubectl apply` command
    includes options to reference all files in a directory, including recursively–so
    order and structure the files; however, it makes the most sense to manage them
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To match this example, the code at [https://github.com/kubernetes-for-developers/kfd-flask](https://github.com/kubernetes-for-developers/kfd-flask)
    has a tag that you can use to update all the files at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '(If you skipped the earlier example, you may need to clone the repository first:
    `git clone https://github.com/kubernetes-for-developers/kfd-flask`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the code updated, deploy the updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Once deployed, you may use `kubectl exec` to run an interactive shell in the
    Pod and inspect the deployment and what has been exposed.
  prefs: []
  type: TYPE_NORMAL
- en: SIDEBAR – JSONPATH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We might look up the specific Pod using a command like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This will find just the pods matching the `app=flask` selector and print out
    human-readable output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This same data is available in a structured form (JSON, YAML, and so on) that
    we can parse with tools such as `jq`. Kubectl includes two additional options
    to make it a more convenient tool—you can use `JSONPATH or GO_TEMPLATE` to dig
    out specific values. With `JSONPATH` built into the `kubectl` client instead of
    doing the preceding two-step process to get the Pod name, you can directly get
    the specific details we want to use, which is the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This can be easily embedded into a shell command using `$()` to execute it inline.
    This ends up being a much more complex command, but it takes care of the step
    where we ask Kubernetes what the relevant Pod name is, which is critical for many
    of the interaction commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can open an interactive shell within the Pod associated with
    this deployment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This gets the name of the Pod and embeds that into `kubectl exec` to run an
    interactive session with the `/bin/sh` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have this session open, you can see the environment variables that
    have been set with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This will show you all the environment variables set, one of which should be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the more complex configuration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We crafted the ConfigMap to have the correct location for this file based on
    what we put into the Deployment specification. If we change the Deployment Spec,
    but not the ConfigMap, the location embedded within the environment variable `CONFIG_FILE`
    will then be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: With Kubernetes Deployment, ConfigMap, and Service specifications in YAML, there
    is a lot of duplicate data that is not abstracted out. From a developer’s perspective,
    this will feel awkward, violating the do not repeat yourself mantra that is commonly
    respected. There is a lot of repetition and places for small changes to unfortunately
    impact on the deployment specification.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes project is evolving the means of interacting with these files,
    with efforts to make generating the relevant configurations more with projects
    that are still early in development. As Kubernetes continues to mature, this should
    evolve to have more code-like qualities when defining the resource declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ConfigMap within Python/Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within Python, you can view environment variables using os.environ, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set a default value when using `os.environ.get` in your code to handle
    a case when the environment variable isn’t set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We set the `CONFIG_FILE` environment variable here to show you how it could
    be done, but it is not strictly necessary to read the configuration file–more
    a convenience to allow you to override that value if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also includes a module to parse and read INI-style configuration files,
    like the one we added in ConfigMap. Continuing with the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, ConfigParser has loaded a section named `DEFAULT` with all the environment
    variables, and we could retrieve one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the parser with a section based on the INI file stored in that
    ConfigMap, which is exposed on the filesystem at `/etc/flask-config/feature.flags`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the parser will be loaded with the `DEFAULT` section from the environment
    variables, and the `''features''` section from the ConfigMap data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And the ConfigParser enables you to include defaults in your code as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use that kind of code to set debugging enabled or disabled based on
    that ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: You can find more details on how to leverage Python 3’s ConfigParser at [https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to take advantage of the declarative nature
    of Kubernetes in detail and managing our application through specification files.
    We also looked at Annotations, ConfigMap, and Secrets and how those can be created
    and then used from within Pods. We closed the chapter with updating our Python
    and Node.js applications to use ConfigMaps to run the example code we set up previously,
    and looked briefly at how to leverage the built-in `JSONPATH` within `kubectl`
    to make that tool more immediately powerful at providing the specific information
    you want.
  prefs: []
  type: TYPE_NORMAL
