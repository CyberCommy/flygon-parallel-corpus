- en: Chapter 9. Exploring Network Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with prerelease versions of Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding MacVLAN interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Docker MacVLAN network driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding IPVLAN interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Docker IPVLAN network driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging VLAN IDs with MacVLAN and IPVLAN networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although many of the features we've discussed in earlier chapters have been
    here since day one, many have been very recently introduced. Docker is a rapidly
    evolving piece of open source software with many contributors. To manage the introduction,
    testing, and potential release of features, Docker releases code in a couple of
    different ways. In this chapter, we'll show how you can explore features that
    are not yet in the production or release version of the software. As part of this,
    we'll review two of the newer networking features that have been introduced to
    Docker. One of which, MacVLAN, was recently merged into the release version of
    the software as of version 1.12\. The second, IPVLAN, is still in the prerelease
    software channel. After we review how to consume the Docker prerelease software
    channels, we'll discuss the basic operation of both MacVLAN and IPVLAN network
    interfaces and then discuss how they are implemented as drivers in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Working with prerelease versions of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker offers two different channels in which you can preview unreleased code.
    This gives users a chance to review features that are both slated for release
    as well as features that are entirely experimental and may never make it into
    an actual release version. Reviewing these features and providing feedback on
    them is an important piece of open source software development. Docker takes the
    feedback it receives seriously and lots of great ideas that have been tested in
    these channels make it into the production code release. In this recipe, we'll
    review how to install both the test and the experimental Docker releases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll be using a freshly installed Ubuntu 16.04 host. Although
    not a requirement, it is recommended that you install prerelease versions of Docker
    on a host that does not currently have Docker installed. If the installer script
    detects Docker is already installed, it will warn you not to install the experimental
    or test code. That being said, I recommend that testing of software from these
    channels occurs on dedicated development servers. In many cases, virtual machines
    are used for this purpose. If you use a virtual machine, I recommend you to install
    your base operating system and then snapshot the VM to give yourself a restore
    point. If something goes wrong with the installation, you can always revert to
    this snapshot to start from a known good system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Docker calls out in their documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Experimental features are not ready for production. They are provided for
    test and evaluation in your sandbox environments.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Please keep this in mind when using either of the nonproduction trains of code.
    It is strongly encouraged that you provide feedback on GitHub on any and all features
    present in either channel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, there are two different prerelease software channels available
    to end users.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://experimental.docker.com/](https://experimental.docker.com/): This
    is the URL for the script to download and install the experimental version of
    Docker. This version includes features that are entirely experimental. Many of
    these futures may at some later point be integrated into a production release.
    However, many will not and are in this channel solely for experimentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://test.docker.com/](https://test.docker.com/): This is the URL for the
    script to download and install the test version of Docker. Docker also refers
    to this as the **Release Candidate** (**RC**) version of code. This is code has
    features that are slated to be released but have not yet been integrated into
    the production or release version of Docker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install either version, you simply download the script from the URL and
    pass it to the shell. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the experimental release, run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the test or release candidate, release run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a point of interest, you can also use a similar configuration to download
    the production version of Docker. In addition to [https://test.docker.com/](https://test.docker.com/)
    and [https://experimental.docker.com/](https://experimental.docker.com/), there
    is also [https://get.docker.com/](https://get.docker.com/) that will install the
    production release of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, the use of these scripts should be done on machines that do not
    currently have Docker installed. After installation, you can verify the appropriate
    release was installed by examining the output of `docker info`. For example, when
    installing the experimental release, you can see the experimental flag set in
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test or RC version, you''ll see similar output; however, there will
    not be an experimental variable listed in the output of Docker info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After installation via the script, you should find that Docker is installed
    and running just as if you had installed Docker through your operating systems
    default package manager. While the script should prompt you toward the end of
    the installation, it is advisable to add your user account to the Docker group.
    This prevents you from having to escalate your privileges with `sudo` to use the
    Docker CLI commands. To add your user account to the Docker group, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you log off and back in for the setting to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that these scripts can also be used to update to latest version
    of either channel. In those scenarios, the script will still prompt you about
    the possibility of installing over an existing Docker installation, but it will
    provide verbiage to indicate that you can ignore the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Although this is not the only way to get the test and experimental code, it
    is certainly the easiest. You may also download the prebuilt binaries or build
    the binary yourself. Information on how to do both is available on Docker's GitHub
    page at [https://github.com/docker/docker/tree/master/experimental](https://github.com/docker/docker/tree/master/experimental).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MacVLAN interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first feature we'll be looking at is MacVLAN. In this recipe, we'll be implementing
    MacVLAN outside of Docker to gain a better understanding of how it works. Understanding
    how MacVLAN works outside of Docker will be critical in understanding how Docker
    consumes MacVLAN. In the next recipe, we'll walk through the Docker network driver
    implementation of MacVLAN.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be using two Linux hosts (`net1` and `net2`) to demonstrate
    MacVLAN functionality. Our lab topology will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/5453_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is assumed that the hosts are in a base configuration and each host has
    two network interfaces. The `eth0` interface will have a static IP address defined
    and serve as each hosts default gateway. The `eth1` interface will be configured
    with no IP address. For reference, you can find the network configuration file
    (`/etc/network/interfaces`) for each host following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`net1.lab.lab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`net2.lab.lab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we'll cover all of the steps needed to create the topology in this recipe,
    you may wish to refer to [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*, if some of the steps aren't clear. [Chapter 1](ch01.html
    "Chapter 1. Linux Networking Constructs"), *Linux Networking Constructs*, covers
    the base Linux networking constructs and the CLI tools in much greater depth.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MacVLAN represents an entirely different way to configure interfaces from what
    we've seen up until this point. Earlier Linux networking configurations we examined
    relied on constructs that loosely mimicked physical network constructs. MacVLAN
    interfaces are logical in nature and are bound to an existing network interface.
    The interface supporting the MacVLAN interfaces is referred to as the **parent**
    interface and can support one or more MacVLAN logical interfaces. Let's look at
    a quick example of configuring a MacVLAN interface on one of our lab hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring MacVLAN type interfaces is done in a very similar manner to all
    other types on Linux network interfaces. Using the `ip` command-line tool, we
    can use the `link` subcommand to define the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax should be familiar to you from the first chapter of the book where
    we defined multiple different interface types. Once created, the next step is
    to configure it with an IP address. This is also done through the `ip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we need to make sure that bring the interface up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface is now up and we can examine the configuration with the `ip addr
    show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of interesting items to point out now that we have the interface
    configured. First, the name of the MacVLAN interface makes it easy to identify
    the interfaces parent interface. Recall that we mentioned that each MacVLAN interface
    had to be associated with a parent interface. In this case, we can tell that the
    parent of this MacVLAN interface is `eth0` by looking at the name listed after
    the `macvlan1@` in the MacVLAN interface name. Second, the IP address assigned
    to the MacVLAN interfaces is in the same subnet as the parent interface (`eth0`).
    This is intentional to allow external connectivity. Let''s define a second MacVLAN
    interface on the same parent interface to demonstrate what sort of connectivity
    is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our network topology is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have two MacVLAN interfaces bound to net1''s `eth0` interface. If we try
    to reach either interface from an external subnet, the connectivity should work
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, I attempted to reach both `172.16.10.5` and `172.16.10.6`
    from a test server that lives off subnet from the `net1` host. In both cases,
    we were able to reach the IP address of the MacVLAN interfaces implying that routing
    is working as expected. This is why, we gave the MacVLAN interfaces IP addresses
    within the existing subnet of the servers `eth0` interface. Since the multilayer
    switch knew that `172.16.10.0/24` lives out of VLAN 10, it simply has to issue
    an ARP request for the new IP addresses on VLAN 10 to get their MAC addresses.
    The Linux host already has a default route pointing back to the switch that allows
    the return traffic to reach the test server. However, this is by no means a requirement
    of MacVLAN interfaces. I could have easily chosen another IP subnet to use for
    the interfaces, but that would have prevented external routing from inherently
    working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another item to point out is that the parent interface does not need to have
    an IP address associated with it. For instance, let''s extend the topology by
    building two more MacVLAN interfaces. One on the host `net1` and another on the
    host `net2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our topology is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Despite not having an IP address defined on the physical interface, the hosts
    now see the `192.168.10.0/24` network as being defined and believe the network
    to be locally connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the two hosts can reach each other directly through their associated
    IP addresses on that subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you might be wondering why you would use a MacVLAN interface
    type. From the looks of it, it''s doesn''t appear that much different than just
    creating logical subinterfaces. The real difference is in how the interface is
    built. Typically, subinterfaces all use the same MAC address of the parent interfaces.
    You might have noted in the earlier output and diagrams that the MacVLAN interfaces
    have different MAC addresses than their associated parent interface. We can validate
    this on the upstream multilayer switch (gateway) as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In testing, you might find that the Linux host is presenting the same MAC address
    for each IP address in your configuration. Depending on what operating system
    you are running, you may need to change the following kernel parameters in order
    to prevent the host from presenting the same MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the applying these settings in this manner won't persist through
    a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the MAC addresses, we can see that the parent interface (`172.16.10.2`)
    and both MacVLAN interfaces (`172.16.10.5 and .6`) have different MAC addresses.
    MacVLAN allows you to present multiple interfaces using different MAC addresses.
    The net result is that you can have multiple IP interfaces, each with their own
    unique MAC address, that all use the same physical interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the parent interface is responsible for multiple MAC addresses it needs
    to be in promiscuous mode. The host should automatically put an interface into
    promiscuous mode when it''s chosen as a parent interface. You can verify it by
    checking the ip link details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If having the parent interface in promiscuous mode is a concern, you might be
    interested in the later recipes of this chapter where we discuss IPVLAN configurations.
  prefs: []
  type: TYPE_NORMAL
- en: As with other Linux interface types we've seen, MacVLAN interfaces are also
    namespace aware. This can lead to some interesting configuration options. Let's
    now look at deploying MacVLAN interfaces within unique network namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by deleting all of our existing MacVLAN interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Much like we did in [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*, we can create an interface and then move it into
    a namespace. We start by creating the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the MacVLAN interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move the interface into the newly created network namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, from within the namespace, we assign it an IP address and bring
    it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also create a second interface within a second namespace for testing
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you play around with different configurations, it's common to create and
    delete the same interface a number of times. In doing so, you'll likely generate
    interfaces with the same IP address, but different MAC addresses. Since we're
    presenting these MAC address to the upstream physical network, always make sure
    that the upstream device or gateway has the most recent ARP entry for the IP you
    are trying to reach. It's common for many switches and routers to have long ARP
    timeout values during which they won't ARP for the newer MAC entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have a topology that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The parent interface (`eth0`) has an IP address as before, but this time, the
    MacVLAN interfaces live within their own unique namespaces. Despite being in separate
    namespaces, they still share the same parent since this was done before moving
    them into the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should note that external hosts can no longer ping all of
    the IP addresses. Rather, you can only reach the `eth0` IP address of `172.16.10.2`.
    The reason for this is simple. As you''ll recall, namespaces are comparable to
    a **Virtual Routing and Forwarding** (**VRF**) and have their own routing table.
    If you examine, the routing table of both of the namespaces, you''ll see that
    neither of them have a default route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for these interfaces to be reachable off network, we''ll need to give
    each namespace a default route pointing to the gateway on that subnet (`172.16.10.1`).
    Again, this is the benefit of addressing the MacVLAN interfaces in the same subnet
    as the parent interface. The routing is already there on the physical network.
    Add the routes and test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the external test host (some output removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So while external connectivity appears to be working as expected, you''ll note
    that none of the interfaces can talk to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems odd because they all share the same parent interface. The problem
    is in how the MacVLAN interfaces were configured. The MacVLAN interface type supports
    four different modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VEPA**: The **Virtual Ethernet Port Aggregator** (**VEPA**) mode forces all
    traffic sourced from the MacVLAN interfaces out of the parent interface regardless
    of destination. Even traffic destined to another MacVLAN interface sharing the
    same parent interface is subject to this policy. In a layer 2 scenario, the communication
    between two MacVLAN interfaces would likely be blocked because of standard spanning
    tree rules. You could potentially route between the two on an upstream router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bridge**: The MacVLAN bridge mode mimics a standard Linux bridge. Communication
    between two MacVLAN interfaces on the same parent interface is allowed to occur
    directly without transiting the parent interface off the host. This is useful
    for scenarios where you expect a high level of interface to interface communication
    across the same parent interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This mode resembles VEPA mode with the added capability of entirely
    blocking communication between interfaces on the same parent interface. Even if
    you allow the traffic to transit the parent and then hairpin back into the host,
    the communication will be dropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passthru**: Intended as a means to directly tie the parent interface to the
    MacVLAN interface. In this mode, only a single MacVLAN interface per parent is
    allowed and the MacVLAN interface inherits the MAC address from the parent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While not easy to discern without knowing where to look, our MacVLAN interfaces
    happen to be of type VEPA, which happens to be the default. We can see this by
    passing the details (`-d`) flag to the `ip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the VEPA mode is what's preventing the two namespace interfaces
    from talking directly to each other. More commonly, MacVLAN interfaces are defined
    as type `bridge` to allowed communication between interfaces on the same parent.
    However, even in this mode, the child interfaces are not allowed to communicate
    directly with the IP address assigned directly to the parent interface (in this
    case `172.16.10.2`). This should be a separate paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can recreate both interfaces specifying the `bridge` mode for each MacVLAN
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After specifying the `bridge` mode, we can verify that the two interfaces can
    directly to one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we also note that we still cannot reach the hosts IP address defined
    on the parent interface (`eth0`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Working with the Docker MacVLAN network driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I began writing this book, the current version of Docker was 1.10 and at
    that time MacVLAN functionality was included in the release candidate version
    of Docker. Since then, version 1.12 has been released, which pushed MacVLAN into
    the release version of the software. That being said, the only requirement to
    use the MacVLAN driver is to ensure that you have a 1.12 or newer version of Docker
    installed. In this chapter, we'll review how to consume the MacVLAN network driver
    for containers provisioned from Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be using two Linux hosts running Docker. Our lab topology
    will consist of two Docker hosts that live on the same network. It will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/5453_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is assumed that each host is running a version of Docker that is 1.12 or
    greater in order to have access to the MacVLAN driver. The hosts should have a
    single IP interface and Docker should be in its default configuration. In some
    cases, the changes we make may require you to have root-level access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like all of the other user-defined network types, the MacVLAN driver is
    handled through the `docker network` subcommand. Creating a MacVLAN type network
    is just as easy as creating any other network type, but there are a few things
    to keep in mind that are specific to this driver.
  prefs: []
  type: TYPE_NORMAL
- en: You need to specify the upstream gateway when defining the network. Remember
    that MacVLAN interfaces are presented on the same interface of the parent. They'll
    need the host or interfaces upstream gateway to access external subnets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other user-defined network types, Docker would generate a subnet for you
    to use if you decided not to specify one. While that is still the case with the
    MacVLAN driver, it will not function properly unless you specify the network in
    which your parent interface has access to. Like we saw in the last recipe, MacVLAN
    relies on the upstream network device knowing how to route the MacVLAN interfaces.
    This is accomplished by defining the MacVLAN interfaces for your containers on
    the same subnet as the parent interface. You may also chose to use a parent interface
    that does not have a defined IP address. In these cases, just make sure that the
    gateway you specify when defining the network in Docker is reachable out of the
    parent interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an option to the driver, you need to specify the interface that you wish
    to use as the parent interface for all containers attached with MacVLAN interfaces.
    If you do not specify a parent interface as an option, Docker will create a dummy
    network interface and use this as the parent interface. This will prevent any
    communication to outside networks from this network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--internal flag` is available when creating networks with the MacVLAN driver.
    When specified the parent interface is defined as a dummy interface, which prevents
    traffic from leaving the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a one-to-one relationship with MacVLAN user-defined networks and parent
    interfaces. That is, you can only define one MacVLAN type network on a given parent
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some switch vendors limit the number of MAC addresses that can be learned per
    port. While this number is typically extremely high, make sure that you take this
    into consideration when using this network type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other user-defined network types, you can specify an IP range or a set
    of auxiliary addresses that you wish Docker's IPAM not to allocate to containers.
    In MacVLAN mode, these settings are much more significant because you are presenting
    containers directly onto the physical network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking these points into consideration with our current lab topology, we can
    define the network as follows on each host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this configuration, each host on the network will use one half of the available
    defined subnet, which in this case is a `/25`. Since Dockers IPAM automatically
    reserves the gateway IP address for us, there's no need to prevent it from being
    allocated by defining it as an auxiliary address. However, since the Docker hosts
    interfaces themselves do live within this range, we do need to reserve those with
    auxiliary addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now define containers on each host and verify that they can communicate
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that there isn't a need to publish ports when the containers are
    run. Since the container has a uniquely routable IP address at this point, port
    publishing is not required. Any container can offer any service on its own unique
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like other network types, Docker creates a network namespace for each
    container, which it then maps the containers MacVLAN interface into. Our topology
    at this point looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The namespace name can be found by inspecting the container itself or by linking
    the Docker `netns` directory, as we saw in earlier chapters, so the `ip netns`
    subcommand can query Docker-defined network namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an external testing host that lives off subnet, we can verify that each
    containers services are reachable via the containers IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you will note that containers attached to MacVLAN networks are not
    accessible from the local host despite being on the same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The current implementation of Docker support MacVLAN only in the MacVLAN bridge
    mode. We can verify that this is the operating mode of the MacVLAN interfaces
    by checking the details of the interface within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Understanding IPVLAN interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to MacVLAN is IPVLAN. IPVLAN comes in two flavors. The first
    is L2 mode, which operates very similarly to MacVLAN with the exception of how
    MAC addresses are assigned. With IPVLAN mode, all logical IP interfaces use the
    same MAC address. This allows you to keep the parent NIC out of promiscuous mode
    and also prevents you from running into any possible NIC or switch port MAC limitations.
    The second mode is IPVLAN layer 3\. In layer 3 mode, IPVLAN acts like a router
    and forwards unicast packets in and out of IPVLAN connected networks. In this
    recipe, we'll cover the basic IPVLAN networking construct to get an idea of how
    it works and how it can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll be using the same Linux hosts (`net1` and `net2`) from
    the *Understanding MacVLAN interfaces* recipe in this chapter. Please refer to
    *Understanding MacVLAN* recipe's *Getting ready* section for more information
    about the topology.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Older versions of the `iproute2` toolset did not include full support for IPVLAN.
    If the commands are not working for the IPVLAN configuration there's a good chance
    you're on an older version without support. You likely need to update in order
    to get a newer version that has full support. The older versions have some support
    for IPVLAN but lack the ability to define a mode (L2 or L3).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, IPVLAN in L2 mode is almost identical to MacVLAN in terms of functionality.
    The major difference is in the fact that IPVLAN leverages the same MAC address
    for all IPVLAN interfaces attached to the same master. You'll recall that MacVLAN
    interfaces leveraged a different MAC address for each MacVLAN interface attached
    to the same parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the same interfaces we did in MacVLAN recipe to show that the
    interface addresses are created with an identical MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only difference in the configuration is that we''re specifying
    the type as IPVLAN and the mode as L2\. In the case of IPVLAN, the default mode
    is L3, so we need to specify L2 in order to get the interfaces to operate in that
    fashion. Since IPVLAN interfaces inherit the MAC address of the parent, our topology
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can prove this just by checking the interface themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to initiate traffic toward these IPs from off of the local subnet
    we could validate that each IP is reporting the same MAC address by checking the
    ARP table on the upstream gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And while we won't show an example here, IPVLAN interfaces in L2 mode are also
    namespace aware just like we saw in the last couple of recipes with the MacVLAN
    interface type. The only difference would be in the interface MAC addresses as
    we saw in the preceding code. The same restrictions apply in regard to the parent
    interface being unable to talk to the child interfaces and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how IPVLAN in L2 mode works, let''s discuss IPVLAN L3 mode.
    L3 mode is significantly different than what we''ve seen up to this point. As
    the name L3 mode suggests, this interface type routes traffic between all attached
    subinterfaces. This is easiest to comprehend in a namespace configuration. For
    instance, let''s look at this quick lab topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding image, you can see that I''ve created four unique namespaces
    across our two lab hosts. I also created four unique IPVLAN interfaces, mapped
    them into the different namespaces, and gave them each a unique IP address. Since
    these are IPVLAN interfaces, you''ll note that all of the IPVLAN interfaces share
    the MAC address of the parent interface. To build this topology, I used the following
    configuration on each respective host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is configured, you''ll note that the only interfaces that can communicate
    with one another are those on the host `net2` (`10.10.40.10` and `10.10.40.11`).
    Let''s look at this topology logically to understand why:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at this logically, it starts to look like a routed network. You''ll
    notice that all the IP addresses assigned are unique without any overlap. As I
    mentioned earlier, IPVLAN L3 mode acts like a router. From a conceptual perspective,
    you can think of the parent interface as that router. If we look at this from
    a layer 3 perspective, it makes sense that only the interfaces in namespaces 3
    and 4 can talk because they are in the same broadcast domain. The other namespaces
    would need to route through a gateway to talk to each other. Let''s check the
    routing table on all of the namespaces to see where things stand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, each namespace only knows about the local network. So in order
    for these interfaces to communicate, they need to have at the very least a default
    route. This is where things get a little interesting. IPVLAN interfaces do not
    allow broadcast or multicast traffic. This means that if we defined the gateway
    of the interface to be the upstream switch, it would never be able to reach it
    because it wouldn''t be able to ARP for it. However, since the parent is acting
    like a sort of router, we can have the namespaces use the IPVLAN interface itself
    as a gateway. We can do that by adding default routes in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding these routes, you''ll also need to add routes on each Linux host
    to tell them where to go to reach these remote subnets. Since the two hosts in
    this example are layer 2 adjacent, the best place to do this on the host itself.
    While you could also rely on the default route and configure these routes on the
    upstream network device that would not be ideal. You would effectively be routing
    in and out of the same L3 interface on the gateway, which isn''t great network
    design practice. If the hosts had not been layer 2 adjacent adding the routes
    on the multilayer switch would have been required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have all of the routes installed, you should be able to reach all
    of the namespaces from any of the other namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, IPVLAN L3 mode is a different animal than what we've seen up
    until this point. Unlike MacVLAN or IPVLAN L2, you'll need to tell the network
    how to reach these new interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Docker IPVLAN network driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen in the previous recipe, IPVLAN offers some interesting modes of
    operations that can be relevant to large-scale container deployments. As of now,
    Docker support IPVLAN in its experimental software channel. In this recipe, we'll
    review how you can consume IPVLAN attached containers with the Docker IPVLAN driver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be using two Linux hosts running Docker. Our lab topology
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/5453_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is assumed that each host is running the experimental channel of Docker in
    order to get access to the experimental IPVLAN network driver. Please see recipe
    1 in regard to the use and consumption of the experimental software channel. The
    hosts should have a single IP interface and Docker should be in its default configuration.
    In some cases, the changes we make may require you to have root-level access to
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have your hosts running the experimental code, verify that you are
    on the correct version by viewing the output of `docker info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, you need to be on an experimental version of Docker
    for the IPVLAN driver to be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker IPVLAN network driver offers both the layer 2 and layer 3 mode of
    operation. Since the IPVLAN L2 mode closely mimics the MacVLAN configuration we
    reviewed earlier, we''ll focus on implementing the L3 mode in this recipe. The
    first thing we need to do is to define the networks. Before doing so, there are
    a few things to keep in mind when using the IPVLAN network driver:'
  prefs: []
  type: TYPE_NORMAL
- en: While it will allow you to specify a gateway when defining the network, the
    setting is ignored. Recall from the previous recipe that you need to use the IPVLAN
    interface itself as the gateway rather than the upstream network device. Docker
    will take care of configuring this for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an option to the driver, you need to specify the interface that you wish
    to use as the parent interface for all containers attached with IPVLAN interfaces.
    If you do not specify a parent interface as an option, Docker will create a dummy
    network interface and use this as the parent interface. This will prevent any
    communication to outside networks from this network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--internal` flag is available when creating networks with the IPVLAN driver.
    When specified the parent interface is defined as a dummy interface, which prevents
    traffic from leaving the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not specify a subnet, Docker IPAM will select one for you. This is
    not advised as these are routable subnets. IPAM on different Docker hosts will
    likely pick the same subnet. Always specify the subnet you wish to define.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a one-to-one relationship with IPVLAN user-defined networks and parent
    interfaces. That is, you can only define one IPVLAN type network on a given parent
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You''ll note that many of the preceding points are similar to the ones that
    apply to the Docker MacVLAN driver. A significant difference lies in the fact
    that we do not want to use the same network as the parent interface. In our examples,
    we''ll use the subnet `10.10.20.0/24` on the host `docker1` and the subnet `10.10.30.0/24`
    on the host `docker3`. Let''s define the networks on each host now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, we can start a container on each host that uses the IPVLAN network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that we once again do not need to deal with publishing ports.
    The container is assigned a fully routable IP address and can present any service
    it wishes on that IP. The IP addresses assigned to the container will come out
    of the specified subnet. In this case, our topology looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once running, you''ll notice that the containers don''t have any connectivity.
    This is because the network doesn''t know how to reach each of the IPVLAN networks.
    For this to work, we need to tell the upstream network device how to reach each
    subnet. To do this, we''ll add the following routes on the multilayer switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this routing is in place, we''ll be able to route to the remote containers
    and access any service they are offering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that in this mode, the container can also reach the hosts interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'While this works, it''s important to know that this is happening by traversing
    the parent interface out to the multilayer switch and then coming back in. We
    can see that the upstream switch (gateway) is generating ICMP redirects if we
    try the ping in the reverse direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So while host-to-container connectivity works, it's not the best model if you
    require the host to communicate with the containers locally.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging VLAN IDs with MacVLAN and IPVLAN networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One feature that's available with both MacVLAN and IPVLAN Docker network types
    is the ability to tag containers on a particular VLAN. This is possible since
    both network types leverage a parent interface. In this recipe, we'll show you
    how you can create Docker network types that are VLAN tagged or VLAN aware. Since
    this functionality works the same in the case of either network type, we'll focus
    on configuring this with MacVLAN type networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll be a single Docker host to demonstrate how the Linux
    host can send VLAN tagged frames to upstream network devices. Our lab topology
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](graphics/5453_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is assumed that this host is running version 1.12\. The host has two network
    interfaces, `eth0` with an IP address of `10.10.10.101` and `eth1` that is up,
    but has no IP address configured on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the interesting features comes along with MacVLAN and IPVLAN network
    drivers is the ability to provision subinterfaces. A subinterface is a logical
    partition of what's typically a physical interface. The standard way of partitioning
    a physical interface is to leverage VLANs. You'll commonly hear this referred
    to as dot1q trunking or VLAN tagging. To do this, the upstream network interface
    has to be prepared to receive tagged frames and be able to interpret the tag.
    In all of our previous examples, the upstream network port was hard-coded to a
    particular VLAN. This is the case with the `eth0` interface of this server. It
    is plugged into a port on the switch that is statically configured for VLAN 10\.
    In addition to this, the switch also has an IP interface on VLAN 10, which in
    our case is `10.10.10.1/24`. It acts as the server's default gateway. Frames sent
    from the servers `eth0` interface are received by the switch and end up in VLAN
    10\. That piece is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other option is to have the server tell the switch what VLAN it wishes
    to be in. To do this, we create a subinterface on the server that is specific
    to a given VLAN. Traffic leaving that interface is tagged with the VLAN number
    and sent on its way to the switch. In order for this to work, the switch port
    needs to be configured as a **trunk**. Trunks are interfaces that can carry multiple
    VLANs and are VLAN tag (dot1q) aware. When the switch receives the frame, it references
    the VLAN tag in the frame and puts the traffic into the right VLAN based on the
    tag. Logically, you might depict a trunk configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We depict the `eth1` interface as a wide channel that can support connectivity
    to a large number of VLANs. We can see that the trunk port can connect to all
    of the possible VLAN interfaces based on the tag it receives. The `eth0` interface
    is statically bound to the VLAN 10 interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is wise in production environments to limit the VLANs allowed on a trunk
    port. Not doing so would mean someone could potentially gain access to any VLAN
    on the switch just by specifying the right dot1q tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality has been around for a long time, and Linux system administrators
    are likely familiar with the manual process used to create VLAN tagged subinterfaces.
    The interesting piece is that Docker can now manage this for you. For instance,
    we can create two different MacVLAN networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The interfaces are defined much like any other MacVLAN interface. What''s different
    is that we specified the `.19` and `.20` on the parent interface names. Specifying
    a dot with numbers after an interface name is the common syntax for defining subinterfaces.
    If we look at the hosts network interface, we should see the addition of two new
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can tell from this output that these are either MacVLAN or IPVLAN interfaces
    whose parent happens to be the physical interface `eth1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we launch containers on both of these networks, we''ll see that they end
    up within either VLAN 19 or VLAN 20 based on which network we specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we attempt to send traffic to either of their gateways, we''ll find
    that both are reachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we capture the frames as they leave the server, we''ll even be able to see
    the dot1q (VLAN) tag in the layer 2 header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](graphics/5453_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As with other network constructs Docker creates, Docker will also take care
    of the cleanup in the case that you delete these user-defined networks. In addition,
    if you prefer to build the subinterface yourself, Docker can consume interfaces
    that you have already created so long as the name is the same as the parent you
    specify.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to specify VLAN tags as part of a user-defined network is a big deal
    and makes presenting containers to the physical network a much easier task.
  prefs: []
  type: TYPE_NORMAL
