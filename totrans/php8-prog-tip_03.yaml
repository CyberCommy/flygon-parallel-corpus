- en: '*Chapter 2*: Learning about PHP 8''s Functional Additions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter walks you through important additions and enhancements introduced
    to **PHP 8** at the procedural level. The code examples used show new PHP 8 features
    and techniques to facilitate procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the use of the new functions and techniques in this chapter will help
    you to write faster and cleaner applications. Even though this chapter focuses
    on commands and functions, all of the techniques are also useful when developing
    class methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with new PHP 8 operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using arrow functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding uniform variable syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning new array- and string-handling techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing SQLite databases with the authorizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: x86_64-based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 gigabyte (GB) free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of random-access memory (RAM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 kilobits per second (Kbps) or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you need to install the following software:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    code explained in this book. Throughout, we refer to the directory in which you
    restored the sample code for this book as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located here: [https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices).'
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin our discussion by examining new PHP 8 operators.
  prefs: []
  type: TYPE_NORMAL
- en: Working with new PHP 8 operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A number of new **operators** have been introduced with PHP 8\. In addition,
    PHP 8 generally introduces a uniform and consistent manner in which these operators
    can be used. In this section, we examine the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Variadics operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullsafe operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenate operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with a discussion of the variadics operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the variadics operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **variadics** operator consists of three leading dots (`...`) preceding
    a normal PHP variable (or object property). This operator has actually been with
    the language since PHP 5.6\. It''s also referred to as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Splat operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spread operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we dive into the improvements PHP 8 has made using this operator, let's
    have a quick look at how the operator is normally used.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown number of arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most common uses for the variadics operator is in a situation where
    you define a function with an unknown number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, the `multiVardump()` function is able to accept
    any number of variables. It then concatenates the `var_export()` output and returns
    a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first time the function is called, we provide three arguments. The second
    time it's called, we only provide a single argument. Because we used a variadics
    operator, there's no need to rewrite the function to accommodate more or fewer
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is a `func_get_args()` PHP function that gathers all function arguments
    into an array. The variadics operator is preferred, however, as it must be stated
    in the function signature, and thus makes the intentions of the program developer
    much clearer. For more information, see [https://php.net/func_get_args](https://php.net/func_get_args).
  prefs: []
  type: TYPE_NORMAL
- en: Vacuuming up remaining arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another use for the variadics operator is to **vacuum up** any remaining arguments.
    This technique allows you to mix mandatory parameters with an unknown number of
    optional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, a `where()` function produces a `WHERE` clause to be added
    to a **Structured Query Language** (**SQL**) `SELECT` statement. The first two
    arguments are mandatory: it''s not reasonable to produce a `WHERE` clause with
    no arguments! Have a look at the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling code using this function might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noted that `where()` has to be called multiple times as the
    number of arguments is limited. This is a perfect candidate for the variadics
    operator! Here is how the rewritten `where()` function might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `...$args` is always returned as an array, to ensure any additional
    calls to the function do not lose clauses we need to perform an `array_merge()`
    operation. Here is the rewritten calling program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant SQL statement is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows that our SQL generation logic produces a valid statement.
  prefs: []
  type: TYPE_NORMAL
- en: Using variadics operator as a replacement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, none of this is foreign to an experienced PHP developer. What's different
    in PHP 8 is that the variadics operator can now be used in situations where *widening*
    might come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly describe the difference in how the variadics operator can be used,
    we''ll need to briefly return to **Object-Oriented Programming** (**OOP**). If
    we rewrite the `where()` function described just now into a class method, it might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we have a `Select` class that extends `Where` but redefines
    the method signature using a variadics operator. This is how it might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s reasonable to use a variadics operator, as the number of arguments provided
    to formulate a `WHERE` clause is unknown. Here is the rewritten calling program
    using OOP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when you try to run this example under PHP 7, the following warning
    appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the code still works; however, the variadics operator is not seen
    by PHP 7 as a viable replacement. Here''s the same code running under PHP 8 (using
    `/repo/ch02/php8_variadics_no_problem.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Variadics operator acceptable in extending class'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.1_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Variadics operator acceptable in extending class
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two PHP documentation references that explain the reasoning behind
    the PHP variadics operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/variadics](https://wiki.php.net/rfc/variadics)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.php.net/rfc/argument_unpacking](https://wiki.php.net/rfc/argument_unpacking)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the nullsafe operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the nullsafe operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **nullsafe** operator is used in a chain of object property references.
    If one of the properties in the chain does not exist (in other words, it is considered
    `NULL`), the operator returns a value of `NULL` safely, without issuing a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s assume we have the following **Extended Markup Language**
    (**XML**) file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a code snippet that scans through the XML document and displays quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to define a `getQuantity()` function that first checks to see
    if that property is not empty before proceeding to the next level, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you start dealing with deeper nesting levels, the function needed to check
    for the existence of a property grows in complexity. This is exactly where the
    nullsafe operator can be employed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the same program code, but without the need for the `getQuantity()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's now have a look at another use for the nullsafe operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the nullsafe operator to short-circuit a chain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nullsafe operator is also useful when used in a chain of connected operations
    including references to object properties, array-element method calls, and static
    references.
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of illustration, here is a configuration file that returns an anonymous
    class. It defines different methods of extracting data depending on the type of
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This class also includes a method to display the data, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the calling program, in order to safely execute the `display()` method we
    need to add an `is_object()`extra safety check and also `method_exists()` before
    executing the callback, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As with the previous example, the nullsafe operator can be used to confirm the
    existence of `$config` as an object. By simply using the nullsafe operator in
    the first object reference, if the object or methods do not exist, the operator
    *short-circuits* the entire chain and returns `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rewritten code using the PHP 8 nullsafe operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If `$config` comes back as `NULL`, the entire chain of operations is cancelled,
    no warning or notice is generated, and the return value (if any) is `NULL`. The
    net result is that we saved having to write three additional `if()` statements!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on other considerations when using this operator, please
    have a look here: [https://wiki.php.net/rfc/nullsafe_operator](https://wiki.php.net/rfc/nullsafe_operator).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pass the format parameter to the sample code file, you need to
    run the code from your browser as follows: `http://localhost:8888/ch02/php7_nullsafe_short.php?format=json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at changes to the concatenation operator.
  prefs: []
  type: TYPE_NORMAL
- en: The concatenation operator has been demoted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the precise usage of the **concatenation** operator (for example,
    the period (.) has not changed in PHP 8, an extremely important change has been
    made in its relative position in the **order of precedence**. In earlier versions
    of PHP, the concatenation operator was considered equal to the lower-order arithmetic
    operators plus (`+`) and minus (`-`) in terms of precedence. Next, let''s look
    at a potential problem with the traditional order of precedence: counter-intuitive
    results.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with counter-intuitive results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfortunately, this arrangement produces unexpected results. The following
    code snippet presents a counter-intuitive output when executed using PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Just looking at the code, you would expect output something along the lines
    of `"Sum:33"`. That''s not the case! Have a look at the following output when
    running on PHP 7.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you're probably wondering, *as the code never lies* where does
    the sum of `11` + `22` come out to `22`, as we see in the preceding output (last
    line)?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer involves order of precedence: starting with PHP 7, it''s consistently
    left-to-right. So, if we use parentheses to make the order of operations clearer,
    this is what actually happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo ("Sum: " . $a) + $b;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`11` gets concatenated to `"Sum: "`, resulting in `"Sum: 11"` . as a string.
    The string is then type-juggled to an integer, resulting in a `0` + `22` expression,
    which gives us our result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the same code in PHP 8, notice the difference here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the arithmetic operator took precedence over the concatenate
    operator. Using parentheses, this is effectively how the code was processed in
    PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echo "Sum: " . ($a + $b);`'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Use parentheses to avoid complications arising from reliance
    upon order of precedence. For more information on the reasoning behind demoting
    the order of precedence of the concatenate operator, have a look here: [https://wiki.php.net/rfc/concatenation_precedence](https://wiki.php.net/rfc/concatenation_precedence).'
  prefs: []
  type: TYPE_NORMAL
- en: We now turn our attention to the ternary operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested ternary operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ternary operators** are not new to the PHP language. There is, however, a
    major difference in how they are interpreted in PHP 8\. This change has to do
    with the traditional **left-associative behavior** of this operator. To illustrate,
    let''s have a look at a simple example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, let''s say that we are using a `RecursiveDirectoryIterator`
    class in conjunction with a `RecursiveIteratorIterator` class to scan a directory
    structure. The starting code might look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a function that matches those files containing the `$searchPath`
    search path and ending with the `$searchExt` extension, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `if / elseif / else`, however, some developers might be tempted
    to refactor this function using nested ternary operators instead. Here is how
    the same code used in the preceding step might look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from both functions produces identical results in PHP 7, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Nested ternary output using PHP 7'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.2_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Nested ternary output using PHP 7
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, however, the use of nested ternary operations without parentheses
    is no longer allowed. Here is the output when running the same block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Nested ternary output using PHP 8'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.3_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Nested ternary output using PHP 8
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Use parentheses to avoid issues with nested ternary operations.
    For more information on the differences in ternary operator nesting, have a look
    at this article: [https://wiki.php.net/rfc/ternary_associativity](https://wiki.php.net/rfc/ternary_associativity).'
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea of the new nullsafe operator. You have also learned how
    three existing operators—the variadics, concatenation, and ternary operators—have
    had their functionality slightly modified. You are now in a good position to avoid
    potential hazards when upgrading to PHP 8\. Let's now have a look at another new
    feature, *arrow functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Using arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arrow functions** were actually first introduced in PHP 7.4\. However, as
    many developers do not follow every single release update, it''s important to
    include coverage of this excellent new feature in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn about arrow functions and their syntax, as well
    as advantages and disadvantages compared with anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Generic syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simply put, an *arrow function* is a shorthand syntax for the traditional **anonymous
    function**, much like the ternary operator is a shorthand syntax for `if () {}
    else {}`. The generic syntax for an arrow function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fn(<ARGS>) => <EXPRESSION>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<ARGS>` is optional and include anything seen in any other user-defined PHP
    function. `<EXPRESSION>` can include any standard PHP expression such as function
    calls, arithmetic operations, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at the differences between arrow functions and anonymous
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions versus anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you will learn the differences between **arrow functions**
    and **anonymous functions**. In order to become an effective PHP 8 developer,
    it's important to gain an understanding of where and when arrow functions might
    replace anonymous functions and improve code performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before getting into arrow functions, let''s look at a simple anonymous function.
    In the following example, the anonymous function assigned to `$addOld` produces
    the sum of the two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, you can produce exactly the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$addNew = fn($a, $b) => $a + $b;`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the code is much more readable, there are advantages and disadvantages
    to this new feature, summarized in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Anonymous functions versus arrow functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_2.1_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – Anonymous functions versus arrow functions
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding table, arrow functions are more efficient
    than anonymous functions. However, the lack of indirection and lack of support
    for multiple lines means that you still need to use anonymous functions on occasion.
  prefs: []
  type: TYPE_NORMAL
- en: Variable inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anonymous functions, much like any standard PHP function, only recognize variables
    outside their scope if you pass the value as a parameter, use a global keyword,
    or add a `use()` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of where a `DateTime` instance is inherited into an anonymous
    function by way of `use()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is exactly the same thing using an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$new = fn($today) => $today->format($format);`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the syntax is extremely readable and concise. Let's now examine
    a practical example that incorporates arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical example: Using arrow functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Returning to the idea of producing a difficult-to-read CAPTCHA (first presented
    in [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013), *Introducing
    New PHP 8 OOP Features*), let''s have a look at how incorporating arrow functions
    might improve efficiency and reduce the amount of coding required. We now examine
    a script that produces a text-based CAPTCHA, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a function that generates a string consisting of a random
    selection of letters, numbers, and special characters. Note in the following code
    snippet the use of the new PHP 8 `match` expression combined with arrow functions
    (highlighted):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `textCaptcha()` function to produce the text CAPTCHA. We first
    define two arrays representing algorithms and colors. These are then *shuffled*
    to further the randomization. We also define **HyperText Markup Language** (**HTML**)
    `<span>` elements to produce large and small characters, as illustrated in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a series of `InfiniteIterator` instances. This is a useful
    **Standard PHP Library** (**SPL**) class that allows you to continue to call `next()`
    without having to check to see if you''re at the end of the iteration. What this
    iterator class does is automatically move the pointer back to the top of the array,
    allowing you to iterate infinitely. The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then build the text CAPTCHA one character at a time, applying the appropriate
    algorithm and background color, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Again, note the mix of `match` and `arrow` functions to achieve the desired
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of the script simply calls the two functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how the output from `/repo/ch02/php8_arrow_func_3.php` might look from
    a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Output from php8_arrow_func_3.php'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.4_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Output from php8_arrow_func_3.php
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more background information on arrow functions, have a look here: [https://wiki.php.net/rfc/arrow_functions_v2](https://wiki.php.net/rfc/arrow_functions_v2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For information on `InfiniteIterator`, have a look at the PHP documentation
    here: [https://www.php.net/InfiniteIterator](https://www.php.net/InfiniteIterator).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at *uniform variable syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding uniform variable syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most radical initiatives introduced in PHP 7.0 was an effort at normalizing
    PHP syntax. The problem with earlier versions of PHP was that in some cases operations
    were parsed from left to right, whereas in other cases this was done from right
    to left. This inconsistency was the root cause of any of a number of programming
    vulnerabilities and difficulties. As a result, an initiative known as **uniform
    variable syntax** was launched by the PHP core development team. But first, let's
    define key points that form the uniform variable syntax initiative.
  prefs: []
  type: TYPE_NORMAL
- en: Defining uniform variable syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uniform variable syntax is neither a protocol nor a formal language construct.
    Rather, it is a guiding principle that strives to ensure all operations are performed
    in a uniform and consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key points from this initiative:'
  prefs: []
  type: TYPE_NORMAL
- en: Uniformity in the order and referencing of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniformity in function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Straightening out problems with array de-referencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the ability to mix function calls and array de-referencing in a single
    command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the original proposal for PHP 7 uniform variable syntax,
    have a look here: [https://wiki.php.net/rfc/uniform_variable_syntax](https://wiki.php.net/rfc/uniform_variable_syntax).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now examine how the uniform variable syntax initiative affects PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: How does uniform variable syntax affect PHP 8?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The uniform variable syntax initiative was extremely successful in all versions
    of PHP 7, and the transition was relatively smooth. There were a few areas not
    upgraded to this standard, however. Accordingly, a new proposal was introduced
    to address these holdouts. Uniformity has been introduced to the following in
    PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: De-referencing interpolated strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inconsistent de-referencing of magic constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency in class-constant dereferencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced expression support for `new` and `instanceof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before getting into examples of each of these areas, we must first define what
    is meant by *de-referencing*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining de-referencing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**De-referencing** is the process of extracting the value of an array element
    or object property. It also refers to the process of obtaining the return value
    for an object method or function call. Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `$alpha` alpha contains 26 elements representing the letters `A` through
    `Z`. This example de-references the array, extracting the 7th and 15th elements,
    producing an output of `PHP`. De-referencing a function or method call simply
    means executing the function or method and accessing the results.
  prefs: []
  type: TYPE_NORMAL
- en: De-referencing interpolated strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next example is a bit crazy, so please follow closely. The following example
    works in PHP 8, but does not work in PHP 7 or earlier versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, two strings, `$alpha` and `$num`, are interpolated using double
    quotes inside a `foreach()` loop. Here is the output from PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code in PHP 8 produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The conclusion is that PHP 7 is not consistent in how it de-references interpolated
    strings, whereas PHP 8 demonstrates improved consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Inconsistent de-referencing of magic constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In PHP 7 and earlier versions, constants can be de-referenced whereas magic
    constants cannot. Here is a simple example that produces the last three letters
    of the current file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the result in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, the point here is that de-referencing operations in PHP 8 are applied
    consistently (which is a good thing!).
  prefs: []
  type: TYPE_NORMAL
- en: Consistency in class-constant de-referencing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A related issue arises when attempting to de-reference class constants. To
    best illustrate the problem, imagine that we have three classes. The first class,
    `JsonResponse`, produces the data in **JavaScript Object Notation** (**JSON**)
    format, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The second class, `SerialResponse`, produces a response using the built-in
    PHP `serialize()` function, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a `Test` class is able to produce either response, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''ve seen in earlier examples in this section, results in earlier versions
    of PHP are inconsistent. A call to `Test::getJson($data)` works fine. However,
    a call to `Test::getText($data)` produces this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Exactly the same code under PHP 8 produces consistent results for both method
    calls defined in the class shown previously, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, in PHP 8, class constants are now de-referenced in a uniform manner,
    allowing you to produce cleaner code. Now, let's have a look at how PHP 8 allows
    you to use expressions in more places than before.
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced expression support for new and instanceof
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the joys associated with PHP 7 programming is the ability to use arbitrary
    PHP expressions just about anywhere. In this simple example, note the use of a
    `$_GET[''page''] ?? ''home''` arbitrary expression inside the square brackets
    referencing the `$nav` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7 and earlier versions, however, the same thing is not possible if the
    expression involves the `new` or `instanceof` keyword. As you may have guessed,
    this inconsistency has been addressed in PHP 8\. The following is now possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This code example shows the use of an arbitrary expression inside the array
    reference, used in conjunction with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on uniform variable syntax updates in PHP 8, see this
    article: [https://wiki.php.net/rfc/variable_syntax_tweaks](https://wiki.php.net/rfc/variable_syntax_tweaks).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at new techniques available for string and array handling
    in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Learning new array- and string-handling techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been a number of improvements in PHP 8 array- and string-handling
    techniques. Although there is insufficient space in this book to cover every single
    enhancement, we will examine the more significant improvements in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with array_splice()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_splice()` function is a cross between `substr()` and `str_replace()`:
    it lets you replace a subset of one array with another. Its use gets awkward,
    however, when all you need to do is replace the last part of the array with something
    different. A quick look at the syntax reveals where it starts to get inconvenient—the
    `replacement` parameter is preceded by the `length` parameter, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array_splice(&$input,$offset[,$length[,$replacement]]):array`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, developers first run `count()` on the original array and use
    that for the `length` argument, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array_splice($arr, 3, count($arr), $repl);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 8, the third argument can be `NULL`, saving an extra call to `count()`.
    If you take advantage of the **named arguments** feature of PHP 8, the code becomes
    even more concise. Here''s the same code snippet written for PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '`array_splice($arr, 3, replacement: $repl);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example that clearly demonstrates the difference between PHP
    7 and PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code in PHP 7, note the result of the last `var_dump()` instance,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In PHP 7, providing a `NULL` value to the third argument of `array_splice()`
    causes the two arrays to be simply merged, which is not the desired result!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, have a look here at the output from the last `var_dump()`, but this time
    running under PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, having the third parameter as `NULL` has the same functionality
    as providing an array `count()` for the third argument to `array_splice()` when
    running under PHP 8\. You will also note that the total number of array elements
    is `5` in PHP 8, whereas the total was `7` from the same code running in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: Using array_slice()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `array_slice()` function operates on arrays as much as `substr()` does on
    strings. The big problem with earlier versions of PHP is that internally, the
    PHP engine iterated through the *entire array sequentially* until the desired
    offset was reached. If the offset is large, performance suffers in direct correlation
    to the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP 8, a different algorithm is used that does not require sequential array
    iteration. As the size of the array increases, performance improvement becomes
    increasingly evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example shown here, we first build a massive array of approximately
    6 million entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we iterate through the array, taking random offsets all greater than
    `999,999`. This forces `array_slice()` to work hard, and shows a significant performance
    difference between PHP 7 and 8, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output when running the code under PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – array_slice() example using PHP 7'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.5_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – array_slice() example using PHP 7
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice here the massive performance difference when running the same code under
    PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – array_slice() example using PHP 8'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.6_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – array_slice() example using PHP 8
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The new algorithm is only effective if the array does not contain elements with
    a `NULL` value. If the array contains `NULL` elements, the old algorithm is triggered,
    and a sequential iteration occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now turn our attention to some excellent new string functions.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting string beginning, middle, and end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something PHP developers deal with on a constant basis is having to check for
    sets of characters that appear at the beginning, middle, or end of a string. The
    problem with the current set of string functions is that they are *not designed*
    to deal with the presence or absence of a substring. Rather, the current set of
    functions is designed to determine the *position* of a substring. This, in turn,
    can then be interpolated in a Boolean manner to determine the presence or absence
    of a substring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this approach is summarized in a famous quote attributed to
    Sir Winston Churchill:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Golf is a game whose aim is to hit a very small ball into an ever smaller
    hole, with weapons singularly ill-designed for the purpose."'
  prefs: []
  type: TYPE_NORMAL
- en: – *Winston S. Churchill*
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at three incredibly useful new string functions that address
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: str_starts_with()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first function we examine is `str_starts_with()`. To illustrate its use,
    consider a code example where we''re looking for `https` at the beginning and
    `login` at the end, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the introduction to this section, in order to determine if
    a string starts with `https`, we need to invoke both `substr()` and `strlen()`.
    Neither function is designed to give us the desired answer. Further, having to
    use both functions introduces inefficiency in our code and results in a needless
    resource utilization increase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same code can be written in PHP 8, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: str_ends_with()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a similar vein to `str_starts_with()`, PHP 8 has introduced a new function,
    `str_ends_with()`, that can be used to determine if the end of a string matches
    some value. To illustrate the usefulness of this new function, consider old PHP
    code using `strrev()` and `strpos()`, which might appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In an operation, both `$url` and `$end` need to be reversed, a process that
    can gets progressively more expensive in direct proportion to the length of the
    string. Also, as mentioned earlier, the purpose of `strpos()` is to return the
    *position* of a substring, not to determine its presence or absence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same functionality is achieved as follows in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: str_contains()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last function in this context is `str_contains()`. As we've discussed, in
    PHP 7 and earlier there was no specific PHP function that tells you whether or
    not a substring exists within a string, aside from `preg_match()`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using `preg_match()`, as we've all been warned time and again,
    is performance degradation. In order to process a *regular expression*, `preg_match()`
    needs to first analyze the pattern. It then has to perform a second pass in order
    to determine which part of the string matches the pattern. This is an enormously
    expensive operation in terms of time and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When we mention that an operation is *expensive* in terms of time and resources,
    please bear in mind that if your script only consists of a few dozen lines of
    code and/or you are not repeating the operation thousands of times in a loop,
    chances are that you will not see any significant performance gains using the
    new functions and techniques described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, a PHP script uses `preg_match()` to search the *GeoNames*
    project database of cities greater than `15,000` in population for any listing
    containing a reference to `London`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output when running in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Scanning GeoNames file using preg_match()'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.7_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Scanning GeoNames file using preg_match()
  prefs: []
  type: TYPE_NORMAL
- en: 'The same output can be achieved in PHP 8 by replacing the `if` statement with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Scanning GeoNames file using str_contains()'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.8_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Scanning GeoNames file using str_contains()
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the two different output screens, the PHP 8 code runs for
    approximately `0.14` microseconds compared with `0.19` microseconds in PHP 7\.
    This by itself is not a massive performance gain but, as was mentioned earlier
    in this section, more data, longer strings, and more iterations magnify any small
    performance gain you achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Small code modifications that achieve small performance
    gains eventually add up to a large overall performance gain!'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on the *GeoNames* open source project, go to their website
    here: [https://www.geonames.org/](https://www.geonames.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea how and where to use three new string functions. You are
    also able to write more efficient code, using functions specifically designed
    to detect the presence or absence of substrings at the beginning, middle, or end
    of target strings.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we end this chapter with a little bit of fun by having a look at the
    new SQLite3 authorizer.
  prefs: []
  type: TYPE_NORMAL
- en: Securing SQLite databases with the authorizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many PHP developers prefer to use **SQLite** as their database engine rather
    than a separate database server such as PostgreSQL, MySQL, Oracle, or MongoDB.
    The reasons for using SQLite are many, but often come down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLite is a file-based database**: You don''t have to install a separate
    database server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It''s easy to distribute**: The only requirement is that the target server
    needs to have the `SQLite` executable installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQLite is lightweight**: Since there''s no constantly running server, it
    takes fewer resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, the downside is that it's not very scalable. If you have a fairly
    substantial amount of data to deal with, it's probably better to install a more
    powerful database server. The other potentially major drawback is that SQLite
    has no security, covered in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about SQLite, please have a look at their main web page:
    [https://sqlite.org/index.html](https://sqlite.org/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute... no security?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Yes, you heard correctly*: by default, by its very design, SQLite has no security.
    That, of course, is the reason many developers like to use it: having no security
    makes it super-easy to work with!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample block of code that connects to a SQLite database and conducts
    a simple query of the `geonames` table. It returns a list of cities in India where
    the population is greater than 2 million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Most other database extensions require at least a username and password when
    establishing a connection. As you can see in the preceding code snippet, the `$sqlite`
    instance is created with absolutely no security involved: no username or password.'
  prefs: []
  type: TYPE_NORMAL
- en: What's a SQLite authorization callback?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SQLite3 engine now allows you to register an **authorization callback**
    to your SQLite database connection. The callback routine is invoked when sending
    a **prepared statement** to the database for compilation. Here is the generic
    syntax to set an authorization callback on a `SQLite3` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$sqlite3->setAuthorizer(callable $callback);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback is expected to return one of three `SQLite3` class constants,
    each of which represents an integer value. If the callback returns anything other
    than one of these three values, `SQLite3::DENY` is assumed and the operation does
    not proceed. The table shown next lists the three expected return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.2 – Valid SQLite authorization callback return values'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_2.2_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.2 – Valid SQLite authorization callback return values
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've got an idea about the callback, let's have a look at how it
    gets invoked.
  prefs: []
  type: TYPE_NORMAL
- en: What gets sent to the callback?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The callback is invoked when you execute `$sqlite->prepare($sql)`. At that
    time, the SQLite3 engine passes between one to five parameters to the callback.
    The first argument is an **action code** that determines the nature of the remaining
    arguments. Accordingly, the following might be an appropriate generic function
    signature for the callback that you ultimately define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The action codes for the most part mirror the SQL statement to be prepared.
    The following table summarizes a number of more common action codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.3 – Common action codes sent to callback'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Table_2.3_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.3 – Common action codes sent to callback
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to have a look at a usage example.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizer usage example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we''re allowed to read from the SQLite `geonames`
    table, but not to insert, delete, or update:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining an `auth_callback.php` include file in the `/repo/ch02/includes/`
    directory. In the `include` file, we first define constants that are used in the
    callback, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The way the **access control list** (**ACL**) works is that the primary outer
    key is the user (for example, `admin` or `guest`); the secondary key is the table
    (for example, `users` or `geonames`); and the value is an array of `SQLite3` action
    codes allowed for this user and table.
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown previously, the `admin` user has all rights to both tables,
    whereas the `guest` user can only read from the `geonames` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the actual authorization callback function. The first thing
    in the function we need to do is set the default return value to `SQLite3::DENY`.
    We also check to see if the action code is `SQLite3::SELECT`, in which case we
    simply return `OK`. This action code is issued when a `SELECT` statement is first
    processed and does not provide any information on tables or columns. The code
    can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If the action code is anything other than `SQLite3::SELECT`, we need to first
    determine which table is involved before we can make a decision to allow or deny
    the action. The table name is reported as the second argument provided to our
    callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is the perfect time to use a *variadics operator* as we are unsure exactly
    how many parameters might be passed. However, for the major operations of concern
    (for example, `INSERT`, `UPDATE`, or `DELETE`), what is placed into the first
    position in `$args` is the table name. Otherwise, we get the table name from the
    session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In a like manner, we retrieve the username from the session, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Next, we check to see if the user is defined in the ACL, and after that, if
    the table is assigned rights for this user. If the action code given is in the
    array associated with the user and table combination, `SQLite3::OK` is returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then store the table name in the session and return the status code, as
    illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We now turn our attention to the calling program.
  prefs: []
  type: TYPE_NORMAL
- en: 'After including the PHP file defining the authorization callback, we simulate
    acquiring the username by accepting a command-line parameter, a **Uniform Resource
    Locator** (**URL**) parameter, or simply assigning `admin`, as illustrated in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create two arrays and use `shuffle()` to make their order random.
    We build the username, email, and ID values from the randomized arrays, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the `SQLite3` instance and assign the authorization callback,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The SQL `INSERT` statement is now defined and sent to SQLite to be prepared.
    Note that this is when the authorization callback is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If the authorization callback denies the action, the statement object is `NULL`,
    so it''s best to use an `if()` statement to test its presence. If so, we then
    proceed to bind the value and execute the statement, as illustrated in the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm the results, we define a SQL `SELECT` statement to display the contents
    of the `users` table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Not all code is shown here. For complete code, please refer to `/repo/ch02/php8_sqlite_auth_admin.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result if we run the calling program, setting the user to `admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – SQLite3 authorization callback: admin user'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.9_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.9 – SQLite3 authorization callback: admin user'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the preceding screenshot shows us that the operation is successful
    as we are running as the `admin` user, with sufficient authorization privileges.
    Here is the output when the user is set to `guest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – SQLite3 authorization callback: guest user'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.10_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.10 – SQLite3 authorization callback: guest user'
  prefs: []
  type: TYPE_NORMAL
- en: The output shows us that the attempt to run `prepare()` is unsuccessful as we
    are running as a user who lacks sufficient authorization.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of this long-awaited feature. You now know how
    to add authorization to an otherwise insecure database technology.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Original pull request describing the addition of the SQLite authorizer: [https://github.com/php/php-src/pull/4797](https://github.com/php/php-src/pull/4797)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official SQLite documentation on the authorizer callback: [https://www.sqlite.org/c3ref/set_authorizer.html](https://www.sqlite.org/c3ref/set_authorizer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Action codes passed to the callback: [https://www.sqlite.org/c3ref/c_alter_table.html](https://www.sqlite.org/c3ref/c_alter_table.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full list of result codes: [https://www.sqlite.org/rescode.html](https://www.sqlite.org/rescode.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation on the `SQLite3` class: [https://www.php.net/sqlite3](https://www.php.net/sqlite3)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about a number of changes introduced by PHP 8 at
    the procedural level. You first learned about the new nullsafe operator, which
    allows you to considerably shorten any code in which a chain of object references
    might fail. You also learned how usage of the ternary operator and the variadics
    operator has been tightened and improved, and that the concatenate operator has
    been demoted in the order of precedence. This chapter also covered advantages
    and disadvantages of arrow functions, as well as how they can be used as a clean
    and concise alternative to anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Later sections in this chapter showed you how PHP 8 continues the trend toward
    uniform variable syntax first introduced in PHP 7\. You learned how remaining
    inconsistencies have been addressed in PHP 8, including interpolated string and
    magic constant de-referencing, as well as improvements in array and string handling
    that promise to make your PHP 8 cleaner, more concise, and more highly performant.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last section, you learned about a new feature that provides
    support for a SQLite authorization callback, allowing you to finally provide a
    degree of security when using SQLite as your database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about PHP 8 error-handling enhancements.
  prefs: []
  type: TYPE_NORMAL
