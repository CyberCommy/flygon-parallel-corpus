- en: Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic logging—logging allows you to keep track of what the software is doing,
    and it's usually unrelated to its output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging to file—when logging is frequent, it is necessary to store the logs
    on a disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging to Syslog—if your system has a Syslog daemon, you might want to log
    in to Syslog instead of using a standalone file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing arguments—when writing with command-line tools, you need parsing options
    for practically any tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive shells—sometimes options are not enough and you need a form of Read-Eval-Print
    Loop to drive your tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizing terminal text—to align the displayed output properly, we need to know
    the terminal window size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running system commands—how to integrate other third-party commands in your
    software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progress bar—how to show a progress bar in your text tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message boxes—how to display an OK/cancel message box in a text tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input box—how to ask for input in a text tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing a new tool, one of the first needs that arises is making it able
    to interact with the surrounding environment—to display results, track errors,
    and receive inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Users are accustomed to certain standard ways a command-line tool interacts
    with them and with the system, and following this standard might be time-consuming
    and hard if done from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: That's why the standard library in Python provides tools to achieve the most
    common needs in implementing software that is able to interact through a shell
    and through text.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to implement some forms of logging, so that
    our program can keep a log file; we will see how to implement both options-based
    and interactive software, and then we will see how to implement more advanced
    graphical output based on text.
  prefs: []
  type: TYPE_NORMAL
- en: Basic logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first requirements of a console software is for it to log what it
    does, that is, what's happened, and any warnings or errors. Especially when we
    are talking about long-term software or daemons running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, if you've ever tried to use the Python `logging` module, you've probably
    noticed that you can't get any output apart from errors.
  prefs: []
  type: TYPE_NORMAL
- en: That's because the default enabled level is `WARNING`, so that only warnings
    and worse are tracked. Little tweaks are needed to make logging generally available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logging` module allows us to easily set up the logging configuration through
    the `basicConfig` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our `logger` is properly configured, we can try using it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`logging.basicConfig` configures the `root` logger (the main logger, Python
    will use if no specific configuration for the used logger is found) to write anything
    at the `INFO` level or greater. This will allow us to show everything apart from
    the debugging messages. The `format` argument specifies how our logging messages
    should be formatted; in this case, we added the date and time, the name of the
    logger, the level at which we are logging, and the message itself. Finally, the
    `stream` argument tells the logger to write its output to the standard error.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `root` logger configured, any logging we pick that doesn't
    have a specific configuration will just end up using the `root` logger one.
  prefs: []
  type: TYPE_NORMAL
- en: So the next line, `logging.getLogger(__name__)`, gets a logger named similar
    to the Python module that it's executing. If you saved your code to a file, the
    logger will be named something such as `dosum` (given your file is named `dosum.py`);
    if you didn't, then the logger will be named `__main__`, as in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Python loggers are created the first time they are retrieved with `logging.getLogger`,
    and any subsequent call to `getLogger` will just return the already existing one.
    While, for a very simple program, the name won't matter much, in bigger software,
    it's usually a good idea to grab more than one logger, so that you can distinguish
    from which subsystem of your software the messages are coming.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering why we configured `logging` to send its output to `stderr`,
    instead of the standard output. This allows us to separate the output of our software
    (which is written to `stdout` through the print statements) from the logging information.
    This is usually a good practice because the user of your tool might need to call
    the output of your tool without all the noise generated by logging messages, and
    doing so allows us to call our script with something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We'll only get back the results, without all the noise, because we redirected
    `stderr` to `/dev/null`, which on Unix systems leads to throwing away all that
    was written to `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For long-running programs, logging to the screen is not a very viable option.
    After running the code for hours, the oldest logged messages will be lost, and
    even if they were still available, it wouldn't be very easy to read all the logs
    or search through them.
  prefs: []
  type: TYPE_NORMAL
- en: Saving logs to a file allows for unlimited length (as far as our disk allows
    it) and enables the usage of tools, such as `grep`, to search through them.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Python logging is configured to write to screen, but it's easy to
    provide a way to write to any file when logging is configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test `logging` to a file, we are going to create a short tool that computes
    up to the *n^(th)* Fibonacci number based on the current time. If it's 3:01 P.M.,
    we want to compute only 1 number, while if it's 3:59 P.M., we want to compute
    59 numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software will provide the computed numbers as the output, but we also want
    to log up to which number it computed and when it was run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is split into three sections: initializing logging, the `fibo` function,
    and the `main` function of our tool. We explicitly divided code this way because
    the `fibo` function might be used in other modules, and in such a case, we don''t
    want `logging` to be reconfigured; we just want to use the logging configuration
    that the program will provide. For that reason, the `logging.basicConfig` call
    is wrapped in `__name__ == ''__main__''` so that `logging` is only configured
    when the module is called directly as a tool and not when it''s imported by other
    modules.'
  prefs: []
  type: TYPE_NORMAL
- en: When multiple `logging.basicConfig` instances are called, only the first one
    will be considered. If we didn't wrap our logging configuration in `if` when imported
    by other modules, it might end up driving the whole software logging configuration,
    depending on the order the modules were imported in, which is something we clearly
    don't want.
  prefs: []
  type: TYPE_NORMAL
- en: Differently from our previous recipe, `basicConfig` is configured with the `filename`
    argument instead of the `stream` argument. This means `logging.FileHandler` will
    be created to handle the logging messages and the messages will be appended to
    that file.
  prefs: []
  type: TYPE_NORMAL
- en: The central part of the code is the `fibo` function itself, and the last part
    is a check to see whether the code was called as a Python script or imported as
    a module. When imported as a module, we just want to provide the `fibo` function
    and avoid running it, but when executed as a script, we want to compute the Fibonacci
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why I used two `if __name__ == '__main__'` sections;
    if you merge the two into one, the script will continue to work. But it's usually
    a good idea to ensure that `logging` is configured before trying to use it, or
    the result will be that we will end up using the `logging.lastResort` handler,
    which will just write to `stderr` until the logging is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to Syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix-like systems usually provide a way to gather logging messages through the
    `syslog` protocol, which allows us to separate the system storing the logs from
    the one generating them.
  prefs: []
  type: TYPE_NORMAL
- en: Especially in the context of applications distributed across multiple servers,
    this is very convenient; you certainly don't want to log into 20 different servers
    to gather all the logs of your Python application because it was running on multiple
    nodes. Especially for web applications, this is very common nowadays with cloud
    providers, so it's very convenient to be able to gather all the Python logs in
    a single place.
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly what using `syslog` allows us to do; we will see how to send
    the log messages to the daemon running on our system, but it's possible to send
    them to any system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this recipe doesn't need a `syslog` daemon to work, you will need one
    to check that it's properly working or the messages won't be readable. In the
    case of Linux or macOS systems, this is usually configured out of the box, but
    in the case of a Windows system, you will need to install a Syslog server or use
    a cloud solution. Many exist and a quick search on Google should provide you with
    some cheap or even free alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using a heavily customized solution for logging, it''s not possible to
    rely on `logging.basicConfig` anymore, so we will have to manually set up the
    logging environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If this worked properly, your message should be recorded by Syslog and visible
    when running the `syslog` command on macOS or with `tail` as `/var/log/syslog`
    on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `syslog` file path might change from distribution to distribution; if `/var/log/syslog` doesn't
    work, try `/var/log/messages` or refer to your distribution documentation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we relied on `dictConfig`, you noticed that our configuration is a bit more
    complex than in previous recipes. This is because we configured the bits that
    are part of the logging infrastructure ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you configure logging, you write your messages with a logger. By default,
    the system only has one logger: the `root` logger (the one you get if you call
    `logging.getLogger` without providing any specific name).'
  prefs: []
  type: TYPE_NORMAL
- en: The logger doesn't handle messages itself, as writing or printing log messages
    is something handlers are in charge of. Consequently, if you want to read the
    log messages you send, you need to configure a handler. In our case, we use `SysLogHandler`,
    which writes to Syslog.
  prefs: []
  type: TYPE_NORMAL
- en: Handler is then in charge of writing a message, but doesn't really get involved
    in how that message should be built/formatted. You noticed that apart your own
    message, when you log something, you also get the log level, logger name, timestamp,
    and a few details that are added by the logging system for you. Adding those details
    to the message is usually the formatter's work. The formatter takes all the information
    made available by the logger and packs them in a message that should be written
    by the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, your logging configuration can be very complex. You can
    set up some messages to go to a local file and some messages to go to Syslog and
    more that should be printed on screen. This would involve multiple handlers, which
    should know which messages they should threat and which they should ignore. Allowing
    this knowledge is the job of filters. Once you attach a filter to a handler, it's
    possible to control which messages should be saved by that handler and which should
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The Python logging system might now look very intuitive, and that's because
    it's a very powerful solution that can be configured in many ways, but once you
    understand the building blocks that are available, it's possible to combine them
    in very flexible ways.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing command-line tools, it's usually common to have it change behavior
    based on options provided to the executable. These options are usually available
    in `sys.argv` together with the executable name, but parsing them is not as easy
    as it might seem, especially when multiple arguments must be supported. Also,
    when an option is malformed, it's usually a good idea to provide a usage message
    to inform the user about the right way to use the tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `argparse.ArgumentParser` object is the primary object in charge of parsing
    command-line options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our command is called without any arguments, it will provide a short usage
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we provide the `-h` option, `argparse` will generate a complete usage guide
    for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the command will lead to the expected result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the `ArgumentParser.add_argument` method to populate the list of available
    options. For every argument, it's possible to also provide a `help` option, which
    will declare the `help` string for that argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Positional arguments are provided with just the name of the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `nargs` option tells `ArgumentParser` how many times we expect that argument
    to be specified, the `+` value means at least once or more than once. Then `type=int`
    tells us that the arguments should be converted to integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the numbers to which we want to apply the operation, we need to
    know the operation itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we specified an option (starts with a dash, `-`), which can be
    provided both as `-o` or `--operation`. We stated that the only possible values
    are `'add'`, `'sub'`, `'mul'`, or `'div'` (providing a different value will result
    in `argparse` complaining), and that the default value, if the user didn't specify
    one, is `add`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a best practice, our command prints only the result; it was convenient to
    be able to ask some logging about what it was going to do. For this reason, we
    provided the `verbose` option, which drives the logging level we enabled for our
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If that option is provided, we will just store that `verbose` mode is enabled
    (`action="store_true"` makes it so that `True` is stored in `opts.verbose`) and
    we will configure the `logging` module accordingly, such that our `log.info` is
    only visible when `verbose` is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can actually parse the command-line options and get the result
    back into the `opts` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the options available, we configure logging so that we can read
    the `verbose` option and configure it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once options are parsed and `logging` is configured, the rest is just actually
    performing the expected operation on the set of provided numbers and printing
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you mix command-line options with the *Dictionary with fallback* recipe in
    Chapter 1, *Containers and Data Structures*, you can extend the behavior of your
    tools to not only read options from the command line, but also from environment
    variables, which is usually very convenient when you don't have complete control
    over how the command is called but you can set environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, writing a command-line tool is not enough, and you need to be able
    to provide some sort of interactivity. Suppose you want to write a mail client.
    In this case, it's not very convenient to have to call `mymail list` to see your
    mail, or `mymail read` to read a specific mail from your shell, and so on. Furthermore,
    if you want to implement stateful behaviors—such as a `mymail reply` instance that
    should reply to the current mail you are viewing—this might not even be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive programs are better in these cases, and the Python standard library
    provides all the tools we need to write one through the `cmd` module.
  prefs: []
  type: TYPE_NORMAL
- en: We can try to write an interactive shell for our `mymail` program; it won't
    read real email, but we will fake the behavior enough to showcase a fully featured
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cmd.Cmd` class allows us to start interactive shells and implement commands
    based on them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting our script should provide a nice interactive prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As stated with documents, we should be able to read the list of emails, read
    a specific email, and reply to the currently open one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can rely on the more advanced send commands, which also provide autocompletion
    of recipients for our new emails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cmd.Cmd` loop prints the `prompt` we provided through the `prompt` class
    property and awaits a command. Anything we write after `prompt` is split and the
    first part is looked up against the list of methods provided by our own subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a command is provided, `cmd.Cmd.cmdloop` calls the associated method
    and then starts again.
  prefs: []
  type: TYPE_NORMAL
- en: Any method starting with `do_*` is a command, and the part after `do_` is the
    command name. Any docstring of the method implementing the command is then reported
    in our tool's documentation if the `help` command is used within the interactive
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cmd` class provides no facility to parse arguments for a command, so if
    your command has more than a single argument, your have to split them yourself.
    In our case, we relied on `shlex` so that the user has control over how the arguments
    should be split. This allowed us to parse subjects and messages while providing
    a way to include spaces in them. Otherwise, we would have no way to know where
    the subject ends and the message starts.
  prefs: []
  type: TYPE_NORMAL
- en: The `send` command also supports autocompleting recipients, through the `complete_send`
    method. If a `complete_*` method is provided, it is called by `Cmd` when *Tab*
    is pressed to autocomplete command arguments. The method receives the text that
    needs to be completed and some details about the whole line of text and the current
    position of the cursor. As nothing is done to parse the arguments, the position
    of the cursors and the whole line of text can help in providing different autocomplete
    behaviors for each argument. In our case, we could only autocomplete the recipient,
    so there was no need to distinguish between the various arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the `do_EOF` command allows a way to exit the command line
    when *Ctrl* + *D* is pressed. Otherwise, we would have to way to quit the interactive
    shell. That's a convention provided by `Cmd`, and if the `do_EOF` command returns
    `True`, it means that the shell can quit.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing terminal text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw the *Aligning text* recipe in [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml),
    *Text Management*, which showcased a possible solution to align text within a
    fixed space. The amount of space available was defined in a `COLSIZE` constant
    that was chosen to fit most terminals with three columns (most terminals fit 80
    columns).
  prefs: []
  type: TYPE_NORMAL
- en: But what happened if the user had a terminal window smaller than 60 columns?
    Our alignment would have been broken badly. Also, on very big windows, while the
    text wouldn't be broken, it would have looked too small compared to the window.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it's usually better to also take into consideration the size
    of the user terminal window whenever displaying text that should retain proper
    alignment properties.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shutil.get_terminal_size` function can give guidance on the terminal window
    size and provide a fallback for cases where it''s not available. We will adapt
    the `maketable` function from the *Aligning text* recipe of [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml), *Text
    Management* to account for terminal size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is possible to print any text in multiple columns and see it adapt to
    the size of your terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you try to resize you terminal window and rerun the script, you will notice
    that the text is now always aligned differently to ensure it fits the space available.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of relying on a constant for the size of a column, our `maketable` function
    now computes it by taking the terminal width (`term_size.columns`) and dividing
    it by the number of columns to show.
  prefs: []
  type: TYPE_NORMAL
- en: Three characters are always subtracted, because we want to account for the space
    consumed by the `|` separator.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the terminal (`term_size`) is fetched through `shutil.get_terminal_size`,
    which will look at `stdout` to check the size of the connected terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it fails to retrieve the size or something that is not a terminal is connected
    as the output, then a fallback value is used. You can check the fallback value
    is working as expected simply by redirecting the output of your script to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you open `output.txt`, you should see that the fallback of 80 characters
    was used as a file doesn't have any specified width.
  prefs: []
  type: TYPE_NORMAL
- en: Running system commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, especially when writing system tools, there might be work that
    you need to offload to another command. For example, if you have to decompress
    a file, in many cases, it might make sense to offload the work to `gunzip`/`zip`
    commands instead or trying to reproduce the same behavior in Python.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many ways in Python to handle this work, they all have subtle
    differences that might make the life of any developer hard, so it's good to have
    a generally working solution that tackles the most common issues.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining the `subprocess` and `shlex` modules allows us to build a solution
    that is reliable in most cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s easy to check that it works as expected both for successful and failing
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On my system, this properly lists the root of the filesystem and complains
    for a non-existing path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling the command itself is performed by the `subprocess.check_output` function,
    but before we can call it, we need to properly split the command in a list containing
    the command itself and its arguments. Relying on `shlex` allows us to drive and
    distinguish how arguments should be split. To see its effect, you can try to compare
    `run('ls / var')` with `run('ls "/ var"')` on any Unix-like system. The first
    will print a lot of files, while the second will complain that the path doesn't
    exist. That's because, in the first case, we actually sent two different arguments
    to `ls` (`/` and `var`), while in the second case, we sent a single argument (`"/
    var"`). If we didn't use `shlex`, there would have been no way to distinguish
    between the two cases.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the `stderr=subprocess.STDOUT` option then takes care of cases where
    the command fails (which we can detect because the `run` function will return
    a status that is not zero), allowing us to receive the failure description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heavy lifting of calling our command is then performed by `subprocess.check_output`,
    which, in fact, is a wrapper around `subprocess.Popen` that will do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawn the required command with `subprocess.Popen`, configured to write the
    output into a pipe, so that the parent process (our own program) can read from
    that pipe and grab the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawn threads to continuously consume from the content of the pipes opened to
    communicate with the child process. This ensures that they never fill up, as,
    if they did, the command we called would just block as it would be unable to write
    any more output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important thing to note is that our `run` function will look for an executable
    that can satisfy the requested command, but won't run any shell expression. So,
    it's not possible to send shell scripts to it. If that's required, the `shell=True`
    option can be passed to `subprocess.check_output`, but that's heavily discouraged
    because it allows the injection of shell code into our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to write a command that prints the content of a directory
    that the user choose; a very simple solution might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, what would happen if we allowed `shell=True` in `run` and the user provided
    a path such as `/var; rm -rf /`? The user might end up deleting the whole system
    disk, and while this is still limited by the fact that we are relying on `shlex`
    to split arguments, it's still not safe to go through a shell to just run a command.
  prefs: []
  type: TYPE_NORMAL
- en: Progress bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When doing work that requires a lot of time (usually anything that requires
    I/O to slower endpoints, such as disk or network), it's a good idea to let your
    user know that you are moving forward and how much work is left to do. Progress
    bars, while not precise, are a very good way to give our users an overview of
    how much work we have done so far and how much we have left to do.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipe steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The progress bar itself will be displayed by a decorator, so that we can apply
    it to any function for which we want to report progress with minimum effort:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need a function that actually does something for which we might want
    to report progress. For the sake of this example, it will be just a simple function
    that waits a specified amount of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now calling the decorated function should tell us how long it has waited and
    display a progress bar while waiting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'While the script is running, you should see your progress bar and the final
    result, looking something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the work is done by the `withprogressbar` function. It acts as a decorator,
    so we can apply it to any function with the `@withprogressbar` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: That is very convenient because the code that reports progress is isolated from
    the code actually doing the work, which allows us to reuse it in many different
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a decorator that interacts with the decorated function while the function
    itself is running, we relied on Python generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the decorated function (in our example, the `wait` function),
    we will be in fact calling `_func_with_progress` from our decorator. The first
    thing that function will do is call the decorated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As the decorated function contains a `yield progress` statement, any time it
    wants to display some progress (`yield i` from within the `for` loop in `wait`),
    the function will return `generator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time the generator faces a `yield progress` statement, we will receive
    it back as the return value of the next function applied to the generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can then display our progress and call `next(gen)` again so that the decorated
    function can move forward and return a new progress (the decorated function is
    currently paused at `yield` and won't process until we call `next` on it—that's
    why our whole code is wrapped in `while True:`, to let the function continue forever,
    until it finishes what it has to do).
  prefs: []
  type: TYPE_NORMAL
- en: Once the decorated function finished all the work it had to do, it will raise
    a `StopIteration` exception, which will contain the value returned by the decorated
    function in the `.value` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: As we want to propagate any returned value to the caller, we just return that
    value ourselves. This is especially important if the function that was decorated
    is supposed to return some result of the work it did, such as a `download(url)`
    function that is supposed to return a reference to the downloaded file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before returning, we print a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that anything that follows the progress bar won't overlap with
    the progress bar itself, but will be printed on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we are left with just displaying the progress bar itself. The core of
    the progress bar part of the recipe is based on just two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These two lines will ensure that our message is printed on the screen without
    moving to a new line like `print` normally does. Instead, this will move back
    to the beginning of the same line. Try replacing that `'\r'` with `'\n'` and you'll
    immediately see the difference. With `'\r'`, you see a single progress bar moving
    from 0-100%, while with `'\n'`, you will see many progress bars being printed.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `sys.stdout.flush()` is then required to ensure that the progress
    bar is actually displayed, as usually output is only flushed on a new line, and
    as we are just printing the same line over and over, it wouldn't get flushed unless
    we did it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to draw a progress bar and update it, the rest of the
    function is involved in computing the progress bar to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we compute `message`, which is what we want to show on screen. The message
    is computed without the progress bar itself, for the progress bar, we are leaving
    a `%s` placeholder so that we can fill it later on.
  prefs: []
  type: TYPE_NORMAL
- en: We do this so that we know how much space is left for the bar itself after we
    displayed the surrounding brackets and the percentage. That value is `bar_width`,
    which is computed by subtracting from the maximum screen width (retrieved with
    `shutil.get_terminal_size()` at the beginning of our function) from the size of
    our message. The three extra characters we have to add will address the space
    that was consumed by `%s` and `%%` in our message, which won't actually be there
    once the message is displayed to screen, as the `%s` will be replaced by the bar
    itself and the `%%` will resolve to a single `%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know how much space is available for the bar itself, we compute how
    much of that space should be filled with `''=''` (the already completed part of
    the work) and how much should be filled with empty space, `'' ''` (the part of
    the work that is yet to come). This is achieved by computing the size of the screen
    to fill and match the percentage of our progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know how much to fill with `''=''`, the rest is just empty spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can build our bar with filled equal signs and `spaceleft` empty spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the bar is ready, it will be injected into the message that is displayed
    onscreen through the usage of the `%` string formatting operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you noticed, I mixed two types of string formatting (`str.format` and `%`).
    I did so because I think it makes what's going on with the formatting clearer,
    instead of having to properly account for escaping on each formatting step.
  prefs: []
  type: TYPE_NORMAL
- en: Message boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While less common nowadays, there is still a lot of value in being able to create
    interactive character-based user interfaces, especially when just a simple message
    dialog with an OK button or an OK/cancel dialog is needed; you can achieve a better
    result by directing the user's attention to them through a nice-looking text dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `curses` library is only included, in Python for Unix systems, so Windows
    users might need a solution, such as CygWin or the Linux Subsystem for Windows,
    to be able to have a Python setup that includes `curses` support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make a `MessageBox.show` method which we can use to show a message
    box whenever we need it. The `MessageBox` class will be able to show message boxes
    with just OK or OK/cancel buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use it through the `MessageBox.show` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even use it to check for user choices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The message box is based on the `curses` library, which allows us to draw text-based
    graphics on the screen. When we use the dialog box, we will enter a full-screen
    text graphic mode, and as soon as we exit it, we will recover our previous terminal
    state.
  prefs: []
  type: TYPE_NORMAL
- en: That allows us to interleave the `MessageBox` class in more complex programs
    without having to write the whole program with `curses`. This is allowed by the
    `curses.wrapper` function that is used in the `MessageBox.show` class method to
    wrap the `MessageBox._show` method that actually shows the box.
  prefs: []
  type: TYPE_NORMAL
- en: The message to show is prepared in the `MessageBox` initializer, through the
    `MessageBox._build_message` method, to ensure that it wraps when it's too long
    and that multiple lines of text are properly handled. The height of the message
    box depends on the length of the message and the resulting number of lines, plus
    six lines that we always include to add borders (which consume two lines) and
    the buttons (which consume four lines).
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageBox._show` method then creates the actual box window, adds a border
    to it, and displays the message within it. Once the message is displayed, we enter `MessageBox._loop`,
    which will wait for the user choice between OK and cancel.
  prefs: []
  type: TYPE_NORMAL
- en: The `MessageBox._loop` method draws all the required buttons with their own
    borders through the `win.derwin` function. Each button is 10-characters wide and
    3-characters tall, and will display itself depending on the value of `allowedspace,` which
    reserves an equal portion of the box space to each button. Then, once the button
    box is drawn, it will check whether the currently displayed button is the selected
    one; if it is, then the label of the button is displayed with bold text. This
    allows the user to know the currently selected choice.
  prefs: []
  type: TYPE_NORMAL
- en: Once both buttons are drawn, we call `win.refresh()` to actually display on
    screen what we've just drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Then we wait for the user to press any key to update the screen accordingly;
    the left/right arrow keys will switch between the OK/cancel choices, and *Enter*
    will confirm the current choice.
  prefs: []
  type: TYPE_NORMAL
- en: If the the user changes the selected button (by pressing the left or right keys),
    we loop again and redraw the buttons. We only need to redraw the buttons because
    the rest of the screen has not changed; the window border and the message are
    still the same, so there is no need to draw over them. The content of the screen
    is always preserved unless a `win.erase()` method is called, so we never need
    to redraw parts of the screen we don't need to update.
  prefs: []
  type: TYPE_NORMAL
- en: By being smart about this, we could also avoid redrawing the buttons themselves.
    This is because only the cancel/OK text needs to be redrawn when it changes from
    bold to normal and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user presses the *Enter* key, we quit the loop and return the currently
    selected choice between OK and cancel. That allows the caller to act according
    to the user choice.
  prefs: []
  type: TYPE_NORMAL
- en: Input box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing console-based software, it is sometimes necessary to ask users
    to provide long text inputs that can't easily be provided through command options.
  prefs: []
  type: TYPE_NORMAL
- en: There are few examples of this in the Unix world, such as editing `crontab`
    or tweaking multiple configuration options at once. Most of them rely on starting
    a fully-fledged third-party editor, such as **nano** or **vim**, but it's possible
    to easily roll a solution that in many cases will suffice with just the Python
    standard library, such that our tools can ask long or complex user input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `curses` library is only included in Python for Unix systems, so Windows
    users might need a solution, such as CygWin or the Linux Subsystem for Windows,
    to be able to have a Python setup that includes `curses` support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python standard library provides a `curses.textpad` module that has the
    foundation of a multiline text editor with `emacs`, such as key bindings. We just
    need to extend it a little to add some required behaviors and fixes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can read input from the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even ask it to edit an existing text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything starts with the `TextInput._show` method, which prepares two windows;
    the first draws the help text (`'Insert your name:'` in our example) and a border
    box for the text area.
  prefs: []
  type: TYPE_NORMAL
- en: Once those are drawn, it creates a new window dedicated to `Textbox` as the
    textbox will be freely inserting, removing, and editing the content of that window.
  prefs: []
  type: TYPE_NORMAL
- en: If we have existing content (`content= argument`), the `TextInput._load` function
    takes care of inserting it into the textbox before moving forward with editing.
    Each character in the provided content is injected into the textbox window through
    the `Textbox._insert_printable_char` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then we can finally enter the edit loop (the `TextInput._edit` method), where
    we listen for key presses and react accordingly. Actually, most of the work is
    already done for us by `Textbox.do_command`, so we just need to forward the pressed
    key to it to insert the characters into our text or react to a special command.
    The only special part of this method is that we check for character 127, which
    is *Backspace*, and replace it with `curses.KEY_BACKSPACE`, as not all terminals
    send the same codes when the *Backspace* key is pressed. Once the character is
    handled by `do_command`, we can refresh the window so that any new text appears
    and we loop again.
  prefs: []
  type: TYPE_NORMAL
- en: When the user presses *Ctrl* + *G*, the editor will consider the text complete
    and will quit the edit loop. Before doing so, we call `Textbox.gather` to fetch
    the entire contents of the text editor and send it back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that the content is actually fetched from the content of
    the `curses` window. So, it actually includes all the empty space you can see
    on your screen. For this reason, the `Textbox.gather` method will strip empty
    space to avoid sending you back a response that is mostly empty space surrounding
    your text. This is quite clear if you try to write something that includes multiple
    empty lines; they will all be stripped together with the rest of the empty space.
  prefs: []
  type: TYPE_NORMAL
