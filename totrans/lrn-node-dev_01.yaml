- en: Getting Set Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll get your local environment set up for the rest of the
    book. Whether you're on macOS, Linux, or Windows, we'll install Node and look
    at exactly how we can run Node applications.
  prefs: []
  type: TYPE_NORMAL
- en: We'll talk about what Node is, why you would ever want to use it, and why you
    would want to use Node as opposed to something like Rails, C++, Java, or any other
    language that can accomplish similar tasks. By the end of this chapter, you will
    be running your very first Node application. It's going to be simple, but it is
    going to get us to the path to creating real-world production Node apps, which
    is the goal of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Node is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start talking about what Node is and why it's useful, you need to
    first install Node on your machine, because in the next couple of sections, we'll
    want to run a little bit of Node code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to get started, we just need two programsâ€”a browser, I'll be using Chrome
    throughout the book, but any browser will do, and Terminal. I'll use **Spotlight**
    to open up Terminal, which is what it's known as on my operating system.
  prefs: []
  type: TYPE_NORMAL
- en: If you're on Windows, look for the Command Prompt, you can search using the
    Windows key and then by typing `command prompt`, and on Linux, you're looking
    for the command line, although depending on your distribution it might be called
    Terminal or Command Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once you have that program open, you''ll see a screen, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4d7162c-aef9-40d4-98a9-ec1ea68fbca0.png)'
  prefs: []
  type: TYPE_IMG
- en: Essentially, it's waiting for you to run a command. We'll run quite a few commands
    from Terminal throughout the book. I'll discuss it in a few sections later, so
    if you've never used this before, you can start navigating comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js version confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the browser, we can head over to [nodejs.org](http://nodejs.org) to grab
    the installer for the latest version of Node(as shown here). In this book, we''ll
    use the most recent version, version 9.3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01739796-c861-4e5e-a192-0e22f6a8c399.png)'
  prefs: []
  type: TYPE_IMG
- en: It is important that you install a V8 version of Node.js. It doesn't have to
    be 4.0, it could be 1.0, but it is important it's on that V8 branch, because there
    is a ton of new features that come along with V8, including all of the features
    you might have come to love in the browser using ES6.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES6 is the next version of JavaScript and it comes with a lot of great enhancements
    we''ll be using throughout the book. If you look at the following image, Node.js
    Long Term Support Release Schedule ([https://github.com/nodejs/LTS](https://github.com/nodejs/LTS)),
    you can see that the current Node version is V8, out in April 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0386ded3-18cb-4911-a3fe-8efd5908b708.png)'
  prefs: []
  type: TYPE_IMG
- en: Before going further, I would like to talk about the Node release cycle. What
    I have in the preceding image is the official release cycle, this is released
    by Node. You'll notice that only next to the even Node numbers do you find the
    active LTS, the blue bar, and the maintenance bar. Now, LTS stands for long-term
    support, and this is the version that's recommended for most users. I'd recommend
    that you stick with the currently offered LTS option (Node v 8.9.4 LTS), though
    anything on the left-hand side will do, this is shown as the two green buttons
    on [nodejs.org](http://nodejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Now, as you can see, the major version numbers, bump every six months. Regardless
    of any sort of big overarching change, this happens like clockwork even if nothing
    drastic has changed. It's not like Angular where jumping from 1.0 to 2.0 was almost
    like using a completely different library. This is just not the case with Node,
    what you're getting from this book is the latest and greatest Node has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the version is confirmed and selected, all we have to do is to click the
    required version button on the Node website ([nodejs.org](http://nodejs.org))
    and download the installer. The installer is one of those basic *click Next a
    few times and you''re done* type of installers, there''s no need to run any fancy
    commands. I''ll start the installer. As shown in the following screenshot, it''ll
    just ask a few questions, then let''s click on Next or Continue through all of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d793ed5-bdc8-43e9-80af-9c6e539d4a72.png)'
  prefs: []
  type: TYPE_IMG
- en: You might want to specify a custom destination, but if you don't know what that
    means, and you don't usually do it when installing programs, skip that step too.
    Here, in the next screenshot, you can see that I'm using just 58.6 MB, no problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll run the installer by entering my password. And once I enter my password,
    it should really only take a couple of seconds to get Node installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83317cab-1d71-4aaf-ba99-43b150100919.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, we have a message that says The installation
    was completed successfully, which means we are good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17dde6f1-27e8-43e8-b7ba-d3f342d8261b.png)'
  prefs: []
  type: TYPE_IMG
- en: Verifying installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Node has been installed successfully, we can go ahead and verify that
    by running Node from Terminal. Inside Terminal, I''ll shut it down by going to
    Quit Terminal and open it up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef346e4a-2e45-4758-9eac-3c7d3a12bada.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason I'm opening it up is because we've installed a new command, and some
    Terminals require a restart before they will be able to run that new command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we restarted things and we can run our brand new command so, we''ll
    type it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing in this command is we're running the Node command, and we're
    passing in what's called a **flag**, a hyphen sign followed by a letter. It could
    be `a`, it could be `j`, or in our case it's `v`. This command will print the
    version of Node currently installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/624d0bbe-8758-48a9-a8d5-667582827385.png)'
  prefs: []
  type: TYPE_IMG
- en: If you try to run a command that doesn't exist, such as `nodeasdf`, you'll see
    command not found. If you see this, it usually means the Node installer didn't
    work correctly, or you haven't run it in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: In our case though, running Node with the `v` flag should result in a number.
    In our case, it's version 9.3.0\. If you do have Node installed, and you see something
    like the following screenshot, then you are done. In the next section, we'll start
    exploring exactly what Node is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6ad6c47-19b7-41ae-b798-a6cd09c51270.png)'
  prefs: []
  type: TYPE_IMG
- en: What is Node?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node came about when the original developers took JavaScript, something you
    could usually only run inside the browser, and they let it run on your machine
    as a standalone process. This means that we could create applications using JavaScript
    outside the context of the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Now, JavaScript previously had a limited feature set. When I used it in the
    browser, I could do things such as update the URL and remove the Node logo, adding
    click events or anything else, but I couldn't really do much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Node, we now have a feature set that looks much more similar to other
    languages, such as Java, Python, or PHP. Some of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can write Node applications using the JavaScript syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can manipulate your filesystem, creating and removing folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create query databases directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can even create web servers using Node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were things that were not possible in the past, and they are because of
    Node.
  prefs: []
  type: TYPE_NORMAL
- en: Now, both Node and the JavaScript that gets executed inside of your browser,
    they're both running on the exact same engine. It's called the V8 JavaScript runtime
    engine. It's an open source engine that takes JavaScript code and compiles it
    into much faster machine code. And that's a big part of what makes Node.js so
    fast.
  prefs: []
  type: TYPE_NORMAL
- en: Machine code is low-level code that your computer can run directly without needing
    to interpret it. Your machine only knows how to run certain types of code, for
    example, your machine can't run JavaScript code or PHP code directly without first
    converting it into low-level code.
  prefs: []
  type: TYPE_NORMAL
- en: Using this V8 engine, we can take our JavaScript code, compile it to much quicker
    machine code, and execute that. This is where all those new features come in.
    The V8 engine is written in a language called C++. So if you want to extend the
    Node language, you don't write Node code, you write C++ code that builds off of
    what V8 already has in place.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll not be writing any C++ code in this book. This book is not about
    adding onto Node, it is about using Node. So, we will only be writing JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of JavaScript code, let's start writing some inside Terminal. Now,
    throughout the book, we'll be creating files and executing those files, but we
    can actually create a brand new Node process by running the `node` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referring to the following screenshot, I have a little right caret, which is
    waiting for JavaScript Node code, not a new command-prompt command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5947e1b-5bd5-472e-993d-6c281a8324d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that I can run something like `console.log`, which, as you probably
    already know, logs a message to the screen. `log` is a function, so I''ll call
    it as such, opening and closing my parentheses, and passing in a string inside
    two single quotes, a message `Hello world!,` as shown in the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print Hello world to the screen. If I hit *e*n*ter*, Hello world!
    prints just like you''d expect, as shown in the following code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baf96c0b-f956-42f2-9fd4-1ae1d93d86c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, what actually happened behind the scenes? Well, this is what Node does.
    It takes your JavaScript code, it compiles it into machine code, and executes
    it. In the preceding code, you can see it executed our code, printing out Hello
    world!. Now, the V8 engine is running behind the scenes when we execute this command,
    and it's also running inside the Chrome browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I open up the developer tools in Chrome by going to Settings | More Tools
    | Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c50b749f-f331-445c-a2cf-a4e5effb477a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can ignore most of the things. I''m just looking for the Console tab, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46808206-8003-411c-8dca-2745900d99a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot showing the console is a place where we can run some
    JavaScript code. I can type the exact same command, `console.log(''Hello world!'');`
    and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/608f3133-f3d0-4562-9a9b-65c76466c07a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, Hello world! prints to the screen,
    which is the exact same result we got when we ran it up earlier using Terminal.
    In both cases, we're running it through the V8 engine, and in both cases the output
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we already know that the two are different. Node has features such as filesystem
    manipulation, and the browser has features such as manipulating what's shown inside
    the window. Let's take a quick moment to explore their differences.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between JavaScript coding using Node and in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the browser, you''ve probably used `window` if you''ve done any JavaScript
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c86d2ba0-91d4-4829-81fc-5471adbb8604.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Window is the global object, it stores basically everything you have access
    to. In the following screenshot, you can see things such as array, we have all
    sorts of CSS manipulation and Google Analytics keywords; essentially every variable
    you create lives inside Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29a97655-4da3-4dd9-b5ae-fdafb9a1f4dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have something similar inside Node called `global`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cb4f89c-3e2f-4e20-bdfd-2d67697b1e46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s not called `window` because there is no browser window in Node, thus
    it is called `global`. The `global` object stores a lot of the same things as
    `window`. In the following screenshot, you can see methods that might be familiar,
    such as `setTimeout` and `setInterval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/586f7689-f17e-430e-8b70-a9c8c0f411c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at this code screenshot, we have most of the things that are defined
    inside the window, with some exceptions, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddde7001-804c-4a88-a11f-b0c14722b083.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, inside the Chrome browser, I also have access to `document`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9ca1af3-26a5-41f2-8d40-a0c092e1d6e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `document` object stores a reference to the **Document Object Model** (**DOM**)
    in the Node website. The `document` object shows exactly what I have inside the
    browser''s viewport, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f4e6fb3-b941-4b3a-b829-06187cf3fef4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can make changes to the document to update what gets shown up on the browser''s
    viewport. Now, obviously we don''t have this HTML `document` inside Node, but
    we do have something similar, which is called `process`. You can view it by running
    process from Node, and in the following screenshot, we have a lot of information
    about the specific Node process that''s being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dafb06f4-45b7-4327-95e0-ce6f3ac2900f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s also methods available here to shut down the current Node process.
    What I''d like you to do is run the `process.exit` command, passing in as an argument
    the number zero, to say that things exited without error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run this command, you can see I''m now back at the command prompt, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07a39364-2899-4019-a0b4-3900fcd8b12e.png)'
  prefs: []
  type: TYPE_IMG
- en: I've left Node, and I'm at a place where I can run any regular command prompt
    command, such as checking my Node version. I can always get back into Node by
    running `node`, and I can leave it without using the `process.exit` command by
    using *control* + *C* twice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb2936f8-a6d8-4880-9ca1-e3232ac78ae1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, I'm back at my regular command prompt. So, these are the notable differences,
    obviously inside the browser you have the viewable area, window gets changed to
    global, and a document basically becomes process. Now, obviously that's a generalization,
    but those are some of the big picture changes. We'll be exploring all the minutiae
    throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when someone asks you what is Node? You can say *Node's a JavaScript runtime
    that uses the V8 engine.* When they ask you what the V8 engine is, you can say
    *the V8 engine is an open source JavaScript engine written in C++ that takes JavaScript
    code and compiles it to machine code. It's used inside Node.js and it's used in
    the Chrome browser*.
  prefs: []
  type: TYPE_NORMAL
- en: Why use Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll cover the *why* behind Node.js. Why is it so good at
    creating backend apps? And why is it becoming so popular with companies such as
    Netflix, Uber and Walmart, who are all using Node.js in production?
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed since you're taking this course, when people want
    to learn a new backend language, more and more they're turning to Node as the
    language they want to learn. The Node skillset is in hot demand, for both frontend
    developers who need to use Node day to day to do things such as compile their
    applications, to engineers who are creating applications and utilities using Node.js.
    All of this has made Node the backend language of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at the homepage of Node, we have three sentences, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3212c22-2924-411a-ac57-d8e8db1d71b7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous section, we addressed the first sentence. We took a look at
    what Node.js is. There's only three sentences in the image, so in this section,
    we'll take a look at the second two sentences. We'll read them now, then we'll
    break it down, learning exactly why Node is so great.
  prefs: []
  type: TYPE_NORMAL
- en: The first sentence, Node.js uses an event-driven, non-blocking I/O model that
    makes it lightweight and efficient; we'll explore all of this now. The second
    sentence we'll explore at the end of the sectionâ€”Node.js' packaged ecosystem,
    npm, is the largest ecosystem of open source libraries in the world. Now, these
    two sentences have a ton of information packed into them.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go over a few code examples, we'll dive into some charts and graphs, and
    we'll explore what makes Node different and what makes it so great.
  prefs: []
  type: TYPE_NORMAL
- en: Node is an event-driven, non-blocking language. Now, what is I/O? I/O is something
    that your application does all of the time. When you're reading or writing to
    a database, that is I/O, which is short form for input/output.
  prefs: []
  type: TYPE_NORMAL
- en: This is the communication from your Node application to other things inside
    of the Internet of Things. This could be a database read and write request, you
    may be changing some files on your filesystem, or you may be making an HTTP request
    to a separate web server, such as a Google API for fetching a map for the user's
    current location. All of these use I/O, and I/O takes time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the non-blocking I/O is great. That means while one user is requesting
    a URL from Google, other users can be requesting a database file read and write
    access, they can be requesting all sorts of things without preventing anyone else
    from getting some work done.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking and non-blocking software development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go ahead and take a look at the differences between blocking and non
    blocking software development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d98b8e36-15cf-4a2e-8a6f-74ae6d3a7f03.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I have two files that we'll be executing. But before
    going to that, first let's explore how each of these files operates, the steps
    that are required in order to finish the program.
  prefs: []
  type: TYPE_NORMAL
- en: This will help us understand the big differences between blocking, which I have
    on the left side of the image, which is not what Node uses, and non-blocking is
    on the right side, which is exactly how all of our Node applications in the book
    are going to operate.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to understand the individual details, such as what require is,
    in order to understand what's going on in this code example. We'll be breaking
    things down in a very general sense. The first line on each code is responsible
    for fetching a function that gets called. This function will be our simulated
    I/O function that is going to a database, fetching some user data and printing
    it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the preceding code image. After we load in the function, both files
    try to fetch a user with an ID of `123`. When it gets that user, it prints it
    to the screen with the `user1` string first, and then it goes on and it fetches
    the user with `321` as the ID. And it prints that to the screen. And finally both
    files add up `1 + 2`, storing the result, which is 3, in the `sum` variable and
    print it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, while they all do the same thing, they do it in very different ways. Let''s
    break down the individual steps. In the following code image, we''ll go over what
    Node executes and how long it takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbf26905-e195-4d79-be4f-e6fd874a2483.png)'
  prefs: []
  type: TYPE_IMG
- en: You can consider the seconds shown in the preceding screenshot; it doesn't really
    matter, it's just to show the relative operating speed between the two files.
  prefs: []
  type: TYPE_NORMAL
- en: The working of blocking I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The blocking example can be illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edacad6f-9299-41ce-a728-a6172afbd4b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that happens inside our blocking example, as shown in the preceding
    screenshot, is that we fetch the user on line 3 in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, this request requires us to go to a database, which is an I/O operation
    to fetch that user by ID. This takes a little bit of time. In our case, we'll
    say it takes three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on line 4 in the code, we print the user to the screen, which is not
    an I/O operation and it runs right away, printing `user1` to the screen, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, it takes almost no time at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/400cbd6b-099e-48ab-81f4-291cf7d055f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, we wait on the fetching of `user2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/0888c6f8-da6d-4320-aafa-4f6692b70f96.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When `user2` comes back, as you might expect, we print it to the screen, which
    is exactly what happens on line 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add up our numbers and we print it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: None of this is I/O, so right here we have our sum printing to the screen in
    barely any time.
  prefs: []
  type: TYPE_NORMAL
- en: This is how blocking works. It's called blocking because while we're fetching
    from the database, which is an I/O operation, our application cannot do anything
    else. This means our machine sits around idle waiting for the database to respond,
    and can't even do something simple like adding two numbers and printing them to
    the screen. It's just not possible in a blocking system.
  prefs: []
  type: TYPE_NORMAL
- en: The working non-blocking I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our non-blocking example, this is how we'll be building our Node applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break this code example down line by line. First up, things start much
    the same way as we discussed in the blocking example. We''ll start the `getUser`
    function for `user1`, which is exactly what we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c170d20-73ec-417b-a51a-62f13963b8de.png)'
  prefs: []
  type: TYPE_IMG
- en: But we're not waiting, we're simply kicking off that event. This is all part
    of the event loop inside Node.js, which is something we'll be exploring in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice it takes a little bit of time; we''re just starting the request, we''re
    not waiting for that data. The next thing we do might surprise you. We''re not
    printing `user1` to the screen because we''re still waiting for that request to
    come back, instead we start the process of fetching our `user2` with the ID of
    `321`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6e86e00-25f0-453b-89f5-063adbfef43e.png)'
  prefs: []
  type: TYPE_IMG
- en: In this part of the code, we're kicking off another event, which takes just
    a little bit of time to do-it is not an I/O operation. Now, behind the scenes,
    the fetching of the database is I/O, but starting the event, calling this function
    is not, so it happens really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we print the sum. The sum doesn''t care about either of the two user
    objects. They''re basically unrelated, so there''s no need to wait for the users
    to come back before I print that `sum` variable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/989ab9b8-023d-4e73-acd5-ebf2d460f179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happens after we print the sum? Well, we have the dotted box, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47d4fbae-786a-469b-ba5d-eff9d7b767dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This box signifies the simulated time it takes for our event to get responded
    to. Now, this box is the exact same width as the box in the first part of the
    blocking example (waiting on user1), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b946502-ff7c-4c2e-8fe8-2be5a4ae7a62.png)'
  prefs: []
  type: TYPE_IMG
- en: Using non-blocking doesn't make our I/O operations any faster, but what it does
    do is it lets us run more than one operation at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the non-blocking example, we start two I/O operations before the half second
    mark, and in between three and a half seconds, both come back, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88a19684-fd14-41b8-89d3-9feeee9f4591.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the result here is that the entire application finishes much quicker. If
    you compare the time taken in executing both the files, the non-blocking version
    finishes in just over three seconds, while the blocking version takes just over
    six seconds. A difference of 50%. This 50% comes from the fact that in blocking,
    we have two requests each taking three seconds, and in non-blocking, we have two
    requests each taking three seconds, but they run at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the non-blocking model, we can still do stuff like printing the sum without
    having to wait for our database to respond. Now, this is the big difference between
    the two; blocking, everything happens in order, and in non-blocking we start events,
    attaching callbacks, and these callbacks get fired later. We're still printing
    out `user1` and `user2`, we're just doing it when the data comes back, because
    the data doesn't come back right away.
  prefs: []
  type: TYPE_NORMAL
- en: Inside Node.js, the event loop attaches a listener for the event to finish,
    in this case for that database to respond back. When it does, it calls the callback
    you pass in the non-blocking case, and then we print it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine this was a web server instead of the preceding example. That would
    mean if a web server comes in looking to query the database, we can't process
    other users' requests without spinning up a separate thread. Now, Node.js is single
    threaded, which means your application runs on one single thread, but since we
    have non-blocking I/O, that's not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: In a blocking context, we could handle two requests on two separate threads,
    but that doesn't really scale well, because for each request we have to beef up
    the amount of CPU and RAM resources that we're using for the application, and
    this sucks because those threads, are still sitting idle. Just because we can
    spin up other threads doesn't mean we should, we're wasting resources that are
    doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In the non-blocking case, instead of wasting resources by creating multiple
    threads, we're doing everything on one thread. When a request comes in, the I/O
    is non-blocking so we're not taking up any more resources than we would be if
    it never happened at all.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking and non-blocking examples using Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's run these examples in real time and see what we get. And we have the two
    files (`blocking` and `non-blocking` files) that we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We'll run both of these files, and I'm using the Atom editor to edit my text
    files. These are things we'll be setting up later in the section, this is just
    for your viewing purpose, you don't need to run these files.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `blocking` and `non-blocking` files, will both get run and they'll
    do similar things to those we did in the previous section, just in a different
    way. Both use I/O operations, `getUserSync` and `getUser`, that take five seconds
    apiece. The time is no different, it's just the order they execute in that makes
    the non-blocking version much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to simulate and show how things work, I'll add a few `console.log` statements
    as shown in the following code example, `console.log('starting user1')`, `console.log('starting
    user2')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will let us visualize how things work inside Terminal. By running `node
    blocking.js`, this is how we run files. We type `node` and we specify the filename,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When I run the file, we get some output. starting user1 prints to the screen
    and then it sits there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20b59ccb-f0e6-489a-bfcb-4d12c123e78c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we have the user1 object printing to the screen with the name Andrew,
    and starting user2 prints to the screen, as shown in the following code output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1042e6f6-cea0-4939-a0a6-f5ae5687895d.png)'
  prefs: []
  type: TYPE_IMG
- en: After that, the user2 object comes back around five seconds later with the name
    of Jen.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, our two users have printed to the screen,
    and at the very end our sum, which is 3, prints to the screen; everything works
    great.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that starting user1 was immediately followed by the finishing of user1,
    and starting user2 was immediately followed by the finishing of user2 because
    this is a blocking application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll run the non-blocking file, which I''ve called `non-blocking.js`.
    When I run this file, starting user1 prints, starting user2 prints, then the sum
    prints all back to back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2645e90-ed2b-47f9-bc54-0f86d99d7392.png)'
  prefs: []
  type: TYPE_IMG
- en: Around 5 seconds later, at basically the same time, user1 and user2 both print
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This is how non-blocking works. Just because we started an I/O operation doesn't
    mean we can't do other things, such as starting another one and printing some
    data to the screen, in this case just a number. This is the big difference, and
    this is what makes non-blocking apps so fantastic. They can do so many things
    at the exact same time without having to worry about the confusion of multi-threading
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move back into the browser and take a look at those sentences again
    in the Node website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5362f1ab-d1ae-4a24-805f-0c29032f702f.png)'
  prefs: []
  type: TYPE_IMG
- en: Node.js uses an event-driven, non-blocking I/O model that makes it lightweight
    and efficient, and we saw that in action.
  prefs: []
  type: TYPE_NORMAL
- en: Because Node is non-blocking, we were able to cut down the time our application
    took by half. This non-blocking I/O makes our apps super quick, this is where
    the lightweight and efficient comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Node community â€“ problem solving open source libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s go to the last sentence on the Node website, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77e0d3cd-2131-4e2b-9e51-24548fa6adaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Node.js' package ecosystem, npm, is the largest ecosystem of open-source libraries
    in the world. This is what really makes Node fantastic. This is the cherry on
    top-the community, the people every day developing new libraries that solve common
    problems in your Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Things such as validating objects, creating servers, and serving up content
    live using sockets. There's libraries already built for all of those so you don't
    have to worry about this. This means that you can focus on the specific things
    related to your application without having to create all this infrastructure before
    you can even write real code, code that does something specific to your apps use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, npm, which is available on [npmjs.org](http://npmjs.org), is the site
    we''ll be turning to for a lot of third-party modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b3348a0-e931-4ece-a38d-7fbee074a008.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're trying to solve a problem in Node that sounds generic, chances are
    that someone's already solved it. For example, if I want to validate some objects,
    let's say I want to validate that a name property exists and that there's an ID
    with a length of three. I could go into Google or go into npm; I usually choose
    Google, and I could Google search `npm validate object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I google that, I''ll just look for results from [npmjs.com](http://npmjs.com),
    and you can find the first three or so are from that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83bd9ccc-dcdd-4f5f-aff2-b74cc3b8c031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can click the first one, and this will let me explore the documentation and
    see if it''s right for me:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c77764e8-64dc-4c68-947c-e4e74dbb858a.png)'
  prefs: []
  type: TYPE_IMG
- en: This one looks great, so I can add it to my app without any effort.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll go through this process. Don't worry, I'm not going to leave you
    high and dry on how to add third-party modules. We'll be using a ton of them in
    the book because this is what real Node developers do. They take advantage of
    the fantastic community of developers, and that's the last thing that makes Node
    so great.
  prefs: []
  type: TYPE_NORMAL
- en: This is why Node has come to the position of power that it currently sits at,
    because it's non-blocking, meaning it's great for I/O applications, and it has
    a fantastic community of developers. So, if you ever want to get anything done,
    there's a chance someone already wrote the code to do it.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say you should never use Rails or Python or any other blocking
    language again, that is not what I'm getting at. What I'm really trying to show
    you is the power of Node.js and how you can make your applications even better.
    Languages like Python have things such as the library Twisted, which aims to add
    non-blocking features to Python. Though the big problem is all of the third-party
    libraries, as they are still written in a blocking fashion, so you're really limited
    as to which libraries you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Since Node was built non-blocking from the ground up, every single library on
    [npmjs.com](http://npmjs.com) is non-blocking. So you don't have to worry about
    finding one that's non blocking versus blocking; you can install a module knowing
    it was built from the ground up using a non blocking ideology.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, you'll be writing your very first app and running
    it from Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Different text editors for node applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I want to give you a tour of the various text editors you can
    use for this book. If you already have one you love using, you can keep using
    the one you have. There's no need to switch editors to get anything done in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you don't have one and you're looking for a few options, I always recommend
    using **Atom**, which you can find at [atom.io](http://atom.io). It's free, open
    source, and it's available on all operating systems, Linux, macOS, and Windows.
    It's created by the folks behind GitHub and it's the editor that I'll be using
    inside of this book. There's an awesome community of theme and plug-in developers
    so you really can customize it to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Now, aside from Atom there are a few other options. I've heard a lot of people
    talking about **Visual Studio Code**. It is also open source, free, and available
    on all operating systems. If you don't like Atom, I highly recommend you check
    this out, because I've heard so many good things by word of mouth.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we always have **Sublime Text**, which you can find at [sublimetext.com](http://sublimetext.com).
    Now, Sublime Text is not free and it's not open source, but it's a text editor
    that a lot of folks do enjoy using. I prefer Atom because it's very similar to
    Sublime Text, though I find it snappier and easier to use, plus it's free and
    open source.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you are looking for a more premium editor with all of the bells and
    whistles in IDE as opposed to a text editor, I always recommend **JetBrains**.
    None of their products are free, though they do come with a 30-day free trial,
    but they really are the best tools of the trade. If you find yourself in a corporate
    setting or you're at a job where the company is willing to pay for an editor,
    I always recommend that you go with JetBrains. All of their editors come with
    all of the tools you'd expect, such as version control integration, debugging
    tools, and deploying tools built in.
  prefs: []
  type: TYPE_NORMAL
- en: So, take a moment, download the one you want to use, play around with it, make
    sure it fits your needs, and if not, try another one.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World â€“ creating and running the first Node app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will be creating and running your very first Node app.
    Well, it will be a simple one. It'll demonstrate the entire process, from creating
    files to running them from Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Node application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step will be to create a folder. Every project we create will go live
    inside of its own folder. I'll open up the **Finder** on macOS and navigate to
    my desktop. What I'd like you to do is open up the desktop on your OS, whether
    you're on Linux, Windows, or macOS, and create a brand new folder called `hello-world`.
  prefs: []
  type: TYPE_NORMAL
- en: I don't recommend using spaces in your project file or folder names, as it only
    makes it more confusing to navigate inside of Terminal. Now, we have this `hello-world`
    folder and we can open it up inside of our editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I''ll use c*ommand* + *O* (*Ctrl* + *O* for Windows users) to open up,
    and I''ll navigate to the desktop and double-click my hello-world folder, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f41597b-8ced-4bd1-a43f-84b71697a3d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the left I have my files, which are none. So, let''s create a new one. I''ll
    make a new file in the root of the project, and we''ll call this one `app.js`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f21ffe8-49cf-414a-bfa2-e0cab5682fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: This will be the only file we have inside our Node application, and in this
    file we can write some code that will get executed when we start the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the future, we''ll be doing crazy stuff like initializing databases and
    starting web servers, but for now we''ll simply use `console.log`, which means
    we''re accessing the log property on the console object. It''s a function, so
    we can call it with parentheses, and we''ll pass in one argument as string, `Hello
    world!`. I''ll toss a semicolon on the end and save the file, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will be the first app we run.
  prefs: []
  type: TYPE_NORMAL
- en: Now, remember, there is a basic JavaScript requirement for this course, so nothing
    here should look too foreign to you. I'll be covering everything new and fresh
    inside of this course, but the basics, creating variables, calling functions,
    those should be something you're already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Node application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our `app.js` file, the only thing left to do is to run it,
    and we'll do that over in Terminal. Now, to run this program, we have to navigate
    into our project folder. If you're not familiar with Terminal, I'll give you a
    quick refresher.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always figure out where you are using `pwd` on Linux or macOS, or the
    `dir` command on Windows. When you run it, you''ll see something similar to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d60c2c2f-132e-4e91-9502-3ac7e918147c.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm in the `Users` folder, and then I'm in my user folder, and my user name
    happens to be `Gary`.
  prefs: []
  type: TYPE_NORMAL
- en: When you open Terminal or Command Prompt, you'll start in your user directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `cd` to navigate into the desktop, and here we are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f231b7e-2265-4f50-8652-6f360e5727ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we're sitting in the desktop. The other command you can run from anywhere
    on your computer is `cd /users/Gary/desktop`. And this will navigate to your desktop,
    no matter what folder you're located in. The command `cd desktop`, requires you
    to be in the user directory to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can start by cd-ing into our project directory, which we called `hello-world,`
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3490414c-477f-42bf-a6b8-59748150c574.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we''re in this directory, we can run at the `ls` command on Linux or Mac
    (which is the `dir` command on Windows) to see all of our files, and in this case
    we just have one, we have `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/533e8079-8292-4d97-a74d-ddb45f680e25.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the file we'll run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before you do anything else, make sure you are in the `hello-world` folder
    and you should have the `app.js` file inside. If you do, all we''ll do is run
    the `node` command followed by a space so we can pass in an argument, and that
    argument will be the filename, `app.js` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have this in place, hit *enter* and there we go, Hello world! prints
    to the screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dcd99b26-6948-473b-a370-a873bf676c13.png)'
  prefs: []
  type: TYPE_IMG
- en: And that is all it takes to create and run a very basic Node application. While
    our app doesn't do anything cool, we'll be using this process of creating folders/files
    and running them from Terminal throughout the book, so it's a great start on our
    way to making real-world Node apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched base with the concept of Node.js. We took a look
    at what Node is and we learned that it's built on top of the V8 JavaScript engine.
    Then we explored why Node has become so popular, its advantages and its disadvantages.
    We took a look at the different text editors we can choose from and, at the end,
    you created your very first Node application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive in and create our first app. I am really excited
    to start writing real-world applications.
  prefs: []
  type: TYPE_NORMAL
