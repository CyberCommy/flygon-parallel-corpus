- en: Chapter 8. Integrating C++ and the Unreal Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a class or `struct` as a blueprint variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating classes or structs that can be subclassed in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating functions that can be called in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating events that can be implemented in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing multi-cast delegates to Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ enums that can be used in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing class properties in different places in the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making properties accessible in the Blueprint editor graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to property – changed events from the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a native code Construction Script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new editor module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new toolbar buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new menu entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new editor window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Asset type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom context menu entries for Assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new console commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new graph pin visualizer for Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting types with custom **Details** panels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Unreal's primary strengths is that it provides programmers with the ability
    to create Actors and other objects that can be customized or used by designers
    in the editor. This chapter shows how. Following that, we will try to customize
    the editor by creating custom Blueprint and Animation nodes from scratch. We will
    also implement custom editor windows and custom **Details** panels for inspecting
    the types created by users.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class or struct as a blueprint variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types that you declare in C++ do not automatically get incorporated into Blueprint
    for use as variables. This recipe shows you how to make them accessible so that
    you can use custom native code types as Blueprint function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class using the editor. Unlike previous chapters, we are going
    to create an Object-based class. Object isn't visible in the default list of common
    classes, so we need to tick the **Show all classes** button in the editor UI,
    then select **Object**. Call your new **Object** subclass `TileType`.![How to
    do it…](img/00136.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following properties to the `TileType` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the editor, create a new Blueprint class based on `Actor`. Call it `Tile`.![How
    to do it…](img/00137.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the blueprint editor for `Tile`, add a new variable to the Blueprint.
    Check the list of types that you can create as variables, and verify that `TileType`
    is not there.![How to do it…](img/00138.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `BlueprintType` to the `UCLASS` macro as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Recompile the project, then return to the `Tile` blueprint editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now when you add a new variable to your actor, you can select `TileType` as
    the type for your new variable.![How to do it…](img/00139.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now established a "has-a" relationship between `Tile` and `TileType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now `TileType` is a Blueprint type that can be used as a function parameter.
    Create a new function on your `Tile` blueprint called `SetTileType`.![How to do
    it…](img/00140.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new input:![How to do it…](img/00141.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the input parameter's type to `TileType`.![How to do it…](img/00142.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can drag our `Type` variable into the viewport, and select **Set**.![How
    to do it…](img/00143.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the **Exec** pin and input parameter from `SetTileType` to the **Set**
    node.![How to do it…](img/00144.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For performance reasons, Unreal assumes that classes do not require the extra
    reflection code that is needed to make the type available to Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can override this default by specifying `BlueprintType` in our `UCLASS` macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the specifier included, the type is now made available as a parameter or
    variable in Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows that you can use a type as a function parameter in Blueprint
    if its native code declaration includes `BlueprintType`.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the moment, none of the properties that we defined in C++ are accessible
    to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Other recipes in this chapter deal with making those properties accessible so
    that we can actually do something meaningful with our custom objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes or structs that can be subclassed in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this book focuses on C++, when developing with Unreal, a more standard
    workflow is to implement core gameplay functionality as well as performance-critical
    code in C++, and expose those features to Blueprint to allow designers to prototype
    gameplay, which can then be refactored by programmers with additional Blueprint
    features, or pushed back down to the C++ layer.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common tasks, then, is to **mark up** our classes and structs
    in such a way that they are visible to the Blueprint system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class using the editor wizard; call it `BaseEnemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class specifier to the `UCLASS` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open the editor and create a new blueprint class. Expand the list to show all
    classes and select our `BaseEnemyclass` as the parent.![How to do it…](img/00145.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new Blueprint `EnemyGoblin` and open it in the Blueprint editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `UPROPERTY` macro we created earlier still aren't there because
    we haven't yet included the appropriate markup for them to be visible to Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous recipe demonstrated the use of `BlueprintType` as a class specifier.
    `BlueprintType` allows the type to be used as a type within the Blueprint editor
    (that is, it can be a variable or a function input/return value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we may want to create blueprints based on our type (using inheritance)
    rather than composition (placing an instance of our type inside an `Actor`, for
    example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why Epic provided `Blueprintable` as a class specifier. `Blueprintable`
    means a developer can mark a class as inheritable by the Blueprint classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have both `BlueprintType` and `Blueprintable` instead of a single combined
    specifier, because sometimes, you may only want partial functionality. For example,
    certain classes should be usable as variables, but performance reasons forbid
    creating them in Blueprint. In that instance, you would use `BlueprintType` rather
    than both specifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the other hand, perhaps we want to use the Blueprint editor to create new
    subclasses, but we don't want to pass object instances around inside the `Actor`
    blueprints. It is recommended to use `Blueprintable`, but omit `BlueprintType`
    in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, neither `Blueprintable` or `BlueprintType` specifies anything about
    the member functions or member variables contained inside our class. We'll make
    those available in later recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating functions that can be called in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While marking classes as `BlueprintType` or `Blueprintable` allows us to pass
    instances of the class around in Blueprint, or to subclass the type with a Blueprint
    class, those specifiers don't actually say anything about member functions or
    variables, and if they should be exposed to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to mark a function so that it can be called within
    Blueprint graphs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class using the editor. Call the actor `SlidingDoor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY` to the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the class implementation by adding the following to the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of your door out into the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have your `SlidingDoor` instance selected, then open the Level
    blueprint. Right-click on the empty canvas, and expand **Call function on Sliding
    Door 1**.![How to do it…](img/00146.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Door** section, then select the `Open` function.![How to do it…](img/00147.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the execution pin (white arrow) from `BeginPlay` to the white arrow on
    the `Open` node, as seen in the following screenshot:![How to do it…](img/00148.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your level, and verify that the door moves up as expected when `Open` is
    invoked on your door instance.![How to do it…](img/00149.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within the declaration of the door, we create a new function for opening the
    door, a Boolean to track if the door has been told to open, and a vector allowing
    us to precompute the target location of the door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also override the `Tick` actor function so that we can perform some behavior
    on every frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the constructor, we load in the cube mesh and scale it to represent our
    door.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also set `IsOpen` to a known good value of `false` and enable actor ticking
    by using `bCanEverTick` and `bStartWithTickEnabled`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two Booleans control if ticking can be enabled for this actor and if ticking
    starts in an enabled state respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Open` function, we calculate the target location relative to the
    door's starting position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also change the `IsOpen` Boolean from `false` to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the `IsOpen` Boolean is `true`, inside the `Tick` function, the door
    tries to move itself towards the target location using `SetActorLocation` and
    `Lerp` to interpolate between the current location and the destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    has a number of recipes relating to the spawning of actors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating events that can be implemented in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way that C++ can be more tightly integrated with Blueprint is the creation
    of functions that can have Blueprint implementations in native code. This allows
    for a programmer to specify an event, and invoke it, without needing to know anything
    about the implementation. The class can then be subclassed in Blueprint, and another
    member of the production team can implement a handler for the event without ever
    having to go near a line of C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `StaticMeshActor` class called `Spotter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the following functions are defined and overridden in the class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this code to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this to the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Compile and start the editor. Find your `Spotter` class in **Content Browser**,
    then left-click and drag a copy out into the game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play the level, you'll see the red line showing the trace that the
    `Actor` is performing. However, nothing will happen, because we haven't implemented
    our `OnPlayerSpotted` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to implement this event, we need to create a blueprint subclass of
    our `Spotter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on `Spotter` in **Content Browser**, and select **Create Blueprint
    class based on Spotter**. Name the class `BPSpotter`.![How to do it…](img/00150.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the Blueprint editor, click on the **Override** button in the **Functions**
    section of the **My Blueprint** panel:![How to do it…](img/00151.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **On Player Spotted**:![How to do it…](img/00152.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click and drag from the white execution pin on our event. In the context
    menu that appears, select and add a `Print String` node so that it is linked to
    the event.![How to do it…](img/00153.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level again, and verify that walking in front of the trace that the
    `Spotter` is using now prints a string to the screen.![How to do it…](img/00154.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the constructor for our `Spotter` object, we load one of the basic primitives,
    a cone, into our Static Mesh Component as a visual representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then rotate the cone so that it resembles a spotlight pointing to the *X*
    axis of the actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the `Tick` function, we get the actor's location, and then find a point
    200 units away from the actor along its local *X* axis. We call the parent class
    implementation of `Tick` using `Super::` to ensure that any other tick functionality
    is preserved despite our override.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We convert a local position into a world space position by first acquiring the
    Actor-to-World transform for the `Actor`, then using that to transform a vector
    specifying the position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The transform is based on the orientation of the root component, which is the
    static mesh component that we rotated during the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result of that existing rotation, we need to rotate the vector we want
    to transform. Given that we want the vector to point out of what was the bottom
    of the cone, we want a distance along the negative up axis, that is, we want a
    vector of the form (0,0,-d), where *d* is the actual distance away.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having calculated our end location for our trace, we actually perform the trace
    with the `SweepSingleByChannel` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the sweep is performed, we try to cast the resulting hit `Actor` into a
    pawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the cast was successful, we invoke our Implementable Event of `OnPlayerSpotted`,
    and the user-defined Blueprint code executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exposing multi-cast delegates to Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-cast delegates are a great way to broadcast an event to multiple objects
    who **listen** or **subscribe** to the event in question. They are particularly
    invaluable if you have a C++ module that generates events that potentially arbitrary
    Actors might want to be notified about. This recipe shows you how to create a
    multi-cast delegate in C++ that can notify a group of other Actors during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `StaticMeshActor` class called `King`. Add the following to the
    class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `UFUNCTION` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an instance of our multicast delegate to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add our mesh initialization to the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Die` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class called `Peasant`, also based on `StaticMeshActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a default constructor in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the function in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Open Blueprint and create a Blueprint class based on `APeasant` called `BPPeasant`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the blueprint, click and drag away from the white (execution) pin of
    your `BeginPlay` node. Type `get all`, and you should see **Get All Actors Of
    Class**. Select the node to place it in your graph.![How to do it…](img/00155.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the value of the purple (class) node to `King`. You can type `king` in the
    search bar to make locating the class in the list easier.![How to do it…](img/00156.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag from the blue grid (object array) node out into empty space and place a
    get node.![How to do it…](img/00157.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag away from the blue output pin of the get node, and place a Not Equal (object)
    node.![How to do it…](img/00158.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the red (bool) pin of the Not Equal node to a `Branch` node, and wire
    the execution pin of `Branch` to our `Get All Actors Of Class` node.![How to do
    it…](img/00159.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **True** pin of the branch to the **Bind Event to OnKing Death**
    node.![How to do it…](img/00160.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you will probably have to untick **Context Sensitive** in the context
    menu for the **Bind Event** node to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: Drag out the red pin on the **Bind Event** node, and select **Add Custom Event…**
    in the context menu which appears after you release your left mouse button.![How
    to do it…](img/00161.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your event a name, then connect the white execution pin to a new node named
    `Flee`.![How to do it…](img/00162.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that your Blueprint looks like the following figure:![How to do it…](img/00163.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a copy of your `King` class into the level, then add a few `BPPeasant`
    instances around it in a circle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the level Blueprint. Inside it, drag away from `BeginPlay,` and add a `Delay`
    node. Set the delay to **5** seconds.![How to do it…](img/00164.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your `King` instance selected in the level, right-click in the graph editor
    for the Level Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Call function on King 1**, and look in the `King` category for a function
    called `Die`.![How to do it…](img/00165.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Die`, then connect its execution pin to the output execution pin from
    the delay.![How to do it…](img/00166.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you play your level, you should see that the king dies after 5 seconds,
    and the peasants all wail and flee directly away from the king.![How to do it…](img/00167.jpeg)![How
    to do it…](img/00168.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new actor (based on `StaticMeshActor` for convenience, as it saves
    us having to declare or create a Static Mesh component for the `Actor` visual
    representation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare a dynamic multicast delegate using the `DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`
    macro. Dynamic multicast delegates allow an arbitrary number of objects to subscribe
    (listen) and unsubscribe (stop listening) so that they will be notified when the
    delegate is broadcast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The macro takes a number of arguments—the type name of the new delegate signature
    being created, the type of the signature's parameter, then the name of the signature's
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also add a function to `King` that will allow us to tell it to die. Because
    we want to expose the function to Blueprints for prototyping, we mark it as `BlueprintCallable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DECLARE_DYNAMIC_MULTICAST_DELEGATE` macro that we used earlier only declared
    a type; it didn't declare an instance of the delegate, so we do that now, referencing
    the type name that we provided earlier when invoking the macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dynamic multicast delegates can be marked `BlueprintAssignable` in their `UPROPERTY`
    declaration. This indicates to Unreal that the Blueprint system can dynamically
    assign events to the delegate that will be called when the delegate's `Broadcast`
    function is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, we assign a simple mesh to our `King` so that it has a visual representation
    in the game scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `Die` function, we call `Broadcast` on our own delegate. We specified
    that the delegate would have a parameter that is a pointer to the king which died,
    so we pass this pointer as a parameter to the broadcast function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want the king to be destroyed, rather than play an animation or other
    effect when it dies, you would need to change the delegate's declaration and pass
    in a different type. For example, you could use `FVector`, and simply pass in
    the location of the dead king directly so that the peasants could still flee appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Without this, you potentially could have a situation where the `King` pointer
    is valid when `Broadcast` is called, but the call to `Actor::Destroy()` invalidates
    it before your bound functions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Within our next `StaticMeshActor` subclass, called `Peasant`, we initialize
    the static mesh component as usual using, a different shape to the one that we
    used for the `King`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the implementation of the peasant's `Flee` function, we simulate the
    peasants playing sound by printing a message on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then calculate a vector to make the peasants flee by first finding a vector
    from the dead king to this peasant's location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We normalize the vector to retrieve a unit vector (with a length of 1) pointing
    in the same direction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling the normalized vector and adding it to our current location calculates
    a position at a fixed distance, in the exact direction for the peasant to be fleeing
    directly away from the dead king.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetActorLocation` is then used to actually teleport the peasants to that location.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you used a Character with an AI controller, you could have the `Peasant`
    pathfind to the target location rather than teleporting. Alternatively, you could
    use a `Lerp` function invoked during the peasant's `Tick` to make them slide smoothly
    rather than jump directly to the location.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components*, for more extended
    discussions about Actors and Components. [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    discusses events such as `NotifyActorOverlap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ enums that can be used in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums are commonly used in C++ as flags or inputs to switch statements. However,
    what if you want to pass an `enum` value to or from C++ from a Blueprint? Alternatively,
    if you want to use a `switch` statement in Blueprint that uses an `enum` from
    C++, how do you let the Blueprint editor know that your `enum` should be accessible
    within the editor? This recipe shows you how to make enums visible in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `StaticMeshActor` class called `Tree` using the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following code above the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `UPROPERTY` in the `Tree` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `Tree` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create a new Blueprint class, called `MyTree`, based on `Tree`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the blueprint editor for `MyTree`, click on the **Construction Script**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the empty window, and type `treetype`. There is a **Get number
    of entries in TreeType** node.![How to do it…](img/00169.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place it, and then connect its output pin to a **Random Integer** node.![How
    to do it…](img/00170.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of the random integer to a `ToByte` node.![How to do it…](img/00171.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Variables** section of the Blueprint panel, expand **Tree** and select
    **Type**.![How to do it…](img/00172.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag this into the graph, and select **Set** when you see a small context menu
    appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of the `ToByte` node to the input of the **SET Type** node.
    You'll see an extra conversion node automatically appear.![How to do it…](img/00173.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, connect the execution pin of **Construction Script** to the **SET Type**
    node's execution pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Blueprint should look like the following:![How to do it…](img/00174.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify that the blueprint is correctly functioning and randomly assigning
    a type to our tree, we are going to add some nodes to the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a `Print String` node after the **Event BeginPlay** event node.![How to
    do it…](img/00175.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a `Format Text` node, and connect its output to the input of the `Print
    String` node. A conversion node will be added for you.![How to do it…](img/00176.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Format Text` node, add My Type is {`0`}! to the textbox.![How to
    do it…](img/00177.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `Type` from the variables section of the Blueprint into the graph selecting
    **Get** from the menu.![How to do it…](img/00178.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an **Enum to Name** node to `Type` output pin.![How to do it…](img/00179.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Name output to the input pin on `Format Text` labelled `0`.![How
    to do it…](img/00180.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your Event Graph should now look like the following:![How to do it…](img/00181.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a few copies of your Blueprint into the level and hit **Play**. You should
    see a number of trees printing information regarding their type, verifying that
    types are being randomly assigned by the Blueprint code that we created.![How
    to do it…](img/00182.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, we use `StaticMeshActor` as the base class for our `Actor` so that
    we can easily give it a visual representation in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerated types are exposed to the reflection system using the `UENUM` macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We mark the `enum` as Blueprint-available using the `BlueprintType` specifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `enum` declaration is just the same as we would use in any other context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `Tree` requires a `TreeType`. Because *tree has tree-type* is the relationship
    we want to embody, we include an instance of `TreeType` in our `Tree` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, we need to use `UPROPERTY()` to make the member variable accessible
    to the reflection system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `BlueprintReadWrite` specifier to mark the property as having both
    get and set support within Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enumerated types require being wrapped in the `TEnumAsByte` template when used
    in `UPROPERTY`, so we declare an instance of `TEnumAsByte<TreeType>` as the Tree's
    `Type` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor changes for `Tree` are simply the standard load and initialize
    our static mesh component preamble used in other recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a Blueprint that inherits from our `Tree` class so that we can demonstrate
    the Blueprint-accessibility of the `TreeType enum`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to have the Blueprint assign a type to the tree at random when we create
    an instance, we need to use the Blueprint **Construction Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the **Construction Script**, we calculate the number of entries in the
    `TreeType enum`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We generate a random number, and use that as an index in the `TreeType enum`
    type to retrieve a value to store as our `Type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Random number node, however, returns integers. Enumerated types are treated
    as bytes in Blueprint, so we need to use a `ToByte` node, which can then be implicitly
    converted by Blueprint into an `enum` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have **Construction Script** assigning a type to our tree instances
    as they are created, we need to display the tree's type at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do so with the graph attached to the `BeginPlay` event within the Event Graph
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display text on screen, we use a `Print String` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To perform string substitution and print our type out as a human-readable string,
    we use the `Format Text` node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Format Text` node takes terms enclosed in curly braces, and allows you
    to substitute other values for those terms returning the final string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To substitute our `Type` into the `Format Text` node, we need to convert our
    variable stores from the `enum` value into the actual name of the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can do so by accessing our `Type` variable, then using the `Enum to Name`
    node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Name`, or `FNames` in native code, are a type of variable that can be converted
    to strings by Blueprint, so we can connect our `Name` to the input on the `Format
    Text` node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we hit play, the graph executes retrieving the type of tree instances placed
    in the level, and printing the names to the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing class properties in different places in the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing with Unreal, it is common for programmers to implement properties
    on Actors or other objects in C++, and make them visible to the editor for designer
    use. However, sometimes it makes sense to view a property, or to make it editable,
    but only on the object's default state. Sometimes the property should only be
    modifiable at runtime with the default specified in C++. Fortunately, there are
    some specifiers that can help us restrict when a property is available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class in the editor called `PropertySpecifierActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following property definitions to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint based on the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the blueprint, and look at the **Class Defaults** section.![How to do it…](img/00183.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note which properties are editable and visible.![How to do it…](img/00184.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place instances in the level, and view their **Details** panels.![How to do
    it…](img/00185.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that a different set of properties are editable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When specifying `UPROPERTY`, we can indicate where we want that value to be
    available inside the Unreal editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Visible*` prefixes indicate that the value is viewable in the **Details**
    panel for the indicated object. The value won''t be editable, however.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This doesn't mean that the variable is a `const` qualifier; however, native
    code can change the value, for instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Edit*` prefixes indicate that the property can be altered within the **Details**
    panels inside the editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InstanceOnly` as a suffix indicates that the property will only be displayed
    in the **Details** panels for instances of your class that have been placed into
    the game. They won''t be visible in the **Class Defaults** section of the Blueprint
    editor, for example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DefaultsOnly` is the inverse of `InstanceOnly`— `UPROPERTY` will only display
    in the **Class Defaults section**, and can''t be viewed on individual instances
    within the level.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The suffix `Anywhere` is the combination of the two previous suffixes—the `UPROPERTY`
    will be visible in all **Details** panels that inspect either the object's defaults
    or a particular instance in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe makes the property in question visible in the inspector, but doesn't
    allow the property to be referenced in the actual Blueprint Event Graph. See the
    next recipe for a description of how to make that possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making properties accessible in the Blueprint editor graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specifiers mentioned in the previous recipe are all well and good, but they
    only control the visibility of `UPROPERTY` in the **Details** panel. By default,
    even with those specifiers used appropriately, `UPROPERTY` won't be viewable or
    accessible in the actual editor graph for use at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Other specifiers, which can optionally be used in conjunction with the ones
    in the previous recipe, can be used to allow interacting with properties in the
    Event Graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` class called `BlueprintPropertyActor` using the editor
    wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY` to the actor using Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project, and start the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Blueprint class based on your `BlueprintPropertyActor,` and open its
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the properties are visible under the category **Cookbook** in the
    **Variables** sectionof the **My Blueprint** panel.![How to do it…](img/00186.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click and drag the ReadWrite property into the event graph, and select
    `Get`.![How to do it…](img/00187.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous step selecting `Set`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `ReadOnly` property into the graph, and note that the `Set` node is
    disabled.![How to do it…](img/00188.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BlueprintReadWrite` as a `UPROPERTY` specifier indicates to the Unreal Header
    Tool that the property should have both `Get` and `Set` operations exposed for
    use in Blueprints.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly` is, as the name implies, a specifier that only allows Blueprint
    to retrieve the value of the property; never set it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly` can be useful when a property is set by native code, but
    should be accessible within Blueprint.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be noted that `BlueprintReadWrite` and `BlueprintReadOnly` don't specify
    anything about the property being accessible in the **Details** panels or the
    **My Blueprint** section of the editor—these specifiers only control the generation
    of the getter/setter nodes for use in Blueprint graphs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Responding to property – changed events from the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a designer changes the properties of an `Actor` placed in the level, it
    is often important to show any visual results of that change immediately rather
    than just when the level is simulated or played.
  prefs: []
  type: TYPE_NORMAL
- en: When changes are made using the **Details** panels, there's a special event
    that the editor emits called `PostEditChangeProperty`, which gives the class instance
    a chance to respond to the property being edited.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to handle `PostEditChangeProperty` for immediate in-editor
    feedback.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` called `APostEditChangePropertyActor` based on `StaticMeshActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `PostEditChangeProperty`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of your class into the game world, and verify that toggling
    the boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport.![How to do it…](img/00189.jpeg)![How to do it…](img/00190.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new `Actor` based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UPROPERTY` is added to give us a property to change, to cause `PostEditChangeProperty`
    events to be triggered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PostEditChangeProperty` is a virtual function defined in `Actor`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we override the function in our class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component it controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `PostEditChangeProperty`, we first check that the property is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming it is, we retrieve the name of the property using `GetFName()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FNames` are stored internally by the engine as a table of unique values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to use the `GET_MEMBER_NAME_CHECKED` macro. The macro takes a number
    of parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one is the name of the class to check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is the property to check the class for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The macro will, at compile-time, verify that the class contains the member specified
    by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We compare the class member name that the macro returns against the name that
    our property contains.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If they are the same, then we verify that our `StaticMeshComponent` is initialized
    correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is, we set its visibility to match the value of our `ShowStaticMesh` Boolean.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a native code Construction Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within Blueprint, **Construction Script** is an event graph that runs any time
    a property is changed on the object it is attached to—whether from being dragged
    in the editor viewport or changed via direct entry in a **Details** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Construction scripts allow the object in question to 'rebuild' itself based
    on its new location, for instance, or to change the components it contains based
    on user-selected options.
  prefs: []
  type: TYPE_NORMAL
- en: When coding in C++ with Unreal Engine, the equivalent concept is the `OnConstruction`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Actor` called `AOnConstructionActor` based on `StaticMeshActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `OnConstruction`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an instance of your class into the game world, and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnConstruction` does not currently run for C++ actors placed in a level if
    they are moved.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test this, place a breakpoint in your `OnConstruction` function, then move
    your actor around the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To place a breakpoint, place your cursor on the desired line, and hit *F9* in
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the function doesn't get called, but if you toggle the `ShowStaticMesh`
    Boolean, it does, causing your breakpoint to trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to see why, take a look at `AActor::PostEditMove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The top line here casts `UClass` for the current object to `UBlueprint`, and
    will only run the construction scripts and `OnConstruction` again if the class
    is a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create a new Actor based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UPROPERTY` is added to give us a property to change—to cause `PostEditChangeProperty`
    events to be triggered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnConstruction` is a virtual function defined in Actor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we override the function in our class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component that it
    controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `OnConstruction`, the actor rebuilds itself using any properties that
    are required for doing so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this simple example, we set the visibility of the mesh to match the value
    of our `ShowStaticMesh` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This could also be extended to changing other values based on the value of the
    `ShowStaticMesh` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll note that we don't explicitly filter on a particular property being changed
    like the previous recipe does with `PostEditChangeProperty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `OnConstruction` script runs in its entirety for every property that gets
    changed on the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It has no way of testing which property was just edited, so you need to be judicious
    about placing computationally intensive code within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new editor module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following recipes all interact with editor mode-specific code and engine
    modules. As a result, it is considered good practice to create a new module that
    will only be loaded when the engine is running in editor mode so that we can place
    all our editor-only code inside it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your project's `.uproject` file in a text editor such as Notepad or Notepad++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the bolded section of the following to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note the comma after the first module before the second set of curly braces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your source folder, create a new folder using the same name as you specified
    in your `uproject` file (in this instance, `"UE4CookbookEditor"`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this new folder, create a file called `UE4CookbookEditor.Build.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `UE4CookbookEditor.h` and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, create a new source file called `UE4CookbookEditor.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, close Visual Studio if you have it open, then right-click on the `.uproject`
    file, and select **Generate Visual Studio Project files**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see a small window launch, display a progress bar, and then close.![How
    to do it…](img/00191.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now launch Visual Studio, verify that your new module is visible in
    the IDE, and compile your project successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The module is now ready for the next set of recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code changes made in this editor module won't support hot-reloading in the same
    way that code in runtime modules does. If you get a compilation error that mentions
    changes to generated header files, simply close the editor, and rebuild from within
    your IDE instead.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unreal projects use the `.uproject` file format to specify a number of different
    pieces of information about the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This information is used to inform the Header and Build tools about the modules
    that comprise this project, and is used for code generation and `makefile` creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file uses JSON-style formatting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The engine version that the project should be opened in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of modules that are used in the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of module declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these module declarations contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the module—is it an editor module (only runs in editor builds, has
    access to editor-only classes) or a Runtime module (runs in both editor and Shipping
    builds).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loading phase of the module—modules can be loaded at different points during
    program startup. This value specifies the point at which the module should be
    loaded, for example, if there are dependencies in other modules that should be
    loaded first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of dependencies for the module. These are essential modules that contain
    exported functions or classes that the module relies on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We ad a new module to the `uproject file`. The module's name is `UE4CookbookEditor`
    (conventionally, `Editor` should be appended to the main game module for an editor
    module).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This module is marked as an editor module, and is set to load after the baseline
    engine so that it can use the classes declared in Engine code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our module's dependencies are left at the default values for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `uproject` file altered to contain our new module, we need a build
    script for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build scripts are written in C#, and take the name `<ModuleName>.Build.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C#, unlike C++, doesn't use a separate header file and implementation—it's all
    there in the one `.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to access the classes declared in the `UnrealBuildTool` module, so we
    include a `using` statement to indicate that we want to access that namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `public` class with the same name as our module, and which inherits
    from `ModuleRules`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our constructor, we add a number of modules to the dependencies of this
    module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are both private dependencies and public dependencies. According to the
    code of the `ModuleRules` class, Public dependencies are modules that your module's
    public header files depend on. Private dependencies are modules that the private
    code depends on. Anything used in both public headers and private code should
    go into the `PublicDependencyModuleNames` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll note that our `PublicDependencyModuleNames` array contains our main game
    module. This is because some recipes in this chapter will extend the editor to
    better support the classes defined within our main game module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've told the build system that we have a new module to build through
    the project file, and we've specified how to build the module with the build script,
    we need to create the C++ class that is our actual module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a header file that includes the Engine header, the `ModuleManager`
    header, and the `UnrealEd` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We include `ModuleManager` because it defines `IModuleInterface`, the class
    that our module will inherit from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also include `UnrealEd` because we're writing an editor module that will
    need to access the editor functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class we declare inherits from `IModuleInterface`, and takes its name from
    the usual prefix, `F`, followed by the module name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `.cpp` file, we include our module's header, and then use the `IMPLEMENT_GAME_MODULE`
    macro.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IMPLEMENT_GAME_MODULE` declares an exported C function, `InitializeModule()`,
    which returns an instance of our new module class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that Unreal can simply call `InitializeModule()` on any library that
    exports it to retrieve a reference to the actual module implementation without
    needing to know what class it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having added our new module, we now need to rebuild our Visual Studio solution,
    so we close Visual Studio and then regenerate the project files using the context
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the project rebuilt, the new module will be visible in Visual Studio, and
    we can add code to it as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating new toolbar buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have created a custom tool or window for display within the editor, you
    probably need some way to let the user make it appear. The easiest way to do this
    is to create a toolbar customization that adds a new toolbar button, and have
    it display your window when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new engine module by following the previous recipe, as we'll need it
    to initialize our toolbar customization.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new header file, and insert the following class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the new class by placing the following in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following within your module class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to `#include` the header file for your command class as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to implement `StartupModule` and `ShutdownModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project, and start the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that there's a new button on the toolbar in the main level editor, which
    can be clicked on to open a new window:![How to do it…](img/00192.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unreal's editor UI is based on the concept of commands. Commands are a design
    pattern that allows looser coupling between the UI and the actions that it needs
    to perform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to create a class that contains a set of commands, it is necessary
    to inherit from `TCommands`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TCommands` is a template class that leverages the **Curiously Recurring Template
    Pattern** (**CRTP**). The CRTP is used commonly throughout **Slate** UI code as
    a means of creating compile-time polymorphism.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the initializer list for `FCookbookCommands` constructor, we invoke the parent
    class constructor, passing in a number of parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the name of the command set, and is a simple `FName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is a tooltip/human readable string, and as such, uses `FText`
    so it can support localization if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's a parent group of commands, the third parameter contains the name
    of the group. Otherwise, it contains `NAME_None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final parameter for the constructor is the Slate Style set that contains
    any command icons that the command set will be using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `RegisterCommands()` function allows `TCommands`-derived classes to create
    any command objects that they require. The resulting `FUICommandInfo` instances
    returned from that function are stored inside the `Commands` class as members
    so that UI elements or functions can be bound to the commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why we have the member variable `TSharedPtr<FUICommandInfo> MyButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation for the class, we simply need to create our commands in
    `RegisterCommands`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UI_COMMAND` macro used to create an instance of `FUICommandInfo` expects
    a localization namespace to be defined even if it is just an empty default namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we need to enclose our `UI_COMMAND` calls with `#defines` to set
    a valid value for `LOCTEXT_NAMESPACE` even if we don't intend to use localization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual `UI_COMMAND` macro takes a number of parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the variable to store the `FUICommandInfo` in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is a human-readable name for the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third parameter is a description for the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fourth parameter is `EUserInterfaceActionType`. This enumeration essentially
    specifies what sort of button is being created. It supports `Button`, `ToggleButton`,
    `RadioButton`, and `Check` as valid types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buttons are simple generic buttons. A toggle button stores on and off states.
    The radio button is similar to a toggle, but is grouped with other radio buttons,
    and only one can be enabled at a time. Lastly, the checkbox displays a read-only
    checkbox adjacent to the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last parameter for `UI_COMMAND` is the input chord, or the combination of
    keys required to activate the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This parameter is primarily useful for defining key combinations for hotkeys
    linked to the command in question rather than buttons. As a result, we use an
    empty `InputGesture`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So we now have a set of commands, but we haven't told the engine we want to
    add the set to the commands that show on the toolbar. We also haven't set up what
    actually happens when the button is clicked. In order to do this, we need to perform
    some initialization when our module begins, so we place some code into the `StartupModule`/`ShutdownModule`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `StartupModule`, we call the static `Register` function on the commands
    class that we defined earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a shared pointer to a list of commands using the `MakeShareable`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the command list, we use `MapAction` to create a mapping, or association,
    between the `UICommandInfo` object, which we set as a member of the `FCookbookCommands`,
    and the actual function we want to execute when the command is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll note that we don't explicitly set anything regarding what could be used
    to invoke the command here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To perform this mapping, we call the `MapAction` function. The first parameter
    to `MapAction` is a `FUICommandInfo` object, which we can retrieve from `FCookbookCommands`
    by using its static `Get()` method to retrieve the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FCookbookCommands` is implemented as a singleton—a class with a single instance
    that exists throughout the application. You''ll see the pattern in most places—there''s
    a static `Get()` method available in the engine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter of the `MapAction` function is a delegate bound to the
    function to be invoked when the command is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `UE4CookbookEditorModule` is a raw C++ class rather than a `UObject`,
    and we want to invoke a member function rather than a `static` function, we use
    `CreateRaw` to create a new delegate bound to a raw C++ member function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CreateRaw` expects a pointer to the object instance, and a function reference
    to the function to invoke on that pointer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third parameter for `MapAction` is a delegate to call to test if the action
    can be executed. Because we want the command to be executable all the time, we
    can use a simple pre-defined delegate that always returns `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With an association created between our command and the action it should call,
    we now need to actually tell the extension system that we want to add new commands
    to the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can do this via the `FExtender` class, which can be used to extend menus,
    context menus, or toolbars.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initially create an instance of `FExtender` as a shared pointer so that our
    extensions are uninitialized when the module is shut down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then call `AddToolBarExtension` on our new extender, storing the results
    in a shared pointer so that we can remove it on module uninitialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AddToolBarExtension''s` first argument is the name of the extension point
    where we want to add our extension.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To find where we want to place our extension, we first need to turn on the display
    of extension points within the editor UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, open **Editor Preferences** in the **Edit** menu within the editor:![How
    it works…](img/00193.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open **General** | **Miscellaneous**, and select **Display UIExtension Points**:![How
    it works…](img/00194.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the editor, and you should see green text overlaid on the editor UI,
    as in the following screenshot:![How it works…](img/00195.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The green text indicates `UIExtensionPoint`, and the text's value is the string
    we should provide to the `AddToolBarExtension` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're going to add our extension to the **Compile** extension point in this
    recipe, but of course, you could use any other extension point you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's important to note that adding a toolbar extension to a menu extension point
    will fail silently, and vice versa.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter to `AddToolBarExtension` is a location anchor relative
    to the extension point specified. We've selected `FExtensionHook::Before`, so
    our icon will be displayed before the compile point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next parameter is our command list containing mapped actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the last parameter is a delegate that is responsible for actually adding
    UI controls to the toolbar at the extension point and the anchor that we specified
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The delegate is bound to a function that has the form void (`*func`)(`FToolBarBuilder`
    and `builder`). In this instance, it is a function called `AddToolbarExtension`
    defined in our module class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the function is invoked, calling commands on the `builder` that add UI
    elements will apply those elements to the location in the UI we specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we need to load the level editor module within this function so that
    we can add our extender to the main toolbar within the level editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, we can use `ModuleManager` to load a module and return a reference
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that reference in hand, we can get the Toolbar Extensibility Manager for
    the module, and tell it to add our Extender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While this may seem cumbersome at first, the intention is to allow you to apply
    the same toolbar extension to multiple toolbars in different modules if you would
    like to create a consistent UI layout between different editor windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The counterpart to initializing our extension, of course, is removing it when
    our module is unloaded. To do that, we remove our extension from the extender,
    then null the shared pointers for both Extender and extension reclaiming their
    memory allocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `AddToolBarExtension` function within the editor module is the one which
    is responsible for actually adding UI elements to the toolbar that can invoke
    our commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It does this by calling functions on the `FToolBarBuilder` instance passed in
    as a function parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Firstly, we retrieve an appropriate icon for our new toolbar button using the
    `FSlateIcon` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the icon loaded, we invoke `AddToolBarButton` on the `builder` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AddToolbarButton` has a number of parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is the command to bind to—you'll notice it's the same `MyButton`
    member that we accessed earlier when binding the action to the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is an override for the extension hook we specified earlier,
    but we don't want to override that so we can use `NAME_None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third parameter is a label override for the new button that we create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parameter four is a tooltip for the new button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second-last parameter is the button's icon, and the last parameter is a
    name used to refer to this button element for highlighting support if you wish
    to use the in-editor tutorial framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating new menu entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workflow for creating new menu entries is almost identical to that for creating
    new toolbar buttons, so this recipe will build on the previous one, and show you
    how to add the command created therein to a menu rather than a toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new function in your `module` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the following code within the `StartupModule` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that you now have a menu entry under the **Window** menu that displays
    the **Cookbook** window when clicked. If you followed the preceding recipe, you'll
    also see the green text listing the UI extension points, including the one we
    used in this recipe (**LevelEditor**).![How to do it…](img/00196.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll note that `ToolbarExtender` is of type `FExtender` rather than `FToolbarExtender`
    or `FMenuExtender`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using a generic `FExtender` class rather than a specific subclass, the framework
    allows you to create a series of command-function mappings that can be used on
    either menus or toolbars. The delegate that actually adds the UI controls (in
    this instance, `AddMenuExtension`) can link those controls to a subset of commands
    from your `FExtender`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, you don't need to have different `TCommands` classes for different
    types of extensions, and you can place the commands into a single central class
    regardless of where those commands are invoked from the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a result, the only changes that are required are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swapping calls to `AddToolBarExtension` with `AddMenuExtension`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a function that can be bound to `FMenuExtensionDelegate` rather than
    `FToolbarExtensionDelegate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the extender to a Menu Extensibility Manager rather than a Toolbar Extensibility
    Manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new editor window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom editor windows are useful when you have a new tool with user-configurable
    settings, or want to display some information to people using your customized
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to have an editor module by following the recipe earlier in this chapter
    before you start.
  prefs: []
  type: TYPE_NORMAL
- en: Read through either the *Creating new menu entries* or *Creating new toolbar
    buttons* recipes so that you can create a button within the editor that will launch
    our new window.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside your command''s bound function, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you activate the command you created, either by selecting the custom menu
    option or the toolbar option that you added, you should see that the window has
    been displayed with some centered text in the middle:![How to do it…](img/00197.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As should be self-explanatory, your new editor window won't display itself,
    and so, at the start of this recipe, it is mentioned that you should have implemented
    a custom menu or toolbar button or a console command that we can use to trigger
    the display of our new window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of Slate's widgets are usually interacted with in the form of `TSharedRef<
    >` or `TSharedPtr< >`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SNew()` function returns a `TSharedRef` templated on the requested widget
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As has been mentioned elsewhere in this chapter, Slate widgets have a number
    of functions that they implement, which all return the object that the function
    was invoked on. This allows for method chaining to be used to configure the object
    at creation time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is what allows for the Slate syntax of `<Widget>.Property(Value).Property(Value)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The properties that are set on the widget in this recipe are the window title,
    the window size, and whether the window can be maximized and minimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the requisite properties on a widget have been set, the bracket operators
    (`[]`) can be used to specify the content to be placed inside the widget, for
    example, a picture or label inside a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SWindow` is a top-level widget with only one slot for child widgets, so we
    don''t need to add a slot for it ourselves. We place content into that slot by
    creating it inside the pair of brackets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The content we create is `SVerticalBox`, which is a widget that can have an
    arbitrary number of slots for child widgets that are displayed in a vertical list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each widget we want to place into the vertical list, we need to create a
    **slot**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to do this is to use the overloaded `+` operator and the `SVerticalBox::Slot()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Slot()` returns a widget like any other, so we can set properties on it like
    we did on our `SWindow`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe centers the Slot's content on both horizontal and vertical axes
    using `HAlign` and `VAlign`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Slot` has a single child widget, and it's created inside the `[]` operators
    just as for `SWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `Slot` content, we create a text block with some custom text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our new `SWindow` now has its child widgets added, but it isn't being displayed
    yet, because it isn't added to the window hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main frame module is used to check if we have a top-level editor window,
    and if it exists, our new window is added as a child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there's no top-level window to be added as a child to, then we use the Slate
    Application singleton to add our window without a parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you would like to see the hierarchy of the window we've created, you can
    use the Slate Widget Reflector, which can be accessed via **Window** | **Developer
    Tools** | **Widget Reflector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you select **Pick Live Widget**, and hover your cursor over the text in the
    center of our custom window, you will be able to see the **SWindow** with our
    custom widgets added to its hierarchy.![How it works…](img/00198.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 9](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121
    "Chapter 9. User Interfaces – UI and UMG"), *User Interfaces – UI and UMG*, is
    all about UI, and will show you how to add additional elements to your new custom
    window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new Asset type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point in your project, you might need to create a new custom Asset class,
    for example, an Asset to store conversation data in an RPG.
  prefs: []
  type: TYPE_NORMAL
- en: In order to properly integrate these with **Content Browser**, you'll need to
    create a new Asset type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a custom Asset based on `UObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class called `UCustomAssetFactory` based on `UFactory`, overriding
    `FactoryCreateNew`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in **Content Browser**, and under the **Miscellaneous** tab of the
    **Create Advanced Asset** section, you should see your new class, and be able
    to create instances of your new custom type.![How to do it…](img/00199.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first class is the actual object that can exist in the game at runtime.
    It's your texture, data file, or curve data, whatever you require.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the purpose of this recipe, the simplest example is an asset that has an
    `FString` property to contain a name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The property is marked as `UPROPERTY` so that it remains in memory, and additionally
    marked as `EditAnywhere` so that it is editable on both, the default object and
    on instances of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second class is `Factory`. Unreal uses the `Factory` design pattern to create
    instances of assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that there is a generic base `Factory` that uses virtual methods
    to declare the interface of object creation, and then `Factory` subclasses are
    responsible for creating the actual object in question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage of this approach is that the user-created subclass can potentially
    instantiate one of its own subclasses if required; it hides the implementation
    details regarding deciding which object to create away from the object requesting
    the creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `UFactory` as our base class, we include the appropriate header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor is overridden, because there are a number of properties that
    we want to set for our new factory after the default constructor has run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bCreateNew` signifies that the factory is currently able to create a new instance
    of the object in question from scratch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bEditAfterNew` indicates that we would like to edit the newly created object
    immediately after creation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SupportedClass` variable is an instance of `UClass` containing reflection
    information about the type of object the factory will create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most significant function of our `UFactory` subclass is the actual factory
    method—`FactoryCreateNew`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FactoryCreateNew` is responsible for determining the type of object that should
    be created, and using `NewObject` to construct an instance of that type. It passes
    the following parameters through to the `NewObject` call.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InClass` is the class of object that will be constructed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InParent` is the object that should be containing the new object that will
    be created. If this isn''t specified, the object is assumed to go into the transient
    package, which means that it won''t be automatically saved.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Name` is the name of the object to be created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flags` is a bitmask of creation flags that control things such as making the
    object visible outside of the package it is contained in.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `FactoryCreateNew`, decisions can be made regarding which subclass should
    be instantiated. Other initialization can also be performed; for example, if there
    are sub-objects that require manual instantiation or initialization, they can
    be added here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example from the engine code for this function is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen here, there's a second call to `NewObject` to populate the `CameraInterpGroup`
    member of the `NewCamAnim` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Editing class properties in different places in the editor* recipe earlier
    in this chapter gives more context to the `EditAnywhere` property specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom context menu entries for Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Asset types commonly have special functions you wish to be able to perform
    on them. For example, converting images to sprites is an option you wouldn't want
    to add to any other Asset type. You can create custom context menu entries for
    specific Asset types in order to make those functions accessible to users.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class based on `FAssetTypeActions_Base`. You'll need to include
    `AssetTypeActions_Base.h` in the header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the following virtual functions in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the declared functions in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Within your editor module, add the following code to the `StartupModule()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following inside the module''s `ShutdownModule()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of your custom Asset inside **Content Browser**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on your new Asset to see our custom command in the context menu.![How
    to do it…](img/00200.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **CustomAssetAction** command to display a new blank editor window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The base class for all asset type-specific context menu commands is `FAssetTypeActions_Base`,
    so we need to inherit from that class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FAssetTypeActions_Base` is an abstract class that defines a number of virtual
    functions that allow for extending the context menu. The interface which contains
    the original information for these virtual functions can be found in `IAssetTypeActions.h`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also declare a function which we bind to our custom context menu entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )` is the
    function called by the engine code to see if our `AssetTypeActions` class contains
    any actions that can be applied to the selected objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder&
    MenuBuilder)` is called if the `HasActions` function returns `true`. It calls
    functions on `MenuBuilder` to create the menu options for the actions that we
    provide.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetName()` returns the name of this class.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetSupportedClass()` returns an instance of `UClass` which
    our actions class supports.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetTypeColor()` returns the color associated with this
    class and actions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAssetTypeActions::GetCategories()` returns a category appropriate for the
    asset. This is used to change the category under which the actions show in the
    context menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our overridden implementation of `HasActions` simply returns `true` under all
    circumstances relying on filtering based on the results of `GetSupportedClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the implementation of `GetActions`, we can call some functions on the
    `MenuBuilder` object that we are given as a function parameter. The `MenuBuilder`
    is passed as a reference, so any changes that are made by our function will persist
    after it returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AddMenuEntry` has a number of parameters. The first parameter is the name
    of the action itself. This is the name that will be visible within the context
    menu. The name is an `FText` so that it can be localized should you wish. For
    the sake of simplicity, we construct `FText` from a string literal and don''t
    concern ourselves with multiple language support.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is also `FText`, which we construct by calling `FText::FromString`.
    This parameter is the text displayed on a tooltip if the user hovers over our
    command for more than a small amount of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next parameter is `FSlateIcon` for the command, which is constructed from
    the `LevelEditor.ViewOptions` icon within the editor style set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last parameter to this function is an `FUIAction` instance. The `FUIAction`
    is a wrapper around a delegate binding, so we use `FExecuteAction::CreateRaw`
    to bind the command to the `MyCustomAsset_Clicked` function on this very instance
    of `FMyCustomAssetActions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that when the menu entry is clicked, our `MyCustomAssetContext_Clicked`
    function will be run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our implementation of `GetName` returns the name of our Asset type. This string
    will be used on the thumbnail for our Asset if we don't set one ourselves, apart
    from being used in the title of the menu section that our custom Assets will be
    placed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you'd expect, the implementation of `GetSupportedClass` returns `UMyCustomAsset::StaticClass()`,
    as this is the Asset type we want our actions to operate on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GetTypeColor()` returns the color that will be used for color coding in **Content
    Browser**—the color is used in the bar at the bottom of the asset thumbnail. I''ve
    used Emerald here, but any arbitrary color will work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The real workhorse of this recipe is the `MyCustomAssetContext_Clicked()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing that this function does is create a new instance of `SWindow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SWindow` is the Slate Window—a class from the Slate UI framework.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slate Widgets are created using the `SNew` function, which returns an instance
    of the widget requested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slate uses the `builder` design pattern, which means that all the functions
    that are **chained** after `SNew` returns a reference to the object that was being
    operated on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this function, we create our new `SWindow`, then set the window title, its
    client size or area, and whether it can be maximized or minimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our new Window ready, we need to get a reference to the root window for
    the editor so we can add our window to the hierarchy and get it displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this using the `IMainFrameModule` class. It's a module, so we use the
    **Module Manager** to load it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LoadModuleChecked` will assert if we can''t load the module, so we don''t
    need to check it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the module was loaded, we check that we have a valid parent window. If that
    window is valid, then we use `FSlateApplication::AddWindowAsNativeChild` to add
    our window as a child of the top-level parent window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we don't have a top-level parent, the function uses `AddWindow` to add the
    new window without parenting it to another window within the hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So now we have a class which will display custom actions on our custom Asset
    type, but we need to actually tell the engine that it should ask our class to
    handle custom actions for the type. In order to do that, we need to register our
    class with the Asset Tools module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The best way to do this is to register our class when our editor module is loaded,
    and unregister it when it is shut down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we place our code into the `StartupModule` and `ShutdownModule`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `StartupModule`, we load the Asset Tools module using **Module Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the module loaded, we create a new shared pointer that references an instance
    of our custom Asset actions class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we then need to do is call `AssetModule.RegisterAssetTypeActions,` and pass
    in an instance of our actions class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then need to store a reference to that `Actions` instance so that we can
    unregister it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sample code for this recipe uses an array of all the created asset actions
    in case we want to add custom actions for other classes as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `ShutdownModule`, we again retrieve an instance of the Asset Tools module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a range-based for loop, we iterate over the array of `Actions` instances
    that we populated earlier, and call `UnregisterAssetTypeActions`, passing in our
    `Actions` class so it can be unregistered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our class registered, the editor has been instructed to ask our registered
    class if it can handle assets which are right-clicked on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the asset is of the Custom Asset class, then its `StaticClass` will match
    the one returned by `GetSupportedClass`. The editor will then call `GetActions`,
    and display the menu with the alterations made by our implementation of that function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the `CustomAssetAction` button is clicked, our custom `MyCustomAssetContext_Clicked`
    function will be called via the delegate that we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating new console commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, console commands can be very helpful by allowing a developer
    or tester to easily bypass content, or disable the mechanics not relevant to the
    current test being run. The most common way to implement this is via console commands,
    which can invoke functions during runtime. The console can be accessed using the
    tilde key (`~`) or the equivalent in the upper-left area of the alphanumeric zone
    of your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating new console commands](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already followed the *Creating a new editor module* recipe, do
    so, as this recipe will need a place to initialize and register the console command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your editor module''s header file, and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following within the implementation of `StartupModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `ShutdownModule`, add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the following function in the editor module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level, then hit the tilde key to bring up the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `DisplayTestCommandWindow,` and hit *Enter*.![How to do it...](img/00202.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see our tutorial window open up:![How to do it...](img/00203.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Console commands are usually provided by a module. The best way to get the module
    to create the command when it is loaded is to place the code in the `StartupModule`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IConsoleManager` is the module that contains the console functionality for
    the engine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it is a sub-module of the core module, we don't need to add any additional
    information to the build scripts to link in additional modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to call functions within the console manager, we need to get a reference
    to the current instance of `IConsoleManager` that is being used by the engine.
    To do so, we invoke the static `Get` function, which returns a reference to the
    module in a similar way to a singleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RegisterConsoleCommand` is the function that we can use to add a new console
    command, and make it available in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for the function are the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Name`: The actual console command that will be typed by users. It should not
    include spaces.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Help:` The tooltip that appears when users are looking at the command in the
    console. If your console command takes arguments, this is a good place to display
    usage information to users.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Command:` This is the actual function delegate that will be executed when
    the user types the command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Flags:` These flags control visibility of the command in a shipping build,
    and are also used for console variables. `ECVF_Default` specifies the default
    behavior wherein the command is visible, and has no restrictions on availability
    in a release build.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create an instance of the appropriate delegate, we use the `CreateRaw` static
    function on the `FConsoleCommand` delegate type. This lets us bind a raw C++ function
    to the delegate. The extra argument that is supplied after the function reference,
    the `FString` `"Test Command Window"`, is a compile-time defined parameter that
    is passed to the delegate so that the end user doesn't have to specify the window
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second console command, `DisplayUserSpecifiedWindow`, is one that demonstrates
    the use of arguments with console commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The primary difference with this console command, aside from the different name
    for users to invoke it, is the use of `FConsoleCommandWithArgsDelegate` and the
    `CreateLambda` function on it in particular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function allows us to bind an anonymous function to a delegate. It's particularly
    handy when you want to wrap or adapt a function so its signature matches that
    of a particular delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our particular use case, the type of `FConsoleCommandWithArgsDelegate` specifies
    that the function should take a `const TArray` of FStrings. Our `DisplayWindow`
    function takes a single `FString` to specify the window title, so we need to somehow
    concatenate all the arguments of the console command into a single `FString` to
    use as our window title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The lambda function allows us to do that before passing the `FString` onto the
    actual `DisplayWindow` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first line of the function, `[&](const TArray<FString>& Args)`, specifies
    that this lambda or anonymous function wants to capture the context of the declaring
    function by reference by including the ampersand in the capture options `[&]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second part is the same as a normal function declaration specifying that
    our lambda takes in `const Tarray` containing FStrings as a parameter called `Args`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the lambda body, we create a new `FString,` and concatenate the strings
    that make up our arguments together, adding a space between them to separate them
    so that we don't get a title without spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses a range-based `for` loop for brevity to loop over them all and perform
    the concatenation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once they're all concatenated, we use the `this` pointer (captured by the `&`
    operator mentioned earlier) to invoke `DisplayWindow` with our new title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for our module to remove the console command when it is unloaded, we
    need to maintain a reference to the console command object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve this, we create a member variable in the module of type `IConsoleCommand*`,
    called `DisplayTestCommand`. When we execute the `RegisterConsoleCommand` function,
    it returns a pointer to the console command object that we can use as a handle
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to enable or disable console commands at runtime based on gameplay
    or other factors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within `ShutdownModule`, we check to see if `DisplayTestCommand` refers to a
    valid console command object. If it does, we get a reference to the `IConsoleManager`
    object, and call `UnregisterConsoleCommand` passing in the pointer that we stored
    earlier in our call to `RegisterConsoleCommand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The call to `UnregisterConsoleCommand` deletes the `IConsoleCommand` instance
    via the passed-in pointer, so we don't need to `deallocate` the memory ourselves,
    just reset `DisplayTestCommand` to `nullptr` so we can be sure the old pointer
    doesn't dangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `DisplayWindow` function takes in the window title as an `FString` parameter.
    This allows us to either use a console command that takes arguments to specify
    the title, or a console command that uses payload parameters to hard-code the
    title for other commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function itself uses a function called `SNew()` to allocate and create an
    `SWindow` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SWindow` is a Slate Window, a top-level window using the Slate UI framework.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Slate uses the `Builder` design pattern to allow for easy configuration of the
    new window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Title`, `ClientSize`, `SupportsMaximize`, and `SupportsMinimize` functions
    used here, are all member functions of `SWindow`, and they return a reference
    to an `SWindow` (usually, the same object that the method was invoked on, but
    sometimes, a new object constructed with the new configuration).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fact that all these member methods return a reference to the configured
    object allows us to chain these method invocations together to create the desired
    object in the right configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The functions used in `DisplayWindow` create a new top-level Window that has
    a title based on the function parameter. It is 800x400 pixels wide, and cannot
    be maximized or minimized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our new Window created, we retrieve a reference to the main application
    frame module. If the top-level window for the editor exists and is valid, we add
    our new window instance as a child of that top-level window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, we retrieve a reference to the Slate interface, and call `AddWindowAsNativeChild`
    to insert our window in the hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there isn't a valid top-level window, we don't need to add our new window
    as a child of anything, so we can simply call `AddWindow,` and pass in our new
    window instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates*,
    to learn more about delegates. It explains payload variables in greater detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Slate, refer to [Chapter 9](part0122_split_000.html#3KB4K1-c0ca69a0411046888a488e5085138121
    "Chapter 9. User Interfaces – UI and UMG"), *User Interface*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new graph pin visualizer for Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the Blueprint system, we can use instances of our `MyCustomAsset` class
    as variables, provided we mark that class as a `BlueprintType` in its `UCLASS`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, by default, our new asset is simply treated as `UObject`, and we can''t
    access any of its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new graph pin visualizer for Blueprint](img/00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For some types of assets, we might wish to enable in-line editing of literal
    values in the same way that classes such as `FVector` support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new graph pin visualizer for Blueprint](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In order to enable this, we need to use a **Graph Pin** visualizer. This recipe
    will show you how to enable in-line editing of an arbitrary type using a custom
    widget defined by you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new header file called `MyCustomAssetPinFactory.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the header, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another header file called `SGraphPinCustomAsset`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `SGraphPinCustomAsset` in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Add `#include "Chapter8/MyCustomAssetDetailsCustomization.h"` to the `UE4Cookbook`
    editor module implementation file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member to the editor module class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to `StartupModule()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the following code to `ShutdownModule()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new **Function** inside the Level Blueprint by clicking on the plus
    symbol beside **Functions** within the **My Blueprint** panel:![How to do it...](img/00206.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an input parameter.![How to do it...](img/00207.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its type to `MyCustomAsset` (**Reference**):![How to do it...](img/00208.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Level Blueprint's Event graph, place an instance of your new function,
    and verify that the input pin now has a custom visualizer in the form of a color
    picker:![How to do it...](img/00209.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Customizing how objects appear as literal values on Blueprint pins is done using
    the `FGraphPanelPinFactory` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This class defines a single virtual function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The function of `CreatePin`, as the name implies, is to create a new visual
    representation of the graph pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It receives a `UEdGraphPin` instance. `UEdGraphPin` contains information about
    the object that the pin represents so that our factory class can make an informed
    decision regarding which visual representation we should be displaying.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within our implementation of the function, we check that the pin's type is our
    custom class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do this by looking at the `PinSubCategoryObject` property, which contains
    a `UClass`, and comparing it to the `UClass` associated with our custom asset
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pin's type meets our conditions, we return a new shared pointer to a
    Slate Widget, which is the visual representation of our object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pin is of the wrong type, we return a null pointer to indicate a failed
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next class, `SGraphPinCustomAsset`, is the Slate Widget class, which is
    a visual representation of our object as a literal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It inherits from `SGraphPin`, the base class for all graph pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SGraphPinCustomAsset` class has a `Construct` function, which is called
    when the widget is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It also implements some functions from the parent class: `GetPinColor()` and
    `GetDefaultValueWidget()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last function defined is `ColorPicked`, a handler for when a user selects
    a color in our custom pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implementation of our custom class, we initialize our custom pin by calling
    the default implementation of `Construct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The role of `GetDefaultValueWidget` is to actually create the widget that is
    the custom representation of our class, and return it to the engine code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our implementation, it creates a new `SColorPicker` instance—we want the
    user to be able to select a color, and store the hex-based representation of that
    color inside the `FString` property in our custom class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `SColorPicker` instance has a property called `OnColorCommitted`— this
    is a slate event that can be assigned to a function on an object instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before returning our new `SColorPicker`, we link `OnColorCommitted` to the `ColorPicked`
    function on this current object, so it will be called if the user selects a new
    color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ColorPicked` function receives the selected color as an input parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this widget is used when there's no object connected to the pin we are
    associated with, we can't simply set the property on the associated object to
    the desired color string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a new instance of our custom asset class, and we do that by
    using the `NewObject` template function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function behaves similarly to the `SpawnActor` function discussed in other
    chapters, and initializes a new instance of the specified class before returning
    a pointer to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a new instance in hand, we can set its `ColorName` property. `FLinearColors`
    can be converted to `FColor` objects, which define a `ToHex()` function that returns
    an `FString` with the hexadecimal representation of the color that was selected
    on the new widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we need to actually place our new object instance into the graph so
    that it will be referenced when the graph is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do this, we need to access the graph pin object that we represent, and use
    the `GetSchema` function. This function returns the Schema for the graph that
    owns the node that contains our pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Schema contains the actual values that correspond to graph pins, and is
    a key element during graph evaluation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have access to the Schema, we can set the default value for the
    pin that our widget represents. This value will be used during graph evaluation
    if the pin isn't connected to another pin, and acts like a default value provided
    during a function definition in C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with all the extensions we've made in this chapter, there has to be some
    sort of initialization or registration to tell the engine to defer to our custom
    implementation before using its default inbuilt representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to do this, we need to add a new member to our editor module to store
    our `PinFactory` class instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During `StartupModule`, we create a new shared pointer that references an instance
    of our `PinFactory` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We store it inside the editor module's member so it can be unregistered later.
    Then we call `FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)` to tell
    the engine to use our `PinFactory` to create the visual representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During `ShutdownModule`, we unregister the pin factory using `UnregisterVisualPinFactory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we delete our old `PinFactory` instance by calling `Reset()` on the
    shared pointer that contains it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspecting types with custom Details panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `UObject-`derived UAssets open in the generic property editor.
    It looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting types with custom Details panels](img/00210.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, at times you may wish for custom widgets to allow editing of properties
    on your class. To facilitate this, Unreal supports **Details Customization**,
    which is the focus of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new header file called `MyCustomAssetDetailsCustomization.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following includes to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Define our customization class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation file, create an implementation for `CustomizeDetails`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Also create a definition for `ColorPicked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, add the following includes in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In our editor module header, add the following to the implementation of `StartupModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to `ShutdownModule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code, and launch the editor. Create a new copy of `MyCustomAsset`
    via the content browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on it to verify that the default editor now shows your custom layout:![How
    to do it...](img/00211.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Details Customization is performed through the `IDetailCustomization` interface,
    which developers can inherit from when defining a class which customizes the way
    assets of a certain class are displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main function that `IDetailCustomization` uses to allow for this process
    to occur is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Within our implementation of this function, we use methods on `DetailBuilder`
    passed in as a parameter to get an array of all selected objects. The loop then
    scans those to ensure that at least one selected object is of the correct type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customizing the representation of a class is done by calling methods on the
    `DetailBuilder` object. We create a new category for our details view by using
    the `EditCategory` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter of the `EditCategory` function is the name of the category
    we are going to manipulate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second parameter is optional, and contains a potentially localized display
    name for the category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third parameter is the priority of the category. Higher priority means it
    is displayed further up the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EditCategory` returns a reference to the category itself as `CategoryBuilder`,
    allowing us to chain additional method calls onto an invocation of `EditCategory`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, we call `AddCustomRow()` on `CategoryBuilder`, which adds a new
    key-value pair to be displayed in the category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Slate syntax, we then specify that the row will contain a Vertical
    Box with a single center-aligned slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the slot, we create a color picker control, and bind its `OnColorCommitted`
    delegate to our local `ColorPicked` event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Of course, this requires us to define and implement `ColourPicked`. It has
    the following signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Inside the implementation of `ColorPicked`, we check to see if one of our selected
    assets was of the correct type, because if at least one selected asset was correct,
    then `MyAsset` will be populated with a valid value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming we have a valid asset, we set the `ColorName` property to the hex string
    value corresponding to the color selected by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
