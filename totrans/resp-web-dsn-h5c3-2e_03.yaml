- en: Chapter 3. Fluid Layouts and Responsive Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eons ago, in the mists of time (well the late 1990s), websites were typically
    built with their widths defined as percentages. These percentage-based widths
    fluidly adjusted to the screen viewing them and became known as fluid layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In the years shortly after, in the mid to late 2000s, there was an intervening
    fixation on fixed width designs (I blame those pesky print designers and their
    obsession with pixel perfect precision). Nowadays, as we build responsive web
    designs we need to look back to fluid layouts and remember all the benefits they
    offer.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Media Queries – Supporting Differing Viewports"),
    *Media Queries – Supporting Differing Viewports*, we ultimately conceded that
    while media queries allowed our design to adapt to changing viewport sizes, by
    snapping from one set of styles to another, we needed some ability to flex our
    design between the 'break points' that media queries provided. By coding a 'fluid'
    layout, we can facilitate this need perfectly; it will effortlessly stretch to
    fill the gaps between our media query break points.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, we have better means to build responsive web sites than ever. There
    is a new CSS layout module called **Flexible Box** (or **Flexbox** as it is more
    commonly known) that now has enough browser support to make it viable for everyday
    use.
  prefs: []
  type: TYPE_NORMAL
- en: It can do more than merely provide a fluid layout mechanism. Want to be able
    to easily center content, change the source order of markup, and generally create
    amazing layouts with relevant ease? Flexbox is the layout mechanism for you. The
    majority of this chapter deals with Flexbox, covering all the incredible capabilities
    it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: There is another key area to responsive web design we can address better now
    than ever before and that's responsive images. There are now specified methods
    and syntax for sending devices the most relevant version of an image for their
    viewport. We will spend the last section of this chapter understanding how responsive
    images work and how we can make them work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How to convert fixed pixel sizes to proportional sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider existing CSS layout mechanisms and their shortfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the Flexible Box Layout Module and the benefits it offers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the correct syntax for resolution switching and art direction with responsive
    images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a fixed pixel design to a fluid proportional layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphic composites made in a program like Photoshop, Illustrator, Fireworks
    (RIP), or Sketch all have fixed pixel dimensions. At some point, the designs need
    to be converted to proportional dimensions by a developer when recreating the
    design as a fluid layout in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a beautifully simple formula for making this conversion that the father
    of responsive web design, Ethan Marcotte, set down in his 2009 article, *Fluid
    Grids* ([http://alistapart.com/article/FLUIDGRIDS](http://alistapart.com/article/FLUIDGRIDS)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*target / context = result*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If anything resembling math makes you quiver, think of it this way: divide
    the units of the thing you want, by the thing it lives in. Let''s put that into
    practice as understanding it will enable you to convert any fixed dimension layouts
    into responsive/fluid equivalents.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a very basic page layout intended for desktop. In an ideal world we
    would always be moving to a desktop layout from a smaller screen layout, but for
    the sake of illustrating the proportions we will look at the two situations back
    to front.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an image of the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting a fixed pixel design to a fluid proportional layout](img/B03777_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The layout is 960px wide. Both header and footer are the full width of layout.
    The left hand side area is 200px wide, the right hand area is 100px wide. Even
    with my mathematically challenged brain I can tell you the middle section will
    be 660px wide. We need to convert the middle and side sections to proportional
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, the left hand side. It''s 200 units wide (target). Divide that size
    by 960 units (the context) and we have a result: .208333333\. Now, whenever we
    get our result with that formula we need to shift the decimal point two to the
    right. That would give us 20.8333333%. That''s 200px described as a percentage
    of 960px.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, what about the middle section? 660 (target) divided by 960 (context) gives
    us .6875\. Move the decimal two points to the right and we have 68.75%. Finally,
    the right hand section. 100 (target) divided by 960 (context) gives us .104166667\.
    Move the decimal point and we have 10.4166667%. That''s as difficult as it gets.
    Say it with me: target, divided by context, equals result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove the point, let''s quickly build that basic layout as blocks in the
    browser. You can view the layout as `example_03-01`. Here is the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you open the example code in a browser and resize the page you will see the
    dimensions of the middle sections remain proportional to one another. You can
    also play around with the max-width of the .Wrap values to make the bounding dimensions
    for the layout bigger or smaller (it's set in the example to `1400px`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're looking at the markup and wondering why I haven't used semantic elements
    like `header`, `footer`, and `aside`, then worry not. [Chapter 4](ch04.html "Chapter 4. HTML5
    for Responsive Web Designs"), *HTML5 for Responsive Web Designs*, deals with those
    semantic HTML5 elements in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's consider how we would have the same content on a smaller screen that
    flexes to a point and then changes to the layout we have already seen. You can
    view the final code of this layout in `example_03-02`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that for smaller screens we will have a single 'tube' of content.
    The left hand side area will only be viewable as an 'off canvas' area; typically
    an area for a menu area or similar, that sits off the viewable screen area and
    slides in when a menu button is pressed. The main content sits below the header,
    then the right hand section below that, and finally the footer area. In our example,
    we can expose the left hand menu area by clicking anywhere on the header. Typically,
    when making this kind of design pattern for real, a menu button would be used
    to activate the side menu.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To switch the class on the body of the document, I've employed a little JavaScript.
    This isn't 'production ready' though as we are using 'click' as the event handler
    in JavaScript, when ideally we would have some provision for touch (to remove
    the 300ms delay still present on iOS devices).
  prefs: []
  type: TYPE_NORMAL
- en: As you would expect, when combining this with our newly mastered media query
    skills we can adjust the viewport and the design just 'responds'—effortlessly
    moving from one layout to another and stretching between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m not going to list out all the CSS here, it''s all in `example_03-02`.
    However, here''s an example—the left hand section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see that up first, without a media query, is the small screen layout.
    Then, at larger screen sizes, the width becomes proportional, the positioning
    relative and the left value is set to zero. We don't need to re-write properties
    such as the `height`, `display`, or `background-color` as we aren't changing them.
  prefs: []
  type: TYPE_NORMAL
- en: This is progress. We have combined two of the core responsive web design techniques
    we have covered; converting fixed dimensions to proportions and using media queries
    to target CSS rules relevant to the viewport size.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two important things to note in our prior example. Firstly, you may
    be wondering if it's strictly necessary to include all the digits after the decimal
    point. While the widths themselves will ultimately be converted to pixels by the
    browser, their values are retained for future calculations (for example, more
    accurately computing the width of nested elements). Subsequently, I always recommend
    leaving the numbers after the decimals in.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, in a real project we should be making some provision for if JavaScript
    isn't available and we need to view the content of the menu. We deal with this
    scenario in detail in [Chapter 8](ch08.html "Chapter 8. Transitions, Transformations,
    and Animations"), *Transitions, Transformations, and Animations*.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need Flexbox?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to get into the detail of using CSS Flexible Box Layouts, or
    Flexbox as it is more commonly known.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we do that, I think it will be prudent to first consider the
    shortfalls of existing layout techniques such as inline-block, floats and tables.
  prefs: []
  type: TYPE_NORMAL
- en: Inline block and whitespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The biggest issue with using inline-block as a layout mechanism is that it
    renders space in-between HTML elements. This is not a bug (although most developers
    would welcome a sane way to remove the space) but it does mean a few hacks to
    remove the space when it''s unwanted, which for me is about 95% of the time. There
    are a bunch of ways to do this, in the previous example we used the ''font-size
    zero'' approach; an approach not without its own problems and limitations. However,
    rather than list each possible workaround for removing the whitespace when using
    inline-block, check out this article by the irrepressible Chris Coyier: [http://css-tricks.com/fighting-the-space-between-inline-block-elements/](http://css-tricks.com/fighting-the-space-between-inline-block-elements/).'
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth pointing out that there no simple way to vertically center content
    within an inline-block. Using inline-blocks, there is also no way of having two
    sibling elements where one has a fixed width and another fluidly fills the remaining
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hate floats. There I said it. In their favor they work everywhere fairly consistently.
    However, there are two major irritations.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, when specifying the width of floated elements in percentages, their
    computed widths don't get rounded consistently across browsers (some browsers
    round up, some down). This means that sometimes sections will drop down below
    others when it isn't intended and other times they can leave an irritating gap
    at one side.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly you usually have to 'clear' the floats so that parent boxes/elements
    don't collapse. It's easy enough to do this but it's a constant reminder that
    floats were never intended to be used as a robust layout mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Table and table-cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t confuse `display: table` and `display: table-cell` with the equivalent
    HTML elements. These CSS properties merely mimic the layout of their HTML based
    brethren. They in no way affect the structure of the HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve found enormous utility in using CSS table layouts. For one, they enable
    consistent and robust vertical centring of elements within one another. Also,
    elements set to be `display: table-cell` inside an element set as `display: table`
    space themselves perfectly; they don''t suffer rounding issues like floated elements.
    You also get support all the way back to Internet Explorer 7!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are limitations. Generally, it''s necessary to wrap an extra
    element around items (to get the joys of perfect vertical centring, a table-cell
    must live inside an element set as a table). It''s also not possible to wrap items
    set as `display: table-cell` onto multiple lines.'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, all of the existing layout methods have severe limitations. Thankfully,
    there is a new CSS layout method that addresses these issues and much more. Cue
    the trumpets, roll out the red carpet. Here comes Flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flexbox addresses the shortfalls in each of the aforementioned display mechanisms.
    Here''s a brief overview of its super powers:'
  prefs: []
  type: TYPE_NORMAL
- en: It can easily vertically center contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can change the visual order of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can automatically space and align elements within a box, automatically assigning
    available space between them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can make you look 10 years younger (probably not, but in low numbers of empirical
    tests (me) it has been proven to reduce stress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bumpy path to Flexbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flexbox has been through a few major iterations before arriving at the relatively
    stable version we have today. For example, consider the changes from the 2009
    version ([http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/](http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/)),
    the 2011 version ([http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/](http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/)),
    and the 2014 version we are basing our examples on ([http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/)).
    The syntax differences are marked.
  prefs: []
  type: TYPE_NORMAL
- en: These differing specifications mean there are three major implementation versions.
    How many of these you need to concern yourself with depends on the level of browser
    support you need.
  prefs: []
  type: TYPE_NORMAL
- en: Browser support for Flexbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get this out of the way up front: there is no Flexbox support in Internet
    Explorer 9, 8, or below.'
  prefs: []
  type: TYPE_NORMAL
- en: For everything else you'd likely want to support (and virtually all mobile browsers),
    there is a way to enjoy most (if not all) of Flexbox's features. You can check
    the support information at [http://caniuse.com/](http://caniuse.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Before we get stuck into Flexbox, we need to take a brief but essential tangent.
  prefs: []
  type: TYPE_NORMAL
- en: Leave prefixing to someone else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s my hope that once you have seen a few examples of Flexbox, you will appreciate
    its utility and feel empowered to use it. However, manually writing all the necessary
    code to support each of the different Flexbox specifications is a tough task.
    Here''s an example. I''m going to set three Flexbox related properties and values.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s how the properties and values would look in the most recent syntax.
    However, if we want support for Android browsers (v4 and below) and IE 10, here
    is what would actually be needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's necessary to write all that because in the last few years, as browsers
    made experimental versions of new functionality available, they did so with a
    'vendor prefix'. Each vendor had their own prefix. For example `-ms-` for Microsoft,
    `-webkit-` for WebKit, `-moz-` for Mozilla, and so on. For every new feature this
    meant it was necessary to write multiple versions of the same property; the vendor
    prefixed versions first, and the official W3C version at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this spell in web history is CSS that looks like the previous
    example. It's the only way to get the feature working across the widest number
    of devices. Nowadays, vendors rarely add prefixes but for the foreseeable future
    we must live with the reality of many existing browsers still requiring prefixes
    to enable certain features. This brings us back to Flexbox, an extreme example
    of vendor prefixing thanks to not just multiple vendor versions but also different
    specifications of the feature. And understanding and remembering everything you
    need to write in the current format and each previous format is not a whole lot
    of fun.
  prefs: []
  type: TYPE_NORMAL
- en: I don't know about you, but I'd rather spend my time doing something more productive
    than writing out that little lot each time! In short, if you intend to use Flexbox
    in anger, take the time to setup an auto-prefixing solution.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing your auto-prefixing solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the sake of your sanity, to accurately and easily add vendor-prefixes to
    CSS, use some form of automatic prefixing solution. Right now, I favor Autoprefixer
    ([https://github.com/postcss/autoprefixer](https://github.com/postcss/autoprefixer)).
    It's fast, easy to setup and very accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are versions of Autoprefixer for most setups; you don''t necessarily
    need a command line based build tool (for example, Gulp or Grunt). For example,
    if you use Sublime Text, there is a version that will work straight from the command
    palette: [https://github.com/sindresorhus/sublime-autoprefixer](https://github.com/sindresorhus/sublime-autoprefixer).
    There are also versions of Autoprefixer for Atom, Brackets, and Visual Studio.'
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, unless essential to illustrate a point, there will be no
    more vendor prefixes in the code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Flexy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flexbox has four key characteristics: **direction**, **alignment**, **ordering**,
    and **flexibility**. We''ll cover all these characteristics and how they relate
    by way of a few examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The examples are deliberately simplistic; just moving some boxes and their content
    around so we can understand the principals of how Flexbox works.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect vertically centered text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that this first Flexbox example is `example_03-03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Perfect vertically centered text](img/B03777_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the entire CSS rule that''s styling that markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The majority of the property/value pairs in that rule are merely setting colors
    and font sizing. The three properties we are interested in are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have not used Flexbox or any of the properties in the related Box Alignment
    specification ([http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/))
    these properties probably seem a little alien. Let''s consider what each one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display: flex`: This is the bread and butter of Flexbox. This merely sets
    the item to be a Flexbox (as opposed to a block, inline-block, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`align-items`: This aligns the items within a Flexbox in the cross axis (vertically
    centering the text in our example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`justify-content`: This sets the main axis centring of the content. With a
    Flexbox row, you can think of it like the button in a word processor that sets
    the text to the left, right, or center (although there are additional `justify-content`
    values we will look at shortly).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK, before we get further into the properties of Flexbox, we will consider a
    few more examples.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some of these examples I'm making use of the Google hosted font 'Oswald'
    (with a fallback to a sans-serif font). In [Chapter 5](ch05.html "Chapter 5. CSS3
    – Selectors, Typography, Color Modes, and New Features"), *CSS3 – Selectors, Typography,
    Color Modes, and New Features*, we will look at how we can use the `@font-face`
    rule to link to custom font files.
  prefs: []
  type: TYPE_NORMAL
- en: Offset items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How about a simple list of navigation items, but with one offset to one side?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Offset items](img/B03777_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'How about that—not a single float, inline-block, or table-cell needed! When
    you set `display: flex;` on a wrapping element, the children of that element become
    flex-items which then get laid out using the flex layout model. The magic property
    here is `margin-left: auto` which makes that item use all available margin on
    that side.'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse the order of items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Want to reverse the order of the items?
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse the order of items](img/B03777_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s as easy as adding `flex-direction: row-reverse;` to the wrapping element
    and changing `margin-left: auto` to `margin-right: auto` on the offset item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How about if we want them laid out vertically instead?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simple. Change to `flex-direction: column;` on the wrapping element and remove
    the auto margin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Column reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Want them stacked in the opposite direction? Just change to `flex-direction:
    column-reverse;` and you''re done.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should be aware that there is a `flex-flow` property that is shorthand
    for setting `flex-direction` and `flex-wrap` in one. For example, `flex-flow:
    row wrap;` would set the direction to a row and set wrapping on. However, at least
    initially, I find it easier to specify the two settings separately. The `flex-wrap`
    property is also absent from the oldest Flexbox implementations so can render
    the whole declaration void in certain browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Different Flexbox layouts inside different media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the name suggests, Flexbox is inherently flexible so how about we go for
    a column list of items at smaller viewports and a row style layout when space
    allows. It''s a piece of cake with Flexbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can view that as `example_03-05`. Be sure to resize the browser window to
    see the different layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Inline-flex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flexbox has an inline variant to complement inline-block and inline-table.
    As you might have guessed it is `display: inline-flex;`. Thanks to its beautiful
    centering abilities you can do some wacky things with very little effort.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inline-flex](img/B03777_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the CSS for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When items are set as `inline-flex` anonymously (for example, their parent
    element is not set to `display: flex;`) then they retain whitespace between elements,
    just like inline-block or inline-table do. However, if they are within a flex
    container, then whitespace is removed, much as it is with table-cell items within
    a table.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't always have to center items within a Flexbox. There are
    a number of different options. Let's look at those now.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox alignment properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to play with this example, you can find it at `example_03-07`. Remember
    the example code you download will be at the point where we finish this section
    so if you want to 'work along' you may prefer to delete the CSS in the example
    file and start again.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to understand with Flexbox alignment is the concept of axis.
    There are two axis to consider, the 'main axis' and the 'cross axis'. What each
    of these represents depends upon the direction the Flexbox is heading. For example,
    if the direction of your Flexbox is set to `row`, the main axis will be the horizontal
    axis and the cross axis will be the vertical axis.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if your Flexbox direction is set to `column`, the main axis will
    be the vertical axis and the cross axis will be the horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification ([http://www.w3.org/TR/css-flexbox-1/#justify-content-property](http://www.w3.org/TR/css-flexbox-1/#justify-content-property))
    provides the following illustration to aid authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flexbox alignment properties](img/B03777_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the basic markup of our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set basic Flexbox related styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, that produces this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flexbox alignment properties](img/B03777_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Right, let's test drive the effects of some of these properties.
  prefs: []
  type: TYPE_NORMAL
- en: The align-items property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `align-items` property positions items in the cross axis. If we apply this
    property to our wrapping element like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would imagine, the item within that box gets centered vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The align-items property](img/B03777_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same effect would be applied to any number of children within.
  prefs: []
  type: TYPE_NORMAL
- en: The align-self property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to pull just one item into a different alignment. Individual
    flex items can use the `align-self` property to align themselves. At this point,
    I''ll remove the previous alignment properties, add another two items into the
    markup (they have been given the `.FlexInner` HTML class), and on the middle one
    I''ll add another HTML class (`.AlignSelf`) and use it to add the `align-self`
    property. Viewing the CSS at this point may be more illustrative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the effect in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The align-self property](img/B03777_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wow! Flexbox really makes these kinds of changes trivial. In that example the
    value of `align-self` was set to `flex-end`. Let's consider the possible values
    we could use on the cross axis before looking at alignment in the main axis.
  prefs: []
  type: TYPE_NORMAL
- en: Possible alignment values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For cross axis alignment, Flexbox has the following possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex-start`: Setting an element to `flex-start` would make it begin at the
    ''starting'' edge of its flex container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex-end`: Setting to `flex-end` would align the element at the end of the
    flex container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`: Puts it in the middle of the flex container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`baseline`: Sets all flex items in the container so that their baselines align'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch`: Makes the items stretch to the size of their flex container (in
    the cross axis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some particulars inherent to using these properties, so if something
    isn''t playing happily, always refer to the specification for any edge case scenarios:
    [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).'
  prefs: []
  type: TYPE_NORMAL
- en: The justify-content property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alignment in the main axis is controlled with `justify-content` (for non Flexbox/block-level
    items, the `justify-self` property has also been proposed ([http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/)).
    Possible values for `justify-content` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex-start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex-end`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space-between`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space-around`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three do exactly what you would now expect. However, let''s take
    a look what `space-between` and `space-around` do. Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And then consider this CSS. We are setting the three flex-items (`FlexInner`)
    to each be 25% width, wrapped by a flex container (`FlexWrapper`) set to be 100%
    width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As the three items will only take up 75% of the available space, `justify-content`
    explains what we would like the browser to do with the remaining space. A value
    of `space-between` puts equal amount of space between the items and `space-around`
    puts it around. Perhaps a screenshot here will help: This is `space-between`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The justify-content property](img/B03777_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And here is what happens if we switch to `space-around`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The justify-content property](img/B03777_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Those two values are pretty handy I think you will agree.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The various alignment properties of Flexbox are currently being specified into
    the CSS Box Alignment Module Level 3\. This should give the same fundamental alignment
    powers to other display properties, such as `display: block;` and `display: table;`.
    The specification is still being worked upon so check the status at [http://www.w3.org/TR/css3-align/](http://www.w3.org/TR/css3-align/).'
  prefs: []
  type: TYPE_NORMAL
- en: The flex property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve used the `width` property on those flex-items but it''s also possible
    to define the width, or ''flexiness'' if you will, with the `flex` property. To
    illustrate, consider another example; same markup, but amended CSS for the items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flex` property is actually a shorthand way of specifying three separate
    properties: `flex-grow`, `flex-shrink`, and `flex-basis`. The specification covers
    these individual properties in more detail at [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).
    However, the specification recommends that authors use the `flex` shorthand property,
    so that''s what we''re rolling with here, capiche?'
  prefs: []
  type: TYPE_NORMAL
- en: '![The flex property](img/B03777_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For flex-items, if a `flex` property is present (and the browser supports it),
    it is used to size the item rather than a width or height value (if present).
    Even if the width or height value is specified after the `flex` property, it will
    still have no effect. Let's look at what each of these values do.
  prefs: []
  type: TYPE_NORMAL
- en: '`flex-grow` (the first value you can pass to flex) is the amount, relevant
    to the other flex items, the flex-item can grow when free space is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex-shrink` is the amount the flex-item can shrink relevant to the other
    flex-items when there is not enough space available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex-basis` (the final value you can pass to Flex) is the basis size the flex-item
    is sized to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although it''s possible to just write `flex: 1`, I recommend writing all the
    values into a `flex` property. I think it''s clearer what you intend to happen.
    For example: `flex: 1 1 auto` means that the item will grow into 1 part of the
    available space, it will also shrink 1 part when space is lacking and the basis
    size for the flexing is the intrinsic width of the content (the size the content
    would be if flex wasn''t involved).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another: `flex: 0 0 50px` means this item will neither grow nor
    shrink and it''s basis is 50px (so it will be 50px regardless of any free space).
    How about flex: 2 0 50%—that''s going to take two ''lots'' of available space,
    it won''t shrink and its basis size is 50%. Hopefully, these brief examples have
    demystified the flex property a little.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set the `flex-shrink` value to zero, then the flex basis effectively
    behaves like a minimum width.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the `flex` property as a way to set ratios. With each flex-item
    set to 1, they each take an equal amount of space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The flex property](img/B03777_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right, so to test the theory, let''s amend the HTML classes in the markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And then here is the amended CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, `FlexOne` takes up 1.5 the amount of space that `FlexTwo`
    and `FlexThree` take up.
  prefs: []
  type: TYPE_NORMAL
- en: This shorthand syntax really becomes useful for quickly bashing out relationships
    between items. For example, if the request comes in, "that needs to be 1.8 times
    wider than the others", you could easily facilitate that request with the flex
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, the incredibly powerful flex property is starting to make a little
    sense now?
  prefs: []
  type: TYPE_NORMAL
- en: I could write chapters and chapters on Flexbox! There are so many examples we
    could look at. However, before we move on to the other main topic of this chapter
    (responsive images) there are just two more things I would like to share with
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Simple sticky footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you want a footer to sit at the bottom of the viewport when there is
    not enough content to push it there. This has always been a pain to achieve but
    with Flexbox it''s simple. Consider this markup (which can be viewed in `example_03-08`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at that in the browser and test adding more content into `.MainContentdiv`.
    You'll see that when there is not enough content, the footer is stuck to the bottom
    of the viewport. When there is, it sits below the content.
  prefs: []
  type: TYPE_NORMAL
- en: This works because our `flex` property is set to grow where space is available.
    As our body is a flex container of 100% minimum height, the main content can grow
    into all that available space. Beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: Changing source order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the dawn of CSS, there has only been one way to switch the visual ordering
    of HTML elements in a web page. That was achieved by wrapping elements in something
    set to `display: table` and then switching the `display` property on the items
    within, between `display: table-caption` (puts it on top), `display: table-footer-group`
    (sends it to the bottom), and `display: table-header-group` (sends it to just
    below the item set to `display: table-caption`). However, as robust as this technique
    is, it was a happy accident, rather than the true intention of these settings.'
  prefs: []
  type: TYPE_NORMAL
- en: However, Flexbox has visual source re-ordering built in. Let's have a look at
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that the third item within the wrapper has a HTML class of
    `FlexContent`—imagine that this `div` is going to hold the main content for the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let's keep things simple. We will add some simple colors to more easily
    differentiate the sections and just get these items one under another in the same
    order they appear in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'That renders in the browser like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing source order](img/B03777_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, suppose we want to switch the order of `.FlexContent` to be the first
    item, without touching the markup. With Flexbox it''s as simple as adding a single
    property/value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `order` property lets us revise the order of items within a Flexbox simply
    and sanely. In this example, a value of `-1` means that we want it to be before
    all the others.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to switch items around quite a bit, I'd recommend being a little
    more declarative and add an order number for each. This makes things a little
    easier to understand when you combine them with media queries.
  prefs: []
  type: TYPE_NORMAL
- en: Let's combine our new source order changing powers with some media queries to
    produce not just a different layout at different sizes but different ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: you can view this finished example at `example_03-09`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it''s generally considered wise to have your main content at the beginning
    of a document, let''s revise our markup to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: First the page content, then our two sidebar areas, then the header and finally
    the footer. As I'll be using Flexbox, we can structure the HTML in the order that
    makes sense for the document, regardless of how things need to be laid out visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the smallest screens (outside of any media query), I''ll go with this ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives us this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing source order](img/B03777_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, at a breakpoint, I''m switching to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives us this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing source order](img/B03777_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In that example, the shortcut `flex-flow: row wrap` has been used. That allows
    the flex items to wrap onto multiple lines. It''s one of the poorer supported
    properties, so depending upon how far back support is needed, it might be necessary
    to wrap the content and two side bars in another element.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up Flexbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are near endless possibilities when using the Flexbox layout system and
    due to its inherent 'flexiness', it's a perfect match for responsive design. If
    you've never built anything with Flexbox before, all the new properties and values
    can seem a little odd and it's sometimes disconcertingly easy to achieve layouts
    that have previously taken far more work. To double-check implementation details
    against the latest version of the specification, make sure you check out [http://www.w3.org/TR/css-flexbox-1/](http://www.w3.org/TR/css-flexbox-1/).
  prefs: []
  type: TYPE_NORMAL
- en: I think you'll love building things with Flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hot on the heels of the Flexible Box Layout Module is the Grid Layout Module
    Level 1: [http://www.w3.org/TR/css3-grid-layout/](http://www.w3.org/TR/css3-grid-layout/).'
  prefs: []
  type: TYPE_NORMAL
- en: It's relatively immature compared to Flexbox (much like the early history of
    Flexbox, grid layout has already been through some major changes) and as such
    we aren't looking at it in detail here. However, it's definitely one to keep an
    eye on as it promises us even more layout powers.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serving the appropriate image to users based upon the particulars of their device
    and environment has always been a tricky problem. This problem was highlighted
    with the advent of responsive web design, the very nature of which is to serve
    a single code base to each and every device.
  prefs: []
  type: TYPE_NORMAL
- en: The intrinsic problem of responsive images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an author, you cannot know or plan for every possible device that may visit
    your site now or in the future. Only a browser knows the particulars of the device
    using it (screen size and device capabilities for example) at the moment it serves
    up and renders the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely only the author (you and I) know what versions of an image we have
    at our disposal. For example, we may have three versions of the same image. A
    small, medium, and large: each with increasing dimensions to cover off a host
    of screen size and density eventualities. The browser does not know this. We have
    to tell it.'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the conundrum, we have halve of the solution in that we know what
    images we have, and the browser has the other halve of the solution in that the
    browser knows what device is visiting the site and what the most appropriate image
    dimensions and resolution would be.
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell the browser what images we have at our disposal so that it may
    chose the most appropriate one for the user?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first few years of responsive web design, there was no specified way.
    Thankfully, now we have the Embedded Content specification: [https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The Embedded Content specification describes ways to deal with the simple resolution
    switching of images (to facilitate a user on a higher resolution screen receiving
    a higher resolution version of images) and 'art direction' situations, for when
    authors want users to see a totally different image, depending upon a number of
    device characteristics (think media queries).
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating responsive image examples is tricky. It's not possible to appreciate
    on a single screen the different images that could be loaded with a particular
    syntax or technique. Therefore, the examples that follow will be mainly code and
    you'll just have to trust me that's it's going to produce the result you need
    in supporting browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the two most common scenarios you likely need responsive images
    for. These are switching an image when a different resolution is needed, and changing
    an image entirely depending upon the available viewport space.
  prefs: []
  type: TYPE_NORMAL
- en: Simple resolution switching with srcset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's suppose you have three versions of an image. They all look the same except
    one is a smaller size or resolution intended for smaller viewports, another caters
    for medium size viewports, and finally a larger version covers off every other
    viewport. Here is how we can let the browser know we have these three versions
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is about as simple as things get with responsive images, so let's ensure
    that syntax makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the `src` attribute, which you will already be familiar with,
    has a dual role here; it's specifying the small 1x version of the image and it
    also acts as a fallback image if the browser doesn't support the `srcset` attribute.
    That's why we are using it for the small image. This way, older browsers that
    will ignore the `srcset` information will get the smallest and best performing
    image possible.
  prefs: []
  type: TYPE_NORMAL
- en: For browsers that understand `srcset`, with that attribute, we provide a comma-separated
    list of images that the browser can choose from. After the image name (such as
    `scones_medium.jpg`) we issue a simple resolution hint. In this example 1.5x and
    2x have been used but any integer would be valid. For example, 3x or 4x would
    work too (providing you can find a suitably high resolution screen).
  prefs: []
  type: TYPE_NORMAL
- en: However, there is an issue here; a device with a 1440px wide, 1x screen will
    get the same image as a 480px wide, 3x screen. That may or may not be the desired
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced switching with srcset and sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider another situation. In a responsive web design, it wouldn''t
    be uncommon for an image to be the full viewport width on smaller viewports, but
    only half the width of the viewport at larger sizes. The main example in [Chapter
    1](ch01.html "Chapter 1. The Essentials of Responsive Web Design"), *The Essentials
    of Responsive Web Design*, was a typical example of this. Here''s how we can communicate
    these intentions to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inside the image tag we are utilizing `srcset` again. However, this time, after
    specifying the images we are adding a value with a w suffix. This tells the browser
    how wide the image is. In our example we have a 450px wide image (called `scones-small.jpg`)
    and a 900px wide image (called `scones-medium.jpg`). It's important to note this
    `w` suffixed value isn't a 'real' size. It's merely an indication to the browser,
    roughly equivalent to the width in 'CSS pixels'.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What exactly defines a pixel in CSS? I wondered that myself. Then I found the
    explanation at [http://www.w3.org/TR/css3-values/](http://www.w3.org/TR/css3-values/)
    and wished I hadn't wondered.
  prefs: []
  type: TYPE_NORMAL
- en: This `w` suffixed value makes more sense when we factor in the `sizes` attribute.
    The `sizes` attribute allows us to communicate the intentions for our images to
    the browser. In our preceding example, the first value is equivalent to, "for
    devices that are at least 17em wide, I intend the image to be shown around 100vw
    wide".
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If some of the units used, such as vh (where 1vh is equal to 1% of the viewport
    height) and vw (where 1vw is equal to 1% of the viewport width) don't make sense,
    be sure to read [Chapter 5](ch05.html "Chapter 5. CSS3 – Selectors, Typography,
    Color Modes, and New Features"), *CSS3 – Selectors, Typography, Color Modes, and
    New Features*.
  prefs: []
  type: TYPE_NORMAL
- en: The second part is effectively, "Hi browser, for devices that are at least 40em
    wide, I only intend the image to be shown at 50vw". That may seem a little redundant
    until you factor in DPI (or DPR for Device Pixel Ratio). For example, on a 320px
    wide device with a 2x resolution (effectively requiring a 640px wide image if
    shown at full width) the browser might decide the 900px wide image is actually
    a better match as it's the first option it has for an image that would be big
    enough to fulfill the required size.
  prefs: []
  type: TYPE_NORMAL
- en: Did you say the browser 'might' pick one image over another?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important thing to remember is that the `sizes` attributes are merely hints
    to the browser. That doesn't necessarily ensure that the browser will always obey.
    This is a good thing. Trust me, it really is. It means that in future, if there
    is a reliable way for browsers to ascertain network conditions, it may choose
    to serve one image over another because it knows things at that point that we
    can't possibly know at this point as the author. Perhaps a user has a setting
    on their device to 'only download 1x images' or 'only download 2x images'; in
    these scenarios the browser can make the best call.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to the browser deciding is to use the `picture` element. Using
    this element ensures that the browser serves up the exact image you asked for.
    Let's take a look at how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Art direction with the picture element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final scenario you may find yourself in is one in which you have different
    images that are applicable at different viewport sizes. For example, consider
    our cake based example again from [Chapter 1](ch01.html "Chapter 1. The Essentials
    of Responsive Web Design"), *The Essentials of Responsive Web Design*. Maybe on
    the smallest screens we would like a close up of the scone with a generous helping
    of jam and cream on top. For larger screens, perhaps we have a wider image we
    would like to use. Perhaps it''s a wide shot of a table loaded up with all manner
    of cakes. Finally, for larger viewports still, perhaps we want to see the exterior
    of a cake shop on a village street with people sat outside eating cakes and drinking
    tea (I know, sounds like nirvana, right?). We need three different images that
    are most appropriate at different viewport ranges. Here is how we could solve
    this with `picture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First of all, be aware that when you use the `picture` element, it is merely
    a wrapper to facilitate other images making their way to the `img` tag within.
    If you want to style the images in any way, it's the `img` that should get your
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the `srcset` attribute here works exactly the same as the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Thirdly, the `img` tag provides your fallback image and also the image that
    will be displayed if a browser understands picture but none of the media definitions
    match. Just to be crystal clear; do not omit the `img` tag from within a `picture`
    element or things won't end well.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference with picture is that we have a `source` tag. Here we can
    use media query style expressions to explicitly tell the browser which asset to
    use in a matching situation. For example, our first one in the preceding example
    is telling the browser, "Hey you, if the screen is at least 30em wide, load in
    the `cake-table.jpg` image instead". As long as conditions match, the browser
    will dutifully obey.
  prefs: []
  type: TYPE_NORMAL
- en: Facilitate new-fangled image formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a bonus, `picture` also facilitates us providing alternate formats of an
    image. ''WebP'' (more info at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/))
    is a newer format that plenty of browsers lack support for ([http://caniuse.com/](http://caniuse.com/)).
    For those that do, we can offer a file in that format and a more common format
    for those that don''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully this is now a little more straightforward. Instead of the `media`
    attribute, we are using `type` (we will do more with the type attribute in [Chapter
    4](ch04.html "Chapter 4. HTML5 for Responsive Web Designs"), *HTML5 for Responsive
    Web Designs*), which, although more typically used to specify video sources (possible
    video source types can be found at [https://html.spec.whatwg.org/multipage/embedded-content.html](https://html.spec.whatwg.org/multipage/embedded-content.html)),
    allows us here to define WebP as the preferred image format. If the browser can
    display it, it will, otherwise it will grab the default one in the `img` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are plenty of older browsers that will never be able to make use of the
    official W3C responsive images. Unless there is a specific reason not to, my advice
    would be to allow the built-in fallback capabilities do their thing. Use a sensibly
    sized fallback image to provide them with a good experience and allow more capable
    devices to enjoy an enhanced experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground in this chapter. We have spent considerable time
    getting acquainted with Flexbox, the most recent, powerful, and now well-supported
    layout technique. We have also covered how we can serve up any number of alternative
    images to our users depending upon the problems we need to solve. By making use
    of `srcset`, `sizes`, and `picture`, our users should always get the most appropriate
    image for their needs, both now and in the future.
  prefs: []
  type: TYPE_NORMAL
- en: So far we've looked at lots of CSS and some of its emerging possibilities and
    capabilities, but only with responsive images have we looked at more modern markup.
    Let's address that issue next.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to be all about HTML5\. What it offers, what's changed
    from the previous version, and for the most part, how we can make best use of
    its new semantic elements to create cleaner, more meaningful HTML documents.
  prefs: []
  type: TYPE_NORMAL
