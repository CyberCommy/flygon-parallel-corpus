- en: Optimizing the Performance of Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our JavaScript code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of custom UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping animations running at 60 FPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the most out of ListView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting the performance of our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of native iOS modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of native Android modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of native iOS UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the performance of native Android UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is a key requirement of almost every single piece of technology
    in software development. React Native was introduced to solve the issue of poor
    performance that existed in hybrid apps that wrap web applications in a native
    container. React Native has an architecture that lends itself to both flexibility
    and excellent performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When considering the performance of a React Native app, it is important to
    think about the big picture of how React Native works. There are three major parts
    to a React Native app, and their relative performance is depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5e5d3840-ef23-43ba-b367-5883966d71e8.png)'
  prefs: []
  type: TYPE_IMG
- en: The recipes in this chapter focus on using lower-level functions that take up
    less memory and have fewer operations, thus lowering the time it takes for a task
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our JavaScript code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's safe to say that your React Native apps will probably be written mostly
    in JavaScript. There may be some native modules and custom UI components, but
    for the most part, all of the views and business logic will likely be written
    in JSX and JavaScript. And if you're using modern JavaScript development techniques,
    you'll also be using language constructs introduced with ES6, ES7, and beyond.
    These may be available natively as part of the JavaScript interpreter bundled
    with React Native (JavaScriptCore) or polyfilled by the Babel transpiler. Since
    JavaScript probably constitutes the majority of any given React Native app, this
    should be the first part we optimize in order to squeeze extra performance out
    of the app.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will provide some helpful tips for optimizing JavaScript code to
    make it as performant as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is not necessarily dependent on React Native, since it focuses on
    the JavaScript that's used to write any React app. Some of these suggestions are
    micro-optimizations that will probably only improve performance on older/slower
    devices. Depending on which devices you intend to support, some tips will go further
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first optimization to look at is speeding up iterations. Often, you''ll
    likely be using functions that take iterator functions as arguments (`forEach`,
    `filter`, and `map`). As a rule of thumb, these will be slower than doing a standard
    `for` loop. If the size of the collection you''re iterating over is very large,
    this could make a difference. Here''s an example of a faster filter function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When optimizing iterations, it can also be more performant to ensure that you
    store the variables you are accessing on the iteration, somewhere close by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also optimize your logical expressions. Keep your fastest and closest
    executing statements on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While modern JavaScript (ES6, ES7, and so on) constructs can be more enjoyable
    to develop with, some of their features execute more slowly than their ES5 counterparts.
    These features can include `for of`, `generators`, `Object.assign`, and others.
    A good reference for performance comparisons can be found at [https://kpdecker.github.io/six-speed/](https://kpdecker.github.io/six-speed/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can be helpful to avoid `try-catch` statements, since they can affect the
    optimization made by the interpreter (as is the case in V8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Arrays should have members that are all of the same type. If you need to have
    a collection where the type can vary, use an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript performance is a topic of constant debate. It is sometimes difficult
    to keep up with the latest in performance metrics, since Google, Apple, Mozilla,
    and the global open source community is always hard at work improving their JavaScript
    engines. For React Native, we focus on WebKit's JavaScriptCore.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of custom UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building your React Native app, it's a safe bet that you will be creating
    custom UI components. These components can either be compositions of several other
    components or a component that builds on top of an existing component and adds
    more functionality. With added functionality, complexity also increases. This
    increased complexity leads to more operations, and in turn, the potential for
    slowdowns. Fortunately, there are some ways to make sure that our custom UI components
    are performing the best they can. This recipe shows several techniques for getting
    the most out of our components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires that you have a React Native app with some custom components.
    As these performance suggestions may or may not provide value to your app, use
    discretion when you choose to apply these to your code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first optimization we should look at is what is tracked in the `state` object
    of a given component. We should make sure that all the objects we have in the
    `state` are being used, and that each can potentially change, causing a desired
    re-render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the `render` function of each component. The overall goal is
    to keep this function performing as fast as possible, so try to ensure that no
    long-running processes occur within it. If you can, cache computations and constant
    values outside the `render` function so that they are not instantiated every time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have conditional JSX that may return in the `render` function, `return`
    as early as possible. Here''s a trivial example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important optimization we can make is to skip the `render` method
    altogether if it isn''t needed. This is done by implementing the `shouldComponentUpdate`
    method and returning `false` from it, making it a pure component. Here''s how
    we can make a component a `PureComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of your React Native apps will consist of custom components. There
    will be a mix of stateful and stateless components. As highlighted in *step 2*,
    the overall goal is to render our component in the shortest amount of time possible.
    Another gain can be achieved if a component can be architected to only have to
    render the component once and then be left untouched, as covered in *step 4*.
    For more information on how pure components are used and how they can be beneficial,
    check out [https://60devs.com/pure-component-in-react.html](https://60devs.com/pure-component-in-react.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find some more information about React component performance optimizations
    in the official documentation at [https://reactjs.org/docs/optimizing-performance.html](https://reactjs.org/docs/optimizing-performance.html).
  prefs: []
  type: TYPE_NORMAL
- en: Keeping animations running at 60 FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of any quality mobile app is the fluidity of the user interface.
    Animations are used to provide a rich user experience, and any jank or jitter
    can negatively affect this. Animations will likely be used for all kinds of interactions,
    from changing between views, to reacting to a user's touch interaction on a component.
    One of the most important factors in creating high-quality animations is making
    sure that they do not block the JavaScript thread. To keep animations fluid and
    not interrupt UI interactions, the render loop has to render each frame in 16.67
    ms, so that 60 FPS can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at several techniques for improving the
    performance of animations. These techniques focus in particular on preventing
    JavaScript execution from interrupting the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll assume that you have a React Native app that has some
    animations defined.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, when debugging animation performance in React Native, we'll
    want to enable the performance monitor. To do so, show the Dev Menu (shake the
    device or *cmd* + *D* from the simulator) and tap Show Perf Monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output in iOS will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/736fdab4-9302-4864-919c-976104b70754.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The output in Android will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4bccef67-4132-4af7-a859-3cacb76cf832.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are looking to animate a component's transition (`opacity`) or dimensions
    (`width`, `height`), then make sure to use `LayoutAnimation`. You can find an
    example of using `LayoutAnimation` in [Chapter 6](84fe882a-ef68-470e-8c13-d220b128d4e0.xhtml), *Adding
    Basic* *Animations to Your App*, in the *Expanding and collapsing containers* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to use `LayoutAnimation` on Android, you need to add the following
    code when your application starts: `UIManager.setLayoutAnimationEnabledExperimental
    && UIManager.setLayoutAnimationEnabledExperimental(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need finite control over the animations, it is recommended that you
    use the `Animated` library that comes with React Native. This library allows you
    to offload all of the animation work onto the native UI thread. To do so, we have
    to add the `useNativeDriver` property to our `Animated` call. Let''s take a sample
    `Animated` example and offload it to the native thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Currently, only a subset of the functionality of the Animated library supports
    native offloading. Please refer to the *There's more...* section for a compatibility
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unable to offload your animation work onto the native thread, there
    is still a solution for providing a smooth experience. We can use the `InteractionManager`
    to execute a task after the animations have completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you are still suffering from poor performance, you'll have to either
    rethink your animation strategy or implement the poorly performing view as a custom
    UI view component on the target platform(s). This would mean implementing both
    your view and animation natively using the iOS and/or Android SDK. In [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*,
    we covered creating custom UI components in the *Rendering custom iOS view components* and
    *Rendering custom Android view components* recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tips in this recipe focus on the simple goal of preventing the JavaScript
    thread from locking. The moment our JavaScript thread begins to drop frames (lock),
    we lose the ability to interact with our application, even if it's for a fraction
    of a second. It may seem inconsequential, but the effect is felt immediately by
    a savvy user. The focus of the tips in this recipe is to offload animations onto
    the GPU. When the animation is running on the main thread (the native layer, rendered
    by the GPU), the user can interact with the app freely without stuttering, hanging,
    jank, or jitters.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a quick reference for where `useNativeDriver` is usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **iOS** | **Android** |'
  prefs: []
  type: TYPE_TB
- en: '| `style`, `value`, `propertys` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `decay` |  | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `timing` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring` |  | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `multiply` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `modulo` | **√** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `diffClamp` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `interpoloate` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `event` |  | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `division` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: '| `transform` | **√** | **√** |'
  prefs: []
  type: TYPE_TB
- en: Getting the most out of ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native provides a pretty performant list component out of the box. It
    is extremely flexible, supports rendering almost any component you can imagine
    inside of it, and renders them rather quickly. If you'd like to read some more
    examples of how to work with `ListView`, there are a couple of recipes in this
    book, including *Displaying a list of items* in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*, that use it. The React Native `ListView` is built
    on top of `ScrollView` to achieve the flexibility of rendering variable-height
    rows with any view component.
  prefs: []
  type: TYPE_NORMAL
- en: The major performance and resource drawback of the `ListView` component occurs
    when you are working with an extremely large list. As the user scrolls through
    the list, the next page of rows is rendered at the bottom. The invisible rows
    at the top can be set to be removed from the render tree, which we will cover
    shortly. However, the references to the rows are still in memory as long as the
    component is mounted. Naturally, as our component uses up the available memory,
    there will be less room for quickly accessible storage for the upcoming components.
    This recipe will cover dealing with some of these potential performance and memory
    resource issues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we assume that you have a React Native app that is making use
    of a `ListView`, preferably with a large dataset.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with some optimizations we can make to our vanilla `ListView` component.
    If we set the `initialListSize` property to `1`, we can speed up the initial rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we can bump up the `pageSize` if the component being rendered in each
    row is not complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another optimization is setting the `scrollRenderAheadDistance` to a comfortable
    value. If you can expect users to rarely scroll past the initial viewport, or
    that they're likely to scroll slowly, then you can lower the value. This prevents
    the `ListView` from rendering too many rows in advance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, the last optimization we can make use of is the `removeClippedSubviews`
    property. However, the official documentation states the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"The feature may have bugs (missing content) in some circumstances - use at
    your own risk."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining *steps 1 to step 4* can be seen in the following example code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with developing any app, the more flexible and complex something is, the
    slower it performs. `ListView` is an excellent example of this concept. It is
    extremely flexible, since it can render any `View` in a row, but it can quickly
    bring your application to a halt if not used carefully. The result of the optimizations
    defined in *step 1* to *step 4* will vary across different situations based on
    what you are rendering and the data structure that is being used by the `ListView`.
    You should experiment with these values until you find a good balance. As a last
    resort, if you are still unable to achieve the required performance benchmark,
    you can look at some of the community modules that provide new `ListView` implementations
    or alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of some of the third-party `ListView` implementations
    that promise increased performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`recyclerlistview`: This library is the most robust alternative to `ListView`,
    boasting a long list of improvements and features, including support for staggered
    grid layouts, horizontal mode, and footer support. The repository is located at
    [https://github.com/Flipkart/recyclerlistview](https://github.com/Flipkart/recyclerlistview).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-sglistview`: This takes `removeClippedSubviews` to the next level
    by flushing the memory when the offscreen rows are removed from the render tree.
    The repository is located at [https://github.com/sghiassy/react-native-sglistview](https://github.com/sghiassy/react-native-sglistview).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boosting the performance of our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reason for React Native's existence is building native apps with JavaScript.
    This is different than similar frameworks such as Ionic or Cordova hybrid applications,
    which wrap a web application written in JavaScript and attempt to emulate native
    app behavior. Those web applications only have access to native APIs for performing
    processing, but cannot render native views inside their apps. This is one major
    benefit to React Native apps, thus making them inherently faster than hybrid apps.
    Since it's so much more performant out of the box, we generally do not have to
    worry about overall performance as much as we would with a hybrid web app. Still,
    with a little extra effort, a slight improvement in performance might be achievable.
    This recipe will provide some quick wins that we can use to build faster React
    Native apps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest optimization we can make is to not output any statements to the
    console. Performing a `console.log` statement is not as trivial a task as you'd
    imagine for the framework, so it's recommended to remove all console statements
    when you are ready to bundle your final app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use a lot of console statements during development, you can have Babel
    automatically remove them when creating the bundle by using the `transform-remove-console` plugin.
    This can be installed into the project via the Terminal using `yarn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the package installed, you can add it to the project by adding a `.babelrc`
    file containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, make sure that when you're analyzing your performance, your app is running
    in production mode, preferably on a device. If you are curious about how to do
    this, you can refer to the *Deploying test builds to HockeyApp* recipe in Chapter
    13, *Deploying Our App*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, when you are animating the position or layout of a `View`, you may
    notice performance dips in the UI thread. You can mitigate this by setting the
    `shouldRasterizeIOS` and `renderToHardwareTextureAndroid` properties to true for
    iOS and Android platforms. Be mindful that this may increase memory usage significantly,
    so be sure to test the performance after these changes as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you find that you need to transition views using a navigation state change
    while also performing synchronous, potentially long-running processes, it can
    become a performance bottleneck. This commonly occurs when building a `DataSource`
    for a `ListView` or when transforming data to power the upcoming view. You should
    experiment with processing only an initial subset of the data, enough to render
    the UI quickly enough. Once the animation completes between page transitions,
    you can use `InteractionManager` to load the rest of the data. You can refer to
    the *Keeping animations running at 60 FPS* recipe for more information on how
    to use `InteractionManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if you have identified a particular component or task that is slowing
    down your app, and cannot find a viable solution, then you should consider moving
    it to the native thread by creating a native module or native UI component to
    implement this piece of functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers some higher-level and broader-scoped tips for all React Native
    apps. The most significant performance gains you will likely see from these tips
    are from moving a component to the native layer, as covered in *step 7*.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of native iOS modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, when building a React Native app, you will need to work with native Android
    and iOS code. You may have built these native modules to expose some extra functionality
    provided by a native API, or perhaps your app needed to perform an intensive background
    task.
  prefs: []
  type: TYPE_NORMAL
- en: As was touched on earlier, working in the native layer really allows you to
    make use of a device's full capacity. However, it doesn't mean that the code we
    write will automatically be the fastest it could be. There's always room to optimize
    and achieve performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will provide some tips on how to make your Objective-C code
    run a bit faster using the iOS SDKs. We will also consider how React Native and
    the React Native bridge, which is used to communicate between the JavaScript and
    the native layers, fit into the bigger picture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a React Native app that uses native modules that
    have been created for iOS. If you need help with writing native modules, take
    a look at the *Exposing custom iOS modules* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, when working with native modules, we have to be mindful
    of the data going through the React Native bridge. Keeping the data in cross-bridge
    events and callbacks to a minimum is always the goal, since the data serialization
    between Objective-C and JavaScript is very slow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you need to keep data cached in memory for consumption by the native module,
    keep it stored in a local property or field variable. Native modules are singletons.
    Do this instead of returning a large object to store in the React Native component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, we have to leverage classes that are large because they are robust
    in their feature set. For the Objective-C and iOS side of things, instead of instantiating
    something like `NSDateFormatter` in your method each time that you expose the
    feature via `RCT_EXPORT_METHOD`, store the reference of this class as a property
    or an instance variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, native methods such as `NSDateFormatter` are often extremely heavy,
    so avoiding them is advisable where possible. For instance, if your application
    can deal with just UNIX timestamps, then you can easily get an `NSDate` object
    from a timestamp with the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The most significant performance optimization you can make, if the situation
    presents itself, is spawning asynchronous background threads to handle intensive
    processing. React Native fits this model well, since it uses an asynchronous messaging/event
    system to communicate between the JavaScript and native threads. When your background
    process is complete, you can either invoke a callback/promise or fire an event
    for the JavaScript thread to pick up. To learn how to create and leverage background
    processes in React Native iOS native modules, check out the *Background processing
    on iOS* recipe in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objective-C code executes very quickly – almost as quickly as vanilla C. Therefore,
    the optimizations we perform do not have much to do with executing tasks but rather
    with how things are instantiated and by not blocking native threads. The biggest
    performance boost you'll see is by property using the **Grand Central Dispatch**
    (**GCD**) to spawn background processes, as described in *step 5*.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of native Android modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing your React Native application, you may find yourself writing
    native Android modules to either create cross-platform features on both iOS and
    Android or to make use of native APIs that have not been wrapped as first-party
    modules for Android but that do exist on iOS. Hopefully, you found some useful
    advice on working with native modules in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding
    Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover several techniques for speeding up our React Native
    Android native modules. Many of these techniques are limited to general development
    on Android,  and a few will address communicating with the React Native JavaScript
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a React Native app that makes use of the native
    modules you created for Android. If you need help with writing native modules,
    please take a look at the *Exposing custom Android modules* recipe in [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First and foremost, just as with iOS native modules, you'll want to limit the
    amount of data crossing the React Native bridge. Keeping the data that's in events
    and callbacks to a minimum will help to avoid slowdowns caused by the serialization
    between Java and JavaScript. Also, as with iOS, try to keep data cached in memory
    to be used by the native module; keep it stored in a private field. Native modules
    are singletons. This should be leveraged instead of returning a large object to
    store in the React Native component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When writing Java code for Android, you should do your best to avoid creating
    short-term objects. If you can, use primitives, especially for datasets such as
    arrays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is better to reuse objects instead of relying on the garbage collector to
    pick up an unused reference and instantiate a new object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Android SDK provides a memory-efficient data structure for replacing the
    use of a `Map`, which maps integers to objects, called `SparseArray`. Using it
    can reduce memory usage and improve performance. Here''s an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is also `SparseIntArray`, which maps integers to integers, and `SparseBooleanArray`,
    which maps integers to Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: While it may sound counterintuitive to developers used to OOP development in
    Java, avoiding the use of getters and setters by accessing the instance field
    directly can also improve performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're ever working with `String` concatenation, make use of `StringBuilder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, the most significant performance optimization you can make, if possible,
    is spawning asynchronous background threads to perform heavy computations by leveraging
    React Native's asynchronous messaging/event system to communicate between the
    JavaScript and native threads. When your background process is complete, you can
    either invoke a callback/promise or fire an event for the JavaScript thread to
    pick up. To learn how to create background processes in React Native Android native
    modules, please read the *Background processing on Android* recipe in [Chapter
    11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of the tips in this recipe revolve around efficient memory management.
    The Android OS uses a traditional-style garbage collector similar to the desktop
    Java VM. When the garbage collector kicks in, it can take anywhere between 100-200
    ms to free memory. *Steps 3-6* all provide suggestions that reduce the app's memory
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of native iOS UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native provides us with an excellent foundation to build almost any kind
    of user interface using built-in components and styling. Components built in Objective-C
    using the iOS SDK, OpenGL, or some other drawing library will generally perform
    better than composing the prebuilt components using JSX. When using these native
    view components, there are some use cases that may have a negative impact on app
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will focus on getting the most out of the iOS UIKit SDK when rendering
    custom views. Our goal is to render everything as quickly as possible for our
    application to run at 60 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a React Native app that renders custom native
    UI components you have written for iOS. If you need help with wrapping UI components
    in React Native, please take a look at the *Exposing custom iOS view components* recipe
    in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, only pass data across the React Native bridge when
    it is unavoidable to do otherwise, since data serialization between Objective-C
    and JavaScript types is slow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is data that you need to store for referencing sometime in the near
    future, it's better to store it in the native class that you initialized. Depending
    on your application, you can either store it as a property on the `ViewManager`,
    a singleton that serves instances of the `View`, or a property on the `View` itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your view component involves rendering multiple `UIView` instances as children
    of a parent `UIView` container, make sure all the instances have the `opaque`
    property set to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are rendering an image inside your view component (not using the React
    Native `Image` component), then setting your image to be the same dimension as
    the `UIImageView` component can help performance. Scaling, and other image transformations,
    are heavy operations that can impact frame rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One of the most impactful tweaks in writing iOS view components is avoiding
    offscreen rendering. Avoid doing the following with SDK functionality if possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using classes that start with the **Core Graphics** (**CG**) library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the `drawRect` implementation of `UIView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `shouldRasterize=YES`, or using `setMasksToBounds` or `setShadow` on
    your `UIView` instance's `layer` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom drawings using `CGContext`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need to add a shadow to your view, make sure to set the `shadowPath`
    to prevent offscreen rendering. Here''s an example of how the initialization and
    shadow definition should look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe focused on some helpful tips that allow the GPU to do as much of
    the work as it can. The second part discussed how to keep the load on the GPU
    as low as possible. Enforcing the `opaque` property in *step 3* tells the GPU
    not to worry about checking the visibility of other components so that it can
    calculate transparency. *Steps 5* and *step 6* prevent offscreen rendering. Offscreen
    rendering generates bitmap images using the CPU (which is a slow process) and,
    more importantly, it keeps the GPU from rendering the view until the images have
    been generated.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the performance of native Android UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last few years, Android native UI performance has improved significantly.
    This is primarily due to its ability to render components and layouts using GPU
    hardware acceleration. In your React Native app, you may find yourself using custom
    view components, especially if you want to use a built-in Android feature that
    has not yet been wrapped as a React Native component. Even though the Android
    platform has made a conscious effort to increase the performance of its UI, the
    way components are rendered can quickly negate all of these benefits.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll discuss a few ways to get the best performance out of
    our custom Android view components.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you should have a React Native application that renders custom
    native UI components you have written for Android. If you need help with wrapping
    UI components in React Native, check out the *Exposing custom Android view components* recipe
    in [Chapter 11](4c1e3a01-dd78-4767-8a74-d2e7245a86ba.xhtml), *Adding Native Functionality*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, only cross the React Native bridge with data when necessary.
    Keep the data in events and callbacks to a minimum as the data serialization between
    Java and JavaScript is slow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is data that you need to store for referencing sometime in the near
    future, it's better to store it in the native class that you've initialized. Depending
    on your application, you can either store it as a property on the `SimpleViewManager`,
    a singleton that serves instances of the `View`, or a property on the `View` itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When building out views, consider that components often consist of other child
    components. These components are held in a hierarchy of layouts. Over-nesting
    layouts can become a very expensive operation. If you are using multi-level nested
    `LinearLayout` instances, try to replace them with a single `RelativeLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can analyze the efficiency of your layout using the HierarchyViewer tool
     that's bundled inside the Android Device Monitor. To open it from the Android
    Device Monitor, click Window | Open Perspective... | Hierarchy View and select
    OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are performing repeated animations on your custom view natively in Java
    (not using the React Native Animated API), then you can leverage hardware layers
    to improve performance. Simply add a `withLayer` method call to your `animate`
    call. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, there aren't that many optimizations you can perform when it
    comes to rendering Android UI components. They generally revolve around not over-nesting
    layouts, since this increases complexity by orders of magnitude. When you have
    layout performance issues, the app is most likely suffering from overusing the
    GPU, or overdrawing. Overdrawing occurs when the GPU renders a new view over an
    existing view that is already rendered. You can enable GPU Overdraw Debugging
    in the Android Developer Settings menu. The order of severity of overdrawing is
    No Color -> Blue -> Green -> Light Red -> Dark Red.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we provided a quick tip for improving the performance of animations.
    This is particularly true for repeated animations, since it caches the animation
    output on the GPU and replays it.
  prefs: []
  type: TYPE_NORMAL
