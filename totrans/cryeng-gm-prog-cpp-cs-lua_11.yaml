- en: Chapter 11. Effects and Sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CryENGINE hosts a very modular effects system, allowing the spawning of effects
    at runtime with minimal effort. The engine also features FMOD integration, giving
    the developer the tools for dynamic playback of audio, music, and localized dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the effects and sound systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering how to create and trigger material effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to export and customize sounds via FMOD Designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing back custom sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to integrate sounds into particles and physical events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without FX, the game world is usually hard to believe and is considered void
    of life. Simply adding effects such as sound and particles helps to make the world
    come alive, giving the player a much more immersive feeling of the world.
  prefs: []
  type: TYPE_NORMAL
- en: Although there isn't one combined system for all types of effects in the engine,
    we'll be covering a number of systems that handle effects of various sorts. This
    includes material effects, particle effects, sound effects, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Material effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The material effects system handles reactions between materials, for example,
    to play different particle and sound effects based on which material a rock lands
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Surface types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each material is assigned a **surface type**, indicating what type of surface
    it is. For example, if we are creating a rock material, we should use the mat_rock
    surface type.
  prefs: []
  type: TYPE_NORMAL
- en: By assigning a surface type, the physics system will be able to gather information
    on how collisions should behave, for example, by getting the surface type's friction
    value. Interactions between multiple surface types also allow for dynamic effects
    that change based on the surface types in contact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Surface types can be queried programmatically quite easily, allowing various
    systems to create different code paths that are triggered based on the surface
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, surface types are represented by the `ISurfaceType` interface, which
    can be obtained by using `IMaterial::GetSurfaceType`.
  prefs: []
  type: TYPE_NORMAL
- en: Using C#, surface types are represented by the `CryEngine.SurfaceType` class,
    and can be retrieved by using the `CryEngine.Material.SurfaceType` property.
  prefs: []
  type: TYPE_NORMAL
- en: Adding or modifying surface types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Surface types are defined in `Game/Libs/MaterialEffects/SurfaceTypes.xml`. The
    file is parsed by the engine at startup, allowing materials to use the loaded
    surface types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each surface type is defined by using the `SurfaceType` element, for example,
    `mat_fabric` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The physics properties are queried by the physics system when collisions occur.
  prefs: []
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Particle effects are handled by the `IParticleManager` interface, accessible
    by using `I3DEngine::GetParticleManager`. To obtain a pointer to an `IParticleEffect`
    object, see `IParticleManager::FindEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Particle effects are created by using the **Particle Editor** contained in the
    **Sandbox Editor**, and are typically saved to `Game/Libs/Particles`.
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CryENGINE sound system is powered by FMOD, an audio content creation tool
    for games. By using FMOD, the engine supports easy creation and manipulation of
    sounds for immediate use in the game.
  prefs: []
  type: TYPE_NORMAL
- en: The sound system can be accessed via the `ISoundSystem` interface, which is
    commonly retrieved via the `gEnv->pSoundSystem` pointer. Sounds are represented
    by the `ISound` interface, from which a pointer can be retrieved via `ISoundSystem::CreateSound`
    or `ISoundSystem::GetSound`.
  prefs: []
  type: TYPE_NORMAL
- en: By accessing the `ISound` interface, we can alter semantics, distance multipliers,
    and more, as well as actually play the sound via `ISound::Play`.
  prefs: []
  type: TYPE_NORMAL
- en: FMOD Designer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The designer is what we'll use every time we want to add more sounds to the
    different sound libraries in use by our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![FMOD Designer](img/5909OT_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The designer allows the creation and maintenance of sound banks, essentially
    libraries that create a separation between different sounds. Within the sound
    banks are events, sound definitions, and music. These can be given static and
    dynamic modifiers, for example, to give distinctive 3D effects to the sounds depending
    on the in-game environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and triggering material effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to trigger custom material effects, as explained in the following
    sections
  prefs: []
  type: TYPE_NORMAL
- en: Automated playback based on physical interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When two materials collide due to a physical event, the engine will look up
    a material effect in `Game/Libs/MaterialEffects/MaterialEffects.xml` based on
    the surface types assigned to the materials. This allows various particles and
    sounds to be played when certain interactions occur.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a rock collides with wood, we can play a specific sound event
    along with wood splinter particles.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open `MaterialEffects.xml` with Microsoft Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it's possible to modify the material effects document manually, this
    is not recommended due to the complicated nature of the Excel format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Automated playback based on physical interactions](img/5909OT_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should now see the material effects sheet inside your Excel application.
    The various surface types are laid out in a grid, and the intersection between
    the row and column defines which effect to use.
  prefs: []
  type: TYPE_NORMAL
- en: For example, judging by the sheet shown in the previous screenshot, if a material
    with the surface type **mat_flesh** collides with a **mat_vegetation** surface,
    the engine will load the **collision:vegetation_spruce** effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete list of surface types can be viewed (or modified) via `Libs/MaterialEffects/SurfaceTypes.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new surface types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to add new surface types to the material effects document, simply
    add a corresponding row and a column with the surface type name, in order to have
    the engine load it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the names of your surface type must appear in the same order for
    both the row and column.
  prefs: []
  type: TYPE_NORMAL
- en: Effect definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now that we know how the system finds effects for various surface type collisions,
    how do we find and create effects?
  prefs: []
  type: TYPE_NORMAL
- en: 'Effects are contained inside `Libs/MaterialEffects/FXLibs/` as pure XML files.
    For example, the definition of the previously used **collision:vegetation_spruce**
    effect is contained in `Libs/MaterialEffects/FXLibs/Collision.xml` with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This tells the engine to play the specified particle when the effect is triggered.
    For example, as we defined previously, if a material with the surface type of
    **mat_flesh** collides with another of the type **mat_vegetation**, the engine
    will spawn the `Snow.Vegetation.SpruceNeedleGroup` effect at the position of impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about sounds? Sounds can be played back via events in a similar fashion
    to particles; simply replace the `Particle` tag with `Sound` and specify the name
    of your sound as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now when the effect is played, we should be able to hear a pig squirm. That's
    what happens when you collide into vegetation, right?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth remembering that an effect does not have to contain one specific
    type of effect, but can also play multiple effects simultaneously. For example,
    based on the previous code, we could create a new effect that plays a sound and
    also spawns a particle effect when triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering custom events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also possible to trigger custom material effects, which is useful when,
    for example, creating footstep effects that should differ based on the interaction
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering custom events](img/5909OT_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The colon ('**:**') stands for the effect category, which is the name of the
    effect library we created in the `Libs/MaterialEffects/FXLibs/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot is a smaller selection of custom material effects that
    are triggered programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the ID of an effect, call `IMaterialEffects::GetEffectId`, by supplying
    the interaction name and the relevant surface type as shown in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways of obtaining surface identifiers. For example, casting a
    ray using `RayWorldIntersection` will allow us to get the collided surface ID
    via the `ray_hit::surface_idx` variable. We could also simply call `IMaterial::GetSurfaceTypeId`
    on any material instance.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have the identifier of the `footstep_player` effect, based on
    the surface type we passed to `GetEffectId`. For example, by cross-referencing
    with the previous screenshot, and assuming that we passed the `mat_metal` identifier,
    we should have the ID of the `footstep_player:metal_thick` effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then execute the effect by calling `IMaterialEffects::ExecuteEffect`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to get the effect resources by calling `IMaterialEffects::GetResources`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Animation-based events and effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation-based events can be used to trigger specific effects during a set
    time of an animation. For example, we could use this to link sounds to animations
    to make sure that the sound is always played in sync with its corresponding animation.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open the **Character Editor** via the **Sandbox Editor**, load any
    character definition, and then select any animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation-based events and effects](img/5909OT_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select the **Animation Control** tab at the bottom center of the window, and
    choose any time during the animation during which you want to play your sound.
  prefs: []
  type: TYPE_NORMAL
- en: When you have the slider positioned on the time your sound should be played
    at, click on **New Event**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Name** field of the event should be **sound**, and set the **Parameter**
    field to the path of the sound that you want to play.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animation-based events and effects](img/5909OT_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After clicking on **Save**, the sound should start playing along with the animation
    at the time specified.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning particle emitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the *Particle effects* section, particle effects are represented
    by the `IParticleEffect` interface. However, a particle effect is not the same
    as a particle emitter. The effect interface handles the properties of the default
    effect, and can spawn individual emitters that show the visual effect in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Emitters are represented by the `IParticleEmitter` interface, and are most commonly
    retrieved by calling `IParticleEffect::Spawn`.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting sounds by using FMod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So you want to export a few sounds to the engine? The first thing we need to
    do is create a new FMod project, via the **FMOD Designer**. To do so, start by
    opening the designer via `<Engine Root>/Tools/FmodDesigner/fmod_designer.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new project, click on the **File** menu, select **New Project**,
    and then save the project to the location you see fit. We'll be saving ours to
    `Game/Sounds/Animals/Animals.fdp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more in-depth tutorial on the FMOD sound system, see the CryENGINE documentation
    at [http://docs.cryengine.com/display/SDKDOC3/The+FMOD+Designer](http://docs.cryengine.com/display/SDKDOC3/The+FMOD+Designer).
  prefs: []
  type: TYPE_NORMAL
- en: Adding sounds to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a sound project, it''s time to add a few sounds. To do so,
    make sure that you''re in the **Events** menu, with the **Groups** tab activated
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sounds to the project](img/5909OT_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to add a sound, simply drag a `.wav` file into the group you selected,
    and it should appear there. You can now navigate to **Project** | **Build**, or
    press *Ctrl* + *B*, in order to build the wave bank for your project, which is
    what the engine will load to detect the sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sounds to the project](img/5909OT_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By adding more sounds to the event group, the system will randomly pick a sound
    when the group is requested.
  prefs: []
  type: TYPE_NORMAL
- en: By selecting an event group in FMOD, we'll also be able to modify its properties,
    essentially tweaking how the sound is played when it is played back.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding sounds to the project](img/5909OT_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most properties statically affect the sound, whereas ending with **Randomization**
    creates an effect that is randomly applied at runtime. For example, by tweaking
    **Pitch Randomization**, we can ensure that the pitch of the sound will be randomly
    offset by the value we choose, giving the sound a unique touch.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When playing audio, we have to differentiate between dynamic sounds triggered
    by the programmer, and static sounds that are triggered by the level creator.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways of triggering audio events, which should be evaluated
    based on the purpose of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: Using SoundSpots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The soundspot entity exists to allow level designers to easily place an entity
    that will play a predefined sound in a specific area. The sound entity supports
    looping sounds, or playing them once each time it is triggered from a scripted
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a soundspot, start by placing a new instance of the **SoundSpot** entity
    via the Rollupbar, or navigate to **Sound** | **Soundspot**. Once placed, you
    should see something similar to the example shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SoundSpots](img/5909OT_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now assign a sound that should be played within the spot. To do so,
    click on the **Source** entity property and then choose a sound via the **Sound
    Browser** window as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SoundSpots](img/5909OT_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can then set up **SoundSpot** to either always play the sound, or be triggered
    via flowgraph. For example, in the following screenshot, the soundspot will play
    its sound when the player uses the *K* key.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SoundSpots](img/5909OT_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Programmatically playing sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To programmatically play a sound, we''ll first need to retrieve an `ISound`
    pointer relevant to the specific sound we''re interested in playing, via `ISoundSystem::CreateSound`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then play the sound directly via `ISound::Play`, or attach it to an
    entity''s sound proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By using an entity sound proxy, we can make sure that the sound follows that
    entity as it moves around the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Sound flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating sounds by using the `ISoundSystem::CreateSound interface`, we
    have the option to specify a set of flags that will affect the playback of our
    sound.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some flags need to be set up in FMOD before they can be used. For example, sounds
    with 3D space effects have to be set up in FMOD before they can be used in the
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: These flags are contained in `ISound.h` as preprocessor macros with the `FLAG_SOUND_`
    prefix. For example, we could apply the `FLAG_SOUND_DOPPLER` flag to our sound
    in order to have a Doppler effect simulated on playback.
  prefs: []
  type: TYPE_NORMAL
- en: Sound semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semantics are essentially modifiers applied to sounds, and are required for
    each sound in order to have it played.
  prefs: []
  type: TYPE_NORMAL
- en: The different sound semantics can be viewed in `ISound.h` (in the CryCommon
    project), within the `ESoundSemantic` enum.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have exported sounds from FMOD into the engine, and learned
    how to tweak them.
  prefs: []
  type: TYPE_NORMAL
- en: You should now know how to trigger sounds both via the Sandbox Editor and programmatically,
    and also have a working knowledge of material effects.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not quite ready to move on to the next chapter, why not try expanding
    your knowledge? A possibility could be to dive into the particle editor and create
    your own particle, complete with custom effects and sounds.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the process of debugging and profiling
    your game logic, aiding you in working more efficiently.
  prefs: []
  type: TYPE_NORMAL
