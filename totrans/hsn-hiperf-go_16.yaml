- en: Tracing Go Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tracing Go programs is a fantastic way to check the interoperability between
    functions and services within your Go program. Tracing allows you to pass context
    through your system and evaluate where you are being held up, whether it''s by
    a third-party API call, a slow messaging queue, or an *O*(*n*²) function. Tracing
    will help you to find where this bottleneck resides. In this chapter, we''re going
    to learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The process of implementing tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of sampling with tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of interpreting tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of comparing traces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to implement tracing and interpret the results will help developers
    to understand and troubleshoot their distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tracing instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go''s concurrency model uses goroutines, and is very powerful. One of the drawbacks
    of having high concurrency is that you will experience difficulty when you attempt
    to debug that high-concurrency model. To avoid this difficulty, the language creators
    created `go tool trace`. They then distributed this in Go version 1.5 in order
    to be able to investigate and resolve concurrency issues. The Go tracing tool
    hooks into the goroutine scheduler so that it can produce meaningful information
    about goroutines. Some of the implementation details that you may want to investigate
    with Go tracing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contention of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O-related events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syscalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Garbage Collection** (**GC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting all of these issues will help you to build a more resilient
    distributed system. In the next section, we are going to discuss the tracing format
    and how it's applicable to Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the tracing format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go traces can have lots of information and can capture a lot of requests per
    second. The traces are therefore captured in a binary format. The structure of
    the trace output is static. In the following output, we can see that the traces
    follow a specific pattern—they are defined, and events are categorized with a
    hex prefix and some information about the specific trace event. Looking at this
    trace format will help us to understand how the events of our traces are stored
    and retrieved with the tooling that the Go team has made available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: More information about the Go execution tracer can be found in the original
    specification document by Dmitry Vyukov, published at [https://docs.google.com/document/u/1/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub](https://docs.google.com/document/u/1/d/1FP5apqzBgr7ahCCgFO-yoVhk4YZrNIDNf9RybngBc14/pub).
  prefs: []
  type: TYPE_NORMAL
- en: Being able to see all these elements of a trace can help us to understand how
    to break traces down into atomic chunks. In the next section, we'll be discussing
    trace collection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding trace collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to collect traces is integral to implementing tracing in your distributed
    system. If we don''t aggregate these traces somewhere, we won''t be able to make
    sense of them at scale. There are three methods with which we can collect trace
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually invoking the tracing of the data by calling `trace.Start` and `trace.Stop`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the test flag `-trace=[OUTPUTFILE]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumenting the `runtime/trace` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to understand how to implement tracing around your code, let''s take
    a look at a simple example program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first instantiate our package and import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then invoke our `main` function. We write the trace output to a file, `trace.out`,
    which we will use later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we implement the trace that we want to use in our program and we defer
    the end of the trace until the return of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then write the code that we want to implement. Our example here is just
    a simple pass of the string `"Hi Gophers"` across a channel in an anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our trace implemented around our (admittedly simple) program,
    we need to execute our program to produce a trace output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1bc51c4-054c-4a88-9e51-22e14d29dcc6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To view traces, you may need to install additional packages. For the Fedora
    system I''m testing on, I had to install an additional `golang-misc` package:
    `sudo dnf install golang-misc`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you create a trace, you can open the trace that you created using the `go
    tool trace trace.out` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This makes it possible for you to start the HTTP server that will serve the
    trace output. We can see this output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b54e468f-f12c-4783-afa8-7158f541f7e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the resulting trace output in a Chrome browser. It''s important
    to mention that we need to use a compatible browser, namely Chrome. At the time
    of writing this book, Firefox will produce a blank page for a trace output. Here
    is the output of the trace in a Chrome browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cb0717a-8035-40ef-8f40-549a81db2ea7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This HTML page gives you a bunch of different useful output choices. Let''s
    look at them one by one in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Link** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| View trace | View the GUI trace output. |'
  prefs: []
  type: TYPE_TB
- en: '| Goroutine analysis | Displays distinct goroutine information. |'
  prefs: []
  type: TYPE_TB
- en: '| Network blocking profile | Displays network blocking; can create a separate
    profile. |'
  prefs: []
  type: TYPE_TB
- en: '| Synchronization blocking profile | Displays synchronization blocking; can
    create a separate profile. |'
  prefs: []
  type: TYPE_TB
- en: '| Syscall blocking profile | Displays syscall blocking; can create a separate
    profile. |'
  prefs: []
  type: TYPE_TB
- en: '| Scheduler latency profile | Shows all the latency associated with the scheduler;
    can create a separate profile. |'
  prefs: []
  type: TYPE_TB
- en: '| User-defined tasks | Allows for the viewing of the task data type; used for
    tracing a user-defined, logical operation. This is called using the format `trace.NewTask()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| User-defined regions | Allows for the viewing of the region data type; used
    for tracing a region of code. This is called using the format `trace.WithRegion()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Minimum mutator utilization | Creates a visual plot of where and when the
    garbage collector is stealing work from your program. This helps you know whether
    or not your production service is GC-bound. |'
  prefs: []
  type: TYPE_TB
- en: 'We can start by looking at the trace in our web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edd1f3d9-8df0-4a17-bbe4-f0c54cd30120.png)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the first things we can do when we look at these traces is to look at
    the help menu, available in the question mark box in the top-right corner of the
    screen. This information menu gives us lots of descriptions of the tracing tool''s
    abilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8172c4c6-9077-4281-a9a6-f7f0ad7a4991.png)'
  prefs: []
  type: TYPE_IMG
- en: Being able to quickly and effectively move about in the tracing window will
    help you to look through the trace very quickly. This can be exceptionally helpful
    when you are trying to troubleshoot a production problem quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Movement in the tracing window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the classic *WASD* movement keys (inspired by lots of first-person role-playing
    video games), we can move around the trace. The movement keys are described as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The *W* key zooms into the trace's timing window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *S* key zooms out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *A* key goes backward in time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *D* key moves forward in time. We can also go backward and forward in time
    by clicking and dragging the mouse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the mouse pointer selector or clicking on the number keys allows us to
    manipulate timing information. The keypad changes are listed in the following
    bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: The *1* key lets us select the part of the trace that we'd like to inspect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *2* key allows us to pan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *3* key invokes the zoom functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *4* key allows us to select a specific timing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now use the */* key to search through the trace and the *Enter* key to
    step through the results.
  prefs: []
  type: TYPE_NORMAL
- en: We also have file-size stats, metrics, frame data, and input latency windows
    that are available on the right-hand side of the screen. When clicked, these buttons
    will open a popup that will tell you more details about each of these particular
    statistics within the trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the blue area in the goroutines row in the trace, we can take
    a look at some of the available stats we have for our goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GCWaiting`, which is the amount of garbage collection runs that are waiting
    (currently with a value of 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of runnable goroutines (currently with a value of 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of running goroutines (currently with a value of 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see a sampling of the available stats for our goroutines in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2a6c91a-b495-44e7-b78c-7bb9c4065b31.png)'
  prefs: []
  type: TYPE_IMG
- en: The goroutine information can be helpful for the end user debugging the program.
    Watching goroutines in the Go trace tool can help us to determine when a goroutine
    is fighting for contention. It may be waiting on a channel to clear, it might
    be blocked by a syscall, or it might be blocked by the scheduler. If there are
    many goroutines in a waiting state, that means the program might be creating too
    many goroutines. This could cause the scheduler to be overallocated. Having access
    to all of this information can help us to make an informed decision on how to
    better write our program to utilize goroutines more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the orange bar in the Heap row will display the heap information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04865725-43d9-47f1-86f3-2b84abe7321a.png)'
  prefs: []
  type: TYPE_IMG
- en: At the time selected (0.137232), we can see that we have 425984 bytes, or approximately
    425 KB, allocated to the heap. Knowing the amount of memory currently allocated
    to the heap can tell us whether or not we have memory contention in our program.
    Profiling (as we learned in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml),
    *Profiling Go Code*) is usually a better methodology for looking at heap information,
    but having a general understanding of the allocation within the trace context
    can often be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can look at the thread information next. Clicking on an active thread (the
    magenta block in the Threads row of the trace) will show you the number of threads in InSyscall
    and Running states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d9b9579-f430-4d23-a18c-31aa5a04a684.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be helpful to know the number of OS threads that are running and how
    many are currently being blocked by syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can take a look at each of the individual processes running. Clicking
    on the process will tell you all of the details that are shown in the following
    screenshot. If you hover over one of the events at the bottom pane of the trace,
    you will be able to see how the processes are tied together, denoted by the red
    arrow in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84eef16-2487-4c23-97a0-917f9475ce61.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowing the end-to-end flow of your processes can often help you diagnose problem
    processes. In the next section, we'll learn how to explore pprof-like traces.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring pprof-like traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go tool trace can also generate four different types of traces that may
    be pertinent to your troubleshooting needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`net`: A network-blocking profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: A synchronization-blocking profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syscall`: A syscall-blocking profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sched`: A scheduler-latency profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of how to use these tracing profiles on a
    web server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our `main` and import the necessary packages. Note the
    blank identifier for the explicit package name within `_ "net/http/pprof"`. This
    is used in order to make sure we can make the tracing call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We next set up a simple web server that waits five seconds and returns a string
    to the end user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run our server by executing `go run netTracePprof.go`, we can take
    a trace: `curl localhost:1234/debug/pprof/trace?seconds=10 > trace.out`. We can
    see the output of our `curl` in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fee7866d-9776-4db5-87da-bbd466be6431.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Concurrently, in another Terminal, we can make a request for the `/` path on
    our sample webserver: `curl localhost:1234/`. We will then be returned with a
    `trace.out` file in the directory in which we ran the trace. We can then open
    our trace using `go tool trace trace.out`. We will then see our tracing result.
    Utilizing the network-blocking profile in the resulting HTTP page, we can see
    a trace of the network-blocking profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57aa695e-104a-4342-b378-462014acf963.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, we see a five-second wait, as this is the waiting timing that
    we added into our handler function for this particular web request. If we want
    to, we can download this profile and look at it in the upstream `pprof` tool that
    we discussed in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling
    Go Code*. In the trace HTML window, there''s a download button next to the web
    profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7657e853-acb9-4f88-bcf3-f34514fd2bf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we have downloaded this profile, we can take a look at it using the upstream
    `pprof` tool we installed in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling
    Go Code*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then look at things like the flame graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c94a6a96-e73e-40c0-9336-c38e26c70822.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the peek UI in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/598d77a6-10b2-4875-bd88-1b41b5549789.png)'
  prefs: []
  type: TYPE_IMG
- en: Both the flame graph and the peek UI help to make these complex debugging views
    a little bit more concise. In the next section, we shall see what distributed
    tracing in Go is.
  prefs: []
  type: TYPE_NORMAL
- en: Go distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing and investigating individual traces for Go programs can be a fruitful
    endeavor, giving a lot of output with respect to the data that results in requests
    to our programs. As enterprises have more and more distributed code bases with
    many more intricate calls that all interoperate with one another, tracing individual
    calls becomes untenable in the long run. There have been two projects that have
    tried to help with distributed tracing for Go, and these are the OpenCensus Go
    library and the OpenTelemetry library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`opencensus-go`: [https://github.com/census-instrumentation/opencensus-go](https://github.com/census-instrumentation/opencensus-go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opentracing-go`: [https://github.com/opentracing/opentracing-go](https://github.com/opentracing/opentracing-go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintainers of these projects have decided to converge these two projects
    and begin working on one code base, named OpenTelemetry. This new code base will
    allow for a simplified integration of distributed tracing across many languages
    and infrastructures. You can read more about the Go implementation of OpenTelemetry
    at [https://github.com/open-telemetry/opentelemetry-go](https://github.com/open-telemetry/opentelemetry-go).
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, OpenTelemetry is not yet ready for production
    use. OpenTelemetry will provide backward compatibility with both OpenCensus and
    OpenTracing, and will also provide security patches. In the next section of the
    book, we'll look at how we can implement Go programs with OpenCensus. In the future,
    implementing your program with OpenTelemetry should be relatively straightforward
    using the strategies that we are going to talk about when we look at implementing
    tracing with OpenCensus.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see how to implement OpenCensus for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OpenCensus for your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's use a practical example for OpenCensus tracing in an application. To get
    started, we need to make sure that we have Docker installed on our machine. You
    should be able to use the installation documents at [https://docs.docker.com/](https://docs.docker.com/)
    in order to be certain that Docker is installed and runs correctly on your machine.
    Once this is completed, we can get going with creating, implementing, and viewing
    a sample application. Once we have Docker installed, we can pull important images
    for our instrumentation. In our example, we will use Redis (a key–value store)
    to store key–value events in our application and Zipkin (a distributed tracing
    system) to view these traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pull our dependencies for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redis, which is a key–value store that we are going to use in our sample application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Zipkin, which is a distributed trace system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will stand up our Redis server and let it run in the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do the same thing for our Zipkin server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have all of our dependencies installed and ready, we can start writing
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll instantiate our `main` package and add our necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `tracingServer` function defines a few things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set up a new Zipkin endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We initialize a new HTTP reporter, which is the endpoint to which we send spans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set up a new exporter, which returns a `trace.Exporter` (this is how we upload
    spans to the Zipkin server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We register our exporter to the tracing handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We apply a configuration for a sampling rate. In this example, we set up our
    example to always trace, but we could make this a smaller percentage of our requests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `makeRequest` function, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `span`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a request to a given HTTP URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a sleep timeout to simulate additional latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate our span
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a response status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `writeToRedis` function, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new span
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect to our local Redis server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a specific key–value pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then bring this all together using our `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve invoked our program by executing `go run ocZipkin.go`, we can then take
    a look at our Zipkin server. If we select one of the traces that are in our trace
    list, we can see the traces that we''ve created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e4ba0a84-ea05-4651-a52d-9e2f91ffd6fd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on one of the spans, we can investigate it further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b3555a8-7122-4f24-a795-d81fb40a5499.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the calls to the `httprequest` and `rediswrite` functions that are
    in our code. As we start to implement more spans around our code, we will get
    larger and larger traces that will help us diagnose where our code has the most
    amount of latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on one of the individual elements in the trace, we can see the
    annotations that we wrote in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6310d60b-dd08-438f-9de5-66bd074a4783.png)'
  prefs: []
  type: TYPE_IMG
- en: Annotations can be useful if we are trying to understand a particular behavior
    for an end user. We can also see the details of `traceId`, `spanId`, and `parentId`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all about traces. We learned how to implement individual
    traces on particular pieces of code and analyze them to understand their behavior.
    We also learned how to implement and analyze distributed traces to understand
    problems in our distributed system. Being able to use these skills will help you
    to debug distributed systems, and in turn, help to lower the **mean time-to-resolution** (**MTTR**)
    while troubleshooting distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 14](74c0cef8-9628-4e31-abc3-9bd9aa52fafa.xhtml), *Clusters and Job
    Queues*, we'll learn how to evaluate clusters and job queues for performance optimizations.
  prefs: []
  type: TYPE_NORMAL
