- en: Reducing Power Consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many applications for embedded systems that require them to be battery
    powered. From small **IoT **(short for **internet of things**) devices collecting
    data from sensors, pushing it into the cloud for processing, to autonomous vehicles
    and robots—these systems should be as power efficient as possible so that they
    can operate for a long time without a steady external power supply.
  prefs: []
  type: TYPE_NORMAL
- en: Power efficiency means the smart control of the power consumption of all parts
    of a system, from the peripheral devices to the memory and the processor. The
    efficiency of power control depends significantly on the choice of hardware components
    and the system design. If a processor does not support dynamic voltage control
    or a peripheral device cannot enter power-saving mode when idle, then not much
    can be done on the software side. If, however, hardware components implement standard
    specifications, such as an **advanced configuration and power interface** (**ACPI**),
    then a lot of the burden of power management can be offloaded to the operating
    system kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore different power-saving modes of modern hardware
    platforms and how they can be utilized. We will learn how to manage the power
    state of external devices and reduce the power consumption of processors by writing
    more efficient software.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring power-saving modes in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waking up using **RTC** (short for **real-time clock**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the autosuspend of USB devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CPU frequency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using events for waiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling power consumption with PowerTOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes from this chapter will help you efficiently utilize the power-saving
    capabilities of modern operating systems and write code that is optimized for
    battery-powered devices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For running code examples in this chapter, you need to have a Raspberry PI box
    revision 3 or above.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring power-saving modes in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a system is in the idle state and does not have work to do, it can be put
    in a sleep state to save power. Similar to human sleep, it cannot do anything
    until it is woken up by external event, for example an alarm clock.
  prefs: []
  type: TYPE_NORMAL
- en: Linux supports multiple sleep modes. The choice of sleep mode and the amount
    of power it can save depends on the hardware support and the time it takes to
    enter the mode and wake up from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suspend-to-idle **(**S2I**): This is a light sleep mode that can be implemented
    purely in software and does not require any support from the hardware. The devices
    are put into low-power mode and time keeping is suspended to let the processor
    spend more time in a power-efficient idle state. A system is woken up by an interrupt
    from any of the peripheral devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standby**: This is similar to S2I, but provides more power saving by taking
    all non boot CPUs offline. Interruption from some devices can wake the system
    up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suspend-to-RAM** (**STR** or **S3**): All components of the system (except
    memory), including CPUs, go into low-power mode. The system state is maintained
    in memory until it is woken up by an interrupt from a limited set of devices.
    This mode requires hardware support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hibernation** or **suspend-to-disk**: This provides the greatest power saving,
    since all the system components can be powered off. When entering this state,
    a snapshot of the memory is taken and written to persistent storage (disk or flash).
    After that, the system can be turned off. As part of the boot process, on wake
    up, the saved snapshot is restored and the system resumes its work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to query the sleep modes supported on a particular
    system and how to switch to one of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use simple bash commands to access sleep modes supported
    by a Linux system running in **QEMU **(short for **quick emulator**).
  prefs: []
  type: TYPE_NORMAL
- en: Run the Raspberry Pi QEMU as described in [Chapter 3](b89bff48-21be-4288-af10-de42f182d426.xhtml),* Working
    with Different Architectures*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in as user `pi`, using the password `raspberry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `sudo` to gain root access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the list of supported sleep modes, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now switch to one of the supported modes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The system goes to sleep, but we have not instructed it as to how to wake up.
    Close the QEMU window now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Power management is part of the Linux kernel; that is why we cannot use a Docker
    container to work with it. Docker virtualization is lightweight and uses the kernel
    of the host operating system.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use the real Raspberry Pi board either, because it does not provide
    any sleep modes at all because of hardware limitations. QEMU, however, provides
    full virtualization, including power management in the kernel we use to emulate
    Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux provides access to its power management functions through the sysfs interface.
    Applications can read and write text files in the `/sys/power` directory. Access
    to power-management functions is limited for the root user; that is why we need
    to get the root shell once we log into the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get the list of supported sleep modes. To do this, we read the `/sys/power/state`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The file consists of a single line of text. Each word represents a sleep mode
    that is supported, with the modes separated by spaces. We can see that the QEMU
    kernel supports two modes: `freeze` and `mem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e12ba0b1-2558-41d6-83c6-8ad7026751c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Freeze represents the S2I state we discussed in the preceding section. The meaning
    of `mem` is defined by the content of the `/sys/power/mem_sleep` file. In our
    system, it contains only `[s2idle]`, representing the same S2I state as `freeze`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s switch our emulator to `freeze` mode. We write the word `freeze` to
    `/sys/power/state`, and immediately the QEMU window turns black and frozen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3f7043f-286b-49d6-acc7-a05c553aa1dd.png)'
  prefs: []
  type: TYPE_IMG
- en: We were able to put the emulated Linux system to sleep, but cannot wake it up—there
    are no sources of interrupts that it can understand. We learned about different
    sleep modes and the kernel API to work with them. Based on the requirements of
    your embedded system, you can use these modes to reduce power consumption.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about sleep modes can be found in the corresponding section
    of the *Linux Kernel Guide* at [https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html](https://www.kernel.org/doc/html/v4.19/admin-guide/pm/sleep-states.html.).
  prefs: []
  type: TYPE_NORMAL
- en: Waking up using RTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we were able to put our QEMU system to sleep but were
    not able to wake it up. We need a device that can send an interrupt to the system
    when most of its internal components are powered off.
  prefs: []
  type: TYPE_NORMAL
- en: The **RTC** (**Real-time clock)** is one such device. One of its functions is
    to keep the internal clock running when the system is off, and to do this, it
    has its own battery. RTC power consumption is similar to an electronic watch;
    it uses the same 3 V battery and can function on its power for years.
  prefs: []
  type: TYPE_NORMAL
- en: RTC can work as an alarm clock, sending an interrupt to the CPU at a given time.
    This makes it an ideal device for waking up a system on schedule.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to wake up a Linux system at a specific time
    using the built-in RTC.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will set a wake-up time to 1 minute in advance and put the
    system to sleep:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to any Linux system that has an RTC clock—any Linux laptop can work.
    Unfortunately, Raspberry Pi does not have an onboard RTC, and cannot be woken
    up without additional hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get root permissions using `sudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Instruct RTC to wake up the system in `1` minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the system to sleep:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Wait for a minute. Your system will wake up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many other functions exposed by the Linux kernel, RTC can be accessed via
    sysfs interfaces. To set an alarm that will send a wake-up interrupt to the system,
    we need to write a **POSIX** (short for** Portable Operating System Interface**)
    timestamp to the `/sys/class/rtc/rtc0/wakealarm` file.
  prefs: []
  type: TYPE_NORMAL
- en: The POSIX timestamp, which we discuss in more detail in [Chapter 11](78be8bb8-ddec-4412-9d1e-a5ae2ffec6b7.xhtml),
    *Time Points and Intervals*, is defined as the number of seconds elapsed since
    the Epoch, or 00:00 January 1, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: Though we can write a program to read the current timestamp using the `time`
    function, add 60, and write the result to the `wakealarm` file, we can do this
    in one line using the Unix shell and the `date` command, which is available on
    any modern Unix system.
  prefs: []
  type: TYPE_NORMAL
- en: The date utility can not only format the current time using different formats,
    but it can also interpret dates and times in different formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'We instruct `date` to interpret the time string `+1 minute` and use the formatting
    pattern `%s` to output it as a POSIX timestamp. We redirect its standard output
    to the `wakealarm` file, effectively passing it to the RTC driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, knowing that in 60 seconds the alarm will go off, we can put the system
    to sleep. As in the previous recipe, we write the desired sleep mode to the `/sys/power/state`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The system goes to sleep. You will notice that the screen turns off. If you
    connected to the Linux box using **Secure Shell** (**SSH**), the command line
    freezes. However, in one minute it wakes up, the screen turns on, and the Terminal
    is responsive again.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is very efficient for tasks such as gathering data from sensors
    on a regular, infrequent basis, such as hourly or daily. The system spends most
    of the time powered off, waking up only to collect data and store it or send it
    to the cloud, and then it goes to sleep again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative way to set RTC alarms is by using the `rtcwake` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the autosuspend of USB devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Turning an external device off is one of the most efficient ways to save power.
    It is, however, not always easy to understand when a device can be turned off
    safely. Peripheral devices such as network cards or memory cards can perform internal
    data processing; otherwise, the caching and powering off of the device at an arbitrary
    point can cause data loss.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this problem, many external devices that are connected over the
    USB can switch themselves into low-power consumption mode when requested by the
    host. This way, they can perform all necessary steps to handle internal data safely
    before entering the suspended state.
  prefs: []
  type: TYPE_NORMAL
- en: Since Linux provides access to peripheral devices only through its API, it knows
    when a device is in use by applications and kernel services. If a device is not
    in use for a certain amount of time, the power-management system within the Linux
    kernel can instruct the device to enter power-saving mode automatically—explicit
    requests from userspace applications are not needed. This feature is called **autosuspend**.
    The kernel, however, allows applications to control the device's idle time, after
    which  autosuspend kicks in.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to enable autosuspend and modify the autosuspend
    interval for a particular USB device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to enable autosuspend and modify its autosuspend time for a USB
    device connected to your Linux box:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Linux box (Raspberry Pi, Ubuntu, and Docker containers won't
    work).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the root account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current `autosuspend` status for all USB devices that are connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable `autosuspend` for one of the devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the `autosuspend` interval for the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `autosuspend` interval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the current power mode of the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The same operations can be programmed in C++ using the standard file API.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux exposes its power management API via the sysfs filesystem, which makes
    it possible to read the current status and modify the settings of any device using
    standard file read and write operations. As a result, we can use any programming
    language that supports basic file operations to control peripheral devices in
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify our examples, we are going to use the Unix shell, but exactly the
    same logic can be programmed in C++ when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: First, we check the `autosuspend` settings for all attached USB devices. In
    Linux, the parameters of each USB device are exposed as a directory under the `/sysfs/bus/usb/devices/`
    folder. Each device directory, in turn, has a set of files that represent the
    device parameters. All parameters related to power management are grouped in the
    `power` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the status of `autosuspend`, we need to read the `control` file in
    the `power` directory of a device. Using Unix shell wildcard substitution, we
    can read this file for all USB devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For each directory matching the wildcard, we display the full path of the control
    file and its content. The result depends on the devices that are connected and
    may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad39f854-2adc-4c82-93d8-22a61a3718a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The reported status may either be autosuspend or `on`. If the status is reported
    as autosuspend, then the automatic power management is enabled; otherwise, the
    device is always kept on.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, devices `usb1`, `1-1.1`, and `1-1.2` are on. Let's modify the configuration
    of `1-1.2` to use autosuspend. To do it, we just write a string `_auto_` to the
    corresponding  `_control_`  file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the read loop over all devices again shows that the `1-1.2` device
    is now in `autosuspend` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a67c2bca-1a51-47ae-a018-07121f050716.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When is it going to be suspended? We can read this from the `autosuspend_delay_ms`
    file in the `power` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows that the device will be suspended after `2000` milliseconds of idleness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eca24651-a7e7-4029-9c0c-a9e827d52322.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change it to `5` seconds. We write `5000` in the `autosuspend_delay_ms`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading it again shows that the new value is accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6ee3c8-c017-4d68-9df7-b5343e3bf17d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s check the current power state of the device. We can read it from
    the `runtime_status` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The status is reported as `active`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71e3495c-e054-41b5-bdf4-1265560fe78f.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that the kernel does not control the power state of devices directly;
    it only requests them to change the state. Even if a device is requested to switch
    into suspend mode, it may refuse to do it for various reasons—for example, it
    may not support the power-saving mode at all.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the power-management setting of any device through the sysfs interface
    is a powerful way to tweak the power consumption of the embedded system running
    Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no direct way to turn a USB device off immediately; however, in many
    cases, it can be done by writing `0` into the `autosuspend_delay_ms` file. A zero
    autosuspend interval is interpreted by the kernel as an immediate suspend request
    to the device.
  prefs: []
  type: TYPE_NORMAL
- en: More details on the USB power management in Linux can be found in the corresponding
    section of the Linux kernel documentation, available at [https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html](https://www.kernel.org/doc/html/v4.13/driver-api/usb/power-management.html)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CPU frequency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CPU frequency is an important parameter of the system that determines its
    performance and its power consumption. The higher the frequency, the more instructions
    the CPU can perform per second. But it comes with a cost. Higher frequency implies
    a higher power consumption that, in turn, means more heat that needs to be dissipated
    to avoid the processor overheating.
  prefs: []
  type: TYPE_NORMAL
- en: Modern processors are able to use different operating frequencies depending
    on their load. For computationally intense tasks, they use their maximum frequency
    to achieve the maximum performance, but when the system is mostly idle, they switch
    to lower frequencies to reduce both the power consumption and thermal impact.
  prefs: []
  type: TYPE_NORMAL
- en: Proper frequency selection is managed by the operating system. In this recipe,
    we will learn how to set the CPU frequency range and select a frequency governor
    in Linux to fine-tune the CPU frequency to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use simple shell commands to adjust the parameters of CPU frequency
    on a Raspberry PI box:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to a Raspberry Pi or another nonvirtualized Linux system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the root account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the current frequency of all CPU cores available in the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all of the frequencies supported by the CPU:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the available CPU-frequency governors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check which frequency governor is currently in use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the minimum frequency of the CPU to the highest supported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the current frequencies again to understand the effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the minimum frequency to the lowest supported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check how the CPU frequency depends on the governor in use. Select
    a `performance` governor and get the current frequency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the `powersave` governor and observe the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can use a regular file API to implement the same logic in C++.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to USB power management, the CPU-frequency management system API is
    exposed via sysfs. We can read and modify its parameters as regular text files.
  prefs: []
  type: TYPE_NORMAL
- en: We can find all settings related to CPU cores under the `/sys/devices/system/cpu/`
    directory. Configuration parameters are grouped by CPU cores in subdirectories
    named after each code index, such as `cpu1`, `cpu2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are interested in several parameters related to CPU frequencies management
    that live in the `cpufreq` subdirectory of each core. Let''s read the current
    frequency of all available cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that all cores have the same frequency, 600 MHz (the `cpufreq` subsystem
    uses KHz as a measurement unit for frequency):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d9f305d-d3ca-47eb-8766-1b3fa5718836.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we figure out all the frequencies supported by our CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The ARM processor of Raspberry Pi 3 supports only two frequencies, 600 MHz
    and 1.2 GHz:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd10cdcb-aff0-4f3d-9b17-7416aac38365.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We cannot set the desired frequency directly. Linux manages the CPU frequencies
    internally through a so-called **governor**, and only allows us to adjust two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A range of frequencies available for the governor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of governor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though this looks like a limitation, these two parameters give enough flexibility
    to implement fairly complex policies. Let's check how the modification of both
    of these parameters affects the CPU frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s figure out which governors are supported and which is currently
    in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52365c50-07d0-495b-942b-f45dc54dd619.png)'
  prefs: []
  type: TYPE_IMG
- en: The current governor is `ondemand`*. *It adjusts the frequency based on the
    system load. At the moment, the Raspberry Pi board is pretty idle, and so it uses
    the lowest frequency, 600 MHz. But what if we make the lowest frequency equal
    to the highest frequency?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After we updated the `scaling_min_freq` parameter of one core, the frequency
    of all cores was changed to the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac1af6c9-2bce-4cfa-a881-8d99f9e5ebad.png)'
  prefs: []
  type: TYPE_IMG
- en: Since all four cores belong to the same CPU, we cannot change their frequencies
    independently; changing the frequency of one core affects all cores. We can, however,
    control the frequencies of separate CPUs independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we revert the minimum frequency back to 600 MHz and change the governor.
    Instead of the `ondemand` governor that adjusts the frequency, we selected the
    `performance` governor, aiming to deliver maximal performance unconditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s no surprise that it raised the frequency up to the maximum supported
    frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac5ded8a-1be2-402d-9f5c-b475828d8ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, the `powersave` governor aims to save as much power as possible
    as it always sticks to the lowest-supported frequency regardless of the load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc0f3d39-c055-4afe-b659-df0401954695.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, adjusting both the frequency ranges and the frequency governor
    allows you to flexibly fine-tune the frequency depending on the nature of the
    system and reduce the power consumed by the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides `ondemand`, `performance`, and `powersave`, there are other governors
    that provide even more flexible tuning of CPU frequency from userspace applications.
    You can find more details about the available governors and their properties in
    the corresponding section of Linux CPUFreq at [https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt](https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt)
  prefs: []
  type: TYPE_NORMAL
- en: Using events for waiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waiting is an extremely common pattern in software development. Applications
    have to wait for user input or for data to be ready for processing. Embedded programs
    communicate with peripheral devices and need to know when data can be read from
    the device and when the device is ready to accept data.
  prefs: []
  type: TYPE_NORMAL
- en: Often, developers use variations of the polling technique for waiting. They
    check a device-specific availability flag in a loop, and when it is set to true
    by the device, they proceed with reading or writing data.
  prefs: []
  type: TYPE_NORMAL
- en: Though this approach is easy to implement, it is inefficient from the perspective
    of power consumption. When a processor is constantly busy looping around a flag
    check, it cannot be put into a more power-efficient mode by the operating system
    power manager. Based on the load, the Linux `ondemand` frequency governor that
    we discussed earlier can even decide to increase the CPU frequency despite the
    fact that it is a wait in disguise. Additionally, polling requests may prevent
    the target device or the device bus from staying in power-saving mode until data
    is ready.
  prefs: []
  type: TYPE_NORMAL
- en: That is why instead of polling programs that care about energy efficiency, it
    should rely on interrupts and events generated by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the operating system events to wait
    for a specific USB device to be connected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create an application that can monitor USB devices and wait
    until a specific device appears:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working `~/test` directory create a subdirectory called `udev`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `udev.cpp` file in the `udev` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the essential includes and the `namespace` definition into the `udev.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define the `Device` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the definition of the `Monitor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After `Device` and `Monitor` are defined in the `usb` namespace, add a simple `main` function that
    shows how to use them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Copy the `udev` directory into your home directory on your Linux box using `ssh`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to your Linux box, change the directory to `udev`, and build the program
    using `cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get system notifications about events on USB devices, we are using a library
    called `libudev`. It provides only a plain C interface, and so we created simple
    C++ wrappers to make coding easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our wrapper classes, we declared a `namespace` named `usb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It contains two classes. The first class is `Device`, which gives us a C++ interface
    to a low-level `libudev` object called `udev_device`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a constructor that created an instance of `Device` from a `udev_device`
    pointer and a destructor to release the `udev_device`. Internally, `libudev` uses
    reference counting for its object, and so our destructor calls a function to decrease
    the reference count of the `udev_device`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can copy the `Device` instances without memory or file descriptor
    leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the constructors and the destructor, the `Device` class has only two
    methods: `action` and `attr`. The `action` method returns the most recent USB
    device action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attr` method returns any sysfs attribute associated with the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Monitor` class also has a constructor and a destructor, but we made it
    noncopyable by disabling the copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the `libudev` instance using a static variable
    to ensure it is initialized only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'It also sets up the monitoring filter and enables monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wait` method contains the most important monitoring logic. It accepts
    a function-like `process` object that is called each time an event is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The function should return `true` if the event and the device it originates
    from are what we need; otherwise, it returns `false` to indicate that `wait` should
    keep working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internally, the `wait` function creates a file descriptor that is used to deliver
    device events to the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it sets up the monitoring loop. Despite its name, the `poll` function does
    not check the status of devices constantly; it waits for events on the specified
    file descriptors. We pass `-1` as a timeout, indicating that we intend to wait
    for events forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `poll` function returns only in the case of an error or a new USB event.
    We handle an error condition by throwing an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For each event, we create a new instance of `Device` and pass it to the `process`.
    If `process` returns `true`, we exit the wait loop, returning the instance of
    `Device` to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we can use these classes in our application. In the `main` function,
    we create an instance of `Monitor` and invoke its `wait` function. We use a lambda
    function to process each action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the lambda function, we print information about all of the events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also check for the specific action and device `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Once found, we display information about its function and power requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this application initially does not produce any output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/981bab41-7f4d-4a76-9bd0-5e55b1811789.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, once we insert a USB device (a USB microphone in my case), we can
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8c72d62-873a-42ca-9486-e57804844157.png)'
  prefs: []
  type: TYPE_IMG
- en: The application can wait for a specific USB device and handle it after it is
    connected. It does this without busy looping, relying on the information provided
    by the operating system. As a result, the application spends most of the time
    sleeping while the `poll` call is blocked by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of C++ wrappers for `libudev`. You can use one of these or
    create your own using the code from the recipe as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling power consumption with PowerTOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In complex operating systems such as Linux that run multiple userspace and kernel
    space services and control many peripheral devices at once, it is not always easy
    to find components that can cause excessive power drain. Even when inefficiency
    is identified, fixing it may be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: One of the solutions is to use a power profiler tool, such as PowerTOP. It can
    diagnose issues with power consumption in a Linux system and allows the user to
    tweak system parameters that can save power.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to install and use PowerTOP on a Raspberry
    Pi system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will run PowerTOP in interactive mode and analyze its output:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Raspberry Pi system as user `pi`, using the password `raspberry`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `sudo` to gain root access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Install PowerTOP from the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Staying in a root shell, run PowerTOP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The PowerTOP UI will show up in your Terminal. Use the *Tab* key to navigate
    between its screens.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PowerTOP is a tool created by Intel to diagnose power issues in a Linux system.
    It is part of the Raspbian distribution and can be installed using the `apt-get`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run it without parameters, it starts in an interactive mode and lists
    all of the processes and kernel tasks, ordered by their power usage and the frequency
    of the events they generate. As we discussed in the *Using events for waiting*
    recipe, the more often a program has to wake up the processor, the less energy
    efficient it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f7a54ae-1a79-4f1f-91ce-152fbfd006a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the *Tab* key, we can switch to other reporting modes. For example, Device
    stats shows how much energy or CPU time the devices consume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e968743-e8ab-4fe5-a55b-b05a3742586c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another interesting tab is Tunab. PowerTOP can check a number of settings that
    affect power consumption and flags those that are suboptimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3140c865-d15a-48e7-80de-28bd1c5857a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, two of the USB devices are marked as `Bad` because they do
    not use autosuspend. By pressing the *Enter* key, PowerTOP enables autosuspend,
    displaying a command line that can be used from a script to make it permanent.
    After autosuspend is enabled, the tunable status changes to `Good`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/866eb512-32b4-4ea7-a5bd-5f42106a267c.png)'
  prefs: []
  type: TYPE_IMG
- en: A number of system parameters can be tuned to save power. Sometimes they are
    obvious, like using autosuspend on USB devices. Sometimes they are not, such as
    using timeout on the kernel that is used to flush the file cache to disk. Using
    power diagnostic and optimization tools such as PowerTOP helps you to tune your
    system for maximum power efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides its interactive mode, PowerTOP has other modes to help you optimize
    power use, such as calibration, workload, and auto-tune. More information about
    PowerTOP features, usage scenarios, and the interpretation of results can be found
    in the *PowerTOP User* *Guide* at [https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf](https://01.org/sites/default/files/page/powertop_users_guide_201412.pdf).
  prefs: []
  type: TYPE_NORMAL
