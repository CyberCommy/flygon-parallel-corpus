- en: Regmap API â€“ A Register Map Abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the regmap API was developed, there were redundant codes for the device
    drivers dealing with SPI core, I2C core, or both. The principle was the same;
    accessing the register for read/write operations. The following figure shows how
    either SPI or I2C API were standalone before Regmap was introduced to kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00016.gif)'
  prefs: []
  type: TYPE_IMG
- en: SPI and I2C subsystems before regmap
  prefs: []
  type: TYPE_NORMAL
- en: 'The regmap API was introduced in version 3.1 of the kernel, to factorize and
    unify the way kernel developers access SPI/I2C devices. It is then just a matter
    of how to initialize, configure a regmap, and process any read/write/modify operation
    fluently, whether it is SPI or I2C:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SPI and I2C subsystems after regmap
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will walk through regmap framework by mean of:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the main data structures used in by the regmap framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walking through regmap configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing devices using the regmap API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the regmap caching system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a complete driver that summarizes the concepts learned previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with the regmap API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The regmap API is quite simple. There are only a few structures to know. The
    two most important structures of this API are `struct regmap_config` , which represents
    the configuration of the regmap, and `struct regmap` , which is the regmap instance
    itself. All of the regmap data structures are defined in `include/linux/regmap.h`
    .
  prefs: []
  type: TYPE_NORMAL
- en: regmap_config structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`struct regmap_config` stores the configuration of the regmap during the driver''s
    lifetime. What you set here affects read/write operations. It is the most important
    structure in the regmap API. The source looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`reg_bits` : This mandatory field is the number of bits in a register''s address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val_bits` : This represents the number of bits used to store a register''s
    value. It is a mandatory field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writeable_reg` : This is an optional callback function. If provided, it is
    used by the regmap subsystem when a register needs to be written. Before writing
    into a register, this function is automatically called to check whether the register
    can be written to or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`readable_reg` : This is the same as `writeable_reg` but for every register
    read operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volatile_reg` : This is a callback function called every time a register needs
    to be read or written through the regmap cache. If the register is volatile, the
    function should return true. A direct read/write is then performed to the register.
    If false is returned, it means the register is cacheable. In this case, the cache
    will be used for a read operation, and the cache will be written in the case of
    a write operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`wr_table` : Instead of providing a `writeable_reg` callback, one could provide
    a `regmap_access_table` , which is a structure holding a `yes_range` and a `no_range`
    field, both pointers to `struct regmap_range` . Any register that belongs to a
    `yes_range` entry is considered as writeable, and is considered as not writeable
    if it belongs to a `no_range` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rd_table` : This is same as `wr_table` , but for any read operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volatile_table` : Instead of `volatile_reg` , one could provide `volatile_table`
    . The principle is then the same as `wr_table` or `rd_table` , but for the caching
    mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_register` : This is optional, it specifies the maximum valid register
    address, upon which no operation is permitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reg_read` : Your device may not support simple I2C/SPI read operations. You''ll
    then have no choice but to write your own customized read function. `reg_read`
    should then point to that function. That said most devices do not need that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reg_write` : This is the same as `reg_read` but for write operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I highly recommend you look at `include/linux/regmap.h` for more details on
    each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a kind of initialization of `regmap_config` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: regmap initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, the regmap API supports both SPI and I2C protocols. Depending
    on the protocol you need to support in your driver, you will have to call either
    `regmap_init_i2c()` or `regmap_init_sp()i` in the `probe` function. To write a
    generic driver, regmap is the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: The regmap API is generic and homogenous. Only the initialization changes between
    bus types. Other functions are the same.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to always initialize the regmap in the `probe` function,
    and one must always fill the `regmap_config` elements prior to initializing the
    regmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether one allocated an I2C or SPI register map, it is freed with `regmap_exit`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function simply release a previously allocated register map.
  prefs: []
  type: TYPE_NORMAL
- en: SPI initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regmap SPI initialization consists of setting the regmap up, so that any device
    access will internally be translated into SPI commands. The function that does
    is `regmap_init_spi()` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It takes a valid pointer to a `struct spi_device` structure as a parameter,
    which is the SPI device that will be interacted with, and a `struct regmap_config`
    that represents the configuration for the regmap. This function returns either
    a pointer to the allocated struct regmap on success, or a value that will be an
    `ERR_PTR()` on error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I2C initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the other hand, I2C regmap initialization consists of calling `regmap_init_i2c()`
    on the regmap config, which will configure the regmap so that any device access
    will internally be translated into I2C commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The function takes a `struct i2c_client` structure as parameter, which is the
    I2C device that will used for interaction, along with a pointer to `struct regmap_config`
    which represents the configuration for the regmap. This function returns either
    a pointer to the allocated `struct regmap` on success, or a value that will be
    an `ERR_PTR()` on error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Device access functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API handles data parsing, formatting, and transmission. In most cases,
    device accesses are performed with `regmap_read` , `regmap_write` and `regmap_update_bits`
    . These are the three most important functions you should always remember when
    it comes to storing/fetching data into/from the device. Their respective prototypes
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`regmap_write` : This writes data to the device. If set in `regmap_config`
    , `max_register` , it will be used to check if the register address you need to
    read from is greater or lower. If the register address passed is lower than or
    equal to, `max_register` , then the write operation will be performed; otherwise,
    the regmap core will return invalid I/O error (`-EIO` ). Immediately after, the
    `writeable_reg` callback is called. The callback must return `true` before going
    on to the next step. If it returns `false` , then `-EIO` is returned and the write
    operation stopped. If `wr_table` is set instead of `writeable_reg` , then:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the register address lies in `no_range` , `-EIO` is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the register address lies in `yes_range` , the next step is performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the register address is present neither in `yes_range` nor `no_range` , then
    `-EIO` is returned and the operation is terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `cache_type != REGCACHE_NONE` , then cache is enabled. In this case, the
    cache entry is first updated, and then a write to the hardware is performed; otherwise,
    a no cache action is performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `reg_write` callback is provided, it is used to perform the write operation;
    otherwise, the generic regmap write function will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regmap_read` : This reads data from the device. It works exactly like `regmap_write`
    with appropriate data structures (`readable_reg` , and `rd_table` ). Therefore,
    if provided, `reg_read` is used to perform the read operation; otherise, the generic
    remap read function will be performed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: regmap_update_bits function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`regmap_update_bits` is a three-in-one function. Its prototype is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It performs a read/modify/write cycle on the register map. It is a wrapper
    on `_regmap_update_bits` , which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, bits you need to update must be set to `1` in `mask` , and the corresponding
    bits should be set to the value you need to give to them in `val` .
  prefs: []
  type: TYPE_NORMAL
- en: As an example, to set the first and third bits to `1` , the mask should be `0b00000101`
    , and the value should be `0bxxxxx1x1` . To clear the seventh bit, mask must be
    `0b01000000` and the value should be `0bx0xxxxxx` , and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Special regmap_multi_reg_write function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of `remap_multi_reg_write()` function is writing multiple registers
    to the device. Its prototype looks like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how to use that function, you need to know what `struct reg_sequence`
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Other device access functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`regmap_bulk_read()` and `regmap_bulk_write()` are used to read/write multiple
    registers from/to the device. Use them with large blocks of data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to look into the regmap header file in the kernel source to see what
    choices you have.
  prefs: []
  type: TYPE_NORMAL
- en: regmap and cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, regmap supports caching. Whether the cache system is used or not
    depends on the value of the `cache_type` field in `regmap_config` . Looking at
    `include/linux/regmap.h` , accepted values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is set to `REGCACHE_NONE` by default, meaning that the cache is disabled.
    Other values simply define how the cache should be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your device may have a predefined power-on-reset value in certain registers.
    Those values can be stored in an array, so that any read operation returns the
    value contained in the array. However, any write operation affects the real register
    in the device, and updates the content in the array. It is a kind of a cache that
    we can use to speed up access to the device. That array is `reg_defaults` . Its
    structure looks like this in the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`reg_defaults` is ignored if `cache_type` is set to none. If no `default_reg`
    is set but you still enable the cache, the corresponding cache structure will
    be created for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite simple to use. Just declare it and pass it as a parameter to the
    `regmap_config` structure. Let''s have a look at the `LTC3589` regulator driver
    in `drivers/regulator/ltc3589.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Any read operation on any one of the registers present in the array will immediately
    return the value in the array. However, a write operation will be performed on
    the device itself, and updates the affected register in the array. This way, reading
    the `LTC3589_VRRCR` register will return `0xff` ; write any value in that register
    and it will update its entry in the array so that any new read operation will
    return the last written value, directly from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to set up regmap subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a struct `regmap_config` , according to your device's characteristic.
    Set a register range if needed, default values if any, the `cache_type` if needed,
    and so on. If custom read/write functions are needed, pass them to `reg_read/reg_write`
    fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `probe` function, allocate a regmap using `regmap_init_i2c` or `regmap_init_spi`
    depending on the bus: I2C or SPI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you need to read/write from/into registers, call `remap_[read|write]`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are done with the regmap, call `regmap_exit` to free the register map
    allocated in `probe` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A regmap example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve our goal, let''s first describe a fake SPI device for which we can
    write a driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 8-bit register address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8-bit register values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Max register: 0x80'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The write mask is 0x80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Valid address range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0x20 to 0x4F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0x60 to 0x7F
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No custom read/write function needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a fake skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about the regmap API. How easy it is, gives you an idea
    about how useful and widely used it is. This chapter has told you everything you
    need to know about the regmap API. Now you should be able to convert any standard
    SPI/I2C driver into a regmap. The next chapter will cover IIO devices, a framework
    for an analog to digital converter. Those kinds of device always sit on top of
    the SPI/I2C buses. It will be a challenge for us, at the end of the next chapter,
    to write an IIO driver using the regmap API.
  prefs: []
  type: TYPE_NORMAL
