- en: Cryptocurrency Wallet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密货币钱包
- en: In this chapter, you are going to learn how to build a desktop cryptocurrency
    wallet. You will still use the same GUI library, Qt for Python or PySide2 to create
    a desktop application. This cryptocurrency wallet can send ethers as well as ERC20
    tokens. Before building this cryptocurrency wallet, you will learn advanced features
    of the PySide2 library, such as tabs, comboboxes, size policy, and adding stretch
    to control the distribution of widgets in a layout. On top of that, you will integrate
    testing into applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何构建一个桌面加密货币钱包。您仍将使用相同的GUI库，Qt for Python或PySide2来创建桌面应用程序。这个加密货币钱包可以发送以太币和ERC20代币。在构建这个加密货币钱包之前，您将学习PySide2库的高级功能，比如标签、组合框、大小策略以及添加拉伸以控制布局中小部件的分布。此外，您还将把测试集成到应用程序中。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Advanced features of the PySide2 library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PySide2库的高级功能
- en: Pytest Qt, a library to test a Qt for a Python application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pytest Qt，用于测试Python应用程序的Qt库
- en: How to build a cryptocurrency wallet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建加密货币钱包
- en: Some considerations when building a cryptocurrency wallet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建加密货币钱包时需要考虑的一些因素
- en: Advanced features of the PySide2 library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PySide2库的高级功能
- en: This chapter requires the reader to have some knowledge of the PySide2 library.
    You should read [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend
    Decentralized Application*,first if you have not done so, as this chapter is based
    on that one. If you have familiarized yourself with building a GUI with `PySide2`,
    you are equipped with the necessary skills to build a desktop cryptocurrency wallet,
    at least from the **User Interface** (**UI**) persepective. However, the application
    that you build will be jarring to users. For example, if you incorporated a button
    in a horizontal layout and that button is the only widget in the horizontal layout,
    when you resize the window that has the horizontal layout, the button will be
    stretched to the right and left. If this is not what you want to happen, you need
    a way to tell the button to keep its width.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要读者对PySide2库有一定的了解。如果您还没有这样做，您应该先阅读[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml)
    *前端去中心化应用*，因为本章是基于那一章的。如果您已经熟悉了使用`PySide2`构建GUI，那么您就具备了构建桌面加密货币钱包所需的技能，至少从**用户界面**（**UI**）的角度来看。但是，您构建的应用程序对用户来说可能会很刺耳。例如，如果您在水平布局中加入了一个按钮，并且该按钮是水平布局中唯一的小部件，当您调整具有水平布局的窗口大小时，按钮将被拉伸到右侧和左侧。如果这不是您想要发生的，您需要一种方法告诉按钮保持其宽度。
- en: So, let's learn other features from the `PySide2` library, such as tab, size
    policy, and grid layout, so that we have the skills to make the UI of our application
    more attractive. Our application will not win the *Apple Best Design Award*, but
    at least it will be less jarring for users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从`PySide2`库中学习其他功能，比如标签、大小策略和网格布局，这样我们就有了制作应用程序UI更具吸引力的技能。我们的应用程序可能不会赢得*苹果最佳设计奖*，但至少对用户来说不会那么刺耳。
- en: In addition, in [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized
    Application*, we neglected testing. Since a cryptocurrency wallet application
    is an application that handles people's money, errors are costly. Consequently,
    we need to catch any errors before users do. We should therefore write proper
    testing for our cryptocurrency wallet. However, we will focus on testing for the
    UI part of the cryptocurrency wallet. We will not focus on testing inner methods.
    In other words, our testing will be integration testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml) *前端去中心化应用*中，我们忽略了测试。由于加密货币钱包应用程序是处理人们的资金的应用程序，错误是代价高昂的。因此，我们需要在用户之前捕捉到任何错误。因此，我们应该为我们的加密货币钱包编写适当的测试。但是，我们将专注于对加密货币钱包的UI部分进行测试。我们不会专注于测试内部方法。换句话说，我们的测试将是集成测试。
- en: 'Install the `Qt` library if you haven''t already done so. Please read [Chapter
    7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized Application*,
    for guidance on how to do this. After doing so, create a virtual environment for
    your project using the following command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装`Qt`库，请阅读[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml) *前端去中心化应用*，了解如何安装。之后，使用以下命令为您的项目创建一个虚拟环境：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also want to install a test library to test our application, which can be
    done by means of the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望安装一个测试库来测试我们的应用程序，可以通过以下命令来完成：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that all the libraries have been set up, let's write a simple application
    so we can test it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的库都已经设置好了，让我们写一个简单的应用程序来测试一下。
- en: Testing application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: 'Create a directory named `advanced_course_qt`. We can put all of our tutorial
    files here. Name the first script `button_and_label.py` and use the following
    code to create a button and a label for that button (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py)):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`advanced_course_qt`的目录。我们可以把所有的教程文件放在这里。将第一个脚本命名为`button_and_label.py`，并使用以下代码为该按钮创建一个按钮和一个标签（请参考以下GitLab链接上的代码文件获取完整代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py)）：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the preceding code to see what this application is about. The application
    consists of a button and a label:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，看看这个应用程序是关于什么的。该应用程序由一个按钮和一个标签组成：
- en: '![](assets/62549502-1017-428a-ac5f-b1ed6284849b.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62549502-1017-428a-ac5f-b1ed6284849b.png)'
- en: 'If you click the button, the text on the label will change, as shown in the
    following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击按钮，标签上的文本将会改变，如下图所示：
- en: '![](assets/62e8a851-c9d0-42e7-ad12-ac727a7ccba6.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62e8a851-c9d0-42e7-ad12-ac727a7ccba6.png)'
- en: 'So let''s test this application. Name the test `test_button_and_label.py` and
    put it in the same directory. Use the following code block for the test application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个应用程序。将测试命名为`test_button_and_label.py`，并将其放在相同的目录中。使用以下代码块进行测试应用程序：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the test using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be aware that the `(wallet-venv) $ python test_button_and_label.py`command is
    a negligible error often used to run the test. Don't fall for it!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`(wallet-venv) $ python test_button_and_label.py`命令是一个微不足道的错误，经常用于运行测试。不要上当！
- en: In this test script, we import our `widget` class. Then, we create a test method
    that has a name starting with `test_`. This method has a parameter named `qtbot`.
    Don't change its name. `qtbot` is a special name and must not be changed. Inside
    this method, `qtbot` can be used to interact with the `widget` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试脚本中，我们导入我们的`widget`类。然后，我们创建一个以`test_`开头的测试方法。这个方法有一个名为`qtbot`的参数。不要更改它的名称。`qtbot`是一个特殊的名称，不得更改。在这个方法内部，`qtbot`可以用来与`widget`类交互。
- en: 'First of all, we instantiate a `widget` class that we want to test. Then, we
    add that `widget` instance using the `addWidget` method from `qtbot`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个我们想要测试的`widget`类。然后，我们使用`qtbot`的`addWidget`方法添加该`widget`实例：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we test the `text` on the `label` variable before clicking the button:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在单击按钮之前，我们测试`label`变量上的`text`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, we can access `label` from `widget`. This is made possible
    because we declared the `label` variable in `button_and_label.py` using the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以从`widget`中访问`label`。这是因为我们在`button_and_label.py`中使用以下代码声明了`label`变量：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you declare the label in `button_and_label.py` with the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`button_and_label.py`中使用以下代码声明标签：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then you would not be able to access `label` from the instance of `widget`
    in the test. Of course, you could circumvent that situation by creating a variable
    to hold the text of the label. However, making the `label` a `widget` instance
    property is the easiest thing to do in order to test the text of the label. You
    will use this strategy in all further tests. In a nutshell, if you want to test
    widgets (such as a label, button, or combobox), make that `widget` a property
    of its parent widget instance. Then, we move on to how we click the button widget:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将无法从测试中的`widget`实例访问`label`。当然，您可以通过创建一个变量来保存标签的文本来规避这种情况。然而，将`label`作为`widget`实例属性是测试标签文本的最简单方法。您将在所有后续测试中使用这种策略。简而言之，如果您想测试小部件（如标签、按钮或组合框），请将该`widget`作为其父小部件实例的属性。然后，我们继续讨论如何单击按钮小部件：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To click a button during testing, you use the `mouseClick` method from `qtbot`.
    The first parameter of the `mouseClick` method of `qtbot` is a button widget,
    or something that accepts a clicking event. The second parameter is an option
    to detect the nature of the mouse click event. The test in this case will only accept a
    left button click.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试期间单击按钮，您可以使用`qtbot`的`mouseClick`方法。`qtbot`的`mouseClick`方法的第一个参数是一个按钮小部件，或者是接受点击事件的东西。第二个参数是检测鼠标点击事件性质的选项。在这种情况下，测试将只接受左键点击。
- en: 'The following code is to test and display the text of a label after clicking
    the button:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是测试并显示单击按钮后标签的文本：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In building a GUI application, on occasion, we have to display a list of objects.
    In our cryptocurrency wallet, the list could hold accounts. So let''s write a
    test for that scenario. First, however, we have to create a script to display
    a list of objects. Name the script `button_and_list.py` and use the following
    code block for the script (refer to the code file on the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py)):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建GUI应用程序时，我们偶尔需要显示对象列表。在我们的加密货币钱包中，列表可以包含账户。因此，让我们为这种情况编写一个测试。但首先，我们必须创建一个脚本来显示对象列表。将脚本命名为`button_and_list.py`，并使用以下代码块进行脚本（有关完整代码，请参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py)）：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the script to see how the application appears. The following shows the
    screenshot of the button prior to clicking it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本以查看应用程序的外观。以下是单击按钮之前的按钮的屏幕截图：
- en: '![](assets/e116c5e4-dd24-4718-ab6a-9c882d979332.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e116c5e4-dd24-4718-ab6a-9c882d979332.png)'
- en: 'And the following shows the result of clicking the button:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了单击按钮的结果：
- en: '![](assets/7ee4e5c2-944b-4949-95ed-39eb0e8c382f.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ee4e5c2-944b-4949-95ed-39eb0e8c382f.png)'
- en: You have a single button here and if you click it, a new label should appear
    with text that simply reads `1`. If you click the button for a second time, a
    new label will appear at the bottom with text that reads `2`, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个按钮，如果您单击它，将会出现一个新的标签，文本简单地显示为`1`。如果您再次单击按钮，将会在底部出现一个新的标签，文本显示为`2`，依此类推。
- en: The new label that shows up after we click the button is part of the vertical
    box layout. This means that we need to make that vertical box layout the widget
    instance's property so that we can access it in the test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮后出现的新标签是垂直框布局的一部分。这意味着我们需要将垂直框布局作为小部件实例的属性，以便在测试中访问它。
- en: 'Let''s write a test for this GUI script, as shown in the following code block,
    and name it `test_button_and_list.py`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个GUI脚本编写一个测试，如下面的代码块所示，并将其命名为`test_button_and_list.py`：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see in the preceding code block, after the third execution of the `mouseClick`
    method of `qtbot`, we grab the label from the vertical box layout using the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码块中所看到的，在`qtbot`的`mouseClick`方法第三次执行之后，我们使用以下代码从垂直框布局中获取标签：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We take the child widget of a widget by means of the `takeAt` method. The parameter
    that we use in this case is `2`. This means that we want to grab the third child,
    the last one. Then, we test the text of the widget using the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`takeAt`方法获取小部件的子小部件。在这种情况下我们使用的参数是`2`。这意味着我们想要获取第三个子小部件，也就是最后一个。然后，我们使用以下代码测试小部件的文本：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's create a more complicated scenario. Hitherto, everything we have tested
    has been inside one window, but what if we have an input dialog? How do we test
    a dialog?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更复杂的场景。到目前为止，我们测试的所有内容都在一个窗口内，但如果有一个输入对话框怎么办？我们如何测试对话框？
- en: 'Let''s create a GUI script that has a dialog and name it `button_and_dialog.py`:
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py)):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有对话框的GUI脚本，并将其命名为`button_and_dialog.py`：（有关完整代码，请参考以下GitLab链接的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py)）：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the code to view the application. There is a button and empty space beneath
    it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码以查看应用程序。有一个按钮和空白空间在其下方：
- en: '![](assets/e948dc67-2901-4f81-9c2a-241f051f0a48.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e948dc67-2901-4f81-9c2a-241f051f0a48.png)'
- en: 'Click button and a dialog will appear, after which you should type any text
    in the input dialog and click OK:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮，然后会出现一个对话框，之后您应该在输入对话框中输入任何文本，然后点击OK：
- en: '![](assets/9d3d1205-4bdd-461c-8afa-20e9baa69f60.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d3d1205-4bdd-461c-8afa-20e9baa69f60.png)'
- en: 'The text you have inputted will appear beneath the button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入的文本将出现在按钮下方：
- en: '![](assets/5b54a19c-249e-4153-816d-e2e68a29d8b7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5b54a19c-249e-4153-816d-e2e68a29d8b7.png)'
- en: 'Let''s take a look at another test script in the following code block in order
    to understand how to handle the flow involving two different windows. In this
    test method, we have another parameter besides `qtbot`, called `monkeypatch`. Name
    the test file `test_button_and_dialog.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码块中的另一个测试脚本，以了解如何处理涉及两个不同窗口的流程。在这个测试方法中，除了`qtbot`之外，我们还有另一个参数叫做`monkeypatch`。将测试文件命名为`test_button_and_dialog.py`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`monkeypatch` is used to override a dialog input. This means that the `getText`
    method of `QInputDialog` would return a `("New Text", True)` tuple when we launch
    the dialog in the test. Remember the API of `QInputDialog`? This returns a tuple.
    This tuple contains two parameters—the text that we type in the dialog, and whether
    we click the OK or Cancel buttons.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`用于覆盖对话框输入。这意味着在测试中，`QInputDialog`的`getText`方法将返回一个`("New Text",
    True)`元组。记得`QInputDialog`的API吗？这返回一个元组。这个元组包含两个参数——我们在对话框中输入的文本，以及我们是否点击了OK或取消按钮。'
- en: 'The `getText` method of `QInputDialog` accepts four parameters: the window
    instance that this dialog is based upon, the title, the label before the input
    field, and the type of input field. When you type text, such as `To the moon!`
    in the input field, and clicked the **OK** button, it returns a tuple consisting
    of the string `To the moon!` and the `boolean` value of whether you click the OK button:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`QInputDialog`的`getText`方法接受四个参数：此对话框基于的窗口实例、标题、输入字段之前的标签和输入字段的类型。当您在输入字段中输入文本，例如`To
    the moon!`，然后点击**OK**按钮时，它会返回一个元组，其中包含字符串`To the moon!`和您是否点击了**OK**按钮的`boolean`值：'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, `monkeypatch` patches this method so in the testing, no dialog would
    be launched. We bypass them. It''s as if the launching dialog line is replaced
    with the following line of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`monkeypatch`会修补这个方法，因此在测试中，不会启动对话框。我们绕过它们。就好像启动对话框的行被以下代码替换了一样：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For all of these tests, we always use a button-type widget to initiate something
    (changing the text on the label). Let''s use another type of widget to change
    the label, as given in the following code block, and name the script `combobox_and_label.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些测试，我们总是使用一个按钮类型的小部件来启动某些操作（更改标签上的文本）。让我们使用另一种类型的小部件来更改标签，如下面的代码块所示，并将脚本命名为`combobox_and_label.py`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This GUI script uses combobox to change the text on the label. It sets the
    text on the label with the text from the selected option of the label. Run the
    script to see how it appears:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GUI脚本使用组合框来更改标签上的文本。它使用所选标签的文本设置标签上的文本。运行脚本以查看它的外观：
- en: '![](assets/cb21233e-8a94-4283-8442-15ac65678c0a.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb21233e-8a94-4283-8442-15ac65678c0a.png)'
- en: 'Now, let''s create a test script to test this combobox widget and name it `test_combobox_and_label.py`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个测试脚本来测试这个组合框小部件，并将其命名为`test_combobox_and_label.py`：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The key point that we can take here is the way we change the selected option
    of `combobox` with `qtbot`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里得到的关键点是使用`qtbot`更改`combobox`的选定选项的方式：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method's name is not intuitive; it accepts two parameters. The first one
    is the widget, or the combobox in this case. The second one is the option text
    in the combobox. This `keyClicks` method is not just for selecting an option in
    combobox. It could also be used to type text in the line edit. Just put the line
    edit widget in the first parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的名称不直观；它接受两个参数。第一个是小部件，或者在这种情况下是组合框。第二个是组合框中的选项文本。这个`keyClicks`方法不仅用于选择组合框中的选项。它也可以用于在行编辑中输入文本。只需将行编辑小部件放在第一个参数中。
- en: This test knowledge is sufficient for testing our cryptocurrency wallet. Before
    we jump into building our cryptocurrency wallet, let's learn about some other
    features of `PySide2`, including grid layout, tab, and size policy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试知识足以测试我们的加密货币钱包。在我们开始构建加密货币钱包之前，让我们了解一下`PySide2`的一些其他功能，包括网格布局、选项卡和大小策略。
- en: Advanced features of Qt for Python or PySide2
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt for Python或PySide2的高级功能
- en: The first thing that we want to learn about here is stretching. We know how
    to add widgets to a box layout (vertical or horizontal). However, we can configure
    to some extent how to distribute these widgets that we added into a box layout.
    Should we stretch the widgets, put the widgets on top for the horizontal layout,
    and let the space devour the rest?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to explain this configuration of widget distribution
    in a box layout and name the script `add_stretch.py` (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the script to see how it looks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2001b1a9-b988-4014-a04d-6489c683e960.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: If you add stretching to the end of the vertical container, it would push the
    widgets to the beginning of the vertical container and let the rest be an empty
    space. If you add stretching in the beginning, it would push the widgets to the
    end of the vertical container and let the rest be an empty space. If you don't
    add any stretching, the widgets would be distributed equally across the layout.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the functionality of the application, it does not make any difference.
    However, it can make the UI more attractive if you choose the right options.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We always use the box layout (vertical box layout or horizontal box layout).
    The box layout suffices in most cases. Occasionally, however, you want to use
    a more complicated layout. Qt has a grid layout that is more powerful than the
    box layout.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to explore the power of the grid layout and name the
    script `create_grid_window.py` (refer to the code file on the following GitLab
    link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py)):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the script to see how the grid layout manages its child window:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2c8e907-efc1-463d-9333-8d8b1ddd2cd4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: A grid is like a table or spreadsheet. Instead of adding a widget to a row with
    a horizontal layout, or a column with a vertical layout, you add a widget to a
    table that is composed of rows and columns.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add the widget to the first row and the first column, use the
    following statement:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first parameter indicates a row. The second parameter indicates a column.
    So if you want to add the widget to the second row and the first column, use the
    following statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `addWidget` method of the grid layout accepts optional third and fourth
    parameters. The third parameter indicates how many rows you want this widget to
    extend to. The fourth parameter indicates how many columns you want this widget
    to extend to:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you stretch the window, you will see something similar to the following
    screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19cdf235-f769-4620-9caf-ac701ea923fe.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Take a look at Label G. This stretches up to two rows and two columns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about what happens to the widget if we increase the size of
    the parent window that contains the widget. Should the widget resize along with
    it? Should the widget stay still, and allow the margin to become wider? You can
    decide on the resizing configuration with the size policy. Let''s create a script
    named `button_with_sizepolicy.py` to demonstrate size configuring this policy
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py)):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the script to see how each button appears differently with a different
    size policy:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本以查看每个按钮如何根据不同的大小策略显示不同：
- en: '![](assets/ec08a954-b1aa-4eba-b33f-2d6c07bac46b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ec08a954-b1aa-4eba-b33f-2d6c07bac46b.png)'
- en: 'Then, try to resize the window to make sense of the size policy configuration:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，尝试调整窗口大小以理解大小策略配置：
- en: '![](assets/9e0ef275-b462-4e6f-8b73-82e0d853e917.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9e0ef275-b462-4e6f-8b73-82e0d853e917.png)'
- en: '`QSizePolicy.Maximum` indicates that the widget cannot be bigger than the size
    hint, or the content of the button in this case. If you want your button to stick
    to its original size, use this size policy. `QSizePolicy.Preferred` indicates
    that it prefers a size hint but it can be larger or smaller. `QSizePolicy.Expanding`
    indicates that the widget should expand as much as possible. `QSizePolicy.Minimum`
    indicates that the widget can be expanded, but it cannot be smaller than the size
    hint. `QSizePolicy.MinimumExpanding` indicates that the widget cannot be smaller
    than the size hint, but it expands as much as possible.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSizePolicy.Maximum`表示小部件不能比大小提示更大，或者在这种情况下按钮的内容。如果您希望按钮保持其原始大小，请使用此大小策略。`QSizePolicy.Preferred`表示它更喜欢大小提示，但它可以更大或更小。`QSizePolicy.Expanding`表示小部件应尽可能扩展。`QSizePolicy.Minimum`表示小部件可以扩展，但不能小于大小提示。`QSizePolicy.MinimumExpanding`表示小部件不能小于大小提示，但尽可能扩展。'
- en: In creating a GUI application, most of the time you would not put all of your
    functionalities/widgets in a single window. Otherwise, the window would be bigger
    than the screen resolution of the monitor.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建GUI应用程序时，大多数情况下您不会将所有功能/小部件放在一个窗口中。否则，窗口将比显示器的屏幕分辨率大。
- en: You could launch a dialog with a button to hold more functionalities/widgets.
    That certainly works. But what you really want is something like a controller.
    In Qt, you have **StackView**. StackView can contain many windows, but it displays
    a maximum of one window at one time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动一个对话框，其中包含一个按钮来容纳更多功能/小部件。这当然有效。但是您真正想要的是类似控制器的东西。在Qt中，您有**StackView**。StackView可以包含许多窗口，但一次只显示一个窗口。
- en: 'We wouldn''t use StackView directly. Instead, we use tabbed view. Tabbed view
    uses StackView behind the scenes. Let''s create a script to use tabbed view and
    name it `tabbed_window.py`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用StackView。相反，我们使用选项卡视图。选项卡视图在幕后使用StackView。让我们创建一个脚本来使用选项卡视图，并将其命名为`tabbed_window.py`：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This tabbed window has three tabs. Each tab holds a widget. The second tab even
    holds a widget that we created in a separate script, `button_and_label.py`. This
    widget, which is in the second tab, has a button and a label. To add a tab to
    a tabbed window, you use the `addTab` method. The first parameter is the widget,
    and the second parameter is the title of the tab.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项卡窗口有三个选项卡。每个选项卡都包含一个小部件。第二个选项卡甚至包含一个我们在单独的脚本`button_and_label.py`中创建的小部件。这个小部件在第二个选项卡中有一个按钮和一个标签。要向选项卡窗口添加选项卡，您可以使用`addTab`方法。第一个参数是小部件，第二个参数是选项卡的标题。
- en: 'Run the script to see how tabbed view works. In the following screenshot, we
    see Tab 1:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本查看选项卡视图的工作原理。在下面的截图中，我们看到选项卡1：
- en: '![](assets/c4710d0e-3940-4c79-8d3a-4822a3b367eb.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c4710d0e-3940-4c79-8d3a-4822a3b367eb.png)'
- en: 'In the following screenshot, we see Tab 2 and the widget from `button_and_label.py`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们看到选项卡2和来自`button_and_label.py`的小部件：
- en: '![](assets/3940dbae-3c1c-4762-9ca2-ddab507b1055.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3940dbae-3c1c-4762-9ca2-ddab507b1055.png)'
- en: Building a cryptocurrency wallet
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建加密货币钱包
- en: Now that you have an understanding of other features of Qt for Python library,
    let's start to build a desktop cryptocurrency wallet. Since this is a complex
    application, we should not put everything in one file; instead, we will separate
    it into many files. We even separate the many files into different directories.
    We also want to keep this application basic enough for the purpose of a tutorial.
    Consequently, we will not put a lot of features in this application. This cryptocurrency
    wallet can create new accounts, send ethers to another account, and watch ERC20
    tokens so that we can later send some token coins to another account. However,
    it will not have complete features that you would expect from a proper cryptocurrency
    wallet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Qt for Python库的其他功能，让我们开始构建一个桌面加密货币钱包。由于这是一个复杂的应用程序，我们不应该将所有东西都放在一个文件中；相反，我们将其分成许多文件。我们甚至将许多文件分成不同的目录。我们还希望将此应用程序保持足够基本，以用于教程的目的。因此，我们不会在此应用程序中放置很多功能。这个加密货币钱包可以创建新账户，向另一个账户发送以太币，并监视ERC20代币，以便稍后将一些代币发送到另一个账户。但它不会具有您从正式加密货币钱包中期望的完整功能。
- en: 'First, let''s create a project directory and its inner directory using the
    following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令创建项目目录及其内部目录：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The main application, main library, and its configuration files are put in the
    main directory, which is the `wallet` directory. Some icons to spice up the UI
    of the application are put inside the `icons` directory. The avatar images are
    put inside the `images` directory. The test files are put inside the `tests` directory.
    The library files that are not related to blockchain and the UI are put inside
    the `tools` directory. The thread classes are put inside the `wallet_threads`
    directory. Finally, the child widgets of the main widget are put inside the `wallet_widgets`
    directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序、主库及其配置文件放在主目录`wallet`中。一些用于提升应用程序UI的图标放在`icons`目录中。头像图像放在`images`目录中。测试文件放在`tests`目录中。与区块链和UI无关的库文件放在`tools`目录中。线程类放在`wallet_threads`目录中。最后，主小部件的子小部件放在`wallet_widgets`目录中。
- en: Blockchain class
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区块链类
- en: Let's create a blockchain interface code in `wallet` and name the script `blockchain.py`.
    This file is responsible for connecting to the blockchain. Its responsibilities
    include checking the balance of the account, getting local accounts, sending transactions,
    and getting token information. By putting all blockchain functions inside one
    class or file, it is easier for us to debug the problem, to test the implementations,
    and to develop the functionalities. Go to [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet)
    and refer to the `blockchain.py` code file for this section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`wallet`中创建一个名为`blockchain.py`的区块链接口代码文件。这个文件负责连接到区块链。它的职责包括检查账户余额，获取本地账户，发送交易以及获取代币信息。通过将所有区块链功能放在一个类或文件中，我们更容易调试问题，测试实现，并开发功能。转到[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet)并参考本节的`blockchain.py`代码文件。
- en: This blockchain class has 10 methods to interact with the blockchain. In addition,
    it also has the generic `json` interface of the ERC20 token.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个区块链类有10个方法来与区块链交互。此外，它还具有ERC20代币的通用`json`接口。
- en: 'Let''s discuss this blockchain class file on a line-by-line basis:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行讨论这个区块链类文件：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After importing the required libraries, we create two named tuples. So, why
    do we want to create these named tuples? Basically, we do this to avoid errors.
    Having errors in a cryptocurrency wallet is expensive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所需的库之后，我们创建了两个命名元组。那么，为什么我们要创建这些命名元组呢？基本上，我们这样做是为了避免错误。在加密货币钱包中出现错误是很昂贵的。
- en: 'Imagine you have the following function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有以下函数：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You execute the function as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样执行这个函数：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you swap the sender and the destination, in the worst case scenario, you
    get an unhandled exception and the program stops because the private key does
    not match the sender. However, what if you swap the amount and the fee? In this
    case, you send the small amount to someone with a very high fee. There are many
    ways to avoid this mistake. For example, you could use a keyword argument, as
    given in the following code block, or you could use a named tuple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你交换了发送方和接收方，在最坏的情况下，你会得到一个未处理的异常，程序会停止，因为私钥与发送方不匹配。但是，如果你交换了金额和费用呢？在这种情况下，你会向某人发送少量的代币，但支付了非常高的费用。有许多方法可以避免这个错误。例如，你可以使用关键字参数，就像下面的代码块中所示，或者你可以使用命名元组：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s move on to the `json` interface of the ERC20 token smart contract.
    This is not required when we want to send ethers: it is only required when we
    want to send token coins:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论ERC20代币智能合约的`json`接口。当我们想发送以太币时，这是不需要的：只有当我们想发送代币时才需要。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you are aware, in order to interact with a smart contract, you need the
    `json` interface (`abi`) of the smart contract. You may be wondering how we get
    this `json` interface. This is achieved through the compilation output of the
    ERC20 token smart contract. It does not matter what the name, decimal number,
    and the symbol are. As long as the interface is from the smart contract that fulfills
    the ERC20 standard, we should get the correct interface. I decided to put the
    interface in the same file as the `Blockchain` class in order to simplify matters.
    However, you could put the interface in the `json` file, and then load the `json`
    file in the `Blockchain` class file. Then, we move on to the definition of the `Blockchain`
    class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，为了与智能合约交互，你需要智能合约的`json`接口（`abi`）。你可能想知道我们如何获得这个`json`接口。这是通过ERC20代币智能合约的编译输出实现的。不管名称、小数点数量和符号是什么，只要接口来自满足ERC20标准的智能合约，我们就应该得到正确的接口。我决定将接口放在与`Blockchain`类相同的文件中，以简化事情。但是，你可以将接口放在`json`文件中，然后在`Blockchain`类文件中加载`json`文件。然后，我们继续定义`Blockchain`类：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we start the `Blockchain` class. In its initialization method, we construct
    a `w3` variable to connect to blockchain. We hardcode the connection to blockchain
    with an IPC provider. You can change this configuration if you use `HTTPProvider`,
    for example, or use a different `IPC` file path. The `tokens_file` variable is
    the file that holds all the tokens that we watch.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始`Blockchain`类。在它的初始化方法中，我们构建一个`w3`变量来连接区块链。我们使用IPC提供程序硬编码连接到区块链。如果你使用`HTTPProvider`，或者使用不同的`IPC`文件路径，你可以更改这个配置。`tokens_file`变量是保存我们监视的所有代币的文件。
- en: 'Let''s take a look at the following lines of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下代码行：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We get all local accounts with `w3.eth.accounts`, and then we get the balance
    from each account using `w3.eth.getBalance`. The local accounts are the accounts
    you created in the local node. Usually, the files are kept in the `keystore` directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`w3.eth.accounts`获取所有本地账户，然后使用`w3.eth.getBalance`从每个账户获取余额。本地账户是你在本地节点创建的账户。通常，文件保存在`keystore`目录中。
- en: 'The following code is used to create a new account in the local blockchain
    node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于在本地区块链节点中创建一个新账户：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The account file will be encrypted with the password we supply. To see the private
    key, we need to decrypt the account file with the password. However, this is not
    necessary except for backup purposes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 账户文件将使用我们提供的密码进行加密。要查看私钥，我们需要用密码解密账户文件。但是，这除了备份目的外是不必要的。
- en: 'Use the following code to get the balance from an address:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码从一个地址获取余额：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The balance is in wei. Then, we convert the balance in wei to the balance in
    ethers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 余额以wei为单位。然后，我们将wei中的余额转换为以太币中的余额。
- en: 'The following code block is designed to obtain the balance of ERC20 tokens,
    but not the balance of ethers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块旨在获取ERC20代币的余额，而不是以太币的余额：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we get the contract's object that accepts two parameters – the address
    of the smart contract and the json interface. If you remember what you learned
    in `Chapter 8`, *Creating Token in Ethereum*, the ERC20 token needs to have a
    `balanceOf` method. The purpose of this method is to get the balance of the token
    from the account's address.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取接受两个参数的合同对象——智能合同的地址和json接口。如果您还记得在`第8章`中学到的内容，*在以太坊中创建代币*，ERC20代币需要有一个`balanceOf`方法。此方法的目的是从账户地址获取代币的余额。
- en: 'The following code block is used for creating a transaction of sending ethers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于创建发送以太币的交易：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, you get the `nonce`, and then you construct a transaction object. To
    send this transaction using a password, and not a private key, you need to use
    the `sendTransaction` method from the `w3.personal` object. Then, you wait until
    the transaction is confirmed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您获取`nonce`，然后构建一个交易对象。要使用密码而不是私钥发送此交易，您需要使用`w3.personal`对象的`sendTransaction`方法。然后，您等待交易得到确认。
- en: 'After learning about transactions involving the sending of ethers, let''s move
    on to the following code block, which is a method for creating a transaction whereby
    ERC20 tokens are sent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习涉及发送以太币的交易之后，让我们继续下一个代码块，这是用于创建发送ERC20代币的交易的方法：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, you get the `nonce`, and then construct a contract object. Then, you
    call the `transfer` method of this smart contract object. Remember that the ERC20
    token needs to have a `transfer` method to transfer token coins that accepts two
    parameters—the destination and the amount of token coins. Then, you execute this
    method by building a transaction from this method before passing it to the `sendTransaction`
    method from the `w3.personal` object. Finally, we wait for this transaction to
    be confirmed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您获取`nonce`，然后构建一个合同对象。然后，您调用此智能合同对象的`transfer`方法。请记住，ERC20代币需要有一个`transfer`方法来转移代币，该方法接受两个参数——目的地和代币数量。然后，通过从该方法构建交易来执行此方法，然后将其传递给`w3.personal`对象的`sendTransaction`方法。最后，我们等待此交易得到确认。
- en: 'The following code block is used to obtain the information from the token smart
    contract:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块用于从代币智能合同中获取信息：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we create a contract object. Then, to get the name, symbol and total
    supply, we access the `name`, `symbol`, and `totalSupply`methods from the smart
    contract. Because the name and symbol are byte objects, we need to decode it to
    string. We wrap this information in a tuple named `TokenInformation`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个合同对象。然后，为了获取名称、符号和总供应量，我们从智能合同中访问`name`、`symbol`和`totalSupply`方法。因为名称和符号是字节对象，我们需要将其解码为字符串。我们将这些信息封装在一个名为`TokenInformation`的元组中。
- en: 'The following code is a convenient way of wrapping a token information dictionary
    inside a named `tuple`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一种方便的方式，用于在命名的`tuple`中封装代币信息字典：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code is used to get all tokens that we''re watching from the
    configuration file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于从配置文件中获取我们正在观察的所有代币：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are many smart contracts for tokens out there, but we only want to use
    some of these. Consequently, we save the information pertaining to these token
    smart contracts into a `json` file. Then, we go to the last line of the file,
    which is constructing a `Blockchain` class instance:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多代币的智能合同，但我们只想使用其中的一些。因此，我们将与这些代币智能合同相关的信息保存到一个`json`文件中。然后，我们转到文件的最后一行，即构造一个`Blockchain`类实例：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We do this so that any file that imports this module would get the blockchain
    object straight away and two different files would get the same object. This is
    similar to a singleton pattern.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了让导入此模块的任何文件都可以立即获得区块链对象，并且两个不同的文件将获得相同的对象。这类似于单例模式。
- en: Thread classes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类
- en: Now, let's write thread objects in order to access the blockchain. When creating
    a transaction in a blockchain, you usually want to use a thread or non-blocking
    function. Consequently, every time we want to broadcast a transaction, we use
    these thread classes. These thread classes will use the blockchain object that
    we have described previously.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写线程对象，以便访问区块链。在区块链中创建交易时，通常希望使用线程或非阻塞函数。因此，每当我们想要广播一个交易时，我们使用这些线程类。这些线程类将使用我们之前描述的区块链对象。
- en: 'Use the following code block to create a `balance_thread.py` file in the `wallet_threads`
    directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码块在`wallet_threads`目录中创建一个`balance_thread.py`文件：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This thread class is not creating any transaction in the blockchain; its purpose
    is to read the balance of the ethers in every account. So, why do we need a thread
    to read the balance? Is reading the balance supposed to be fast? Imagine you launch
    your cryptocurrency wallet, and you see your balance is 10 ethers. Then, someone
    sends you some ethers. You want your balance to be reflected as soon as possible,
    right? That is the purpose of this thread; it will check the balance of every
    account every 2 seconds. The `kill` method is designed to shut down the application
    and stop the thread from working. It is not mandatory, but if you don't do this,
    you would get an annoying warning stating that the application is destroyed while
    the thread is still running when you close your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程类不会在区块链中创建任何交易；它的目的是读取每个账户中以太币的余额。那么，为什么我们需要一个线程来读取余额呢？读取余额应该是快速的吗？想象一下，当您启动您的加密货币钱包时，您看到您的余额是10个以太币。然后，有人给您发送了一些以太币。您希望您的余额尽快反映出来，对吧？这就是这个线程的目的；它将每2秒检查一次每个账户的余额。`kill`方法旨在关闭应用程序并停止线程的工作。这不是强制性的，但如果您不这样做，当您关闭应用程序时，您会收到一个令人讨厌的警告，指出应用程序在线程仍在运行时被销毁。
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_thread.py`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`wallet_threads`目录中创建另一个线程类，并将其命名为`send_thread.py`：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The purpose of this thread class is to call the `create_send_transaction` method
    of the blockchain object. Before we run the thread, we need to call the `prepareTransaction`
    method of this thread class with a `tuple` parameter named `SendTransaction`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_token_thread.py`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is similar to the `SendThread` class. The purpose of this thread is to
    call the `create_send_token_transaction` method, which accepts two parameters
    this time, one tuple named `SendTransaction`, and another tuple named `TokenInformation`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Identicon and Icons
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's understand what the identicon library is. The purpose of the identicon
    library is to generate a custom avatar image (such as fractal) based on the hash
    of a specific string. If you log in to StackOverflow and you don't set your profile
    image, your avatar would be generated by the identicon library.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot will appear like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d388efc-5fb7-4d16-b502-3090b716ac56.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Or it will appear like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4073f739-35ad-41cd-a492-07974e4ea5d4.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: This is optional. Our cryptocurrency wallet could run fine without these avatar
    images. This is just to spice up the UI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Download the file from [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py) into
    the `tools` directory. This is fine work on the part of Shin Adachi. I have modified
    it so that it works with Python 3\. You don't have to understand this file; treat
    it like a third-party library.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file inside the `tools` directory, using the following code
    block to utilize this library, and name it `util.py`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Basically, this method can render an avatar image using the account address.
    This serves to make an application a bit more attractive. Consequently,when you
    create an account, you get an avatar that is unique according to your address.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, download a number of icons in the `icons` folder. You need two of these:
    `ajax-loader.gif` and `copy.svg`. You can download `copy.svg` from the free icon
    website. Any icon showing a copying action should do just fine. Then, you can
    download `ajax-loader.gif` from [http://ajaxload.info/](http://ajaxload.info/).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Building widgets
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our main application using the following code block. This is
    the main entry for our cryptocurrency wallet. Name it `wallet.py`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`WalletWidget` is a tabbed window. There are three tabs:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The first tab is designed to hold an account widget. This widget is responsible
    for managing accounts (listing accounts and creating a new account).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second tab is designed to hold a widget that a user can use to create a
    transaction to send ethers or ERC20 tokens. Anything to do with sending ethers
    or tokens is done in this widget.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third tab is used to hold token widgets. This widget is responsible for
    watching ERC20 tokens. Watching ERC20 tokens means getting the information from
    the ERC20 custom token smart contract and making these tokens capable of being
    spent in the sending transaction widget.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three widgets will be defined in other files that will be discussed later.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The `killThreads` method is optional. If you don't use this method, you will
    get alerts after you close the application because the thread that the application
    created has not finished its business.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Account widget
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create the first widget in the first tab of this tabbed window. Put
    the file inside the `wallet_widgets` directory and name it `account_widget.py`.
    You will then get the full code file from the following link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, this widget will show up in the first tab of the wallet
    tabbed window. In this tab, you will acquire listing accounts and create new account
    functionalities.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to import many types of widgets and classes from `PySide2`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We also import the `blockchain` object and the `render_avatar` method, among
    other things. In addition, we will use the `balance_thread` instance, which is
    a thread to update our account's balance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block to create a button that allows us to create an
    account within the widget:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All of these accounts will be put in the `accounts_layout` vertical box layout.
    We get all local accounts from the blockchain object, and then we use the `addAccountToWindow`
    method to put this account in the accounts layout. After this, we put the button
    and `accounts_layout` in the main layout. Lastly, we connect the slot for the `BalanceThread`
    thread instance to the `_updateBalances` method and run the thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to launch the input dialog and request the password:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we call the `create_new_account` method of the `blockchain` object. The
    address of the new account will be sent to the `_addAccountToWindow` method, which
    will include the new account information in the vertical box layout.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the following code block to copy the address of the account to
    the clipboard:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, we get the clipboard object and copy the content to it. Consequently,
    in every piece of account information, there will a button that is connected to
    this method. First, however, we will show the information for this copying action
    in a tooltip. `Qcursor.pos()` is the our mouse's position. The `showText` method
    of `QtoolTip` is used to show the tooltip.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main widgets—the account''s address label, the button to copy
    the address of the account, the balance of this account''s label, and the avatar
    image. To display the avatar image, we can use a label. But instead of the `setText`
    method, we use the `setPixmap` method, as provided in the following code block:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`setPixmap` accepts the `Qpixmap` object. If `resize_parent` is true, then
    we will increase the height of the window. We access the main window, which is
    the tabbed window, with a method called `parentWidget` . This has to be chained
    and called twice, like `self.parentWidget().parentWidget()`. The first parent
    widget is the stack view. A tabbed widget is built using the stack view.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to call the `kill()` method of the `BalanceThread` instance:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will tell the thread to stop its task.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is used by the thread instance to update the balance:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`balance_widgets[account]` holds a balance label for a specific account.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Sending a transaction widget
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second widget is `SendWidget`. Create a file named `send_widget.py` inside
    the `wallet_widgets` directory. This widget is responsible for sending ethers
    or coins from the ERC20 token. For the full code in this section, go to the following
    GitLab link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This widget is the most complex in the tabbed window. In this widget, we need
    to select the account of the sender, and then, based on that account, we need
    to display the balance of ethers or coins relative to the ERC20 token for this
    account. Whether or not the balance is displayed in ethers or ERC20 tokens is
    decided based on whether Ethereum or the ERC20 token is selected in another part
    of this widget. We also need to add a line edit so people can fill in the destination
    address. In addition, we need a way to choose the fee because sometimes, people
    don't mind paying a higher fee so that their transaction is processed faster.
    Then, there is a button to launch an input dialog that requests the password so
    we can create a transaction.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'To import widgets and classes from the `PySide2` library, use the following
    code block:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We also imported other things as well, such as tools to render an avatar, methods
    to interact with the blockchain, and the thread classes that create transactions
    and retrieve information regarding tokens.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to initialize the `SendWidget` class:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`tokens_file` holds the `tokens.json` file. This configuration file is the
    file that contains all ERC20 tokens that we watch. `token_name` is set to `Ethereum`
    initially because, by default, our cryptocurrency wallet is supposed to handle
    Ethereum transactions, and not ERC20 tokens. In this widget, we can send ethers
    or custom tokens. Then, we call six methods to establish six inner layouts. This
    widget is composed of six layouts. The sender layout is used to choose the account
    of a sender. The destination layout is a field designed to hold the destination
    account of the transaction. The progress layout, which is hidden by default, is
    used to show that the transaction is still being confirmed after just sending
    the transaction. The token layout is used to choose whether you want to send ERC20
    token or ethers. In addition, the send layout is used to hold the send button,
    and the slider layout is used to hold the slider to choose the transaction fee.
    We also create two thread instances—the first is used to send ethers, while the
    second is used to send ERC20 tokens. For the main layout, we use the grid layout.
    This layout is used because it is easier to lay out our widgets.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method that can be used to set up the sender
    layout section for creating a transaction widget:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you have a combobox to choose the local account, an avatar image, and
    a balance label. If you change the value of the combobox, this would automatically
    change the text on the balance label and the avatar image.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set up the destination layout
    section:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This method mainly holds a line edit. You paste or type the destination's address
    in this line edit.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method for setting up the token layout section:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This section has an avatar for a token, the combobox to choose Ethereum or
    other ERC20 tokens, and the total supply of the ERC20 token. If we change the
    value of combobox, it will change the avatar and the total supply label. The avatar
    of the token is derived from the address of the token smart contract. However,
    Ethereum does not have the address, since it is the platform itself. So, for Ethereum,
    we use the following dummy address: `0xcccccccccccccccccccccccccccccccccccccccc`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set up the progress layout section:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Basically, this is a label used to show that the transaction is being confirmed.
    In this section, there is a label used to display the loading activity indicator.
    First, we initialize the `QMovie` object that accepts a `gif` file. Then, you
    set this `Qmovie` to a label by calling the `setMovie` method of that label.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method to set up the send layout section of the
    widget to create a transaction:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This section is used to hold a send button, which is connected to a callback.
    This send button is customized to make it appear more attractive by using background
    colors. The way you change the color for the button is simple:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to get the palette object from the button and then set
    the color to that palette object:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, we use predefined colors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to create a slider and a label indicating
    what value we choose in a slider:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The purpose of the slider is to choose the fee of the transaction. If you choose
    the bigger fee, the transaction will be processed faster.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to choose Ethereum or the ERC20 token:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is the callback that will be executed if we change the value of the token
    combobox. We update the balance of ethers or the token of the account here. After
    doing so, we change the avatar of the token. We also update the total supply of
    the token.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to choose the sender account:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is the callback that will be executed if we change the value of the sender
    combobox. Here, we update the balance of ethers or tokens of the account and then
    we change the avatar of the account based on the address.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set the balance of the account
    to the label:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this `updateBalanceLabel` method, we set the text for `balance_label` with
    the `get_balance` method from the `blockchain` object if we are working with Ethereum.
    If we are working with ERC20 tokens, we use the `get_token_balance` method from
    `blockchain`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set the avatar:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This method is used to set the avatar of both the token and the account.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the callback that will be executed when we change
    the value of the fee slider:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following code block is the method that will be executed when we click
    the Send button:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, we will be asked to provide the password in an input dialog. If we hit
    Ok, then we will set the progress label and loading activity indicator as visible.
    We construct a tuple named `SendTransaction` and then send it to the thread class
    objects that handle sending transactions either for Ethereum or ERC20 tokens.
    Finally, we run the thread.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to hide the progress label (loading indicator)
    when the transaction is finished:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This method will be called by the thread instance after finishing the job (either
    by sending ethers or coins as ERC20 tokens).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Token widget
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last widget is the token widget. This widget is responsible for watching
    the ERC20 token. Create `token_widget.py` inside the `wallet_widgets` directory.
    Go to the following GitLab link provided for the full code file in this section: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'This last widget is in the third tab of the main widget. The purpose here is
    to watch the ERC20 token and list all ERC20 tokens that have been watched. There
    is a button to launch an input dialog,a button to ask for the address of the ERC20
    smart contract token, and then there is a vertical layout that displays all ERC20
    tokens:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As usual, we import many things, such as rendering the avatar tool, the blockchain
    object to establish information regarding tokens from the blockchain, and a number
    of libraries to deal with filesystems. On top of that, we also import UI classes
    from `PySide2`, such as many types of widgets, and classes to attach the callback
    to widgets. Beside UI classes, we import non-UI classes from PySide2, such as
    `slot` and `signal`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block for the initialization method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this initialization method, we create a button that is linked to the `watchNewToken`
    method, and then a vertical box layout to hold all token information. We also
    declare the `tokens_file` object, which holds the `tokens.json` configuration
    file. This file keeps  track of all ERC20 token-related information.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block to create an avatar image, a token name label,
    a token symbol label, and a token total supply label for each piece of token information:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If `resize_parent` is true, this means we add token information through a dialog.
    In other words, we ask the parent window to increase its height. If `resize_parent`
    is `false`, this means that this method is called from the start.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method used to request the address of the smart
    contract with a dialog:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If a user confirms the address of the smart contract, we get the token information
    using the `get_information_of_token` method of the `blockchain` object. This token's
    information is then put in the vertical box layout. Later, we save the token's
    information in the json file. This is done so that we can load this token information
    when we restart the application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can launch your cryptocurrency wallet, make sure you run a private
    chain first and then deploy one or two ERC20 smart contracts in this private chain.
    You can use the ERC20 smart contract source code in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml),
    *Creating Token in Ethereum*. After doing this, run the desktop cryptocurrency
    wallet using the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You will get the final output shown in the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2647ef2-3ccf-4947-8e4f-1bdf78b2adf3.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we see the Account tab showing the balance of each
    account. Make sure you have at least two accounts. If not, create one from this
    tab by clicking the Create Account button.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Send tab, where we can send ethers to any
    account we choose:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce0eb96c-c4ee-46fb-98a9-6817b9e0e66c.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: 'In the second tab, try to send ethers. It will take some time before the transaction
    is confirmed. Consequently, try sending ERC20 tokens to another account (but you
    have to add the ERC20 token first in the third tab), as shown in the following
    screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da2cf602-c46f-4701-8b5d-edc36a383fbb.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in the third tab, try to watch a token smart contract. Put the address
    of the smart contract address in the dialog when you click the Watch Token button:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce1b1bdf-c3d1-4191-9c4d-e52b31190c6c.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Your token will be reflected in the second tab.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Test
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write tests for this GUI application. These tests should not be exhaustive.
    We will create three tests, one for each tab. We will not create a test for the
    non-UI part of the application. This section is simply here to demonstrate how
    to test a UI application.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test for the first tab is an account widget test. Name the test `test_account.py`
    and save it inside the `tests` directory. The following code block is the test
    script:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this test, we test how many children the accounts layout has before we click
    a button, launch a dialog, fill in a password, and then click OK. Then, we check
    the number of children again after we create a new account. The number should
    have increased by one. For this test, we patch the dialog to make it easier for
    testing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: This test is not comprehensive. We did not test the fail case. I will leave
    that as an exercise for the reader.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the second tab is a sending transaction widget test. Name the
    test file `test_send.py` and save it inside the `tests` directory. The test script
    is given in the following code block (refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py)):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this test, we check the balance of the second account in the combobox. This
    second account will be the destination account. Here, we read the balance from
    the label and then we change the value of the combobox back to the first account,
    which will be the sender. After that, we set the destination account's address
    to the destination line edit. We then set the amount of ethers in the amount line
    edit and click the Send button, but remember, we need to patch the input dialog.
    Finally, we wait around 20 seconds before changing the account combobox's value
    again to be the second account. We retrieve the balance from the label and then
    we compare the difference between the old value and the new value, which should
    be 10 ethers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the third tab is for testing a token widget. Name this `test_token.py`
    and save it inside the `tests` directory. The test script for this test is given
    in the following code block:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: First, we load the address of the token smart contract in the `address.txt`
    file because we don't want to hardcode it in the test file. The strategy is the
    same as in the test of the account widget. We check how many children the vertical
    box layout has. After that is done, we click the button, launch a dialog, fill
    in the address of the smart contract, and then click OK. Next, we check again
    how many children the vertical box layout has. The number should have increased
    by 1 again.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, this test is actually not complete. We should test the token information
    as well. However, this test is a good start.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the preceding tests by using the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Considerations when building a cryptocurrency wallet
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have now created a desktop cryptocurrency wallet. However, this wallet
    is not yet complete. A cryptocurrency wallet is a vast topic that changes so often
    that a book could be written on this topic alone. There are other features you
    can implement into a cryptocurrency wallet application, such as how many blocks
    have been confirmed for this transaction. In our application, we only wait for
    one transaction, but some users may want to confirm a couple of blocks first.
    If the transaction is confirmed with only one block, there is a slight chance
    that it could be replaced with a longer block. However, after 12 blocks, the transaction
    in the block is pretty much secure and irreversible, as explained in the following
    link: [https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum](https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Our cryptocurrency wallet is a pure cryptocurrency wallet. However, you could
    also add other features to our cryptocurrency wallet that are unrelated to the
    wallet functionality. For example, the Mist cryptocurrency wallet is not just
    a wallet; it is a decentralized application explorer as well. It can also compile
    a smart contract's source code and deploy it to the blockchain.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: There are many features that you should implement if you want to make a fully-fledged
    cryptocurrency wallet. A number of ideas include generating a QR code, an option
    to export an encrypted private key, importing a private key, using a seed phrase
    to generate accounts, the validation of input, and remembering a password for
    a short period of time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are building a desktop cryptocurrency wallet. A desktop application
    can have the luxury of a lot of memory and storage. However, if you are building
    a mobile cryptocurrency wallet, this is a different story. For example, a Bitcoin
    desktop cryptocurrency wallet can access the full node locally. However, you cannot
    put a full Bitcoin node on a mobile phone as it is just too big. You could, of
    course, put the full Bitcoin node on the cloud and let the mobile cryptocurrency
    wallet application access that. However, most people don't want to set up a full
    node on the cloud. As a result, any developer of a Bitcoin mobile cryptocurrency
    wallet usually uses **Simplified Payment Verification** (**SPV**). In this way,
    the Bitcoin mobile cryptocurrency wallet does not require a full Bitcoin node
    to be stored on the phone.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build a cryptocurrency wallet or contribute to existing cryptocurrency
    wallets, you need to bear two things in mind: security and the **user experience**
    (**UX**).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cryptocurrency wallet handles money, so you need to make it secure. Security
    is a complex topic that we will discuss briefly here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Don't install a third-party library just because you can; every library is another
    vector attack. Be conservative in bundling third-party libraries in your application.
    Our cryptocurrency wallet uses libraries from Ethereum GitHub, such as web3.py
    and Populus. That should be fine because they are core libraries. We also use
    the `PySide2` library from the Qt company. This library is a must because without
    a GUI library, there cannot be a GUI application. We also use a third-party library
    to generate an identicon avatar image. We need to be careful here. The library
    is a single file, and I have read it fully to ensure there is no hidden malware.
    Because of that, I can integrate it confidently into our application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Use a minimum number of confirmations before declaring that the transaction
    is complete. How many confirmations is good enough depends on your threat and
    risk modelling. Usually, 12 confirmations make the reversing transaction impractical.
    The Mist wallet uses 12 confirmations, while the ZCash wallet uses 10 confirmations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You could also force the user to create a good password when creating an account
    in a cryptocurrency wallet, because most users have a tendency to create an account
    with a bad password. But be careful here; you don't want to annoy them too much.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: User experience
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an application is very secure but very hard to use, it is of no use. As a
    consequence, we need to make it less intimidating for users. The creator of Bitcoin,
    Satoshi Nakamoto, put a lot of thought into user experience when building the
    software. Previously, people used base64 format to convert binary to text. However,
    Satoshi used base58 to represent the Bitcoin address. Base58 is like base64, but
    without characters that cause confusion when it gets printed, such as I (capital
    i) and l (lower L).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Zcash has released a UX guide for designing a cryptocurrency wallet, and this
    can be found at the following link: [https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html](https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html).
    Not everything can be implemented here because Zcash has a private transaction
    that Ethereum does not have. However, other suggestions can be implemented; for
    example, market information. Like it or not, people peg the cryptocurrency price
    to fiat money and it is a good idea to show people what the market price of 1
    ether is. If the network is congested, you should inform the user as well. You
    can suggest that the user waits or increases the transaction fee.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: If you build an iOS cryptocurrency wallet, you should follow the Apple Human
    Interface Guideline. If you are building an Android cryptocurrency wallet, you
    should follow the Material Design guidelines. Be careful when choosing typography
    and the color to be used. You should do the user interview when designing a cryptocurrency
    wallet. UX is a broad subject. Balancing UX and security is a delicate art. You
    should not ignore UX when building a cryptocurrency wallet.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have familiarized ourselves with the tabbed view, size
    policy, and the grid layout of `PySide2`. Then, we also learned how to test Qt
    applications. Next, we started to build a desktop cryptocurrency wallet. We divided
    the application into many parts: the blockchain, the thread, the widget, the identicon
    tool, and the test. The blockchain part of the cryptocurrency wallet is based
    on the `web3` and `Populus` libraries and its purpose is to read and create transactions
    in the blockchain. The thread is a middleman between the UI part and the blockchain
    object when creating a transaction. The identicon tool is used to create an avatar
    image based on a specific string (usually the address of the account or the token
    smart contract''s address). The widget part is a tabbed widget that has three
    tabs. The first tab is the account widget, the second tab is the sending transaction
    widget, and the third tab is the token widget. Lastly, we created tests for this
    application.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start learning a topic beyond the scope of blockchain
    technology. This technology is called IPFS. It is still part of the decentralized
    technology, but this technology will overcome the weakness associated with the
    blockchain technology; in other words, its storage is expensive.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
