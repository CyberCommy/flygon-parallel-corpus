- en: Cryptocurrency Wallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn how to build a desktop cryptocurrency
    wallet. You will still use the same GUI library, Qt for Python or PySide2 to create
    a desktop application. This cryptocurrency wallet can send ethers as well as ERC20
    tokens. Before building this cryptocurrency wallet, you will learn advanced features
    of the PySide2 library, such as tabs, comboboxes, size policy, and adding stretch
    to control the distribution of widgets in a layout. On top of that, you will integrate
    testing into applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of the PySide2 library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pytest Qt, a library to test a Qt for a Python application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a cryptocurrency wallet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some considerations when building a cryptocurrency wallet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced features of the PySide2 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the reader to have some knowledge of the PySide2 library.
    You should read [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend
    Decentralized Application*,first if you have not done so, as this chapter is based
    on that one. If you have familiarized yourself with building a GUI with `PySide2`,
    you are equipped with the necessary skills to build a desktop cryptocurrency wallet,
    at least from the **User Interface** (**UI**) persepective. However, the application
    that you build will be jarring to users. For example, if you incorporated a button
    in a horizontal layout and that button is the only widget in the horizontal layout,
    when you resize the window that has the horizontal layout, the button will be
    stretched to the right and left. If this is not what you want to happen, you need
    a way to tell the button to keep its width.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's learn other features from the `PySide2` library, such as tab, size
    policy, and grid layout, so that we have the skills to make the UI of our application
    more attractive. Our application will not win the *Apple Best Design Award*, but
    at least it will be less jarring for users.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, in [Chapter 7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized
    Application*, we neglected testing. Since a cryptocurrency wallet application
    is an application that handles people's money, errors are costly. Consequently,
    we need to catch any errors before users do. We should therefore write proper
    testing for our cryptocurrency wallet. However, we will focus on testing for the
    UI part of the cryptocurrency wallet. We will not focus on testing inner methods.
    In other words, our testing will be integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Qt` library if you haven''t already done so. Please read [Chapter
    7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized Application*,
    for guidance on how to do this. After doing so, create a virtual environment for
    your project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to install a test library to test our application, which can be
    done by means of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that all the libraries have been set up, let's write a simple application
    so we can test it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a directory named `advanced_course_qt`. We can put all of our tutorial
    files here. Name the first script `button_and_label.py` and use the following
    code to create a button and a label for that button (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_label.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code to see what this application is about. The application
    consists of a button and a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62549502-1017-428a-ac5f-b1ed6284849b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click the button, the text on the label will change, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62e8a851-c9d0-42e7-ad12-ac727a7ccba6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So let''s test this application. Name the test `test_button_and_label.py` and
    put it in the same directory. Use the following code block for the test application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that the `(wallet-venv) $ python test_button_and_label.py`command is
    a negligible error often used to run the test. Don't fall for it!
  prefs: []
  type: TYPE_NORMAL
- en: In this test script, we import our `widget` class. Then, we create a test method
    that has a name starting with `test_`. This method has a parameter named `qtbot`.
    Don't change its name. `qtbot` is a special name and must not be changed. Inside
    this method, `qtbot` can be used to interact with the `widget` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we instantiate a `widget` class that we want to test. Then, we
    add that `widget` instance using the `addWidget` method from `qtbot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we test the `text` on the `label` variable before clicking the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can access `label` from `widget`. This is made possible
    because we declared the `label` variable in `button_and_label.py` using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you declare the label in `button_and_label.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you would not be able to access `label` from the instance of `widget`
    in the test. Of course, you could circumvent that situation by creating a variable
    to hold the text of the label. However, making the `label` a `widget` instance
    property is the easiest thing to do in order to test the text of the label. You
    will use this strategy in all further tests. In a nutshell, if you want to test
    widgets (such as a label, button, or combobox), make that `widget` a property
    of its parent widget instance. Then, we move on to how we click the button widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To click a button during testing, you use the `mouseClick` method from `qtbot`.
    The first parameter of the `mouseClick` method of `qtbot` is a button widget,
    or something that accepts a clicking event. The second parameter is an option
    to detect the nature of the mouse click event. The test in this case will only accept a
    left button click.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is to test and display the text of a label after clicking
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In building a GUI application, on occasion, we have to display a list of objects.
    In our cryptocurrency wallet, the list could hold accounts. So let''s write a
    test for that scenario. First, however, we have to create a script to display
    a list of objects. Name the script `button_and_list.py` and use the following
    code block for the script (refer to the code file on the following GitLab link
    for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_list.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to see how the application appears. The following shows the
    screenshot of the button prior to clicking it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e116c5e4-dd24-4718-ab6a-9c882d979332.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following shows the result of clicking the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7ee4e5c2-944b-4949-95ed-39eb0e8c382f.png)'
  prefs: []
  type: TYPE_IMG
- en: You have a single button here and if you click it, a new label should appear
    with text that simply reads `1`. If you click the button for a second time, a
    new label will appear at the bottom with text that reads `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The new label that shows up after we click the button is part of the vertical
    box layout. This means that we need to make that vertical box layout the widget
    instance's property so that we can access it in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a test for this GUI script, as shown in the following code block,
    and name it `test_button_and_list.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code block, after the third execution of the `mouseClick`
    method of `qtbot`, we grab the label from the vertical box layout using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the child widget of a widget by means of the `takeAt` method. The parameter
    that we use in this case is `2`. This means that we want to grab the third child,
    the last one. Then, we test the text of the widget using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a more complicated scenario. Hitherto, everything we have tested
    has been inside one window, but what if we have an input dialog? How do we test
    a dialog?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a GUI script that has a dialog and name it `button_and_dialog.py`:
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_and_dialog.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code to view the application. There is a button and empty space beneath
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e948dc67-2901-4f81-9c2a-241f051f0a48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click button and a dialog will appear, after which you should type any text
    in the input dialog and click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d3d1205-4bdd-461c-8afa-20e9baa69f60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The text you have inputted will appear beneath the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b54a19c-249e-4153-816d-e2e68a29d8b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at another test script in the following code block in order
    to understand how to handle the flow involving two different windows. In this
    test method, we have another parameter besides `qtbot`, called `monkeypatch`. Name
    the test file `test_button_and_dialog.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`monkeypatch` is used to override a dialog input. This means that the `getText`
    method of `QInputDialog` would return a `("New Text", True)` tuple when we launch
    the dialog in the test. Remember the API of `QInputDialog`? This returns a tuple.
    This tuple contains two parameters—the text that we type in the dialog, and whether
    we click the OK or Cancel buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getText` method of `QInputDialog` accepts four parameters: the window
    instance that this dialog is based upon, the title, the label before the input
    field, and the type of input field. When you type text, such as `To the moon!`
    in the input field, and clicked the **OK** button, it returns a tuple consisting
    of the string `To the moon!` and the `boolean` value of whether you click the OK button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `monkeypatch` patches this method so in the testing, no dialog would
    be launched. We bypass them. It''s as if the launching dialog line is replaced
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For all of these tests, we always use a button-type widget to initiate something
    (changing the text on the label). Let''s use another type of widget to change
    the label, as given in the following code block, and name the script `combobox_and_label.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This GUI script uses combobox to change the text on the label. It sets the
    text on the label with the text from the selected option of the label. Run the
    script to see how it appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb21233e-8a94-4283-8442-15ac65678c0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a test script to test this combobox widget and name it `test_combobox_and_label.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The key point that we can take here is the way we change the selected option
    of `combobox` with `qtbot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The method's name is not intuitive; it accepts two parameters. The first one
    is the widget, or the combobox in this case. The second one is the option text
    in the combobox. This `keyClicks` method is not just for selecting an option in
    combobox. It could also be used to type text in the line edit. Just put the line
    edit widget in the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This test knowledge is sufficient for testing our cryptocurrency wallet. Before
    we jump into building our cryptocurrency wallet, let's learn about some other
    features of `PySide2`, including grid layout, tab, and size policy.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of Qt for Python or PySide2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we want to learn about here is stretching. We know how
    to add widgets to a box layout (vertical or horizontal). However, we can configure
    to some extent how to distribute these widgets that we added into a box layout.
    Should we stretch the widgets, put the widgets on top for the horizontal layout,
    and let the space devour the rest?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to explain this configuration of widget distribution
    in a box layout and name the script `add_stretch.py` (refer to the code file on
    the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/add_stretch.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2001b1a9-b988-4014-a04d-6489c683e960.png)'
  prefs: []
  type: TYPE_IMG
- en: If you add stretching to the end of the vertical container, it would push the
    widgets to the beginning of the vertical container and let the rest be an empty
    space. If you add stretching in the beginning, it would push the widgets to the
    end of the vertical container and let the rest be an empty space. If you don't
    add any stretching, the widgets would be distributed equally across the layout.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the functionality of the application, it does not make any difference.
    However, it can make the UI more attractive if you choose the right options.
  prefs: []
  type: TYPE_NORMAL
- en: We always use the box layout (vertical box layout or horizontal box layout).
    The box layout suffices in most cases. Occasionally, however, you want to use
    a more complicated layout. Qt has a grid layout that is more powerful than the
    box layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a script to explore the power of the grid layout and name the
    script `create_grid_window.py` (refer to the code file on the following GitLab
    link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/create_grid_window.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to see how the grid layout manages its child window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2c8e907-efc1-463d-9333-8d8b1ddd2cd4.png)'
  prefs: []
  type: TYPE_IMG
- en: A grid is like a table or spreadsheet. Instead of adding a widget to a row with
    a horizontal layout, or a column with a vertical layout, you add a widget to a
    table that is composed of rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add the widget to the first row and the first column, use the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter indicates a row. The second parameter indicates a column.
    So if you want to add the widget to the second row and the first column, use the
    following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addWidget` method of the grid layout accepts optional third and fourth
    parameters. The third parameter indicates how many rows you want this widget to
    extend to. The fourth parameter indicates how many columns you want this widget
    to extend to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you stretch the window, you will see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/19cdf235-f769-4620-9caf-ac701ea923fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at Label G. This stretches up to two rows and two columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about what happens to the widget if we increase the size of
    the parent window that contains the widget. Should the widget resize along with
    it? Should the widget stay still, and allow the margin to become wider? You can
    decide on the resizing configuration with the size policy. Let''s create a script
    named `button_with_sizepolicy.py` to demonstrate size configuring this policy
    (refer to the code file on the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/advanced_course_qt/button_with_sizepolicy.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script to see how each button appears differently with a different
    size policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec08a954-b1aa-4eba-b33f-2d6c07bac46b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, try to resize the window to make sense of the size policy configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e0ef275-b462-4e6f-8b73-82e0d853e917.png)'
  prefs: []
  type: TYPE_IMG
- en: '`QSizePolicy.Maximum` indicates that the widget cannot be bigger than the size
    hint, or the content of the button in this case. If you want your button to stick
    to its original size, use this size policy. `QSizePolicy.Preferred` indicates
    that it prefers a size hint but it can be larger or smaller. `QSizePolicy.Expanding`
    indicates that the widget should expand as much as possible. `QSizePolicy.Minimum`
    indicates that the widget can be expanded, but it cannot be smaller than the size
    hint. `QSizePolicy.MinimumExpanding` indicates that the widget cannot be smaller
    than the size hint, but it expands as much as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: In creating a GUI application, most of the time you would not put all of your
    functionalities/widgets in a single window. Otherwise, the window would be bigger
    than the screen resolution of the monitor.
  prefs: []
  type: TYPE_NORMAL
- en: You could launch a dialog with a button to hold more functionalities/widgets.
    That certainly works. But what you really want is something like a controller.
    In Qt, you have **StackView**. StackView can contain many windows, but it displays
    a maximum of one window at one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wouldn''t use StackView directly. Instead, we use tabbed view. Tabbed view
    uses StackView behind the scenes. Let''s create a script to use tabbed view and
    name it `tabbed_window.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This tabbed window has three tabs. Each tab holds a widget. The second tab even
    holds a widget that we created in a separate script, `button_and_label.py`. This
    widget, which is in the second tab, has a button and a label. To add a tab to
    a tabbed window, you use the `addTab` method. The first parameter is the widget,
    and the second parameter is the title of the tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script to see how tabbed view works. In the following screenshot, we
    see Tab 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4710d0e-3940-4c79-8d3a-4822a3b367eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following screenshot, we see Tab 2 and the widget from `button_and_label.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3940dbae-3c1c-4762-9ca2-ddab507b1055.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a cryptocurrency wallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an understanding of other features of Qt for Python library,
    let's start to build a desktop cryptocurrency wallet. Since this is a complex
    application, we should not put everything in one file; instead, we will separate
    it into many files. We even separate the many files into different directories.
    We also want to keep this application basic enough for the purpose of a tutorial.
    Consequently, we will not put a lot of features in this application. This cryptocurrency
    wallet can create new accounts, send ethers to another account, and watch ERC20
    tokens so that we can later send some token coins to another account. However,
    it will not have complete features that you would expect from a proper cryptocurrency
    wallet.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a project directory and its inner directory using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The main application, main library, and its configuration files are put in the
    main directory, which is the `wallet` directory. Some icons to spice up the UI
    of the application are put inside the `icons` directory. The avatar images are
    put inside the `images` directory. The test files are put inside the `tests` directory.
    The library files that are not related to blockchain and the UI are put inside
    the `tools` directory. The thread classes are put inside the `wallet_threads`
    directory. Finally, the child widgets of the main widget are put inside the `wallet_widgets`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Blockchain class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a blockchain interface code in `wallet` and name the script `blockchain.py`.
    This file is responsible for connecting to the blockchain. Its responsibilities
    include checking the balance of the account, getting local accounts, sending transactions,
    and getting token information. By putting all blockchain functions inside one
    class or file, it is easier for us to debug the problem, to test the implementations,
    and to develop the functionalities. Go to [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet)
    and refer to the `blockchain.py` code file for this section.
  prefs: []
  type: TYPE_NORMAL
- en: This blockchain class has 10 methods to interact with the blockchain. In addition,
    it also has the generic `json` interface of the ERC20 token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss this blockchain class file on a line-by-line basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: After importing the required libraries, we create two named tuples. So, why
    do we want to create these named tuples? Basically, we do this to avoid errors.
    Having errors in a cryptocurrency wallet is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You execute the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you swap the sender and the destination, in the worst case scenario, you
    get an unhandled exception and the program stops because the private key does
    not match the sender. However, what if you swap the amount and the fee? In this
    case, you send the small amount to someone with a very high fee. There are many
    ways to avoid this mistake. For example, you could use a keyword argument, as
    given in the following code block, or you could use a named tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to the `json` interface of the ERC20 token smart contract.
    This is not required when we want to send ethers: it is only required when we
    want to send token coins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you are aware, in order to interact with a smart contract, you need the
    `json` interface (`abi`) of the smart contract. You may be wondering how we get
    this `json` interface. This is achieved through the compilation output of the
    ERC20 token smart contract. It does not matter what the name, decimal number,
    and the symbol are. As long as the interface is from the smart contract that fulfills
    the ERC20 standard, we should get the correct interface. I decided to put the
    interface in the same file as the `Blockchain` class in order to simplify matters.
    However, you could put the interface in the `json` file, and then load the `json`
    file in the `Blockchain` class file. Then, we move on to the definition of the `Blockchain`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start the `Blockchain` class. In its initialization method, we construct
    a `w3` variable to connect to blockchain. We hardcode the connection to blockchain
    with an IPC provider. You can change this configuration if you use `HTTPProvider`,
    for example, or use a different `IPC` file path. The `tokens_file` variable is
    the file that holds all the tokens that we watch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We get all local accounts with `w3.eth.accounts`, and then we get the balance
    from each account using `w3.eth.getBalance`. The local accounts are the accounts
    you created in the local node. Usually, the files are kept in the `keystore` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to create a new account in the local blockchain
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The account file will be encrypted with the password we supply. To see the private
    key, we need to decrypt the account file with the password. However, this is not
    necessary except for backup purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to get the balance from an address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The balance is in wei. Then, we convert the balance in wei to the balance in
    ethers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is designed to obtain the balance of ERC20 tokens,
    but not the balance of ethers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the contract's object that accepts two parameters – the address
    of the smart contract and the json interface. If you remember what you learned
    in `Chapter 8`, *Creating Token in Ethereum*, the ERC20 token needs to have a
    `balanceOf` method. The purpose of this method is to get the balance of the token
    from the account's address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used for creating a transaction of sending ethers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, you get the `nonce`, and then you construct a transaction object. To
    send this transaction using a password, and not a private key, you need to use
    the `sendTransaction` method from the `w3.personal` object. Then, you wait until
    the transaction is confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'After learning about transactions involving the sending of ethers, let''s move
    on to the following code block, which is a method for creating a transaction whereby
    ERC20 tokens are sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, you get the `nonce`, and then construct a contract object. Then, you
    call the `transfer` method of this smart contract object. Remember that the ERC20
    token needs to have a `transfer` method to transfer token coins that accepts two
    parameters—the destination and the amount of token coins. Then, you execute this
    method by building a transaction from this method before passing it to the `sendTransaction`
    method from the `w3.personal` object. Finally, we wait for this transaction to
    be confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to obtain the information from the token smart
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a contract object. Then, to get the name, symbol and total
    supply, we access the `name`, `symbol`, and `totalSupply`methods from the smart
    contract. Because the name and symbol are byte objects, we need to decode it to
    string. We wrap this information in a tuple named `TokenInformation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a convenient way of wrapping a token information dictionary
    inside a named `tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used to get all tokens that we''re watching from the
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many smart contracts for tokens out there, but we only want to use
    some of these. Consequently, we save the information pertaining to these token
    smart contracts into a `json` file. Then, we go to the last line of the file,
    which is constructing a `Blockchain` class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We do this so that any file that imports this module would get the blockchain
    object straight away and two different files would get the same object. This is
    similar to a singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Thread classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write thread objects in order to access the blockchain. When creating
    a transaction in a blockchain, you usually want to use a thread or non-blocking
    function. Consequently, every time we want to broadcast a transaction, we use
    these thread classes. These thread classes will use the blockchain object that
    we have described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block to create a `balance_thread.py` file in the `wallet_threads`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This thread class is not creating any transaction in the blockchain; its purpose
    is to read the balance of the ethers in every account. So, why do we need a thread
    to read the balance? Is reading the balance supposed to be fast? Imagine you launch
    your cryptocurrency wallet, and you see your balance is 10 ethers. Then, someone
    sends you some ethers. You want your balance to be reflected as soon as possible,
    right? That is the purpose of this thread; it will check the balance of every
    account every 2 seconds. The `kill` method is designed to shut down the application
    and stop the thread from working. It is not mandatory, but if you don't do this,
    you would get an annoying warning stating that the application is destroyed while
    the thread is still running when you close your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_thread.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this thread class is to call the `create_send_transaction` method
    of the blockchain object. Before we run the thread, we need to call the `prepareTransaction`
    method of this thread class with a `tuple` parameter named `SendTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create another thread class inside the `wallet_threads` directory
    and name it `send_token_thread.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the `SendThread` class. The purpose of this thread is to
    call the `create_send_token_transaction` method, which accepts two parameters
    this time, one tuple named `SendTransaction`, and another tuple named `TokenInformation`.
  prefs: []
  type: TYPE_NORMAL
- en: Identicon and Icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's understand what the identicon library is. The purpose of the identicon
    library is to generate a custom avatar image (such as fractal) based on the hash
    of a specific string. If you log in to StackOverflow and you don't set your profile
    image, your avatar would be generated by the identicon library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot will appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d388efc-5fb7-4d16-b502-3090b716ac56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Or it will appear like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4073f739-35ad-41cd-a492-07974e4ea5d4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is optional. Our cryptocurrency wallet could run fine without these avatar
    images. This is just to spice up the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Download the file from [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tools/identicon.py) into
    the `tools` directory. This is fine work on the part of Shin Adachi. I have modified
    it so that it works with Python 3\. You don't have to understand this file; treat
    it like a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a file inside the `tools` directory, using the following code
    block to utilize this library, and name it `util.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this method can render an avatar image using the account address.
    This serves to make an application a bit more attractive. Consequently,when you
    create an account, you get an avatar that is unique according to your address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, download a number of icons in the `icons` folder. You need two of these:
    `ajax-loader.gif` and `copy.svg`. You can download `copy.svg` from the free icon
    website. Any icon showing a copying action should do just fine. Then, you can
    download `ajax-loader.gif` from [http://ajaxload.info/](http://ajaxload.info/).'
  prefs: []
  type: TYPE_NORMAL
- en: Building widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create our main application using the following code block. This is
    the main entry for our cryptocurrency wallet. Name it `wallet.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`WalletWidget` is a tabbed window. There are three tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: The first tab is designed to hold an account widget. This widget is responsible
    for managing accounts (listing accounts and creating a new account).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second tab is designed to hold a widget that a user can use to create a
    transaction to send ethers or ERC20 tokens. Anything to do with sending ethers
    or tokens is done in this widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third tab is used to hold token widgets. This widget is responsible for
    watching ERC20 tokens. Watching ERC20 tokens means getting the information from
    the ERC20 custom token smart contract and making these tokens capable of being
    spent in the sending transaction widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three widgets will be defined in other files that will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: The `killThreads` method is optional. If you don't use this method, you will
    get alerts after you close the application because the thread that the application
    created has not finished its business.
  prefs: []
  type: TYPE_NORMAL
- en: Account widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create the first widget in the first tab of this tabbed window. Put
    the file inside the `wallet_widgets` directory and name it `account_widget.py`.
    You will then get the full code file from the following link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, this widget will show up in the first tab of the wallet
    tabbed window. In this tab, you will acquire listing accounts and create new account
    functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to import many types of widgets and classes from `PySide2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We also import the `blockchain` object and the `render_avatar` method, among
    other things. In addition, we will use the `balance_thread` instance, which is
    a thread to update our account's balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block to create a button that allows us to create an
    account within the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: All of these accounts will be put in the `accounts_layout` vertical box layout.
    We get all local accounts from the blockchain object, and then we use the `addAccountToWindow`
    method to put this account in the accounts layout. After this, we put the button
    and `accounts_layout` in the main layout. Lastly, we connect the slot for the `BalanceThread`
    thread instance to the `_updateBalances` method and run the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to launch the input dialog and request the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the `create_new_account` method of the `blockchain` object. The
    address of the new account will be sent to the `_addAccountToWindow` method, which
    will include the new account information in the vertical box layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the following code block to copy the address of the account to
    the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the clipboard object and copy the content to it. Consequently,
    in every piece of account information, there will a button that is connected to
    this method. First, however, we will show the information for this copying action
    in a tooltip. `Qcursor.pos()` is the our mouse's position. The `showText` method
    of `QtoolTip` is used to show the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main widgets—the account''s address label, the button to copy
    the address of the account, the balance of this account''s label, and the avatar
    image. To display the avatar image, we can use a label. But instead of the `setText`
    method, we use the `setPixmap` method, as provided in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`setPixmap` accepts the `Qpixmap` object. If `resize_parent` is true, then
    we will increase the height of the window. We access the main window, which is
    the tabbed window, with a method called `parentWidget` . This has to be chained
    and called twice, like `self.parentWidget().parentWidget()`. The first parent
    widget is the stack view. A tabbed widget is built using the stack view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to call the `kill()` method of the `BalanceThread` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will tell the thread to stop its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method is used by the thread instance to update the balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`balance_widgets[account]` holds a balance label for a specific account.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending a transaction widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second widget is `SendWidget`. Create a file named `send_widget.py` inside
    the `wallet_widgets` directory. This widget is responsible for sending ethers
    or coins from the ERC20 token. For the full code in this section, go to the following
    GitLab link: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  prefs: []
  type: TYPE_NORMAL
- en: This widget is the most complex in the tabbed window. In this widget, we need
    to select the account of the sender, and then, based on that account, we need
    to display the balance of ethers or coins relative to the ERC20 token for this
    account. Whether or not the balance is displayed in ethers or ERC20 tokens is
    decided based on whether Ethereum or the ERC20 token is selected in another part
    of this widget. We also need to add a line edit so people can fill in the destination
    address. In addition, we need a way to choose the fee because sometimes, people
    don't mind paying a higher fee so that their transaction is processed faster.
    Then, there is a button to launch an input dialog that requests the password so
    we can create a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import widgets and classes from the `PySide2` library, use the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We also imported other things as well, such as tools to render an avatar, methods
    to interact with the blockchain, and the thread classes that create transactions
    and retrieve information regarding tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to initialize the `SendWidget` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`tokens_file` holds the `tokens.json` file. This configuration file is the
    file that contains all ERC20 tokens that we watch. `token_name` is set to `Ethereum`
    initially because, by default, our cryptocurrency wallet is supposed to handle
    Ethereum transactions, and not ERC20 tokens. In this widget, we can send ethers
    or custom tokens. Then, we call six methods to establish six inner layouts. This
    widget is composed of six layouts. The sender layout is used to choose the account
    of a sender. The destination layout is a field designed to hold the destination
    account of the transaction. The progress layout, which is hidden by default, is
    used to show that the transaction is still being confirmed after just sending
    the transaction. The token layout is used to choose whether you want to send ERC20
    token or ethers. In addition, the send layout is used to hold the send button,
    and the slider layout is used to hold the slider to choose the transaction fee.
    We also create two thread instances—the first is used to send ethers, while the
    second is used to send ERC20 tokens. For the main layout, we use the grid layout.
    This layout is used because it is easier to lay out our widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method that can be used to set up the sender
    layout section for creating a transaction widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have a combobox to choose the local account, an avatar image, and
    a balance label. If you change the value of the combobox, this would automatically
    change the text on the balance label and the avatar image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set up the destination layout
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This method mainly holds a line edit. You paste or type the destination's address
    in this line edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method for setting up the token layout section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This section has an avatar for a token, the combobox to choose Ethereum or
    other ERC20 tokens, and the total supply of the ERC20 token. If we change the
    value of combobox, it will change the avatar and the total supply label. The avatar
    of the token is derived from the address of the token smart contract. However,
    Ethereum does not have the address, since it is the platform itself. So, for Ethereum,
    we use the following dummy address: `0xcccccccccccccccccccccccccccccccccccccccc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set up the progress layout section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Basically, this is a label used to show that the transaction is being confirmed.
    In this section, there is a label used to display the loading activity indicator.
    First, we initialize the `QMovie` object that accepts a `gif` file. Then, you
    set this `Qmovie` to a label by calling the `setMovie` method of that label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method to set up the send layout section of the
    widget to create a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This section is used to hold a send button, which is connected to a callback.
    This send button is customized to make it appear more attractive by using background
    colors. The way you change the color for the button is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to get the palette object from the button and then set
    the color to that palette object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use predefined colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to create a slider and a label indicating
    what value we choose in a slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the slider is to choose the fee of the transaction. If you choose
    the bigger fee, the transaction will be processed faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to choose Ethereum or the ERC20 token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is the callback that will be executed if we change the value of the token
    combobox. We update the balance of ethers or the token of the account here. After
    doing so, we change the avatar of the token. We also update the total supply of
    the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to choose the sender account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This is the callback that will be executed if we change the value of the sender
    combobox. Here, we update the balance of ethers or tokens of the account and then
    we change the avatar of the account based on the address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set the balance of the account
    to the label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this `updateBalanceLabel` method, we set the text for `balance_label` with
    the `get_balance` method from the `blockchain` object if we are working with Ethereum.
    If we are working with ERC20 tokens, we use the `get_token_balance` method from
    `blockchain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the method used to set the avatar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This method is used to set the avatar of both the token and the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is the callback that will be executed when we change
    the value of the fee slider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code block is the method that will be executed when we click
    the Send button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here, we will be asked to provide the password in an input dialog. If we hit
    Ok, then we will set the progress label and loading activity indicator as visible.
    We construct a tuple named `SendTransaction` and then send it to the thread class
    objects that handle sending transactions either for Ethereum or ERC20 tokens.
    Finally, we run the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is used to hide the progress label (loading indicator)
    when the transaction is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called by the thread instance after finishing the job (either
    by sending ethers or coins as ERC20 tokens).
  prefs: []
  type: TYPE_NORMAL
- en: Token widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last widget is the token widget. This widget is responsible for watching
    the ERC20 token. Create `token_widget.py` inside the `wallet_widgets` directory.
    Go to the following GitLab link provided for the full code file in this section: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/tree/master/chapter_09/wallet/wallet_widgets).
  prefs: []
  type: TYPE_NORMAL
- en: 'This last widget is in the third tab of the main widget. The purpose here is
    to watch the ERC20 token and list all ERC20 tokens that have been watched. There
    is a button to launch an input dialog,a button to ask for the address of the ERC20
    smart contract token, and then there is a vertical layout that displays all ERC20
    tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we import many things, such as rendering the avatar tool, the blockchain
    object to establish information regarding tokens from the blockchain, and a number
    of libraries to deal with filesystems. On top of that, we also import UI classes
    from `PySide2`, such as many types of widgets, and classes to attach the callback
    to widgets. Beside UI classes, we import non-UI classes from PySide2, such as
    `slot` and `signal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block for the initialization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this initialization method, we create a button that is linked to the `watchNewToken`
    method, and then a vertical box layout to hold all token information. We also
    declare the `tokens_file` object, which holds the `tokens.json` configuration
    file. This file keeps  track of all ERC20 token-related information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code block to create an avatar image, a token name label,
    a token symbol label, and a token total supply label for each piece of token information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If `resize_parent` is true, this means we add token information through a dialog.
    In other words, we ask the parent window to increase its height. If `resize_parent`
    is `false`, this means that this method is called from the start.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is a method used to request the address of the smart
    contract with a dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If a user confirms the address of the smart contract, we get the token information
    using the `get_information_of_token` method of the `blockchain` object. This token's
    information is then put in the vertical box layout. Later, we save the token's
    information in the json file. This is done so that we can load this token information
    when we restart the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can launch your cryptocurrency wallet, make sure you run a private
    chain first and then deploy one or two ERC20 smart contracts in this private chain.
    You can use the ERC20 smart contract source code in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml),
    *Creating Token in Ethereum*. After doing this, run the desktop cryptocurrency
    wallet using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the final output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2647ef2-3ccf-4947-8e4f-1bdf78b2adf3.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we see the Account tab showing the balance of each
    account. Make sure you have at least two accounts. If not, create one from this
    tab by clicking the Create Account button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Send tab, where we can send ethers to any
    account we choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce0eb96c-c4ee-46fb-98a9-6817b9e0e66c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second tab, try to send ethers. It will take some time before the transaction
    is confirmed. Consequently, try sending ERC20 tokens to another account (but you
    have to add the ERC20 token first in the third tab), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da2cf602-c46f-4701-8b5d-edc36a383fbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in the third tab, try to watch a token smart contract. Put the address
    of the smart contract address in the dialog when you click the Watch Token button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce1b1bdf-c3d1-4191-9c4d-e52b31190c6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Your token will be reflected in the second tab.
  prefs: []
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write tests for this GUI application. These tests should not be exhaustive.
    We will create three tests, one for each tab. We will not create a test for the
    non-UI part of the application. This section is simply here to demonstrate how
    to test a UI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test for the first tab is an account widget test. Name the test `test_account.py`
    and save it inside the `tests` directory. The following code block is the test
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we test how many children the accounts layout has before we click
    a button, launch a dialog, fill in a password, and then click OK. Then, we check
    the number of children again after we create a new account. The number should
    have increased by one. For this test, we patch the dialog to make it easier for
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This test is not comprehensive. We did not test the fail case. I will leave
    that as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the second tab is a sending transaction widget test. Name the
    test file `test_send.py` and save it inside the `tests` directory. The test script
    is given in the following code block (refer to the code file in the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_09/wallet/tests/test_send.py)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we check the balance of the second account in the combobox. This
    second account will be the destination account. Here, we read the balance from
    the label and then we change the value of the combobox back to the first account,
    which will be the sender. After that, we set the destination account's address
    to the destination line edit. We then set the amount of ethers in the amount line
    edit and click the Send button, but remember, we need to patch the input dialog.
    Finally, we wait around 20 seconds before changing the account combobox's value
    again to be the second account. We retrieve the balance from the label and then
    we compare the difference between the old value and the new value, which should
    be 10 ethers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the third tab is for testing a token widget. Name this `test_token.py`
    and save it inside the `tests` directory. The test script for this test is given
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: First, we load the address of the token smart contract in the `address.txt`
    file because we don't want to hardcode it in the test file. The strategy is the
    same as in the test of the account widget. We check how many children the vertical
    box layout has. After that is done, we click the button, launch a dialog, fill
    in the address of the smart contract, and then click OK. Next, we check again
    how many children the vertical box layout has. The number should have increased
    by 1 again.
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, this test is actually not complete. We should test the token information
    as well. However, this test is a good start.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the preceding tests by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Considerations when building a cryptocurrency wallet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have now created a desktop cryptocurrency wallet. However, this wallet
    is not yet complete. A cryptocurrency wallet is a vast topic that changes so often
    that a book could be written on this topic alone. There are other features you
    can implement into a cryptocurrency wallet application, such as how many blocks
    have been confirmed for this transaction. In our application, we only wait for
    one transaction, but some users may want to confirm a couple of blocks first.
    If the transaction is confirmed with only one block, there is a slight chance
    that it could be replaced with a longer block. However, after 12 blocks, the transaction
    in the block is pretty much secure and irreversible, as explained in the following
    link: [https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum](https://ethereum.stackexchange.com/questions/319/what-number-of-confirmations-is-considered-secure-in-ethereum).'
  prefs: []
  type: TYPE_NORMAL
- en: Our cryptocurrency wallet is a pure cryptocurrency wallet. However, you could
    also add other features to our cryptocurrency wallet that are unrelated to the
    wallet functionality. For example, the Mist cryptocurrency wallet is not just
    a wallet; it is a decentralized application explorer as well. It can also compile
    a smart contract's source code and deploy it to the blockchain.
  prefs: []
  type: TYPE_NORMAL
- en: There are many features that you should implement if you want to make a fully-fledged
    cryptocurrency wallet. A number of ideas include generating a QR code, an option
    to export an encrypted private key, importing a private key, using a seed phrase
    to generate accounts, the validation of input, and remembering a password for
    a short period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are building a desktop cryptocurrency wallet. A desktop application
    can have the luxury of a lot of memory and storage. However, if you are building
    a mobile cryptocurrency wallet, this is a different story. For example, a Bitcoin
    desktop cryptocurrency wallet can access the full node locally. However, you cannot
    put a full Bitcoin node on a mobile phone as it is just too big. You could, of
    course, put the full Bitcoin node on the cloud and let the mobile cryptocurrency
    wallet application access that. However, most people don't want to set up a full
    node on the cloud. As a result, any developer of a Bitcoin mobile cryptocurrency
    wallet usually uses **Simplified Payment Verification** (**SPV**). In this way,
    the Bitcoin mobile cryptocurrency wallet does not require a full Bitcoin node
    to be stored on the phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to build a cryptocurrency wallet or contribute to existing cryptocurrency
    wallets, you need to bear two things in mind: security and the **user experience**
    (**UX**).'
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cryptocurrency wallet handles money, so you need to make it secure. Security
    is a complex topic that we will discuss briefly here.
  prefs: []
  type: TYPE_NORMAL
- en: Don't install a third-party library just because you can; every library is another
    vector attack. Be conservative in bundling third-party libraries in your application.
    Our cryptocurrency wallet uses libraries from Ethereum GitHub, such as web3.py
    and Populus. That should be fine because they are core libraries. We also use
    the `PySide2` library from the Qt company. This library is a must because without
    a GUI library, there cannot be a GUI application. We also use a third-party library
    to generate an identicon avatar image. We need to be careful here. The library
    is a single file, and I have read it fully to ensure there is no hidden malware.
    Because of that, I can integrate it confidently into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Use a minimum number of confirmations before declaring that the transaction
    is complete. How many confirmations is good enough depends on your threat and
    risk modelling. Usually, 12 confirmations make the reversing transaction impractical.
    The Mist wallet uses 12 confirmations, while the ZCash wallet uses 10 confirmations.
  prefs: []
  type: TYPE_NORMAL
- en: You could also force the user to create a good password when creating an account
    in a cryptocurrency wallet, because most users have a tendency to create an account
    with a bad password. But be careful here; you don't want to annoy them too much.
  prefs: []
  type: TYPE_NORMAL
- en: User experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an application is very secure but very hard to use, it is of no use. As a
    consequence, we need to make it less intimidating for users. The creator of Bitcoin,
    Satoshi Nakamoto, put a lot of thought into user experience when building the
    software. Previously, people used base64 format to convert binary to text. However,
    Satoshi used base58 to represent the Bitcoin address. Base58 is like base64, but
    without characters that cause confusion when it gets printed, such as I (capital
    i) and l (lower L).
  prefs: []
  type: TYPE_NORMAL
- en: Zcash has released a UX guide for designing a cryptocurrency wallet, and this
    can be found at the following link: [https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html](https://zcash.readthedocs.io/en/latest/rtd_pages/ux_wallet_checklist.html).
    Not everything can be implemented here because Zcash has a private transaction
    that Ethereum does not have. However, other suggestions can be implemented; for
    example, market information. Like it or not, people peg the cryptocurrency price
    to fiat money and it is a good idea to show people what the market price of 1
    ether is. If the network is congested, you should inform the user as well. You
    can suggest that the user waits or increases the transaction fee.
  prefs: []
  type: TYPE_NORMAL
- en: If you build an iOS cryptocurrency wallet, you should follow the Apple Human
    Interface Guideline. If you are building an Android cryptocurrency wallet, you
    should follow the Material Design guidelines. Be careful when choosing typography
    and the color to be used. You should do the user interview when designing a cryptocurrency
    wallet. UX is a broad subject. Balancing UX and security is a delicate art. You
    should not ignore UX when building a cryptocurrency wallet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have familiarized ourselves with the tabbed view, size
    policy, and the grid layout of `PySide2`. Then, we also learned how to test Qt
    applications. Next, we started to build a desktop cryptocurrency wallet. We divided
    the application into many parts: the blockchain, the thread, the widget, the identicon
    tool, and the test. The blockchain part of the cryptocurrency wallet is based
    on the `web3` and `Populus` libraries and its purpose is to read and create transactions
    in the blockchain. The thread is a middleman between the UI part and the blockchain
    object when creating a transaction. The identicon tool is used to create an avatar
    image based on a specific string (usually the address of the account or the token
    smart contract''s address). The widget part is a tabbed widget that has three
    tabs. The first tab is the account widget, the second tab is the sending transaction
    widget, and the third tab is the token widget. Lastly, we created tests for this
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start learning a topic beyond the scope of blockchain
    technology. This technology is called IPFS. It is still part of the decentralized
    technology, but this technology will overcome the weakness associated with the
    blockchain technology; in other words, its storage is expensive.
  prefs: []
  type: TYPE_NORMAL
