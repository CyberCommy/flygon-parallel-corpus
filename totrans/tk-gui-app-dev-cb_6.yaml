- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running methods on threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting threads with a progress bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling scheduled actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling idle tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawning separate processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other programming language, Python lets you divide a process execution
    into multiple units that can be performed independently in time, called **threads**.
    When you launch a Python program, it starts its execution in the **main thread**.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter's main loop must start from the main thread, which is responsible for
    handling all the events and updates to the GUI. By default, our application code,
    such as callbacks and event handlers, will also be executed in this thread.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we launch a long running action in this thread, the main thread
    execution will block until this operation is completed, and therefore the GUI
    will freeze and not respond to user events.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover several recipes to achieve responsiveness in
    our applications while separate actions occur in the background, and also take
    a look at how to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A basic technique to prevent blocking the main thread in Tkinter is scheduling
    an action that will be invoked after a timeout has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how to implement this with Tkinter using
    the `after()` method, which can be called from all Tkinter widget classes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following code shows a straightforward example of how a callback can block
    the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This application consists of a single button that gets disabled when it is
    clicked, waits 5 seconds, and is enabled again. A trivial implementation would
    be the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding program, you will note that the **Wait 5 seconds**
    button is not disabled at all, but clicking on it freezes the GUI for 5 seconds.
    We can directly note that in the button styling, which looks active instead of
    disabled; also, the title bar will not respond to mouse clicks until the 5 seconds
    have elapsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c38a83be-7aae-4da8-9461-e4c44b592c65.png)'
  prefs: []
  type: TYPE_IMG
- en: If we had included additional widgets, such as entries and scroll bars, this would
    also have affected them.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a look at how to achieve the desired functionality by scheduling
    the action instead of suspending the thread execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `after()` method allows you to register a callback that is invoked after
    a delay expressed in milliseconds within Tkinter's main loop. You can think of
    these registered alarms as events that should be handled as soon as the system
    is idle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will replace the call to `time.sleep(5)` with `self.after(5000,
    callback)`. We use the `self` instance because the `after()` method is also available
    in the root `Tk` instance, and there will not be any difference in calling it
    from a child widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding approach, the application is responsive before the scheduled
    action is called. The appearance of the button will change to disabled, and we
    could also interact with the title bar as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/064d3045-79e4-43cc-ae25-e13f2ab909e7.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the example mentioned in the preceding section, you might suppose the `after()`
    method executes the callback exactly after the given duration of milliseconds
    is passed as a delay.
  prefs: []
  type: TYPE_NORMAL
- en: However, what it does is request Tkinter to register an alarm that only guarantees
    that it will not be executed earlier than the specified time; so, if the main
    thread is busy, there is no upper limit to how long it will actually take.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also keep in mind that the method execution continues immediately
    after scheduling the action. The following example illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will print `"First"`, then `"Second"`, and finally `"Third"`
    after 1 second each. During this time, the main thread will keep the GUI responsive,
    and users can interact with the application as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we would want to prevent the running of the same background action
    more than once, so it's a good idea to disable the widget that triggered the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget that any scheduled function will be executed on the main thread,
    so just using `after()` is not enough to prevent freezing the GUI; it is also
    important to avoid executing long running methods as callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will take a look at how we can leverage the execution
    of these blocking actions in separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `after()` method returns an identifier of the scheduled alarm, which can
    be passed to the `after_cancel()` method to cancel the execution of the callback.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in another recipe how to implement the functionality of stopping
    a scheduled callback using this method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *canceling scheduled actions* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running methods on threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the main thread should be responsible only for updating the GUI and handling
    events, the rest of the background actions must be executed in separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: Python's Standard Library includes the `threading` module to create and control
    multiple threads using a high-level interface that will allow us to work with
    simple classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that CPython—the reference Python implementation—is inherently
    limited by the **GIL** (**Global Interpreter Lock**), a mechanism that prevents
    multiple threads from executing Python byte codes once and therefore, they cannot
    run in separate cores to take full advantage of multiprocessor systems. This should
    be kept in mind if trying to use the `threading` module to improve the performance
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example combines the suspension of a thread with `time.sleep()`
    with an action scheduled via `after()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a new `Thread` object, we can use the constructor with the `target`
    keyword argument, which will be invoked on a separate thread when we call its
    `start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding section, we used a reference to the `run_action` method on
    the current application instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we periodically polled the thread status using `after()`, which schedules
    the same method again until the thread is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we set a delay of `100` milliseconds, because
    there is no need to keep polling more frequently than that. Of course, this number
    may vary depending on the nature of the threaded action.
  prefs: []
  type: TYPE_NORMAL
- en: 'This timeline can be represented by the following sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/fea2c979-482b-44a4-a0b5-c4ed260cd966.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The rectangle on **Thread-1** represents the time it is busy executing **time.sleep(5)**.
    Meanwhile, **MainThread** only checks the status periodically, and there is no
    operation long enough to causes it to freeze the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we had a brief introduction to the `Thread` class, but it is
    also important to point out some details about instantiating and using threads
    in your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Thread methods - start, run, and join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example, we called `start()` because we wanted to execute the method
    in a separate thread and continue the execution of the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we had invoked the `join()` method, the main thread would
    have been blocked until the new thread is terminated. Therefore, it would have
    caused the same "freezing" behavior that we wanted to avoid, even if we are using
    multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `run()` method is where the thread actually executes its callable
    target operation. We will override it when we extend the `Thread` class, as in
    the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, always remember to call `start()` from the main thread to
    avoid blocking it.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing the target method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the constructor of the `Thread` class, it''s possible to specify
    the arguments of the target method via the `args` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `self` parameter is passed automatically since we are using the
    current instance to reference the target method. This might be handy in scenarios
    where the new thread needs to access information from the caller instance.
  prefs: []
  type: TYPE_NORMAL
- en: Performing HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating your application with a remote server via HTTP is a common use
    case of asynchronous programming. The client performs a request, which is transferred
    across the network using the TCP/IP protocol; then, the server processes the information
    and sends the response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The time to perform this operation might vary from a few milliseconds to several
    seconds, but in most cases it is safe to assume that this latency may be noticed
    by your users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of third-party web services on the internet that can be freely
    accessed for prototyping purposes. However, we do not want to rely on an external
    service because its API may change or it might even go offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will implement our custom HTTP server, which generates
    a random JSON response that will be printed on our separate GUI application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To start this server, run the `server.py` script and leave the process running
    to accept incoming HTTP requests on local port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our client application consists of a simple label to display information to
    users and a button to perform a new HTTP request to our local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the request is completed, the label shows the random value generated in
    the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/1dafeaf9-7935-446d-a1fb-b04232acb21b.png)'
  prefs: []
  type: TYPE_IMG
- en: As usual, the button gets disabled while the asynchronous action is running
    to avoid performing a new request before the preceding one has been processed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we extended the `Thread` class to implement the logic that
    must run in a separate thread using a more object-oriented approach. This is done
    by overriding its `run()` method, which will be responsible for performing the
    HTTP request to the local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of HTTP client libraries, but here we will simply use the `urllib.request`
    module from the standard library. This module contains the `urlopen()` function,
    which can take a URL string and return an HTTP response that can work as a context
    manager—that is, it can be safely read and closed using the `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server returns a JSON document like the following one (you can check it
    by opening the `http://localhost:8080` URL in your browser):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To decode the string to a object, we pass the response contents to the `loads()`
    function from the `json` module. Thanks to this, we can access the random value
    like using a dictionary, and store it in the `result` attribute, which is initialized
    to `None` to prevent the main thread from reading a field that is not set in case
    an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the GUI periodically polls the thread status, as we saw in the preceding
    recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, the main difference is that once the thread is not alive, we can retrieve
    the value of the `result` attribute because it has been set before finishing its
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running methods on threads* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting threads with a progress bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progress bars are useful indicators of the status of a background task, showing
    an incrementally filled portion of the bar relative to the progress. They are
    frequently used in long-running operations, so it is common to connect them with
    the threads that execute these tasks to provide visual feedback to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our sample application will consist of a horizontal progress bar that will
    increment a fixed amount of progress once the user clicks on the Start button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/39ccaa8f-15d9-4d73-bfc0-e0be22d147d2.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To simulate the execution of a background task, the increment of the progress
    bar will be generated from a different thread that will suspend its execution
    for 1 second between each step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The communication will be made using a synchronized queue that allow us to
    exchange information in a thread-safe manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Progressbar` is a themed widget included in the `tkinter.ttk` module. We will
    dive into this module in [Chapter 8](b8705c23-ce33-4fa7-b318-e7626e557b86.xhtml),
    *Themed Widgets*, to explore the new widgets that it defines, but so far we only
    need to use `Progressbar` as a regular widget.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to import the `queue` module, which defines synchronized collections
    such as `Queue`. Synchronicity is an important topic in multithreaded environments,
    because an unexpected result might occur if shared resources are accessed at exactly
    the same time—we define this unlikely but possible scenarios as a **race condition**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these additions, our `App` class contains these new statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Like previous examples, the `start_action()` method starts a thread, passing
    the queue and the number of steps that will simulate the long running task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `AsyncAction` subclass defines a custom constructor to receive these parameters,
    which will later be used in the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The loop suspends the execution of the thread for 1 second and adds the increment
    to the queue as many times as indicated in the `steps` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The item added to the queue is retrieved from the application instance by reading
    the queue from `check_queue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method is periodically called from `poll_thread()`, which polls
    the thread status and schedules itself again with `after()` until the thread completes
    its execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running methods on threads* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling scheduled actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter's scheduling mechanism not only provides methods to delay callback executions,
    but also to cancel them if they have not been executed yet. Consider an operation
    that may take too much time to complete, so we want to let users to stop it by
    pressing a button or closing the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take the example from the first recipe and add a Stop button to allow
    us to cancel the scheduled action.
  prefs: []
  type: TYPE_NORMAL
- en: 'This button will be enabled only while the action is scheduled, which means
    that once you click on the left button, the user can wait for 5 seconds, or click
    on the Stop button to immediately enable it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/d3b3fcb2-7afe-4875-83aa-f97e554a4787.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `after_cancel()` method cancels the execution of a scheduled action by
    taking the identifier previously returned by calling `after()`. In this example,
    this value is stored in the `scheduled_id` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To unschedule a callback, we will first need the alarm identifier returned
    by `after()`. We will store this identifier in the `scheduled_id` attribute, since
    we will need it in a separate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, this field is passed to `after_cancel()` in the callback of the `Stop`
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our case, it is important to disable the `Start` button once it is clicked,
    because if `start_action()` is called twice, `scheduled_id` would be overridden,
    and the `Stop` button could only cancel the last scheduled action.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, `after_cancel()` has no effect if we call it with an alarm identifier
    that has already been executed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we covered how to cancel a scheduled alarm, but if this callback
    was polling the status of a background thread, you might wonder how to stop the
    thread as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no official API to gracefully stop a `Thread` instance.
    If you have defined a custom subclass, you might need to include a flag that is
    periodically checked inside its `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, this flag can be externally modified by setting `thread.do_stop = True`
    when invoking `after_cancel()` also to stop the thread.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this approach will heavily depend on the operations performed inside
    the `run()` method—for instance, this mechanism is easier to implement if it consists
    of a loop, because you can perform this check between each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Python 3.4, you can use the `asyncio` module, which includes classes
    and functions to manage asynchronous operations, including cancellations. Even
    though this module is outside the scope of this book, we recommend you explore
    it if you face more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Handling idle tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are certain situations where an operation causes a small pause in the
    execution of the program. It might not even take a second to complete, but it
    is still noticeable to your users because it introduces a momentary pause in the
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to deal with these scenarios without needing
    to process the whole task in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take the example from the *Scheduling actions* recipe, but with a timeout
    of 1 second instead of 5.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we change the state of the button to `DISABLED`, the callback continues
    its execution, so the state of the button is not actually changed until the system
    is idle, which means it has to wait for `time.sleep()` to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can force Tkinter to update all the pending GUI updates to execute
    at a specific moment, as shown in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key to the snippet mentioned in the preceding section is the call to `self.update_idletasks()`.
    Thanks to this, the change to the button state is processed by Tkinter before
    calling `time.sleep()`. So, during the second that the callback is suspended,
    the button has the desired appearance, instead of `ACTIVE`, which is the state
    that Tkinter sets for the button before invoking the callback.
  prefs: []
  type: TYPE_NORMAL
- en: We used `time.sleep()` to illustrate a situation where a statement takes long
    enough to execute but is short enough to consider moving it to a new thread—in
    real-world scenarios, it would be a more complex computing operation.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning separate processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under some circumstances, it is not possible to implement the desired functionality
    for your application just by using threads. For instance, you might want to call
    a separate program that could be written in a different language.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we also need to use the `subprocess` module to invoke the target
    program from our Python process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example performs a ping to an indicated DNS or IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/2d22640c-8c92-43f6-8cec-59f2f6dcb862.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we define a custom `AsyncAction` method, but, in this case, we call
    `subprocess.run()` with the value set in the Entry widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function starts a separate subprocess that, unlike threads, uses a separate
    memory space. This means that in order to get the result of the `ping` command,
    we must pipe the result printed to the standard output and read it in our Python
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `run()` function executes the subprocess specified in the array of arguments.
    By default, the result contains only the return code of the process, so we also
    pass the `stdout` option with the `PIPE` constant to indicate that the standard
    output stream should be piped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this function with the keyword argument—`shell`—set to `True` to avoid
    opening a new console for the `ping` subprocess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when the main thread verifies that this operation has finished, it
    prints the output to the Text widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
