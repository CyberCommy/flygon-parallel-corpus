- en: '*Chapter 12*: Creating Animations with Animator, Cinemachine, and Timeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At our current game status, we mostly have a static Scene, without considering
    the Shader and particle animations. In the next chapter, when we will add scripting
    to our game, everything will start to move according to the behavior we want.
    But sometimes, we need to move objects in a predetermined way, such as with cutscenes,
    or specific character animations, such as jumping, running, and so on. The idea
    of this chapter is to go over several Unity animation systems to create all the
    possible movements of objects we can get without scripting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following animation concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using skeletal animations with Animator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic cameras with Cinemachine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cutscenes with Timeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create cutscenes to tell the
    history of your game or highlight specific areas of your level, as well as create
    dynamic cameras that are capable of giving an accurate look of your game, regardless
    of the situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Using skeletal animations with Animator
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used what are called static meshes, which are solid three-dimensional
    models that are not supposed to bend or animate in any way (aside from moving
    separately, like the doors of a car). We also have another kind of mesh, called
    skinned meshes, which are meshes that have the ability to be bent based on a skeleton,
    so they can emulate the muscle movements of the human body. We are going to explore
    how to integrate animated humanoid characters into our project to create the enemy
    and player movements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following skeletal mesh concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Understanding skinning
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing skinned meshes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration using Animator Controllers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to explore the concept of skinning and how it allows you to animate
    characters. Then, we are going to bring animated meshes into our project to finally
    apply animations to them. Let's start by discussing how to bring skeletal animations
    into our project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Understanding skinning
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get an animated mesh, we need to have four pieces, starting with
    the mesh itself and the model that will be animated, which is created the same
    way as any other mesh. Then, we need the skeleton, which is a set of bones that
    will match the desired mesh topology, such as the arms, fingers, feet, and so
    on. In *Figure 12.1*, you can see an example of a set of bones aligned with our
    target mesh. You will notice that these kinds of meshes are usually modeled with
    the *T* pose, which will facilitate the animation process:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – A ninja mesh with a skeleton matching its default pose'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B14199.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – A ninja mesh with a skeleton matching its default pose
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the artist has created the model and its bones, the next step is to do
    the skinning, which is the act of associating every vertex of the model to one
    or more bones. In this way, when you move a bone, the associated vertexes will
    move with it. This is done in such a way because it is easier to animate a reduced
    amount of bones instead of every single vertex of the model. In the next screenshot,
    you will see the triangles of a mesh being painted according to the color of the
    bone that affects it as a way to visualize the influence of the bones. You will
    notice blending between colors, meaning that those vertexes are affected differently
    by different bones to allow the vertexes near an articulation to bend nicely.
    Also, the screenshot illustrates an example of a two-dimensional mesh used for
    two-dimensional games, but the concept is the same:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Mesh skinning weights visually represented as colors'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B14199.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Mesh skinning weights visually represented as colors
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last piece you need is the actual animation, which will simply
    consist of a blending of different poses of the meshes. The artist will create
    keyframes in an animation, determining which pose the model needs to have at different
    moments, and then the animation system will simply interpolate between them. Basically,
    the artist will animate the bones, and the skinning system will apply this animation
    to the whole mesh. You can have one or several animations, which you will later
    switch between according to the animation that you want to match the character's
    motion (such as idle, walking, falling, and so on).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要的最后一部分是实际的动画，它将简单地由网格的不同姿势混合而成。艺术家将在动画中创建关键帧，确定模型在不同时刻需要采取哪种姿势，然后动画系统将简单地在它们之间进行插值。基本上，艺术家将对骨骼进行动画处理，而蒙皮系统将把这个动画应用到整个网格上。你可以有一个或多个动画，之后你可以根据你想要匹配角色动作的动画来在它们之间切换（比如站立、行走、跌倒等）。
- en: In order to get the four parts, we need to get the proper assets containing
    them. The usual format in this scenario is **Filmbox** (**FBX**), which is the
    same that we have used so far to import 3D models. This format can contain every
    piece we need—the model, the skeleton with the skinning, and the animations—but
    usually, we will split the parts into several files to reutilize the pieces.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这四个部分，我们需要获取包含它们的适当资产。在这种情况下，通常的格式是**Filmbox**（**FBX**），这与我们迄今为止用来导入3D模型的格式相同。这种格式可以包含我们需要的每一部分——模型、带有蒙皮的骨骼和动画——但通常，我们会将部分拆分成多个文件以重复利用这些部分。
- en: 'Imagine a city simulator game where we have several citizen meshes with different
    aspects and all of them must be animated. If we have a single FBX per citizen
    containing the mesh, the skinning, and the animation, it will cause each model
    to have its own animation, or at least a clone of the same one, repeating them.
    When we need to change that animation, we will need to update all the mesh citizens,
    which is a time-consuming process. Instead of this, we can have one FBX per citizen,
    containing the mesh and the bones with the proper skinning based on that mesh,
    as well as a separate FBX for each animation, containing the same bones that all
    the citizens have with the proper animation, but without the mesh. This will allow
    us to mix and match the citizen FBX with the animation''s FBX files. You may be
    wondering why both the model FBX and the animation FBX must have the mesh. This
    is because they need to match in order to make both files compatible. In the next
    screenshot, you can see how the files should look:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个城市模拟游戏，我们有几个市民网格，外观各异，所有这些网格都必须进行动画处理。如果每个市民的单个FBX包含网格、蒙皮和动画，那么每个模型都会有自己的动画，或者至少是相同动画的克隆，重复出现。当我们需要更改动画时，我们需要更新所有网格市民，这是一个耗时的过程。与此相反，我们可以为每个市民准备一个FBX，其中包含网格和骨骼，以及一个单独的FBX文件用于每个动画，其中包含所有市民都具有的相同骨骼和适当动画，但不包含网格。这将允许我们混合和匹配市民FBX和动画的FBX文件。也许你会想为什么模型FBX和动画FBX都必须有网格。这是因为它们需要匹配才能使两个文件兼容。在下一个截图中，你可以看到文件应该是什么样子的：
- en: '![Figure 12.3 – The animation and model FBX files of the package we will use
    in our project'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 我们将在项目中使用的包的动画和模型FBX文件'
- en: '](img/Figure_12.03_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.03_B14199.jpg)'
- en: Figure 12.3 – The animation and model FBX files of the package we will use in
    our project
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 我们将在项目中使用的包的动画和模型FBX文件
- en: Also, it is worth mentioning a concept called retargeting. As we said before,
    in order to mix a model and an animation file, we need them to have the same bone
    structure, which means the same amount of bones, hierarchy, and names. Sometimes,
    this is not possible, especially when we mix custom models created by our artist
    with external animation files that you can record from an actor using motion capture
    techniques or just by buying a Mocap library. In such cases, it is highly likely
    that you will encounter different bone structures between the one in the Mocap
    library and your character model, so here is where retargeting kicks in. This
    technique allows Unity to create a generic mapping between two different humanoid-only
    bone structures to make them compatible. In a moment, we will see how to enable
    this feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得一提的是一个叫做重定向的概念。正如我们之前所说，为了混合模型和动画文件，我们需要它们具有相同的骨骼结构，这意味着相同数量的骨骼、层次结构和名称。有时，这是不可能的，特别是当我们混合我们的艺术家创建的自定义模型与使用动作捕捉技术从演员那里记录下来的外部动画文件，或者只是购买一个Mocap库。在这种情况下，很可能会遇到Mocap库中的骨骼结构与您的角色模型不同，这就是重定向发挥作用的地方。这种技术允许Unity创建两种不同的仅限于人形的骨骼结构之间的通用映射，使它们兼容。一会儿，我们将看到如何启用这个功能。
- en: Now that we understand the basics behind skinned meshes, let's see how we can
    get the model's assets with bones and animations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了有关蒙皮网格的基础知识，让我们看看如何获取带有骨骼和动画的模型资产。
- en: Importing skeletal animations
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入骨骼动画
- en: Let's start with how to import some animated models from the Asset Store, under
    the **3D** | **Characters** | **Humanoids** section. You can also use external
    sites, such as Mixamo, to download them. But for now, I will stick to the Asset
    Store as you will have less trouble making the assets work. In my case, I have
    downloaded a package, as you can see in the following screenshot, that contains
    both models and animations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何从资产商店导入一些带有动画的模型开始，在**3D** | **Characters** | **Humanoids**部分。你也可以使用外部网站，比如Mixamo，来下载它们。但现在，我会坚持使用资产商店，因为你在使资产工作时会遇到更少的麻烦。在我的情况下，我已经下载了一个包，正如你在下面的截图中所看到的，其中包含了模型和动画。
- en: 'Note that sometimes you will need to download them separately because some
    assets will be model- or animation-only. Also, consider that the packages used
    in this book might not be available at the time you''re reading; in that case,
    you can either look for another package with similar assets (characters and animations,
    in this case) or download the project files from the GitHub repository of the
    book and copy the required files from there:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Soldier models for our game'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B14199.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Soldier models for our game
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: In my package content, I can find the animation's FBX files in the `Animations`
    folder and the single model FBX file in `Model`. Remember that sometimes you won't
    have them separated like this, and the animations may be located in the same FBX
    as the model, if any animations are present at all. Now that we have the required
    files, let's discuss how to properly configure them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start selecting the **Model** file and checking the **Rig** tab. Within
    this tab, you will find a setting called **Animation Type**, as in the following
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The Rig properties'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B14199.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – The Rig properties
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'This property contains the following options:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: Mode for non-animated models; every static mesh in your game will
    use this mode.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legacy**: The mode to be used in old Unity Projects and models; do not use
    this in new projects.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic**: A new animation system that can be used in all kinds of models
    but is commonly used in non-humanoid models, such as horses, octopuses, and so
    on. If you use this mode, both the model and animation FBX files must have the
    exact same bone names and structure, thereby reducing the possibility of combining
    animation from external sources.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Humanoid**: New animation systems designed to be used in humanoid models.
    It enables features such as retargeting and **Inverse Kinematics** (**IK**). This
    allows you to combine models with different bones than the animation because Unity
    will create a mapping between those structures and a generic one, called the avatar.
    Take into account that sometimes the automatic mapping can fail, and you will
    need to correct it manually; so, if your generic model has everything you need,
    I would recommend you to stick to **Generic** if that''s the default configuration
    of the FBX.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my case, the FBX files in my package have the modes set to **Humanoid**,
    so that's good, but remember, only switch to other modes if it is absolutely necessary
    (for example, if you need to combine different models and animations). Now that
    we have discussed the **Rig** settings, let's talk about the **Animation** settings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, select any animation FBX file and look for the **Animation**
    section of the Inspector window. You will find several settings, such as the **Import
    Animation** checkbox, which must be marked if the file has an animation (not the
    model files), and the **Clips** list, where you will find all the animations in
    the file. In the following screenshot, you can see the **Clips** list for one
    of our animation files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – A Clips list in the Animation settings'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B14199.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – A Clips list in the Animation settings
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'An FBX file with animations usually contains a single large animation track,
    which can contain one or several animations. Either way, by default, Unity will
    create a single animation based on that track, but if that track contains several
    animations, you will need to split them manually. In our case, our FBX contains
    several animations already split by the package creator, but in order to learn
    how to do a manual split, do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: From the `HumanoidCrouchIdle`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the **Start** and **End** values below the animation timeline
    and remember them; we will use them to recreate this clip:![Figure 12.7 – The
    Clip settings
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B14199.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – The Clip settings
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Click on the minus button on the bottom-right part of the **Clips** list to
    delete the selected clip.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**片段**列表底部右侧的减号按钮以删除所选的片段。
- en: Use the plus button to create a new clip and select it.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用加号按钮创建一个新的片段并选择它。
- en: Rename it to something similar to the original using the `Take 001` input field.
    In my case, I will name it `Idle`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Take 001`输入字段将其重命名为与原始名称类似的内容。在我的例子中，我会将其命名为`空闲`。
- en: Set the `319` for `264` for **Start**. This information usually comes from the
    artist, but you can just try the number that works best or simply drag the blue
    markers in the timeline on top of these properties.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**开始**设置为`319`，将`结束`设置为`264`。这些信息通常来自艺术家，但您可以尝试最适合的数字，或者简单地在时间轴上拖动蓝色标记到这些属性上。
- en: 'You can preview the clip by clicking on the bar titled for your animation (**HumanoidIdle**,
    in my case) at the very bottom of the Inspector window and click on the Play button.
    You will see the default Unity model, but you can see your own by dragging the
    model file to the preview window because it is important to check whether our
    models are properly configured. If the animation does not play, you will need
    to check whether the **Animation Type** setting matches the animation file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过单击检视器窗口底部的标题栏上的条形图来预览片段，然后单击播放按钮来预览您的动画（在我的例子中是**HumanoidIdle**）。您将看到默认的Unity模型，但是您可以通过将模型文件拖放到预览窗口中来查看自己的模型，因为检查我们的模型是否正确配置是很重要的。如果动画没有播放，您需要检查**动画类型**设置是否与动画文件匹配：
- en: '![Figure 12.8 – Animation preview'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 - 动画预览'
- en: '](img/Figure_12.08_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.08_B14199.jpg)'
- en: Figure 12.8 – Animation preview
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - 动画预览
- en: 'Now, open the animation file, click on the arrow, and check the sub-assets.
    You will see that here, there is a file titled for your animation, alongside the
    other animations in the clip list, which contains the cut clips. In a moment,
    we will play them. In the following screenshot, you can see the animations in
    our `.fbx` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开动画文件，单击箭头，然后检查子资产。您会看到这里有一个与您的动画标题相对应的文件，以及剪辑列表中的其他动画，其中包含了剪辑。一会儿，我们将播放它们。在下面的截图中，您可以看到我们`.fbx`文件中的动画：
- en: '![Figure 12.9 – Generated animation clips'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 - 生成的动画片段'
- en: '](img/Figure_12.09_B14199.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.09_B14199.jpg)'
- en: Figure 12.9 – Generated animation clips
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 - 生成的动画片段
- en: Now that we covered the basic configuration, let's see how to integrate animations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本配置，让我们看看如何集成动画。
- en: Integration using Animation Controllers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动画控制器进行集成
- en: When adding animations to our characters, we need to think about the flow of
    the animations, which means thinking about which animations must be played, when
    each animation must be active, and how transitions between animations should happen.
    In previous Unity versions, you needed to code that manually, generating complicated
    scripts of C# code to handle complex scenarios; but now, we have Animation Controllers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在为角色添加动画时，我们需要考虑动画的流程，这意味着考虑必须播放哪些动画，每个动画何时处于活动状态，以及动画之间的过渡应该如何发生。在以前的Unity版本中，您需要手动编写复杂的C#代码脚本来处理复杂的情景；但现在，我们有了动画控制器。
- en: Animation Controllers are a state machine-based asset where we can diagram the
    transition logic between animations with a visual editor called **Animator**.
    The idea is that each animation is a state and our model will have several of
    them. Only one state can be active at a time, so we need to create transitions
    in order to change them, which will have conditions that must be met in order
    to trigger the transition process. Conditions are comparisons of data about the
    character to be animated, such as its velocity, whether it's shooting or crouched,
    and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器是基于状态机的资产，我们可以使用名为**动画师**的可视编辑器来绘制动画之间的转换逻辑。其思想是每个动画都是一个状态，我们的模型将有多个状态。一次只能激活一个状态，因此我们需要创建转换来改变它们，这些转换将具有必须满足的条件才能触发转换过程。条件是关于要进行动画的角色的数据的比较，例如其速度、是否在射击或蹲下等。
- en: 'So, basically, an Animation Controller or state machine is a set of animations
    with transition rules that will dictate which animation should be active. Let''s
    start creating a simple Animation Controller by doing the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，动画控制器或状态机基本上是一组带有转换规则的动画，它将决定哪个动画应处于活动状态。让我们通过以下步骤开始创建一个简单的动画控制器：
- en: Click the `Player`. Remember to locate your asset within a folder for proper
    organization; I will call mine `Animators`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“播放器”。记得将您的资产放在一个文件夹中以便进行适当的组织；我会把我的称为“动画师”。
- en: Double-click on the asset to open the **Animator** window. Don't confuse this
    window with the **Animation** window; the **Animation** window does something
    different.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产以打开**动画师**窗口。不要将此窗口与**动画**窗口混淆；**动画**窗口有不同的功能。
- en: Drag the **Idle** animation clip of your character into the **Animator** window.
    This will create a box in the Controller representing the animation that will
    be connected to the entry point of the Controller, indicating that the animation
    will be the default one because it is the first one that we dragged. If you don't
    have an **Idle** animation, I encourage you to find one. We will need at least
    one **Idle** and one walking/running animation clip:![Figure 12.10 – Dragging
    an animation clip from an FBX asset into an Animator Controller
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您角色的**空闲**动画片段拖放到**动画师**窗口中。这将在控制器中创建一个框，表示将连接到控制器的默认动画，因为这是我们拖动的第一个动画。如果您没有**空闲**动画，我建议您找一个。我们至少需要一个**空闲**和一个行走/奔跑的动画片段：![图12.10
    - 从FBX资产中拖动动画片段到动画控制器
- en: '](img/Figure_12.10_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B14199.jpg)'
- en: Figure 12.10 – Dragging an animation clip from an FBX asset into an Animator
    Controller
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 - 从FBX资产中拖动动画片段到动画控制器
- en: Drag the running animation in the same way.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式拖动奔跑动画。
- en: Right-click on the **Idle** animation, select **Create Transition**, and left-click
    on the **Run** animation. This will create a transition between **Idle** and **Run**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Idle**动画，选择**Create Transition**，然后左键点击**Run**动画。这将在**Idle**和**Run**之间创建一个过渡。
- en: Create another transition from **Run** to **Idle** in the same way:![Figure
    12.11 – Transitions between two animations
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式从**Run**到**Idle**创建另一个过渡：![图12.11 – 两个动画之间的过渡
- en: '](img/Figure_12.11_B14199.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B14199.jpg)'
- en: Figure 12.11 – Transitions between two animations
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 两个动画之间的过渡
- en: 'Transitions must have conditions in order to prevent animations from swapping
    constantly, but in order to create conditions, we need data to make comparisons.
    We will add properties to our Controller, which will represent data used by the
    transitions. Later, in *Part 3*, we will set that data to match the current state
    of our object. But for now, let''s create the data and test how the Controller
    reacts with different values. In order to create conditions based on properties,
    do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡必须有条件，以防止动画不断切换，但为了创建条件，我们需要数据进行比较。我们将向我们的Controller添加属性，这些属性将代表过渡所使用的数据。稍后在*第3部分*中，我们将设置这些数据以匹配对象的当前状态。但现在，让我们创建数据并测试Controller对不同值的反应。为了基于属性创建条件，做如下操作：
- en: Click on the **Parameters** tab in the top-left part of the **Animator** window.
    If you don't see it, click on the crossed-eye button to display the tabs.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Animator**窗口左上角的**Parameters**选项卡。如果你没有看到它，点击交叉眼按钮显示选项卡。
- en: Click on the `Velocity`. If you missed the renaming part, just left-click on
    the variable and rename it:![Figure 12.12 – The Parameters tab with a float Velocity
    property
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Velocity`。如果你错过了重命名部分，只需左键点击变量并重命名：![图12.12 – 具有浮点速度属性的参数选项卡
- en: '](img/Figure_12.12_B14199.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B14199.jpg)'
- en: Figure 12.12 – The Parameters tab with a float Velocity property
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 具有浮点速度属性的参数选项卡
- en: Click on the `Conditions` property in the Inspector window.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中点击`Conditions`属性。
- en: Click on the `0`. This tells us that the transition will execute from `0`. I
    recommend you to set a slightly higher value, such as `0.01`, to prevent any float
    rounding errors (a common CPU issue). Also, remember that the actual value of
    **Velocity** needs to be set manually via scripting, which we will do in *Part
    3*:![Figure 12.13 – Condition to check whether the velocity is greater than 0.01
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`0`。这告诉我们过渡将从`0`执行。我建议你设置一个稍高一点的值，比如`0.01`，以防止任何浮点舍入错误（常见的CPU问题）。还要记住，**Velocity**的实际值需要通过脚本手动设置，这将在*第3部分*中进行：![图12.13
    – 检查速度是否大于0.01的条件
- en: '](img/Figure_12.13_B14199.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B14199.jpg)'
- en: Figure 12.13 – Condition to check whether the velocity is greater than 0.01
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 检查速度是否大于0.01的条件
- en: 'Do the same to the `0.01`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`0.01`做同样的操作：
- en: '![Figure 12.14 – Condition to check whether a value is less than 0.01'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14 – 检查值是否小于0.01的条件'
- en: '](img/Figure_12.14_B14199.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B14199.jpg)'
- en: Figure 12.14 – Condition to check whether a value is less than 0.01
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 检查值是否小于0.01的条件
- en: 'Now that we have our first Animator Controller set up, it''s time to apply
    it to an object. In order to do that, we will need a series of components. First,
    when we have an animated character, rather than a regular Mesh Renderer, we use
    the Skinned Mesh Renderer. If you drag the model of the character to the scene
    and explore its children, you will see a component, as shown:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了第一个Animator Controller，是时候将它应用到一个对象上了。为了做到这一点，我们需要一系列的组件。首先，当我们有一个动画角色时，我们使用蒙皮网格渲染器而不是普通的网格渲染器。如果你将角色模型拖到场景中并探索它的子级，你会看到一个组件，如下所示：
- en: '![Figure 12.15 – A Skinned Mesh Renderer component'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 一个蒙皮网格渲染器组件'
- en: '](img/Figure_12.15_B14199.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.15_B14199.jpg)'
- en: Figure 12.15 – A Skinned Mesh Renderer component
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 一个蒙皮网格渲染器组件
- en: 'This component will be in charge of applying the bones'' movements to the mesh.
    If you search the children of the model, you will find some bones; you can try
    rotating, moving, and scaling them to see the effect, as shown in the following
    screenshot. Consider the fact that your bone hierarchy might be different from
    mine if you downloaded another package from the Asset Store:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将负责将骨骼的移动应用到网格上。如果你搜索模型的子级，你会发现一些骨骼；你可以尝试旋转、移动和缩放它们，以查看效果，如下面的截图所示。请注意，如果你从资产商店下载了另一个包，你的骨骼层次结构可能与我的不同：
- en: '![Figure 12.16 – Rotating the neckbone'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – 旋转颈骨'
- en: '](img/Figure_12.16_B14199.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.16_B14199.jpg)'
- en: Figure 12.16 – Rotating the neckbone
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 旋转颈骨
- en: 'The other component that we need is **Animator**, which is automatically added
    to skinned meshes at its root GameObject. This component will be in charge of
    applying the state machine that we created in the Animator Controller if the animation
    FBX files are properly configured as we mentioned earlier. In order to apply the
    Animator Controller, do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的另一个组件是**Animator**，它会自动添加到其根GameObject的蒙皮网格上。这个组件将负责应用我们在Animator Controller中创建的状态机，如果动画FBX文件按照我们之前提到的方式正确配置的话。为了应用Animator
    Controller，做如下操作：
- en: Drag the model of the character to the Scene if it's not already there.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果场景中还没有角色模型，将角色模型拖到场景中。
- en: Select it and locate the **Animator** component in the root GameObject.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并定位根GameObject中的**Animator**组件。
- en: Click on the circle to the right of the **Controller** property and select the
    **Player** controller we created earlier. You can also just drag it from the Project
    window.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Controller**属性右侧的圆圈，选择之前创建的**Player**控制器。你也可以直接从项目窗口拖动它。
- en: Make sure that the **Avatar** property is set to the avatar inside the FBX model;
    this will tell the animator that we will use that skeleton. You can identify the
    avatar asset by its icon of a person, as in the following screenshot. Usually,
    this property is correctly set automatically when you drag the FBX model to the
    Scene:![Figure 12.17 – Animator using the Player controller and the robot avatar
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.17_B14199.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.17 – Animator using the Player controller and the robot avatar
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Camera** GameObject so that it's looking at the player and play the
    game, and you will see the character executing its **Idle** animation.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without stopping the game, open the Animator Controller asset again by double-clicking
    it and selecting the character in the **Hierarchy** pane. By doing this, you should
    see the current state of the animation being played by that character, using a
    bar to represent the current part of the animation:![Figure 12.18 – The Animator
    Controller in Play mode while an object is selected,
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: showing the current animation and its progress
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.18_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – The Animator Controller in Play mode while an object is selected,
    showing the current animation and its progress
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Using the `1.0` and see how the transition will execute:![Figure 12.19 – Setting
    the velocity of the Controller to trigger a transition
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.19_B14199.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – Setting the velocity of the Controller to trigger a transition
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how the **Run** animation was set, your character might start
    to move. This is caused by the root motion, a feature that will move the character
    based on the animation movement. Sometimes, this is useful, but due to the fact
    that we will fully move our character using scripting, we want that feature to
    be turned off. You can do that by unchecking the **Apply Root Motion** checkbox
    in the **Animator** component of the **Character** object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Disabled root motion'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.20_B14199.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – Disabled root motion
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice a delay between changing the **Velocity** value and the
    start of the animation transition. That''s because, by default, Unity will wait
    for the original animation to end before executing a transition, but in this scenario,
    we don''t want that. We need the transition to start immediately. In order to
    do this, select each transition of the Controller and in the Inspector window,
    uncheck the **Has Exit Time** checkbox:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Disabling the Has Exit Time checkbox to execute the transition
    immediately'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.21_B14199.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – Disabling the Has Exit Time checkbox to execute the transition
    immediately
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You can start dragging other animations into the Controller and create complex
    animation logic, such as adding jumping, falling, or crouched animations. I invite
    you to try other parameter types, such as a Boolean, that use checkboxes instead
    of numbers. Also, as you develop your game further, your Controller will grow
    in its number of animations. To manage that, there are other features worth researching,
    such as Blend Trees and sub-state machines, but that's beyond the scope of this
    book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of character animations in Unity, let's discuss
    how to create dynamic camera animations to follow our player.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic cameras with Cinemachine
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cameras are a very important subject in video games. They allow the player to
    see their surroundings to make decisions based on what they see. The game designer
    usually defines how it behaves to get the exact gameplay experience they want,
    and that's no easy task. A lot of behaviors must be layered to get the exact feeling.
    Also, during cutscenes, it is important to control the path that the camera will
    be traversing and where the camera is looking to focus the action during those
    constantly moving scenes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use the Cinemachine package to create both of the dynamic
    cameras that will follow the player's movements, which we will code in *Part 3*,
    and also, the cameras to be used during cutscenes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Cinemachine软件包创建两个动态摄像机，这些摄像机将跟随玩家的动作，我们将在*第3部分*中编写，并且还将用于过场动画中使用的摄像机。
- en: 'In this section, we will examine the following Cinemachine concepts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下Cinemachine概念：
- en: Creating camera behaviors
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建摄像机行为
- en: Creating dolly tracks
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建摄影机轨道
- en: Let's start by discussing how to create a Cinemachine controlled camera and
    configure behaviors in it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论如何创建一个Cinemachine控制的摄像机，并在其中配置行为。
- en: Creating camera behaviors
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建摄像机行为
- en: Cinemachine is a collection of different behaviors that can be used in the camera,
    which when properly combined can generate all kinds of common camera types in
    video games, including following the player from behind, first-person cameras,
    top-down cameras, and so on. In order to use these behaviors, we need to understand
    the concept of brain and virtual cameras.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine是一组不同的行为，可以用于摄像机中，当正确组合时可以生成各种常见的视频游戏摄像机类型，包括从后面跟随玩家，第一人称摄像机，俯视摄像机等。为了使用这些行为，我们需要了解大脑和虚拟摄像机的概念。
- en: In Cinemachine, we will only keep one main camera, as we have done so far, and
    that camera will be controlled by virtual cameras, separated GameObjects that
    have the previously mentioned behaviors. We can have several virtual cameras and
    swap between them at will, but the active virtual camera will be the only one
    that will control our main camera. This is useful for switching cameras at different
    points of the game, such as switching between our player's first-person camera.
    In order to control the main camera with the virtual cameras, it must have a **Brain**
    component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cinemachine中，我们将只保留一个主摄像机，就像我们迄今为止所做的那样，该摄像机将由虚拟摄像机控制，这些虚拟摄像机是分开的游戏对象，具有先前提到的行为。我们可以有几个虚拟摄像机，并且可以随意在它们之间切换，但是活动虚拟摄像机将是唯一控制我们主摄像机的摄像机。这对于在游戏的不同点之间切换摄像机非常有用，例如在我们玩家的第一人称摄像机之间切换。为了使用虚拟摄像机控制主摄像机，它必须具有**Brain**组件。
- en: 'To start using Cinemachine, first, we need to install it from the Package Manager,
    as we did previously with other packages. If you don''t remember how to do this,
    just do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Cinemachine，首先我们需要从软件包管理器中安装它，就像我们之前安装其他软件包一样。如果您不记得如何做到这一点，只需执行以下操作：
- en: Go to **Window** | **Package Manager**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**窗口** | **软件包管理器**。
- en: Ensure that the **Packages** option in the top-left part of the window is set
    to **Unity Registry**:![Figure 12.22 – The Packages filter mode
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保窗口左上角的**软件包**选项设置为**Unity Registry**：![图12.22 – 软件包过滤模式
- en: '](img/Figure_12.22_B14199.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.22_B14199.jpg)'
- en: Figure 12.22 – The Packages filter mode
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – 软件包过滤模式
- en: Wait a moment for the left panel to populate all packages from the servers (internet
    is required).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待左侧面板从服务器中填充所有软件包（需要互联网）。
- en: Look for the **Cinemachine** package from the list and select it. At the moment
    of writing this book, we are using Cinemachine 2.6.0.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找列表中的**Cinemachine**软件包并选择它。在撰写本书时，我们使用的是Cinemachine 2.6.0。
- en: Click the **Install** button in the bottom-right corner of the screen.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击屏幕右下角的**安装**按钮。
- en: 'Let''s start creating a virtual camera to follow the character we animated
    previously, which will be our player hero. Do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个虚拟摄像机来跟随我们之前制作的角色，这将是我们的玩家英雄。执行以下操作：
- en: Click `CM vcam1`:![Figure 12.23 – Virtual camera creation
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`CM vcam1`：![图12.23 – 虚拟摄像机创建
- en: '](img/Figure_12.23_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.23_B14199.jpg)'
- en: Figure 12.23 – Virtual camera creation
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – 虚拟摄像机创建
- en: If you select the main camera from the `CinemachineBrain` component has been
    automatically added to it, making our main camera follow the virtual camera. Try
    to move the created virtual camera, and you will see how the main camera follows
    it:![Figure 12.24 – The CinemachineBrain component
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您从`CinemachineBrain`组件中选择了主摄像机，那么我们的主摄像机将自动添加到其中，使我们的主摄像机跟随虚拟摄像机。尝试移动创建的虚拟摄像机，您将看到主摄像机如何跟随它：![图12.24
    – CinemachineBrain组件
- en: '](img/Figure_12.24_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.24_B14199.jpg)'
- en: Figure 12.24 – The CinemachineBrain component
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – CinemachineBrain组件
- en: Select the virtual camera and drag the character to the **Follow** and **Look
    At** properties of the Cinemachine virtual camera component. This will make the
    movement and looking behaviors use that object to do their jobs:![Figure 12.25
    – Setting the target of our camera
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择虚拟摄像机，并将角色拖动到Cinemachine虚拟摄像机组件的**跟随**和**看向**属性中。这将使移动和观察行为使用该对象来完成它们的工作：![图12.25
    – 设置我们摄像机的目标
- en: '](img/Figure_12.25_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.25_B14199.jpg)'
- en: Figure 12.25 – Setting the target of our camera
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 设置我们摄像机的目标
- en: You can see how the `0`, `3`, and `-3`) values:![Figure 12.26 – The camera following
    the character from behind
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到`0`，`3`和`-3`）值：![图12.26 – 摄像机从后面跟随角色
- en: '](img/Figure_12.26_B14199.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.26_B14199.jpg)'
- en: Figure 12.26 – The camera following the character from behind
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 – 摄像机从后面跟随角色
- en: '*Figure 12.26* shows the `0`, `1.5`, and `0` worked well to make the camera
    look at the chest instead:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图12.26显示`0`，`1.5`和`0`很好地使摄像机看向胸部：
- en: '![Figure 12.27 – Changing the Aim offset'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.27 – 改变瞄准偏移'
- en: '](img/Figure_12.27_B14199.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.27_B14199.jpg)'
- en: Figure 12.27 – Changing the Aim offset
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – 改变瞄准偏移
- en: 'As you can see, using Cinemachine is pretty simple, and in our case, the default
    settings were mostly enough for the kind of behavior we needed. However, if you
    explore the other **Body** and **Aim** modes, you will find that you can create
    any type of camera for any type of game. We won''t cover the other modes in this
    book, but I strongly recommend you look at the documentation for Cinemachine to
    check what the other modes do. To open the documentation, do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用Cinemachine非常简单，在我们的情况下，默认设置大多已经足够满足我们需要的行为。但是，如果您探索其他**Body**和**Aim**模式，您会发现您可以为任何类型的游戏创建任何类型的摄像机。我们不会在本书中涵盖其他模式，但我强烈建议您查看Cinemachine的文档，以了解其他模式的功能。要打开文档，请执行以下操作：
- en: Open the Package Manager by going to **Window** | **Package Manger**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**窗口** | **包管理器**来打开包管理器。
- en: Find **Cinemachine** in the left-hand side list. Wait a moment if it doesn't
    show up. Remember that you need an internet connection for it to work.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中找到**Cinemachine**。如果没有显示，请稍等一会。请记住，您需要互联网连接才能使用它。
- en: Once **Cinemachine** is selected, look for the **View documentation** link in
    blue. Click on it:![Figure 12.28 – The Cinemachine documentation link
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了**Cinemachine**，请查找蓝色的**查看文档**链接。单击它：![图12.28 - Cinemachine文档链接
- en: '](img/Figure_12.28_B14199.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.28_B14199.jpg)'
- en: Figure 12.28 – The Cinemachine documentation link
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 - Cinemachine文档链接
- en: 'You can explore the documentation using the navigation menu on the left:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用左侧的导航菜单来探索文档：
- en: '![Figure 12.29 – The Cinemachine documentation'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.29 - Cinemachine文档'
- en: '](img/Figure_12.29_B14199.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.29_B14199.jpg)'
- en: Figure 12.29 – The Cinemachine documentation
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29 - Cinemachine文档
- en: As you did with Cinemachine, you can find other packages' documentation in the
    same way. Now that we have achieved the basic camera behavior that we need, let's
    explore how we can use Cinemachine to create a camera for our intro cutscene.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您在Cinemachine中所做的那样，您也可以以同样的方式找到其他软件包的文档。现在我们已经实现了我们需要的基本摄像机行为，让我们探索如何使用Cinemachine为我们的开场动画创建摄像机。
- en: Creating dolly tracks
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建推车轨道
- en: When the player starts the level, we want a little cutscene with a pan over
    our scene and the base before entering the battle. This will require the camera
    to follow a fixed path, and that's exactly what Cinemachine's dolly camera does.
    It creates a path where we can attach a virtual camera so that it will follow
    it. We can set Cinemachine to move automatically through the track or follow a
    target to the closest point to the track; in our case, we will use the first option.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始关卡时，我们希望有一个小的过场动画，展示我们的场景和战斗之前的基地。这将需要摄像机沿着固定路径移动，这正是Cinemachine的推车摄像机所做的。它创建了一个我们可以附加虚拟摄像机的路径，以便它会跟随它。我们可以设置Cinemachine自动沿着轨道移动或者跟随目标到轨道最近的点；在我们的情况下，我们将使用第一个选项。
- en: 'In order to create a dolly camera, do the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建推车摄像机，请执行以下操作：
- en: Let's start creating the track with a cart, which is a little object that will
    move along the track, which will be the target to follow the camera. To do this,
    click on **Cinemachine** | **Create Dolly Track with Cart**:![Figure 12.30 – A
    dolly camera with a default straight path
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始用一个推车创建轨道，这是一个小物体，将沿着轨道移动，这将是摄像机跟随的目标。要做到这一点，请单击**Cinemachine** | **创建带有推车的推车轨道**：![图12.30
    - 默认直线路径的推车摄像机
- en: '](img/Figure_12.30_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.30_B14199.jpg)'
- en: Figure 12.30 – A dolly camera with a default straight path
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30 - 默认直线路径的推车摄像机
- en: If you select the `DollyTrack1` object, you can see two circles with the numbers
    `0` and `1`. These are the control points of the track. Select one of them and
    move it as you move other objects using the arrows of the translation gizmo.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选择`DollyTrack1`对象，您可以看到两个带有数字`0`和`1`的圆圈。这些是轨道的控制点。选择其中一个并像移动其他对象一样移动它，使用平移图标的箭头。
- en: You can create more control points by clicking the `CinemachineSmoothPath` component
    of the `DollyTrack1` object:![Figure 12.31 – Adding a path control point
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过单击`DollyTrack1`对象的`CinemachineSmoothPath`组件来创建更多的控制点：![图12.31 - 添加路径控制点
- en: '](img/Figure_12.31_B14199.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.31_B14199.jpg)'
- en: Figure 12.31 – Adding a path control point
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 - 添加路径控制点
- en: Create as many waypoints as you need to create a path that will traverse the
    areas you want the camera to oversee in the intro cutscene. Remember, you can
    move the waypoints by clicking on them and using the translation gizmo:![Figure
    12.32 – A dolly track for our scene. It ends right behind the character
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建尽可能多的航点，以创建一个将在开场动画中遍历您希望摄像机监视的区域的路径。请记住，您可以通过单击它们并使用平移图标来移动航点：![图12.32 -
    我们场景中的推车轨道。它在角色的后面结束
- en: '](img/Figure_12.32_B14199.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.32_B14199.jpg)'
- en: Figure 12.32 – A dolly track for our scene. It ends right behind the character
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 - 我们场景中的推车轨道。它在角色的后面结束
- en: Create a new virtual camera. If you go to the **Game** view after creating it,
    you will notice that the character camera will be active. In order to test how
    the new camera looks, select it and click on the **Solo** button in the Inspector
    window:![Figure 12.33 – The Solo button to temporarily enable this virtual camera
    while editing
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟摄像机。创建后，如果您转到**游戏**视图，您会注意到角色摄像机将处于活动状态。为了测试新摄像机的外观，选择它并在检查器窗口中单击**独奏**按钮：![图12.33
    - 在编辑时临时启用虚拟摄像机的“独奏”按钮
- en: '](img/Figure_12.33_B14199.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.33_B14199.jpg)'
- en: Figure 12.33 – The Solo button to temporarily enable this virtual camera while
    editing
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 - 在编辑时临时启用虚拟摄像机的“独奏”按钮
- en: Set the `DollyCart1` object that we previously created with the track.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们之前使用轨道创建的`DollyCart1`对象。
- en: Set `0`, `0`, and `0` to keep the camera in the same position as the cart.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`，`0`和`0`设置为使摄像机保持在与推车相同的位置。
- en: Set **Aim** to **Same As Follow Target** to make the camera look in the same
    direction as the cart, which will follow the track curves:![Figure 12.34 – Configuration
    to make the virtual camera follow the dolly track
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Aim**设置为**与跟随目标相同**，使摄像机朝着相同的方向看，这将跟随轨道曲线：![图12.34 - 配置以使虚拟摄像机跟随推车轨道
- en: '](img/Figure_12.34_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.34_B14199.jpg)'
- en: Figure 12.34 – Configuration to make the virtual camera follow the dolly track
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34 – 配置使虚拟相机跟随推车轨道
- en: 'Select the **DollyCart1** object and change the **Position** value to see how
    the cart moves along the track. Do this while the game window is focused and **CM
    vcam2** is in solo mode to see how the camera will look:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**DollyCart1**对象，并更改**位置**值，以查看推车沿着轨道移动的情况。在游戏窗口聚焦且**CM vcam2**处于独立模式时执行此操作，以查看相机的外观：
- en: '![Figure 12.35 – The Dolly Cart component'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.35 – 推车组件'
- en: '](img/Figure_12.35_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.35_B14199.jpg)'
- en: Figure 12.35 – The Dolly Cart component
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35 – 推车组件
- en: With the dolly track properly set, we can create our cutscene using **Timeline**
    to sequence it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确设置的推车轨道，我们可以使用**时间轴**来创建我们的剧情场景。
- en: Creating cutscenes with Timeline
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间轴创建剧情场景
- en: We have our intro camera, but that's not enough to create a cutscene. A proper
    cutscene is a sequence of actions happening at the exact moment that they should
    happen, coordinating several objects to act as intended. We can have actions such
    as enabling and disabling objects, switching cameras, playing sounds, moving objects,
    and so on. To do this, Unity offers **Timeline**, which is a sequencer of actions
    to coordinate that kind of cutscenes. We will use **Timeline** to create an intro
    cutscene for our scene, showing the level before starting the game.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的开场相机，但这还不足以创建一个剧情场景。一个合适的剧情场景是一系列在应该发生的确切时刻发生的动作，协调多个对象以按预期方式行动。我们可以有启用和禁用对象、切换相机、播放声音、移动对象等动作。为此，Unity提供了**时间轴**，这是一个协调这种类型剧情场景的动作的序列器。我们将使用**时间轴**为我们的场景创建一个开场剧情，展示游戏开始前的关卡。
- en: 'In this section, we will examine the following Timeline concepts:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下时间轴概念：
- en: Creating animation clips
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: Sequencing our intro cutscene
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排我们的开场剧情
- en: We are going to see how to create our own animation clips in Unity to animate
    our GameObjects and then place them inside a cutscene to coordinate their activation
    using the Timeline sequencer tool. Let's start creating a camera animation to
    use later in Timeline.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Unity中创建自己的动画剪辑，以动画我们的游戏对象，然后将它们放入一个剧情场景中，使用时间轴序列工具协调它们的激活。让我们开始创建一个相机动画，以便稍后在时间轴中使用。
- en: Creating animation clips
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: This is actually not a Timeline-specific feature, but rather a Unity feature
    that works great with Timeline. When we downloaded the character, it came with
    animation clips that were created using external software, but you can create
    custom animation clips using Unity's **Animation** window. Don't confuse it with
    the **Animator** window, which allows us to create animation transitions that
    react to the game situation. This is useful to create small object-specific animations
    that you will coordinate later in Timeline with other objects' animations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是时间轴特定的功能，而是一个与时间轴很好配合的Unity功能。当我们下载角色时，它带有使用外部软件创建的动画剪辑，但您可以使用Unity的**动画**窗口创建自定义动画剪辑。不要将其与**动画师**窗口混淆，后者允许我们创建根据游戏情况做出反应的动画过渡。这对于创建您稍后将在时间轴中与其他对象的动画协调的小对象特定动画非常有用。
- en: 'These animations can control any value of an object''s component properties,
    such as the positions, colors, and so on. In our case, we want to animate the
    dolly track''s **Position** property to make it go from start to finish in a given
    time. In order to this, do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画可以控制对象组件属性的任何值，例如位置、颜色等。在我们的情况下，我们想要动画推车轨道的**位置**属性，使其在给定时间内从起点到终点。为了做到这一点，请执行以下操作：
- en: Select the `DollyCart1` object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DollyCart1`对象。
- en: Open the **Animation** (not **Animator**) window by going to **Window** | **Animation**
    | **Animation**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**动画**（而不是**动画师**）窗口，方法是转到**窗口** | **动画** | **动画**。
- en: Click on the **Create** button at the center of the **Animation** window. Remember
    to do this while the dolly cart (not track) is selected:![Figure 12.36 – Creating
    a custom animation clip
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**动画**窗口中心的**创建**按钮。记住在选择推车（而不是轨道）时执行此操作：![图12.36 – 创建自定义动画剪辑
- en: '](img/Figure_12.36_B14199.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.36_B14199.jpg)'
- en: Figure 12.36 – Creating a custom animation clip
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36 – 创建自定义动画剪辑
- en: After doing this, you will be prompted to save the animation clip somewhere.
    I recommend you create an `Animations` folder in the project (inside the `Assets`
    folder) and call it `IntroDollyTrack`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，系统将提示您在某个位置保存动画剪辑。我建议您在项目中（在`Assets`文件夹内）创建一个`Animations`文件夹，并将其命名为`IntroDollyTrack`。
- en: If you pay attention, the dolly cart now has an **Animator** component with
    an Animator Controller created, which contains the animation we just created.
    As with any animation clip, you need to apply it to your object with an Animator
    Controller; custom animations are no exception. So, the **Animation** window created
    them for you.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，推车现在有一个带有创建的动画控制器的**动画师**组件，其中包含我们刚刚创建的动画。与任何动画剪辑一样，您需要将其应用到具有动画控制器的对象上；自定义动画也不例外。所以，**动画**窗口为您创建了它们。
- en: Animating in this window consists of specifying the value of its properties
    at given moments. In our case, we want `0` at the beginning of the animation at
    the second 0 at the timeline, and have a value of `240` at the end of the animation
    at second `5`. I chose `240` because that's the last possible position in my cart,
    but that depends on the length of your dolly track. Just test which is the last
    possible position in yours. Also, I chose the second `5` because that's what I
    feel is the correct length for the animation, but feel free to change it as you
    wish. Now, whatever happens between the animation's `0` and `5` seconds is an
    interpolation of the `0` and `240` values, meaning that in `2.5` seconds, the
    value of `120`. Animating always consists of interpolating different states of
    our object at different moments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口中进行动画操作包括在给定时刻指定其属性的值。在我们的情况下，我们希望在动画的开始时在时间轴的第0秒处为`0`，并在动画结束时在第`5`秒处为`240`。我选择了`240`，因为这是我的手推车的最后可能位置，但这取决于您的手推车轨道的长度。只需测试一下您的最后可能位置是什么。此外，我选择第`5`秒，因为我觉得这是动画的正确长度，但随时可以根据需要进行更改。现在，在动画的`0`和`5`秒之间发生的任何事情都是`0`和`240`值的插值，这意味着在`2.5`秒时，值为`120`。动画始终包括在不同时刻对对象的不同状态进行插值。
- en: 'In order to do this, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，执行以下操作：
- en: In the **Animation** window, click on the record button (the red circle in the
    top-left section). This will make Unity detect any changes in our object and save
    it to the animation. Remember to do this while you have selected the dolly cart.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，单击记录按钮（位于左上角的红色圆圈）。这将使Unity检测对象的任何更改并将其保存到动画中。记得在选择手推车时进行此操作。
- en: Set the `1` and then `0`. Changing this to any value and then to `0` again will
    create a keyframe, which is a point in the animation that says that at `0` seconds,
    we want the `0`. We need to set it first to any other value if the value is already
    at `0`. You will notice that the **Position** property has been added to the animation:![Figure
    12.37 – The animation in Record mode after changing the Position value to 0
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`1`，然后设置为`0`。将其更改为任何值，然后再次更改为`0`将创建一个关键帧，这是动画中的一个点，表示在`0`秒时，我们希望`0`。如果值已经为`0`，则首先将其设置为任何其他值。您会注意到**位置**属性已添加到动画中：![图12.37
    - 在将位置值更改为0后，记录模式下的动画
- en: '](img/Figure_12.37_B14199.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.37_B14199.jpg)'
- en: Figure 12.37 – The animation in Record mode after changing the Position value
    to 0
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37 - 在将位置值更改为0后，记录模式下的动画
- en: Using the mouse scroll wheel, zoom out the timeline to the right of the `5`
    seconds in the top bar:![Figure 12.38 – The timeline of the Animation window showing
    5 seconds
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标滚轮，将时间轴向右缩小到顶部栏的`5`秒：![图12.38 - 显示5秒的动画窗口时间轴
- en: '](img/Figure_12.38_B14199.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.38_B14199.jpg)'
- en: Figure 12.38 – The timeline of the Animation window showing 5 seconds
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38 - 显示5秒的动画窗口时间轴
- en: Click on the `5` second label in the top bar of the timeline to position the
    playback header at that moment. This will locate the next change we do at that
    moment.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击时间轴顶部的`5`秒标签，将播放头定位到该时刻。这将定位我们在该时刻进行的下一个更改。
- en: Set the `240`. Remember to have the **Animation** window in **Record** mode:![Figure
    12.39 – Creating a keyframe with the 240 value at second 5 of the animation
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`240`。记得将**动画**窗口设置为**记录**模式：![图12.39 - 在动画的第5秒创建一个值为240的关键帧
- en: '](img/Figure_12.39_B14199.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.39_B14199.jpg)'
- en: Figure 12.39 – Creating a keyframe with the 240 value at second 5 of the animation
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39 - 在动画的第5秒创建一个值为240的关键帧
- en: Hit the play button in the top-left section of the `CM vcam2` is in solo mode.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`CM vcam2`左上角的播放按钮，它处于独奏模式。
- en: 'Now, if we hit play, the animation will start playing, but that''s something
    we don''t want. In this scenario, the idea is to give control of the cutscene
    to the cutscene system, Timeline, because this animation won''t be the only thing
    that needs to be sequenced in our cutscene. One way to prevent the **Animator**
    component from automatically playing the animation we created is to create an
    empty animation state in the Controller and set it as the default state by doing
    the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击播放，动画将开始播放，但这并不是我们想要的。在这种情况下，想法是将过场动画的控制权交给过场动画系统Timeline，因为这个动画不是我们需要在过场动画中进行排序的唯一内容。防止**Animator**组件自动播放我们创建的动画的一种方法是在控制器中创建一个空动画状态，并通过以下方式将其设置为默认状态：
- en: Search the Animator Controller that we created when we created the animation
    and open it. If you can't find it, just select the dolly cart and double-click
    on the **Controller** property of the **Animator** component on our Game Object
    to open the asset.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们创建动画时创建的动画控制器并打开它。如果找不到它，只需选择手推车，然后双击我们游戏对象的**Animator**组件的**Controller**属性以打开资产。
- en: Right-click on an empty state in the Controller and select **Create State**
    | **Empty**. This will create a new state in the state machine as if we created
    a new animation, but it is empty this time:![Figure 12.40 – Creating an empty
    state in the Animator Controller
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中的空状态上右键单击，然后选择**创建状态** | **空**。这将在状态机中创建一个新状态，就好像我们创建了一个新动画，但这次是空的：![图12.40
    - 在动画控制器中创建一个空状态
- en: '](img/Figure_12.40_B14199.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.40_B14199.jpg)'
- en: Figure 12.40 – Creating an empty state in the Animator Controller
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.40 - 在动画控制器中创建一个空状态
- en: Right-click on **New State** and click on **Set as Layer Default State**. The
    state should become orange:![Figure 12.41 – Changing the default animation of
    the Controller to an empty state
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**新状态**，然后单击**设置为层默认状态**。状态应变为橙色：![图12.41 - 将控制器的默认动画更改为空状态
- en: '](img/Figure_12.41_B14199.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.41_B14199.jpg)'
- en: Figure 12.41 – Changing the default animation of the Controller to an empty
    state
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41 - 将控制器的默认动画更改为空状态
- en: Now, if you hit play, no animation will play as the default state of our dolly
    cart is empty.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果点击播放，由于我们手推车的默认状态为空，不会播放任何动画。
- en: Now that we have created our camera animation, let's start creating a cutscene
    that switches from the intro cutscene camera to the player camera by using Timeline.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Sequencing our intro cutscene
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Timeline is already installed in your project, but if you go to the Package
    Manager of Timeline, you may see an **Update** button to get the latest version
    if you need some of the new features. In our case, we will keep the default version
    included in our project (1.3.4, at the time of writing this book).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is create a cutscene asset and an object in the
    scene responsible for playing it. To do this, follow these steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty GameObject using the **GameObject** | **Create Empty** option.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the empty object and call it `Director`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Window** | **Sequencing** | **Timeline** to open the **Timeline** editor.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button in the middle of the **Timeline** window while the
    **Director** object is selected to convert that object into the cutscene player
    (or director).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After doing this, a window will pop up asking you to save a file. This file
    will be the cutscene or timeline; each cutscene will be saved in its own file.
    Save it in a `Cutscenes` folder in your project (the `Assets` folder).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can see that the **Director** object has a **Playable Director** component
    with the **Intro** cutscene asset saved in the previous step set for the **Playable**
    property, meaning this cutscene will be played by the director:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.42 – Playable Director prepared to play the Intro Timeline asset'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.42_B14199.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.42 – Playable Director prepared to play the Intro Timeline asset
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Timeline asset ready to work with, let's make it sequence
    actions. To start, we need to sequence two things—first, the cart position animation
    we did in the last step and then the camera swap between the dolly track camera
    (**CM vcam2**) and the player cameras (**CM vcam1**). As we said before, a cutscene
    is a sequence of actions executing at given moments, and in order to schedule
    actions, you will need tracks. In Timeline, we have different kinds of tracks,
    each one allowing you to execute certain actions on certain objects. We will start
    with the animation track.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The animation track will control which animation a specific object will play;
    we need one track per object to animate. In our case, we want the dolly track
    to play the **Intro** animation that we created, so let''s do that doing the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Create an Animation Track doing right click in the left part of the Timeline
    editor and clicking Animation Track:![Figure 12.43 – Creating Animation Track
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.43_B14199.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.43 – Creating Animation Track
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Director** object and check the **Bindings** list of the **Playable
    Director** component in the Inspector window.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Cart** object to specify that we want the animation track to control
    its animation:![Figure 12.44 – Making the animation track control the dolly cart
    animation in this director
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.44_B14199.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.44 – Making the animation track control the dolly cart animation in
    this director
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Timeline is a generic asset that can be applied to any scene, but as the tracks
    control specifics objects, you need to manually bind them in every scene. In our
    case, we have an animation track that expects to control a single animator, so
    in every scene, if we want to apply this cutscene, we need to drag the specific
    animator to control in the **Bindings** list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Drag the **Intro** animation asset that we created to the animation track in
    the **Timeline** window. This will create a clip in the track showing when and
    for how long the animation will play. You can drag many animations that the cart
    can play into the track to sequence different animations at different moments;
    but right now, we want just that one:![Figure 12.45 – Making the animator track
    play the intro clip
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.45_B14199.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.45 – Making the animator track play the intro clip
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: You can drag the animation to change the exact moment you want it to play. Drag
    it to the beginning of the track.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit the Play button in the top-left part of the **Timeline** window to see
    it in action. You can also manually drag the white arrow in the **Timeline** window
    to view the cutscene at different moments:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.46 – Playing a timeline and dragging the playback header'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.46_B14199.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.46 – Playing a timeline and dragging the playback header
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you don't need to use Timeline to play animations. In this case,
    we did it this way to control at exactly which moment we want the animation to
    play. You can control animators using scripting as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will make our Intro timeline asset tell the `CinemachineBrain` component
    (the main camera) which camera will be active during each part of the cutscene,
    switching to the player camera once the camera animation is over. We will create
    a second track—a Cinemachine track—which is specialized in making a specific `CinemachineBrain`
    component to switch between different virtual cameras. To do this, follow these
    steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the empty space below the animation track and click on **Cinemachine
    Track**. Note that you can install Timeline without Cinemachine, but this kind
    of track won't show up in that case:![Figure 12.47 – Creating a new Cinemachine
    Track
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.47_B14199.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.47 – Creating a new Cinemachine Track
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the **Playable Director** component's **Bindings** list, drag the main camera
    to **Cinemachine Track** to make that track control which virtual camera will
    be the one that controls the main camera at different moments of the cutscene:![Figure
    12.48 – Making the Cinemachine Track control our Scene's Main Camera
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.48_B14199.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.48 – Making the Cinemachine Track control our Scene's Main Camera
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The next step indicates which virtual camera will be active during specific
    moments of the timeline. To do so, our Cinemachine Track allows us to drag virtual
    cameras to it, which will create virtual camera clips. Drag both **CM vcam2**
    and **CM vcam1**, in that order, to the Cinemachine Track:![Figure 12.49 – Dragging
    virtual cameras to the Cinemachine Track
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.49_B14199.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.49 – Dragging virtual cameras to the Cinemachine Track
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: If you hit the play button or just drag the **Timeline Playback** header, you
    can see how the active virtual camera changes when the playback header reaches
    the second virtual camera clip. Remember to view this in the **Game** view.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you place the mouse near the ends of the clips, a resize cursor will show
    up. If you drag them, you can resize the clips to specify their duration. In our
    case, we will need to match the length of the **CM vcam2** clip to the **Cart**
    animation clip and then put **CM vcam1** at the end of it by dragging it so that
    the camera will be active when the dolly cart animation ends. In my case, they
    were already the same length, but just try to change it anyway to practice. Also,
    you can make the **CM vcam1** clip be shorter; we just need that to play it for
    a few moments to execute the camera swap.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also overlap the clips a little bit to make a smooth transition between
    the two cameras, instead of a hard switch, which will look odd:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.50 – Resizing and overlapping clips to interpolate them'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.50_B14199.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.50 – Resizing and overlapping clips to interpolate them
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If you wait for the full cutscene to end, you will notice how at the very end,
    `CinemachineBrain` component, which will pick the virtual camera with the highest
    **Priority** value. We can change the **Priority** property of the virtual cameras
    to be sure that **CM vcam1** (the player camera) is always the more important
    one, or set **Wrap Mode** of the **Playable Director** component to **Hold**,
    which will keep everything, as the last frame of the timeline specifies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will use the latter option to test the Timeline-specific features:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.51 – Wrap Mode set to the Hold mode'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.51_B14199.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.51 – Wrap Mode set to the Hold mode
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Most of the different kinds of tracks work under the same logic; each one will
    control a specific aspect of a specific object using clips that will execute during
    a set time. I encourage you to test different tracks to see what they do, such
    as **Activation**, which enables and disables objects during the cutscene. Remember,
    you can check out the documentation of the Timeline package in the Package Manager.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the different animation systems that Unity provides
    for different requirements. We discussed importing character animations and controlling
    them with Animation Controllers. We also saw how to make cameras that can react
    to the game's current situation, such as the player's position, or that can used
    during cutscenes. Finally, we looked at Timeline and the animation system to create
    an intro cutscene for our game. These tools are useful for making the animators
    in our team work directly in Unity without the hassle of integrating external
    assets (except for character animations) and also preventing the programmer from
    creating repetitive scripts to create animations, wasting time in the process.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are able to import and create animation clips in Unity, as well as
    apply them to GameObjects to make them move according the clips. Also, you can
    place them in the Timeline sequencer to coordinate them and create cutscenes for
    your game. Finally, you can create dynamic cameras to use in-game or in cutscenes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed lots of Unity systems that allow us to develop different
    aspects of our game without coding, but sooner or later, scripting will be needed.
    Unity provides generic tools for generic situations, but our game's unique gameplay
    must usually be coded manually. In the next chapter, the first chapter of *Part
    3*, we will start learning how to code in Unity using C#.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
