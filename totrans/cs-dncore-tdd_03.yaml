- en: Writing Testable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](2cce7b7c-f5dc-4ad0-b6b8-940ef3dafd3a.xhtml), *Exploring Test-Driven
    Development*, pitfalls that should be avoided when writing code to prevent code
    smell were explained. While writing good code is in itself an art, the process
    of writing code that can be efficiently tested requires extra efforts and commitment
    on the part of the developers to write clean code that can be repeatedly tested
    without any hassle.
  prefs: []
  type: TYPE_NORMAL
- en: It is true that practicing TDD improves code production and encourages writing
    good code that is robust and maintainable. Nevertheless, time spent doing TDD
    can be wasted and the technique's return on investment might not be obtained if
    developers involved in software projects write code that is untestable. This can
    usually be traced to the use of bad code design architecture and not adequately
    or effectively using object-oriented design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests is as important as writing the main code. It is stressful and
    really difficult writing tests for code that is untestable, which is the reason
    why untestable code should be avoided in the first place. Code can be untestable
    for different reasons, such as when the code does too much (**Monster Code**),
    it violates the single responsibility principle, there is wrong use of architecture,
    or faulty object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning signs when writing untestable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Law of Demeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SOLID architecture principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up DI Container for ASP.NET Core MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning signs when writing untestable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effective and continuous practice of TDD can improve the code-writing process,
    making testing easier, which results in improved code quality and robust software
    application. However, when a project's code base contains portions of codes that
    are untestable, writing unit or integration tests becomes extremely difficult
    or nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Software development teams cannot emphatically validate the consistent behavior
    of the functionalities and features of an application when there is untestable
    code in a software project's code base. To avoid this preventable situation, writing
    code that is testable is not an option but a must for every serious development
    team that values quality software.
  prefs: []
  type: TYPE_NORMAL
- en: Untestable code results from the violation of common standards, practices, and
    principles that have been proven and tested to improve the quality of code. While
    professionalism comes with repeated use of good practices and experience, there
    are some common bad code designs and writing approaches that are common sense
    even to a beginner, such as the use of global variables when not required, tight
    coupling of code, hard-coding dependencies, or values that can change in code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss some common anti-patterns and pitfalls that
    you should watch out for when writing code as they can make writing tests for
    your production code difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Coupling** is the extent to which objects depend on or are closely related
    to one another. To explain this further, when a `LoanProcessor` class is tightly
    coupled to `EligibilityChecker`, changing the latter can affect the behavior or
    modify the state of the former.'
  prefs: []
  type: TYPE_NORMAL
- en: The majority of untestable code is usually a result of inherent dependencies
    scattered in different portions of the codes, usually through the use of concrete
    implementations of dependencies causing a mixing of concerns that otherwise should
    be separated across application boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing code with tightly coupled dependencies will lead to testing the
    different objects that are tightly coupled. Dependencies that should ideally be
    easy to mock when injected into the constructor, during unit testing will not
    be possible. This can often slow down the overall testing process as all the dependencies
    would have to be constructed in the code under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `LoanProcessor` is tightly coupled to `EligibilityChecker`.
    This is because `EligibilityChecker` has been instantiated with the new keyword
    in the `LoanProcessor` constructor. Changes made to `EligibilityChecker` will
    affect `LoanProcessor`, which can cause it to break. Also, unit testing any method
    contained in `LoanProcessor` will always cause `EligibilityChecker` to be constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An approach to resolve the tight coupling in `LoanProcessor` is through the
    use of **Dependency Injection** (**DI**). Since `LoanProcessor` cannot be tested
    in isolation, as `EligibilityChecker` object will have to be instantiated in the
    constructor, `EligibilityChecker` will be injected into `LoanProcessor`, through
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With `EligibilityChecker` injected, testing `LoanProcessor` becomes easier as
    this allows you to write a test where you mock the implementation of `EligibilityChecker`,
    allowing you to test `LoanProcessor` in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, `EligibilityChecker` can be injected through properties or members
    of the `LoanProcessor` class instead of passing the dependency through the `LoanProcessor`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the dependency injected either through the constructor or property, `LoanProcessor`
    and `EligibilityChecker` have now become loosely coupled, thereby making the writing
    of unit tests and mocking `EligibilityChecker` easy.
  prefs: []
  type: TYPE_NORMAL
- en: To make a class loosely coupled and testable, you have to ensure that the class
    does not instantiate other classes and objects. Instantiating objects inside constructors
    or methods of a class can result in preventing the injection of mock or dummy
    objects while attempting to get the code under a test harness.
  prefs: []
  type: TYPE_NORMAL
- en: Monster Constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test a method, you have to instantiate or construct the class containing
    the method. The most common mistake developers make is to create what I call **Monster
    Constructor**, which is simply a constructor that does too much work or real work,
    such as performing I/O operations, database calls, static initialization, reading
    some large files, or establishing communication with external services.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a class designed with a constructor that initializes or instantiates
    objects other than value objects (list, array, and dictionary), the class technically
    has a nonflexible structure. This is a bad class design because the class automatically
    becomes strongly tied to the classes it is instantiating, making unit testing
    difficult. Any class with this design also violates the single responsibility
    principle, because the creation of an object graph is a responsibility that can
    be delegated to another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing methods in a class with a constructor that does a great deal of work
    comes with great costs. In essence, to test the methods in a class with the preceding
    design, you are compelled to go through the pain of creating the dependent objects
    in the constructor. If the dependent object makes a database call when constructed,
    this call will be repeated each time a method in that class is tested, making
    testing slow and painful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, the object graph construction is being done in
    the `LoanProcessor` constructor, which will definitely make the class difficult
    to test. It is a good practice to have a lean constructor, that does little work
    and has little knowledge of other objects, especially what they can do but not
    how they do it.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes developers use a test hack, which involves creating multiple constructors
    for a class. One of the constructors will be designated as a test-only constructor.
    While using this approach can allow the class to be tested in isolation, there
    is a bad side to it. For example, the class created with multiple constructors
    can have other classes referencing it and instantiating it using the constructor
    that does a lot of work. This can make testing those dependent classes very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet illustrates the bad design of creating a separate
    constructor solely for the purpose of testing the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are important warning signs that can aid you in designing a loosely coupled
    class with a constructor that does little work. Avoid the use of the `new` operators
    in the constructor, to allow the injection of dependent objects. You should initialize
    and assign to the appropriate fields all objects injected through the constructor.
    Lightweight value objects instantiation should also be done in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, avoid static method calls, this is because static calls cannot be injected
    or mocked.  Also, the use of iterations or conditional logic inside the constructor
    should be avoided; each time the class is tested, the logic or loop will be executed,
    causing excessive overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Design your class with testing in mind, don't create dependent objects or collaborators
    in the constructor. When your classes need to be dependent on other classes, inject
    the dependencies. Ensure the creation of value objects only. When you create object
    graphs in your code, use *factory methods* to achieve this. Factory methods are
    used for creating objects.
  prefs: []
  type: TYPE_NORMAL
- en: Classes with more than one responsibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, a class should have only one responsibility. When you design your class
    with more than one responsibility, it is possible to have interactions between
    responsibilities in the class that will make code modifications difficult and
    testing the interactions in isolation nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: There are indicators that can clearly point out that a class is doing too much
    and has more than one responsibility. For example, when you are struggling with
    giving a class a name and you probably end up with the word `and` in the class
    name, it's a clue that the class does too much.
  prefs: []
  type: TYPE_NORMAL
- en: Another sign of a class with multiple responsibilities is when the fields in
    the class are used only in some methods or when the class has static methods that
    operate only on parameters and not on the class fields. Additionally, a class
    does too much when it has a long list of fields or methods and many dependent
    objects passed into the class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoanProcessor` class in the following snippet has the dependencies neatly
    injected into the constructor, making it loosely coupled with the dependencies.
    However, the class has more than one reason to change; the class has a mix of
    both methods with code for data retrieval and business rules processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `GetCarLoans` method should not be in `LoanProcessor` in order to make the
    class maintainable and be easily tested. `LoanProcessor` should be refactored
    with `GetCarLoans` in a data access layer class.
  prefs: []
  type: TYPE_NORMAL
- en: Classes with the qualities described in this section can be difficult to debug
    and test. Also, it might be difficult for new team members to understand the inner
    workings of the class quickly. If you have a class with these attributes in your
    code base, it is advisable to refactor it by identifying the responsibilities
    and separating them into different classes and naming the classes as per their
    responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Static objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using **static variables**, **methods**, and **objects** in code can be useful
    as these allow the objects to have the same value throughout all instances of
    the object, as only one copy of the object is created and put in memory. However,
    testing code containing statics, especially static methods, can create testing
    issues because you cannot override static methods in a subclass and using mocking
    frameworks to mock static methods is a very daunting task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you create static methods that maintain states, such as in the `CalculateCarLoanRate`
    method in `LoanProcessor` in the preceding snippet, the static methods cannot
    be subclassed or extended using polymorphism. Also, the static method cannot be
    defined using interfaces, thereby making mocking impossible, since most mocking
    frameworks work effectively with interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Law of Demeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software applications are complex systems made up of different components that
    communicate to achieve the overall purposes of solving real-life problems and
    business process automations. In reality, the components have to coexist, interact,
    and share information across the component's boundary without the different concerns
    getting mixed up, to promote component reusability and overall system flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: In software programming, there are technically no hardcore laws defined that
    must be stringently followed. However, various principles and laws have been formulated
    that serve as guidelines and can assist software developers and practitioners,
    and facilitate building software applications that have components with high cohesion
    and loose coupling to encapsulate data adequately and ensure that quality source
    codes are produced that can be easily understood and extended, thereby reducing
    the maintenance costs of software. One of these laws is the **Law of Demeter**
    (**LoD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'LoD, also known as the **principle of least knowledge**, is an important design
    approach or rule for developing object-oriented software applications. The rule
    was formulated at *Northeastern University in 1987 by Ian Holland*. With the proper
    knowledge of this principle, software developers can write code that is easy to
    test and build software applications with fewer or no bugs. The formulation of
    the law is that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each unit should have only limited knowledge about other units: only units
    "closely" related to the current unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each unit should only talk to its friends; don't talk to strangers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LoD emphasizes low coupling, which effectively means an object should have little
    or very limited information about another object. Relating LoD to a typical class
    object, the methods in a class should only have limited knowledge about other
    methods of closely related objects.
  prefs: []
  type: TYPE_NORMAL
- en: LoD serves as heuristics for software developers to facilitate information-hiding
    in modules and components of software. LoD has two forms—the **object or dynamic
    form** and **class or static form**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class form of LoD is formulated as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **method** (**M**) of a **class** (**C**) should only send messages to objects
    of the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Argument classes of M including C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance variables of C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes of instances created within M
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties or fields of C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the object form of LoD is formulated as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an M, messages can only be sent to the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters of M, which include the enclosing object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An immediate part-object, which is the object that M called on the enclosing
    object returns, including attributes of the enclosing object, or an element of
    a collection that is an attribute of the enclosing object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code clearly violates LoD, this is because `LoanProcessor` does
    not really care about `LoanCalculator` as it does not keep any reference to it.
    In the code, `LoanProcessor` is already talking to `LoanCalculator`, a stranger.
    This code is not really reusable because both `CurrencyConverter` and `LoanProcessor`
    will be required by any class or code attempting to reuse them, though technically
    `LoanCalculator` is not used beyond the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for `LoanProcessor` will require that the object graph be
    created. `LoanCalculator` should be created in order for `CurrencyConverter` to
    be available. This creates coupling in the system, if `LoanCalculator` is refactored,
    which is possible anyway, so there is the risk that this might break `LoanProcessor`,
    causing the unit test to stop running.
  prefs: []
  type: TYPE_NORMAL
- en: While the `LoanCalculator` class can be mocked, to test `LoanProcessor` in isolation,
    this can sometimes make the test unreadable, it is better that the coupling is
    avoided so that you can write code that is flexible and can be easily tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refactor the preceding code snippet, and make it comply with LoD and take
    its dependencies from the class constructor, thereby eliminating an extra dependency
    on `LoanCalculator` and reduce coupling in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Train Wreck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another anti-pattern that violates LoD is what is called **Train Wreck** or
    **Chain Calls**. This is a chain of functions and occurs when you have a series
    of C# methods that are appended to each other all in a single line of code. You
    will know you have written a code with Train Wreck when you are spending time
    trying to figure out what the line of code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering how this phenomenon violates LoD. First, the code lacks
    readability and it is not maintainable. Also, the line of code is not reusable
    as there are three method calls in only a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line of code can be refactored by minimizing the interactions and eliminating
    the method chaining so as to make it comply with the principle of *don''t talk
    to strangers*. This principle explains that a calling point or method should only
    interact with one object at a time. With the elimination of the methods chain,
    the resulting code can be reused elsewhere without having to struggle to understand
    what the piece of code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An object should have limited knowledge and information of other objects. Also,
    methods in an object should have little awareness of the object graph of the application.
    Through conscious efforts, using LoD, you can build software applications that
    are loosely coupled and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID architecture principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software application development procedures and methodologies, from the first
    step to the last step, should be simple and easily understood by both novices
    and experts. These procedures, when used in combination with the right principles,
    make the process of developing and maintaining software applications easy and
    seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Developers from time to time adopt and use different development principles
    and patterns in order to simplify complexities and make software applications
    code bases maintainable. One such principle is the SOLID principle. This principle
    has proven to be very useful and a must-know for every serious programmer of object-oriented
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID is an acronym of the five basic principles of developing object-oriented
    systems. The five principles are for class design and are denoted as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**: Single Responsibility Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**: Open-Closed Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**: Liskov Substitution Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Interface Segregation Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Dependency Inversion Principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles were first consolidated under the acronym SOLID and popularized
    by *Robert C. Martins* (popularly known as **Uncle Bob**) in the early 2000s.
    The five principles are meant for class design, and when abided by, can assist
    with dependency management, which will avoid the creation of rigid code bases
    tangled with dependencies here and there.
  prefs: []
  type: TYPE_NORMAL
- en: Proper understanding and use of the SOLID principles can enable software developers
    to achieve a very high degree of cohesion and write quality code that can be easily
    understood and maintained. With SOLID principles, you can write clean code and
    build software applications that are robust and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Uncle Bob clarified that SOLID principles are not laws or rules but
    are heuristics that have been observed to work in several cases. To use the principles effectively,
    you have to search your code and check for portions where the principles are violated
    and then refactor them.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Single Responsibility Principle** (**SRP**) is the first of the five SOLID
    principles. The principle states that a class must at any point in time have only
    one reason to change. This simply means that a class should only perform one duty
    at a time or have one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The business requirements of software projects are not usually fixed. Before
    a software project is shipped and, indeed, throughout the life cycle of a software,
    requirements change from time to time and developers have to adapt the code base
    to the changes. In order for the software application to meet its business needs
    and adapt to changes, it is imperative that flexible design patterns are used
    and classes have a single responsibility at all times.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is important to understand that when a class has more than
    one responsibility, making even the minutest change can have a great impact on
    the entire code base. Changes made to the class can cause ripple effects leading
    to functionalities or other methods that have been working earlier to break. For
    example, if you have a class that parses a `.csv` file, while at the same time
    it makes a call to a web service to retrieve information that is not related to
    the `.csv` file parsing, the class has more than one reason to change. Changes
    in the web service call will affect the class, though the changes are not related
    to the `.csv` file parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of the `LoanCalculator` class in the following snippet clearly violates
    SRP. `LoanCalculator` has two responsibilities—the first is to calculate house
    and car loans and the second is to parse loan rates from XML files and XML strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The dual responsibility status of the `LoanCalculator` class creates several
    issues. First, the class becomes very volatile, because changes to one responsibility
    might affect the other. For instance, a change to the structure of the XML contents
    to be parsed for the rates might necessitate that the class be rewritten, tested,
    and redeployed; despite that, changes have not been made to the second concern,
    which is the loan calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tangled code in the `LoanCalculator` class can be fixed by redesigning
    the class and separating the responsibilities. The new design will be to move
    the responsibility of XML rates parsing into a new `RateParser` class and leaving
    the loan calculation concern in the existing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `RateParser` class extracted from `LoanCalculator`, `RateParser` can
    now be used as a dependency in `LoanCalculator`. Changes made to any method in
    `RateParser` will not affect `LoanCalculator` since they now handle different
    concerns and each class has only one reason to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having the concerns separated creates great flexibility in the code base and
    allows for easy testing of the two classes. With the new design, changes made
    to `RateParser` cannot affect `LoanCalculator` and the two classes can be unit
    tested in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities should not be mixed in a class. You should avoid muddling up
    responsibilities together in a class, which leads to monster classes that do too
    much. Instead, if you can think of a reason or motivation to change a class, then
    it already has more than one responsibility; split the class into classes, each
    containing only a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, a first glance at the `LoanRepository` class in the following
    snippet might not outrightly indicate that concerns are muddled up. But if you
    carefully examine the class, both data access and business logic codes are mixed
    in the class, making it violate SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The class can be refactored by separating the business logic code of calculating
    a car loan rate into a new class—`LoanService`, this will allow the `LoanRepository`
    class to only contain code related to the data layer, thereby making it adhere
    to SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With the business logic code separated into the `LoanService` class, the `LoanRepository`
    class now has has only one dependency, which is the `DbContext` entity framework.
    Going forward, `LoanRepository` can be easily maintained and tested. The new `LoanService`
    class also adheres to SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When you have concerns in your code well-managed, the code base will have high
    cohesion and will be flexible and easy to test and maintain in the future. With
    high cohesion, the classes will be loosely coupled and changes to the classes
    will have little probability of breaking the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Open-Closed Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The approach for designing and eventually writing production code should be
    the one that allows new functionalities to be added to a project's code base without
    having to make many changes, change several portions or classes of the code base,
    or break existing functionalities that were already working and in good condition.
  prefs: []
  type: TYPE_NORMAL
- en: If, for any reason, you make changes to a method in a class and as a result
    of the changes, changes have to be made to several parts or modules, it's an indication
    of a problem with the code design. This is what the **Open-Closed Principle** (**OCP**)
    addresses, to allow your code base design to be flexible, so that you can easily
    make modifications and enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The OCP states that software entities, such as classes, methods, and modules,
    should be designed to be open for extension, but closed for modification. This
    principle can be achieved through inheritance or design patterns, such as factory,
    observer, and strategy patterns. It is where classes and methods can be designed
    to allow the addition of new functionalities to be used by the existing code,
    without actual modification or changes made to the existing code but by extending
    the behavior of the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, with the proper use of object abstraction, you can have sealed classes
    that are closed for modification while the behavior of the classes can be extended
    through derived classes. Derived classes are children or subclasses of the sealed
    classes. Using inheritance, you can create classes that add more features by extending
    their base class without modifying the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `LoanCalculator` class in the following snippet, which has a `CalculateLoan`
    method that must be able to calculate the loan details for any type of loan passed
    into it. Without using the OCP, the requirement can be computed with the use of
    `if..else if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoanCalculator` class has a rigid structure, which necessitates much work
    when a new type is to be supported. For example, if you intend to add more types
    of customer loans, you have to modify the `CalculateLoan` method and add additional
    `else if` statements to accommodate the new types of loans. `LoanCalculator` violates
    the OCP since the class is not closed for modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the `LoanCalculator` class open for extension and closed for modification,
    we can use inheritance to simplify the refactoring. `LoanCalculator` will be refactored
    to allow subclasses to be created from it. Making `LoanCalculator` a base class
    will facilitate the creation of two derived classes, `HouseLoanCalculator` and
    `CarLoanCalulator`. The business logic for calculating the different types of
    loans has been removed from the `CalculateLoan` method and implemented in the
    two derived classes, as seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `If` conditions have been removed from the `CalculateLoan` method in the
    `LoanCalculator` class. Instead of having the `if(loanDTO.LoanType==LoanType.CarLoan)`
    line of code, the new `CarLoanCaculator` class now contains logic for obtaining
    car loan calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HouseLoanCalculator` class has been created from `LoanCalculator` with
    a `CalculateLoan` method that overrides the base `CalculateLoan` method in `LoanCalculator`.
    Any changes made to `HouseLoanCalculator` will not affect the `CalculateLoan`
    method of its base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If a new type of loan is introduced, let's say a postgraduate study loan, a
    new class, `PostGraduateStudyLoan`, can be created to extend `LoanCalculator`
    and implement the `CalculateLoan` method without having to make any modifications
    to the `LoanCalculator` class.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, observing the OCP implies that classes and methods in your code
    should be opened for extension, meaning the classes and methods can be extended
    to add new behaviors to support new or changing application requirements. And
    the classes and methods are closed for modification, which means you can't make
    changes to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make `LoanCalculator` open for changes, we made it a base class
    that other types were derived from. Alternatively, we can create an `ILoanCalculator`
    abstraction, instead of using classical object inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `CarLoanCalculator` class can now be created to implement the `ILoanCalculator`
    interface. Which will necessitate that the methods and properties defined in the
    interface will be explicitly implemented by the `CarLoanCalculator` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HouseLoanCalculator` class can also be created to implement `ILoanCalculator`,
    with the `IRateParser` object injected into it through the constructor, similar
    to `CarLoanCalculator`. The `CalculateLoan` method can be implemented with the
    specific code required to calculate a house loan. Any other type of loan can be
    added by simply creating the class and making it implement the `ILoanCalculator`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using OCP, you can create software applications that are flexible with behaviors
    that can be easily extended, thereby avoiding a code base that is rigid and lacks
    reusability. Through appropriate use of OCP, by effectively using code abstraction
    and objects polymorphism, you can make changes to a code base without having to
    change many parts and with little effort. You really don't have to recompile the
    code base to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Liskov Substitution Principle** (**LSP**), which can sometimes referred
    to as **Design by Contract**, is the third of the SOLID principles and was first
    put forward by *Barbara Liskov*. LSP states that a derived or subclass should
    be substitutable for the base or superclass without having to make modifications
    to the base class or generating any runtime errors in the system.
  prefs: []
  type: TYPE_NORMAL
- en: LSP can be further explained using the following mathematical notation—let S
    be a subset of T, an object of T could be substituted for an object of S without
    breaking the existing working functionalities of the system or causing any type
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the concepts of LSP, let's consider a `Car` super class with a
    `Drive` method. If `Car` has two derived classes, `SalonCar` and `JeepCar`, both
    having an overridden implementation of the `Drive` method, wherever `Car` is requested,
    both `SalonCar` and `JeepCar` should be usable in place of the `Car` class. The
    derived classes have an *is a* relationship with `Car`, because `SalonCar` is
    a `Car` and `JeepCar` is a `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to design your classes and implement them to be LSP-compliant, you
    should ensure that the derived classes elements are designed by contract. The
    derived classes method definitions should be somewhat similar to that of the base
    class, though the implementation can be different because of the different business
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is important that the implementation of the derived classes doesnot
    violate whatever constraints are implemented in the base classes or interfaces.
    When you partially implement an interface or base class, by having methods that
    are not implemented, you are violating LSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet has a `LoanCalculator` base class, with a `CalculateLoan`
    method and two derived classes, `HouseLoanCalculator` and `CarLoanCalculator`,
    which have `CalculateLoan` methods and can have different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If LSP is not violated in the preceding snippet, the `HouseLoanCalculator`
    and `CarLoanCalculator` derived class can be used in place of `LoanCalculator`
    wherever a reference to `LoanCalculator` is required. This is demonstrated in
    the `Main` method, shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Interface Segregation Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Interface** is an object-oriented programming construct that is used by
    objects to define the methods and properties they expose, and to facilitate interactions
    with other objects. An interface contains related methods with empty bodies but
    no implementation. An interface is a useful construct in object-oriented programming
    and design; it allows the crafting of software applications that are flexible
    and loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle** (**ISP**) states that interfaces should
    be modest, by containing definitions for only properties and methods that are
    needed, and clients should not be forced to implement interfaces that they don't
    use, or depend on methods they don't need.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the ISP in your code base effectively, you should favor the creation
    of simple and thin interfaces that have methods that are logically grouped together
    to solve a specific business case. With the creation of thin interfaces, the methods
    contained in the class code can be easily implemented with great flexibility while
    keeping the code base clean and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you have fat or bloated interfaces that have methods with
    functionalities that are not required in the classes that implement the interface,
    you are more likely to violate the ISP and create coupling in the code, which
    will result in a code base that cannot be easily tested.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a bloated or fat interface, you can create two or more thin
    interfaces with the methods logically grouped and have your class implement more
    than one interface, or let the interfaces inherit from other thin interfaces,
    a phenomenon known as multiple inheritance, supported in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IRateCalculator` interface in the following snippet violates the ISP.
    It can be considered a polluted interface because the only class it implements
    does not require the `FindLender` method as it is not needed by the `RateCalculator`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RateCalculator` class has the `GetYearlyCarLoanRate` and `GetYearlyHouseLoanRate`
    methods that are required to fulfill the requirements of the class. By implementing `IRateCalculator`,
    `RateCalculator` is forced to have an implementation for the `FindLender` method,
    which is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `IRateCalculator` can be refactored into two cohesive interfaces
    that have methods that can be logically grouped together. With the small interfaces,
    the code can be written with great flexibility and unit testing the classes that
    implement the interface is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With `IRateCalculator` refactored into two interfaces, `RateCalculator` can
    be refactored to remove the `FindLender` method that is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: An anti-pattern to watch out for while implementing interfaces that comply with
    the ISP is the creation of one interface per method, in an attempt to create thin
    interfaces; these can lead to the creation of several interfaces, resulting in
    a code base that will be difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rigid or bad designs can make changes to components or modules of software applications
    very difficult and create maintenance issues. These nonflexible designs can often
    break functionalities that might earlier be working. These can come in the forms
    of incorrect use of principles and patterns, bad code, and coupling of different
    components or layers, thereby making the maintenance process a very difficult
    one.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a rigid design in an application code base, examining the code
    closely will reveal that the modules are tightly coupled, making changes difficult.
    Making changes to any of the modules can create the risk of breaking another module
    that was working before. Observing the last of the SOLID principles—the **Dependency
    Inversion Principle** (**DIP**) can eliminate any coupling of modules, making
    the code base flexible and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DIP has two forms, both intended to achieve code flexibility and loose
    coupling between objects and their dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules; both should depend
    on abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details; details should depend on abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When high-level modules or entities are directly coupled to low-level modules,
    making changes to the low-level modules can often have a direct impact on the
    high-level modules, causing them to change, creating a ripple effect. In practical
    terms, it is when changes are made to higher level modules that the low-level
    modules should change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can apply DIP wherever you have classes that have to talk to or send
    messages to other classes. The DIP advocates the well-known principle of layering,
    or separation of concerns, in application development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `AuthenticationManager` class in the preceding code snippet represents a
    high-level module, while the `DbContext` Entity Framework that was passed to the
    class constructor is a low-level module responsible for CRUD and data layer activities.
    While a nonprofessional developer might not see anything wrong in the code structure,
    it violates the DIP. This is because the `AuthenticationManager` class depends
    on the `DbContext` class and an attempt to makes changes to the inner code of
    `DbContext` will trickle up to `AuthenticationManager`, causing it to change which
    will result in the violation of the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor the `AuthenticationManager` class to have a good design and
    comply with the DIP. This will necessitate the creation of an `IDbContext` interface and
    make `DbContext` implement the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`AuthenticationManager` can be coded against the interface, thereby breaking
    the coupling or direct dependence on `DbContext` and instead depending on the
    abstraction. Coding `AuthenticationManager` against `IDbContext` means the interface
    will be injected in the constructor of `AuthenticationManager` or by using *Property
    Injection*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With the refactoring done, `AuthenticationManager` now uses dependency inversion
    and depends on abstraction—`IDbContext`. In future, if changes are made to the
    `DbContext` class, it can no longer affect the `AuthenticationManager` class and
    will not violate the OCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `IDbContext` injected to `AutheticationManager` through the constructor
    is very elegant, the `IDbcontext` can also be injected into `AuthenticationManager`
    through a public property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, DI can be done through *Interface Injection*, where object references
    are passed using interface actions. It simply means interfaces are used to inject
    dependencies. The following snippet explains the concept of dependency using an
    interface injection.
  prefs: []
  type: TYPE_NORMAL
- en: '`IRateParser` is created with the `ParseRate` method definition. A second interface, `IRepository`,
    is created containing the `InjectRateParser` method, which accepts `IRateParser`
    as an argument and will inject the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `LoanRepository` class to implement the `IRepository`
    interface and have a code implementation for `InjectRateParser`, to inject the `IRateParser`
    repository into the `LoanRepository` class as dependency for use in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create concrete implementations of the `IRateParser` dependency,
    `XmlRateParser` and `RestServiceRateParser`, which both contain implementations
    of the `ParseRate` method for parsing loan rates from XML and REST sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To wrap it up, we can test the *Interface Injection* concept using the interfaces
    and the classes created in the preceding snippets. A concrete object of `IRateParser`
    is constructed, which is injected into the `LoanRepository` class, through the
    `IRepository` interface, and any of the two implementations of the `IRateParser`
    interface can be used to construct it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Any of the three techniques described in this section can be effectively used
    to inject dependencies into your code wherever it is required. Appropriate and
    effective use of DIP can facilitate the creation of loosely coupled applications
    that can be easily maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a DI container for ASP.NET Core MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Central to ASP.NET Core is DI. The framework provides built-in DI services to
    allow developers to create loosely coupled applications and prevent instantiation
    or construction of dependencies. Using the built-in DI services, your application
    code can be set up to use DI, and dependencies can be injected into methods in
    the `Startup` class.  While the default DI container has some cool features, you
    can still use other known, matured DI containers in ASP.NET core applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure your code to use DI in two modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor Injection**: The interfaces required by a class are passed or
    injected via the class''s public constructor. Constructor injection is not possible
    using a private constructor, an `InvalidOperationException` will be thrown when
    this is attempted. In a class with an overloaded constructor, only one of the
    constructors can be used for DI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Injection**: Dependencies are injected into a class by using public
    interface properties in the class. Any of the two modes can be used to request
    dependencies, which will be injected by the DI container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DI container, also known as an **Inversion of Control** (**IoC**) container,
    is typically a class or factory that can create classes with their associated
    dependencies. Before a class with injected dependencies can be successfully constructed,
    the project must be designed or set up to use DI, and the DI container must have
    been configured with the dependency types. In essence, the DI will have a configuration
    containing mappings of the interfaces to their concrete classes and will use this
    configuration to resolve the requested dependencies for the classes that require
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASP.NET Core built-in IoC container is depicted by the `IServiceProvider`
    interface and you can configure it using the `ConfigureService` method in the
    `Startup` class. The container has a default support for constructor injection.
    In the `ConfigureService` method, services and platform features such as Entity
    Framework core and ASP.NET MVC core can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The ASP.NET Core inbuilt container has some extension methods, such as `AddDbContext`,
    `AddIdentity`, and `AddMvc`, that you can use to add additional services. The
    application dependencies can be configured using the `AddTransient` method, which
    takes two generic-type arguments, the first is the interface and the second is
    the concrete class. The `AddTransient` method maps the interface to the concrete
    class, so the service is created every time it is requested. The container uses
    this configuration to inject the interfaces for every object that requires it
    in the ASP.NET MVC project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other extension methods for configuring services are the `AddScoped` and `AddSingleton`
    methods. `AddScoped` only creates a service once per request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddSingleton` method creates a service only the first time it is requested
    and keeps it in memory, making it available for use for subsequent requests of
    the service. You can instantiate the singleton yourself or simply leave it for
    the container to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The built-in IoC container for ASP.NET Core is lightweight and has limited features,
    but basically you can use it for DI configuration in your applications. However,
    you can replace it with other IoC containers available in .NET, such as **Ninject**
    or **Autofac**.
  prefs: []
  type: TYPE_NORMAL
- en: Using DI will simplify your application development experience and enable you
    to craft code that is loosely coupled and can easily be tested. In a typical ASP.NET
    Core MVC application, you should use DI for dependencies, such as **Repositories**,
    **Controllers**, **Adapters**, and **Services**, and avoid static access to services
    or `HttpContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the object-oriented design principles in this chapter will assist you
    in mastering the skills required to write clean, flexible, easy-to-maintain, and
    easy-to-test code. The LoD and the SOLID principles explained in the chapter can
    serve as guidelines for creating loosely coupled, object-oriented software applications.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reap the benefits of a TDD cycle, you must write code that is testable.
    The SOLID principles covered describes appropriate practices that can facilitate
    the writing of testable code that can be easily maintained and then enhanced when
    needed. The last section of the chapter focused on setting up and using a dependency-injection
    container for an ASP.NET Core MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the attributes of a good unit test, the
    .NET ecosystem of unit testing frameworks available for use in creating tests,
    what to consider when unit testing ASP.NET MVC Core projects, and we will delve
    into the unit testing property on the .NET Core platform using the xUnit library.
  prefs: []
  type: TYPE_NORMAL
