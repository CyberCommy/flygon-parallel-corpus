- en: Digital Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advent of cloud computing is impacting every facet of the enterprise landscape.
    From the core infrastructure to the client-facing applications, the enterprise
    landscape is seeing the impact of the forces of change. Some enterprises are the
    leading harbingers of these transformations, while others are still trying to
    figure out where to start and what to do. Depending upon the maturity of the industry
    domain, the transformation journey can be very different. Some domains are the
    first to adopt technology trends (such as BFSI), while others wait for technology
    obsolescence to adopt new technology (manufacturing, utilities). In this chapter,
    we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping the application portfolio for digital transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking an existing monolithic application into a distributed cloud-native
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes required at the process, people, and technology levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own platform services (control versus delegation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application portfolio rationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision for digital transformation is typically mapped to a larger application
    portfolio. The external forces in terms of customer-centricity, better customer
    experiences, compliance/regulatory, the advent of cloud computing, open source,
    and so on lead to enterprises looking at their entire application landscape and
    identifying areas to improve, enhance, and rework.
  prefs: []
  type: TYPE_NORMAL
- en: The initial step is to identify the opportunities or the applications that need
    to be transformed for cloud deployment. In this step, we typically do an overall
    portfolio analysis across business and technical parameters. These parameters
    help provide a weighted score of the portfolio. Using the score, we can map the
    applications across four quadrants. These quadrants help us identify where to
    focus and where we will see the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Portfolio analysis – business and technical parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is measured and scored across business and technical parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters for technical value are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: IT standards compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture standards compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality of service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operational considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License/support cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project/change cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application maintenance cost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sourcing (insourcing/outsourcing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters for business value are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Financial impact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application user impact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer impact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Criticality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overlap/redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regulatory / compliance risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service failure risk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product/vendor stability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can rate these parameters on a scale of 1-5 (one being the lowest and five
    being the highest).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping these parameters helps us identify cost and complexity hotspots and
    segregate applications based on business capability areas. These application categories
    are further analyzed for inter-dependencies, touch points, integration points,
    and the underlying infrastructure. Using all these, we can analyze the benefits
    and provide recommendations for a transformation roadmap. The next step is based
    on the business value and technical value; we plot the applications in one of
    the following quadrants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74c6700a-b4de-41c3-9191-68a0df37c21b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The scores help us provide the cost-benefit analysis at the application and
    portfolio level. It also helps to identify where there is a functional overlap
    (because of mergers and acquisition activities), understand the lack of business,
    IT alignment, and where the business priorities lie. These can help identify where
    the investment opportunities are and the potential non-core areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding basis, the applications in each of the quadrants can be
    further mapped to one of the dispositions as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52b5ea01-ecdf-48e4-b449-9269a51bd586.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These dispositions provide us with rational opportunities for application across
    the areas which we will discuss in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Retire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications that fall into the low business value and low technical
    value can be marked for retirement. These are typically applications that have
    either lost relevance in a different business environment or had new functionality
    implemented.
  prefs: []
  type: TYPE_NORMAL
- en: These applications are marked by low usage and come with a very low business
    risk. One can also identify such applications by aggregating the tickets against
    these applications and usage volumes. Applications with low usage and lower numbers
    of tickets are typically candidates for decommissioning.
  prefs: []
  type: TYPE_NORMAL
- en: Retain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications that come with low technical value and high business value
    fall into this category. The technical maturity might be low, but they provide
    significant value to the business. These applications do not cost too much to
    run from an IT perspective. We can keep the lights switched on for these applications,
    as these still provide significant value to the business.
  prefs: []
  type: TYPE_NORMAL
- en: Consolidate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications that come with a high technical value and low business value
    fall into this category. The high technical value might be a result of the high
    cost of technical support, lack of people with technical skills, lack of documentation,
    and so on. The business can articulate the value of the applications, but the
    current spend on these applications might not be justifiable. These sets of applications
    need to be migrated and consolidated to upgrade the technical currency.
  prefs: []
  type: TYPE_NORMAL
- en: Transform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are the applications that have high technical value and high business
    value. This means the applications have a large user base, multiple releases,
    a large number of tickets, and high infrastructure support costs, but still provide
    a significant advantage to the business. These applications are where the effort
    needs to be put in, because they provide significant differentiators for the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Using the preceding methodology, we can identify the applications that are ripe
    for transformation. For our example, we can take an existing Java/JEE application
    that is currently running on-premises and needs to be transformed for a distributed
    application design model.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic application to distributed cloud-native application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advent of the J2EE specification coupled with application servers providing
    the requisite services led to the design and development of monolithic applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e333613-c3c5-4408-bf91-506c0c9a7944.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the characteristics of the monolithic application and its ecosystem
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is packaged into a single `.ear` file. The single `.ear` file requires
    a multi-month test cycle, which results in a reduced velocity of change in production.
    Typically, a *big* push to production once or twice a year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application build complexity is very high with dependencies across various modules.
    At times, there is a clash between the versions of the JAR files used by the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse between application is primarily performed by sharing `.JAR` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huge bug and feature databases—from a backlog perspective, there are many feature
    sets/bugs across the various application modules. At times, some of the backlogs
    might be at loggerheads with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User acceptance criteria usually undefined. There are some smoke tests, but
    by and large, new features and integration is mostly visible in production only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring multiple team involvement and significant oversight (business team,
    architecture team, development team, testing team, operations teams, and so on)
    for design, development, and operations management. During the release cycles,
    coordinating between the various teams is a Herculean effort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical debt accumulation over a period of time—as new features/functions
    are added to the application, the original design never undergoes any change/refactor
    to account for new requirements. This results in a lot of dead and duplicate code
    accumulating in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outdated runtimes (licenses, complex updates)—the application might be running
    on an older version of JVM, older application servers and/or database. Upgrade
    costs are high and usually very complex. Planning an upgrade means foregoing any
    feature release during that development cycle. The involvement of multiple teams
    requires complex project management models. The absence of regression test scripts
    makes this even worse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The technical design-led approach followed by the team. The architecture and
    design is frozen upfront before development starts. As the application grows,
    new features/functions are getting added, there is no second look at the application
    architecture/design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barely any business components or domains are used. The application design is
    usually sliced horizontally based on the tiers (presentation tier, business tier,
    integration tier, and database tier) and on the customer/application flows into
    specific modules/patterns. For example, applications making use of the MVC pattern
    will create packages along the lines of model, views, and controllers, with value
    and common thrown in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, there is a single database schema for the entire application. There
    is no segregation of the functionality at the database level. The domains are
    linked to each other with foreign keys and databases following the third normalization
    form. The application design is usually bottom-up, with the DB schema determining
    the application database tier design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average enterprise application will have more than 500k lines of code, with
    plenty of boilerplate code. As the application grows, there will be plenty of
    dead and duplicate code in the source code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications typically supported by heavyweight infrastructure—the abilities
    of the application are managed by adding more and more hardware. Server clustering
    is used to scale the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thousands of test cases lead to increased time to run the regression test suite.
    At times, the release will skip the regression test suite to speed up the cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team size is higher than 20 in most of these projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that, in the case of monolithic applications, the business velocity
    and rate of change is very low. This model may have worked 10-15 years back. In
    today's competitive market, the ability to release features/functions at an incredible
    pace is paramount. You are not just competing with other large enterprises but
    with a lot of smaller nimbler start-ups that do not have the baggage of legacy
    applications, technologies, and processes.
  prefs: []
  type: TYPE_NORMAL
- en: The advent of open source growth of consumer companies, and growing mobile devices,
    among other factors, led to innovation in the application architecture space and
    more distributed applications driven by microservices and reactive models. The
    monolithic applications got decomposed into smaller sets of applications/services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will explore the key architecture concerns that go with a distributed
    application. We will see how these key concerns map to the overall application
    technical capabilities and what capabilities should be hired and what should be
    built:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc6c12b2-74b7-46b6-ba1e-f5c665efba34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the characteristics of the distributed application and its ecosystem
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightweight runtime containers**: The advent of microservices correlates
    to the demise of the heavyweight JEE containers. As the applications morph into
    microservices with a singular purpose and loose coupling, there is a need to simplify
    the container managing the component lifecycle. The advent of Netty led to the
    development of the reactive framework that was just right for the purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction management**: Another causality of the application simplification
    was transaction management. Bounded context means the services are not talking
    to multiple resources and trying to do a two-phase commit transaction. Patterns
    such as CQRS, Event Store, **Multi Version Concurrency Control** (**MVCC**), eventual
    consistency, and so on, helped simplify and move the application to model a where
    locking resources are not needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service scaling**: Breaking the application allows individual services to
    be scaled up and out independently. Using the Pareto principle, 80% of the incoming
    traffic is handled by 20% of the services. The ability to scale these 20% services
    becomes a significant driver toward the higher availability SLAs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: Unlike the monolithic application, where the load balancing
    was between the application server cluster nodes, in the case of distributed applications,
    the load balancing is across the service instances (running in Docker-like containers).
    These service instances are stateless and typically can go up/down very frequently.
    The ability to discover the instances that are active and which are not active
    becomes a key feature of the load balancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible deployment**: One of the key abilities of the distributed architecture
    is moving from a rigid cluster deployment model to a more flexible deployment
    model (cattle versus pets), where the deployment instances are deployed as immutable
    instances. Orchestration engines such as Kubernetes allow the optimum utilization
    of the underlying resources and take away the pain of managing/deploying hundreds
    of instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: As the service instance becomes immutable, the service configuration
    is abstracted out of the services and held in a central repository (configuration
    management server). The service at boot time, or as part of the service initialization,
    picks up the configuration and starts in the available mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery**: The use of stateless immutable service instances running
    over commodity hardware means the services can go up and down at any time. The
    clients invoking these services should be able to discover the service instances
    at runtime. This feature, along with load balancing, helps maintain the service
    availability. Some new products (such as Envoy) have merged service discovery
    with load balancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service versions:** As the services start getting consumers, there will be
    a need to upgrade the service contracts to accommodate new features/changes. In
    this case, running multiple versions of the service becomes paramount. You will
    need to worry about moving the existing consumers to a new service version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Unlike the traditional monolithic monitoring that focused on
    infrastructure and application server monitoring, the distributed architecture
    requires monitoring at the transaction level as it flows through the various service
    instances. **Application performance management** (**APM**) tools such as AppDynamics,
    New Relic, and so on are used to monitor the transactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handling / messaging / asynchronous communication**: Services do not
    talk to each other on a point-to-point basis. Services make use of asynchronous
    communication through events as a means to decouple them from each other. Some
    of the key messaging tools such as RabbitMQ, Kafka, and so on are used to bring
    asynchronous communication between the services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-blocking I/O**: The services themselves make use of the non-blocking
    I/O models to get the maximum performance from the underlying resources. Reactive
    architecture is being pursued by microservices frameworks (with the likes of Play
    framework, Dropwizard, Vert.x, Reactor, and so on) used to build the underlying
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyglot services**: The advent of the distributed application and using
    APIs as integration allows the service instance to be built with best-of-breed
    technologies. Since the integration model is JSON over HTTP, the services can
    be polyglot, allowing the use of the right technologies to build the services.
    The services can also make use of different data stores based on the type of service
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance persistence**: With the services owning their own data stores,
    the read/write services need to handle large volumes of concurrent requests. Patterns
    such as **Command Query Request Segregation** (**CQRS**) allow us to segregate
    the read/write requests and move to the data store to an eventual consistency
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API management**: Another key ingredient of the distributed architecture
    is the ability to abstract out concerns such as service throttling, authentication/authorization,
    transformation, reverse proxy, and so on and move to an external layer called
    API management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health check and recovery**: Services implement health checks and recovery
    in order for the load balancer to discover the healthy service instances and remove
    the unhealthy ones. The services implement the heartbeat mechanism which is used
    by the service discovery mechanism to track healthy/unhealthy services across
    the application landscape.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-service security:** Service-to-service invocation needs to be secured.
    Data in motion can be protected by a secured communication (HTTPS) or by encrypting
    the data over the wire. The services can also use public/private keys to match
    which client services can call the other services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We saw some of the architecture concerns needed to build a distributed application.
    To cover the scope of the overall application, built as a bunch of microservices,
    we are looking at the following key architecture concerns across the various areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac53a31f-61c7-4325-b819-738e65b2f28f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the application to be cloud-native, it is important to build the application
    using SaaS/PaaS offered by the cloud vendor. This model allows you to focus on
    the pivoting on the business functionality, improve your innovation cadence, and
    improve the customer experience. Unless technology is not a key differentiator
    for the organization, the running of the core infrastructure and platform services
    should be left to the experts. In cases where there is a huge variability in demand,
    cloud elastic scale models provide an impetus. I do not want to do the marketing
    for cloud vendors, but unless the infrastructure is not an important aspect of
    your business, you should not be running the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside of this is you are getting tied to the services offered by
    the cloud provider. Organizations are going with multi-cloud vendor strategies,
    where they spread their application and they take advantage of the key differentiators
    of the cloud vendors. For example, GCP provides a rich library of analytical and
    machine learning capabilities, with the ability to run your analytical workloads
    and decipher meaning insights, and **Machine Learning** (**ML**) models are one
    way to use the best-of-breed features. Similarly, for consumer-facing applications,
    AWS provides a rich set of PaaS services that can be used to launch and pivot
    on client-centric solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Transformation of a monolithic application to a distributed application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a monolithic application and see what steps are
    required for it to be architected into a distributed application.
  prefs: []
  type: TYPE_NORMAL
- en: We are assuming a typical Java application running on an application server,
    scaled through a clustering model and using a typical RDBMS. The application is
    already in production and needs to be refactored/migrated to a distributed architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about multiple parallel tracks that need to work together to refactor/roll
    out the distributed application. We will cover individual tracks initially and
    then see them all come together. In your organization, you might choose to have
    separate teams for each track or one team managing more than one track. The idea
    is to provide you with a glimpse of the activities involved in actual transformation
    of a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: Customer journey mapping to domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key driver to start the digital transformation is defining new customer
    journeys and building a new customer experience. This customer-centricity is what
    pushes the business to fund the digital transformation program. For our case,
    we can assume that the business has approved the digital transformation program
    and we proceed from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a service decomposition perspective, we need to follow the steps mentioned
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40b2159c-2db2-4bb6-8961-45f4bc9a67a3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Customer experience journey mapping**: One of the key drivers for digital
    transformation is defining new customer journeys. A customer experience journey
    is a map of initial contact point of customer, through the process engagement
    model. This exercise is typically done by specialists and involves customer focus
    studies, touch points, actors/systems involved, business requirements, and competition
    analysis, among other things. The customer journey is typically created as an
    infographic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer journey helps identify the gaps as the customer interactions move
    across devices, channels, or processes. It helps plug those gaps and identify
    means and ways to enhance the overall customer experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deriving the domain models**: The customer experience journey maps are mapped
    for the current and future requirements. These requirements then form the basis
    for the user stories. For new applications, the requirements can form the basis
    for functional decomposition of the system. In case of an existing application,
    the system might already be decomposed into identifiable domains/sub-domains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the requirements, we can start identifying the various sub-domains
    within the system. The domain model is documented using ubiquitous language. The
    whole idea is to use a language that is understood both by business and technology
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: The domains are modeled around entities and their functions. We also consider
    dependencies which interoperate among the functions. Usually, as a first pass,
    we end up with a big ball of mud, where all the known entities and functions have
    been identified. For smaller applications, the domain model might be the right
    size, but for larger applications, the big ball will need to be broken down further,
    and that's where the bounded context comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the bounded context**: The big ball of mud needs to be broken down
    into smaller chunks for easy adoptability. Each of these smaller chunks or bounded
    contexts has its own business context that is built around a specific responsibility.
    Context can also be modeled around how the teams are organized or how the existing
    application code base is structured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no rules to define how the context is defined, but it is very important
    that everybody understands the boundary conditions. You can create context maps
    to map out the domain landscape and make sure that the bounded context is clearly
    defined and mapped. There are various patterns (for example, Shared Kernel, Conformist,
    Producer/Supplier, and so on) that can be applied to map out the bounded context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service decomposition**: Using the bounded context, we can identify the teams
    that will work as part of one bounded context. They will focus on the services
    that need to be produced/consumed to provide functionality as part of the bounded
    context. The business capabilities are decomposed into individual microservices.
    The service can be decomposed based on the following principles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single responsibility**: First and foremost is the scope of the service and
    the capability that will be exposed by the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Independent**: Changes in function/feature requirement should be limited
    to one service, allowing the one team to own and complete the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loose coupling**: The services should be loosely coupled, allowing them to
    evolve independent of each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping the up/down stream service dependency**: As the services are identified
    in each of the domains, the services can be mapped as for dependency. Core entity
    services that encapsulate the system of records are the upstream services. Changes
    from the upstream services are published as events that are subscribed or consumed
    by the downstream services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/37965ca6-ac3c-49c6-b243-1a2fce68eb0c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining the architecture runway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business application needs to sit on the shoulders of a platform. The platform
    can be built or bought, depending on the business and application needs. The organization
    needs to define an intentional architecture model and define the rail guards to
    make sure the teams are building services within the given technical constraints.
    The platform team owns this overarching architecture, chooses the architecture
    and technical components, and helps build any common concerns required for successful
    running of the application services.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e693cdb-0ced-4d43-b5b6-8d74f605d328.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Platform architecture**: One of the key ingredients of a successful distributed
    architecture is the underlying platform. One can choose to build the platform
    by using off-the-shelf, open source / commercial software (Red Hat OpenStack,
    Cloud Foundry, and so on) or can choose a strategic cloud provider (such as AWS,
    Azure) to start building the platform. The elastic nature of the underlying infrastructure
    (compute, network, and storage) provides the fundamental building blocks for the
    platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tech selection, validation, and integration**: To build the platform services,
    you might want to evaluate multiple sets of technologies to determine what works
    the best in your ecosystem. The tech stack evaluation is typically a multiple-step
    process where the requirements are mapped to the available technologies/products,
    and a detailed series of steps to validate is undertaken, resulting in a matrix
    with regards to the integration of the technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design decisions**: The result of the technology evaluations is mapped to
    the underlying requirements, resulting in a matrix. This matrix is used to determine
    the best fit and help take a design decision. This step works in close conjunction
    with the previous step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment setup**: Once the key design decisions are in place, we need
    to start with the environment setup. Depending upon whether the choice is on-premises
    or the cloud, there will be variation in the setup and the related steps. You
    can start with the setup of the development, test, pre-production, and production
    environment. The environments are built in the order of complexity and go through
    multiple iterations (to move from manual to script/automated).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DevOps/Maven archetypes**: Next, we start working on the **continuous integration**
    (**CI**) / **continuous deployment** (**CD**) part of the application build and
    deployment. For applications being developed in the Agile model, the CI/CD model
    helps do multiple releases in a day, and bring higher velocity to the entire process.
    We can also develop accelerators to aid the CI/CD process. For example, Maven
    archetypes that come with requisite bindings for creating the deployable artifact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform services build**: Next comes the set of platform services that need
    to be built/provided to the users of the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services are in application development (for example, queuing, workflows,
    API Gateways, email services, and so on), database (for example, NoSQL, RDBMS,
    Cache, and so on), DevOps tooling (for example, CI/CD tools, service registry,
    code repos, and so on), security (such as directory services, key management services,
    certificate management services, **hardware security module** (**HSM**), and so
    on), data analytics (such as Cognitive Services, Data Pipelines, Data lake, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: You can buy these services from multiple vendors (such as Tiles, offered as
    part of the **Pivotal Cloud Foundry** (**PCF**), Iron.io platform) or subscribe
    to services provided by cloud vendors or create your own platform services on
    top on products.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-functional requirements (NFR) concerns**: Once the key platform services
    are in place, and the first set of applications start getting onboarded to the
    platform, we need to start worrying about how to handle the NFR concerns of the
    applications. How will the application scale based on the incoming load, how to
    detect failures, how to maintain minimum threshold of the application, and so
    on. Again, you may want to integrate existing products to your platform that provide/support
    these NFR concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Production concerns**: Last of all, we need to start worrying about the production
    concerns such as service management, monitoring, security, and so on. We will
    need to build services and requisite portals from an operations point of view
    to monitor, detect, and take appropriate actions in case of deviations/defined
    rules. The services are usually built using the organization standards in mind.
    The services mature as more and more uses cases are identified. The idea is to
    automate all possible operations to make sure the platform is ticking all the
    time, without any human intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another key aspect of the digital transformation is to focus on your existing
    team managing/maintaining the existing application. The team needs to be upgraded
    in terms of skills and technologies, to be able to refactor/build/deploy the existing
    application into a distributed application. We will cover the steps needed to
    reskill the teams to handle the distributed application story.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbf06227-fa6f-48b5-ac1d-7941939a775d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Developer reskill/training**: First and foremost is teaching developers new
    skills for the new application architecture techniques and design patterns. This
    means classroom training, online technology training, vendor product sessions/training,
    and so on. Another way to raise the skill of a team is to hire people with relevant
    skills and have them spearhead the overall development with support from existing
    developer teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, you might want to have two teams—one that changes the business and
    a second that runs the business. In this case, the first business team brings
    the new skills to the team. The other business team manages and operates the existing
    application during the transformation period.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dev machine upgrade and setup**: The new technology stack requires upgrades
    of the developer machines. If the machines are running on 4 GB RAM, we might want
    to upgrade them to minimum of 8 GB RAM, better still 16 GB RAM. The newer stack
    requires virtual machines, Docker engine, IDEs, and other software for development
    and unit testing. Slower machines increase the time to build/test the code. Without
    adequate horse power, the developer is simply not productive enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hands on lab / proof of concept**: Once the machines are upgraded and developer
    training is done, the developer can start doing hands on lab and/or proof of concepts
    with the new technology stack to familiarize themselves with new development techniques.
    The developer can be given small projects or be involved as part of stack evaluation
    to enable them to become familiar with the technology stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The work done by the developer team should be evaluated by an SME in the area
    to point out what they are doing wrong and the correct way of doing it. Having
    an external consultant (either SME or vendor consultant team) helps bridge this
    gap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code branching and configuration**: Once the developer team is ready to start
    working on the distributed application, the next step is to branch off the code
    from the monolithic application. You may want to branch off the configuration
    data also.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, even with branching, the existing application maintenance continues
    on the main code trunk. The branch version is used to refactor the code. We will
    see more details in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Develop/build microservices**: Once the code is branched and refactored,
    the developer should start packaging them as microservices. The team can also
    start creating new microservices that map to new requirements of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code on the branch is regularly synced with the trunk to ensure changes
    made to the trunk are available in the branch code.
  prefs: []
  type: TYPE_NORMAL
- en: Movement to specific PaaS services provided by the cloud vendor is also part
    of this phase. If you want to make use of services such as queuing or notification,
    or any of the other services, then this is the phase where you make the relevant
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**CI/CD process of microservices**: Developers will start creating pipelines
    for continuous integration and deployment of the microservices. Service dependencies
    are mapped out and considered. Various code analysis checks are run as part of
    the CI process to ensure production readiness of the code. Additional service
    governance processes can be built into the various stages of the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional/integration test**: Last but not least, developers will write
    functional and integration test suites to verify the correctness of the services.
    These test suites are integrated as part of the CI pipeline. As and when the new
    code is deployed, these tests are run as part of the regression to ensure the
    functional correctness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the monolithic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the key steps of digital transformation is the actual refactoring of
    the monolithic application. In this case, we are assuming a Java-based application
    that needs to be refactored/broken down into a distributed application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b7e7f94-e74a-438c-9f26-96673d1305c4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Initial state**: Before we begin, we take the initial state of the monolithic
    application. In this state, the application is composed of a deployment unit (such
    as a WAR file), which is internally composed of multiple JAR files. The code is
    laid out in a logical manner, with some semblance of logical structuring across
    presentation, business, and data tiers. Each of the layers is further bifurcated
    by the modules or sub-packages modeled based on modules. If not, there is some
    distinction based on the class names to identify the modules. The configuration
    is stored as a set of external properties files. Code coverage is decent (more
    than 60%) and there is potential to write more test cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code refactoring**: The next step is to carve pieces of the code from the
    monolithic application that potentially go together. For example, classes across
    the module can be packaged as a separate Java project. Common files or utility
    classes can be packaged as separate JAR(s). As you refactor the code from a single
    code project, you will create multiple, interdependent Java projects. Package
    the JARs as part of the larger WAR or EAR file only. Remember, we are working
    on the master trunk of the code base. Changes are integrated and synchronized
    back on the branch code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the code, you will also need to refactor the application configuration.
    As you refactor the code, the configuration needs to be mapped to the respective
    Java projects. The configuration might be specific to the project/module, be shared
    across modules, or global, which is used across the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build process update**: As you work on the code refactoring part, creating
    smaller independent Java projects, you will need to update your project build
    process. The Java projects need to be built in the order that they are dependent
    on each other. As you carve out the projects, the build process keeps going through
    iterations. The build process is updated in conjunction with the code refactoring
    steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the code gets refactored, the updated WAR/EAR needs to be deployed to production.
    This ensures that the code refactoring works, and other metrics—code coverage,
    unit test, regression test, and so on are factored in. This makes sure that the
    work you are doing gets incorporated on a daily basis to production.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java version update**: Multiple times, we have seen that the JVM version
    being used on the project might not be current. Some of the newer reactive frameworks
    usually work with Java 1.7 upwards. This means the base JVM version needs to be
    upgraded. This might require application code to be refactored for features that
    got deprecated. Some pieces of the code might need to be upgraded for newer features.
    The refactored code needs to go into production along with the upgraded JVM version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introducing circuit breaker / reactive patterns**: The next step in the code
    refactoring is to upgrade the code for resiliency patterns. You can bring in patterns
    such as a circuit breaker by implementing a Java library such as Hystrix. You
    can also improve the code across the modules by implementing patterns such as
    decoupling the modules by implementing async messaging, bringing in reactive frameworks
    (such as Spring Boot, Vert.x, Dropwizard, and so on), and improving concurrency
    (such as Akka, RxJava, and so on). All the changes are to the production code
    and integrated with branch code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature flag implementation**: At times, you might be integrating code coming
    from the branch. In this case, you may not want some piece of code going live.
    You can introduce feature flags in the code, controlled through configuration.
    So you can take code into production which might be dead till the feature is ready
    to go live.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ongoing functional updates**: The application will be undergoing regular
    functional changes/updates. The changes are made to the code and synchronized
    back to the branched code on regular basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw how the four tracks are working at the application in their individual
    capacities. Now we bring all four tracks together in a collaborative manner. As
    the monolithic application undergoes transformation, the other tracks set up the
    base platform for carving out the bounded context and related microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/906a6786-8fe8-4162-b8b2-891586ae1516.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see how the two tracks change the business, run the business overlap,
    and provide the perfect balance to migrate from a monolithic model to a distributed
    application model.
  prefs: []
  type: TYPE_NORMAL
- en: This is akin to changing the tires of a moving car.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own platform services (control versus delegation)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another key decision for enterprises is how to choose your platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Should I be building my own platform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should I subscribe to an existing platform and develop my application on top
    of it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This decision boils down to the factor how do you see technology, as an enabler
    (control) or a differentiator (delegation)?
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core, all companies are technology companies. But the question is whether
    controlling technology provides you with the additional edge over your competition,
    or helps build a moat that can potentially discourage new players from coming.
    Let''s take a couple of examples and see how it plays out:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are to planning to compete with a company such as Amazon in the retail
    space, you need to have deep pockets. The low margin business of Amazon retails
    is bankrolled by profitable business from AWS. So, unless you have a sugar daddy
    or alternate revenue models, competing with Amazon is not going to be easy. But
    assuming you have deep pockets, can you start modeling your retail platform on
    top of AWS or any of the cloud providers? Yes! You can start with any of the public
    cloud platforms and once you have predictable demand, you can move into a private
    cloud model. This model saves you the upfront capex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take an example of a manufacturing domain that sells physical products.
    They can potentially augment their product with **internet of things** (**IoT**)
    devices that provide a regular stream of data about the performance and usage
    of the product. The company collects this data and provides analytics services
    (such as predictive maintenance) as digital services around these products. Now,
    you can model and build the analytics model on any of the cloud providers. The
    choice of the platform can be determined by the choice of cognitive or data churning
    capabilities. You can choose the cognitive services from the platform or even
    create your own. The underlying platform capabilities are delegated to the cloud
    provider. You focus on building the right model to predict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no right or wrong model. You may start with a delegate (going with
    a public cloud provider) initially, and then go to a control model (private cloud)
    where you have full control over the features/functionality of your application.
    It is easy to pivot on the cloud provider model without a lot of upfront investment
    and lock in. The idea is to identify where the differentiator lies for you!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to the end of digital transformation. We saw how we need to evaluate
    our application portfolio for transformation opportunities. We saw the reasons
    why monolithic applications are becoming a hindrance to achieving our business
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: Once a transformation opportunity is identified, we can take an existing monolithic
    application and move to a distributed application model. We saw various steps
    that need to be taken across people, process, and technology levels.
  prefs: []
  type: TYPE_NORMAL
- en: This also brings an end to the overall journey for building cloud-native applications
    in Java. We saw the various tools/technologies to build new age microservice-based
    applications, how to build them, how to take these applications to production,
    how to monitor them, and how we adopt these applications for cloud providers such
    as AWS and Azure. We also saw some of the best practices in building API-based
    platforms, and how to take an existing monolithic application and transform it
    into a distributed microservice-based application.
  prefs: []
  type: TYPE_NORMAL
