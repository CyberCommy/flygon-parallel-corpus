- en: Chapter 9. Web Workers Unite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If you want creative workers, give them enough time to play."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*—John Cleese*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this chapter we will learn how to use HTML5 web workers to run background
    processes in another thread. We can use this to make applications with long running
    processes more responsive. We will draw a Mandelbrot fractal on a canvas using
    a web worker to generate it asynchronously without locking up the browser window.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to make web applications more responsive by using web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to start and manage a web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to communicate with a web worker and send data back and forth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw a Mandelbrot fractal on a canvas using a web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips for debugging web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web workers provide a way to run JavaScript code in the background on a separate
    thread from the main thread of a web application. Although it may seem like JavaScript
    is multithreaded because of its asynchronous nature, the truth is that there is
    only one thread. If you tie that thread up with a long running process, the web
    page will become unresponsive until it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: In the past you could alleviate this problem by breaking long-running processes
    into chunks to do a little bit of the work at a time. After each chunk you would
    call `setTimeout(),` passing it a value of zero for the timeout. When you call
    `setTimeout()` `,` what actually happens is that an event gets put into the event
    queue after the amount of time specified. This allows other event already in the
    queue a chance to get handled until your timer event makes it to the front of
    the queue.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever worked with threads before you will be aware that it is easy
    to run into concurrency issues. One thread could be working on the same data as
    another thread, which could cause corrupted data, or even worse, deadlocks. Fortunately
    web workers don't give us much of a chance to run into concurrency issues. Web
    workers are not allowed to access non-thread safe components such as the DOM.
    They also can't access the `window`, `document`, or `parent` objects.
  prefs: []
  type: TYPE_NORMAL
- en: This thread safety does come at a price, though. Since a web worker can't access
    the DOM, it can't do any work that manipulates page elements. It can't directly
    manipulate any of the data structures from the main thread, either. At this point
    you might be thinking, if the web worker can't access anything then what good
    is it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, web workers can't access data in the main thread, but they can pass data
    back and forth via messages. The key thing to remember, however, is that any data
    passed to a web worker is serialized before being sent and then de-serialized
    on the other end so that it is working on a copy, not the original data. The web
    worker can then do some processing on the data and send it back, using serialization
    again, to the main thread. Just remember that there will be some overhead to passing
    large data structures so you might still want to chunk your data and process it
    in smaller batches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some browsers do support the ability to transfer objects without making a copy,
    which is great for large data structures. At this time it is only supported by
    a few browsers so we will not cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a web worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for a web worker is defined in its own JavaScript file separate from
    the main application. The main thread spawns a web worker by creating a new `Worker`
    object giving it the path to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The application and the worker communicate with each other by sending messages.
    To receive messages we add a message event handler to the worker using `addEventListener()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An `event` object gets passed as a parameter to the event handler. It has a
    `data` field that contains any data passed back from the worker. The `data` field
    can be anything that can be represented with JSON including strings, number, data
    objects, and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a worker after it has been created you send a message to it using
    the `postMessage()` method. It takes one optional parameter which is the data
    to send to the worker. In this example it''s simply a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a web worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, the code for the web worker is specified in a separate
    file. Inside a worker you also add an event listener to receive messages from
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside the worker there is a `self` keyword that references the global scope
    of the worker. Using the `self` keyword is optional, like using the `window` object
    (all global variables and functions are attached to the `window` object). We will
    use it here just to show the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker can send messages back to the main thread using `postMessage()`
    . It works exactly the same as it does in the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When a worker is finished it can call the `close()` method to terminate the
    worker. After closing, a worker it can no longer be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import other external JavaScript files into a worker using the
    `importScripts()` method. It takes the path to one or more script files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This works well for using the same library of code in both your main thread
    and the web worker.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using a web worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a really simple application that gets the user's name and passes
    it to a web worker. The web worker will return a "hello" message back to the application.
    The code for this section can be found in `Chapter 9/example9.1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The web workers don't work in some browsers unless you are running them through
    a web server such as IIS or Apache.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we create an application with `webWorkerApp.html`, `webWorkerApp.css`,
    and `webWorkerApp.js` files. We add a text input field to the HTML asking for
    the user''s name and a response section to display the message from the worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In `webWorkerApp.js`, when the user clicks on the submit button we call the
    `executeWorker()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First we get the name the user entered into the text field. Then we create a
    new `Worker` that has its code defined in `helloWorker.js`. We add a message event
    listener that gets a message back from the worker and puts it into the page's
    response section. Last but not least we send the user's name to the worker using
    `postMessage()` to start it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the code for our web worker in `helloWorker.js`. There we
    add the code to get the message from the main thread and send a message back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First we add an event listener to get the message from the application. We extract
    the name from the `event.data` field and pass that into the `sayHello()` function.
    The `sayHello()` function simply prepends "Hello" to the user's name and sends
    the message back to the application using `postMessage()`. Back in the main application
    it gets the message and displays it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a simple application that gets the user's name and passes it to a
    web worker. The web worker sends a message back to the application where it is
    displayed on the page - that's how easy it is to use web workers.
  prefs: []
  type: TYPE_NORMAL
- en: The Mandelbrot set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how to use web workers to do some real processing we will create
    an application that draws **Mandelbrot fractals** . Drawing a Mandelbrot is pretty
    intensive and takes a lot of processing power. If you don't run it in a separate
    thread, the application will become unresponsive while it's drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Mandelbrot is a relatively simple process. We will use the **escape
    time algorithm** . For each pixel in the image we will determine how many iterations
    it takes to reach a critical escape condition. The number of iterations determines
    the color of the pixel. If we don't reach the escape condition within a maximum
    number of iterations, it is considered to be inside the Mandelbrot set and we
    color it black.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about this algorithm and the Mandelbrot set see the Wikipedia
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Mandelbrot_set](http://en.wikipedia.org/wiki/Mandelbrot_set)'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – implementing the algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `MandelbrotGenerator` object in a new file named `mandelbrotGenerator.js`.
    This object will implement the algorithm that generates the Mandelbrot. The constructor
    takes the canvas width and height, and the bounds of the Mandelbrot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we define the variables that the algorithm uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scalarX` and `scalarY` variables are used to convert the Mandelbrot coordinates
    to canvas coordinates. They are computed by dividing the width or height of the
    Mandelbrot by the width or height of the canvas. For example, while the canvas
    may be set to 640 by 480 pixels, the bounds of the Mandelbrot may be something
    like (-2, -2) for top left and (2, 2) for bottom right. In this case the Mandelbrot
    height and width are both 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – implementing the algorithm](img/5947OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we set the maximum number of iterations for the algorithm to 1000\. If
    you set it higher you will get better results but it will take longer to compute.
    Using 1000 provides a good middle ground between processing time and acceptable
    results. The `abort` variable is used to stop the algorithm. The `inSetColor`
    variable controls what color pixels that are in the Mandelbrot set get colored.
    We set it to black. Finally there is an array of colors that will get used to
    color pixels that aren't in the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write those methods to convert canvas coordinates to Mandelbrot coordinates
    first. They simply multiply the position by the scalar and add the top or left
    offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define the main loop of the algorithm in a public method named `draw()`.
    It takes the image data from a canvas to draw on as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the outer loop we iterate over all of the rows of pixels in the canvas. Inside
    this loop we call `getMandelbrotY()`, passing in the canvas y-position and get
    back the corresponding y-position in the Mandelbrot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we iterate over all of the pixels in the row. For each pixel we:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `getMandelbrotX()`, passing in the canvas x-position and get back the corresponding
    x-position in the Mandelbrot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `getIterations()`, passing in the Mandelbrot x and y positions. This method
    is where it will find the number of iterations it takes to reach the escape condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `getColor()`, passing in the number of iterations. This method gets the
    color for the number of iterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we call `setPixel()`, passing in the image data, x and y positions,
    and the color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s implement the `getIterations()` method next. This is where we determine
    if the pixel is within the Mandelbrot set or not. It takes the Mandelbrot x and
    y positions as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: First we initialize working `x` and `y` positions to zero and the `iteration`
    counter to zero. Next we start a `do-while` loop. Inside the loop we increment
    the `iteration` counter and if it is more than `maxIterations` we return `-1`.
    This signals that the escape condition was not met and the point is inside the
    Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: Next we compute the x and y variables for checking the escape condition. Then
    we check the condition to determine whether to continue with the loop. Once the
    escape condition has been met we return the number of iterations it took to find
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will write the `getColor()` method. It takes the iteration count as
    a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the `iteration` parameter is less than zero it means it's in the Mandelbrot
    set and we return the `inSetColor` object. Otherwise we look up the color object
    in the colors array by using the modulus operator to constrain the number of iterations
    to the length of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we will write the `setPixel()` method. It takes the image data, canvas
    x and y positions, and the color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This should look very familiar from [Chapter 5](ch05.html "Chapter 5. Not So
    Blank Canvas"), *Not So Blank Canvas*, where we learned how to manipulate image
    data. First we find the index of the pixel in the image data array. Then we set
    each of the color channels from the `color` object and set the opacity to the
    maximum value of `255`.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We implemented the algorithm to draw a Mandelbrot to a canvas's image data.
    Each pixel is set to either black if it's in the Mandelbrot set or some color
    depending on how many iterations it took to find the escape condition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Mandelbrot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the algorithm implemented let's create an application that
    uses it to draw a Mandelbrot on the page. We will start off drawing it without
    a web worker to show how the process makes the web page unresponsive. Then we
    will use a web worker to draw the Mandelbrot in the background to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a Mandelbrot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start off by creating a new application with `mandelbrot.html`, `mandelbrot.css`,
    and `mandelbrot.js` files. We also include `mandelbrotGenerator.js` we created
    previously for the application. You can find the code for this section in `Chapter
    9/example9.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the HTML file we add a `<canvas>` element to the HTML to draw the Mandelbrot
    on and set the size to 640 by 480:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add three buttons with pre-set Mandelbrot bounds defined as arrays
    in JSON format in the `data-settings` custom data attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go into the JavaScript file and add the code to call the Mandelbrot
    generator. Here we define variables to hold references to the canvas and its context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we add a `drawMandelbrot()` method that will get called when one of the
    buttons is clicked. It takes the bounds of the Mandelbrot to draw as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First we display a status of **Drawing…** in the status bar. Then we get the
    image data for the entire canvas. Next we create a new instance of the `MandelbrotGenerator`
    object, passing in the canvas and bounds settings. Then we call its `draw()` method
    passing, in the image data. When it has finished we draw the image data back to
    the canvas and set the status to **Finished**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is update the application''s `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we add one click event handler for all of the buttons. When a button is
    clicked on we get the `settings` custom data attribute, which is an array, and
    pass the values into `drawMandelbrot()` to draw it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it- let''s open it in the browser and take a look. Depending on the
    browser you are using (some are a lot faster than others) and the speed of your
    system, the Mandelbrot should take long enough to draw that you notice the page
    has become unresponsive. If you try to click one of the other buttons nothing
    will happen. Also notice that although we call `setStatus("Drawing...")` you never
    see the status actually change. That''s because the drawing algorithm takes over
    before the runtime gets a chance to update the text on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – creating a Mandelbrot application](img/5947OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an application to draw Mandelbrot sets using the drawing algorithm
    we created in the previous section. It doesn't use a web worker yet, so the page
    becomes unresponsive while it's drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Mandelbrot using a web worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will implement the same thing except this time we will use a web worker
    to offload the processing onto another thread. This will free up the main thread
    to handle page updates and user interaction. You can find the source code for
    this section in `Chapter 9/example9.3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go into the HTML and add a checkbox where we can select whether to use
    web workers or not. This will make it easier to compare results in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a stop button. There was no way to stop before without web
    workers because the UI was locked up, but now we will be able to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s go ahead and create our web worker in a new file named `mandelbrotWorker.js`.
    Our worker needs to use the `MandelbrotGenerator` object so we will import that
    script into the worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s define our message event handler for the worker. Upon receiving
    a message with the data necessary to draw the Mandelbrot, the worker will start
    generating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First we create a new instance of `MandelbrotGenerator`, passing in the values
    we got from the main application thread including the canvas width and height
    and the Mandelbrot bounds. Then we call the generator's `draw()` method, passing
    in the image data which is also included in the message. After the generator is
    done, we pass the image data with the Mandelbrot drawn into back to the main thread
    by calling `postMessage()` with the image data as the parameter. Lastly, we call
    `close()` to terminate the worker.
  prefs: []
  type: TYPE_NORMAL
- en: That's it for the worker. Let's go back to our main application object, `MandelbrotApp`
    and add code to start the web worker when one of the buttons is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `mandelbrot.js`, we need to add a global variable to the application
    object named worker that will hold a reference to the web worker. Then we rewrite
    `drawMandelbrot()` to add some new code to start the worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'First we check if the `worker` variable is set. If so the worker is already
    running and there''s no need to continue. Then we clear the canvas and set the
    status. Next we check if the **Use worker** checkbox is checked. If so, we call
    `startWorker(),` passing in the Mandelbrot bounds parameters. The `startWorker()`
    method is where we create the web worker and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First we create a new `Worker,` passing into it the path to `mandelbrotWorker.js`.
    Then we add a message event handler to the worker which will get called when it
    is done. It takes the image data it got back from the worker and draws it to the
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Next we start the worker. First we get the image data from the canvas's context.
    Then we put the image data, the canvas width and height, and the Mandelbrot bounds
    into an object that we pass to the worker by calling `postMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one thing left to do. We need to implement the stop button. Let''s
    write a `stopWorker()` method that will be called when the stop button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First we check if the worker is running by checking if the `worker` variable
    is set. If so we call the worker's `terminate()` method to stop the worker. Calling
    `terminate()` is equivalent to calling `self.close()` from inside the worker.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We implemented a web worker that can draw the Mandelbrot from a background thread.
    This allows the user to continue to interact with the page while the Mandelbrot
    is drawing. We demonstrated this by adding a stop button that can stop the drawing
    process. You will also notice that the **Drawing…** status message now gets displayed
    while the fractal is being drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One problem with our Mandelbrot application is that we are serializing and transferring
    the entire canvas's image data to the web worker and back. In our example that
    is 640 * 480 * 4 bytes, or 1,228,800 bytes. That's 1.2 GB! See if you can come
    up with a way to chunk up the drawing of the Mandelbrot into smaller pieces. If
    you want to see how I did it look at `Chapter 9/example9.4`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging web workers can be difficult. You don't have access to the `window`
    object so you can't call `alert()` to display a message or `console.log()` to
    write out to the browser's JavaScript console. You can't write out a message to
    the DOM either. You can't even attach a debugger and step through the code. So
    what's a poor developer to do?
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you can do is add an error listener to the worker, so you get notified
    of any errors inside the worker''s thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The event object passed into the error handler contains the `filename`, `lineno`,
    and `message` fields. From those you can tell exactly where an error happened.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you aren't getting an error, things just aren't working right? First
    of all, I recommend that you keep the code that does all of the processing for
    your worker in a separate file, like we did in `mandelbrotGenerator.js`. This
    allows you to run the code from your main thread as well as a worker. If you need
    to debug it you can run it directly from the application and debug as you normally
    would.
  prefs: []
  type: TYPE_NORMAL
- en: 'One debugging trick you can use is to define a `console` object in your web
    worker that sends messages back to the main thread where they can be logged using
    the window''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In your application, you then listen for the message and log it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How do you send data to a web worker?
  prefs: []
  type: TYPE_NORMAL
- en: You can't send data to a worker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `postMessage()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `sendData()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `sendMessage()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. Which resource in the main thread does a web worker have access to?
  prefs: []
  type: TYPE_NORMAL
- en: The DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `window` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `document` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we created an application to draw Mandelbrot fractals to learn
    how to use HTML web workers to execute long running processes in a background
    thread. This allowed the browser to remain responsive and accept user input while
    generating the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use web workers to make web applications more responsive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a web worker and start it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to send messages and data between the main thread and the web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw a Mandelbrot using a web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to catch errors thrown from a web worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to debug web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next and final chapter we will learn how to prepare a web application
    for release by combining and compressing its JavaScript files. This will give
    the application a lighter network footprint. In addition we will see how to use
    the HTML5 Application Cache to cache an application so it will run even when the
    user is offline.
  prefs: []
  type: TYPE_NORMAL
