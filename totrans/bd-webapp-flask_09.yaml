- en: Chapter 9. Extensions, How I Love Thee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using extensions to amplify our examples for a few chapters now;
    Flask-SQLAlchemy was used to connect to a relational database, Flask-MongoEngine
    to connect to MongoDB, Flask-WTF to create flexible reusable forms, and so on.
    Extensions are a great way to add functionality to your projects without adding
    anything *in the way* of your code and, if you like what we've done so far, you're
    going to love this chapter because it is dedicated to extensions!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about a few very popular extensions we have neglected
    so far. Shall we begin?
  prefs: []
  type: TYPE_NORMAL
- en: How to configure extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask extensions are modules you import, (usually) initialize, and use to integrate
    with third-party libraries. They're (also) usually imported from `flask.ext.<extension_name>`
    (which is part of the extension pattern) and should be available in the PyPi repository
    under the BSD, MIT, or another less restrictive license.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s good practice for an extension to have two states: uninitialized and
    initialized. This is good practice because your Flask application may not be available
    at the time you instantiate your extension. Our example in the previous chapter
    only initializes Flask-SQLAlchemy after it is imported in the main module. Ok,
    nice to know but how is the initialization process important?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it''s through the initialization that the extension fetches its configuration
    from the application. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we create a configuration class and loaded it with `config.from_object`.
    This way, `LOG_LEVEL` became available to all extensions with a hold on the app
    instance through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to load a configuration into `app.config` is using environment
    variables. This approach is especially useful in deployment environments, because
    you don''t want to store a sensitive deployment configuration in your version
    control repository (it''s unsafe!). It works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If `PATH_TO_CONFIGURATION` is set to a Python file path such as `/home/youruser/someconfig.py`
    then `someconfig.py` will be loaded into config. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both the earlier configuration schemes have the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be warned that `from_envvar` will load the environment variable from the user
    running the project. If you export the environment variable to your user and run
    your project as another, like www-data, it may not be able to find your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Principal and Flask-Login (aka Batman and Robin)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in the project page ([https://pythonhosted.org/Flask-Principal/](https://pythonhosted.org/Flask-Principal/)),
    Flask-Principal is a permission extension. It manages who can access what and
    to what extent. You usually should use it with an authentication and session manager,
    as is the case of Flask-Login, another extension we'll learn in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask-Principal handles permissions through four simple entities: **Identity**,
    **IdentityContext**, **Need**, and **Permission**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: This implies the way Flask-Principal identifies a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IdentityContext**: This implies the context of a user tested against Permission.
    It is used to verify whether the user has the right to do something. It can be
    used as a decorator (block unauthorized access) or as a context manager (only
    execute).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **Need** is a criterion you need (aha moment!) to satisfy in order to do
    something, such as having a role or a permission. There are a few preset needs
    available with Principal, but you may create your own easily, as a Need is just
    a named tuple such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Permission**: This is a group of needs that should be satisfied in order
    to allow something. Interpret it as a guardian of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given that we have our authorization extension all set, we need to authorize
    against something. A usual scenario is to restrict access to an administrative
    interface to administrators (don''t say anything). To do that, we need to identify
    who is an administrator and who isn''t. Flask-Login can be of help here by providing
    us with user session management (login and logout). Let''s try an example. First,
    we make sure the required dependencies are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As our example now is just too big, we'll understand it piecemeal. First, we
    make the necessary imports and create our extension instances. We set the `login_view`
    for the `login_manager` so that it knows where to redirect our user if he tries
    to access a page that requires user authentication. Be aware that Flask-Principal
    does not handle or keep track of logged users. That is Flask-Login abracadabra!
  prefs: []
  type: TYPE_NORMAL
- en: 'We also create our `admin_permission`. Our admin permission has only one need:
    the role admin. This way, we are defining that, for our permission to accept a
    user, this user needs to have the Role `admin`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have two models here, one to hold our user information and another to hold
    our user roles. A role is usually used to categorize users, like `admin`; you
    may have three admins in your system and all of them will have the role admin.
    As a result, they will all be able to do "admin stuff", if the permissions are
    properly configured. Notice we define an `is_active` method for User. That method
    is required and I advise you to always overwrite it, even though `UserMixin` already
    provides an implementation. `is_active` is used to tell `login` whether the user
    is active or not; if not active, he may not log in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we write the `LoginForm` ourselves. You could say: "Why not use `model_form`,
    dude?" Well, to use `model_form` here, you would have to initialize your database
    with your app (that you do not have yet) and set up a context. Just too much trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: We also define two custom validators, one to check if the `username` is valid
    and another to check if the `password` and `username` match.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice we give very broad error messages for this particular form. We do this
    in order to avoid giving too much info to a possible attacker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define our configuration objects, our `app` setup, and application
    factory. I would say the tricky part is the setup, as it registers views using
    an `app` method and not a decorator (yes, the same result as using `@app.route`)
    and we connect our `identity_loaded` signal to our app, so that the user identity
    is loaded and available in each request. We could also register it as a decorator,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `load_user` function is required by Flask-Login to load the user using the
    `userid` stored in the session storage. It should return `None`, if the `userid`
    was not found. Do not throw an exception here.
  prefs: []
  type: TYPE_NORMAL
- en: '`on_identity_loaded` is registered with the `identity_loaded` signal and is
    used to load identity needs stored in your models. This is required because Flask-Principal
    is a generic solution and has no idea of how you have your permissions stored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`login_view` and `logout_view` are just what is expected of them: a view to
    authenticate and another to unauthenticate the user. In both cases, you just have
    to make sure to call the appropriate Flask-Login functions (`login_user` and `logout_user`)
    and send an adequate Flask-Principal signal (and clean the session in the logout).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our actual views: `admin_view` and `admin_only_view`. Both
    of them do the exact same thing, they check whether the user is logged with Flask-Login
    and then check if they have adequate permission to access the view. The difference
    here is that, in the first scenario, `admin_view` uses permission as a decorator
    to verify the user''s credentials and as a context in the second scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`populate` is used to add a proper user and role to our database in case you
    want to test it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A word of caution about our earlier example: we used plain text for the user
    database. In actual live code, you don''t want to do that because it is common
    practice for users to use the same password for multiple sites. If the password
    is in plain text, anyone with access to the database will be able know it and
    test it against sensitive sites. The solution provided in [http://flask.pocoo.org/snippets/54/](http://flask.pocoo.org/snippets/54/)
    might help you avoid this scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now here is an example `base.html` template you could use with the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice we use `current_user.is_authenticated()` to check if the user is authenticated
    in the template as `current_user` is available in all templates. Now, try writing
    `login.html` and `admin.html` on your own, extending `base.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Admin like a boss
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons why Django got so famous is because it has a nice and flexible
    administrative interface and we want one too!
  prefs: []
  type: TYPE_NORMAL
- en: Just like Flask-Principal and Flask-Login, Flask-Admin, the extension we'll
    use to build our administrative interface, does not require a particular database
    to work with. You may use MongoDB as a relational database (with SQLAlchemy or
    PeeWee), or another database you happen to like.
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to Django, where the admin interface is focused in the apps/models,
    Flask-Admin is focused in page/models. You cannot (without some heavy coding)
    load a whole blueprint (the Flask equivalent of a Django app) into the admin interface,
    but you can create a page for your blueprint and register the blueprint models
    with it. One advantage of this approach is that you may pick where all your models
    will be listed with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we created two models to hold our user and role information,
    so, let''s create a simple admin interface for these two models. We make sure
    our dependency is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create and initialize the `admin` extension and then register
    our models with it using `ModelView`, a special class that creates a **CRUD**
    for our model. Run this code and try to access `http://127.0.0.1:5000/admin/`;
    you'll see a nice administrative interface with a Home link at the top followed
    by a Profile drop-down with two links, **User** and **Role**, that point to our
    model CRUDs. That's a very basic example that does not amount to much, as you
    cannot have an administrative interface like that, open to all users.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to add authentication and permission verification to our admin views
    is by extending `ModelView` and `IndexView`. We''ll also use a cool design pattern
    called `mixin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What are we doing here? We overwrite the `is_accessible` method, so that users
    without permission will receive a forbidden-access message, and overwrite the
    `index_view` for `AdminIndexView` and `ModelView`, adding the `login_required`
    decorator that will redirect unauthenticated users to the login page. `admin_permission`
    verifies that the given identity has the required set of permissions—`RoleNeed('admin')`,
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're wondering what a mixin is, try this link [http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful](http://stackoverflow.com/questions/533631/what-is-a-mixin-and-why-are-they-useful).
  prefs: []
  type: TYPE_NORMAL
- en: As our model already has **Create, Read, Update, Delete** (**CRUD**) and permission
    control access, how could we modify our CRUD to show just certain fields, or prevent
    the addition of other fields?
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like Django Admin, Flask-Admin allows you to change your ModelView behavior
    through setting class attributes. A few of my personal favorites are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`can_create`: This allows the user to create the model using CRUD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_edit`: This allows the user to update the model using CRUD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_delete`: This allows the user to delete the model using CRUD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_template`, `edit_template`, and `create_template`: These are default
    CRUD templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list_columns`: This implies thats columns show in the list view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column_editable_list`: This indicates columns that can be edited in the list
    view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form`: This is the form used by CRUD to edit and create views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_args`: This is used to pass form field arguments. Use it like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`form_overrides`: use it to override a form field like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`form_choices`: allow you to define choices for a form field. Use it like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Custom pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, were you willing to add a custom **reports page** to your administrative
    interface, you certainly would not use a model view for the task. For these cases,
    add a custom `BaseView` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you have an admin interface with a nice Reports Page link at the top. Do
    not forget to write a `reports.html` page in order to make the preceding example
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if you don''t want the link to be shown in the navigation bar, because
    you have it somewhere else? Overwrite the `BaseView.is_visible` method as it controls
    whether the view will appear in the navigation bar. Do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we just learned some tricks with regard to user authorization
    and authentication, and even had a go at creating an administrative interface.
    That was quite a lot of knowledge that will help you extensively in your daily
    coding, as security (and making sure people just interact with what they can and
    should interact with) is a quite common need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rejoice, my friend, as now you know how to develop robust Flask applications,
    using MVC, TDD, relational, and NoSQL databases integrated with permissions and
    authentication control: forms; how to implement cross site forgery protection;
    and even how to use an administrative tool out-of-the-box.'
  prefs: []
  type: TYPE_NORMAL
- en: The focus of our studies was on knowing all the most useful tools (in my opinion,
    of course) in the Flask development world and how to use them to some extent.
    We did not explore any of them in greater depth, because of scope restrictions,
    but the basics were certainly shown.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is left for you to improve your understanding of each of the presented
    extensions and libraries and to for new ones. The next and final chapter tries
    to enlighten you in this journey, suggesting reading material, articles, and tutorials
    (among other things).
  prefs: []
  type: TYPE_NORMAL
- en: I hope you've enjoyed the book so far and take great pleasure in the final notes.
  prefs: []
  type: TYPE_NORMAL
