- en: Chapter 4. Command-line Tools to Find Domain Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat application we built in the previous chapters is ready to take the
    world by storm, but not before we give it a home on the Internet. Before we invite
    our friends to join the conversation, we need to pick a valid, catchy, and available
    domain name that we can point to the server running our Go code. Instead of sitting
    in front of our favorite domain name provider for hours on end trying different
    names, we are going to develop a few command-line tools that will help us find
    the right one. As we do so, we will see how the Go standard library allows us
    to interface with the terminal and other executing applications, as well as explore
    some patterns and practices to build command-line programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build complete command-line applications with as little as a single code
    file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to ensure that the tools we build can be composed with other tools using
    standard streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with a simple third-party JSON RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to utilize the standard in and out pipes in Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read from a streaming source one line at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a WHOIS client to look up domain information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to store and use sensitive or deployment-specific information in environment
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe design for command-line tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a series of command-line tools that use the standard streams
    (`stdin` and `stdout` ) to communicate with the user and with other tools. Each
    tool will take input line by line via the standard in pipe, process it in some
    way, and then print the output line by line to the standard out pipe for the next
    tool or for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the standard input is connected to the user''s keyboard, and the
    standard output is printed to the terminal from which the command was run; however,
    both can be redirected using redirection metacharacters. It''s possible to throw
    the output away by redirecting it to `NUL` on Windows or `/dev/null` on Unix machines,
    or redirecting it to a file, which will cause the output to be saved to the disk.
    Alternatively, you can pipe (using the `|` pipe character) the output of one program
    into the input of another; it is this feature that we will make use of in order
    to connect our various tools together. For example, you could pipe the output
    from one program to the input of another program in a terminal by using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our tools will work with lines of strings where each line (separated by a linefeed
    character) represents one string. When run without any pipe redirection, we will
    be able to interact directly with the programs using the default in and out, which
    will be useful when testing and debugging our code.
  prefs: []
  type: TYPE_NORMAL
- en: Five simple programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build five small programs that we will combine together
    at the end. The key features of the programs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sprinkle** : This program will add some web-friendly sprinkle words to increase
    the chances of finding available domain names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domainify** : This program will ensure words are acceptable for a domain
    name by removing unacceptable characters and replacing spaces with hyphens and
    adding an appropriate top-level domain (such as `.com` and `.net` ) to the end'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coolify** : This program will make a boring old normal word into Web 2.0
    by fiddling around with vowels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synonyms** : This program will use a third-party API to find synonyms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Available** : This program will check to see whether the domain is available
    or not using an appropriate WHOIS server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five programs might seem like a lot for one chapter, but don't forget how small
    entire programs can be in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Sprinkle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first program augments incoming words with some sugar terms in order to
    improve the odds of finding available names. Many companies use this approach
    to keep the core messaging consistent while being able to afford the `.com` domain.
    For example, if we pass in the word `chat` , it might pass out `chatapp` ; alternatively,
    if we pass in `talk` , we may get back `talk time` .
  prefs: []
  type: TYPE_NORMAL
- en: Go's `math/rand` package allows us to break away from the predictability of
    computers to give a chance or opportunity to get involved in our program's process
    and make our solution feel a little more intelligent than it actually is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our Sprinkle program work, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an array of transformations using a special constant to indicate where
    the original word will appear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `bufio` package to scan input from `stdin` and `fmt.Println` to write
    output to `stdout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `math/rand` package to randomly select which transformation to apply
    to the word, such as appending "app" or prefixing the term with "get"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of our programs will reside in the `$GOPATH/src` directory. For example,
    if your `GOPATH` is `~/Work/projects/go` , you would create your program folders
    in the `~/Work/projects/go/src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `$GOPATH/src` directory, create a new folder called `sprinkle` and add
    a `main.go` file containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From now on, it is assumed that you will sort out the appropriate `import` statements
    yourself. If you need assistance, refer to the tips provided in [Appendix](text00062.html#page
    "Appendix A. Good Practices for a Stable Go Environment") , *Good Practices for
    a Stable Go Environment* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code represents our complete Sprinkle program. It defines three
    things: a constant, a variable, and the obligatory `main` function, which serves
    as the entry point to Sprinkle. The `otherWord` constant string is a helpful token
    that allows us to specify where the original word should occur in each of our
    possible transformations. It lets us write code such as `otherWord+"extra"` ,
    which makes it clear that, in this particular case, we want to add the word extra
    to the end of the original word.'
  prefs: []
  type: TYPE_NORMAL
- en: The possible transformations are stored in the `transforms` variable that we
    declare as a slice of strings. In the preceding code, we defined a few different
    transformations such as adding `app` to the end of a word or `lets` before it.
    Feel free to add some more in there; the more creative, the better.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, the first thing we do is use the current time as a random
    seed. Computers can't actually generate random numbers, but changing the seed
    number for the random algorithms gives the illusion that it can. We use the current
    time in nanoseconds because it's different each time the program is run (provided
    the system clock isn't being reset before each run).
  prefs: []
  type: TYPE_NORMAL
- en: We then create a `bufio.Scanner` object (called `bufio.NewScanner` ) and tell
    it to read input from `os.Stdin` , which represents the standard in stream. This
    will be a common pattern in our five programs since we are always going to read
    from standard in and write to standard out.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bufio.Scanner` object actually takes `io.Reader` as its input source, so
    there is a wide range of types that we could use here. If you were writing unit
    tests for this code, you could specify your own `io.Reader` for the scanner to
    read from, removing the need for you to worry about simulating the standard input
    stream.
  prefs: []
  type: TYPE_NORMAL
- en: As the default case, the scanner allows us to read, one at a time, blocks of
    bytes separated by defined delimiters such as a carriage return and linefeed characters.
    We can specify our own split function for the scanner or use one of the options
    built in the standard library. For example, there is `bufio.ScanWords` that scans
    individual words by breaking on whitespace rather than linefeeds. Since our design
    specifies that each line must contain a word (or a short phrase), the default
    line-by-line setting is ideal.
  prefs: []
  type: TYPE_NORMAL
- en: A call to the `Scan` method tells the scanner to read the next block of bytes
    (the next line) from the input, and returns a `bool` value indicating whether
    it found anything or not. This is how we are able to use it as the condition for
    the `for` loop. While there is content to work on, `Scan` returns `true` and the
    body of the `for` loop is executed, and when `Scan` reaches the end of the input,
    it returns `false` , and the loop is broken. The bytes that have been selected
    are stored in the `Bytes` method of the scanner, and the handy `Text` method that
    we use converts the `[]byte` slice into a string for us.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `for` loop (so for each line of input), we use `rand.Intn` to select
    a random item from the `transforms` slice, and use `strings.Replace` to insert
    the original word where the `otherWord` string appears. Finally, we use `fmt.Println`
    to print the output to the default standard output stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our program and play with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the program is running, since we haven''t piped any content in, or specified
    a source for it to read from, we will use the default behavior where it reads
    the user input from the terminal. Type in `chat` and hit return. The scanner in
    our code notices the linefeed character at the end of the word and runs the code
    that transforms it, outputting the result. For example, if you type `chat` a few
    times, you might see output like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Sprinkle never exits (meaning the `Scan` method never returns `false` to break
    the loop) because the terminal is still running; in normal execution, the in pipe
    will be closed by whatever program is generating the input. To stop the program,
    hit *Ctrl* + *C* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let''s try running Sprinkle specifying a different input
    source, we are going to use the `echo` command to generate some content, and pipe
    it into our Sprinkle program using the pipe character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The program will randomly transform the word, print it out, and exit since the
    `echo` command generates only one line of input before terminating and closing
    the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully completed our first program, which has a very simple but
    useful function, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – configurable transformations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an extra assignment, rather than hardcoding the `transformations` array as
    we have done, see if you can externalize it into a text file or database.
  prefs: []
  type: TYPE_NORMAL
- en: Domainify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the words that output from Sprinkle contain spaces and perhaps other
    characters that are not allowed in domains, so we are going to write a program,
    called Domainify, that converts a line of text into an acceptable domain segment
    and add an appropriate **Top-level Domain** ( **TLD** ) to the end. Alongside
    the `sprinkle` folder, create a new one called `domainify` , and add a `main.go`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice a few similarities between the Domainify and Sprinkle programs:
    we set the random seed using `rand.Seed` , generate a `NewScanner` method wrapping
    the `os.Stdin` reader, and scan each line until there is no more input.'
  prefs: []
  type: TYPE_NORMAL
- en: We then convert the text to lowercase and build up a new slice of `rune` types
    called `newText` . The `rune` types consist only of characters that appear in
    the `allowedChars` string, which `strings.ContainsRune` lets us know. If `rune`
    is a space that we determine by calling `unicode.IsSpace` , we replace it with
    a hyphen, which is an acceptable practice in domain names.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ranging over a string returns the index of each character and a `rune` type,
    which is a numerical value (specifically `int32` ) representing the character
    itself. For more information about runes, characters, and strings, refer to [http://blog.golang.org/strings](http://blog.golang.org/strings)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we convert `newText` from a `[]rune` slice to a string and add either
    `.com` or `.net` to the end before printing it out using `fmt.Println` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run Domainify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Type in some of these options to see how `domainify` reacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Monkey`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hello Domainify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"What''s up?"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`One (two) three!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that, for example, `One (two) three!` might yield `one-two-three.com`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to compose Sprinkle and Domainify to see them work together.
    In your terminal, navigate to the parent folder (probably `$GOPATH/src` ) of `sprinkle`
    and `domainify` , and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we ran the Sprinkle program and piped the output into the Domainify program.
    By default, `sprinkle` uses the terminal as the input and `domanify` outputs to
    the terminal. Try typing in `chat` a few times again, and notice the output is
    similar to what Sprinkle was outputting previously, except now the words are acceptable
    for domain names. It is this piping between programs that allows us to compose
    command-line tools together.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – making top-level domains configurable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only supporting `.com` and `.net` top-level domains is fairly limiting. As an
    additional assignment, see if you can accept a list of TLDs via a command-line
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: Coolify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often domain names for common words such as `chat` are already taken and a common
    solution is to play around with the vowels in the words. For example, we might
    remove the `a` leaving `cht` (which is actually less likely to be available),
    or add an `a` to produce `chaat` . While this clearly has no actual effect on
    coolness, it has become a popular, albeit slightly dated, way to secure domain
    names that still sound like the original word.
  prefs: []
  type: TYPE_NORMAL
- en: Our third program, Coolify, will allow us to play with the vowels of words that
    come in via the input, and write the modified versions to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `coolify` alongside `sprinkle` and `domainify` ,
    and create the `main.go` code file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding Coolify code looks very similar to the codes of Sprinkle
    and Domainify, it is slightly more complicated. At the very top of the code we
    declare two constants, `duplicateVowel` and `removeVowel` , that help make Coolify
    code more readable. The `switch` statement decides whether we duplicate or remove
    a vowel. Also, using these constants, we are able to express our intent very clearly,
    rather than using just `true` or `false` .
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `randBool` helper function that just randomly returns `true`
    or `false` by asking the `rand` package to generate a random number, and checking
    whether if that number comes out as zero. It will be either `0` or `1` , so there's
    a 50/50 chance of it being `true` .
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function for Coolify starts the same way as the `main` functions
    for Sprinkle and Domainify—by setting the `rand.Seed` method and creating a scanner
    of the standard input stream before executing the loop body for each line of input.
    We call `randBool` first to decide whether we are even going to mutate a word
    or not, so Coolify will only affect half of the words passed through it.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each rune in the string and look for a vowel. If our `randBool`
    method returns `true` , we keep the index of the vowel character in the `vI` variable.
    If not, we keep looking through the string for another vowel, which allows us
    to randomly select a vowel from the words rather than always modifying the same
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have selected a vowel, we then use `randBool` again to randomly decide
    what action to take.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is where the helpful constants come in; consider the following alternative
    switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, it's difficult to tell what is going on because
    `true` and `false` don't express any context. On the other hand, using `duplicateVowel`
    and `removeVowel` tells anyone reading the code what we mean by the result of
    `randBool` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The three dots following the slices cause each item to pass as a separate argument
    to the `append` function. This is an idiomatic way of appending one slice to another.
    Inside the `switch` case, we do some slice manipulation to either duplicate the
    vowel or remove it altogether. We are reslicing our `[]byte` slice and using the
    `append` function to build a new one made up of sections of the original word.
    The following diagram shows which sections of the string we access in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coolify](img/Image00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take the value `blueprints` as an example word, and assume that our code
    selected the first `e` character as the vowel (so that `vI` is `3` ), we can see
    what each new slice of word represents in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `word[:vI+1]` | `blue` | Describes a slice from the beginning of the word
    slice to the selected vowel. The `+1` is required because the value following
    the colon does not include the specified index; rather it slices up to that value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `word[vI:]` | `eprints` | Describes a slice starting at and including the
    selected vowel to the end of the slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `word[:vI]` | `blu` | Describes a slice from the beginning of the word slice
    up to, but not including, the selected vowel. |'
  prefs: []
  type: TYPE_TB
- en: '| `word[vI+1:]` | `prints` | Describes a slice from the item following the
    selected vowel to the end of the slice. |'
  prefs: []
  type: TYPE_TB
- en: After we modify the word, we print it out using `fmt.Println` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build Coolify and play with it to see what it can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When Coolify is running, try typing `blueprints` to see what sort of modifications
    it comes up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how Coolify plays with Sprinkle and Domainify by adding their names
    to our pipe chain. In the terminal, navigate back (using the `cd` command) to
    the parent folder and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will first spice up a word with extra pieces and make it cooler by tweaking
    the vowels before finally transforming it into a valid domain name. Play around
    by typing in a few words and seeing what suggestions our code makes.
  prefs: []
  type: TYPE_NORMAL
- en: Synonyms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our programs have only modified words, but to really bring our solution
    to life, we need to be able to integrate a third-party API that provides word
    synonyms. This allows us to suggest different domain names while retaining the
    original meaning. Unlike Sprinkle and Domainify, Synonyms will write out more
    than one response for each word given to it. Our architecture of piping programs
    together means this is no problem; in fact we do not even have to worry about
    it since each of the three programs is capable of reading multiple lines from
    the input source.
  prefs: []
  type: TYPE_NORMAL
- en: The Big Hugh Thesaurus at [bighughlabs.com](http://bighughlabs.com) has a very
    clean and simple API that allows us to make a single HTTP `GET` request in order
    to look up synonyms.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If in the future the API we are using changes or disappears (after all, this
    is the Internet!), you will find some options at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use the Big Hugh Thesaurus, you'll need an API key, which you
    can get by signing up to the service at [http://words.bighugelabs.com/](http://words.bighugelabs.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables for configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your API key is a sensitive piece of configuration information that you won't
    want to share with others. We could store it as `const` in our code, but that
    would not only mean we couldn't share our code without sharing our key (not good,
    especially if you love open source projects), but also, and perhaps more importantly,
    you would have to recompile your project if the key expires or if you want to
    use a different one.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is using an environment variable to store the key, as this
    will allow you to easily change it if you need to. You could also have different
    keys for different deployments; perhaps you have one key for development or testing
    and another for production. This way, you can set a specific key for a particular
    execution of code, so you can easily switch keys without having to change your
    system-level settings. Either way, different operating systems deal with environment
    variables in similar ways, so they are a perfect choice if you are writing cross-platform
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new environment variable called `BHT_APIKEY` and set your API key as
    its value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For machines running a bash shell, you can modify your `~/.bashrc` file or
    similar to include `export` commands such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: On Windows machines, you can navigate to the properties of your computer and
    look for **Environment Variables** in the **Advanced** section.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming a web API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Making a request for [http://words.bighugelabs.com/apisample.php?v=2&format=json](http://words.bighugelabs.com/apisample.php?v=2&format=json)
    in a web browser shows us what the structure of JSON response data looks like
    when finding synonyms for the word love:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The real API returns a lot more actual words than what is printed here, but
    the structure is the important thing. It represents an object where the keys describe
    the types of words (verbs, nouns, and so on) and values are objects that contain
    arrays of strings keyed on `syn` or `ant` (for synonym and antonym respectively);
    it is the synonyms we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn this JSON string data into something we can use in our code, we must
    decode it into structures of our own using capabilities found in the `encoding/json`
    package. Because we''re writing something that could be useful outside the scope
    of our project, we will consume the API in a reusable package rather than directly
    in our program code. Create a new folder called `thesaurus` alongside your other
    program folders (in `$GOPATH/src` ) and insert the following code into a new `bighugh.go`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `BigHugh` type we define houses the necessary API
    key and provides the `Synonyms` method that will be responsible for doing the
    work of accessing the endpoint, parsing the response, and returning the results.
    The most interesting parts of this code are the `synonyms` and `words` structures.
    They describe the JSON response format in Go terms, namely an object containing
    noun and verb objects, which in turn contain a slice of strings in a variable
    called `Syn` . The tags (strings in backticks following each field definition)
    tell the `encoding/json` package which fields to map to which variables; this
    is required since we have given them different names.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, JSON keys have lowercase names, but we have to use capitalized names
    in our structures so that the `encoding/json` package knows that the fields exist.
    If we didn't, the package would simply ignore the fields. However, the types themselves
    (`synonyms` and `words` ) do not need to be exported.
  prefs: []
  type: TYPE_NORMAL
- en: The `Synonyms` method takes a `term` argument and uses `http.Get` to make a
    web request to the API endpoint in which the URL contains not only the API key
    value, but also the `term` value itself. If the web request fails for some reason,
    we will make a call to `log.Fatalln` , which writes the error out to the standard
    error stream and exits the program with a non-zero exit code (actually an exit
    code of `1` )—this indicates that an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If the web request is successful, we pass the response body (another `io.Reader`
    ) to the `json.NewDecoder` method and ask it to decode the bytes into the `data`
    variable that is of our `synonyms` type. We defer the closing of the response
    body in order to keep memory clean before using Go's built-in `append` function
    to concatenate both `noun` and `verb` synonyms to the `syns` slice that we then
    return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have implemented the `BigHugh` thesaurus, it isn''t the only option
    out there, and we can express this by adding a `Thesaurus` interface to our package.
    In the `thesaurus` folder, create a new file called `thesaurus.go` , and add the
    following interface definition to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This simple interface just describes a method that takes a `term` string and
    returns either a slice of strings containing the synonyms, or an error (if something
    goes wrong). Our `BigHugh` structure already implements this interface, but now
    other users could add interchangeable implementations for other services, such
    as [Dictionary.com](http://Dictionary.com) or the Merriam-Webster Online service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we are going to use this new package in a program. Change directory in
    terminal by backing up a level to `$GOPATH/src` , create a new folder called `synonyms`
    , and insert the following code into a new `main.go` file you will place in that
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When you manage your imports again, you will have written a complete program
    capable of looking up synonyms for words by integrating the Big Huge Thesaurus
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the first thing our `main` function does is get the `BHT_APIKEY`
    environment variable value via the `os.Getenv` call. To bullet proof your code,
    you might consider double-checking to ensure this value is properly set, and report
    an error if it is not. For now, we will assume that everything is configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the preceding code starts to look a little familiar since it scans each
    line of input again from `os.Stdin` and calls the `Synonyms` method to get a list
    of replacement words.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a program and see what kind of synonyms the API comes back with
    when we input the word `chat` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The results you get will most likely differ from what we have listed here since
    we're hitting a live API, but the important aspect here is that when we give a
    word or term as input to the program, it returns a list of synonyms as output,
    one per line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try chaining your programs together in various orders to see what result you
    get. Regardless, we will do this together later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting domain suggestions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By composing the four programs we have built so far in this chapter, we already
    have a useful tool for suggesting domain names. All we have to do now is run the
    programs while piping the output into input in the appropriate way. In a terminal,
    navigate to the parent folder and run the following single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because the `synonyms` program is first in our list, it will receive the input
    from the terminal (whatever the user decides to type in). Similarly, because `domainify`
    is last in the chain, it will print its output to the terminal for the user to
    see. At each step, the lines of words will be piped through the other programs,
    giving them each a chance to do their magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in some words to see some domain suggestions, for example, if you type
    `chat` and hit return, you might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The number of suggestions you get will actually depend on the number of synonyms,
    since it is the only program that generates more lines of output than we give
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We still haven't solved our biggest problem—the fact that we have no idea whether
    the suggested domain names are actually available or not, so we still have to
    sit and type each of them into a website. In the next section, we will address
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final program, Available, will connect to a WHOIS server to ask for details
    about domains passed into it—of course, if no details are returned, we can safely
    assume that the domain is available for purchase. Unfortunately, the WHOIS specification
    (see [http://tools.ietf.org/html/rfc3912](http://tools.ietf.org/html/rfc3912)
    ) is very small and contains no information about how a WHOIS server should reply
    when you ask it for details about a domain. This means programmatically parsing
    the response becomes a messy endeavor. To address this issue for now, we will
    integrate with only a single WHOIS server that we can be sure will have `No match`
    somewhere in the response when it has no records for the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more robust solution might be to have a WHOIS interface with well-defined
    structures for the details, and perhaps an error message for the cases when the
    domain doesn't exist—with different implementations for different WHOIS servers.
    As you can imagine, it's quite a project; perfect for an open source effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `available` alongside the others in `$GOPATH/src`
    and add a `main.go` file in it containing the following function code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `exists` function implements what little there is in the WHOIS specification
    by opening a connection to port `43` on the specified `whoisServer` instance with
    a call to `net.Dial` . We then defer the closing of the connection, which means
    that however the function exits (successfully or with an error, or even a panic),
    `Close()` will still be called on the connection `conn` . Once the connection
    is open, we simply write the domain followed by `\r\n` (the carriage return and
    line feed characters). This is all the specification tells us, so we are on our
    own from now on.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, we are looking for some mention of no match in the response, and
    that is how we will decide whether a domain exists or not (`exists` in this case
    is actually just asking the WHOIS server if it has a record for the domain we
    specified). We use our favorite `bufio.Scanner` method to help us iterate over
    the lines in the response. Passing the connection into `NewScanner` works because
    `net.Conn` is actually an `io.Reader` too. We use `strings.ToLower` so we don't
    have to worry about case sensitivity, and `strings.Contains` to see if any of
    the lines contains the no match text. If it does, we return `false` (since the
    domain doesn't exist), otherwise we return `true` .
  prefs: []
  type: TYPE_NORMAL
- en: The `com.whois-servers.net` WHOIS service supports domain names for `.com` and
    `.net` , which is why the Domainify program only adds these types of domains.
    If you used a server that had WHOIS information for a wider selection of domains,
    you could add support for additional TLDs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a `main` function that uses our `exists` function to check to see
    whether the incoming domains are available or not. The check mark and cross mark
    symbols in the following code are optional—if your terminal doesn't support them
    you are free to substitute them with simple `Yes` and `No` strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `main.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code for the `main` function, we simply iterate over each line
    coming in via `os.Stdin` , printing out the domain with `fmt.Print` (but not `fmt.Println`
    , as we do not want the linefeed yet), calling our `exists` function to see whether
    the domain exists or not, and printing out the result with `fmt.Println` (because
    we *do* want a linefeed at the end).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `time.Sleep` to tell the process to do nothing for `1` second
    in order to make sure we take it easy on the WHOIS server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most WHOIS servers will be limited in various ways in order to prevent you from
    taking up too much resources. So slowing things down is a sensible way to make
    sure we don't make the remote servers angry.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what this also means for unit tests. If a unit test was actually making
    real requests to a remote WHOIS server, every time your tests run, you will be
    clocking up stats against your IP address. A much better approach would be to
    stub the WHOIS server to simulate real responses.
  prefs: []
  type: TYPE_NORMAL
- en: The `marks` map at the top of the preceding code is a nice way to map the Boolean
    response from `exists` to human-readable text, allowing us to just print the response
    in a single line using `fmt.Println(marks[!exist])` . We are saying not exist
    because our program is checking whether the domain is available or not (logically
    the opposite of whether it exists in the WHOIS server or not).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the check and cross characters in our code happily because all Go
    code files are UTF-8 compliant—the best way to actually get these characters is
    to search the Web for them, and use copy and paste to bring them into code; else
    there are platform-dependent ways to get such special characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'After fixing the `import` statements for the `main.go` file, we can try out
    Available to see whether domain names are available or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Available is running, type in some domain names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for domains that are obviously not available, we get our little
    cross mark, but when we make up a domain name using random numbers, we see that
    it is indeed available.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing all five programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have completed all five of our programs, it''s time to put them
    all together so that we can use our tool to find an available domain name for
    our chat application. The simplest way to do this is to use the technique we have
    been using throughout this chapter: using pipes in a terminal to connect the output
    and input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, navigate to the parent folder of the five programs and run
    the following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once the programs are running, type in a starting word and see how it generates
    suggestions before checking their availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, typing in `chat` might cause the programs to take the following
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The word `chat` goes into `synonyms` and out comes a series of synonyms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confab`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`confabulation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schmooze`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The synonyms flow into `sprinkle` where they are augmented with web-friendly
    prefixes and suffixes such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confabapp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goconfabulation`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schmooze time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These new words flow into `coolify` , where the vowels are potentially tweaked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confabaapp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goconfabulatioon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schmoooze time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The modified words then flow into `domainify` where they are turned into valid
    domain names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confabaapp.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goconfabulatioon.net`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schmooze-time.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the domain names flow into `available` where they are checked against
    the WHOIS server to see whether somebody has already taken the domain or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confabaapp.com` ×'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`goconfabulatioon.net` ✔'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schmooze-time.com` ✔'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One program to rule them all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running our solution by piping programs together is an elegant architecture,
    but it doesn't have a very elegant interface. Specifically, whenever we want to
    run our solution, we have to type the long messy line where each program is listed
    separated by pipe characters. In this section, we are going to write a Go program
    that uses the `os/exec` package to run each subprogram while piping the output
    from one into the input of the next as per our design.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `domainfinder` alongside the other five programs,
    and create another new folder called `lib` inside that folder. The `lib` folder
    is where we will keep builds of our subprograms, but we don't want to be copying
    and pasting them every time we make a change. Instead, we will write a script
    that builds the subprograms and copies the binaries to the `lib` folder for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `build.sh` on Unix machines or `build.bat` for Windows
    and insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script simply builds all of our subprograms (including `domainfinder`
    , which we are yet to write) telling `go build` to place them in our `lib` folder.
    Be sure to give the new script execution rights by doing `chmod +x build.sh` ,
    or something similar. Run this script from a terminal and look inside the `lib`
    folder to ensure that it has indeed placed the binaries for our subprograms in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about the `no buildable Go source files` error for now, it's just
    Go telling us that the `domainfinder` program doesn't have any `.go` files to
    build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `main.go` inside `domainfinder` and insert the following
    code in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `os/exec` package gives us everything we need to work with running external
    programs or commands from within Go programs. First, our `cmdChain` slice contains
    `*exec.Cmd` commands in the order in which we want to join them together.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the `main` function, we tie the `Stdin` (standard in stream) of
    the first program to the `os.Stdin` stream for this program, and the `Stdout`
    (standard out stream) of the last program to the `os.Stdout` stream for this program.
    This means that, like before, we will be taking input through the standard input
    stream and writing output to the standard output stream.
  prefs: []
  type: TYPE_NORMAL
- en: Our next block of code is where we join the subprograms together by iterating
    over each item and setting its `Stdin` to the `Stdout` of the program before it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows each program, with a description of where it gets
    its input from, and where its output goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Program | Input (Stdin) | Output (Stdout) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `synonyms` | The same `Stdin` as `domainfinder` | `sprinkle` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprinkle` | `synonyms` | `coolify` |'
  prefs: []
  type: TYPE_TB
- en: '| `coolify` | `sprinkle` | `domainify` |'
  prefs: []
  type: TYPE_TB
- en: '| `domainify` | `coolify` | `available` |'
  prefs: []
  type: TYPE_TB
- en: '| `available` | `domainify` | The same `Stdout` as `domainfinder` |'
  prefs: []
  type: TYPE_TB
- en: We then iterate over each command calling the `Start` method, which runs the
    program in the background (as opposed to the `Run` method which will block our
    code until the subprogram exits—which of course is no good since we have to run
    five programs at the same time). If anything goes wrong, we bail with `log.Fatalln`
    , but if the program starts successfully, we then defer a call to kill the process.
    This helps us ensure the subprograms exit when our `main` function exits, which
    will be when the `domainfinder` program ends.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the programs are running, we then iterate over every command again
    and wait for it to finish. This is to ensure that `domainfinder` doesn't exit
    early and kill off all the subprograms too soon.
  prefs: []
  type: TYPE_NORMAL
- en: Run the `build.sh` or `build.bat` script again and notice that the `domainfinder`
    program has the same behavior as we have seen before, with a much more elegant
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how five small command-line programs can, when composed
    together, produce powerful results while remaining modular. We avoided tightly
    coupling our programs so they are still useful in their own right. For example,
    we can use our available program just to check if domain names we manually enter
    are available or not, or we can use our `synonyms` program just as a command-line
    thesaurus.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how standard streams could be used to build different flows of these
    types of programs, and how redirection of the standard input and the standard
    output lets us play around with different flows very easily.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how simple it is in Go to consume a JSON RESTful APIs web service
    when we needed to get synonyms from the Big Hugh Thesaurus. We kept it simple
    at first by coding it inline and later refactoring the code to abstract the `Thesaurus`
    type into its own package, which is ready to share. We also consumed a non-HTTP
    API when we opened a connection to the WHOIS server and wrote data over raw TCP.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the `math/rand` package can bring a little variety and unpredictability,
    by allowing us to use pseudo random numbers and decisions in our code, which meant
    that each time we run our program, we get different results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we built our `domainfinder` super program that composes all the subprograms
    together giving our solution a simple, clean, and elegant interface.
  prefs: []
  type: TYPE_NORMAL
