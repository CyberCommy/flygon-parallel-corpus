- en: IoTFW.js - II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen the basic setup among Raspberry Pi, broker,
    API engine, and the web app. In this chapter, we will work on the remaining part
    of the framework. We will also build a simple example that involves sensing and
    actuating. We will read temperature and humidity using a temperature and humidity
    sensor and also turn on/off an LED connected to our Raspberry Pi using web, desktop,
    or mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the API engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the API engine with web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an end-to-end example using DHT11 and LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a desktop app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with the web app development, we will update the API engine
    to add the device's API and data service, along with web sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `api-engine/server/routes.js`; we will add two routes here. Update `api-engine/server/routes.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add the definitions for these routes. Inside the `api-engine/server/api`
    folder, create a new folder named `device`. Inside the `device` folder, create
    a new file named `index.js`. Update `api-engine/server/api/device/index.js`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added five routes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get one device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, create another file inside the `api-engine/server/api/device/` folder
    named `device.model.js`. This file will consist of the mongoose schema for the
    device collection. Update `api-engine/server/api/device/device.model.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the controller logic. Create a file named `device.controller.js` inside
    the `api-engine/server/api/device` folder and update `api-engine/server/api/device/device.controller.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined the logic for the routes.
  prefs: []
  type: TYPE_NORMAL
- en: The device API manages the device for us. To manage the data for each device,
    we will use this collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will define the data APIs. Create a new folder named `data` inside
    the `api-engine/server/api` folder. Inside the `api-engine/server/api/data` folder,
    create a new file named `index.js` and update `api-engine/server/api/data/index.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined two routes here: one to view data based on a device ID and
    another to create data. The view data route returns the data from a device that
    is limited to the number passed in as part of the request. If you remember, in
    the `web-app/src/app/services/data.service.ts`, we have defined the `dataLimit`
    class variable as `30`. This is the number of records we get, at a given time,
    from the API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, for the mongoose schema, create a new file named `data.model.js` inside
    the `api-engine/server/api/data` folder and update `api-engine/server/api/data/data.model.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the controller logic for the data API. Create a file named `data.controller.js`
    inside `api-engine/server/api/data` and update `api-engine/server/api/data/data.controller.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined two methods: one for getting data for a device and one
    for creating a new data record for a device.'
  prefs: []
  type: TYPE_NORMAL
- en: For the data API, we will implement sockets as well, so when a new record comes
    from the Raspberry Pi, we immediately notify the web app, desktop app, or mobile
    app so that the data can be displayed in real time.
  prefs: []
  type: TYPE_NORMAL
- en: As we see from the preceding code, if the incoming topic is `LED`, we will call
    the `sendLEDData()`, which in turns publishes the data to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `data.socket.js` inside the `api-engine/server/api/data`
    folder and update `api-engine/server/api/data/data.socket.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will take care of sending a new data record as it successfully gets saved
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the socket to the socket configuration. Open `api-engine/server/config/socketio.js`
    and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using `socketio-jwt` to validate the socket connection to see
    if it has JWT. If a valid JWT is not provided, we do not allow the client to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we are done with the required changes to the API engine. Save all
    the files and launch the API engine by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the API engine. In the next section, we will test the integration
    between the web app and API engine and continue our walk through from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating web app and API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Launch the broker, API engine, and web app. Once all of them are successfully
    launched, navigate to `http://localhost:4200/`. Log in with the credentials we
    have created. Once we have successfully logged in, we should see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Which is true, as we do not have any devices in our account. Click on Add Device
    and we should see something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Add a new device by giving it a name. I named my device `Pi 1` and added the
    mac address. We will use the mac address of the device as a unique way of identifying
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Create and we should see a new device created, it will redirect us
    to the home page and display the newly created device, which can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when we click on the View button, we should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the examples across this book, we will keep updating this template and keep
    modifying it as we need to. For now, this is a dummy template represented by `web-app/src/app/device/device.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the developer tools and look at the network tab WS section, as shown
    in the following screenshot, we should be able to see that a web socket request
    is sent to our server with the JWT token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with stitching the Raspberry Pi with the broker, the
    broker with the API engine, and the API engine with the web app. To complete the
    entire round trip of data from the device to the web app, we will implement a
    simple use case in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an end-to-end flow using DHT11 and LED
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start working on the desktop and mobile app, we will implement an
    end-to-end data flow for the Raspberry Pi to the web app and back.
  prefs: []
  type: TYPE_NORMAL
- en: The example that we will work on implements an actuator and a sensor use case.
    We will connect an LED to the Raspberry Pi and turn the LED on/off from the web
    app, and we will also connect a DHT11 temperature sensor to the Raspberry Pi and
    view its values in real time on the web app.
  prefs: []
  type: TYPE_NORMAL
- en: We will get started with the Raspberry Pi, implement the required logic there;
    next, work with the API engine, make the required changes, and finally the web
    app to represent the data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and updating the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will set up the circuit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will make the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Source pin** | **Component pin** |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi pin 1 - 3.3V | Breadboard + railing |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi pin 6 - Ground | Breadboard - railing |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi pin 3 - GPIO 2 | Temperature sensor signal pin |'
  prefs: []
  type: TYPE_TB
- en: '| Raspberry Pi pin 12 - GPIO 18 | LED anode pin |'
  prefs: []
  type: TYPE_TB
- en: '| LED cathode pin | Breadboard - railing |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature sensor + pin | Breadboard + railing |'
  prefs: []
  type: TYPE_TB
- en: '| Temperature sensor - pin | Breadboard - railing |'
  prefs: []
  type: TYPE_TB
- en: We have used a current limiting resistor of 220 ohms between pin 12/GPIO 18
    and the anode of a LED pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this connection has been set up, we will write the required logic. On
    the Raspberry Pi, open the `pi-client/index.js` file and update it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added a couple of node modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rpi-dht-sensor`: [https://www.npmjs.com/package/rpi-dht-sensor](https://www.npmjs.com/package/rpi-dht-sensor);
    this module will help us in reading the values of the DHT11 sensor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpio`: [https://www.npmjs.com/package/rpio](https://www.npmjs.com/package/rpio);
    this module will help us manage GPIOs on the board, using which we will manage
    the LED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have written a `setInterval()` that keeps running forever, every 3 seconds.
    Inside the `callback`, we call the `getDHT11Values()` that read the temperature
    and humidity from the sensor. If there is any change in the temperature and humidity
    values, we publish this data to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice the `client.on('message')`; here, we have added another `if` condition
    and are listening for the `LED` topic. If the current message is from the `LED`
    topic, we know that we will receive either a `1` or `0` indicating to switch on
    or switch off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, finally we will install the two modules, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all the files and run `npm start`; this should connect the Raspberry Pi
    to the broker and subscribe to the `LED` topic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, if we see the console out from the Raspberry Pi, we should see
    something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever there is a change in the data, the data is published to the broker.
    We have not yet implemented the logic for reacting to this data on the API engine,
    which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will add the required code to the MQTT client running on the API engine
    to handle the data from the device. Update `api-engine/server/mqtt/index.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have subscribed to a topic named `dht11`, to listen for a message published
    by the Raspberry Pi about the temperature and humidity values. We have also exposed
    another method named `sendLEDData` that will accept the data that needs to be
    sent to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we save all the files and restart the API engine, we should see something
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can see that the data comes from the Raspberry
    Pi and gets saved to MongoDB. To validate if the data is saved, we can head over
    to the `mlab` DB and look for a collection named `datas` and it should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever the data is saved successfully, the same copy will be sent to the web
    app as well. In the next section, we will display this data in real time on the
    web dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop the code needed to display the data in real
    time inside the web app, as well as provide an interface, using which we can turn
    on/off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: We will get started by adding a toggle switch component. We will use the `ngx-ui-switch`
    ([https://github.com/webcat12345/ngx-ui-switch](https://github.com/webcat12345/ngx-ui-switch))
    for the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'From inside the `web-app-base` folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `ng2-charts` [https://valor-software.com/ng2-charts/](https://valor-software.com/ng2-charts/)
    for plotting charts of our temperature and humidity values. We will install this
    module as well by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the toggle switch and `ng2-charts` modules. Next, we need
    to add this to `@NgModule`. Open `web-app/src/app/app.module.ts` and add the following
    command to the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add `UiSwitchModule` and `ChartsModule` to the imports array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we need to import `chart.js` into our application. Open
    `web-app/.angular-cli.json` and update the `scripts` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Save all the files and restart the web app, if it is already running.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use this directive in the device component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our current use case, we have to display the temperature and humidity values
    as well as provide a toggle switch to turn the LED on/off. For this, our template
    in `web-app/src/app/device/device.component.html` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The required code for the `DeviceComponent` class: `web-app/src/app/device/device.component.ts`
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The key methods to notice are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getData()`: This method is used to get the last 30 records on page load. We
    are sending the data in the descending order from the API engine; hence we extract
    the last record and save it as the last record. We can use the remaining records
    to plot a chart if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toggleChange()`: This method will get fired when the toggle switch is clicked.
    This method will send the data to the API engine to save it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socketInit()`: This method keeps listening to the data save event on the device.
    Using this, we update the `lastRecord` variable with the latest data from the
    device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`genChart()`: This method takes the data collection and then plots a graph.
    When a new data arrives over the socket, we remove the last record in the data
    array and push the new record, keeping the total size of 30 records at all times'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we are done with the development of the template needed to process
    this setup.
  prefs: []
  type: TYPE_NORMAL
- en: Save all files, launch the broker, API engine, and the web app and then log
    in to the application and then navigate to the device page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is set up correctly, we should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, whenever the data comes via sockets, the chart updates automatically!
  prefs: []
  type: TYPE_NORMAL
- en: Now to test the LED, toggle the LED button to on and you should see that the
    LED that we have set up on the Raspberry Pi will light up and similarly if we
    turn it off, it will turn off the LED.
  prefs: []
  type: TYPE_NORMAL
- en: Building the desktop app and implementing an end-to-end flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with an end-to-end flow with the web app, we will extend
    the same to the desktop and mobile apps. We will start off by building a desktop
    client for the same API engine. So, if a user is more comfortable in using a desktop
    app over a web or mobile app, he/she could use this.
  prefs: []
  type: TYPE_NORMAL
- en: This desktop app, we will have all the same features as the web app.
  prefs: []
  type: TYPE_NORMAL
- en: For building the desktop app, we will use the electron ([https://electron.atom.io/](https://electron.atom.io/))
    framework. Using a Yeoman ([http://yeoman.io/](http://yeoman.io/)) generator named
    `generator-electron` ([https://github.com/sindresorhus/generator-electron](https://github.com/sindresorhus/generator-electron)),
    we will scaffold the base application. Then, we will build our web app and use
    the `dist` folder from that build as an input to the desktop app. All this will
    be more clear once we start working.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the yeoman generator and the electron generator. Next, inside
    the `chapter2` folder, create a folder named `desktop-app` and then, open a new
    command prompt/terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This wizard will ask a few questions and you can answer them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will go ahead and install the required dependencies. Once the installation
    is completed, we should see a folder structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With the `node_modules` folder present at the root.
  prefs: []
  type: TYPE_NORMAL
- en: Everything starts with `desktop-app/package.json` start script, which launches
    the `desktop-app/index.js`. `desktop-app/index.js` creates a new browser window
    and launches the `desktop-app/index.html` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly test drive from inside the `desktop-app` folder, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will add the required code. At the root of the `desktop-app` folder,
    create a file named `freeport.js` and update `desktop-app/freeport.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, we will find a free port on the end user's machine
    and launch our web app inside the electron shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a folder named `app` at the root of the `desktop-app` folder.
    We will dump files into this in a moment. Next, at the root of the `desktop-app`
    folder, create a file named `server.js`. Update `server.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we listen to a free port and launch `index.html`. Now, all we need to
    do is update `createMainWindow()` in `desktop-app/index.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That is all the setup we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head back to the terminal/prompt of the `web-app` folder (yes `web-app`,
    not `desktop-app`) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder inside the `web app` folder named `dist`. The
    contents of the `dist` folder should be on the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All code we have written in the web app is finally bundled into the preceding
    files. We will grab all the files (not the `dist` folder) present inside the `dist`
    folder and then paste it inside the `desktop-app/app` folder. The final structure
    of the desktop app after the preceding changes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we are just going to paste the contents of the `web-app/dist` folder
    into the `app` folder of the `desktop-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test drive, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will bring up the log in screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you see a pop up as shown previously, allow it. Once you have successfully
    logged in, you should be able to see all the devices in your account, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, the device information screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can turn the LED on/off and it should react accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build a mobile app using the Ionic framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building the mobile app and implementing an end-to-end flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build our mobile companion app using the Ionic framework
    ([http://ionicframework.com/](http://ionicframework.com/)). The output or the
    example would be the same as what we have done for the web and desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we will install the latest version of `ionic` and `cordova`
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need the mobile app base. If you have not already cloned the book''s
    code repository, you can do so using the following command (anywhere on your machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: or you can download the zip file from [https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript](https://github.com/PacktPublishing/Practical-Internet-of-Things-with-JavaScript)
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the repository has been downloaded, `cd` into the `base` folder and make
    a copy of `mobile-app-base` folder into `chapter2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the copy is completed, `cd` into the `mobile-app` folder and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And then
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will take care of installing the required dependencies and adding Android
    or iOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `mobile-app` folder, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In our `mobile-app` folder, the most important file is `mobile-app/config.xml`.
    This file consists of the definitions needed by cordova to convert the HTML/CSS/JS
    application into a hybrid mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `mobile-app/resources`, `mobile-app/plugins`, and `mobile-app/platforms`
    folder that will consist of the cordova wrapped code for the app we are developing.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, the `mobile-app/src` folder, this folder is where we have all our
    source code. The setup for the mobile is similar to what we had for the web app
    and the desktop app. We have a service folder that has the `mobile-app/src/services/auth.service.ts`
    for authentication, `mobile-app/src/services/device.service.ts` for interfacing
    with the devices API, `mobile-app/src/services/data.service.ts` for fetching the
    latest data from the device, `mobile-app/src/services/socket.service.ts` to set
    up web sockets in our mobile app, and finally, `mobile-app/src/services/toast.service.ts`
    to show notifications, tailored to a mobile. `mobile-app/src/services/toast.service.ts`
    is similar to the notification service we have used in the web and desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the needed pages. The mobile app implements only the login page.
    We are forcing the user to use the web or desktop app to create a new account.
    `mobile-app/src/pages/login/login.ts` consists of the authentication logic. `mobile-app/src/pages/home/home.ts`
    consists of the list of all devices that a user is registered with. `mobile-app/src/pages/add-device/add-device.ts`
    has the logic needed to add a new device and `mobile-app/src/pages/view-device/view-device.ts`
    to view the device information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from inside the `mobile-app` folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch the app in the browser. If you would like to test it on an
    actual app, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the app on the device. In either case, the app will behave
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the app is launched, we will see the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have successfully logged in, we should see the home page as follows.
    We can add a new device using the + icon in the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The newly created device should reflect on our home screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we click on VIEW DEVICE, we should see the device information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we toggle the button on/off, the LED on the Raspberry Pi should turn on/off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another view of the same setup is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding is the setup of the Raspberry Pi 3 with a DHT11 sensor and LED.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have successfully established an end-to-end architecture for executing
    out the Internet of Things examples. From now on, we will work with the web app,
    mobile app, desktop app, Raspberry Pi, and a bit of API engine for our next examples.
    The changes we will make are minimal. We will focus on the use case rather than
    building the setup again and again.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case you do not see the expected output, check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the broker, API engine, web app, and Raspberry Pi app are running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the IP address of the broker provided to the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the IP address of the API engine provided to the mobile app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee), *IoTFW.js
    - I* and in this chapter, we went through the entire process of setting up an
    entire frame to work with the Internet of Things solutions. We built the entire
    framework using only JavaScript as our programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We started with understanding the architecture and data flow from Raspberry
    Pi to an end user device, such as a web app, desktop app, or a mobile app. Then
    we started working on the broker using Mosca, after setting up MongoDB. Next we
    designed and developed the API engine and completed the basic Raspberry Pi setup.
  prefs: []
  type: TYPE_NORMAL
- en: We worked on the web app and desktop app and integrated a simple LED and a DHT11
    temperature and humidity sensor with the Raspberry Pi, and saw a simple flow from
    one end to another. We streamed the temperature and humidity in real time to the
    web app and desktop app, and using the toggle button, we turned on the LED.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we built a mobile app and implemented/validated the LED and DHT11
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Chapter 4](part0083.html#2F4UM0-ce91715363d04669bca1c1545beb57ee), *Smart
    Agriculture*, using the current setup as a base, we will build a smart agriculture
    solution.
  prefs: []
  type: TYPE_NORMAL
