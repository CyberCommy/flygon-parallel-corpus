- en: Server-Side React Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything that you've learned so far in this book has been React code that
    runs in web browsers. React isn't confined to the browser for rendering, and in
    this chapter, you'll learn how to render components from a Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: The first section of this chapter briefly touches upon high-level server rendering
    concepts. The next four sections go into depth, teaching you how to implement
    the most crucial aspects of server-side rendering with React and Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: What is isomorphic JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another term for **server-side rendering** is **isomorphic JavaScript**. This
    is a fancy way of saying JavaScript code that can run in the browser and in Node.js
    without modification. In this section, you'll learn the basic concepts of isomorphic
    JavaScript before diving into code.
  prefs: []
  type: TYPE_NORMAL
- en: The server is a render target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beauty of React is that it's a small abstraction layer that sits on top
    of a rendering target. So far, the target has been the browser, but it can also
    be the server. The render target can be anything, just as long as the correct
    translation calls are implemented behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of rendering on the server, components are rendered to strings.
    The server can''t actually display rendered HTML; all it can do is send the rendered
    markup to the browser. The idea is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/77166a87-3979-4c13-ba5d-00af63f94795.png)'
  prefs: []
  type: TYPE_IMG
- en: It's possible to render a React component on the server and send the rendered
    output to the browser. The question is, why would you want to do this on the server
    instead of in the browser?
  prefs: []
  type: TYPE_NORMAL
- en: Initial load performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main motivation behind server-side rendering, for me personally, is improved
    performance. In particular, the initial rendering just feels faster for the user
    and this translates to an overall better user experience. It doesn't matter how
    fast your application is once it's loaded and ready to go; it's the initial load
    time that leaves a lasting impression on your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three reasons that this approach means better performance for the
    initial load:'
  prefs: []
  type: TYPE_NORMAL
- en: The rendering that takes place on the server is generating a string; there's
    no need to compute a difference or to interact with the DOM in any way. Producing
    a string of rendered markup is inherently faster than rendering components in
    the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rendered HTML is displayed as soon as it arrives. Any JavaScript code that
    needs to run on the initial load is run after the user is already looking at the
    content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are fewer network requests to fetch data from the API, because these have
    already happened on the server and the server typically has vastly more resources
    than a single client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates these performance ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8c12fc51-253b-43fa-871b-cdae1b6a5f38.png)'
  prefs: []
  type: TYPE_IMG
- en: Sharing code between the server and the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a good chance that your application will need to talk to API endpoints
    that are out of your control, for example, an application that is composed from
    many different microservice endpoints. It's rare that you can use data from these
    services without modification. Rather, you have to write code that transforms
    data so that it's usable by your React components.
  prefs: []
  type: TYPE_NORMAL
- en: If you're rendering your components on a Node.js server, then this data transformation
    code will be used by both the client and the server, because on the initial load,
    the server will need to talk to the API, and later on, the component in the browser
    will need to talk to the API.
  prefs: []
  type: TYPE_NORMAL
- en: It's not just about transforming the data that's returned from these services
    either. For example, you have to think about providing input to them as well,
    like when creating or modifying resources.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental adjustment that you'll need to make as a React programmer is
    to assume that any given component that you implement will need to be rendered
    on the server. This may seem like a minor adjustment, but the devil is in the
    detail. Speaking of which, let's jump into some code examples now.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rendering components in Node.js means rendering to strings, instead of trying
    to figure out the best way to insert them into the DOM. The string content is
    then returned to the browser, which displays this to the user immediately. Let''s
    look at an example. First, the component to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s implement the server that will render this component when the
    browser asks for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you visit [http://127.0.0.1:8080](http://127.0.0.1:8080) in your browser,
    you''ll see the rendered component content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5aef47b3-ea22-473b-a86f-b38551709050.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two things to pay attention to with this example. First, there's the
    `doc()` function. This creates the basic HTML document template with a placeholder
    for rendered React content. The second is the call to `renderToString()` , which
    is just like the `render()` call that you're used to. This is called in the server
    request handler and the rendered string is sent to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Backend routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, you implemented a single request handler in the server
    that responded to requests for the root URL (`/`). Your application is going to
    need to handle more than a single route. You learned how to use the `react-router`
    package for routing in the previous chapter. Now, you're going to see how to use
    the same package in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the main `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three routes that this application handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: The home page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/first`: The first page of content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/second`: The second page of content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App` content is divided into `<header>` and `<main>` elements. In each
    of these sections, there is a `<Route>` component that handles the appropriate
    content. For example, the main content for the `/` route is handled by a `render()`
    function that renders links to `/first` and `/second`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component will work fine on the client, but will it work on the server?
    Let''s implement that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You now have both frontend and backend routing! How does this work exactly?
    Let's start with the request handler path. This has changed this so that it's
    now a wildcard (`/*`). Now this handler is called for every request.
  prefs: []
  type: TYPE_NORMAL
- en: On the server, the `<StaticRouter>` component is used instead of the `<BrowserRouter>`
    component. The `<App>` component is the child, which means that the `<Route>`
    components within will be passed data from `<StaticRouter>`. This is how `<App>`
    knows to render the correct content based on the URL.  The resulting `html` value
    that results from calling `renderToString()` can then be used as part of the document
    that's sent to the browser as a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now your application is starting to look like a real end-to-end React rendering
    solution. This is what the server renders if you hit the root URL `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/03d2aca6-d30c-4897-b196-9aa3731215e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you hit the `/second` URL, the Node.js server will render the correct component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7d9175f8-7617-4d54-b069-a128b4861e32.png)'
  prefs: []
  type: TYPE_IMG
- en: If you navigate from the main page to the first page, the request goes back
    to the server. We need to figure out how to get the frontend code to the browser
    so that it can take over after the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend reconciliation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only thing that was missing from the last example was the client JavaScript
    code. The user wants to use the application and the server needs to deliver the
    client code bundle. How would this work? Routing has to work in the browser and
    on the server, without modification to the routes. In other words, the server
    handles routing in the initial request, then the browser takes over as the user
    starts clicking things and moving around in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `index.js` module for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This looks like most other `index.js` files that you've seen so far in this
    book. You render the `<App>` component in the root element in the HTML document.
    In this case, you're using the `hydrate()` function instead of the `render()`
    function. The two functions have the same end result — rendered JSX content in
    the browser window. The `hydrate()` function is different because it expects rendered
    component content to already be in place. This means that it will perform less
    work, because it will assume that the markup is correct and doesn't need to be
    updated on the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: Only in development mode will React examine the entire DOM tree of the server-rendered
    content to make sure that the correct content is displayed. If there's a mismatch
    between the existing content and the output of the React components, you'll see
    warnings that show you where these mismatches happened so that you can go fix
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `App` component that your app will render in the browser and on
    the Node.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The component renders a button that, when clicked, will update the `clicks`
    state. This state is rendered in a label above the button. When this component
    is rendered on the server, the default clicks value of 0 is used, and the `onClick`
    handler is ignored since it''s just rendering static markup. Let''s take a look
    at the server code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s walk through this source and see what''s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This reads the `index.html` file that''s created by your React build tool,
    such as `create-react-app/react-scripts`, and stores it in `doc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the Express server to serve files under the `./build` as static
    files, except for `index.html`. Instead, you''re going to write a handler that
    responds to requests for the root of the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is where the `html` constant is populated with rendered React content.
    Then, it gets interpolated into the HTML string using `replace()` and is sent
    as the response. Because you've used the `index.html` file based on your build,
    it contains a link to the bundled React app that will run when loaded in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if one of your components needs to fetch API data before it can fully render
    its content? This presents a challenge for rendering on the server because there's
    no easy way to define a component that knows when to fetch data on the server
    as well as in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: This is where a minimal framework like **Next.js** comes into play. Next.js
    treats server rendering and browser rendering as equals. This means that the headache
    of fetching data for your components is abstracted—you can use the same code in
    the browser and on the server.
  prefs: []
  type: TYPE_NORMAL
- en: The previous edition of this book didn't use any frameworks for fetching React
    component data on the server. I think that if you're going to go down this road,
    not using a framework is a mistake. There are simply too many things that can
    go wrong and without a framework, you're ultimately responsible for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle routing, Next.js uses the concept of pages. A **page** is a JavaScript
    module that exports a React component. The rendered content of the component turns
    into the page content. Here''s what the `pages` directory looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.js` module is the root page of the app: Next.js knows this based
    on the filename. Here''s what the source looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This page uses a `<Layout>` component to ensure that common components are
    rendered without the need to duplicate code. Here''s what the page looks like
    when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/238b9e43-d07f-4e63-9f20-57656db13039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the paragraph, you have the overall application layout includes
    the navigation links to other pages. Here''s what the `Layout` source looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Layout` component renders a `Header` component, and `props.children`.
    The `children` prop is the value that you pass to the `Layout` component in your
    pages. Let''s take a look at the `Header` component now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Link` component used here comes from Next.js. This is so that the links
    work as expected with the routing that Next.js sets up automatically. Now let''s
    look at a page that has data fetching requirements - `pages/first.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `fetch()` function that's used to fetch data comes from the `isomorphic-unfetch`
    package. This version of `fetch()` works on the server and in the browser—there's
    no need for you to check anything. Once again, the `Layout` component is used
    to wrap the page content for consistency with other pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getInitialProps()` function is how Next.js fetches data—in the browser
    and on the server. This is an async function, meaning that you can take as long
    as you need to fetch data for the component properties, and Next.js will make
    sure not to render any markup until the data is ready. Let''s take a look at the
    `fetchFirstItems()` API function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is mimicking API behavior by returning a promise that''s resolved
    after 1 second with data for the component. If you navigate to `/first`, you''ll
    see the following after 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/05bfede2-4c36-4470-bc1f-787d72611acf.png)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the first link, you caused the `getInitialProps()` function to
    be called in the browser since the app has already been delivered. If you reload
    the page while at `/first`, you'll trigger `getInitialProps()` to be called on
    the server since this is the page that Next.js is handling on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that React can be rendered on the server, in addition
    to the client. There are a number of reasons for doing this, such as sharing common
    code between the frontend and the backend. The main advantage to server-side rendering
    is the performance boost that you get on the initial page load. This translates
    to a better user experience and therefore a better product.
  prefs: []
  type: TYPE_NORMAL
- en: You then progressively improved on a server-side React application, starting
    with a single page render. Then you were introduced to routing, client-side reconciliation,
    and component data fetching to produce a complete backend rendering solution using
    Next.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll learn how to implement React Bootstrap components
    to implement a mobile-first design.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledege
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between the `render()` function from `react-dom` and
    the `renderToString()` function from `react-dom/server`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `render()` function is only used to sync React component content with the
    DOM in a browser. The `renderToString()` function doesn't require a DOM because
    it renders markup as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two functions are interchangeable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `render()` function is slower on the server so `renderToString()` is a better
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should only use `render()` in the browser if you have to. The `renderToString()`
    function is preferable in most cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Routing on the server is necessary because:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Without routing on the server, there's no way to actually render components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't need to worry about rendering on the server since the routes will
    be handled in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The router on the server will determine that content is rendered based on the
    requested URL. This content is then sent to the browser so that the user perceives
    a faster load time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing on the server should be down manually instead of using components from
    react-router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What function should you use when reconciling server-rendered React markup with
    React components in the browser?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always use `render()` in the browser. It knows how to make changes to existing
    markup that are necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always use `hydrate()` when the server sends rendered React components. Unlike
    `render()`, `hydrate()` expects rendered component markup and can handle it efficiently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check out the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-dom-server.html](https://reactjs.org/docs/react-dom-server.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reacttraining.com/react-router/core/api/StaticRouter](https://reacttraining.com/react-router/core/api/StaticRouter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://nextjs.org/learn/](https://nextjs.org/learn/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
