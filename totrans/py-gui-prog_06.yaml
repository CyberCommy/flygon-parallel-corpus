- en: Creating Menus with Menu and Tkinter Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application grows, organizing access to its features becomes increasingly
    important. Traditionally, applications have addressed this with a **menu system**,
    which is typically located at the top of the application window or (on some platforms)
    in a global desktop menu. While these menus are application-specific, certain
    organizational conventions have been developed that we should follow in order
    to make our software user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing some reported problems and deciding on a solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring some of Tkinter's dialog classes, and using them for implementing
    common menu functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to work with Tkinter's Menu widget and using it to create a menu
    for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating some options for our application and saving them to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving problems in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your boss has brought you the first set of problems that need to be addressed
    in your application. First, in situations where the last reports of the day aren't
    able to be entered until the following day, the hardcoded date string in the filename
    is a problem. The data entry staff need a way to manually choose which file they'll
    be appending to.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the data entry staff have mixed feelings about the auto-populate features
    in the form. Some find it very helpful, but others would really like to see it
    disabled. You'll need a way to allow users to turn this feature on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, some users have a hard time noticing the status bar text at the bottom,
    and would like the application to be more conspicuous when it fails to save data
    due to errors.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding how to address these problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s clear you need to implement a way to select a file and toggle the auto-populate
    features of the form. First, you consider just adding controls to the main application
    for both of these, and make this quick mock-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b7aaf697-23dc-40a6-8c42-0e8c13ba42d7.png)'
  prefs: []
  type: TYPE_IMG
- en: It doesn't take long for you to realize that this is not a great design, and
    certainly not one that will accommodate growth. Your users don't want to have
    to type a file path and filename blindly into the box, nor do they want a lot
    of extra fields cluttering up the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Tkinter offers some tools that will help us to solve these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File dialogs**: Tkinter''s `filedialog` library will help make file selection
    simple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error dialogs**: Tkinter''s `messagebox` library will let us display error
    messages more noticeably'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main menu**: Tkinter''s `Menu` class can help us organize common functionality
    for easy access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing simple Tkinter dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The status bar is fine for incidental information that shouldn't interrupt a
    user's workflow, but for errors that prevent work from continuing as expected,
    users should be alerted in a more assertive way. An **error dialog** that halts
    the program until it's acknowledged with a mouse click is fairly assertive and
    seems like a good way to address the issue of users not seeing errors. In order
    to implement these, you'll need to learn about Tkinter's `messagebox` library.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter messagebox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to display simple dialog boxes in Tkinter is by using the `tkinter.messagebox`
    library, which contains several convenient functions that allow you to quickly
    create common dialog types. Each function displays a preset icon and a selection
    of buttons with a message and detail text that you specify, and returns a value
    depending on which button the user clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the `messagebox` functions with their icons
    and return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Icon** | **Button** / **return value** |'
  prefs: []
  type: TYPE_TB
- en: '| `askokcancel` | Question | Ok (`True`), Cancel (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askretrycancel` | Warning | Retry (`True`), Cancel (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askyesno` | Question | Yes (`True`), No (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askyesnocancel` | Question | Yes (`True`), No (`False`), Cancel (`None`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `showerror` | Error | Ok (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: '| `showinfo` | Information | Ok (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: '| `showwarning` | Warning | Ok (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: 'We can pass the following three text arguments into any `messagebox` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This argument sets the title of the window, which is displayed in
    the title bar and/or task bar in your desktop environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: This argument sets the main message of the dialog. It''s usually
    in a heading font and should be kept fairly short.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detail`: This argument sets the body text of the dialog, which is usually
    displayed in the standard window font.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a basic call to `showinfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows 10, it results in a dialog box (on other platforms, it may look
    a bit different), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ae47462-cc7e-4428-bee7-9a8e23f15ea4.png)'
  prefs: []
  type: TYPE_IMG
- en: Tkinter `messagebox` dialog boxes are **modal**, which means that the program
    execution pauses and the rest of the UI is unresponsive while the dialog box is
    open. There is no way to change this, so only use them in situations where it's
    acceptable for the program to pause execution while the box is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small example to show the use of the `messagebox` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To use `messagebox`, we need to import it from Tkinter; you can't simply use
    `tk.messagebox` because it's a submodule and must be explicitly imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a yes-no message box as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a dialog with Yes and No buttons; if Yes is clicked, the function
    returns `True`. If No is clicked, the function returns `False` and  the application
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case our user wants to see more boxes, let''s display an information box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the difference between the way `message` and `detail` are displayed on
    your platform. On some platforms, there is no difference; on others, `message`
    is large and bold, which is appropriate for short texts. For cross-platform software,
    it's best to use `detail` for extended output.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the error dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand how to use `messagebox`, error dialogs should be easy
    to implement. The `Application.on_save()` method already displays errors in the
    status bar; we just need to make this error display in an error message box as
    well by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to import it in `application.py` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `on_save()` method after the check for errors, we''ll set up the
    message for the error dialog. We''ll make a bullet list of the fields with errors
    by joining them with `"\n *"`. Unfortunately, `messagebox` doesn''t support any
    sort of markup, so constructs like bullet lists need to be built manually using
    regular characters, as in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call `showerror()`, just after the call to `status()` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the program and hit Save; you''ll see a dialog box alerting you to
    the errors in the application, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/b7f981fb-dc26-4abf-9ff9-b839d434646d.png)'
  prefs: []
  type: TYPE_IMG
- en: This error should be hard for anyone to miss!
  prefs: []
  type: TYPE_NORMAL
- en: One shortcoming of the `messagebox` dialogs is that they don't scroll; a long
    error message will create a dialog that may fill (or extend beyond) the screen.
    If this is a potential problem, you'll want to create a custom dialog containing
    a scrollable widget.
  prefs: []
  type: TYPE_NORMAL
- en: Designing our menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications organize functionality into a hierarchical **menu system**,
    typically displayed at the top of the application or screen (depending on the
    OS). While the organization of this menu varies between operating systems, certain
    items are fairly common across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of these common items, our application will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A file menu containing file operations such as open/save/export, and often an
    option to quit the application. Our users will need this menu to select a file
    and quit the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An options, preferences, or settings menu where users can configure the application.
    We'll need this menu for our toggle settings; we'll call it options for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A help menu, which contains links to help documentation, or, at the very least,
    an about message giving the basic information about the application. We'll implement
    this menu for the about dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple, Microsoft, and the Gnome Project publish guidelines for macOS, Windows,
    and Gnome desktops (used on Linux and BSD), respectively; each set of guidelines
    addresses the layout of menu items specific to that platform.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can implement our menu, we'll need to understand how menus work in
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating menus in Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tkinter.Menu` widget is used to implement menus in Tkinter applications;
    it's a fairly simple widget that acts as a container for any number of menu items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu items can be one of the following five types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`command`: These items are labeled buttons that, when clicked, run a callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkbutton`: These items are just like `Checkbutton` in our forms, and can
    be used to toggle `BooleanVar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radiobutton`: These items are similar to `Checkbutton`, but can be used to
    switch any kind of Tkinter variable between several mutually exclusive options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`separator`: These items are used to segment the menu into sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cascade`: These items allow you to add a submenu to the menu. The submenu
    is just another `tkinter.Menu` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write the following small program to demonstrate the use of Tkinter
    menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This application sets up a label whose text is controlled by a string variable, `main_text`.
    If you run this application, you'll see a simple window that says Hi. Let's start
    adding the menu components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right above `root.mainloop()`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This creates a main menu and then sets it as the main menu of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, that menu is empty, so let''s add an item by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We've added a command to quit the application. The `add` method allows us to
    specify an item type and any number of attributes to create a new menu item. In
    the case of a command, we need to at least have a `label` argument specifying
    the text that will show in the menu and a `command` argument pointing to a Python
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms, such as macOS, don't allow a command in the top-level menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try creating a submenu as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating a submenu is just like creating a menu, except that we specify the
    `parent` menu as the widget's `parent`. Notice the `tearoff` argument; by default,
    submenus in Tkinter are tearable, which means they can be pulled off and moved
    around as independent windows. You don't have to disable this option, but it is
    a rather archaic UI feature that is rarely used on modern platforms. Users will
    likely just find it confusing, so it's best to disable it whenever you create
    submenus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some commands to the menu as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `lambda` functions here for convenience, but you can pass any
    Python callable. The `add_command` method used here is simply a shortcut for `add('command')`.
    There are analogous methods for adding other items as well (cascade, separator,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `add_cascade` method to add our menu back to its `parent` widget
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When adding a submenu to its `parent` menu, we simply have to provide the label
    for the menu and the menu itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can add the  `Checkbutton` and `Radiobutton` widgets to the menu as well.
    To demonstrate this, let's create another submenu to alter the label's appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need the following setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're just creating variables to store the state of the bold option and
    font size, then a callback method that actually sets the label's font from these
    variables when called. Then, we set up a trace on both variables to call the callback
    whenever their values are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to create the menu options to change the variables by adding
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Like a regular `Checkbutton` widget, the `add_checkbutton` method takes `BooleanVar`,
    which is passed to the `variable` argument that will be bound to its checked status.
    Unlike a regular `Checkbutton` widget, use the `label` argument, rather than the
    `text` argument, to assign the label text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the radio buttons, let''s add a submenu to our submenu, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Just as we added a submenu to our main menu, we can add submenus to submenus.
    In theory, you could nest submenus indefinitely, but most UI guidelines discourage
    more than two levels. To create the items for our size menu, we're just iterating
    a generated list of even numbers between 8 and 24; for each one, we add a `radiobutton` item
    with a value equal to that size. Just like with regular `Radiobutton` widgets,
    the variable given in the `variable` argument will be updated with the value given
    in the `value` argument when the button is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the application and try it out, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18dd3562-6645-4d90-84e7-3fd42afc8a8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you understand the `Menu` widget, let's add one to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our application menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a major component of the GUI, our menu is clearly a view, and should be
    implemented in the `views.py` file. However, it''s also going to need to set options
    that affect other views (such as the form options we''re implementing now) and
    run functions that affect the application (like quitting). We need to implement
    it in such a way that we keep controller functions in the `Application` class
    but still keep the UI code in `views.py`. Let''s take a look at the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start out by opening `views.py` and creating a `MainMenu` class that
    subclasses `tkinter.Menu`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our overridden `__init__()` method will take two dictionaries, a `settings`
    dictionary and a `callbacks` dictionary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use these dictionaries to communicate with the controller: `settings`
    will contain Tkinter variables that can be bound to our menu controls, and `callbacks`
    will be controller methods that we can bind to menu commands. Naturally, we''ll
    need to make sure to populate these dictionaries with the expected variables and
    callables in our `Application` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start creating our submenus, starting with the file menu as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first command in the file menu is `Select file...`. Notice the ellipses
    in the label: this indicates to the user that the option will open another window
    that will require further input. We''re setting `command` to a reference from
    our `callbacks` dictionary using the `file->open` key. This function doesn''t
    exist yet; we''ll implement it shortly. Let''s add our next file menu command,
    `file->quit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we've pointed this command to an as yet undefined function in our
    `callbacks` dictionary. We've also added a separator; since quitting the program
    is a fundamentally different sort of operation from selecting a target file, it
    makes sense to separate them, and you'll see this in most application menus.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the file menu, so we need to add it to the main `menu` object
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next submenu we need to create is our `options` menu. Since we only have
    two menu options, we''ll just add them directly to the submenu as `Checkbutton`.
    The option menu looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables bound to these `Checkbutton` widgets are in the `settings` dictionary,
    so our `Application` class will populate `settings` with two `BooleanVar` variables:
    `autofill date` and `autofill sheet data`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Last of all, we''ll create a `help` menu, featuring an option to show an `About`
    dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Our `About` command points to an internal `MainMenu` method called `show_about`,
    which we'll implement next. The `About` dialog is going to be pure UI code with
    no actual application functionality in it, so we can implement it entirely within
    the view.
  prefs: []
  type: TYPE_NORMAL
- en: Showing an About dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen how to use `messagebox` to create error dialogs. Now, we
    can apply that knowledge to create our `About` box by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new method definition after `__init__()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `About` dialog can show any information you feel is relevant, including
    your contact information, support information, version information, or even the
    entire `README` file. In our case, we''ll keep it fairly short. Let''s specify
    the `message` header text and `detail` body text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We're just using the application name for the header, and a short message about
    our name and who to contact for support for the detail. Feel free to put whatever
    text you wish in your `About` box.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways you can deal with long, multiline strings in Python code;
    the approach used here is to place multiple strings between parenthesis with only
    whitespace between them. Python automatically concatenates strings separated by
    only whitespace, so to Python this looks like a single long string inside a set
    of parentheses. In contrast to other methods, such as triple-quoting, this allows
    you to maintain clean indents and control new lines explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to display our `About` box as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `showinfo()` function is clearly the most appropriate,
    since we are in fact showing information. This finishes our `show_about()` method
    and our `MainMenu` class. Next, we need to make the necessary modifications to
    `Application` to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the menu functionality in the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our menu class is defined, our `Application` object needs to create
    an instance and add it into the main window. Before we can do that, we'll need
    to define some things that our `MainMenu` class needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the following things from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a `settings` dictionary that contains Tkinter variables for our two
    settings options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a `callbacks` dictionary that points to callbacks for `file->select`
    and `file->quit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need the actual functions that implement file selection and quitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define some things that our `MainMenu` class needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `application.py` and let''s start adding code just before the creation
    of `self.recordform`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be our global settings dictionary that stores the boolean variables
    for our two configuration options. Next, we''ll create the `callbacks` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re pointing our two callbacks to the methods of the `Application` class
    that will implement the functionality. Fortunately for us, Tkinter already implements
    `self.quit`, which does exactly what you''d expect it to do, so we only need to
    implement `on_file_select` ourselves. We will finish up here by creating our `menu`
    object and add it to the application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Handling file selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user needs to enter a file or directory path, the preferred way to do
    this is to display a dialog containing a miniature file browser, commonly called
    a file dialog. Like most toolkits, Tkinter provides us with dialogs for opening
    files, saving files, and selecting a directory. These are all part of the `filedialog`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `messagebox`, `filedialog` is a Tkinter submodule that needs to be
    explicitly imported to be used. Also like `messagebox`, it contains a set of convenience
    functions that create file dialogs that are appropriate for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the functions, what they return, and their UI features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Return value** | **Features** |'
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory` | Directory path as string | Only shows directories, no files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile` | File handle object | Only allows selection of existing files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename` | File path as string | Only allows selection of existing
    files |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilenames` | File paths as list of strings | Like `askopenfilename`,
    but allows multiple selections |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfiles` | List of file handle objects | Like `askopenfile`, but allows
    multiple selections |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile` | File handle object | Allows creation of new files, prompts
    for confirmation on existing files |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename` | File path as string | Allows creation of new files,
    prompts for confirmation on existing files |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see, each file selection dialog comes in two versions: one that
    returns a path as a string, and one that returns an open file object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each function can take the following common arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This argument specifies the dialog window title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent`: This argument specifies the (optional) `parent` widget. The file
    dialog will appear over this widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialdir`: This argument is the directory in which the file browser should
    start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filetypes`: This argument is a list of tuples, each with a label and matching
    pattern, which will be used to create files of the filter drop-down type typically
    seen under the filename entry. This is used to filter the visible files to only
    those supported by the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `asksaveasfile` and `asksaveasfilename` methods take the following two
    additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialfile`: This option is a default file path to select'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultextension`: This option is a file extension string that will be automatically
    appended to the filename if the user doesn''t do it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the methods that return a file object take a `mode` argument that specifies
    the file-open mode; these are the same one- or two-character strings used by Python's
    `open` built-in function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which dialog do we need to use in our application? Let''s consider our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a dialog that allows us to select an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to be able to create a new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since opening the file is the responsibility of the model, we just want to get
    a filename to pass to the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These requirements clearly point to the `asksaveasfilename` function. Let''s
    take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new method on the `Application` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The method first asks the user to select a file with a `.csv` extension; using
    the `filetypes` argument, the selection of existing files will be limited to those
    ending in `.csv` or CSV. When the dialog exits, the function will return the path
    to the selected file as a string to `filename`. Somehow, we have to get this path
    to our model.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the filename is generated in the `Application` object's `on_save`
    method and passed into the model. We need to move `filename` to a property of
    the `Application` object so that we can override it from our `on_file_select()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in the `__init__()` method, add the following code line before the `settings`
    and `callbacks` definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `self.filename` property will keep track of the currently selected save
    file. Previously, we set up our hardcoded filename inside the `on_save()` method;
    there''s no good reason to keep doing this every time `on_save()` is called, particularly
    since we''re only using it if the user hasn''t selected a file otherwise. Instead,
    move those lines from `on_save()` to just above the `self.filename` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the default filename defined, we can supply it as a default value for `StringVar`.
    The value will be updated by `on_file_select()` whenever the user selects a filename.
    This is accomplished by the following lines at the end of `on_file_select()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the `if` statement is that we only want to set a value if a file
    was actually selected by the user. Remember that the file dialogs will return
    `None` if the user cancels the operation; in this case, a user would expect that
    the currently set filename will remain the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we need to make our `on_save()` method use this value when it's set
    instead of the hardcoded default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Down in the `on_save()` method, locate the line where `filename` is defined
    and change it to the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That completes the code changes to make filename selection work. At this point,
    you should be able to run the application and test out the file selection functionality.
    Save a few records and note that they indeed save to the file you selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making our settings work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the file saving works, the settings do not. The `settings` menu items
    should work as expected, remaining checked or unchecked, but they don't yet change
    the behavior of the data entry form. Let's make this work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that both autofill features are implemented in the `DataRecordForm`
    class''s `reset()` method. To use our new settings, we need to give our form access
    to the `settings` dictionary by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `views.py` and update the `DataRecordForm.__init__()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added an additional positional argument, `settings`, and then set that
    to `self.settings` so that all of the methods in the class can access it. Now,
    look at the `reset()` method; currently, the date autofill code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to make sure this happens only when `settings[''autofill date'']`
    is `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Autofilling the sheet data is already under a conditional statement, as you
    can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the setting effective, we just need to add another condition to the
    `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last piece of the puzzle is to make sure we're sending our `settings` dictionary
    to `DataRecordForm` when it's created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `Application` code, update our call to `DataRecordForm()` to include
    `self.settings` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run the program, you should find that the settings are respected;
    try checking and unchecking them and see what happens after you save a record.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Persisting settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our settings work, but there''s a major annoyance: they don''t persist between
    sessions. Shut down the application and start it up again, and you''ll see that
    the settings are back to their defaults. It''s not a major problem, but it''s
    a rough edge we shouldn''t leave for our users.'
  prefs: []
  type: TYPE_NORMAL
- en: Python gives us a variety of ways to persist data in files. We've already experienced
    CSV, which is designed for tabular data; there are other formats designed with
    different capabilities in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows just a few of the options for storing data available
    in the Python standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Library** | **Data type** | **Suitable ** | **Benefits** | **Drawbacks**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pickle` | Binary | Any kind of object | Fast, easy, small files | Not safe,
    files aren''t human-readable, whole file has to be read |'
  prefs: []
  type: TYPE_TB
- en: '| `configparser` | Text | `key->value` pairs | Fast, easy, human-readable files
    | Can''t handle sequences or complex objects, limited heirarchy |'
  prefs: []
  type: TYPE_TB
- en: '| `json` | Text | Simple values and sequences | Widely used, easy, human-readable
    files | Can''t serialize complex objects without modification |'
  prefs: []
  type: TYPE_TB
- en: '| `xml` | Text | Any kind of Python object | Powerful, flexible, mostly human-readable
    files | Not safe, complex to use, verbose file syntax |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite` | Binary | Relational data | Fast and powerful files | Requires
    SQL knowledge, objects must be translated to tables |'
  prefs: []
  type: TYPE_TB
- en: If this weren't enough, there are even more options available in the third-party
    libraries. Almost any of them would be suitable for storing a couple of boolean
    values, so how do we choose?
  prefs: []
  type: TYPE_NORMAL
- en: SQL and XML are powerful, but far too complex for our simple needs here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'd like to stick to a text format in case we need to debug a corrupt settings
    file, so `pickle` is out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configparser` would work now, but its inability to handle lists, tuples, and
    dictionaries may be limiting in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That leaves `json`, which is a good option. While it can't handle every kind
    of Python object, it can handle strings, numbers, and booleans, as well as lists
    and dictionaries. That should cover our configuration needs just fine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it mean when we say that a library is "not safe"? Some data formats
    are designed with powerful capabilities, such as extensibility, linking, or aliasing,
    which parser libraries must implement. Unfortunately, those capabilities can be
    exploited for malicious purposes. For example, the billion laughs XML vulnerability
    combines three XML capabilities to craft a file that, when parsed, expands to
    a massive size (usually causing the program or, in some cases, the system, to
    crash).
  prefs: []
  type: TYPE_NORMAL
- en: Building a model for settings persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any kind of data persistence, we need to start by implementing a model.
    As with our `CSVModel` class, the settings model needs to save and load the data,
    as well as define the layout of the settings data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `models.py` file, let''s start a new class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did with our `CSVModel` class, we''ll need to define our model''s
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `variables` dictionary will store both the schema and the values for each
    item. Each setting has a dictionary listing the data type and default value (we
    could list other attributes here if they are needed, such as minimum, maximum,
    or possible values). The `variables` dictionary will be the data structure we
    save to disk and load from disk to persist the program's settings.
  prefs: []
  type: TYPE_NORMAL
- en: The model needs a location to save the configuration file too, so our constructor
    will take the filename and path as arguments. For now, we'll just provide and
    use reasonable defaults, but in the future we may want to change these.
  prefs: []
  type: TYPE_NORMAL
- en: We can't just provide a single file path, though; we have different users on
    the same computer who will want to save different settings. We need to make sure
    that the settings are saved in the individual user's home directory rather than
    a single common location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, our `__init__()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As users of the Linux or macOS Terminal will know, the `~` symbol is a Unix
    shortcut that points to the user's home directory. Python's `os.path.expanduser()`
    function translates this character into an absolute path (even on Windows), so
    that the file will be saved in the home directory of the user running the program.
    `os.path.join()` appends the filename to the expanded path, giving us a full path
    to a user-specific configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the model is created, we'll want to load the user's saved options
    from disk. Loading data from disk is a pretty basic model operation that we should
    be able to control outside the class, so we'll make this a public method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this method `load()`, and call it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`load()` will expect to find a JSON file containing a dictionary in the same
    format as the `variables` dictionary. It will need to load that data from the
    file and replace its own copy of `variables` from the file copy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplistic implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `json.loads()` function reads in a JSON string and converts it to a Python
    object, which we're saving directly to our `variables` dictionary. Of course,
    there are some problems with this method. First of all, what happens if the settings
    file doesn't exist? In that case, `open` will throw an exception and the program
    will crash. Not good!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before we try to open the file, let''s test to see if it exists as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the file doesn't exist, the method simply returns and does nothing. It's
    perfectly reasonable for the file not to exist, especially if the user has never
    run the program or edited any of the settings. In this case, the method would
    leave `self.variables` alone and the user would end up with the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that our settings file might exist, but contain no data
    or invalid data (such as keys not present in the `variables` dictionary), resulting
    in a crash. To prevent this, we'll pull in the JSON data to a local variable;
    we'll then update `variables` by asking `raw_values` for only those keys that
    exist in `variables`, providing a default value if they aren't present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new, safer code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Since `variables` is created with default values already in place, we just need
    to ignore `raw_values` if it doesn't have a given key or if the dictionary in
    that key doesn't contain a `values` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `load()` is written, let''s write a `save()` method to write our values
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json.dumps()` function is the inverse of `loads()`: it takes a Python
    object and returns a JSON string. Saving our `settings` data is as simple as converting
    the `variables` dictionary to a string and writing it to the specified text file.'
  prefs: []
  type: TYPE_NORMAL
- en: The final method our model needs is a way for external code to set values; they
    could manipulate `variables` directly, but in the interest of protecting our data
    integrity, we'll do it through a method call. Keeping with Tkinter convention,
    we'll call this method `set()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic implementation of the `set()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This simple method just takes a key and value and writes them to the `variables`
    dictionary. Once again, though, this opens up some potential problems; what if
    the value provided isn't valid for the data type? What if the key isn't in our
    `variables` dictionary? This could create a situation that would be hard to debug,
    so our `set()` method should safeguard against this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: By using the `type` strings that correspond to the names of actual Python types,
    we can match it against the value's type name using `type(value).__name__` (we
    could have used the actual type objects themselves in our `variables` dictionary,
    but those can't be serialized to JSON). Now, an attempt to write an unknown key
    or incorrect variable type will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we shouldn''t let it fail silently; we should immediately raise `ValueError`
    to alert us to the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Why raise an exception? If the test fails, it can only mean a bug in the calling
    code. With an exception, we'll know immediately if calling code is sending bad
    requests to our model. Without it, requests would fail silently, leaving a hard-to-find
    bug.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of raising an exception on purpose often seems strange to beginners;
    after all, exceptions are something we're trying to avoid, right? This is true
    in the case of small scripts where we're mainly users of existing modules; when
    writing your own module, however, exceptions are the correct way for your module
    to communicate problems to the code using it. Trying to handle—or worse, silence—bad
    behavior by external calling code will, at best, break modularity; at worst, it
    will create subtle bugs that are difficult to track down.
  prefs: []
  type: TYPE_NORMAL
- en: Using the settings model in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application needs to load in the settings when it starts, then save them
    automatically whenever they are changed. Currently, the application''s `settings`
    dictionary is created manually, but our model should really be telling it what
    kind of variables to create. Let''s perform the following steps for using the
    `settings` model in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code that defines `Application.settings` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a `settings` model and save it to our `Application` object.
    Then, we're going to run a `load_settings()` method. This method will be responsible
    for setting up the `Application.settings` dictionary based on `settings_model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create `Application.load_settings()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our model stores the type and value for each variable, but our application
    needs Tkinter variables. We need a way to translate the model''s representation
    of the data into a structure that `Application` can use. A dictionary provides
    a handy way to do this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that each name matches the type name of a Python built-in function.
    We could add more entries here, but this should cover most of our future needs.
    Now, we can combine this dictionary with the model''s `variables` dictionary to
    construct the `settings` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The main reason for using Tkinter variables here is so that we can trace any
    changes the user makes to the values via the UI and respond immediately. Specifically,
    we want to save our settings whenever the user makes a change as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this means we need to write a method called `Application.save_settings()`,
    which will run whenever the values are changed. `Application.load_settings()`
    is complete, so let''s do that next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save_settings()` method just needs to get the data back from `Application.settings`
    to the model and then save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: It's as simple as looping through `self.settings` and calling our model's `set()`
    method to pull in the values one at a time. Then, we call the model's `save()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to run the program and observe that the settings are
    saved, even when you close and re-open the application. You'll also find a file
    in your home directory called `abq_settings.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, our simple form has taken a big step forward towards being
    a fully-blown application. We've implemented a main menu, option settings that
    are persisted between executions, and an `About` dialog. We've added the ability
    to select a file where records are saved, and improved the visibility of form
    errors with an error dialog. Along the way, you learned about Tkinter menus, file
    dialogs, and message boxes, as well as the various options for persisting data
    in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to be asked to make the program read and write.
    We'll learn about Tkinter's tree widget, how to switch between main views, and
    how to make our `CSVModel` and `DataRecordForm` classes capable of reading and
    updating existing data.
  prefs: []
  type: TYPE_NORMAL
