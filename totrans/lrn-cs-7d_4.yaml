- en: Day 04 - Discussing C# Class Members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are in day four of our seven-day learning series. On day two, we discussed
    the typical C# program, and you understood how to compile and execute the program.
    We discussed the `Main` method and its use. We also discussed the reserved keywords
    of language C#, and then, we got an overview of classes and structures in C#.
    On day three, we discussed all the new features introduced in C#7.0.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the fundamentals of C# methods and properties will be explained,
    and we will also cover the concept of indexers in C#. The string manipulation
    discussed on day two will be extended through RegEx, and we will explain why it
    is powerful. File management will be covered along with some medium-level file
    system observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, we will cover C# classes in more depth. This chapter will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing regular expression and its importance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On day two, we discussed a typical C# program, and we discussed how a program
    can be compiled and executed. What is the use/importance of the `Main` method?
    We will carry forward the same discussion and start our day four.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let''s go through the steps of our program in the String calculator
    ([https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)).
    There is a simple requirement to add numbers that are provided as a string. Here
    is a simple code snippet on the basis of this one-liner requirement that does
    not mention how many numbers are needed to be supplied in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output when we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code is working fine and giving us the expected results. The
    requirements that we discussed previously are very limited and vague. Let''s elaborate
    on the initial requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple String calculator with the `Add` operation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This operation should only accept input in a string data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Add` operation can take zero, one, or two comma-separated numbers and will
    return their sum, for example, *1* or *1,2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Add` operation should accept an empty string, but for an empty string,
    it will return zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding requirements are unanswered in our previous code snippet. To achieve
    these requirements, we should tweak our code snippet, which we will discuss in
    the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modifiers are nothing but special keywords in C# that are used to declare how
    a specific method, property, or variable could be accessible. In this section,
    we will discuss modifiers and discuss their usage with the use of code examples.
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of modifiers is encapsulation. It's about how objects get simplified
    by encapsulations, and modifiers are like knobs saying how much you want to show
    to some clients, and how much not to. To understand encapsulation, refer to day
    seven, *Encapsulation*.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers and accessibility levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access modifiers tell us how and where a member, declared type, and so on can
    be accessed or available. The following discussion will give you a broader idea
    of all access modifiers and accessibility levels.
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `public` modifier helps us define the scope of the member without any restrictions.
    This means if we define any class, method, property, or variable with a public
    access modifier, the member can be accessed without any restrictions for other
    members.
  prefs: []
  type: TYPE_NORMAL
- en: The accessibility level of the type or the member of derived type that is declared
    using the public access modifier is unrestricted, which means it can be accessible
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand unrestricted accessibility levels, let''s consider following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will run perfectly and produce the expected results.
    When you run the preceding code, it will show results, as in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: protected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `protected` modifier helps us define the scope of the member without the class
    or type defined/created from the class where the member is defined. In other words,
    when we define the variable, property, or method with the access modifier `protected`,
    this means the scope of availability of these are within the class in which all
    these members are defined.
  prefs: []
  type: TYPE_NORMAL
- en: The accessibility level of the type or the member of derived type that is declared
    using protected access modifiers is restricted, which means it can only be accessible
    within the class or from the derived types that are created from class of the
    member. The protected modifier is importantly and actively responsible in OOPS
    using C#. You should get an idea of inheritance. Refer to day seven, *Inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand protected accessibility levels, let''s consider the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have two classes: `StringCalculator` and `StringCalculatorImplementation`.
    Properties are defined with the `protected` access modifier in the `StringCalculator`
    class. This means these properties are only accessible either from the `StringCalculator`
    class or the `StringCalculatorImplementation` (this is a derived type of the `StringCalculatorclass`).
    The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code will not work and will produce a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we tried to access `Num1` and `Num2` from the `StringCalculatorImplementation`
    class by creating an instance of the `StringCalculator` class. This is not possible
    and will not work. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: internal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An internal modifier helps us define the scope of the member for the same assembly.
    Members that are defined using internal access modifiers cannot access outside
    of the assembly where they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: The accessibility level of the type or the member that is declared using internal
    access modifiers is restricted for outside the assembly. This means these members
    are not allowed to access from external assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand internal accessibility levels, let''s consider the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code belongs to the assembly `ExternalLib` that contains a `StringCalculatorExternal`
    class of internal access modifiers with two properties, `Num1` and `Num2`, defined
    with the `public` access modifier. It will not work if we call this code from
    some other assembly. Let''s consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is of a separate assembly day four, and we are trying to
    call a `StringCalculatorExternal` class of assembly `ExternalLib` that is not
    possible, as we have defined this class as `internal`. This code will throw the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we use protected and internal access modifier jointly i.e. protected internal
    this combinition of modifiers known as composite modifier.
  prefs: []
  type: TYPE_NORMAL
- en: '`protected internal` means protected or internal and not protected and internal.
    This means a member can be accessed from any class within the same assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand protected internal accessibility levels, let''s consider the
    following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is for assembly day four with a class `StringCalculatorImplement`,
    that is, the inherited `StringCalculator` class (this class has two properties
    with the `protected internal` access modifier). Let''s consider code from the
    same assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: private
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `private` modifier is the lowest scope of the member. This means whenever
    a member is defined using the `private` modifier, that member is only accessible
    within the class where it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`private` means restricted access, and the member can only be accessed from
    within class or its nested types, if defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand private accessibility levels, let''s consider the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code properties, `Num1` and `Num2` are not accessible to outside
    the `StringCalculator` class. The following code will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will throw a compile-time error as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rules for the access modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed the access modifier and accessibility with the use of this
    access modifier. Now, there are certain rules we should follow while working with
    these access modifiers that are discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combination restriction**: A restriction is there while using an access modifier.
    These modifiers should not be used in combination unless you are using access
    modifiers protected internal. Consider the code example discussed in the previous
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace restriction**: These access modifiers should not be used with namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default accessibility restriction**: When, or if, a member is declared without
    an access modifier, then default accessibility is used. All classes are implicitly
    internal, and its members are private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top-level type restriction**: Top-level types are parent types that have
    immediate parent type objects. Parent or top-level types cannot use any accessibility
    other than `internal` or `public` accessibility. If no access modifier is applied,
    default accessibility will be internal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested-type restriction**: Nested types are those that are members of other
    types, or have immediate parent types other than universal types, that is, an
    object. The accessibility of these can be declared as discussed in the following
    table ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels)):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Nested Type** | **Default Accessibility for Members** | **Allowed Accessibility
    Can Be Declared** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | `public` | None | `enum` has public accessibility, and its members
    have only `public` accessibility. These are meant to be used for other types;
    hence, they are not allowed to set any accessibility explicitly. |'
  prefs: []
  type: TYPE_TB
- en: '| Class | `private` | `public`, `internal`, `protected`, `private`, `protected
    internal` | Class is internal by default, and members are `private.` Refer to
    the previous section-Rules for access modifier for more details. |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | `public` | None | Interface is internal by default, and its members
    are `public.` Members of interface are meant to be utilized from inherited types,
    so there is no explicit accessibility allowed for interface. |'
  prefs: []
  type: TYPE_TB
- en: '| struct | `private` | `public`, `internal`, `private` | The same as `class`,
    struct is internal by default and its members are `private`. We can explicitly
    apply accessibility of `public`, `internal`, and `private`. |'
  prefs: []
  type: TYPE_TB
- en: abstract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple words, we can say that an abstract modifier indicates that things
    are yet to be completed. A `class` is only meant to be a base class for other
    classes when an abstract modifier is used to create a `class`. Members marked
    as abstract in this `class` should be implemented in the derive class.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract modifier indicates incomplete things and can be used with class,
    method, property, indexer, and/or event. Members marked as abstract would not
    be allowed to define accessibility other than `public`, `protected`, `internal`
    and `protected internal`.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes are half-defined. This means these provide a way to override
    members to child classes. We should use base classes in the project where we need
    to have the same member for all child classes with its own implementations or
    need to override. For example, let's consider an abstract class car with an abstract
    method color and have child classes Honda car, Ford car, Maruti car, and so on.
    In this case, all child classes would have color member but with different implementations
    because the color method would be overridden in the child classes with their own
    implementations. The point to be noted here is that abstract classes represent
    is-a relation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the capacity of this modifier, let''s consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet is an abstract class that contains abstract properties
    and a non-abstract method. Other classes can only implement this class. Please
    refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Rules of the abstract modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are certain rules we need to follow while working with abstract modifiers,
    and these rules are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiation**: If a class is marked as abstract, we cannot create the instance
    of it. In other words, object initialization is not allowed for abstract classes.
    We will get a compile-time error if we try to do this explicitly. Refer to the
    following screenshot, where we are trying to instantiate an abstract class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Non-abstract**: A class may or may not contain abstract methods or members
    that are marked as abstract. This means there is no restriction when we have to
    create all abstract members and methods for abstract classes. The following code
    obeys this rule:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Limit**-**inherit nature**: As we discussed, an abstract class is meant to
    be inherited by other classes. If we do not want to inherit the abstract class
    from other classes, we should use a sealed modifier. We will discuss this in detail
    in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members)
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation nature**: All members of an abstract class should be implemented
    in the child class that is inheriting the abstract class only if the child class
    is non-abstract. To understand this, let''s consider the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, consider another example where the inherited class is non-abstract. In
    this case, the child class should implement all the abstract members of the abstract
    class; otherwise, it will throw a compile-time error. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Virtual in nature**: Methods and properties marked as abstract for the `abstract`
    class are virtual, by default, in nature. These methods and properties will be
    overridden in inherited classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the complete example of abstract class implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` modifier provides a way to make a method of the anonymous type or
    a lambda expression as asynchronous. When it is used with a method, that method
    is called as the `async` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`async` will be discussed in details on day six.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will provide the same result as discussed in the code examples
    in the previous sections; the only difference is this method call is asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `const` modifier gives the ability to define a constant field or constant
    local. When we defined fields or variables using `const`, these fields are not
    called variables anymore because `const` is not meant for change, while variables
    are. Constant fields are class-level constants that are accessible within or outside
    the `class` (depends upon their modifier), while constant locals are defined within
    a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fields and variables defined as `const` are not variables and may not be modified.
    These constants can be any of these: numbers, bool, string, or null references.
    A static modifier is not allowed while declaring constants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code snippet that shows the valid constant declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modifier `event` helps declare an event for the `publisher` class. We will
    discuss this in detail on day five. For more information on this modifier, refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event)
  prefs: []
  type: TYPE_NORMAL
- en: extern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modifier `extern` helps declare a method that uses an external library or
    dll. This is important when you want to use an external unmanaged library.
  prefs: []
  type: TYPE_NORMAL
- en: A method that is implementing external unmanaged libraries using the `extern`
    keyword must be declared as static. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern)
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new` operator can be a modifier, an operator, or modifier. Let''s discuss
    this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operator**: `new` as an operator helps us create an object instance of a
    `class` and invokes their constructors. For example, the following line is showing
    the use of `new` as an operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Modifier**: The new modifier helps hide members inherited from a base class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is also known as hiding in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constraint**: The `new` operator as a constraint makes sure that in declaration
    of every generic class, it must have a public parameter-less constructor. This
    will be discussed in detail on day five.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: override
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `override` modifier helps extend the abstract or virtual implementation
    of inherited members (that is, method, property, indexer, or event). This will
    be discussed in detail on day seven.
  prefs: []
  type: TYPE_NORMAL
- en: partial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the help of the `partial` modifier, we can split a class, an interface,
    or a struct into multiple files. Look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two files, `Calculator.cs` and `Calculator1.cs`. Both files have
    `Calculator` as their partial class.
  prefs: []
  type: TYPE_NORMAL
- en: readonly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `readonly` modifier helps us create a field declaration as `readonly`.
    A `readonly` field can only be assigned a value at the time of declaration or
    as part of the declaration itself. To understand this better, consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will throw a compile-time error if we explicitly try to assign a value to
    the `Num1 readonly` field. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: sealed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modifier `sealed` is something that, when applied with a `class`, says,
    "I am not going to be available for any kind of inheritance further. Do not inherit
    me now." In simple words, this modifier restricts classes from being inherited
    by other classes.
  prefs: []
  type: TYPE_NORMAL
- en: The modifier sealed is used with override when applying abstract methods (which
    are virtual in default by nature) to derived or inherited class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You cannot apply a sealed modifier on an abstract classes. If we explicitly
    try this, it eventually throws a compile-time error. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modifier `static` helps us declare static members. These members are actually
    also known as class-level members and not object-level members. This means there
    is no need to create an instance of object to use these members.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the static modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are certain rules that need to be followed while working with the `static`
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restriction**: You can use the `static` modifier with only class, field,
    method, property, operator, event, and constructors. This modifier cannot be used
    with indexer and types other than `class`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nature by static**: When we declare a constant, it is implicitly static by
    nature. Consider the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `StringCalculator` class is has two constants, `Num1` and `Num2`.
    These are accessible by `class`, and there is no need to create an instance of
    `class.` See the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Complete static**: If class is defined with the use of the `static` modifier,
    then all the members of this `static` class should be `static`. There will be
    a compile-time error if a `static` class is explicitly defined to create non-static
    members. Consider the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Availability**: No need to create an instance of class to access the `static`
    member.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The keyword `this` cannot be applied on `static` methods or properties. We have
    already discussed this, and base keywords, on day two.
  prefs: []
  type: TYPE_NORMAL
- en: unsafe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This modifier helps use unsafe code blocks. We will discuss this in detail on
    day six.
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This modifier helps us define virtual methods that are meant to be overridden
    in inherited classes. See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual)
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A block of statements that have the access modifier, name, return type, and
    parameters (which may or may not be there) are nothing but a method. A method
    is meant to perform some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Methods are meant to call either by another method or by another program.
  prefs: []
  type: TYPE_NORMAL
- en: How to use a method?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As said earlier, methods are meant to perform some actions. So, any method or
    program that needs to utilize these actions could call/consume/use the defined
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method has various element discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access modifier**: A method should have an access modifier (refer to the
    previous section for more details on modifier). The modifier helps us define the
    scope of method or the availability of the method, for example. A method defined
    using the `private` modifier can only be visible to its own class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return type**: After performing an action, a method may or may not return
    something. Method return type is based on the data types (refer to day two for
    information on datatypes). For example, if method is returning a number, its data
    type would be an int and its return type is `void` if the method does not return
    anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: A name is unique within the `class`. Names are case sensitive. In
    the class `StringCalculator`, we cannot define two methods with the name `Sum()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter(s):** These are optional for any method. This means a method may
    or may not have a parameter. Parameters are defined based on the datatype.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functioning body**: A part of instructions to be executed by a method is
    nothing but a functionality of the method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a typical method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before moving ahead, let''s recall the requirements we discussed at the start
    of day four, where we created a method to calculate the sum of a string parameter
    list. Here is the program that meets these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces output as expected. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code is working absolutely fine but needs refactoring, so lets
    split our code into small methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Code refactoring is beyond the scope of this book. For more details on code
    refactoring, refer to [https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010.](https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010)
  prefs: []
  type: TYPE_NORMAL
- en: Now, our code looks better and readable. This will produce the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properties are members of a class, structure, or interface generally called
    as a named member. The intended behaviors of properties are similar to fields
    with the difference being that the implementation of properties is possible with
    the use of accessors.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are extensions to fields. The accessors get and set helps retrieve
    and assign value to property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the typical property (also called property with auto-property syntax)
    of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For auto property, compiler generates the backup field, which is nothing but
    a storage field. So, the preceding property would be shown as follows, with a
    backup field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding property with an expression body looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For more details on the expression bodies property, refer to [https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx.](https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx)
  prefs: []
  type: TYPE_NORMAL
- en: Types of properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple flavors of properties we can declare or play. We just discussed
    auto properties and discussed how compiler converts it with a backup storage field.
    In this section, we will discuss the other types of properties available.
  prefs: []
  type: TYPE_NORMAL
- en: Read-write property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A property that allows us to store and retrieve values is nothing but a read-write
    property. A typical read-write property with backing storage field would have
    both `set` and `get` accessors. The `set` accessor stores the data of the data
    type of the property. Note that for the set accessor, there's always a single
    parameter, that is, value, and this matches the storage data or data type of the
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Auto properties are automatically converted to property with backing storage
    fields by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following code snippet to understand this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we had two properties: one defined using the backing field and
    another by auto property. The accessor `set` is responsible for storing the data
    using the parameter value, and it matches the data type int, and `get` is responsible
    for retrieving the data of data type int.'
  prefs: []
  type: TYPE_NORMAL
- en: Read-only property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A property defined with only the `get` accessor or with a private `set` accessor
    is called a read-only property.
  prefs: []
  type: TYPE_NORMAL
- en: There is slight difference between read-only and `const`. Refer to [https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly](https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name indicates, read-only properties only retrieve values. You cannot
    store the data in a read-only property. See the following code snippet for more
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have three properties; all are read-only. `Num1` is
    a read-only property, and this is restricted by a constructor. This means you
    can set a property in a constructor only. `Num2` is a pure read-only property;
    this means it is meant to retrieve the data. Numbers is the auto-initializer read-only
    property; it has a default initialization for a property of collection.
  prefs: []
  type: TYPE_NORMAL
- en: Computed property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A property that returns the results of an expression is called a computed property.
    The expression may be based on other properties of the same class or based on
    any valid expression with CLR-compliant data types (for data types, refer to day
    two) that should be the same as the property data type.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties return the results of an expression and cannot allow to
    set data, so these are some kind of read-only property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this in detail, let''s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Block-bodied members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the block-bodied computed property, calculations are returned with the get
    accessor. Refer to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have three properties: `Num3`, `Num4` and `Sum`.
    The property `Sum` is a computed property that returns an expression result from
    within the get accessor.'
  prefs: []
  type: TYPE_NORMAL
- en: Expression-bodied members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In expression-bodied, the computed property calculations are returned using
    lambda expression, which is used by the expression-bodied members. Refer to the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, our `Add` property is returning an expression of `Sum`
    for two other properties.
  prefs: []
  type: TYPE_NORMAL
- en: Property using validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be scenarios when we want to validate certain data for properties.
    Then, we would use a few validations along with properties. These are not a special
    type of property, but complete properties with validation.
  prefs: []
  type: TYPE_NORMAL
- en: Data annotation is a way to validate various properties and add custom validations.
    For more information, refer to [https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame.](https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame)
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties are important in a scenario when we need to validate the input
    using properties. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there is no need to apply any explicit validation on
    the client code for the preceding property. The property `Number` is self-validated
    whenever it is being called to store data. In the previous code, whenever the
    client code tries to enter any negative number, it implicitly throws out an exception
    that the number can't be negative. In this case, only positive numbers are entered
    by the client code. On the same node, you can apply as much as validation as you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An indexer provides a way to access an object via an index like array. For instance,
    if we define an indexer for a class, that class works similarly to an array. This
    means the collection of this class can be accessed by index.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword `this` is used to define an indexer. The main benefit of indexer is
    that we can set or retrieve the indexed value without explicitly specifying a
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a simpler one to represent the power of an indexer. We
    have a `PersonCollection` class having an indexer that makes this class accessible
    via indexer. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the following output after executing the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For more information on indexers, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/)
  prefs: []
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File is nothing but a collection of data that stores physically in a directory
    of the system. The data that file contains could be any information. In C#, whenever
    the file is available programmatically for information retrieval (read) or updating
    information (write), that is nothing but a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Stream is nothing but a sequence of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C# file, I/O is just a way to call input streams or output streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input stream**: This is nothing but a read operation. Whenever we programmatically
    read the data from the file, it is called an input stream or a read operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output stream**: This is nothing but an update operation. Whenever we programmatically
    add data to the file, it is called an output stream or a write operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O is a part of the `System.IO` namespace that contains various classes.
    In this section, we will discuss FileStream that we will use in our code example.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of System.IO classes is available at [https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0)
  prefs: []
  type: TYPE_NORMAL
- en: FileStream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed previously, there are a couple of helpful classes that are available
    under the `System.IO` namespace. FileStream is one of these classes that helps
    us read/write data to/from a file. Before going on to discuss this `class`, let''s
    consider one short example where we will create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code first creates a file with specific text/data and then displays
    the same. Here is the output of the preceding code. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A complete reference of FileStream is available at [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception is a kind of error that comes when methods do not work as expected
    or are not able to handle the situation as intended. Sometimes, there might be
    unknown situations where exceptions occurred; for instance, a method can have
    a situation divide by zero problem in division operation the situation was never
    expected while someone wrote the method, this is an unpredicted situational error.
    To handle these kind of situations and other unknown scenarios that can create
    such exceptions or error, C# provides a method that is called exception handling.
    In this section, we will discuss exceptions and exception handing using C# in
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can be handled using the `try`...`catch`...`finally` block. Catch
    or finally blocks should be there with the try block to handle exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will throw an unhandled divide by zero exception if the
    divisor comes as zero once called using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following screenshot for the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To handle situations similar to the previous situation, we can use exception
    handling. In C#, exception handling has common components, which are discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: try block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `try` block is a code of block that is the source of the exception. A `try`
    block can have multiple `catch` blocks and/or one final bock. This means a `try`
    block should have at least one catch block or one final block.
  prefs: []
  type: TYPE_NORMAL
- en: catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `catch` block is a code block where a particular or general exception is
    being handled. The `catch` has a parameter of `Exception` that tells us what exception
    has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: finally block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `finally` block is one that executes in any case (if supplied) whether an
    exception is thrown or not. Generally, a `finally` block is meant to execute few
    cleanup tasks after exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `throw` keyword helps to throw a system or a custom exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s revisit the preceding code that threw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have modified the code by adding `try`...`catch`...`finally` blocks.
    Now, whenever an exception occurs, it first goes to the `catch` block and then
    to the `finally` block. After putting the `finally` block, whenever we divide
    by zero an exception will occur, which will produce the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Different compiler-generated exceptions in catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed previously, there may be multiple `catch` blocks within a `try`
    block. This means we can catch multiple exceptions. The different `catch` block
    could be written to handle a specific exception class. For example, an `exception`
    class for divide by zero exception is `System.DivideByZeroException`. A complete
    discussion of all these classes is beyond the scope of this book. For further
    study on these exception classes, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions)
  prefs: []
  type: TYPE_NORMAL
- en: User-defined exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom exceptions created as per requirements are user exceptions, and when
    we create an `exception` class, to handle a specific scenario, it is called a
    user-defined exception. All user-defined `exception` classes are derived from
    the `Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a user-defined `exception`. Recall the `StringCalculatorUpdated`
    class (discussed in the section **Methods**) that is responsible for calculating
    the sum of string numbers. Add one more scenario to the existing requirements,
    that is, throw the `NumberIsExceded` exception if any number is greater than 1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code snippet that handles our newly created exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever the number exceeds 1,000, it throws an exception. Let''s write
    a client code that throws an exception, consider the preceding code is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Discussing a regular expression and its importance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular expression or pattern matching is nothing but a way in which we can
    check whether an input string is correct or not. This is possible with the use
    of the `Regex` class of the `System.Text.RegularExpressions` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of a regular expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is very important while we are working to validate text input.
    Here, regular expression plays an important role.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns are very flexible and provide us with a way to make our own pattern
    to validate the input.
  prefs: []
  type: TYPE_NORMAL
- en: Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various constructs that help us define the regular expression. Hence,
    we need to make them important in our programming where we need validated input.
    These constructs are character classes, character escapes, quantifiers, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Special characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a huge usage of regular expressions in our day-to-day programmings
    and that why regular expressions are important. Here are various scenarios as
    per their usage, where special characters of regular expression helps us validate
    the input when it comes with a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The period sign (.)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a wildcard character that matches any character besides the newline
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The word sign (w)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backslash and a lowercase *w* is a character class that will match any word
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The space sign (s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: White space can be matched using *s* (backslash and *s*).
  prefs: []
  type: TYPE_NORMAL
- en: The digit sign (d)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The digits zero to nine can be matched using *d* (backslash and lowercase *d*).
  prefs: []
  type: TYPE_NORMAL
- en: The hyphen sign (-)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ranges of characters can be matched using the hyphen (*-*).
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the number of matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The minimum number of matches required for a character, group, or character
    class can be specified with curly brackets (*{n}*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code snippet showing the previous special characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code allows `inputText` and `Regexpression` to be performed on
    it. Here is the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Regular expression is a broad topic. For more details, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the unsolved questions from what you learned up until day four:'
  prefs: []
  type: TYPE_NORMAL
- en: What are access modifiers and their accessibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to use `protected internal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are abstract classes? Elaborate with the help of a program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does an abstract class have a constructor? If yes, the why can't we instantiate
    abstract class? (Refer to [https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created](https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain, with the help of a small program, how we can stop an abstract class
    from being inherited.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate the `sync` and `async` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate the `const` and `readOnly` modifiers with the help of a small
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a program to calculate string numbers in addition to the following rules
    to our `StringCalcuatorUpdated` example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw an exception where the number is greater than 1,000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore negative numbers by replacing them with zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the entered string is not a number, throw an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a small program to elaborate on property types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a property using validation to meet all rules discussed in *question
    8.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How we can handle exceptions in C#? Elaborate using a small program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a user-defined exception if a string contains special characters other
    than delimiters, as defined in the requirements of our class `StringCalculatorUpdated`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program to create a file dynamically with the use of various classes
    of the `System.IO` namespace (refer to [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are indexers? Write a short program to create a collection of paginated
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are regular expressions and how are they helpful in string manipulation.
    Elaborate using a small program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revisiting Day 04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are concluding our day four learning. Today, we discussed all available modifiers
    and went through the code examples of these modifiers; we also discussed accessor
    modifiers, namely `public`, `private`, `internal`, `protected`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we came to methods and properties, where we discussed various scenarios
    and dealt with programs. We also discussed the indexer and file I/O, and we concluded
    our day by learning regular expressions. We went through the constants and we
    discussed constant filed and constant local.
  prefs: []
  type: TYPE_NORMAL
- en: Tomorrow, that is, on day five, we will discuss some advanced concepts covering
    reflection and understand how we can create and execute code dynamically.
  prefs: []
  type: TYPE_NORMAL
