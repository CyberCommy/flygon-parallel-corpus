- en: Chapter 7. Advanced Module Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at a number of more advanced techniques for working
    with modules and packages. In particular, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the more unusual ways in which the `import` statement can be used, including
    optional imports, local imports, and how to tweak the way importing works by changing
    `sys.path`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly examine a number of "gotchas" relating to importing modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at how you can use the Python interactive interpreter to help develop
    your modules and packages more quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to work with global variables within a module or package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to configure a package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how to include data files as part of your Python package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try opening the Python interactive interpreter and entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpreter will return the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This shouldn't be a surprise to you; you may have even seen this error in your
    own programs if you made a typo within an `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing about this error is that it doesn''t just apply where
    you''ve made a typo. You can also use this to test if a module or package is available
    on this particular computer, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use this to have your program take advantage of the module if
    it is present, or do something else if the module or package isn''t available,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we check to see if the `numpy` library was installed, and if
    so, use `numpy.zeros()` to create a two-dimensional array. Otherwise, we use a
    list of lists instead. This allows your program to take advantage of the speed
    of the NumPy library if it was installed, while still working (albeit more slowly)
    if this library isn't available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this example is just made up; you probably wouldn't be able to use
    a list of lists directly instead of a NumPy array and have the rest of your program
    work without any change. But the concept of doing one thing if a module is present,
    and something else if it is not, remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using optional imports like this is a great way of having your module or package
    take advantage of other libraries, while still working if they aren't installed.
    Of course, you should always mention these optional imports in the documentation
    for your package so that your users will know what will happen if these optional
    modules or packages are installed.
  prefs: []
  type: TYPE_NORMAL
- en: Local imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Using Modules and Packages"), *Using Modules
    and Packages*, we introduced the concept of a **global namespace**, and showed
    how the `import` statement adds the name of the imported module or package into
    the global namespace. This description was actually a slight oversimplification.
    In fact, the `import` statement adds the imported module or package to the *current*
    namespace, which may or may not be the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there are two namespaces: the global namespace and the local namespace.
    The global namespace is where all the top-level definitions in your source file
    are stored. For example, consider the following Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import this Python module, you will have added four entries to the
    global namespace: `random`, `string`, `set_length`, and `make_name`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several other entries in the global namespace, automatically added
    by the Python interpreter. We'll ignore these for now.
  prefs: []
  type: TYPE_NORMAL
- en: If you then call the `set_length()` function, the `global` statement at the
    top of this function will add another entry to the module's global namespace,
    called `_length`. The `make_name()` function also includes a `global` statement,
    allowing it to refer to the global `_length` value while generating a random name.
  prefs: []
  type: TYPE_NORMAL
- en: So far so good. The thing that may not be so obvious is that, within each function,
    there is a second namespace called the **local namespace**, that holds all variables
    and other definitions that aren't global. In the `make_name()` function, the `letters`
    list, as well as the variable `i` used by the `for` statement, are *local* variables—they
    only exist within the local namespace, and their values are lost when the function
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local namespace isn''t just for local variables: you can use it for local
    imports, too. For example, consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `os` and `os.path` modules are imported *within* the function,
    rather than at the top of a module or other source file. Because these modules
    are imported within the function, the `os` and `os.path` names are added to the
    local namespace rather than the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, you should avoid using local imports: having all your `import`
    statements near the top of the source file (and so making all your import statements
    global) makes it easier to see at a glance which modules your source file depends
    upon. There are, however, two situations where local imports can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: If the module or package you are importing is particularly large or is slow
    to initialize itself, your module will be quicker to import if you use a local
    import rather than a global one. The delay when importing the module will only
    show up when your function is called. This can be particularly useful if the function
    is only called in certain circumstances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local imports are a great way of avoiding circular dependencies. If module A
    depends on module B and module B depends on module A, then your program will crash
    if both sets of imports are global. However, changing one set of imports to be
    a local import will break the co-dependency since the import won't take place
    until your function is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a general rule you should stick to global imports, though local imports can
    be very useful in these special situations.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking imports using sys.path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `import` command, the Python interpreter has to search for
    the module or package you want to import. It does this by looking through the
    **module search path**, which is a list of the various directories where modules
    or packages can be found. The module search path is stored in `sys.path`, and
    the Python interpreter will check the directories in this list one after another
    until the desired module or package is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Python interpreter starts, it initializes the module search path with
    the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: The directory containing the currently-executing script, or the current directory
    if you are running the Python interactive interpreter in a terminal window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any directories listed in the `PYTHONPATH` environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the interpreter's `site-packages` directory, including any modules
    referred to by path configuration files within the `site-packages` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `site-packages` directory is used to hold the various third-party modules
    and packages that you install. For example, if you use the Python Package Manager,
    `pip`, to install a Python module or package, that module or package would normally
    be placed within the `site-packages` directory.
  prefs: []
  type: TYPE_NORMAL
- en: A number of directories containing the various modules and packages that make
    up the Python Standard Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which these directories appear in `sys.path` is important because
    the search stops as soon as a module or package with the desired name is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can print out the contents of your module search path if you wish, though
    the list is likely to be long and rather hard to understand as there are often
    many directories containing the various parts of the Python Standard Library as
    well as other directories used by any third-party packages you may have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to remember is that this list is searched *in sequence*
    until a match is found. As soon as a module or package is found with the desired
    name, the search stops.
  prefs: []
  type: TYPE_NORMAL
- en: Now, `sys.path` is not just a read-only list. If you alter this list, for example
    by adding a new directory, you will change the places where the Python interpreter
    searches for modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are actually a few modules that are built in to the Python interpreter;
    these are always imported directly, ignoring the module search path. To see which
    modules have been built in to your Python interpreter, you can execute the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you try to import one of these modules, the built-in version will always
    be used, regardless of what you do to the module search path.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can make any changes you like to `sys.path`, for instance by removing
    or rearranging the contents of this list, the most common use is to add entries
    to the list. For example, you might want to store the various modules and packages
    that you create in a special directory, which you can then access from any Python
    program that needs it. For example, imagine that you have a directory at `/usr/local/shared-python-libs`
    which contains several modules and packages you''ve written that you want to use
    within a number of different Python programs. Within that directory, imagine that
    you have a module named `utils.py` and a package named `approxnums` that you wish
    to use in your program. While a simple `import utils` would fail with an `ImportError`,
    you can make the contents of your `shared-python-libs` directory available to
    your program in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering why you can''t just store your shared modules and packages
    within the `site-packages` directory. There are two reasons for this: first, because
    the `site-packages` directory is often protected and can only be written to by
    an administrator, which makes it hard to create and modify files stored in this
    directory. The second reason is that you might want to keep your own shared modules
    separate from other third-party modules that you''ve installed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we modified `sys.path` by appending our `shared-python-libs`
    directory to the end of this list. While this works, remember that the module
    search path is searched *in sequence*. If there was any other module in any directory
    on the module search path named `utils.py`, that module would be imported rather
    than the one in your `shared-python-libs` directory. For this reason, rather than
    appending, you would normally modify `sys.path` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use `insert(1, ...)` rather than `insert(0, ...)`. This has the
    effect of adding the new directory as the *second* entry in `sys.path`. Since
    the first entry in the module search path is normally the directory containing
    the currently executing script, adding the new directory as the second entry means
    that the program's directory will be searched first. This helps to avoid confusing
    errors where you define a module within your program's directory and find that
    a different module with the same name is being imported instead. For this reason,
    it is good practice to use `insert(1, ...)` when adding a directory to `sys.path`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, like any other technique, modifying `sys.path` can be abused. If
    your reusable module or package modifies `sys.path`, users of your code may be
    confused by subtle bugs that show up because you've changed the module search
    path. As a general rule, you should only ever change the module search path in
    a main program rather than a reusable module and always clearly document what
    you've done so that there are no surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Import gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While modules and packages are extremely useful, there are times when Python's
    `import` machinery can leave you with subtle problems that can take a long time
    to figure out. In this section, we will discuss some of the more common problems
    that you are likely to encounter while working with modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing name for your module or package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you''re writing a program that makes use of the Python Standard
    Library. For example, you might make use of the `random` module to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your program is working correctly until you decide that it has too many mathematical
    functions in the main script, and you refactor it to move these functions into
    a separate module. You decide to call this module `math.py`, and store it in your
    main program''s directory. As soon as you do this, the previous code will crash
    with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What on earth is going on here? Code that was working perfectly now crashes,
    even though you haven't changed it. To make matters worse, the traceback shows
    that it's crashing at the point where your program imports a module from the Python
    Standard Library!
  prefs: []
  type: TYPE_NORMAL
- en: To understand what is going on here, you need to remember that the module search
    path by default includes the current program's directory as the first entry—ahead
    of other entries which point to the various parts of the Python Standard Library.
    By creating a new module named `math.py` as part of your program, you've made
    it impossible for the Python interpreter to load the `math.py` module from the
    Python Standard Library. This applies not just to the code you write but to *any*
    module or package on the module search path that may try to load this module from
    the Python Standard Library. In this example, it was the `random` module that
    failed, but it could have been any module that depended on the `math` library.
  prefs: []
  type: TYPE_NORMAL
- en: This is known as **name masking**, and is a particularly insidious problem.
    To avoid it, you should always be careful when choosing the names for the top-level
    modules and packages in your program to make sure they don't mask a module in
    the Python Standard Library, regardless of whether you use that module or not.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to avoid name masking is to make use of a package to organize the
    modules and packages you write within your program. For example, you might create
    a top-level package named `lib`, and create your various modules and packages
    within the `lib` package. Since there's no module or package named `lib` in the
    Python Standard Library, there's no risk of you masking a Standard Library module,
    no matter what name you choose for the modules and packages you place inside the
    `lib` package.
  prefs: []
  type: TYPE_NORMAL
- en: Naming a Python script after a module or package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more subtle example of name masking can occur when you have a Python script
    that has the same name as a module in the Python Standard Library. For example,
    imagine that you''re trying to figure out how the `re` module ([https://docs.python.org/3.3/library/re.html](https://docs.python.org/3.3/library/re.html))
    works. This module can be a bit confusing if you haven''t worked with regular
    expressions before, so you might decide to write a simple test script to discover
    how it works. This test script might include the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This program might help you to figure out what the `re` module does, but if
    you save this script under the name `re.py`, you''ll get a mysterious error when
    you run your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Can you figure out what's going on here? The answer lies, once again, in the
    module search path. The name of your script, `re.py`, is masking the `re` module
    in the Python Standard Library, so when your program attempts to import the `re`
    module, it actually loads itself instead. You're seeing an `AttributeError` here
    because the script successfully loaded itself as a module but that module doesn't
    have the `search()` function you were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a script import itself as a module can also cause unexpected problems;
    we'll look at this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is simple: never use the name of a Python Standard
    Library module for a script. Instead, call your test script something like `re_test.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding package directories to sys.path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common trap to fall into is adding a package directory to `sys.path`. Let's
    take a look at what happens when you do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory to hold a test program, and create a sub-directory named
    `package` within this main directory. Then, create an empty package initialization
    (`__init__.py`) file within the `package` directory. Also, create a module, named
    `module.py`, within the same directory. Then, add the following to the `module.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out a message when the module is imported. Next, create a Python
    source file named `good_imports.py` in your top-most directory, and enter the
    following Python code into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving this file, open a terminal or command-line window and use the
    `cd` command to set the current directory to your outermost directory (the one
    containing your `good_imports.py` script), and type `python good_imports.py` to
    run this program. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the first `import` statement loaded the module, which caused
    the `### Initializing module.py ###` message to be printed out. For the subsequent
    `import` statements, no initialization took place—instead, the already-imported
    copy of the module was used. This is the behavior we want as it ensures that we
    only ever have one copy of each module. This is important for those modules that
    keep information in global variables as having different copies of a module with
    different values in their global variables can lead to all sorts of strange and
    confusing behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, that''s exactly what we can end up with if we add a package,
    or a sub-directory of a package, to `sys.path`. To see this problem in action,
    create a new top-level script named `bad_imports.py`, and enter the following
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This program sets `package_dir` to the full directory path to the `package`
    directory and then adds this directory to `sys.path`. It then makes two separate
    `import` statements, one to import `module` from the package named `package` and
    the other to import `module` directly. Both `import` statements will work as the
    module can be accessed in both ways. However, the results are not what you might
    expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the module is imported *twice*, once as `package.module` and
    again as `module`. You end up with two separate copies of the module, both of
    which are initialized and appear as two distinct modules to the Python system.
  prefs: []
  type: TYPE_NORMAL
- en: Having two copies of a module can lead to all sorts of subtle bugs and problems.
    This is why you should never add a Python package, or a sub-directory of a Python
    package, directly to `sys.path`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, it's fine to add a directory *containing* a package to `sys.path`;
    just don't add the package directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: Executing and importing the same module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another more subtle example of the double-import problem can occur if you execute
    a Python source file and then import that same file as if it were a module. To
    see how this works, create a directory to hold a new example program, and create
    a new Python source file in this directory named `test.py`. Then, enter the following
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When this file is run as a script, it calls the `helpers.run_test()` function
    to start running a test. This file also defines a function, `do_something()`,
    that performs some useful functionality. Now, create a second Python source file
    in the same directory named `helpers.py`, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `helpers.py` module is importing `test.py` as a module and
    then calling the `do_something()` function as part of running the test. In other
    words, even though `test.py` is executed as a script, it is also being imported
    (indirectly) as a module as part of the execution of that script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when you run this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good. The program is running and, despite the convoluted module imports,
    it seems to be working. But let''s take a closer look; add the following statement
    to the top of your `test.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As in our previous example, we are using a `print()` statement to show when
    the module is being loaded. This gives the module the opportunity to initialize
    itself, and we would expect to only see the initialization happen once as there
    should only ever be one copy of each module in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, however, that''s not what happens. Try running the program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the module is being initialized *twice*—once when it's run as
    a script and again when the module is imported by `helpers.py`.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, make sure that any scripts you write are only used as
    scripts. Keep any other code (such as the `do_something()` function from our previous
    example) out of your scripts so that you'll never need to import them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this doesn't mean that you can't have chameleon modules that act as
    both a module and as a script, as described in [Chapter 3](ch03.html "Chapter 3. Using
    Modules and Packages"), *Using Modules and Packages*. Just be careful that the
    script you execute only uses functions defined within the module itself. If you
    start importing other modules from the same package, you should probably move
    all the functionality into a different module, which you then import into your
    script, rather than having them both together in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Using modules and packages with the Python interactive interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As well as calling modules and packages from a Python script, it is often useful
    to call them directly from the Python interactive interpreter. This is a great
    way of employing the **rapid application development** (**RAD**) technique for
    Python programming: you make a change of some sort to a Python module or package
    and immediately see the results of your change by calling that module or package
    from the Python interactive interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a few limitations and issues to be aware of. Let's take
    a closer look at how you can use the interactive interpreter to speed up your
    development of modules and packages; we'll also see where a different approach
    might suit you better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new Python module named `stringutils.py`, and enter the
    following code into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This module represents our first attempt at writing a function to extract all
    the numbers from a string. Note that it is not working yet—the `extract_numbers()`
    function will crash if you try to use it. It's also not particularly efficient
    (a much easier approach would be to use the `re.findall()` function). But we're
    using this code deliberately to show how you can apply rapid application development
    techniques to your Python modules, so bear with us.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses the `re` (regular expression) module to find the parts of
    the string that match the given expression pattern. The complicated `pattern`
    string is used to match a number, including an optional `+` or `-` at the front,
    any number of digits, and an optional fractional part at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `re.finditer()` function, we find the parts of the string that match
    our regular expression pattern. We then extract each matching part of the string
    and append the results to the `numbers` list, which we then return back to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: So much for what our function is supposed to do. Let's test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal or command-line window, and use the `cd` command to switch
    to the directory holding the `stringutils.py` module. Then, type `python` to start
    up the Python interactive interpreter. When the Python command prompt appears,
    try entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our module doesn''t work yet—we have a bug in it. Looking closer,
    we can see that the problem is on line 7 of our `stringutils.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message suggests that you are trying to add a built-in function (in
    this case, `match.end`) to a number (`1`), which of course doesn''t work. The
    `match.start` and `match.end` values were supposed to be the indices into the
    string for the start and end of the number, but a quick look at the documentation
    for the `re` module shows that `match.start` and `match.end` are functions, not
    simple numbers, and so we need to call these functions to get the values we want.
    Doing this is easy; simply edit line 7 of your file to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve changed our module, let''s take a look at what happens. We''ll
    start by re-executing the `print()` statement to see if that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you know that you can press the up arrow and down arrow keys on your keyboard
    to move through the history of commands that you've typed previously into the
    Python interactive interpreter? This saves you from having to retype a command;
    simply use the arrow keys to select the command you want, and press *Return* to
    execute it.
  prefs: []
  type: TYPE_NORMAL
- en: You'll immediately see the same error message you saw previously—nothing has
    changed. This is because you imported the module into the Python interpreter;
    once a module or package has been imported, it is held in memory and the source
    file(s) on disk are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have your changes take effect, you need to **reload** the module. To do
    this, type the following into your Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Python 2.x, you can't use the `importlib` module. Instead,
    simply type `reload(stringutils)`. If you are using Python version 3.3, use `imp`
    rather than `importlib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try re-executing that `print()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s much better—our program now runs without crashing. There is, however,
    one more problem we need to fix: when we extract the characters that make up a
    number, we''re extracting one character too many, so the number `1` is being returned
    as `1o` and so on. To fix this, remove the `+1` from line 7 of your source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, reload the module again and re-execute your `print()` statement. You
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! If you wanted to, you could use the `float()` function to convert these
    strings into floating-point numbers, but for our purposes this module is now finished.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a step back and review what we've done. We had a module with mistakes
    in it, and used the Python interactive interpreter to help identify and fix these
    problems. We repeatedly tested our program, noticed a mistake, and fixed it, using
    a RAD approach to quickly find and correct the bugs in our module.
  prefs: []
  type: TYPE_NORMAL
- en: When developing your modules and packages, it's often helpful to test them in
    the interactive interpreter to find and fix problems as you go along. You just
    have to remember that every time you make a change to a Python source file, you'll
    need to call `importlib.reload()` to reload the affected module or package.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Python interactive interpreter in this way also means that you have
    the complete Python system available for your testing. For example, you could
    use the `pprint` module in the Python Standard Library to pretty-print a complex
    dictionary or list so that you can easily view the information being returned
    by one of your functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some limitations, however, in the `importlib.reload()` process:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you have two modules, A and B. Module A uses the `from B import...`
    statement to load functionality from module B. If you then change module B, the
    changed functionality won't be used by module A unless you reload that module
    too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If your module crashes while initializing itself, it can end up in a strange
    state. For example, imagine that your module includes the following top-level
    code, which is supposed to initialize a list of customers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This module will be imported, but because of the misspelled variable name it
    will raise an exception during initialization. If this happens, you will need
    to firstly use the `import` command in the Python interactive interpreter to make
    the module available, and then use `imp.reload()` to load the updated source code.
  prefs: []
  type: TYPE_NORMAL
- en: Because you have to either type the commands yourself or select a command from
    the Python command history, it can get tedious to run the same code over and over,
    especially if your test involves more than a couple of steps. It's also very easy
    to miss a step when using the interactive interpreter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it is best to use the interactive interpreter to fix specific
    problems or to help you rapidly develop a particular small piece of code. Custom
    written scripts work better when the tests get complicated or if you have to work
    with multiple modules.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with global variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how to use global variables to share information between
    different functions within a module. We've seen how to define globals as top-level
    variables within a module, causing them to be initialized the first time the module
    is imported, and we have also seen how to use the `global` statement within a
    function to allow that function to access and change the value of a global variable.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will build on this knowledge to learn how to share global
    variables *between* modules. When creating a package, you often need to define
    variables that can be accessed or changed by any module within that package. Sometimes,
    you also need to make a variable available to Python code outside your package.
    Let's take a look at how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `globtest`, and create an empty package initialization
    file inside this directory to make it a Python package. Then, create a file inside
    this directory named `globals.py`, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this module, we have defined two global variables that we want to use in
    our package, and given each variable a default value of `None`. Let's now use
    these globals in another module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another file in the `globtest` directory named `test.py`, and enter
    the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To test your program, open a terminal or command-line window, use the `cd`
    command to move to the directory that contains your `globtest` package, and type
    `python` to start up the Python interactive interpreter. Then, try entering the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have successfully set the value of the `language` and `currency`
    globals, which are stored in our `globals` module, and then retrieved these values
    again to print them out. Because we are storing these globals in a separate module,
    you can retrieve or change these globals anywhere within the current package or
    even in other code that imports your package. Using a separate module to hold
    your package's global variables is an excellent way of managing globals within
    a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is, however, one thing to be aware of: for a global variable to be shared
    between modules, you must import the *module* that contains that global variable,
    not the variable itself. For example, the following won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: What this statement does is import a copy of the `language` variable into your
    current module's global namespace, not the original global. This means that the
    global variable won't be shared with other modules. For a variable to be shared
    between modules, you need to import the `globals` module, not the variables within
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Package configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you develop more sophisticated modules and packages, you will often find
    that your code needs to be *configured* in some way before it can be used. For
    example, imagine that you're writing a package that uses a database. To do this,
    your package needs to know which database engine to use, the name of the database,
    and the username and password to use to access that database.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could hardwire this information into your program''s source code, but doing
    this is a very bad idea, for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Different computers and different operating systems will use different database
    setups. Since the information used to access the database will vary from one computer
    to another, anyone wanting to use your package would have to edit the source code
    directly to enter the correct database details before the package can be run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username and password used to access a database is highly sensitive information.
    If you share your package with other people, or even just store a copy of your
    package's source code on a public repository such as GitHub, then other people
    can discover your database access credentials. This is a huge security risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These database access credentials are an example of *package configuration*—information
    that your package needs before it can run but which you don't want to build into
    your package's source code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are building an application rather than a standalone module or package,
    your configuration task is much simpler. There are modules in the Python Standard
    Library that can help with configuration, for example, `configparser`, `shlex`,
    and `json`. Using these modules, you can store configuration settings in a file
    on disk, which the end user can edit. When your program starts, you load those
    settings into memory and access them as needed. Because the configuration settings
    are stored externally to your application, users won't have to edit your source
    code to configure the program, and you won't be exposing sensitive information
    if your source code is published or shared.
  prefs: []
  type: TYPE_NORMAL
- en: When writing modules and packages, however, the file-based approach to configuration
    is much less convenient. There's no obvious place to store a package's configuration
    file, and requiring configuration files at a particular location is going to make
    your module or package harder to reuse as part of a different program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, configuration for a module or package is usually done by supplying
    parameters to your module or package''s initialization function. We saw an example
    of this in the previous chapter, where the `quantities` package required you to
    supply a `locale` value when initializing the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This passes the job of configuration back to the surrounding application; the
    application can make use of a configuration file, or any other configuration scheme
    it likes, and it is the application that supplies the package''s configuration
    settings when the package is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Package configuration](graphics/B05102_7_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This makes things easier for the package developer as all the package needs
    to do is remember the settings it has been given.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `quantities` package only used a single configuration setting (the
    name of the locale), it is common for packages to use many settings. A very convenient
    way of supplying the configuration settings for a package is to use a Python dictionary.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a dictionary in this way makes it easy to support *default values* for
    your package''s configuration settings. The following Python snippet shows how
    a package''s `init()` function can accept configuration settings, supply default
    values, and store the settings in a global variable so that it can be accessed
    when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using `dict.get()` in this way, you retrieve the setting if one has been supplied,
    while providing a default value to use if the setting isn't specified. This is
    an ideal way of handling configuration within a Python module or package, making
    it simple for users of your module or package to configure it as required, while
    still leaving the details of how and where the configuration settings are stored
    up to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Package data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A package might contain more than just Python source files. Sometimes, you might
    need to include other types of files as well. For example, a package may include
    one or more image files, a large text file containing a list of all the ZIP codes
    in the USA, or any other type of data you may need. If you can store something
    in a file, you can include this file as part of your Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would place your package data in a separate sub-directory within
    the package directory. To access these files, your package needs to know where
    to find this sub-directory. While you could hardwire the location of this directory
    into your package, this won''t work if your package is to be reused or moved.
    It''s also not necessary as you can easily find the directory in which a module
    resides by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you the complete path to the directory containing the current module.
    Using the `os.path.join()` function, you can then get access to the sub-directory
    that holds your data files and open them in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about including data files inside your package is that the data
    files are effectively part of your package's source code. When you share your
    package or upload it to a source code repository such as GitHub, the data files
    are automatically included along with the rest of your package. This makes it
    much easier to keep track of the data files used by your package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a number of the more advanced aspects of working
    with modules and packages in Python. We saw how a `try..except` statement can
    be used to implement optional imports, and how an `import` statement can be placed
    inside a function so that the module only gets imported when that function is
    executed. We then learned about the module search path and how you can modify
    `sys.path` to change the way the Python interpreter looks for modules and packages.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at some of the gotchas related to the use of modules and packages.
    We learned about name masking, where you define a module or package with the same
    name as a module or package in the Python Standard Library, which can lead to
    unexpected failures. We looked at how giving a Python script the same name as
    a Standard Library module can also cause name masking problems, and how adding
    a package directory or sub-directory to `sys.path` can cause a module to be loaded
    twice, leading to subtle problems with global variables within that module. We
    saw how executing a module and then importing it also leads to that module being
    loaded twice, which can again lead to problems.
  prefs: []
  type: TYPE_NORMAL
- en: We next looked at how you can use the Python interactive interpreter as a type
    of rapid application development (RAD) tool to quickly find and fix problems within
    your modules and packages, and how the `importib.reload()` command allows you
    to reload a module after you have changed the underlying source code
  prefs: []
  type: TYPE_NORMAL
- en: We finished our survey of advanced module techniques by learning how to define
    global variables that are used throughout a package, how to handle package configuration,
    and how to store and access data files within a package.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the ways in which you can test,
    deploy, and share your Python modules and packages.
  prefs: []
  type: TYPE_NORMAL
