- en: Chapter 5. Managing Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](part0032.xhtml#aid-UGI01 "Chapter 4. Developing the Model-View-Controller
    Layers"), *Developing the Model-View-Controller Layers*, we used the Model-View-Controller
    pattern and wrote the base of our social network. We split our application into
    backend and frontend directories. The code in the first folder serves the assets
    and generates the home page. Along with this, we made the base of our backend
    API. The client side of the project is driven by the Ractive.js framework. This
    is the place where we store our controllers, models, and views. With these elements,
    we will continue with the management of users. In this part of the book, we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the MongoDB database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering a new user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication with sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a user's profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the MongoDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, almost every web application stores and retrieves data from a database.
    One of the most popular databases that works well with Node.js is MongoDB ([http://www.mongodb.org/](http://www.mongodb.org/)).
    This is what we are going to use. The main characteristic of MongoDB is that it
    is a NoSQL database with a different data format and query language.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with every other popular software, MongoDB is available for all operating
    systems. If you are a Windows user, there is an installer that you can download
    from the official page [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
    For Linux or OS X developers, MongoDB is reachable through most popular package
    management systems. We are not going to cover the installation in detail, but
    you will find nicely written instructions at [http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Running MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After its successful installation, we will have a `mongod` command available.
    By running it in the terminal, we start a MongoDB server listening by default
    on port `27017`. Our Node.js backend will connect to this port and execute database
    queries. Here is how our console looks like after the execution of the `mongod`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running MongoDB](img/image00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting to the database server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A benefit of Node.js is the existence of thousands of modules. Because of the
    growing community, we have a module for almost every task that we come across.
    We have already used several Gulp plugins. Now, we will add the official MongoDB
    driver to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to run `npm install` to get the module into the `node_modules` directory.
    Once the process finishes, we can connect to the server with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `nodejs-by-example` is the name of our database. The callback
    that is invoked gives us access to the driver''s API. We can use the `db` object
    to operate with the collections in the database or in other words, create, update,
    retrieve, or delete documents. This can be demonstrated with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how to manage the data in our system. Let's continue to the next
    section and extend our client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the code from the previous chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding new functionalities to the code base that already exists means refactoring
    and extending the already written code. In order to develop the management of
    users, we need to update the `models/Base.js` file. So far, we have a simple `Version`
    model and we will need a new `User` model. An improvement in our navigation and
    routing is needed so that users have pages to create, edit, and manage their accounts.
  prefs: []
  type: TYPE_NORMAL
- en: The code that comes with this chapter has a lot of additions to the CSS styles.
    We are not going to discuss them, because we want to focus more on the JavaScript
    part. They provide a slightly better look to the application. If you are interested
    in how the final CSS is generated, check out the code pack of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our base model class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, `models/Base.js` has had only two methods. The first one, `fetch`,
    performs a `GET` request to the server with the given URL. In [Chapter 2](part0020.xhtml#aid-J2B81
    "Chapter 2. Architecting the Project"), *Architecting the Project*, we talked
    about REST APIs; to fully support this architecture, we have to add methods to
    create, update, and remove records. In fact, all these methods will be close to
    the one that we already have. Here is the `create` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We run the method of the model, which gets the data from its `value` property
    and executes a `POST` request. In the end, we fire a callback. If there is a problem,
    we send the error as a first argument. If not, then the first argument (representing
    an error state) is `null` and the second one contains the server's response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the same approach for updating and deleting code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The difference is the `request` method. For the `save` operation, we use `PUT`,
    and to remove data, we use `DELETE`. Note that during the deletion, we do not
    have to send the model's data as we are performing a simple operation to remove
    a specific data object from the database and not making more complex changes as
    seen in the `create` and `save` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Updating page navigation and routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code from [Chapter 4](part0032.xhtml#aid-UGI01 "Chapter 4. Developing the
    Model-View-Controller Layers"), *Developing the Model-View-Controller Layers*,
    contains only two links in its navigation. We need to add a bit more to it—links
    to register, log in and out, and profile management access. The `frontend/tpl/navigation.html`
    template fragment looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Together with the new `<a>` tags, we made the following two interesting additions:'
  prefs: []
  type: TYPE_NORMAL
- en: There is an `{{#if}}` expression. In our Ractive.js component, we need to register
    an `isLogged` variable. It will control the state of the navigation by hiding
    and showing the appropriate buttons. When the user is not logged in, we will display
    the **Register** and **Login** buttons. Otherwise, our application will show the
    **Logout** and **Profile** links. More about the `isLogged` variable will be discussed
    at the end of this chapter when we cover session support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the `on-click` attributes. Note that these attributes are not valid
    HTML, but they are interpreted by Ractive.js to produce the desired result. Every
    link in the navigation will dispatch a `goto` event with a specific parameter,
    and this will happen when the links are triggered by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the main file of the application (`frontend/js/app.js`), we have a `showPage`
    function. This method has access to the current page, and it is a perfect place
    to listen for the `goto` event. It is also a good choice because in the same file,
    we have a reference to the router. Thus, we are able to change the current site''s
    page. A little change to this function and we are done with the switching of the
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will continue with the code that will register a new
    user in our system.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a new user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To handle the registration of users, we need to update both our frontend and
    backend code. The client-side part of the application will collect the data and
    the backend will store it in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We updated the navigation and now, if users click on the **Register** link,
    the app will forward them to a `/register` route. We have to tweak our router
    and register a handler in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the home page, we will create a new controller located in `frontend/js/controllers/Register.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The template attached to this controller contains a form with several fields—the
    first and last name, e-mail, and a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth mentioning that we have placeholders for error and success messages.
    They are protected with the `{{#if}}` expressions and are hidden by default. If
    we, in the controller, set a value to the `error` or `success` variables, these
    hidden `div` elements will become visible. In order to get the values of the input
    fields, we will use Ractive.js bindings. By setting `value="{{firstName}}"`, we
    will create a new variable that will be available in our controller. We can even
    listen for changes in this variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The data from the input field should be sent to a `model` class that communicates
    with the backend. Since we have several form fields, it makes sense to create
    a helper that saves us a little writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setter` method returns the same closure that we used in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we look back and check `controllers/Register.js`, we will see all the fields
    from the registration form. In this form, we have a button that dispatches the
    `register` event. The controller is subscribed for that event and triggers the
    `create` function of the model. Based on the result, we either show an error message
    or display a registration successful message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we used a `userModel` object. This is an instance of
    the `User` class, which extends the `models/Base.js` file. Here is the code that
    is stored in `frontend/js/models/User.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We extended the base model. So, we got the `create` and `setter` functions automatically.
    For the registration process, we do not need any other custom methods. However,
    to log in and out, we will add more functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several parts of our system will need this model. So, we will create its global
    `userModel` instance. An appropriate place for this is the `frontend/js/app.js`
    file. The listener of the `window.onload` event is a good host for such code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that we missed the `var` keyword in front of the variable definition. This
    is how we make `userModel` available in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the backend API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our client-side code making a `POST` request to the backend with the
    new user''s data. To close the circle, we have to handle the request in our backend
    API and record the information in the database. Let''s first extend `backend/API.js`
    with a few helper functions and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of this chapter, we learned how to make queries to the MongoDB
    database. What we need is access to the driver's API. There is a piece of code
    that we will use often. So, it is a good idea to wrap it in a helper method. The
    `getDatabaseConnection` function is exactly the function that can be used to achieve
    this. It only connects to the database during the first time of its execution.
    Every call after that returns the cached `database` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common task typical to Node.js request handling is the fetching of
    the `POST` data. The `GET` parameters are available in the `request` object that
    comes to every route handler. However, for the `POST` data, we need a special
    helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We use the `request` object as a stream and subscribe to its `data` event. Once
    we receive all the information, we use `querystring.parse` to format it into a
    usable hashmap (key/value of the `POST` parameters) object and fire the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we will add an e-mail validation function. We will need it during
    the registration and the updating of the user''s profile. The actual validation
    is done with the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s continue with the code that will accept the `POST` request and register
    a new user in the database. So far, we have only added two routes to the API—`/api/version`
    and the default one. We will add one more, `/api/user`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same route will host different operations. To distinguish them, we will
    rely on the `request` method as it is described in the REST API concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `POST` case, we will first fetch the data by using the `processPOSTRequest`
    helper. After that, we will run a series of checks to make sure that the data
    sent is correct. If it is not, we will respond with an appropriate error message.
    If everything is okay, we will use the other `getDatabaseConnection` helper and
    make a new record in the database. It''s not a good practice to store the users''
    password as plain text. So, before sending them to MongoDB, we will encrypt them
    using the `sha1` module. This is a module that is available in the Node.js package
    manager registry. At the top of `backend/API.js`, we will add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To get this line working, we have to update the `package.json` file and run
    `npm install` in the console.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement the `GET`, `PUT` and `DELETE` cases.
    Together with this, we will introduce you to a new route to log in.
  prefs: []
  type: TYPE_NORMAL
- en: User authentication with sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We implemented the functionalities that register new users in our system. The
    next step is to authenticate these users. Let''s first provide an interface to
    enter a username and password. We need to add a new route handler in `frontend/js/app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All the other pages so far use the same idea. We will initialize a new controller
    and pass it to the `showPage` helper. The template that is used here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'During the registration process, we used similar placeholders for the error
    and success messages. Again, we have an HTML form. However this time, the form
    contains input fields for the username and password. We will also bind two variables
    and make sure that the button dispatches the `login` event. Here is the code for
    our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the same `setter` function, we stored the values filled into our model.
    There is a `userModel.login` method that is similar to `userModel.create`. It
    triggers a `POST` request to the server with the given data. In this case, the
    data is the username and password. This time, we are not going to use functions
    from the base model. We will register a new one in the `/frontend/js/models/User.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we used the Ajax helper to send information to the backend API. The
    request goes to the `/api/user/login` URL. At the moment, we will not handle such
    routes. The following code goes to `/backend/API.js` just above the `/api/user`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `processPOSTRequest` function delivers the `POST` data sent by the frontend.
    We will keep the same e-mail and password validation mechanisms. If everything
    is okay, we will check whether the provided credentials match some of the accounts
    in the database. The result for a correct e-mail and password is an object containing
    the user''s details. It is not a good idea to return the ID and password of the
    user. So, we will remove them from the returned user object. There is one more
    thing that we haven''t talked about so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we store a session. By default, we do not have a `session` object
    available. There is a module that delivers this functionality. It''s called `cookie-session`.
    We have to add it to `package.json` and run the `npm install` command in the terminal.
    After its successful installation, we have to tweak the `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Before passing the application's flow to the router, we run the `checkSession`
    function. The method uses the newly added module and patches the `request` object
    by attaching the `session` object. All API methods have access to the current's
    user session. This means that we may secure every request to the backend by simply
    checking whether the user is authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may remember that at the beginning of this chapter, we created a global
    `userModel` object. It''s initialization occurred in the `window.onload` handler,
    which is effectively the bootstrapping point of our frontend. We can ask the backend
    whether the current user is logged in before showing the UI. This will help us
    display the proper navigation buttons. So, here is how `frontend/js/app.js` changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userModel` function extends the base model where the `fetch` method puts
    the response from the server in the `value` property of the model. Fetching data
    from the frontend means making a `GET` request, and in this case, this is a `GET`
    request to the `/api/user` URL. Let''s see how `backend/API.js` handles the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user is logged in, we return what is stored in the `session` object.
    If not, the backend responds with an empty object. For the client side, this means
    that the `userModel` object may or may not have information in its `value` property
    based on the current user''s status. So, it makes sense to add a new `isLogin`
    method in the `frontend/js/models/User.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the preceding function, we can use the `userModel.isLogged()` call anywhere
    in our client-side code and we will know whether the user has logged in or not.
    This will work because we performed the fetching at the very beginning of our
    application. For example, the navigation (`frontend/js/views/Navigation.js`) needs
    this information in order to display the correct links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Managing a user's profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous sections of this chapter gave us enough knowledge to update the
    information saved in the database. Again, we need to create a page in the frontend
    that has an HTML form. The difference here is that the input fields of the form
    should be filled by default with the data of the current user. So, let''s start
    by adding a route handler for the `/profile` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is no reason to allow access to this page if the user is not logged in.
    A simple authentication check before calling the `showPage` helper forwards the
    user to the login page if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template that we need for the `Profile` controller is identical to the
    one that we used for registration. There are only two things that we have to change—we
    need to remove the `email` field and update the label of the button from **Register**
    to **Update**. The removing of the `email` field is not absolutely necessary,
    but it is a good practice to prevent changes by the user and leave it as it was
    entered during the registration. Here is how the controller looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `updateProfile` event is the event that is fired by the button on the page.
    We update the `model` fields with the values from the form. The password is changed
    only if the user enters something in the field. Otherwise, the backend keeps the
    old value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call `userModel.save`, which performs a `PUT` request to the API. Here
    is how we handle the request in `backend/API.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The usual field validation is here again. We will check whether the user has
    typed something for their first and last name. The password is updated only if
    there is data for the same. It's important to note that we need the user's e-mail
    to update the profile. This is how we refer to the exact record in our MongoDB
    database. Since we stored the e-mail in the session of the user, it is quite easy
    to fetch it from there. If everything goes well, we update the information in
    the `session` object. This is needed because the frontend gets the user's details
    from there, and if we forget to perform this change, our UI will show the old
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made a lot of progress. We built one of the core features
    of our social network—user management. We learned how to store data in a MongoDB
    database and use sessions to authenticate users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will implement the functions of friend management. The
    users of any social network will be familiar with the same. At the end of the
    next chapter, users will be able to make friends using our application.
  prefs: []
  type: TYPE_NORMAL
