- en: Improving UI Feedback with UMG and Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过UMG和音频改进UI反馈
- en: User feedback is very important in games, because the user needs information
    about what is going on in the game (score, hp, displaying inventory, and so on).
    In previous chapters, we've created a very simple HUD to display text and items
    in your inventory, but if you want a game that looks professional you'll want
    to have a much nicer **User Interface** (**UI**) than that!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，用户反馈非常重要，因为用户需要了解游戏中发生的情况（得分、生命值、显示库存等）。在以前的章节中，我们创建了一个非常简单的HUD来显示文本和库存中的物品，但是如果您想要一个看起来专业的游戏，您将需要一个比那更好得多的**用户界面**（**UI**）！
- en: Fortunately, there are easier ways of building a UI now with Unreal Motion Graphics
    UI Designer (UMG), a system included with UE4, just for this purpose. This chapter
    will show you how to use it to take what we've done before and make something
    that looks much better and has more functionality. We'll start updating the inventory
    window, and I will make suggestions on how you can continue the process and update
    the rest of the UI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在有更简单的方法来使用虚幻动态图形UI设计师（UMG）构建UI，这是UE4附带的系统，专门用于此目的。本章将向您展示如何使用它来接管我们之前所做的工作，并制作看起来更好并具有更多功能的东西。我们将开始更新库存窗口，并我将提出您可以继续该过程并更新其余UI的建议。
- en: Another way of providing feedback is through audio, either in the game itself
    or through the UI when you interact with it, so we will also be introducing how
    to play sounds.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过音频提供反馈的另一种方法是，无论是在游戏本身还是通过UI与其交互时，我们还将介绍如何播放声音。
- en: 'The topics we''ll be covering are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要涵盖的主题如下：
- en: What is UMG?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMG是什么？
- en: Updating the inventory window
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新库存窗口
- en: Laying out your UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局您的UI
- en: Updating your HUD and adding health bars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新您的HUD并添加生命条
- en: Playing audio
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频
- en: What is UMG?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG是什么？
- en: You may have noticed that the code we've used to draw on the screen has been
    very complicated. Every element needs to be placed onscreen manually. You might
    ask yourself if there's an easier way. And there is! It's the Unreal Motion Graphics
    UI Designer, or UMG.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们用来在屏幕上绘制的代码非常复杂。每个元素都需要手动放置在屏幕上。您可能会问自己是否有更简单的方法。有！那就是虚幻动态图形UI设计师，或者UMG。
- en: UMG simplifies the process of creating a UI by using special blueprints to allow
    you to lay out the interface visually. This can also let you have a tech-savvy
    artist do the layout for you, while you hook everything up. We will be using this,
    but since this is a C++ book we will be handling most of the behind the scenes
    functionality in C++.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: UMG通过使用特殊蓝图简化了创建UI的过程，允许您以可视方式布局界面。这也可以让您让精通技术的艺术家为您设计布局，而您则将一切连接起来。我们将使用这个，但由于这是一本C++书，我们将在C++中处理大部分幕后功能。
- en: 'In order to use UMG, first you need for find the `GoldenEgg.Build.cs` file
    in your Visual Studio project. `.cs` files are generally C#, not C++, but you
    don''t have to worry about that since we''ll only be making minor changes to this
    file. Find this line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用UMG，首先需要在Visual Studio项目中找到`GoldenEgg.Build.cs`文件。`.cs`文件通常是C#，而不是C++，但您不必担心，因为我们只会对此文件进行轻微更改。找到这一行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And add the following to that list:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下内容添加到列表中：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may want to restart the engine once you do that. Then you'll be ready to
    code in UMG!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要在这样做后重新启动引擎。然后您将准备好在UMG中编码！
- en: Updating the inventory window
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新库存窗口
- en: We're going to start by updating the inventory window. What we have right now
    isn't a real window, just images and text drawn on the screen, but now you'll
    see how you can easily create something that looks more like a real window—with
    a background and a Close button, and the code will be much simpler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从更新库存窗口开始。我们现在拥有的不是一个真正的窗口，只是在屏幕上绘制的图像和文本，但现在您将看到如何轻松创建看起来更像真正窗口的东西——带有背景和关闭按钮，代码将更简单。
- en: The WidgetBase class
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WidgetBase类
- en: 'To create a C++ class for a UMG Widget, you need to create a new class based
    on `UserWidget`. To find it when adding a new C++ class, you need to check Show
    All Classes and search for it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '要为UMG小部件创建C++类，您需要基于`UserWidget`创建一个新类。在添加新的C++类时，需要检查显示所有类并搜索它以找到它： '
- en: '![](img/bf64bda7-1e63-4817-b4d7-48e14dd54e41.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf64bda7-1e63-4817-b4d7-48e14dd54e41.png)'
- en: Name your class `WidgetBase`. This will be the base class from which you will
    derive any other Widget classes you create. This allows you to put functionality
    in this class that will be reused in many different Widgets. In this case, I put
    the functionality for `CloseButton` in there. Not all Widgets will need one, but
    if you're trying for a standard window it is generally a good idea.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的类命名为`WidgetBase`。这将是您派生任何其他小部件类的基类。这使您可以在此类中放置将在许多不同小部件中重复使用的功能。在这种情况下，我在那里放置了`CloseButton`的功能。并非所有小部件都需要一个，但是如果您想要一个标准窗口，通常是一个好主意。
- en: 'Here is the code for `WidgetBase.h`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`WidgetBase.h`的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sets up all the code that allows you to use a button to close the window.
    `CloseButton` will be the name of the button we create in the design Blueprint.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置允许您使用按钮关闭窗口的所有代码。`CloseButton`将是我们在设计蓝图中创建的按钮的名称。
- en: The line  `UPROPERTY(meta = (BindWidgetOptional))` should automatically link
    the `CloseWindow` variable to the `Button` object with the same name in the blueprint
    we will create in a little while. If you know the widget will always be there
    you can use `UPROPERTY(meta = (BindWidget))` instead, but in this case there may
    be cases where there is no button needed to close a window.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 行`UPROPERTY(meta = (BindWidgetOptional))`应自动将`CloseWindow`变量链接到稍后将在蓝图中创建的具有相同名称的`Button`对象。如果您知道小部件将始终存在，则可以改用`UPROPERTY(meta
    = (BindWidget))`，但在这种情况下，可能存在不需要关闭窗口的按钮的情况。
- en: 'And here is `WidgetBase.cpp`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`WidgetBase.cpp`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the UMG includes in this chapter don't work for you you might need to add
    `Runtime/` to the front of the path. But they should work like this (and do work
    in my project).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本章中包含的UMG对您不起作用，您可能需要在路径前面添加“Runtime/”。但它们应该像这样工作（并且在我的项目中确实工作）。
- en: 'The following line is what sets the `OnClicked` event to call a specific function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We no longer need to set up everything in the input settings like we did previously,
    since UMG buttons already are set up to handle `OnClicked`, and you just need
    to tell it what function to call. If for some reason that doesn't work, I'll show
    you how to work around it by setting up `OnClicked` in the blueprint later. Since
    `CloseButton` is optional, you do need to check it to make sure it's not set to
    `NULL` to avoid errors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The `isOpen` variable is there to handle the common UI issue where sometimes
    clicks (or key presses) register multiple times, causing the function to be called
    more than once, which could cause errors. By setting `isOpen` to true the first
    time you call the `OnClicked` function you are making sure it doesn't run it more
    than once, since it will only run if the value is false. Of course, you also need
    to make sure the value is reset if you reopen the window, which is where the `NativeConstruct()`
    function comes in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The InventoryWidget class
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you will want to create the specialized class for handling the inventory
    widget, derived from `WidgetBase`. If for some reason you can't find `WidgetBase`
    to create the class the usual way, uncheck Actors Only under Filters. Call this
    one `InventoryWidget`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created that class you can start adding the code. First, here''s
    `InventoryWidget.h`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This file is much more complicated. We are again using `BindWidget` to set up
    objects in the Blueprint. While you could lay out widgets in code like we did
    previously (but you should be able to create a subwidget including the image,
    text, and button), to keep things simpler I just laid out two on screen and referenced
    them separately. You can always add more yourself later for practice.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: So, in this particular case we have widgets set up for two images, two text
    blocks, and two buttons. There is an `Initialize` function to set those up, as
    well as functions to add a widget, hide all widgets, and mouse click handlers
    for each button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to write `InventoryWidget.cpp`. First, add the includes at the
    top of the file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then set up the `Initialize` function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function sets up the `OnClicked` functions for the buttons. Then add the
    functions to handle Widgets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`HideWidgets` hides all the Widgets in the window so they won''t show up at
    all if there is nothing there. `AddWidget` takes an index, a name, and a texture
    for the image itself, then sets up the Widgets for that index. The Text Widget
    has a `SetText` function that lets you pass in `FText` (`FText::FromString` converts
    it from `FString` to `FText`). The Image Widget has `SetBrushFromTexture` that
    sets the image.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will need to set up the `MouseClicked` functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These just call the HUD''s `MouseClicked` function with the button''s index
    (Hint: this won''t compile until those HUD functions are updated to take the index).
    If you want to experiment further, later you can look into another way to get
    the index based on the button that was clicked, so you can use the same function
    for all the buttons.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the widget blueprint
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, you will need to set up the blueprint. Since this is a special kind of
    blueprint, setting one up with its own class is a little trickier. You can't just
    create a blueprint of the class or you won't have a design blueprint. Instead,
    you have to create the design blueprint first, and then change the parent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go into the Content Browser and select the directory you want to
    put it in, and then select Add New | User Interface | Widget Blueprint:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21cb9202-5a8a-4914-b4d2-865824109afb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Rename it `BP_InventoryWidget` and then double-click to open it. You should
    see something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e677d439-c58d-4973-a2ef-31d64e6b4f4d.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: In the center you will visually lay out the screen, and the box represents the
    edges of the theoretical screen you are aiming for. On the left side the Palette
    shows you the basic UI objects you can add to the screen. You'll see many common
    objects such as images, text fields, progress bars, buttons, checkboxes, and sliders.
    That's a lot of functionality you basically get for free. Once you get to the
    point of setting up a settings window for your game many of those will come in
    handy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to change the parent class on this, which you will do here.
    Select Graph on the top-right corner and Class Settings on the top toolbar, then
    look under Details for Class Options and choose the dropdown by Parent Class.
    Select InventoryWidget there:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60f8599-1131-4736-8ba9-13aa326477a4.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Now we'll want to go back to Designer and start laying out the screen!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: There should already be a Canvas Panel on the screen. You can click on the bottom
    right corner and drag to make it the size you want. The canvas should usually
    be the size of the full screen. All other UI widgets will go inside the canvas.
    When you drag this, it will show the various resolutions on screen that you are
    aiming for. You will want to pick one similar to the resolution you are aiming
    for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Then select Border under the Palette and drag it out onto the screen. This
    will be the background of the window. You can click the corner and drag it to
    the size you want. You can also find the color bar on the right (next to Appearance
    > Brush Color under Details) and click on it to open a Color Picker to choose
    the color of the background:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ec86d68-7381-4e7b-8928-d64953fd59c6.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: You can also rename the object under Details. Once you have that, click and
    drag a Button onscreen and position it on the top-right corner of the background.
    If it tries to fill the entire Border object make sure you select Canvas Panel
    in the hierarchy or drag it outside the Border object and then drag it on top
    of it. Make sure you name this `CloseButton`. You can also put a text object with
    the letter X in it if you want to make it look more like a close button. You should
    uncheck Is Enabled under Behavior in the Details so it won't block mouse clicks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will want to position two image objects and two text objects (you
    can add more later). Make sure the names exactly match the names you used in the
    code or they won't work. In the Text fields, you will find it much easier to set
    a font. Under Details | Appearance you will find font options like you're used
    to in any word processor, and you can use fonts already on your computer (although,
    if you still want to download a font there is nothing stopping you). You can also
    use the font you added earlier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for `OnClicked`, you will want to add a button. You could just add one
    underneath, but I used a common UI method: the invisible button. Drag a button
    out and have it cover both the image and the text for one of them. Then go into
    the Background color and set the alpha (A) to `0`. Alpha is a measurement of how
    transparent a color is, and `0` means you won''t be able to see it at all.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If you later have trouble clicking the buttons other objects might be in the
    way. Try dragging them so they are behind the button or look into ways of disabling
    clicks on those objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, you should have something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c7d7aed-0bfc-4ded-88be-e5c08bb2d320.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Also, carefully note the options under Content on the right when you have Border
    selected. Here is where you can set Horizontal and Vertical alignment. Always
    try to set these, so if you want something to always be positioned in the top-left
    corner of the screen the alignment will be set to Horizontally Align Left and
    Vertically Align Top. If you don't set alignment for every object the results
    could be unpredictable in different screen resolutions. I'll get into that more
    later.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: But for now, this will be your inventory window. It doesn't have to look exactly
    like mine, so have fun and experiment with the visual layout! Although, remember
    that you probably don't want it to take up the entire screen so you can see the
    spell being cast after you click (although you can look into closing the window
    when you click on a spell later).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: AMyHUD changes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But that's not all! We still have to modify our existing classes to support
    this new Widget, starting with the `AMyHud` class. To make things simpler we won't
    be replicating all the previous functionality here. Instead, we will just be setting
    up the `OnClicked` function to cast spells, since that's going to be a lot more
    useful in game than dragging items around on the screen. Right-clicks aren't handled
    automatically by UMG but you can look into that more yourself if you want to add
    it later, and you can also look into the previous click and drag functionality,
    so you might want to comment out the older code instead of deleting it if you
    think you might want it later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the `MouseMoved` and `MouseRightClicked` functions are gone, and the
    `MouseClicked` function now takes an `int` index. We also have new functions for
    `OpenInventory` and `CloseInventory`, so `MyHUD.h` should have this now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also add #include "InventoryWidget.h" at the top of the file. Some of the other
    functions will also be modified. So, now we will look at `AMyHUD.cpp` and you
    will see just how much simpler the new versions of functions are. Here are the
    new functions for handling widgets:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to update the `MouseClicked` function to this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will cast the spell based on the index passed in. Then there are the new
    functions to open and close the inventory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main part is to add or remove the new Widget from the `Viewport`. We also
    want to hide the widgets visually to keep empty widgets from displaying, and to
    clear out all the widgets when the window is closed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed `struct Widget` to remove all the positioning information.
    Any reference to it should have been removed, but if you get any errors later
    (you won''t be able to compile until you make the changes to the Avatar class)
    make sure `MouseMoved` and `MouseRightClicked` are gone or commented out, and
    nothing else is referencing them. The newer, simpler widget should look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: AAvatar changes
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `AAvatar` we will primarily be modifying the `ToggleInventory` function.
    The newer function will look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, many of the same HUD functions were reused, but the new functions
    for `OpenInventory` and `CloseInventory` are now called from here, so the HUD
    can display the window before adding the widgets, and remove the window to close
    it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, delete the following lines from both the `Yaw` and `Pitch` functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also delete the following lines from `MouseRightClicked` (or delete the function,
    but if you do make sure you remove it from `SetupPlayerInputComponent` as well):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, remove these lines from `MouseClicked` (since you don''t want to accidentally
    trigger a spell when you click somewhere that''s not part of the inventory):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now you should be able to compile. Once you do that, go into BP_MyHUD and change
    the Class Defaults > Widgets > W Inventory dropdown to BP_InventoryWidget.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A note on OnClicked
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible your `OnClicked` functions might not work correctly (I ran into
    that problem myself). If you can't find a solution, you can bypass with with blueprints,
    which is why I made all the mouse click functions blueprint callable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'If this happens to you, go into the designer for your Widget blueprint and
    for each button click on it and find Events under Details and click the green
    + button next to On Clicked. This will add `OnClicked` for that button to the
    graph and switch to that. You will need to go back to add the other 2 buttons.
    Then, drag out from the node and add the function you want. It should look something
    like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168d8986-d61f-4867-82fa-656e1ce75423.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Laying out your UI
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're laying out a UI, there are important things to keep in mind, and
    UMG has tools to make this easier for you. One of the most important things to
    keep in mind is that your game won't always run in the same resolution. If you're
    doing a mobile game there could be many different devices with different resolutions,
    and you want your game to look essentially the same on all of them. Even consoles
    are no longer free from this problem, since both Xbox One and PS4 now have 4K
    options. So, your game needs to be set up in a way that makes this possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: If you make all your widgets a specific pixel size and then run it in a resolution
    much bigger, it could be so small it seems unreadable and buttons could be difficult
    to click on. In a smaller resolution it could be too big to fit on screen. So,
    keep this in mind.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas Panel you set up earlier will show you visually how it will look
    in the size you are aiming for. But for variations on the size you need to keep
    several things in mind.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, always use anchors. Under details you will see a dropdown list
    for Anchors. When you open it, you should see something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc965460-7745-4f64-b872-a92b8a533d53.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: The nine options on the top-left corner of the blue lines are to align objects.
    The rows align to the top, middle, and bottom of the screen, while the columns
    align to the left, middle, and right. So, if you have something you always want
    to appear at the top-left corner of the screen (like a score, or health bars)
    you will choose the option on the top-left corner. If you want something else
    to be centered both horizontally and vertically choose the second row, second
    column. The little white square basically shows you the positioning.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The remaining options give you ways to have something stretch across the entire
    screen (no matter what size it is). So, if you want something stretched horizontally
    on the top, middle, or bottom, look at the right column. For vertical, look at
    the bottom row. And the one in the bottom-right corner is great if you want a
    window to stretch across the entire screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: You can also add a Scale Box from the palette if you want everything inside
    it to scale to fit the screen size. Although if you have something you want to
    remain a fixed size, like an image, you can check Size to Content to prevent it
    from automatically resizing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get more advanced, you can add code to check the screen size
    and swap out parts of, or the entire, UI, but that's out of the scope of this
    book, so just keep it in mind if you want to try it later on your own!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important things to keep in mind with your UI is localization. If you
    want to release your game anywhere outside your own country you will need to localize.
    This means you will have to get used to not just hardcoding text but use the built-in
    localization system to add string ids you''ve set up instead of hardcoding the
    text. The code will look for specific ids and swap them for the appropriate localized
    text. You can look into the built-in localization system here: [https://docs.unrealengine.com/en-us/Gameplay/Localization](https://docs.unrealengine.com/en-us/Gameplay/Localization).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: This will also affect how you lay out your UI. The first time you localize your
    game in German, you'll find out that everything is twice as long! While you may
    be able to get your translators to come up with shorter ways to say the same thing,
    you will probably want to make text blocks longer than you think they need to
    be, or consider finding ways to make the text shrink to fit or scroll.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Updating your HUD and adding health bars
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't be giving full instructions here, but here are some hints on updating
    your HUD. Once you do this, it will simplify your code even more!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Creating a HUD class
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to create a new class deriving from WidgetBase for your new HUD.
    In this case, you will need the Canvas Panel but no background. Make sure everything
    will stretch across the entire screen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个从WidgetBase派生的新类，用于您的新HUD。在这种情况下，您将需要Canvas Panel，但不需要背景。确保所有内容都会延伸到整个屏幕。
- en: You will want to keep most of your UI in the corners, so you can add a Progress
    Bar widget to the top-left corner of the screen to display health. Also, consider
    adding a Text widget to tell what it is and/or put the actual numbers onscreen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望将大部分UI放在角落里，因此您可以在屏幕的左上角添加一个进度条小部件来显示健康。此外，考虑添加一个文本小部件来告诉它是什么，和/或在屏幕上显示实际数字。
- en: For the messages, you can align Text widget to the top-middle of the screen
    and use those to display the text.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息，您可以将文本小部件对齐到屏幕的顶部中间，并使用它们来显示文本。
- en: Adding health bars
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康条
- en: If you've added the recommended Progress Bar widget, you'll find drawing health
    bars to be a lot easier now. You will need to get a reference to it just like
    you did with the other widgets. Then, all you need to do is call `SetPercent`
    to show the current health (and reset it whenever it changes).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已添加了推荐的进度条小部件，您会发现绘制健康条现在更容易了。您需要像其他小部件一样获取对它的引用。然后，您所需要做的就是调用“SetPercent”来显示当前的健康值（并在健康值改变时重置它）。
- en: You no longer have to draw the whole thing yourself, but you can use `SetFillColorAndOpacity`
    to customize how it looks!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您不再需要自己绘制整个东西，但是您可以使用“SetFillColorAndOpacity”来自定义外观！
- en: Playing audio
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频
- en: 'We''re going to go back to your code to do one last thing that really helps
    your game''s feedback, yet it somehow tends to be one of the last things anyone
    thinks about when creating a game: audio.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到您的代码，做最后一件真正有助于您的游戏反馈的事情，但是在创建游戏时，这似乎总是最后一个人会考虑到的事情：音频。
- en: Audio can really enhance your game, from playing a sound when you click a button
    to adding sound effects, dialog, background music, and ambience. If you're walking
    alone in the woods at night, the sounds of crickets chirping, your own footsteps,
    and ominous music can really set the mood. Or, you can have bird sounds and happy
    music for a completely different mood. It's all up to you!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以真正增强您的游戏，从在单击按钮时播放声音到添加音效、对话、背景音乐和环境音效。如果您在夜晚独自在树林中行走，蟋蟀的鸣叫声、您自己的脚步声和不祥的音乐可以真正营造氛围。或者，您可以播放鸟鸣和愉快的音乐，营造完全不同的氛围。这都取决于您！
- en: We're just going to add a sound when you cast your blizzard spell. So look for
    a free wind sound. There are plenty of sites that offer royalty-free sound files.
    Some of them want you to mention them in your credits if you use them. For this,
    I found a public domain sound on a site called [SoundBible.com](http://www.soundbible.com),
    which means anyone can use it. But look for one you like.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在你施放暴风雪咒语时添加一个声音。因此，请寻找一个免费的风声。有很多网站提供免版税的声音文件。其中一些要求您在使用它们时在您的制作人员名单中提到他们。对于这个，我在一个名为[SoundBible.com](http://www.soundbible.com)的网站上找到了一个公共领域的声音，这意味着任何人都可以使用它。但是请寻找您喜欢的声音。
- en: Some sites might make you register to download the sounds. You can even record
    one yourself if you're feeling ambitious!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有些网站可能会要求您注册以下载声音。如果您感到有雄心壮志，甚至可以自己录制一个！
- en: I used a .wav file, a standard format, although other formats will probably
    work. But for small sounds, you may want to stick to .wav because MP3s use compression,
    which might slow down your game slightly because it needs to de-compress it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了.wav文件，这是一种标准格式，尽管其他格式可能也有效。但是对于小声音，您可能希望坚持使用.wav，因为MP3使用了压缩，这可能会稍微减慢游戏速度，因为它需要对其进行解压缩。
- en: 'Once you have a file you like, create a folder for Sounds and drag your sound
    file into it from your file manager. Then right-click in the same folder and select
    Sounds | Sound Cue:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您找到喜欢的文件，请为声音创建一个文件夹，并从文件管理器将声音文件拖入其中。然后在同一文件夹中右键单击并选择Sounds | Sound Cue：
- en: '![](img/2b52b6f2-364a-4485-8585-a519d7ae5a5e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b52b6f2-364a-4485-8585-a519d7ae5a5e.png)'
- en: 'Rename that to WindCue and double-click on it to open it in the Blueprint editor.
    It should look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将其重命名为WindCue，然后双击它以在蓝图编辑器中打开它。它应该看起来像这样：
- en: '![](img/131d3ae3-3a8b-4994-a0da-109a867a4541.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/131d3ae3-3a8b-4994-a0da-109a867a4541.png)'
- en: 'The SoundCue is where we will set up our sound. First, right-click anywhere
    and select Wave Player to add one:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 声音提示是我们设置声音的地方。首先，右键单击任何位置，然后选择Wave Player添加一个：
- en: '![](img/500545b1-f0ba-4555-8f2f-fdea977a5965.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/500545b1-f0ba-4555-8f2f-fdea977a5965.png)'
- en: 'Then, select the Wave Player. In the details, you will see an option for Sound
    Wave. Select the dropdown list and search for the `.wav` file you added to select
    it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择Wave Player。在详细信息中，您将看到一个名为Sound Wave的选项。选择下拉列表并搜索您添加的.wav文件以选择它：
- en: '![](img/279db068-abc1-4cde-8025-315c2bb495c0.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/279db068-abc1-4cde-8025-315c2bb495c0.png)'
- en: 'Then, click and drag from the output of your Wave Player into the Output (with
    the small speaker image). This will hook it up. To test it, you can select Play
    Cue and you should hear it and see the line light up orange as the sound is transferred
    to the Output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从Wave Player的输出处拖动并放入输出（带有小扬声器图像）。这将连接它。要测试它，您可以选择播放提示，然后您应该听到声音，并且看到线条变成橙色，表示声音被传输到输出：
- en: '![](img/9be39afa-c610-4f29-aa53-d6ea16ec7fc1.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9be39afa-c610-4f29-aa53-d6ea16ec7fc1.png)'
- en: If you don't like the way it sounds, experiment with the options under details.
    The one I used was too quiet for what I wanted, so I increased the Volume Multiplier
    to make it much louder.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢声音的方式，请尝试详细信息下的选项。我使用的声音对我想要的效果太安静了，所以我增加了音量倍增器使其响亮得多。
- en: 'Now that we have the sound set up, it''s time to add it to the code. In this
    case, we''ll be updating the `AMyHUD` class. First, add the following line to
    the top of `MyHUD.h`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好声音，是时候将其添加到代码中了。在这种情况下，我们将更新“AMyHUD”类。首先，在“MyHUD.h”的顶部添加以下行：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also, add the following in the same file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一文件中添加以下内容：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will want to store the `SoundCue` reference in the blueprint to make it
    easy to update.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望将“SoundCue”引用存储在蓝图中以便于更新。
- en: 'Now, go to `MyHUD.cpp` and add the following line to your `MouseClicked` function
    right after the call to `CastSpell`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`MyHUD.cpp`并在`MouseClicked`函数中的`CastSpell`调用之后添加以下行：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will actually play the sound. Make sure you have `#include "Kismet/GameplayStatics.h"`
    in that file for it to work. For this case, since it is right by the player whenever
    you cast it, a 2D sound will be fine. If you want things in your environment (like
    the monsters) to make their own sounds, you will want to look into 3D sounds.
    UE4 will let you do that!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将实际播放声音。确保在该文件中包含`#include "Kismet/GameplayStatics.h"`才能正常工作。对于这种情况，因为它在玩家附近每当您施放它时，2D声音就可以了。如果您希望环境中的事物（如怪物）发出自己的声音，您将需要研究3D声音。UE4将让您做到这一点！
- en: Now, go back into the editor and compile everything, then go back into the HUD
    blueprint. You will need to add the `SoundCue` you created to the blueprint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，返回编辑器并编译所有内容，然后返回HUD蓝图。您需要将创建的`SoundCue`添加到蓝图中。
- en: 'You can select it from the dropdown list and search for it like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从下拉列表中选择它，并像这样搜索它：
- en: '![](img/0e38e675-aeb7-418a-b880-9cc392463579.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e38e675-aeb7-418a-b880-9cc392463579.png)'
- en: Now, save and compile and run the game. Run around until you pick up a Blizzard
    spell and hit *I* to open the inventory. Click on the Blizzard spell. You should
    not only see the spell cast, but you should hear it too!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存、编译并运行游戏。四处奔跑，直到您捡起了一个暴风雪咒语并按*I*打开库存。点击暴风雪咒语。您不仅应该看到咒语施放，还应该听到它！
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You've now gotten a good look at how User Interfaces are created with UMG, and
    how audio can be added to enhance your experience even further! There is still
    a lot of work to do, but consider that practice!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经深入了解了如何使用UMG创建用户界面，以及如何添加音频以进一步增强您的体验！还有很多工作要做，但请考虑练习！
- en: We're done with the code for this, but not with the book. Next, we'll be looking
    at how to take what we have and view it in virtual reality! I'll give you a few
    hints on that, and then we'll finish things off with an overview of some other
    advanced features in UE4.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这部分的代码，但书还没有完成。接下来，我们将看看如何将我们所拥有的内容在虚拟现实中查看！我会给你一些建议，然后我们将以UE4中的一些其他高级功能概述结束。
