- en: Improving UI Feedback with UMG and Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User feedback is very important in games, because the user needs information
    about what is going on in the game (score, hp, displaying inventory, and so on).
    In previous chapters, we've created a very simple HUD to display text and items
    in your inventory, but if you want a game that looks professional you'll want
    to have a much nicer **User Interface** (**UI**) than that!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are easier ways of building a UI now with Unreal Motion Graphics
    UI Designer (UMG), a system included with UE4, just for this purpose. This chapter
    will show you how to use it to take what we've done before and make something
    that looks much better and has more functionality. We'll start updating the inventory
    window, and I will make suggestions on how you can continue the process and update
    the rest of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Another way of providing feedback is through audio, either in the game itself
    or through the UI when you interact with it, so we will also be introducing how
    to play sounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we''ll be covering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is UMG?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the inventory window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying out your UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating your HUD and adding health bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is UMG?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that the code we've used to draw on the screen has been
    very complicated. Every element needs to be placed onscreen manually. You might
    ask yourself if there's an easier way. And there is! It's the Unreal Motion Graphics
    UI Designer, or UMG.
  prefs: []
  type: TYPE_NORMAL
- en: UMG simplifies the process of creating a UI by using special blueprints to allow
    you to lay out the interface visually. This can also let you have a tech-savvy
    artist do the layout for you, while you hook everything up. We will be using this,
    but since this is a C++ book we will be handling most of the behind the scenes
    functionality in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use UMG, first you need for find the `GoldenEgg.Build.cs` file
    in your Visual Studio project. `.cs` files are generally C#, not C++, but you
    don''t have to worry about that since we''ll only be making minor changes to this
    file. Find this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following to that list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may want to restart the engine once you do that. Then you'll be ready to
    code in UMG!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the inventory window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to start by updating the inventory window. What we have right now
    isn't a real window, just images and text drawn on the screen, but now you'll
    see how you can easily create something that looks more like a real window—with
    a background and a Close button, and the code will be much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The WidgetBase class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a C++ class for a UMG Widget, you need to create a new class based
    on `UserWidget`. To find it when adding a new C++ class, you need to check Show
    All Classes and search for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf64bda7-1e63-4817-b4d7-48e14dd54e41.png)'
  prefs: []
  type: TYPE_IMG
- en: Name your class `WidgetBase`. This will be the base class from which you will
    derive any other Widget classes you create. This allows you to put functionality
    in this class that will be reused in many different Widgets. In this case, I put
    the functionality for `CloseButton` in there. Not all Widgets will need one, but
    if you're trying for a standard window it is generally a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `WidgetBase.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This sets up all the code that allows you to use a button to close the window.
    `CloseButton` will be the name of the button we create in the design Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: The line  `UPROPERTY(meta = (BindWidgetOptional))` should automatically link
    the `CloseWindow` variable to the `Button` object with the same name in the blueprint
    we will create in a little while. If you know the widget will always be there
    you can use `UPROPERTY(meta = (BindWidget))` instead, but in this case there may
    be cases where there is no button needed to close a window.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is `WidgetBase.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the UMG includes in this chapter don't work for you you might need to add
    `Runtime/` to the front of the path. But they should work like this (and do work
    in my project).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line is what sets the `OnClicked` event to call a specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to set up everything in the input settings like we did previously,
    since UMG buttons already are set up to handle `OnClicked`, and you just need
    to tell it what function to call. If for some reason that doesn't work, I'll show
    you how to work around it by setting up `OnClicked` in the blueprint later. Since
    `CloseButton` is optional, you do need to check it to make sure it's not set to
    `NULL` to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `isOpen` variable is there to handle the common UI issue where sometimes
    clicks (or key presses) register multiple times, causing the function to be called
    more than once, which could cause errors. By setting `isOpen` to true the first
    time you call the `OnClicked` function you are making sure it doesn't run it more
    than once, since it will only run if the value is false. Of course, you also need
    to make sure the value is reset if you reopen the window, which is where the `NativeConstruct()`
    function comes in.
  prefs: []
  type: TYPE_NORMAL
- en: The InventoryWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you will want to create the specialized class for handling the inventory
    widget, derived from `WidgetBase`. If for some reason you can't find `WidgetBase`
    to create the class the usual way, uncheck Actors Only under Filters. Call this
    one `InventoryWidget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created that class you can start adding the code. First, here''s
    `InventoryWidget.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This file is much more complicated. We are again using `BindWidget` to set up
    objects in the Blueprint. While you could lay out widgets in code like we did
    previously (but you should be able to create a subwidget including the image,
    text, and button), to keep things simpler I just laid out two on screen and referenced
    them separately. You can always add more yourself later for practice.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this particular case we have widgets set up for two images, two text
    blocks, and two buttons. There is an `Initialize` function to set those up, as
    well as functions to add a widget, hide all widgets, and mouse click handlers
    for each button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to write `InventoryWidget.cpp`. First, add the includes at the
    top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then set up the `Initialize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sets up the `OnClicked` functions for the buttons. Then add the
    functions to handle Widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`HideWidgets` hides all the Widgets in the window so they won''t show up at
    all if there is nothing there. `AddWidget` takes an index, a name, and a texture
    for the image itself, then sets up the Widgets for that index. The Text Widget
    has a `SetText` function that lets you pass in `FText` (`FText::FromString` converts
    it from `FString` to `FText`). The Image Widget has `SetBrushFromTexture` that
    sets the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will need to set up the `MouseClicked` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These just call the HUD''s `MouseClicked` function with the button''s index
    (Hint: this won''t compile until those HUD functions are updated to take the index).
    If you want to experiment further, later you can look into another way to get
    the index based on the button that was clicked, so you can use the same function
    for all the buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the widget blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, you will need to set up the blueprint. Since this is a special kind of
    blueprint, setting one up with its own class is a little trickier. You can't just
    create a blueprint of the class or you won't have a design blueprint. Instead,
    you have to create the design blueprint first, and then change the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go into the Content Browser and select the directory you want to
    put it in, and then select Add New | User Interface | Widget Blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21cb9202-5a8a-4914-b4d2-865824109afb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rename it `BP_InventoryWidget` and then double-click to open it. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e677d439-c58d-4973-a2ef-31d64e6b4f4d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the center you will visually lay out the screen, and the box represents the
    edges of the theoretical screen you are aiming for. On the left side the Palette
    shows you the basic UI objects you can add to the screen. You'll see many common
    objects such as images, text fields, progress bars, buttons, checkboxes, and sliders.
    That's a lot of functionality you basically get for free. Once you get to the
    point of setting up a settings window for your game many of those will come in
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to change the parent class on this, which you will do here.
    Select Graph on the top-right corner and Class Settings on the top toolbar, then
    look under Details for Class Options and choose the dropdown by Parent Class.
    Select InventoryWidget there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60f8599-1131-4736-8ba9-13aa326477a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we'll want to go back to Designer and start laying out the screen!
  prefs: []
  type: TYPE_NORMAL
- en: There should already be a Canvas Panel on the screen. You can click on the bottom
    right corner and drag to make it the size you want. The canvas should usually
    be the size of the full screen. All other UI widgets will go inside the canvas.
    When you drag this, it will show the various resolutions on screen that you are
    aiming for. You will want to pick one similar to the resolution you are aiming
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then select Border under the Palette and drag it out onto the screen. This
    will be the background of the window. You can click the corner and drag it to
    the size you want. You can also find the color bar on the right (next to Appearance
    > Brush Color under Details) and click on it to open a Color Picker to choose
    the color of the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ec86d68-7381-4e7b-8928-d64953fd59c6.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also rename the object under Details. Once you have that, click and
    drag a Button onscreen and position it on the top-right corner of the background.
    If it tries to fill the entire Border object make sure you select Canvas Panel
    in the hierarchy or drag it outside the Border object and then drag it on top
    of it. Make sure you name this `CloseButton`. You can also put a text object with
    the letter X in it if you want to make it look more like a close button. You should
    uncheck Is Enabled under Behavior in the Details so it won't block mouse clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will want to position two image objects and two text objects (you
    can add more later). Make sure the names exactly match the names you used in the
    code or they won't work. In the Text fields, you will find it much easier to set
    a font. Under Details | Appearance you will find font options like you're used
    to in any word processor, and you can use fonts already on your computer (although,
    if you still want to download a font there is nothing stopping you). You can also
    use the font you added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for `OnClicked`, you will want to add a button. You could just add one
    underneath, but I used a common UI method: the invisible button. Drag a button
    out and have it cover both the image and the text for one of them. Then go into
    the Background color and set the alpha (A) to `0`. Alpha is a measurement of how
    transparent a color is, and `0` means you won''t be able to see it at all.'
  prefs: []
  type: TYPE_NORMAL
- en: If you later have trouble clicking the buttons other objects might be in the
    way. Try dragging them so they are behind the button or look into ways of disabling
    clicks on those objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, you should have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c7d7aed-0bfc-4ded-88be-e5c08bb2d320.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, carefully note the options under Content on the right when you have Border
    selected. Here is where you can set Horizontal and Vertical alignment. Always
    try to set these, so if you want something to always be positioned in the top-left
    corner of the screen the alignment will be set to Horizontally Align Left and
    Vertically Align Top. If you don't set alignment for every object the results
    could be unpredictable in different screen resolutions. I'll get into that more
    later.
  prefs: []
  type: TYPE_NORMAL
- en: But for now, this will be your inventory window. It doesn't have to look exactly
    like mine, so have fun and experiment with the visual layout! Although, remember
    that you probably don't want it to take up the entire screen so you can see the
    spell being cast after you click (although you can look into closing the window
    when you click on a spell later).
  prefs: []
  type: TYPE_NORMAL
- en: AMyHUD changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But that's not all! We still have to modify our existing classes to support
    this new Widget, starting with the `AMyHud` class. To make things simpler we won't
    be replicating all the previous functionality here. Instead, we will just be setting
    up the `OnClicked` function to cast spells, since that's going to be a lot more
    useful in game than dragging items around on the screen. Right-clicks aren't handled
    automatically by UMG but you can look into that more yourself if you want to add
    it later, and you can also look into the previous click and drag functionality,
    so you might want to comment out the older code instead of deleting it if you
    think you might want it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the `MouseMoved` and `MouseRightClicked` functions are gone, and the
    `MouseClicked` function now takes an `int` index. We also have new functions for
    `OpenInventory` and `CloseInventory`, so `MyHUD.h` should have this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add #include "InventoryWidget.h" at the top of the file. Some of the other
    functions will also be modified. So, now we will look at `AMyHUD.cpp` and you
    will see just how much simpler the new versions of functions are. Here are the
    new functions for handling widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update the `MouseClicked` function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cast the spell based on the index passed in. Then there are the new
    functions to open and close the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The main part is to add or remove the new Widget from the `Viewport`. We also
    want to hide the widgets visually to keep empty widgets from displaying, and to
    clear out all the widgets when the window is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also changed `struct Widget` to remove all the positioning information.
    Any reference to it should have been removed, but if you get any errors later
    (you won''t be able to compile until you make the changes to the Avatar class)
    make sure `MouseMoved` and `MouseRightClicked` are gone or commented out, and
    nothing else is referencing them. The newer, simpler widget should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: AAvatar changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `AAvatar` we will primarily be modifying the `ToggleInventory` function.
    The newer function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, many of the same HUD functions were reused, but the new functions
    for `OpenInventory` and `CloseInventory` are now called from here, so the HUD
    can display the window before adding the widgets, and remove the window to close
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, delete the following lines from both the `Yaw` and `Pitch` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also delete the following lines from `MouseRightClicked` (or delete the function,
    but if you do make sure you remove it from `SetupPlayerInputComponent` as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, remove these lines from `MouseClicked` (since you don''t want to accidentally
    trigger a spell when you click somewhere that''s not part of the inventory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now you should be able to compile. Once you do that, go into BP_MyHUD and change
    the Class Defaults > Widgets > W Inventory dropdown to BP_InventoryWidget.
  prefs: []
  type: TYPE_NORMAL
- en: A note on OnClicked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible your `OnClicked` functions might not work correctly (I ran into
    that problem myself). If you can't find a solution, you can bypass with with blueprints,
    which is why I made all the mouse click functions blueprint callable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this happens to you, go into the designer for your Widget blueprint and
    for each button click on it and find Events under Details and click the green
    + button next to On Clicked. This will add `OnClicked` for that button to the
    graph and switch to that. You will need to go back to add the other 2 buttons.
    Then, drag out from the node and add the function you want. It should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168d8986-d61f-4867-82fa-656e1ce75423.png)'
  prefs: []
  type: TYPE_IMG
- en: Laying out your UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you're laying out a UI, there are important things to keep in mind, and
    UMG has tools to make this easier for you. One of the most important things to
    keep in mind is that your game won't always run in the same resolution. If you're
    doing a mobile game there could be many different devices with different resolutions,
    and you want your game to look essentially the same on all of them. Even consoles
    are no longer free from this problem, since both Xbox One and PS4 now have 4K
    options. So, your game needs to be set up in a way that makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: If you make all your widgets a specific pixel size and then run it in a resolution
    much bigger, it could be so small it seems unreadable and buttons could be difficult
    to click on. In a smaller resolution it could be too big to fit on screen. So,
    keep this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas Panel you set up earlier will show you visually how it will look
    in the size you are aiming for. But for variations on the size you need to keep
    several things in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, always use anchors. Under details you will see a dropdown list
    for Anchors. When you open it, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc965460-7745-4f64-b872-a92b8a533d53.png)'
  prefs: []
  type: TYPE_IMG
- en: The nine options on the top-left corner of the blue lines are to align objects.
    The rows align to the top, middle, and bottom of the screen, while the columns
    align to the left, middle, and right. So, if you have something you always want
    to appear at the top-left corner of the screen (like a score, or health bars)
    you will choose the option on the top-left corner. If you want something else
    to be centered both horizontally and vertically choose the second row, second
    column. The little white square basically shows you the positioning.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining options give you ways to have something stretch across the entire
    screen (no matter what size it is). So, if you want something stretched horizontally
    on the top, middle, or bottom, look at the right column. For vertical, look at
    the bottom row. And the one in the bottom-right corner is great if you want a
    window to stretch across the entire screen.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add a Scale Box from the palette if you want everything inside
    it to scale to fit the screen size. Although if you have something you want to
    remain a fixed size, like an image, you can check Size to Content to prevent it
    from automatically resizing.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get more advanced, you can add code to check the screen size
    and swap out parts of, or the entire, UI, but that's out of the scope of this
    book, so just keep it in mind if you want to try it later on your own!
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important things to keep in mind with your UI is localization. If you
    want to release your game anywhere outside your own country you will need to localize.
    This means you will have to get used to not just hardcoding text but use the built-in
    localization system to add string ids you''ve set up instead of hardcoding the
    text. The code will look for specific ids and swap them for the appropriate localized
    text. You can look into the built-in localization system here: [https://docs.unrealengine.com/en-us/Gameplay/Localization](https://docs.unrealengine.com/en-us/Gameplay/Localization).'
  prefs: []
  type: TYPE_NORMAL
- en: This will also affect how you lay out your UI. The first time you localize your
    game in German, you'll find out that everything is twice as long! While you may
    be able to get your translators to come up with shorter ways to say the same thing,
    you will probably want to make text blocks longer than you think they need to
    be, or consider finding ways to make the text shrink to fit or scroll.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your HUD and adding health bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't be giving full instructions here, but here are some hints on updating
    your HUD. Once you do this, it will simplify your code even more!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a HUD class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to create a new class deriving from WidgetBase for your new HUD.
    In this case, you will need the Canvas Panel but no background. Make sure everything
    will stretch across the entire screen.
  prefs: []
  type: TYPE_NORMAL
- en: You will want to keep most of your UI in the corners, so you can add a Progress
    Bar widget to the top-left corner of the screen to display health. Also, consider
    adding a Text widget to tell what it is and/or put the actual numbers onscreen.
  prefs: []
  type: TYPE_NORMAL
- en: For the messages, you can align Text widget to the top-middle of the screen
    and use those to display the text.
  prefs: []
  type: TYPE_NORMAL
- en: Adding health bars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've added the recommended Progress Bar widget, you'll find drawing health
    bars to be a lot easier now. You will need to get a reference to it just like
    you did with the other widgets. Then, all you need to do is call `SetPercent`
    to show the current health (and reset it whenever it changes).
  prefs: []
  type: TYPE_NORMAL
- en: You no longer have to draw the whole thing yourself, but you can use `SetFillColorAndOpacity`
    to customize how it looks!
  prefs: []
  type: TYPE_NORMAL
- en: Playing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to go back to your code to do one last thing that really helps
    your game''s feedback, yet it somehow tends to be one of the last things anyone
    thinks about when creating a game: audio.'
  prefs: []
  type: TYPE_NORMAL
- en: Audio can really enhance your game, from playing a sound when you click a button
    to adding sound effects, dialog, background music, and ambience. If you're walking
    alone in the woods at night, the sounds of crickets chirping, your own footsteps,
    and ominous music can really set the mood. Or, you can have bird sounds and happy
    music for a completely different mood. It's all up to you!
  prefs: []
  type: TYPE_NORMAL
- en: We're just going to add a sound when you cast your blizzard spell. So look for
    a free wind sound. There are plenty of sites that offer royalty-free sound files.
    Some of them want you to mention them in your credits if you use them. For this,
    I found a public domain sound on a site called [SoundBible.com](http://www.soundbible.com),
    which means anyone can use it. But look for one you like.
  prefs: []
  type: TYPE_NORMAL
- en: Some sites might make you register to download the sounds. You can even record
    one yourself if you're feeling ambitious!
  prefs: []
  type: TYPE_NORMAL
- en: I used a .wav file, a standard format, although other formats will probably
    work. But for small sounds, you may want to stick to .wav because MP3s use compression,
    which might slow down your game slightly because it needs to de-compress it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a file you like, create a folder for Sounds and drag your sound
    file into it from your file manager. Then right-click in the same folder and select
    Sounds | Sound Cue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b52b6f2-364a-4485-8585-a519d7ae5a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rename that to WindCue and double-click on it to open it in the Blueprint editor.
    It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/131d3ae3-3a8b-4994-a0da-109a867a4541.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The SoundCue is where we will set up our sound. First, right-click anywhere
    and select Wave Player to add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/500545b1-f0ba-4555-8f2f-fdea977a5965.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, select the Wave Player. In the details, you will see an option for Sound
    Wave. Select the dropdown list and search for the `.wav` file you added to select
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/279db068-abc1-4cde-8025-315c2bb495c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click and drag from the output of your Wave Player into the Output (with
    the small speaker image). This will hook it up. To test it, you can select Play
    Cue and you should hear it and see the line light up orange as the sound is transferred
    to the Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9be39afa-c610-4f29-aa53-d6ea16ec7fc1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you don't like the way it sounds, experiment with the options under details.
    The one I used was too quiet for what I wanted, so I increased the Volume Multiplier
    to make it much louder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the sound set up, it''s time to add it to the code. In this
    case, we''ll be updating the `AMyHUD` class. First, add the following line to
    the top of `MyHUD.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following in the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will want to store the `SoundCue` reference in the blueprint to make it
    easy to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to `MyHUD.cpp` and add the following line to your `MouseClicked` function
    right after the call to `CastSpell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will actually play the sound. Make sure you have `#include "Kismet/GameplayStatics.h"`
    in that file for it to work. For this case, since it is right by the player whenever
    you cast it, a 2D sound will be fine. If you want things in your environment (like
    the monsters) to make their own sounds, you will want to look into 3D sounds.
    UE4 will let you do that!
  prefs: []
  type: TYPE_NORMAL
- en: Now, go back into the editor and compile everything, then go back into the HUD
    blueprint. You will need to add the `SoundCue` you created to the blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can select it from the dropdown list and search for it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e38e675-aeb7-418a-b880-9cc392463579.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, save and compile and run the game. Run around until you pick up a Blizzard
    spell and hit *I* to open the inventory. Click on the Blizzard spell. You should
    not only see the spell cast, but you should hear it too!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've now gotten a good look at how User Interfaces are created with UMG, and
    how audio can be added to enhance your experience even further! There is still
    a lot of work to do, but consider that practice!
  prefs: []
  type: TYPE_NORMAL
- en: We're done with the code for this, but not with the book. Next, we'll be looking
    at how to take what we have and view it in virtual reality! I'll give you a few
    hints on that, and then we'll finish things off with an overview of some other
    advanced features in UE4.
  prefs: []
  type: TYPE_NORMAL
