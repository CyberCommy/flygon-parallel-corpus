- en: Memory Management and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the G1 garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unified logging for JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `jcmd` command for JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try-with-resources for better resource handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the memory-aware coding style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for better memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand Epsilon, a low-overhead garbage collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management is the process of memory allocation for program execution
    and memory reuse after some of the allocated memory is not used anymore. In Java,
    this process is called **garbage collection** (**GC**). The effectiveness of GC
    affects two major application characteristics—responsiveness and throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness is measured by how quickly an application responds to the request.
    For example, how quickly a website returns a page or how quickly a desktop application
    responds to an event. Naturally, the lower the response time, the better the user
    experience, which is the goal for many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughput indicates the amount of work an application can do in a unit of time.
    For example, how many requests a web application can serve or how many transactions
    a database can support. The bigger the number, the more value the application
    can potentially generate and the greater number of users it can accommodate.
  prefs: []
  type: TYPE_NORMAL
- en: Not every application needs to have the minimal possible responsiveness and
    the maximum achievable throughput. An application may be an asynchronous submit-and-go-do-something-else,
    which does not require much user interaction. There may be a few potential application
    users too, so a lower-than-average throughput could be more than enough. Yet,
    there are applications that have high requirements to one or both of these characteristics
    and cannot tolerate long pauses imposed by the GC process.
  prefs: []
  type: TYPE_NORMAL
- en: GC, on the other hand, needs to stop any application execution once in a while
    to reassess the memory usage and to release it from data no longer used. Such
    periods of GC activity are called stop-the-world. The longer they are, the quicker
    the GC does its job and the longer an application freeze lasts, which can eventually
    grow big enough to affect both the application responsiveness and throughput.
    If that is the case, the GC tuning and JVM optimization become important and require
    an understanding of the GC principles and their modern implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this step is often missed by programmers. Trying to improve responsiveness
    and/or throughput, they just add memory and other computing capacities, thereby
    providing the originally-small existing problem with the space to grow. The enlarged
    infrastructure, in addition to hardware and software costs, requires more people
    to maintain it and eventually justifies the building of a whole new organization
    dedicated to keeping up the system. By then, the problem reaches the scale of
    becoming virtually unsolvable and feeds on those who have created it by forcing
    them to do the routine—almost menial—work for the rest of their professional lives.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the **Garbage-First** (**G1**) garbage collector,
    which is the default one since Java 9\. However, we'll also refer to a few other
    available GC implementations to contrast and explain some design decisions that
    have brought G1 to life. Besides, they might be more appropriate than G1 for some
    of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Memory organization and management are very specialized and complex areas of
    expertise in JVM development. This book is not intended to address the implementation
    details on such a level. Our focus is on those aspects of GC that can help an
    application developer to tune it for the application needs by setting the corresponding
    parameters of JVM runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There are two memory areas that are used by GC—heap and stack. The first one
    is used by JVM to allocate memory and store objects created by the program. When
    an object is created with the `new` keyword, it is located in the heap, and the
    reference to it is stored in the stack. The stack also stores primitive variables
    and references to heap objects that are used by the current method or thread.
    The stack operates in **Last-In-First-Out** (**LIFO**). The stack is much smaller
    than the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The slightly simplistic, but good enough for our purpose, high-level view of
    the main activity of any GC is the following—walking through objects in the heap
    and removing those that don’t have any references in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the G1 garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous GC implementations include the **Serial GC**, **Parallel GC**,
    and **Concurrent Mark-Sweep** (**CMS**) collector. They divide the heap into three
    sections—young generation, old or tenured generation, and humongous regions for
    holding the objects that are 50% of the size of a standard region or larger. The
    young generation contains most of the newly created objects; this is the most
    dynamic area because a majority of the objects are short-lived and soon (as they
    age) become eligible for collection. The term age refers to the number of collection
    cycles the object has survived. The young generation has three collection cycles—
    an *Eden space* and two survivor spaces, such as survivor 0 (*S0*) and survivor
    1 (*S1*). The objects are moved through them (according to their age and some
    other characteristics) until they are eventually discarded or placed in the old
    generation.
  prefs: []
  type: TYPE_NORMAL
- en: The old generation contains objects that are older than a certain age. This
    area is bigger than the young generation, and because of this, the garbage collection
    here is more expensive and happens not as often as in the young generation.
  prefs: []
  type: TYPE_NORMAL
- en: The permanent generation contains metadata that describes the classes and methods
    used in applications. It also stores strings, library classes, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: When JVM starts, the heap is empty and then the objects are pushed into Eden.
    When it is filling up, a minor GC process starts. It removes the unreferenced
    and circular referred objects and moves the others to the *S0* area.
  prefs: []
  type: TYPE_NORMAL
- en: The next minor GC process migrates the referenced objects to *S1* and increments
    the age of those that survived the previous minor collection. After all the surviving
    objects (of different ages) are moved to *S1*, both *S0* and Eden become empty.
  prefs: []
  type: TYPE_NORMAL
- en: In the next minor collection, *S0* and *S1* switch their roles. The referenced
    objects are moved from Eden to *S1* and from *S1* to *S0*.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the minor collections, the objects that have reached a certain age
    are moved to the old generation. As we mentioned earlier, the old generation is
    checked eventually (after several minor collections), the unreferenced objects
    are removed from there, and the memory is defragmented. This cleaning of the old
    generation is considered a major collection.
  prefs: []
  type: TYPE_NORMAL
- en: The permanent generation is cleaned at different times by different GC algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: The G1 GC does it somewhat differently. It divides the heap into equal-sized
    regions and assigns each of them one of the same roles—Eden, survivor, or old—but
    changes the number of regions with the same role dynamically, depending on the
    need. It makes the memory-cleaning process and the memory defragmentation more
    predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The serial GC cleans the young and the old generations in the same cycle (serially,
    thus the name). During the task, it stops the world. That is why it is used for
    non-server applications with one CPU and a heap size of a few hundred MB.
  prefs: []
  type: TYPE_NORMAL
- en: The parallel GC works in parallel on all available cores, although the number
    of threads can be configured. It also stops the world and is appropriate only
    for applications that can tolerate long freezing times.
  prefs: []
  type: TYPE_NORMAL
- en: The CMS collector was designed to address this issue of long pauses. It does
    it at the expense of not defragmenting the old generation and doing some analysis
    in parallel to the application execution (typically using 25% of CPU). The collection
    of the old generation starts when it is 68% full (by default, but this value can
    be configured).
  prefs: []
  type: TYPE_NORMAL
- en: The G1 GC algorithm is similar to the CMS collector. First, it concurrently
    identifies all the referenced objects in the heap and marks them correspondingly.
    Then it collects the emptiest regions first, thereby releasing a lot of free space.
    That's why it is called *Garbage-First*. Because it uses many small dedicated
    regions, it has a better chance of predicting the amount of time it needs to clean
    one of them and in fitting a user-defined pause time (G1 may exceed it occasionally,
    but it is pretty close most of the times).
  prefs: []
  type: TYPE_NORMAL
- en: The main beneficiaries of G1 are applications that require large heaps (6 GB
    or more) and do not tolerate long pauses (0.5 seconds or less). If an application
    encounters an issue of too many and/or too-long pauses, it can benefit from switching
    from the CMS or parallel GC (especially the parallel GC of the old generation)
    to the G1 GC. If that is not the case, switching to the G1 collector is not a
    requirement when using JDK 9 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'The G1 GC starts with the young generation collection using stop-the-world
    pauses for evacuation (moving objects inside the young generation and out to the
    old generation). After the occupancy of the old generation reaches a certain threshold,
    it is collected too. The collection of some of the objects in the old generation
    is done concurrently and some objects are collected using stop-the-world pauses. The
    steps include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial marking of the survivor regions (root regions), which may have references
    to objects in the old generation, done using stop-the-world pauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scanning of survivor regions for references to the old generation, done
    concurrently while the application continues to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concurrent marking of live objects over the entire heap, done concurrently
    while the application continues to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remark step completes the marking of live objects, done using stop-the-world
    pauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cleanup process calculates the age of live objects, frees the regions (using
    stop-the-world pauses), and returns them to the free list (concurrently)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding sequence might be interspersed with young generation evacuations
    because most of the objects are short-lived and it is easier to free a lot of
    memory by scanning the young generation more often.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a mixed phase when G1 collects the regions already marked as mostly
    garbage in both the young and old generations, and humongous allocation when large
    objects are moved to or evacuated from humongous regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few occasions when full GC is performed, using stop-the-world pauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrent failure**: This happens if the old generation gets full during
    the marking phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promotion failure**: This happens if the old generation runs out of space
    during the mixed phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evacuation failure**: This happens when the collector cannot promote objects
    to the survivor space and the old generation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Humongous allocation**: This happens when an application tries to allocate
    a very big object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If tuned properly, your applications should avoid full GC.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with GC tuning, JVM documentation ([https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html))
    describes ergonomics as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*Ergonomics is t*he process by which* JVM and garbage collection tuning, such
    as behavior-based tuning, improve application performance. The JVM provides platform-dependent
    default selections for the garbage collector, heap size, and runtime compiler.
    These selections match the needs of different types of applications while requiring
    less command-line tuning. In addition, behavior-based tuning dynamically tunes
    the sizes of the heap to meet a specified behavior of the application.*"'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how GC works, write the following program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it creates 99,888,999 objects and adds them to the `List<AnObject>
    list` collection. You might tune it by decreasing the maximum number of objects
    (`max`) to match the configuration of your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The G1 GC is the default collector since Java 9, so you don''t have to set
    anything if it is good enough for your application. Nevertheless, you can explicitly
    enable G1 by providing `-XX:+UseG1GC` on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we assume you can build an executable `.jar` file and understand the
    basic Java execution command. If not, please refer to the JVM documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other available GCs can be used by setting one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:+UseSerialGC` for using a serial collector.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+UseParallelGC` for using a parallel collector with parallel compaction
    (which enables the parallel collector to perform major collections in parallel).
    Without parallel compaction, major collections are performed using a single thread,
    which can significantly limit the scalability. Parallel compaction is disabled
    by the `-XX:+UseParallelOldGC` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+UseConcMarkSweepGC` for using the CMS collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see the log messages of GC, set `-Xlog:gc`. You can also use the Unix utility, `time`,
    to measure the time it took to do the job (the utility publishes the last three
    lines of the output, so you do not need to use it if you cannot or do not want
    to do it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding command. The output may look as follows (the actual values
    may be different on your computer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/559f97f3-d6c4-40f6-8656-ba6b3a7f2834.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the GC went through most of the steps we have described. It
    has started with collecting the young generation. Then, when the `List<AnObject>
    list` object (see the preceding code) becomes too big (more than 50% of a young
    generation region), the memory for it is allocated in the *humongous* region.
    You can also see the initial mark step, the following remark, and other steps
    described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line starts with the time (in seconds) the JVM was running for and ends
    with the time (in milliseconds) that every step took. At the bottom of the screenshot,
    we see three lines printed by the `time` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`real` is the amount of wall clock time spent—all the time elapsed (should
    align with the first column of the JVM uptime value) since the command was run'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user` is the amount of time all the CPUs spent in the user-mode code (outside
    the kernel) within the process; it is bigger because GC worked concurrently with
    the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys` is the amount of time the CPU spent in the kernel within the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`+`sys` is the amount of CPU time the process used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set the `-XX:+PrintGCDetails` option (or just add `*` to the log option, `-Xlog:gc*`)
    to see more details about GC activity. In the following screenshot, we provide
    only the beginning of the log related to GC step 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99a97b8a-3f4b-44ef-bff8-1001d7346e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: Now the log has more than a dozen entries for each of the GC steps and ends
    up with logging the `User`, `Sys`, and `Real` amount of time (the amounts accumulated
    by the `time` utility) each step took. You can modify the program by adding more
    short-lived objects, for example, and see how the GC activity changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Get even more information with the `-Xlog:gc*=debug` option. The following
    is only a fragment of an output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b425d3d-0e6e-4cb2-9900-2a001530b65e.png)'
  prefs: []
  type: TYPE_IMG
- en: So, it is up to you to choose how much info you need for the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more details of the logging format and other log options in
    the *Unified logging for the JVM* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have mentioned earlier, the G1 GC uses default ergonomic values that
    probably would be good enough for most applications. Here is the list of the most
    important ones (`<ergo>` means that the actual value is determined ergonomically
    depending on the environment):'
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:MaxGCPauseMillis=200`: Holds the value for the maximum pause time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:GCPauseTimeInterval=<ergo>`: Holds the maximum pause time between GC steps
    (not set by default, allowing G1 to perform garbage collections back to back if
    needs be)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:ParallelGCThreads=<ergo>`: Holds the maximum number of threads used for
    parallel work during garbage collection pauses (by default, derived from the number
    of available threads; if the number of CPU threads available to the process is
    less than or equal to eight, it uses this number; otherwise, it adds five-eighths
    of the threads greater than eight to the final number of threads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:ConcGCThreads=<ergo>`: Holds the maximum number of threads used for concurrent
    work (set by default as `-XX:ParallelGCThreads` divided by four).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+G1UseAdaptiveIHOP`: Indicates that the initiating heap occupancy should
    be adaptive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:InitiatingHeapOccupancyPercent=45`: Sets the first few collection cycles;
    G1 will use an occupancy of 45% of the old generation as the mark start threshold'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1HeapRegionSize=<ergo>`: Holds the heap region size based on the initial
    and maximum heap sizes (by default, because the heap contains roughly 2,048 heap
    regions, the size of a heap region can vary from 1 to 32 MB and must be a power
    of 2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1NewSizePercent=5` and`-XX:XX:G1MaxNewSizePercent=60`: Define the size
    of the young generation in total, which varies between these two values as percentages
    of the current JVM heap in use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1HeapWastePercent=5`: Holds the allowed unreclaimed space in the collection-set
    candidates as a percentage (G1 stops the space reclamation if the free space in
    the collection-set candidates is lower than that)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1MixedGCCountTarget=8`: Holds the expected length of the space-reclamation
    phase in a number of collections)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:G1MixedGCLiveThresholdPercent=85`: Holds the percentage of the live object
    occupancy of the old generation regions, after which a region won''t be collected
    in this space-reclamation phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, the G1 goals in the default configuration are "to provide relatively
    small, uniform pauses at high throughput"(from the G1 documentation). If these
    default settings do not fit your application, you can change the pause time (using
    `-XX:MaxGCPauseMillis`) and the maximum Java heap size (using the `-Xmx` option).
    Note, though, that the actual pause time will not be an exact match at runtime,
    but G1 will try its best to meet the goal.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to increase the throughput, decrease the pause time goal or
    request a larger heap. To increase responsiveness, change the pause time value.
    Note, though, that the limiting of the young generation size (using `-Xmn`, `-XX:NewRatio`, or other
    options) can impede the pause-time control because "the young generation size
    is the main means for G1 to allow it to meet the pause time"(from the G1 documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first possible causes of poor performance can be full GC triggered
    by a too-high heap occupancy in the old generation. This situation can be detected
    by the presence of *Pause Full (Allocation failure)* in the log. It usually happens
    when too many objects are created in a quick succession (and cannot be collected
    quickly enough) or many large (humongous) objects cannot be allocated in a timely
    manner. There are several recommended ways to handle this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an excessive number of humongous objects, try to reduce their
    count by increasing the region size, using the `-XX:G1HeapRegionSize` option (the
    currently selected heap region size is printed at the beginning of the log).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the size of the heap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the number of concurrent marking threads by setting `-XX:ConcGCThreads`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate the beginning of marking earlier (using the fact that G1 makes the
    decisions based on earlier application behavior). Increase the buffer used in
    an adaptive IHOP calculation by modifying `-XX:G1ReservePercent`, or disable the
    adaptive calculation of the IHOP by setting it manually using `-XX:-G1UseAdaptiveIHOP`
    and `-XX:InitiatingHeapOccupancyPercent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only after addressing full GC can one start tuning the JVM for better responsiveness
    and/or throughput. The JVM documentation identifies the following cases for responsiveness
    tuning:'
  prefs: []
  type: TYPE_NORMAL
- en: Unusual system or real-time usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference processing takes too long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Young-only collections take too long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed collections take too long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High update RS and scan RS times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better throughput can be achieved by decreasing the overall pause times and
    the frequency of the pauses. Refer to the JVM documentation for the identification
    and recommendations of mitigating the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Unified logging for JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main components of JVM include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Classloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JVM memory where the runtime data is stored; it is broken down into the following
    areas:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PC registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native method stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execution engine, which consists of the following parts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JIT compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native method interface JNI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native method library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log message of all these components can now be captured and analyzed using
    unified logging, turned on by the `-Xlog` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of the new logging system are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the log levels—`trace`, `debug`, `info`, `warning`, `error`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message tags that identify the JVM component, action, or message of a specific
    interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three output types—`stdout`, `stderr`, and `file`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enforcement of the one-message-per-line limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see all the logging possibilities at a glance, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/788ed104-16ed-496b-90d0-b8d535eca63d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the format of the `-Xlog` option is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the option in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`what` is a combination of tags and levels of the `tag1[+tag2...][*][=level][,...]` form.
    We have already demonstrated how this construct works when we used the `gc` tag
    in the `-Xlog:gc*=debug` option. The wildcard (`*`) indicates that you''d like to
    see all the messages that have the `gc` tag (maybe among other tags). An absence
    of the `-Xlog:gc=debug` wildcard indicates that you would like to see messages
    marked by one tag (`gc`, in this case) only. If only `-Xlog` is used, the log
    will show all the messages at the `info` level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output` sets the type of output (the default is `stdout`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `decorators` indicate what will be placed at the beginning of each line
    of the log (before the actual log message comes from a component). Default decorators
    are `uptime`, `level`, and `tags`, each included in square brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output_options` may include `filecount=file count` and/or `filesize=file size`
    with optional K, M or G suffix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize, the default log configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run some of the log settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are no messages because the JVM does not log messages with the `cpu` tag
    only. The tag is used in combination with other tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `*` sign and run the command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4566a7ef-010f-4d35-ab73-cdba7dd3f4a9.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `cpu` tag brings only messages about how long it took a
    garbage collection to execute. Even if we set the log level to `trace` or `debug`
    (`-Xlog:cpu*=debug`, for example), no other messages will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the command with the `heap` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You will only get heap-related messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c81bd5b6-448f-48d3-b5d4-af99a70f1f13.png)'
  prefs: []
  type: TYPE_IMG
- en: But let's look closer at the first line. It starts with three decorators—`uptime`,
    `log level`, and `tags`—and then with the message itself, which starts with the
    collection cycle number (0 in this case) and the information that the number of
    Eden regions dropped from 24 to 0 (and their count now is 9). It happened because
    (as we see in the next line) the count of survivor regions grew from 0 to 3 and
    the count of the old generation (the third line) grew to 18, while the count of
    humongous regions (23) did not change. These are all the heap-related messages
    in the first collection cycle. Then, the second collection cycle starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `cpu` tag again and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `cpu` message shows how long each cycle took:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3cfeb83-7d29-427b-a784-3905350fbd00.png)'
  prefs: []
  type: TYPE_IMG
- en: Try to use two tags combined via the `+` sign (`-Xlog:gc+heap`, for example).
    It brings up only the messages that have both tags (similar to the binary `AND`
    operation). Note that a wildcard will not work together with the `+` sign (`-Xlog:gc*+heap`,
    for example, does not work).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also select the output type and decorators. In practice, the decorator
    level does not seem very informative and can be easily omitted by explicitly listing
    only the decorators that are needed. Consider the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the two colons (`::`) were inserted to preserve the default setting
    of the output type. We could also show it explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove any decoration, one can set them to `none`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The most useful aspect of a new logging system is tag selection. It allows a
    better analysis of the memory evolution of each JVM component and its subsystems
    or to find the performance bottleneck, analyzing the time spent in each collection
    phase—both are critical for the JVM and application tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Using the jcmd command for the JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you open the `bin` folder of the Java installation, you can find quite a
    few command-line utilities there that can be used to diagnose issues and monitor
    an application deployed with the **Java Runtime Environment** (**JRE**). They use
    different mechanisms to get the data they report. The mechanisms are specific
    to the **Virtual Machine** (**VM**) implementation, operating systems, and release.
    Typically, only a subset of the tools is applicable to a given issue.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will focus on the diagnostic command introduced with Java
    9 as a command-line utility, `jcmd`. If the `bin` folder is on the path, you can
    invoke it by typing `jcmd` on the command line. Otherwise, you have to go to the
    `bin` directory or prepend the `jcmd` in our examples with the full or relative
    (to the location of your command line window) path to the `bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do type it and there is no Java process currently running on the machine,
    you will get back only one line, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It shows that only one Java process is currently running (the `jcmd` utility
    itself) and it has the **process identifier** (**PID**) of 87863 (which will be
    different with each run).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run a Java program, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `jcmd` will show (with different PIDs) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if entered without any options, the `jcmd` utility reports
    the PIDs of all the currently running Java processes. After getting the PID, you
    can then use `jcmd` to request data from the JVM that runs the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can avoid using PID (and calling `jcmd` without parameters)
    by referring to the process by the main class of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can read the JVM documentation for more details about the `jcmd` utility
    and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`jcmd` is a utility that allows us to issue commands to the specified Java
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the full list of the `jcmd` commands available for a particular Java process
    by executing the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `PID/main-class`, put the process identifier or the main class name. The
    list is specific to JVM, so each listed command requests the data from the specific
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JDK 8, the following `jcmd` commands were available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The JDK 9 introduced the following `jcmd` commands (JDK 18.3 and JDK 18.9 did
    not add new commands):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Compiler.queue`: Prints the methods queued for compilation with either C1
    or C2 (separate queues)'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.codelist`: Prints n-methods (compiled) with full signature, address
    range, and state (alive, non-entrant, and zombie), and allows the selection of
    printing to `stdout`, a file, XML, or text printout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.codecache`: Prints the content of the code cache, where the JIT compiler
    stores the generated native code to improve performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_add file`: Adds compiler directives from a file to the
    top of the directives stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_clear`: Clears the compiler directives stack (leaves the
    default directives only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_print`: Prints all the directives on the compiler directives
    stack from top to bottom'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compiler.directives_remove`: Removes the top directive from the compiler directives
    stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GC.heap_info`: Prints the current heap parameters and status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GC.finalizer_info`: Shows the status of the finalizer thread, which collects
    objects with a finalizer (that is, a `finalize()` method)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JFR.configure`: Allows us to configure the Java Flight Recorder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JVMTI.data_dump`: Prints the Java Virtual Machine Tool Interface data dump'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JVMTI.agent_load`: Loads (attaches) the Java Virtual Machine Tool Interface agent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ManagementAgent.status`: Prints the status of the remote JMX agent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread.print`: Prints all the threads with stack traces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.log [option]`: Allows us to set the JVM log configuration (which we described
    in the previous recipe) at runtime, after the JVM has started (the availability
    can be seen by using `VM.log list`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.info`: Prints the unified JVM info (version and configuration), a list
    of all threads and their state (without thread dump and heap dump), heap summary,
    JVM internal events (GC, JIT, safepoint, and so on), memory map with loaded native
    libraries, VM arguments and environment variables, and details of the operation
    system and hardware'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.dynlibs`: Prints information about dynamic libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.set_flag`: Allows us to set the JVM *writable* (also called *manageable*)
    flags (see the JVM documentation for a list of the flags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.stringtable` and `VM.symboltable`: Prints all UTF-8 string constants'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.class_hierarchy [full-class-name]`: Prints all the loaded classes or just
    a specified class hierarchy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.classloader_stats`: Prints information about the classloader'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM.print_touched_methods`: Prints all the methods that have been touched (have
    been read at least) at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these new commands belong to several groups, denoted by the
    prefix compiler, **garbage collector** (**GC**), **Java Flight Recorder** (**JFR**), **Java
    Virtual Machine Tool Interface** (**JVMTI**),  **Management Agent** (related to
    remote JMX agent), **thread**, and **VM**. In this book, we do not have enough
    space to go through each command in detail. We will only demonstrate the usage
    of a few practical ones.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get help for the `jcmd` utility, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c0c5f23-7cdb-4af3-b2ce-942c651d9803.png)'
  prefs: []
  type: TYPE_IMG
- en: It tells us that the commands can also be read from the file specified after
    `-f` and that there is a `PerfCounter.print` command, which prints all the performance
    counters (statistics) of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output may look like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abfd96d8-ab1b-4ff2-8991-f21ef5f8d76a.png)'
  prefs: []
  type: TYPE_IMG
- en: It shows the total heap size and how much of it was used, the size of a region
    in the young generation and how many regions are allocated, and the parameters
    of `Metaspace` and `class space`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is very helpful in case you are looking for runaway threads
    or would like to know what else is going on behind the scenes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a fragment of the possible output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43091e9-2642-4bde-9792-76cedc1a469e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This command is probably used most often, as it produces a wealth of information
    about the hardware, the JVM process as a whole, and the current state of its components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts with a summary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74c3872d-716d-4a5e-8479-35a470b2c17f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The general process description follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d749730b-0f1f-415e-99cb-20c47419c2fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then come the details of the heap (this is only a tiny fragment of it):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f0074ff-b4b5-465c-b168-bcd5089fa685.png)'
  prefs: []
  type: TYPE_IMG
- en: It then prints the compilation events, GC heap history, deoptimization events,
    internal exceptions, events, dynamic libraries, logging options, environment variables, VM
    arguments, and many parameters of the system running the process.
  prefs: []
  type: TYPE_NORMAL
- en: The `jcmd` commands give a deep insight into the JVM process, which helps to debug
    and tune the process for best performance and optimal resource usage.
  prefs: []
  type: TYPE_NORMAL
- en: Try-with-resources for better resource handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing resources is important. Any mishandling (not releasing) of the resources—database
    connections and file descriptors left opened, for example—can exhaust the system''s
    capability to operate. That''s why, in JDK 7,  the *try-with-resources* statement
    was introduced. We have used it in the examples of [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reminder, here is the `getDbConnection()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the `createStatement()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This was very helpful, but in some cases, we were still required to write extra
    code in the old style, for example, if there is an `execute()` method that accepts
    a `Statement` object as a parameter, and we would like to release (close) it as
    soon as it was used. In such a case, the code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of it is just boilerplate copy-and-paste code.
  prefs: []
  type: TYPE_NORMAL
- en: The new *try-with-resources* statement, introduced with Java 9, addresses this
    case by allowing effectively final variables to be used as the resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rewrite the previous example using the new *try-with-resources* statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is much more concise and focused, without the need to repeatedly
    write trivial code that closes the resource. No more `finally` and additional `try...catch`
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the connection is passed in too, it also can be put in the same try-block
    and closed as soon as it is no longer needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It may or may not fit your application's connection-handling, but often, this
    capability is handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try a different combination, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And this combination is allowed too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The new statement provides more flexibility to write code that fits the needs
    without writing the lines that close the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable included in the `try` statement has to be final or effectively
    final
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resource has to implement the `AutoCloseable` interface, which includes
    only one method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how the new statement works, let's create our own resources that
    implement `AutoCloseable` and use them in a fashion similar to the resources of
    the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the second resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use them in the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27c7e219-b1e6-488a-b968-ce460476c73a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the resource listed first in the `try` statement is closed last.
    Let us make only one change and switch the order  of the references in the `try`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output confirms that the sequence of the references closing changes too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9d13e94-10a6-414f-89ae-61cb50692e48.png)'
  prefs: []
  type: TYPE_IMG
- en: This rule of closing the resources in the reverse order addresses the most important
    possible issue of dependency between resources, but it is up to the programmer
    to define the sequence of closing the resources (by listing them in the `try` statement
    in the correct order). Fortunately, the closing of most standard resources is
    handled by the JVM gracefully, and the code does not break if the resources are
    listed in incorrect order. Still, it is a good idea to list them in the same sequence
    as they were created.
  prefs: []
  type: TYPE_NORMAL
- en: Stack walking for improved debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack trace can be very helpful in figuring out the source of a problem. When
    an automatic correction is possible, the need arises to read it programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Java 1.4, the current stack trace can be accessed via the `java.lang.Thread`
    and `java.lang.Throwable` classes. You can add the following line to any method
    of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print the stack trace to the standard output. Alternatively, since
    Java 8, you can use any of the following lines for the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can extract the fully qualified name of the caller class, using one
    of these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'All the aforementioned solutions are possible because of the `java.lang.StackTraceElement` class,
    which represents a stack frame in a stack trace. This class provides other methods
    that describe the execution point represented by this stack-trace element, which
    allows programmatic access to the stack-trace information. For example, you can
    run this code snippet from anywhere in your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can run the following from anywhere in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this wealth of data comes with a price. The JVM captures the
    entire stack (except for hidden stack frames), and—in those cases when the programmatic
    analysis of the stack trace is embedded in the main application flow—it may affect
    the application performance. Meanwhile, you only need a fraction of this data
    to make a decision.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the new Java 9 class, `java.lang.StackWalker`, with its nested
    `Option` class and `StackFrame` interface, comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StackWalker` class has four overloaded  `getInstance()` static factory
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackWalker getInstance()`: This is configured to skip all the hidden frames
    and no caller class reference is retained. The hidden frames contain JVM internal
    implementation-specific information. Not retaining the caller class reference
    means that calling the `getCallerClass()` method on the `StackWalker` object throws `UnsupportedOperationException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(StackWalker.Option option)`: This creates an instance
    with the given option, specifying the stack frame information it can access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(Set<StackWalker.Option> options)`: This creates an
    instance with the given set of options, specifying the stack frame information
    it can access. If the given set is empty, the instance is configured exactly like
    the instance created by `StackWalker getInstance()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker getInstance(Set<StackWalker.Option> options, int estimatedDepth)`:
    This creates a similar instance as the preceding one and accepts the `estimatedDepth`
    parameter, which allows us to estimate the buffer size it might need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the values of `enum StackWalker.Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StackWalker.Option.RETAIN_CLASS_REFERENCE`: Configures the `StackWalker` instance
    to support the `getCallerClass()` method, and the `StackFrame` to support the `getDeclaringClass()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_HIDDEN_FRAMES`: Configures the `StackWalker` instance
    to show all reflection frames and implementation-specific frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackWalker.Option.SHOW_REFLECT_FRAMES`: Configures the `StackWalker` instance
    to show all reflection frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `StackWalker` class also has three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T walk(Function<Stream<StackWalker.StackFrame>, T> function)`: This applies
    the given function to the stream of `StackFrames` for the current thread, traversing
    the frames from the top of the stack. The top frame contains the method that has
    called this `walk()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void forEach(Consumer<StackWalker.StackFrame> action)`: This performs the
    given action on each element of the `StackFrame` stream of the current thread,
    traversing from the top frame of the stack, which is the method calling the `forEach`
    method. This method is equivalent to calling `walk(s -> { s.forEach(action); return
    null; })`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Class<?> getCallerClass()`: This gets the `Class` object of the caller that
    invoked the method that called `getCallerClass()`. This method throws `UnsupportedOperationException`
    if this `StackWalker` instance is not configured with the `RETAIN_CLASS_REFERENCE`
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create several classes and methods that will call each other, so you can perform
    stack-trace processing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Clazz01` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Clazz02` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Clazz03` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a `demo4_StackWalk()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Call this method from the main method of the `Chapter11Memory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the `Chapter11Memory` class, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60ec130e-737d-49db-831f-f14f3fd5e717.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Do something` message is passed from `Clazz01` and printed out in `Clazz03`.
    Then `Clazz02` passes null to `Clazz03`, and the `Throw the exception` message
    is printed out before the stack trace caused by `NullPointerException` from the `action.toString()` line.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a deeper understanding of the concepts here, let''s modify `Clazz03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb839893-eba0-42a0-9ef6-7f8eccc8e86b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can get a similar output by using `Throwable` instead of
    `Thread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbefaa13-cce7-4a17-b224-fc6f2df44f43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A similar result will produce each of the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Java 9, the same output can be achieved using the `StackWalker` class.
    Let''s look at what happens if we modify `Clazz03` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a56bc8a-4f69-4dc3-81a0-8cee5859d2bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It contains all the information the traditional methods produced. However,
    contrary to the full stack trace generated and stored as an array in the memory,
    the `StackWalker` class only brings the requested elements. This is already a
    big plus. Yet the biggest advantage of `StackWalker` is that, when we need the
    caller class name only, instead of getting all the array and using only one element,
    we can now get the info we need by using the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code snippet is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/370ad025-999a-46d6-afaf-3f2d7557c969.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the memory-aware coding style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing code, a programmer has two main objectives in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: To implement the required functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To write code that is easy to read and understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yet, while doing that, they also have to make many other decisions, one of
    them being which of the standard library classes and methods with similar functionality
    to use. In this recipe, we will walk you through a few considerations that help
    to avoid the wasting of memory and make your code style memory-aware:'
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the object created inside the loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lazy initialization and create an object just before the usage, especially
    if there is a good chance that, this need may never materialize at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't forget to clean the cache and remove unnecessary entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `StringBuilder` instead of the `+` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `ArrayList` if it fits your needs, before using `HashSet` (the memory usage
    increases from `ArrayList` to `LinkedList`, `HashTable`, `HashMap`, and `HashSet`,
    in this sequence)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pay attention to the object created inside the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This recommendation is pretty obvious. Creating and discarding many objects
    in quick succession may consume too much memory before the garbage collector catches
    up with reusing the space. Consider reusing objects instead of creating a new
    one every time. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can be improved by making the `calculate()` method static. Another
    solution would be to create a static property, `Calculator calculator = new Calculator()`,
    of the `SomeOtherClass` class. But the static property is initialized as soon
    as the class is loaded the first time. If the `calculator` property is not used,
    its initialization would be unnecessary overhead. In such cases, lazy initialization
    has to be added.
  prefs: []
  type: TYPE_NORMAL
- en: Use lazy initialization and create an object just before the usage, especially
    if there is a good chance this need may never materialize for some requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous step, we talked about lazy initialization of the `calculator`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `Calculator` object is a singleton—once created,
    only one instance of it exists in the application. If we know that calculator
    property is always going to be used, then there is no need for the lazy initialization.
    In Java, we can take advantage of the static-property initialization the first
    time the class is loaded by any of the application threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: But if there is a good chance the initialized object will never be used, we
    are back to the lazy initialization that can be implemented as was discussed earlier
    (using the `getCalculator()` method) in a single thread or when the shared object
    is stateless and its initialization does not consume many resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a multi-threaded application and complex object initialization
    with substantial resource consumption, some additional measures have to be taken
    to avoid the conflict of a concurrent access and make sure only one instance is
    created. For example, consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding constructor requires an extensive time to complete object
    creation, there is a chance that the second thread enters the constructor before
    the first thread has completed the object creation. To avoid this concurrent creation
    of the second object, we need to synchronize the initialization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we could synchronize access to the `getData()` method, but this
    synchronization is not needed after the object is created and can cause a bottleneck
    in a highly concurrent multithreaded environment. Similarly, we could have only
    one check for null—inside the synchronized block—but this synchronization is not
    needed after the object is initialized, so we surround it with another check for
    null to decrease the chance for the bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to clean the cache and remove unnecessary entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Caching helps to decrease the time for accessing the data. But the cache consumes
    memory, so it makes sense to keep it as small as possible, while still being useful.
    How to do it very much depends on the pattern of the cached data usage. For example,
    if you know that, once used, the object stored in the cache is not going to be
    used again, you can put it in the cache at the application startup time (or periodically,
    according to the pattern of the usage) and remove it from the cache after it was
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you expect a high level of reusability for each object, you
    can put it in the cache after it was requested the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding case may lead to an uncontrollable growth of the cache that consumes
    too much memory and eventually causes the `OutOfMemoryError` condition. To prevent
    it, you can implement an algorithm that keeps the cache''s size limited—after
    a certain size, every time a new object is added, some other object (used the
    most, for example, or used the least) is removed. The following is an example
    of limiting the cache size to 10 by removing the most-used cached object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, one can use the `java.util.WeakHashMap` class to implement the
    cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding example, you will see that the memory usage and the
    cache size first increase, then drop down, then increase, and drop down again.
    Here is an excerpt from an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory usage calculation we used was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `java.util.WeakHashMap` class is a Map implementation with keys of the `java.lang.ref.WeakReference` type. The
    objects that are referenced only by weak references are garbage-collected any
    time the garbage collector decides there is more memory needed. This means that
    an entry in a `WeakHashMap` object will be removed when there is no reference
    to that key. When the garbage collection removes the key from the memory, the
    corresponding value is removed from the map too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding example, none of the cache keys was used outside the map,
    so the garbage collector removed them at its discretion. The code behaves the
    same way even when we add an explicit reference to a key outside the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'That is because the `iObj` reference shown in the earlier code block gets abandoned
    after each iteration and collected, so the corresponding key in the cache is left
    without external reference, and the garbage collector removes it too. To prove
    this point, let''s modify the preceding code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a list and added each of the map keys to it. If we run the
    preceding code, we will eventually get `OutOfMemoryError` because the cache''s
    keys had strong references outside the map.  We can weaken the external references
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code now runs as if the cache keys do not have external references.
    The used memory and cache size grow and drop down again. But the list size does
    not drop down, because the garbage collector does not remove values from the list.
    So, eventually, the application may run out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, whether you limit the size of the cache or let it grow uncontrollably,
    there may be a situation when the application needs as much memory as possible.
    So, if there are big objects that are not critical to the application's main functionality,
    sometimes it makes sense to remove them from memory in order for the application
    to survive and not get into the `OutOfMemoryError` condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a cache, it is typically a good candidate for removing and freeing
    the memory, so we can wrap the cache itself with the `WeakReference` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have wrapped up the map (cache) inside the `WeakReference`
    class, which means we tell the JVM that it can collect this object as soon as
    there is no reference to it. Then, in each iteration of the for-loop, we create
    `new Double[1024]` object and save it in the list. We do it in order to use up
    all the available memory quicker. Then we put the same object in the cache. When
    we run this code, it quickly ends up with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the garbage collector decided to collect cache object after
    25 MB of memory was used. If such an approach, you think, is too aggressive and
    you do not need to renew the cache often, you can wrap it in the `java.lang.ref.SoftReference`
    class instead. If you do, the cache will be collected only when all the memory
    is used up—just on the brink of throwing `OutOfMemoryError`. Here is the code
    snippet that demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run it, the output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That's right, on our test computer, there is 4 GB of RAM, so the cache was removed
    only when almost all of it was used.
  prefs: []
  type: TYPE_NORMAL
- en: Use `StringBuilder` instead of the `+` operator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can find many such recommendations on the internet. There are also quite
    a few statements saying that this recommendation is obsolete because modern Java
    uses `StringBuilder` to implement the `+` operator for strings. Here is the result
    of our experimentation. First, we have run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `usedMemoryMB()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we used `StringBuilder` for the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the `+` operator consumed 71 MB of memory, while `StringBuilder`
    used only 1 MB for the same task. We have tested `StringBuffer`, too. It consumed
    1 MB as well but performed slightly slower than `StringBuilder`, because it is
    thread-safe, while `StringBuilder` can be used in a single-thread environment
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this does not apply to the long `String` value that was broken into several
    substrings with the plus sign for better readability. The compiler collects the
    substring back into one long value. For example, the `s1` and `s2` strings occupy
    the same amount of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If you need to use a collection, select `ArrayList` if it fits your needs. The
    memory usage increases from `ArrayList` to `LinkedList`, `HashTable`, `HashMap`,
    and `HashSet`, in this sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ArrayList` object stores its elements in an `Object[]` array and uses an
    `int` field for tracking the list size (in addition to `array.length`). Because
    of such a design, it is not recommended to allocate an `ArrayList` of a large
    capacity while declaring it, if there is a chance that this capacity will not
    be fully used. As new elements are added to the list, the backend array's capacity
    is incremented in blocks of 10 elements, which is a possible source of wasted
    memory. If it is significant for the application, it is possible to shrink the
    `ArrayList` capacity to the one currently utilized by calling on it the `trimToSize()` method.
    Please, note that the `clear()` and `remove()` methods do not affect the `ArrayList`
    capacity, they change only its size.
  prefs: []
  type: TYPE_NORMAL
- en: Other collections have more overhead because they provide more service. The
    `LinkedList` elements carry references to the previous and next elements as well
    as a reference to the data value. Most implementations of hash-based collections
    are focused on better performance, which often comes at the expense of memory
    footprint.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of Java collection class may be irrelevant if its size is going to
    be small. However, programmers usually use the same coding pattern, and one can
    identify the code's author by its style. That's why it pays, in the long run,
    to figure out the most efficient constructs and use them routinely. However, try
    to avoid making your code difficult to understand; readability is an important
    aspect of code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for better memory usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management may never become an issue for you, it might your every waking
    moment, or you might find yourself in between these two polarities. Most of the
    time, it is a non-issue for the majority of programmers, especially with the constantly
    improving garbage-collection algorithms. The G1 garbage collector (default in
    JVM 9) is definitely a step in the right direction. But there is also a chance
    you will be called (or will notice yourself) about the application's degrading
    performance, and that is when you'll learn how well you are equipped to meet the
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is an attempt to help you avoid such a situation or to get out of
    it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of defense is the code itself. In the previous recipes, we discussed
    the need to release resources as soon as they are no longer needed and the usage
    of `StackWalker` to consume less memory. There are plenty of recommendations on
    the internet, but they might not apply to your application. You'll have to monitor
    the memory consumption and test your design decisions, especially if your code
    handles a lot of data, before deciding where to concentrate your attention.
  prefs: []
  type: TYPE_NORMAL
- en: Test and profile your code as soon as it starts doing what it was supposed to
    do. You might need to change your design or some details of implementation. It
    will also inform your future decisions. There are many profilers and diagnostic
    tools available for any environment. We described one of them, `jcmd`, in the *Using
    the jcmd command for the JVM *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Learn how your garbage collector works (see the *Understanding the G1 garbage
    collector* recipe) and do not forget to use JVM logging (described in the *Unified
    logging for JVM* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you might need to tune the JVM and garbage collector. Here are
    a few frequently used `java` command-line parameters (the size is specified in
    bytes by default, but you can append the letter k or K to indicate kilobytes,
    m or M to indicate megabytes, g or G to indicate gigabytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '`-Xms size`: This option allows us to set the initial heap size (has to be
    greater than 1 MB and a multiple of 1,024).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xmx size`: This option allows us to set the maximum heap size (has to be
    greater than 2 MB and a multiple of 1,024).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xmn size` or a combination of `-XX:NewSize=size` and `-XX:MaxNewSize=size`: This
    option allows us to set the initial and maximum size of the young generation.
    For efficient GC, it has to be lower than `-Xmx size`. Oracle recommends you set
    it at more than 25% and less than 50% of the heap size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:NewRatio=ratio`: This option allows us to set the ratio between the young
    and old generations (two, by default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Xss size`: This option allows us to set the thread stack size. The following
    are the default values for different platforms:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/ARM (32-bit): 320 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/ARM (64-bit): 1,024 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux/x64 (64-bit): 1,024 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS (64-bit): 1,024 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Solaris/i386 (32-bit): 320 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Solaris/x64 (64-bit): 1,024 KB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows: Depends on virtual memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:MaxMetaspaceSize=size`: This option allows us to set the upper limit of
    the class metadata area (no limit, by default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tell-tale sign of a memory leak is the growing of the old generation causing
    the full GC to run more often. To investigate, you can use the JVM parameters
    that dump heap memory into a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-XX:+HeapDumpOnOutOfMemoryError`: Allows us to save the JVM heap content into
    a file, but only when a `java.lang.OutOfMemoryError` exception is thrown. By default,
    the heap dump is saved in the current directory with the `java_pid<pid>.hprof` name
    where `<pid>` is the process ID. Use the `-XX:HeapDumpPath=<path>` option to customize
    the dump file location. The `<path>` value must include filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:OnOutOfMemoryError="<cmd args>;<cmd args>"`: Allows us to provide a set
    of commands (separated by a semicolon) that will be executed when an `OutOfMemoryError`
    exception is thrown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-XX:+UseGCOverheadLimit`: Regulates the size of the proportion of time GC
    takes before an `OutOfMemoryError` exception is thrown. For example, the parallel
    GC will throw an `OutOfMemoryError` exception when GC takes more than 98% of the time
    and recovers less than 2% of the heap. This option is particularly useful when
    the heap is small because it prevents JVM from running with little or no progress.
    It is turned on by default. To disable it, use `-XX:-UseGCOverheadLimit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Epsilon, a low-overhead garbage collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the popular Java interview questions is, c*an you enforce garbage collection?* Java
    runtime memory management remains outside a programmer's control and sometimes
    acts as an unpredictable Joker it interrupts the otherwise well-performing application
    and initiates a stop-the-world full-memory scan. It typically happens at the *worst
    possible time*. It is especially annoying when you try to measure your application
    performance under the load using a short run and realize afterward that a lot
    of time and resources were spent on the garbage collection process and that the
    pattern of the garbage collection, after you changed the code, became different
    than before the code change.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we described quite a few programming tricks and solutions that
    help to ease pressure on the garbage collector. Yet, it remains an independent
    and unpredictable contributor (or detractor) of the application performance. Wouldn't
    it be nice if the garbage collector was better controlled, at least for test purposes,
    or could be turned off? In Java 11, a garbage collector, Epsilon, called a no-op
    garbage collector, was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it looks strange—a garbage collector that doesn't collect anything.
    But it is predictable (that's for sure) because it does nothing, and that feature
    allows us to test algorithms in short runs without worrying about unpredictable
    pauses. Besides, there is a whole category of small short-lived applications that
    need all the resources they can muster for a brief period of time and it is preferable
    to restart the JVM and let the load balancer perform failover than to try factoring
    in an unpredictable Joker of the garbage-collection process.
  prefs: []
  type: TYPE_NORMAL
- en: It was also envisioned as a benchmark process that allows us to estimate a regular
    garbage collector overhead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To invoke the no-op garbage collector, use the `-XX:+UseEpsilonGC` option. At
    the time of writing, it requires an `-XX:+UnlockExperimentalVMOptions` option
    to access the new capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following program for the demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this program, we are trying to allocate 4 GB of memory by
    adding a 1 KB array to the list at each iteration. At the same time, we also create
    a 1 K array, `arr`, at each iteration but do not use the reference to it, so the
    traditional garbage collector can collect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will run the preceding program with the default garbage collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that we have limited the JVM heap memory to 4 GB because, for demonstrative
    purposes, we would like the program to exit with `OutOfMemoryError`. And we have
    wrapped the call with the `time` command to capture three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real time**: How long the program was running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User time**: How long CPU was used by the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sys time**: How long the operating system worked for the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We used JDK 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding commands may be different on your computer. During
    our test run, when we executed the preceding program with the specified `java`
    command parameters, the output started with the following four lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the G1 garbage collector is the default in JDK 11, and it started
    collecting unreferenced `arr` objects right away. As we have expected, the program
    exited after `OutOfMemoryError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The time utility produced the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Our computer is multicore, so the JVM was able to utilize several cores in parallel,
    most likely for the garbage collection. That is why user time is bigger than real
    time, and the system time is bigger than real time for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run the same program with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have added the `-XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC` options,
    which requires Epsilon garbage collector. The result looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the garbage collector did not even try to collect the abandoned
    objects. The usage of the heap space grew steadily until it was consumed completely,
    and the JVM exited with `OutOfMemoryError`.  Using the `time` utility allowed
    us to measure three following time parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, it took much less time to exhaust all the heap memory, and the user
    time is much less than real time. That is why, as we have mentioned already, the
    no-op Epsilon garbage collector can be useful to the programs that have to be
    as fast as possible but do not consume all the heap memory or can be stopped at
    any time. There are probably other use cases where the garbage collector that does
    not do anything can be helpful.
  prefs: []
  type: TYPE_NORMAL
