- en: 'Chapter 8. When Problems Hide: Getting More Information'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。当问题隐藏时：获取更多信息
- en: Sometimes code does not trigger a debug page to be displayed, but it also does
    not produce the correct results. In fact even when code does seem to be working
    correctly, at least in terms of the visible results shown in the browser, behind
    the scenes it may be doing unexpected things that could lead to trouble down the
    road. For example, if a page requires many (or very time-consuming) SQL queries,
    then it may seem to be working fine during development but then quickly cause
    server overload in a production environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时代码不会触发显示调试页面，但也不会产生正确的结果。事实上，即使代码似乎在浏览器中显示的可见结果方面工作正常，幕后它可能也在做一些意想不到的事情，这可能会在以后引起麻烦。例如，如果一个页面需要许多（或非常耗时的）SQL查询，那么在开发过程中它可能看起来运行正常，但在生产环境中很快就会导致服务器超载。
- en: It's good practice, then, to get into the habit of checking up on how code is
    behaving, even when external results are not showing any problems. First, this
    practice can reveal hidden problems that are best known about sooner rather than
    later. Second, knowing what the normal code path looks like is very valuable when
    tracking down where things have gone wrong when a problem does crop up.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，养成检查代码行为的习惯是很好的做法，即使外部结果没有显示任何问题。首先，这种做法可以揭示最好尽早知道的隐藏问题。其次，当问题确实出现时，了解正常的代码路径是非常有价值的。
- en: 'This chapter focuses on ways to get more information about what Django application
    code is doing. Specifically, in this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了获取有关Django应用程序代码正在执行的更多信息的方法。具体来说，在本章中我们将：
- en: Develop template code that can be used to include information about all of the
    SQL queries needed to render a page in the page itself
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模板代码，用于在页面本身包含有关渲染页面所需的所有SQL查询的信息
- en: Learn how to use the Django Debug Toolbar for gathering similar information,
    and more
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Django调试工具栏收集类似信息，以及更多
- en: Discuss techniques for adding logging to Django application code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论向Django应用程序代码添加日志记录的技术
- en: Tracking SQL queries for a request
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪请求的SQL查询
- en: For a typical Django application, database interactions are of key importance.
    Ensuring that the database queries being made are correct helps to ensure that
    the application results are correct. Further, ensuring that the database queries
    produced for the application are efficient helps to make sure that the application
    will be able to support the desired number of concurrent users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的Django应用程序，数据库交互非常重要。确保所做的数据库查询是正确的有助于确保应用程序的结果是正确的。此外，确保为应用程序生成的数据库查询是高效的有助于确保应用程序能够支持所需数量的并发用户。
- en: Django provides support in this area by making the database query history available
    for examination. [Chapter 6](ch06.html "Chapter 6. Django Debugging Overview"),
    *Django Debugging Overview*, introduced this history and showed how it could be
    accessed from a Python shell session. This type of access is useful to see the
    SQL that is issued as a result of calling a particular model method. However,
    it is not helpful in learning about the bigger picture of what SQL queries are
    made during the processing of a particular request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Django通过使数据库查询历史可供检查来支持这一领域。[第6章](ch06.html "第6章。Django调试概述")，“Django调试概述”介绍了这一历史，并展示了如何从Python
    shell会话中访问它。这种访问对于查看由于调用特定模型方法而发出的SQL非常有用。然而，它对于了解在处理特定请求期间进行了哪些SQL查询并不有用。
- en: This section will show how to include information about the SQL queries needed
    for production of a page in the page itself. We will alter our existing survey
    application templates to include query information, and examine the query history
    for some of the existing survey application views. Though we are not aware of
    any problems with the existing views, we may learn something in the process of
    verifying that they issue the queries we expect.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何在页面本身包含有关生产页面所需的SQL查询的信息。我们将修改现有的调查应用程序模板以包含查询信息，并检查一些现有调查应用程序视图的查询历史。虽然我们不知道现有视图存在任何问题，但在验证它们是否发出我们期望的查询时，我们可能会学到一些东西。
- en: Settings for accessing query history in templates
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中访问查询历史的设置
- en: Before the query history can be accessed from a template, we need to ensure
    some required settings are configured properly. Three settings are needed in order
    for the SQL query information to be available in a template. First, the debug
    context processor, `django.core.context_processors.debug`, must be included in
    the `TEMPLATE_CONTEXT_PROCESSORS` setting. This context processor is included
    in the default value for `TEMPLATE_CONTEXT_PROCESSORS`. We have not changed that
    setting; therefore we do not need to do anything to enable this context processor
    in our project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以从模板中访问查询历史之前，我们需要确保一些必需的设置被正确配置。为了使SQL查询信息在模板中可用，需要三个设置。首先，必须在`TEMPLATE_CONTEXT_PROCESSORS`设置中包含调试上下文处理器`django.core.context_processors.debug`。这个上下文处理器包含在`TEMPLATE_CONTEXT_PROCESSORS`的默认值中。我们没有更改该设置；因此，我们不需要在项目中做任何事情来启用这个上下文处理器。
- en: 'Second, the IP address of the machine sending the request must be listed in
    the `INTERNAL_IPS` setting. This is not a setting we have used before, and it
    is empty by default, so we will need to add it to the settings file. When testing
    using the same machine as where the development server runs, setting `INTERNAL_IPS`
    to include the loopback address is sufficient:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，发送请求的机器的IP地址必须列在`INTERNAL_IPS`设置中。这不是我们以前使用过的设置，默认情况下为空，因此我们需要将其添加到设置文件中。在使用与开发服务器运行的相同机器进行测试时，将`INTERNAL_IPS`设置为包括环回地址就足够了：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you also test from other machines, you will need to include their IP addresses
    in this setting as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还从其他机器进行测试，您还需要在此设置中包含它们的IP地址。
- en: Third and finally, `DEBUG` must be `True` in order for the SQL query history
    to be available in templates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，最后，`DEBUG`必须为`True`，才能在模板中使用SQL查询历史。
- en: 'When those three settings conditions are met, the SQL query history may be
    available in templates via a template variable named `sql_queries`. This variable
    contains a list of dictionaries. Each dictionary contains two keys: `sql` and
    `time`. The value for `sql` is the SQL query itself, and the value for `time`
    is the number of seconds the query took to execute.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `sql_queries` context variable is set by the debug context processor.
    Context processors are only called during template rendering when a `RequestContext`
    is used to render the template. Up until now, we have not used `RequestContexts`
    in our survey application views, since they were not necessary for the code so
    far. But in order to access the query history from the template, we will need
    to start using `RequestContexts`. Therefore, in addition to modifying the templates,
    we will need to change the view code slightly in order to include query history
    in the generated pages for the survey application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries for the home page
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by seeing what queries are issued in order to generate the `survey`
    application home page. Recall that the home page view code is:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are three `QuerySets` rendered in the template, so we would expect to
    see that this view generates three SQL queries. In order to check that, we must
    first change the view to use a `RequestContext`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The only change here is to add the `RequestContext(request)` as a third parameter
    to `render_to_response`, after adding an `import` for it earlier in the file.
    When we make this change, we may as well also change the `render_to_response`
    lines for the other views to use `RequestContexts` as well. That way when we get
    to the point of examining the SQL queries for each, we will not get tripped up
    by having forgotten to make this small change.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Second, we'll need to display the information from `sql_queries` somewhere in
    our `survey/home.html` template. But where? We don't necessarily want this information
    displayed in the browser along with the genuine application data, since that could
    get confusing. One way to include it in the response but not have it be automatically
    visible on the browser page is to put it in an HTML comment. Then the browser
    will not display it on the page, but it can be seen by viewing the HTML source
    for the displayed page.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first attempt at implementing this, we might change the top of `survey/home.html`
    to look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This template code prints out the contents of `sql_queries` within an HTML comment
    at the very beginning of the `content` block supplied by `survey/home.html`. First,
    the number of queries is noted by filtering the list through the `length` filter.
    Then the code iterates through each dictionary in the `sql_queries` list and displays
    `sql`, followed by a note in parentheses about the `time` taken for each query.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'How well does that work? If we try it out by retrieving the survey home page
    (after ensuring the development server is running), and use the browser''s menu
    item for viewing the HTML source for the page, we might see that the comment block
    contains something like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the exact number of queries displayed here will depend on the version
    of Django you are running. This result is from Django 1.1.1; later versions of
    Django may not show any queries displayed here. Furthermore, the history of the
    browser's interaction with the site will affect the queries issued. This result
    is from a browser that had been used to access the admin application, and the
    last interaction with the admin application was to log out. You may see additional
    queries if the browser had been used to access the admin application but the user
    had not logged out. Finally, the database in use can also affect the specific
    queries issued and their exact formatting. This result is from a MySQL database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not exactly what we expected. First, a minor annoyance, but `1 queries`
    is wrong, it should be `1 query`. Perhaps that wouldn''t annoy you, particularly
    just in internal or debug information, but it would annoy me. I would change the
    template code that displays the query count to use correct pluralization:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们预期的。首先，一个小小的烦恼，但是`1 queries`是错误的，应该是`1 query`。也许这不会让你烦恼，特别是在内部或调试信息中，但对我来说会让我烦恼。我会更改显示查询计数的模板代码，以使用正确的复数形式：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, since the template needs to use the `length` result multiple times, it
    is first cached in the `qcount` variable by using a `{% with %}` block. Then it
    is displayed, and it is used as the variable input to the `pluralize` filter that
    will put the correct letters on the end of `quer` depending on the `qcount` value.
    Now the comment block will show `0 queries`, `1 query`, `2 queries`, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于模板需要多次使用`length`结果，首先通过使用`{% with %}`块将其缓存在`qcount`变量中。然后它被显示，并且它被用作`pluralize`过滤器的变量输入，该过滤器将根据`qcount`值在`quer`的末尾放置正确的字母。现在注释块将显示`0
    queries`，`1 query`，`2 queries`等等。
- en: With that minor annoyance out of the way, we can concentrate on the next, larger,
    issue, which is that the displayed query is not a query we were expecting. Furthermore,
    the three queries we were expecting, to retrieve the lists of completed, active,
    and upcoming surveys, are nowhere to be seen. What's going on? We'll take each
    of these in turn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个小小的烦恼后，我们可以集中精力解决下一个更大的问题，那就是显示的查询不是我们预期的查询。此外，我们预期的三个查询，用于检索已完成、活动和即将进行的调查列表，都不见了。发生了什么？我们将依次处理每一个。
- en: The query that is shown is accessing the `django_session` table. This table
    is used by the `django.contrib.sessions` application. Even though the survey application
    does not use this application, it is listed in our `INSTALLED_APPS`, since it
    is included in the `settings.py` file that `startproject` generates. Also, the
    middleware that the `sessions` application uses is listed in `MIDDLEWARE_CLASSES`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的查询正在访问`django_session`表。这个表被`django.contrib.sessions`应用程序使用。尽管调查应用程序不使用这个应用程序，但它在我们的`INSTALLED_APPS`中列出，因为它包含在`settings.py`文件中，`startproject`生成。此外，`sessions`应用程序使用的中间件在`MIDDLEWARE_CLASSES`中列出。
- en: 'The `sessions` application stores the session identifier in a cookie, named
    `sessionid` by default, that is sent to the browser as soon as any application
    uses a session. The browser will return the cookie in all requests to the same
    server. If the cookie is present in a request, the session middleware will use
    it to retrieve the session data. This is the query we see previously listed: the
    session middleware is retrieving the data for the session identified by the session
    cookie sent by the browser.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessions`应用程序默认将会话标识符存储在名为`sessionid`的cookie中，一旦任何应用程序使用会话，它就会立即发送到浏览器。浏览器将在所有请求中返回该cookie给同一服务器。如果请求中存在该cookie，会话中间件将使用它来检索会话数据。这就是我们之前看到的查询：会话中间件正在检索由浏览器发送的会话cookie标识的会话数据。'
- en: But the survey application does not use sessions, so how did the browser get
    a session cookie in the first place? The answer is that the admin application
    uses sessions, and this browser had previously been used to access the admin application.
    At that time, the `sessionid` cookie was set in a response, and the browser faithfully
    returns it on all subsequent requests. Thus, it seems likely that this `django_session`
    table query is due to a `sessionid` cookie set as a side-effect of using the admin
    application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是调查应用程序不使用sessions，那么浏览器是如何首先获得会话cookie的呢？答案是管理员应用程序使用sessions，并且此浏览器先前曾用于访问管理员应用程序。那时，`sessionid`
    cookie在响应中设置，并且浏览器忠实地在所有后续请求中返回它。因此，似乎很可能这个`django_session`表查询是由于使用管理员应用程序的副作用设置了`sessionid`
    cookie。
- en: 'Can we confirm that? If we find and delete the cookie from the browser and
    reload the page, we should see that this SQL query is no longer listed. Without
    the cookie in the request, whatever code was triggering access to the session
    data won''t have anything to look up. And since the survey application does not
    use sessions, none of its responses should include a new session cookie, which
    would cause subsequent requests to include a session lookup. Is this reasoning
    correct? If we try it, we will see that the comment block changes to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能确认吗？如果我们找到并删除浏览器中的cookie，然后重新加载页面，我们应该会看到这个SQL查询不再列出。没有请求中的cookie，触发对会话数据的访问的任何代码都不会有任何东西可以查找。而且由于调查应用程序不使用sessions，它的任何响应都不应包含新的会话cookie，这将导致后续请求包含会话查找。这种推理正确吗？如果我们尝试一下，我们会看到注释块变成：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thus, we seem to have confirmed, to some extent, what happened to cause a `django_session`
    table query during processing of a survey application response. We did not track
    down what exact code accessed the session identified by the cookie—it could have
    been middleware or a context processor, but we probably don't need to know the
    details. It's enough to keep in mind that there are other applications running
    in our project besides the one we are working on, and they may cause database
    interactions independent of our own code. If we observe behavior which looks like
    it might cause a problem for our code, we can investigate further, but for this
    particular case we will just avoid using the admin application for now, as we
    would like to focus attention on the queries our own code is generating.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们似乎在一定程度上确认了在处理调查应用程序响应期间导致`django_session`表查询的原因。我们没有追踪到哪些确切的代码访问了由cookie标识的会话——可能是中间件或上下文处理器，但我们可能不需要知道细节。记住我们的项目中运行的除了我们正在工作的应用程序之外还有其他应用程序，它们可能会导致与我们自己的代码无关的数据库交互就足够了。如果我们观察到的行为看起来可能会对我们的代码造成问题，我们可以进一步调查，但对于这种特殊情况，我们现在将避免使用管理员应用程序，因为我们希望将注意力集中在我们自己的代码生成的查询上。
- en: Now that we understand the query that was listed, what about the expected ones
    that were not listed? The missing queries are due to a combination of the lazy
    evaluation property of `QuerySets` and the exact placement of the `comment` block
    that lists the contents of `sql_queries`. We put the `comment` block at the top
    of the `content` block in the home page, to make it easy to find the SQL query
    information when looking at the page source. The template is rendered after the
    three `QuerySets` are created by the view, so it might seem that the comment placed
    at the top should show the SQL queries for the three `QuerySets`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了列出的查询，那么没有列出的预期查询呢？缺少的查询是由于`QuerySets`的惰性评估属性和列出`sql_queries`内容的`comment`块的确切放置位置的组合。我们将`comment`块放在主页的`content`块顶部，以便在查看页面源时轻松找到SQL查询信息。模板在视图创建三个`QuerySets`之后呈现，因此似乎放在顶部的注释应该显示三个`QuerySets`的SQL查询。
- en: However, `QuerySets` are lazy; simply creating a `QuerySet` does not immediately
    cause interaction with the database. Rather, sending the SQL to the database is
    delayed until the `QuerySet` results are actually accessed. For the survey home
    page, that does not happen until the parts of the template that loop through each
    `QuerySet` are rendered. Those parts are all below where we placed the `sql_queries`
    information, so the corresponding SQL queries had not yet been issued. The fix
    for this is to move the placement of the `comment` block to the very bottom of
    the `content` block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`QuerySets`是惰性的；仅创建`QuerySet`并不会立即导致与数据库的交互。相反，直到实际访问`QuerySet`结果之前，将SQL发送到数据库是延迟的。对于调查主页，直到循环遍历每个`QuerySet`的模板部分被渲染之前，这并不会发生。这些部分都在我们放置`sql_queries`信息的下面，因此相应的SQL查询尚未发出。解决此问题的方法是将`comment`块的放置位置移动到`content`块的最底部。
- en: When we do that we should also fix two other issues with the query display.
    First, notice that the query displayed above has `&gt;` shown instead of the `>`
    symbol that would actually have been in the query sent to the database. Furthermore,
    if the database in use is one (such as PostgreSQL) that uses straight quotes instead
    of back quotes for quoting, all of the back quotes in the query would be shown
    as `&quot;`. This is due to Django's automatic escaping of HTML markup characters.
    This is unnecessary and hard to read in our HTML comment, so we can suppress it
    by sending the `sql` query value through the `safe` filter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们还应该修复查询显示的另外两个问题。首先，请注意上面显示的查询中显示的是`&gt;`而不是实际发送到数据库的`>`符号。此外，如果使用的数据库是使用直引号而不是反引号进行引用的数据库（例如PostgreSQL），查询中的所有反引号都将显示为`&quot;`。这是由于Django自动转义HTML标记字符造成的。这在我们的HTML注释中是不必要且难以阅读的，因此我们可以通过将`sql`查询值通过`safe`过滤器发送来抑制它。
- en: Second, the query is very long. In order to avoid needing to scroll to the right
    in order to see the entire query, we can also filter the `sql` value through `wordwrap`
    to introduce some line breaks and make the output more readable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，查询非常长。为了避免需要向右滚动才能看到整个查询，我们还可以通过`wordwrap`过滤器过滤`sql`值，引入一些换行，使输出更易读。
- en: 'To make these changes, remove the added comment block from the top of the `content`
    block in the `survey/home.html` template and instead change the bottom of this
    template to be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行这些更改，请从`survey/home.html`模板的`content`块顶部删除添加的注释块，而是将此模板的底部更改为：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we again reload the survey home page and view the source for the returned
    page, we will see the queries listed in a comment at the bottom:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次重新加载调查主页并查看返回页面的源代码，我们将在底部的注释中看到列出的查询：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That is good, those look like exactly what we expect to see for queries for
    the home page. Now that we seem to have some working template code to show queries,
    we will consider packaging up this snippet so that it can easily be reused elsewhere.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，看起来正是我们期望在主页查询中看到的内容。现在我们似乎有一些可以显示查询的工作模板代码，我们将考虑打包这个片段，以便可以轻松地在其他地方重用。
- en: Packaging the template query display for reuse
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包模板查询显示以便重用
- en: We've now got a small block of template code that we can put in any template
    to easily see what SQL queries were needed to produce a page. However, it is not
    so small that it can be easily re-typed whenever it might come in handy. Therefore,
    it would be good to package it up in a form where it can be conveniently included
    wherever and whenever it might be needed. The Django template `{% include %}`
    tag makes this easy to do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一小块模板代码，可以将其放在任何模板中，以便轻松查看生成页面所需的SQL查询。但是，它并不小到可以在需要时轻松重新输入。因此，最好将其打包成一种形式，可以在需要时方便地包含在任何地方。Django模板`{%
    include %}`标签使这一点变得很容易。
- en: Where should the snippet go? Note that this template snippet is completely general
    and not in any way tied to the survey application. While it would be easy to simply
    include it among the survey templates, putting it there will make it harder to
    reuse for future projects. A better approach is to put it in an independent application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段应该放在哪里？请注意，这个模板片段是完全通用的，与调查应用程序没有任何关联。虽然将其简单地包含在调查模板中很容易，但将其放在那里将使其在将来的项目中更难以重用。更好的方法是将其放在一个独立的应用程序中。
- en: Creating an entirely new application just for this one snippet may seem a bit
    extreme. However, it is common during development to create small utility functions
    or template snippets that don't really belong in the main application. So it is
    likely during development of a real project that there would be other such things
    that should logically be placed somewhere besides the main application. It's helpful
    to have someplace else to put them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个片段创建一个全新的应用程序可能看起来有点极端。然而，在开发过程中创建一些不真正属于主应用程序的小型实用函数或模板片段是很常见的。因此，在实际项目的开发过程中，可能会有其他类似的东西，它们在逻辑上应该放在主应用程序之外的某个地方。有一个地方可以放它们是很有帮助的。
- en: 'Let''s create a new Django application, then, to hold any general utility code
    that does not logically belong within the survey application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Django应用程序，用来保存一些通用的实用代码，这些代码在调查应用程序中并不合乎逻辑：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since its purpose is to hold general utility code, we've named the new application
    `gen_utils`. It can serve as a place to put any non-survey-specific code that
    seems like it might be potentially re-usable elsewhere. Note that as time goes
    on and more and more stuff accumulates in an application like this, it may become
    apparent that some subset of it would be useful to package into its own independent,
    self-contained application with a more descriptive name than `gen_utils`. But
    for now it is enough to start with one place to put utility code that is not really
    tied to the survey application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它的目的是保存通用实用代码，我们将新应用程序命名为`gen_utils`。它可以作为一个放置任何非调查特定代码的地方，看起来可能在其他地方有重复使用的潜力。请注意，随着时间的推移，如果在这样的应用程序中积累了越来越多的东西，可能会变得明显，其中的一些子集将有用，可以打包成一个独立的、自包含的应用程序，其名称比`gen_utils`更具描述性。但是现在，开始一个地方放置与调查应用程序没有真正关联的实用代码就足够了。
- en: 'Next, we can create a `templates` directory within `gen_utils`, and a `gen_utils`
    directory under `templates`, and create a file, `showqueries.html`, to hold the
    template snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`gen_utils`中创建一个`templates`目录，然后在`templates`下创建一个`gen_utils`目录，并创建一个文件`showqueries.html`来保存模板片段：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've made one change here from the previous code placed directly in the `survey/home.html`
    template, which is to place the entire HTML `comment` block inside an `{% if sql_qureies
    %}` block. If the `sql_queries` variable has not been included in the template
    context, then there is no reason to produce the comment at all.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对之前直接放在`survey/home.html`模板中的代码进行了一个改变，就是将整个HTML `comment`块放在了`{% if sql_qureies
    %}`块中。如果`sql_queries`变量没有包含在模板上下文中，那么就没有理由生成注释。
- en: As part of packaging code for reuse, it's also good practice to double-check
    and make sure that the code is truly reusable and not going to fail in odd ways
    if given unexpected or unusual input. Taking a look at that snippet, is there
    anything that might be found in an arbitrary `sql_queries` input that could cause
    a problem?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码重用的一部分，检查并确保代码确实可重用，并且不会在给定意外或异常输入时以奇怪的方式失败也是一个好习惯。看看那个片段，有没有什么可能在任意的`sql_queries`输入中引起问题的东西？
- en: The answer is yes. If a SQL query value contains the HTML end-of-comment delimiter,
    then the comment block will be terminated early. This could result in the browser
    rendering what was intended to be a comment as part of the page content displayed
    to the user. To see this, we can try inserting a model `filter` call that includes
    the HTML end-of-comment delimiter into the home page view code, and see what the
    browser shows.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。如果SQL查询值包含HTML注释结束符，则注释块将被提前终止。这可能导致浏览器将本来应该是注释的内容作为用户显示的页面内容的一部分。为了验证这一点，我们可以尝试在主页视图代码中插入一个包含HTML注释结束符的模型`filter`调用，然后查看浏览器显示的内容。
- en: 'But what is the HTML end-of-comment delimiter? You might guess that it is `-->`,
    but in fact it is just the two dashes in a row. Technically, the `<!` and `>`
    are defined as the beginning and end of markup declaration, while the dashes mark
    the beginning and end of the comment. Thus, a query that contains two dashes in
    a row should trigger the behavior we are worried about here. To test this, add
    this line of code to the `home` view:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是HTML注释结束符是什么？你可能会猜想是`-->`，但实际上它只是连续的两个破折号。从技术上讲，`<!`和`>`被定义为标记声明的开始和结束，而破折号标记注释的开始和结束。因此，包含连续两个破折号的查询应该触发我们在这里担心的行为。为了测试这一点，将这行代码添加到`home`视图中：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note nothing has to be done with the results of the call; the added code must
    simply ensure that the query containing the two dashes is actually sent to the
    database. This added line does that by retrieving the count of results matching
    the pattern containing two dashes. With that added line in the `home` view, Firefox
    will display the survey home page like so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不需要对调用的结果做任何处理；添加的代码只需确保包含两个破折号的查询实际上被发送到数据库。通过检索匹配包含两个破折号的模式的结果计数，添加的代码实现了这一点。有了`home`视图中的这一行，Firefox将显示调查主页如下：
- en: '![Packaging the template query display for reuse](img/7566_08_01(revised).jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![打包模板查询以便重用](img/7566_08_01(revised).jpg)'
- en: The two dashes in a row in a SQL query value caused Firefox to prematurely terminate
    the comment block, and data we had intended to be still inside the comment has
    appeared in the browser page. In order to avoid this, we need to ensure that two
    dashes in a row never appear in the SQL query values included in the comment block.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL查询值中连续出现的两个破折号导致Firefox过早终止了注释块，我们本打算仍然在注释中的数据出现在了浏览器页面上。为了避免这种情况，我们需要确保SQL查询值中不会连续出现两个破折号。
- en: A quick glance through the built-in Django filters doesn't reveal any that could
    be used to replace a string of two dashes with something else. The `cut` filter
    could be used to remove them, but simply removing them would make the `sql` value
    misleading as there would be no indication that the characters had been removed
    from the string. Therefore, it seems we will need to develop a custom filter for
    this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览内置的Django过滤器并没有发现可以用来替换两个破折号的字符串的过滤器。`cut`过滤器可以用来移除它们，但仅仅移除它们会使`sql`值具有误导性，因为没有指示这些字符已从字符串中移除。因此，似乎我们需要为此开发一个自定义过滤器。
- en: 'We will put the custom filter in the `gen_utils` application. Filters and template
    tags must be placed in a `templatetags` module in an application, so we must first
    create the `templatetags` directory. Then, we can put an implementation for a
    `replace_dashes` filter into a file named `gentags.py` within `gen_utils/templatetags`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将自定义过滤器放在`gen_utils`应用程序中。过滤器和模板标签必须放在应用程序的`templatetags`模块中，因此我们首先需要创建`templatetags`目录。然后，我们可以将`replace_dashes`过滤器的实现放入`gen_utils/templatetags`目录中的名为`gentags.py`的文件中：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The bulk of this code is the standard boilerplate `import`, `register` assignment,
    and `@register.filter` decoration needed to register the `replace_dashes` function
    so that it is available for use as a filter. The function itself simply replaces
    any occurrences of a pair of dashes in a string with `~~double-dash~~` instead.
    Since there is no way to escape the dashes so that they will not be interpreted
    as the end of the comment yet still appear as dashes, we replace them with a string
    describing what had been there. The last line marks the `replace_dashes` filter
    as safe, meaning it does not introduce any HTML markup characters that would need
    to be escaped in its output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的主要部分是标准的样板`import`，`register`赋值和`@register.filter`装饰，需要注册`replace_dashes`函数，以便它可以作为过滤器使用。函数本身只是用`~~double-dash~~`替换字符串中一对破折号的任何出现。由于没有办法转义破折号，以便它们不被解释为注释的结束，但仍然显示为破折号，我们用描述原内容的字符串替换它们。最后一行将`replace_dashes`过滤器标记为安全，这意味着它不会引入任何需要在输出中转义的HTML标记字符。
- en: 'We also need to change the template snippet in `gen_utils/showqueries.html`
    to load and use this filter for display of the SQL query values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改`gen_utils/showqueries.html`中的模板片段，以加载和使用此过滤器来显示SQL查询的值：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only changes here are the addition of the `{% load gentags %}` line and
    the addition of `replace_dashes` in the sequence of filters applied to `qdict.sql`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的变化是添加了`{% load gentags %}`一行，并在应用于`qdict.sql`的过滤器序列中添加了`replace_dashes`。
- en: 'Finally, we can remove the comment snippet from the `survey/home.html` template.
    Instead, we will put the new general snippet in the `survey/base.html` template,
    so this becomes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以从`survey/home.html`模板中删除注释片段。相反，我们将把新的通用片段放在`survey/base.html`模板中，因此变成：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Placing `{% include %}` in the base template will cause every template that
    inherits from base to automatically have the comment block added, assuming that
    the other conditions of `DEBUG` being turned on, the requesting IP address being
    listed in `INTERNAL_IPS`, and the response being rendered with a `RequestContext`,
    are met. We'd likely want to remove this before putting the application in a production
    environment, but during development it can come in handy to have easy automatic
    access to the SQL queries used to generate any page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础模板中放置`{% include %}`将导致每个从基础模板继承的模板自动添加注释块，假设`DEBUG`被打开，请求的IP地址被列在`INTERNAL_IPS`中，并且响应被使用`RequestContext`渲染。在将应用程序放入生产环境之前，我们可能想要删除这个功能，但在开发过程中，可以方便地自动访问用于生成任何页面的SQL查询。
- en: Testing the repackaged template code
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试重新打包的模板代码
- en: 'How well does the repackaged version of the code work? If we try to reload
    our survey home page now, we will find that we have forgotten a couple of things.
    The first attempt brings up a Django debug page:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的重新打包版本效果如何？如果我们现在尝试重新加载调查主页，我们会发现我们忘记了一些东西。第一次尝试会弹出一个Django调试页面：
- en: '![Testing the repackaged template code](img/7566_08_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_02.jpg)'
- en: This is an instance of one of the special debug pages mentioned in the last
    chapter. It is a `TemplateSyntaxError` resulting from an exception being raised
    during rendering. The original exception was caught and turned into a `TemplateSyntaxError`,
    and the original traceback is shown as part of the exception value. Looking at
    that, we can see that the original exception was `TemplateDoesNotExist`. For some
    reason, the `gen_utils/showqueries.html` template file was not found by the template
    loader.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一章提到的特殊调试页面的一个实例。这是由于在渲染过程中引发了异常而导致的`TemplateSyntaxError`。原始异常被捕获并转换为`TemplateSyntaxError`，原始回溯作为异常值的一部分显示出来。通过查看原始回溯，我们可以看到原始异常是`TemplateDoesNotExist`。由于某种原因，模板加载器没有找到`gen_utils/showqueries.html`模板文件。
- en: Paging further down on the debug page received here, we learn why the template
    engine behavior of wrapping original exceptions in a `TemplateSyntaxError` can
    sometimes be aggravating. Because the exception that was ultimately raised was
    a `TemplateSyntaxError`, not a `TemplateDoesNotExist`, this debug page does not
    have the template loader postmortem that would detail exactly what template loaders
    were tried, and what files they attempted to load while searching for `gen_utils/showqueries.html`.
    So, we've lost some helpful debug information due to the way `TemplateSyntaxError`
    exceptions are used to wrap others.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里接收到的调试页面中进一步翻页，我们了解到模板引擎将原始异常包装在`TemplateSyntaxError`中的行为有时会令人恼火。因为最终引发的异常是`TemplateSyntaxError`而不是`TemplateDoesNotExist`，这个调试页面没有模板加载器事后报告，该报告将详细说明尝试了哪些模板加载器，以及它们在搜索`gen_utils/showqueries.html`时尝试加载了哪些文件。因此，由于`TemplateSyntaxError`异常用于包装其他异常的方式，我们丢失了一些有用的调试信息。
- en: If we needed to, we could force production of the template loader postmortem
    for this template file by attempting to render it directly from a view, instead
    of by including it in another template. So we could, with a little work, get the
    information that has unfortunately not been included in this particular debug
    page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，我们可以通过尝试直接从视图中渲染它，而不是将其包含在另一个模板中，来强制生成此模板文件的模板加载器事后报告。因此，通过一点工作，我们可以获得这个特定调试页面中不幸未包含的信息。
- en: 'But in this case it is not necessary, since the reason for the exception is
    not particularly obscure: we didn''t do anything to ensure that the templates
    in the new `gen_utils` application would be found. We did not include `gen_utils`
    in `INSTALLED_APPS` so that its `templates` directory would be searched by the
    application template loader, nor did we put the path to the `gen_utils templates`
    directory into the `TEMPLATE_DIRS` setting. We need to do one of these things
    in order to have the new template file found. Since `gen_utils` also now has a
    filter, and in order for that to be loaded `gen_utils` will need to be in `INSTALLED_APPS`,
    we will fix the `TemplateDoesNotExist` exception by including `gen_utils` in `INSTALLED_APPS`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下并不需要，因为异常的原因并不特别隐晦：我们没有采取任何措施确保新的`gen_utils`应用程序中的模板能够被找到。我们没有将`gen_utils`包含在`INSTALLED_APPS`中，以便应用程序模板加载程序可以搜索其`templates`目录，也没有将`gen_utils模板`目录的路径放入`TEMPLATE_DIRS`设置中。我们需要做这些事情中的一件，以便找到新的模板文件。由于`gen_utils`现在也有一个过滤器，并且为了加载该过滤器，`gen_utils`需要被包含在`INSTALLED_APPS`中，我们将通过将`gen_utils`包含在`INSTALLED_APPS`中来修复`TemplateDoesNotExist`异常。
- en: 'Once we make that change, does the new code work? Not quite. Attempting to
    reload the page now brings up a different debug page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出了这个改变，新的代码工作了吗？并没有。尝试重新加载页面现在会出现不同的调试页面：
- en: '![Testing the repackaged template code](img/7566_08_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_03.jpg)'
- en: 'This one is a little more mysterious. The displayed template is `gen_utils/showqueries.html`,
    so we have gotten farther than in the previous case. But for some reason, the
    attempt to `{% load gentags %}` is failing. The error message states:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点神秘。显示的模板是`gen_utils/showqueries.html`，所以我们比之前的情况更进一步了。但出于某种原因，尝试`{% load
    gentags %}`失败了。错误信息显示：
- en: '**''gentags'' is not a valid tag library: Could not load template library from
    django.templatetags.gentags, No module named gentags**.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**''gentags''不是有效的标签库：无法从django.templatetags.gentags加载模板库，没有名为gentags的模块**。'
- en: This is one of the rare cases where you do not want to entirely believe what
    the error message seems to be saying. It seems to be implying that the problem
    is that there is no `gentags.py` file in `django.templatetags`. A natural next
    thought may be that it is required to place custom template tag and filter libraries
    inside Django's own source tree. However, that would be a very odd requirement
    and the documentation clearly contradicts it, since it states that custom tags
    and filters should be placed in the application's `templatetags` directory. Are
    we supposed to use something other than a plain `{% load %}` tag to force Django
    to search beyond its own `templatetags` directory for a tag library?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个罕见的情况，你不希望完全相信错误消息似乎在说什么。它似乎在暗示问题是`django.templatetags`中没有`gentags.py`文件。一个自然的下一个想法可能是，需要将自定义模板标签和过滤器库放在Django自己的源树中。然而，这将是一个非常奇怪的要求，而且文档明确地与之相矛盾，因为它指出自定义标签和过滤器应该放在应用程序的`templatetags`目录中。我们应该使用除了普通的`{%
    load %}`标签以外的东西来强制Django搜索其自己的`templatetags`目录之外的标签库吗？
- en: No, in this case the error is just misleading. Although `django.templatetags`
    is the only module named in the error message, in fact the Django code attempted
    to load `gentags` from a `templatetags` directory under each application listed
    in `INSTALLED_APPS`. So the question is not why did Django fail to look for `gentags`
    under the `gen_utils/templatetags` directory, but why did an attempt to load `gentags`
    from `genutils.templatetags` fail?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这种情况下错误只是误导。尽管错误消息中只命名了`django.templatetags`模块，但实际上Django代码尝试从`INSTALLED_APPS`中列出的每个应用程序的`templatetags`目录中加载`gentags`。因此问题不在于Django为什么未能在`gen_utils/templatetags`目录下查找`gentags`，而是为什么从`genutils.templatetags`加载`gentags`失败？
- en: 'We can attempt to answer that question by trying the same code that Django
    is running during `{% load %}` from a Python shell session:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试回答这个问题，尝试在Python shell会话中运行与`{% load %}`相同的Django代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sure enough, an attempt to import `gentags` from `gen_utils.templatetags` is
    failing. Python claims the `templatetags` module does not exist. But the directory
    certainly exists, and `gentags.py` exists, so what is missing? The answer is an
    `__init__.py` file in that directory to make Python recognize it as a module.
    Creating that file and re-trying the import from the shell shows that the import
    will now work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，尝试从`gen_utils.templatetags`导入`gentags`失败了。Python声称`templatetags`模块不存在。但这个目录肯定是存在的，`gentags.py`也存在，那么缺少什么呢？答案是在该目录中创建一个`__init__.py`文件，使Python将其识别为一个模块。创建该文件并从shell重新尝试导入将会显示导入现在可以工作。
- en: 'However, attempting to simply reload the page in a browser causes the same
    debug page to be re-displayed. This is also one of the rare cases where the development
    server needs to be manually stopped and re-started in order for it to pick up
    on the changes made. That done, we can finally re-load the survey home page and
    see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试在浏览器中简单地重新加载页面会导致相同的调试页面重新显示。这也是开发服务器需要手动停止和重新启动才能接受更改的罕见情况之一。完成这些操作后，我们最终可以重新加载调查首页并看到：
- en: '![Testing the repackaged template code](img/7566_08_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![测试重新打包的模板代码](img/7566_08_04.jpg)'
- en: 'We''re back to the page being served without an exception being raised, and
    there is no more stray debug information from the `sql_queries` being included
    in an HTML comment. If we look further, at the HTML source for the page, we will
    see something like the following at the bottom:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了页面被提供而没有引发异常的情况，也不再有`sql_queries`的杂散调试信息包含在HTML注释中。如果我们进一步查看页面的HTML源代码，底部会看到类似以下内容：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That looks good. The `replace_dashes` filter successfully got rid of the two
    dashes in a row, so the browser no longer thinks the comment block was terminated
    before it was intended to be. Now we can move on to checking the SQL queries needed
    to produce the other survey pages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。`replace_dashes`过滤器成功地去掉了两个连字符，因此浏览器不再认为注释块在预期之前被终止。现在我们可以继续检查生成其他调查页面所需的SQL查询。
- en: SQL queries for the active Survey form display page
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于活动调查表单显示页面的SQL查询
- en: 'Clicking on the link to the one active survey brings up the active survey page
    for that survey:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单击链接到一个活动调查会显示该调查的活动调查页面：
- en: '![SQL queries for the active Survey form display page](img/7566_08_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![用于活动调查表单显示页面的SQL查询](img/7566_08_05.jpg)'
- en: 'Looking at the source for this page, we see that six SQL queries were needed
    to produce it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此页面的源代码，我们看到需要六个SQL查询才能生成它：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Can we match up those queries to the code used to produce the page? Yes, in
    this case it is reasonably straightforward to see where each query comes from.
    The very first query is looking up a survey based on its primary key, and corresponds
    to the `get_object_or_404` call in the very first line in the `survey_detail`
    view:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将这些查询与用于生成页面的代码进行匹配？是的，在这种情况下，可以相对容易地看到每个查询来自哪里。第一个查询是根据其主键查找调查，并对应于`survey_detail`视图中第一行中的`get_object_or_404`调用：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since this is an active survey, the thread of control then proceeds to the
    `display_active_survey` function, which contains the following code to build the
    forms for the page:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个活动调查，控制线程随后转到`display_active_survey`函数，其中包含以下代码来构建页面的表单：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The call to `enumerate(survey.question_set.all())` is responsible for the second
    SQL query for this page, which retrieves all of the questions for the survey being
    displayed. The call to `q.answer_set.count()` within the `for` loop explains the
    third and fourth SQL queries, which retrieve the count of answers for each question
    in the survey.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`enumerate(survey.question_set.all())`负责此页面的第二个SQL查询，它检索显示的调查的所有问题。`for`循环中的`q.answer_set.count()`解释了第三和第四个SQL查询，它们检索了调查中每个问题的答案计数。
- en: 'The last two queries, then, retrieve the set of answers for each question in
    the survey. We might first think that these queries are issued when the `QuestionVoteForm`
    for each question in the survey is created. The `__init__` routine for a `QuestionVoteForm`
    contains this line, to initialize the set of answers for the question:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后两个查询检索了调查中每个问题的答案集。我们可能首先认为这些查询是在创建调查中每个问题的“QuestionVoteForm”时发出的。 “QuestionVoteForm”的`__init__`例程包含此行，以初始化问题的答案集：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, that line of code does not result in a call to the database. It simply
    sets the `queryset` attribute for the form's `answer` field to a `QuerySet` value.
    Since `QuerySets` are lazy, this does not cause a database hit. This is confirmed
    by the fact that both queries that request `COUNT(*)` are issued before the queries
    that retrieve the actual answer information. If the creation of `QuestionVoteForm`
    caused the retrieval of the answer information, then the last two queries would
    not be last, but rather would be interleaved with the `COUNT(*)` queries. The
    trigger for issuing the queries that retrieve the answer information, then, is
    the rendering of the answer values in the `survey/active_survey.html` template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该行代码并不会导致对数据库的调用。它只是将表单的`answer`字段的`queryset`属性设置为`QuerySet`值。由于`QuerySets`是惰性的，这不会导致数据库访问。这得到了证实，即请求`COUNT(*)`的两个查询是在检索实际答案信息的查询之前发出的。如果创建`QuestionVoteForm`导致检索答案信息，那么最后两个查询将不会是最后的，而是将与`COUNT(*)`查询交错。然后，触发检索答案信息的查询是在`survey/active_survey.html`模板中呈现答案值时。
- en: If we were focused on optimization, at this point we might try to see if we
    could reduce the number of queries needed for this page. Retrieving the count
    of answers and then the answer information itself in two separate queries seems
    inefficient compared to simply retrieving the answer information and deriving
    the count based on the returned information. It seems like we could produce this
    page with four queries instead of six.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专注于优化，此时我们可能会尝试看看是否可以减少此页面所需的查询数量。在两个单独的查询中检索答案的计数，然后检索答案信息本身似乎效率低下，与仅检索答案信息并根据返回的信息推导计数相比。看起来我们可以用四个查询而不是六个查询来生成此页面。
- en: However, since we are focused on understanding the current behavior as an aid
    to debugging, we are not going to divert into an optimization discussion here.
    Even if we were developing a real project, at this point in development it would
    not be a good time to work on such optimizations. The inefficiency here is not
    so bad as to be termed a bug, so it is best just to note it as a possible thing
    to look at in the future, when a full picture of the overall performance of the
    application can be determined. At that point the inefficiencies that are the most
    expensive are the ones that will be worth taking the time to investigate improving.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们专注于理解当前行为以帮助调试，我们不会在这里转向优化讨论。即使我们正在开发一个真正的项目，在开发的这个阶段，现在不是进行此类优化的好时机。这里的低效并不糟糕到被称为错误，所以最好只是将其记录为将来可能要查看的可能事项，当可以确定应用程序的整体性能的全貌时。在那时，最昂贵的低效将值得花时间进行改进的。
- en: SQL queries for posting survey answers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布调查答案的SQL查询
- en: 'If we now choose some answers for the survey questions and press the **Submit**
    button, we get the **Thanks** page in response:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在为调查问题选择了一些答案并按下**提交**按钮，我们会收到**感谢**页面的响应：
- en: '![SQL queries for posting survey answers](img/7566_08_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![用于发布调查答案的SQL查询](img/7566_08_06.jpg)'
- en: 'Looking at the source for this page, we find a single SQL query, to retrieve
    a `survey` given the primary key:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此页面的源代码，我们发现了一个单独的SQL查询，以检索给定主键的`survey`：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The line of code associated with that query is obvious; it is the `get_object_or_404`
    in the `survey_thanks` view:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与该查询相关的代码行是显而易见的；它是`survey_thanks`视图中的`get_object_or_404`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But what about all the SQL queries involved in processing the form data when
    it was submitted? Long before the `survey_thanks` view was called, `display_active_survey`
    must have run in order to receive the posted form data and update the database
    for the selected answers. Yet we don't see any of the SQL queries needed for that
    among the queries shown for the thanks page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is because the `display_active_survey` function, in the
    case where the form processing is successful and the database is updated, does
    not render a template directly but rather returns an `HttpResponseRedirect`. The
    web browser, on receiving the HTTP redirect response, automatically fetches the
    location identified in the redirect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Thus, there are two full request/response cycles that take place in between
    pressing the **Submit** button on the browser and seeing the thanks page appear.
    The thanks page itself can show the SQL queries that were executed during its
    (the second) request/response cycle, but it cannot show any of the ones that happened
    in the first request/response cycle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: That's disappointing. At this point, we've gone to a fair amount of trouble
    developing what seemed at first like it was going to be a quite simple little
    bit of utility code. Now, we find that it is not going to work for some of the
    most interesting views in an application—the ones that actually update the database.
    What do we do?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We certainly don't want to just give up on seeing the SQL queries for pages
    that successfully process posted data. But nor do we want to spend much more development
    effort on this utility code. Although we have learned a few things along the way,
    we've started to stray a bit too much from our main application. Fortunately,
    we don't need to do either of these. Instead, we can simply install and start
    using an already-developed general debugging tool for Django applications, the
    Django Debug Toolbar. This tool is the focus of the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The Django Debug Toolbar
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rob Hudson's Django Debug Toolbar is a very useful general purpose debugging
    tool for Django applications. As with the code we developed earlier in this chapter,
    it lets you see the SQL queries that were needed to produce a page. However, as
    we will see, it also goes far beyond that, providing easy access to much more
    information about the SQL queries and other aspects of request processing. Furthermore,
    the debug toolbar has a far more advanced way of displaying the information than
    simply embedding it in HTML comments. The capabilities are best shown by example,
    so we will immediately proceed with installing the toolbar.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Django Debug Toolbar
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolbar can be found on the Python package index site: [http://pypi.python.org/pypi/django-debug-toolbar](http://pypi.python.org/pypi/django-debug-toolbar).
    Once installed, activating the debug toolbar in a Django project is accomplished
    with the addition of just a couple of settings.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: First, the debug toolbar middleware, `debug_toolbar.middleware.DebugToolbarMiddleware`,
    must be added to the `MIDDLEWARE_CLASSES` setting. The documentation for the toolbar
    notes that it should be placed after any other middleware that encodes the response
    content, so it is best to place it last in the middleware sequence.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `debug_toolbar` application needs to be added to `INSTALLED_APPS`.
    The `debug_toolbar` application uses Django templates to render its information,
    thus it needs to be listed in `INSTALLED_APPS` so that its templates will be found
    by the application template loader.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Third, the debug toolbar requires that the requesting IP address be listed in
    `INTERNAL_IPS`. Since we already made this settings change earlier in the chapter,
    nothing needs to be done now for this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the debug toolbar is displayed only when `DEBUG` is `True`. We've been
    running with debug turned on, so again we don't have to make any changes here.
    Note also that the debug toolbar allows you to customize under what conditions
    the debug toolbar is displayed. It's possible, then, to set things up so that
    the toolbar will be displayed for requesting IP addresses not in `INTERNAL_IPS`
    or when debug is not turned on, but for our purposes the default configuration
    is fine so we will not change anything.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is not required is for the application itself to use a `RequestContext`
    in order for things such as the SQL query information to be available in the toolbar.
    The debug toolbar runs as middleware, and thus is not dependent on the application
    using a `RequestContext` in order for it to generate its information. Thus, the
    changes made to the survey views to specify `RequestContexts` on `render_to_response`
    calls would not have been needed if we started off first with the Django Debug
    Toolbar.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Debug toolbar appearance
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the debug toolbar is added to the middleware and installed applications
    settings, we can see what it looks like by simply visiting any page in the survey
    application. Let''s start with the home page. The returned page should now look
    something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug toolbar appearance](img/7566_08_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Note this screenshot shows the appearance of the 0.8.0 version of the debug
    toolbar. Earlier versions looked considerably different, so if your results do
    not look like this you may be using a different version than 0.8.0\. The version
    that you have will most likely be newer than what was available when this was
    written, and there may be additional toolbar panels or functions that are not
    covered here.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the debug toolbar appears on the right-hand side of the browser
    window. It consists of a series of panels that can be individually enabled or
    disabled by changing the toolbar configuration. The ones shown here are the ones
    that are enabled by default.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Before taking a closer look at some of the individual panels, notice that the
    toolbar contains an option to hide it at the top. If **Hide** is selected, the
    toolbar reduces itself to a small tab-like indication to show that it is present:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug toolbar appearance](img/7566_08_08.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: This can be very useful for cases where the expanded version of the toolbar
    obscures application content on the page. All of the information provided by the
    toolbar is still accessible, after clicking again on the **DjDT** tab; it is just
    out of the way for the moment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Most of the panels will provide detailed information when they are clicked.
    A few also provide summary information in the main toolbar display. As of debug
    toolbar version 0.8.0, the first panel listed, **Django Version**, only provides
    summary information. There is no more detailed information available by clicking
    on it. As you can see in the screenshot, Django 1.1.1 is the version in use here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Note that the current latest source version of the debug toolbar already provides
    more information for this panel than the 0.8.0 release. Since 0.8.0, this panel
    has been renamed to **Versions**, and can be clicked to provide more details.
    These additional details include version information for the toolbar itself and
    for any other installed Django applications that provide version information.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The other three panels that show summary information are the **Time**, **SQL**,
    and **Logging** panels. Thus, we can see at a glance from the first appearance
    of the page that 60 milliseconds of CPU time were used to produce this page (111
    milliseconds total elapsed time), that the page required four queries, which took
    1.95 milliseconds, and that zero messages were logged during the request.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will dig into exactly what information is provided
    by each of the panels when clicked. We'll start first with the SQL panel, since
    it is one of the most interesting and provides the same information (in addition
    to a lot more) that we worked earlier in this chapter to access on our own.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The SQL panel
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we click on the **SQL** section of the debug toolbar, the page will change
    to:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: At a glance, this is a much nicer display of the SQL queries for the page than
    what we came up with earlier. The queries themselves are highlighted so that SQL
    keywords stand out, making them easier to read. Also, since they are not embedded
    inside an HTML comment, their content does not need to be altered in any way—there
    was no need to change the content of the query containing the double dash in order
    to avoid it causing display problems. (Now would probably be a good time to remove
    that added query, before we forget why we added it.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the times listed for each query are more specific than what
    was available in Django's default query history. The debug toolbar replaces Django's
    query recording with its own, and provides timings in units of milliseconds instead
    of seconds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The display also includes a graphical representation of how long each query
    took, in the form of horizontal bars that appear above each query. This representation
    makes it easy to see when there are one or more queries that are much more expensive
    than the others. In fact, if a query takes an excessive amount of time, its bar
    will be colored red. In this case, there is not a great deal of difference in
    the query times, and none took particularly long, so all the bars are of similar
    length, and are colored gray.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Digging deeper, some of the information we had to manually figure out earlier
    in this chapter is just a click away on this SQL query display. Specifically,
    the answer to the question of what line of our code triggered a particular SQL
    query to be issued. Each of the displayed queries has a **Toggle Stacktrace**
    option, which when clicked will show the stack trace associated with the query:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Here we can see that all queries are made by the `home` method in the survey
    `views.py` file. Note that the toolbar filters out levels in the stack trace that
    are within Django itself, which explains why each of these has only one level
    shown. The first query is triggered by **Line 61**, which contains the `filter`
    call added to test what will happen if a query containing two dashes in a row
    was logged. The remaining queries are all attributed to **Line 66**, which is
    the last line of the `render_to_response` call in the `home` view. These queries,
    as we figured out earlier, are all made during the rendering of the template.
    (Your line numbers may vary from those shown here, depending on where in the file
    various functions were placed.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this SQL query display makes available information that we had not
    even gotten around to wanting yet. Under the **Action** column are links to **SELECT**,
    **EXPLAIN**, and **PROFILE** each query. Clicking on the **SELECT** link shows
    what the database returns when the query is actually executed. For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Similarly, clicking on **EXPLAIN** and **PROFILE** displays what the database
    reports when asked to explain or profile the selected query, respectively. The
    exact display, and how to interpret the results, will differ from database to
    database. (In fact, the **PROFILE** option is not available with all databases—it
    happens to be supported by the database in use here, MySQL.) Interpreting the
    results from **EXPLAIN** and **PROFILE** is beyond the scope of what's covered
    here, but it is useful to know that if you ever need to dig deep into the performance
    characteristics of a query, the debug toolbar makes it easy to do so.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We've now gotten a couple of pages deep into the SQL query display. How do we
    get back to the actual application page? Clicking on the circled **>>** at the
    upper-right of the main page display will return to the previous SQL query page,
    and the circled **>>** will turn into a circled **X**. Clicking the circled **X**
    on any panel detail page closes the details and returns to displaying the application
    data. Alternatively, clicking again on the panel area on the toolbar for the currently
    displayed panel will have the same effect as clicking on the circled symbol in
    the display area. Finally, if you prefer using the keyboard to the mouse, pressing
    *Esc* has the same effect as clicking the circled symbol.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completely explored the SQL panel, let's take a brief look
    at each of the other panels provided by the debug toolbar.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The Time panel
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on the **Time** panel brings up more detailed information on where
    time was spent during production of the page:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![The Time panel](img/7566_08_12.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: The total CPU time is split between user and system time, the total elapsed
    (wall clock) time is listed, and the number of voluntary and involuntary context
    switches are displayed. For a page that is taking too long to generate, these
    additional details about where the time is being spent can help point towards
    a cause.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Note that the detailed information provided by this panel comes from the Python
    `resource` module. This is a Unix-specific Python module that is not available
    on non-Unix-type systems. Thus on Windows, for example, the debug toolbar time
    panel will only show summary information, and no further details will be available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The Settings panel
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clicking on **Settings** brings up a scrollable display of all the settings
    in effect. The code used to create this display is identical to the code used
    to display the settings on a Django debug page, so the display here will be identical
    to what you would see on a debug page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Headers panel
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **HTTP Headers** brings up a display of all the HTTP headers for
    the request:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP Headers panel](img/7566_08_13.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: This is a subset of the information available in the **META** section of a debug
    page. As mentioned in the previous chapter, the `request.META` dictionary contains
    all of the HTTP headers for a request in addition to other information that has
    nothing to do with the request, since `request.META` is initially copied from
    the `os.environ` dictionary. The debug toolbar has chosen to filter the displayed
    information to include only information pertinent to the HTTP request, as shown
    in the screenshot.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The Request Vars panel
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Request Vars** brings up a display of cookies, session variables,
    GET variables, and POST data for the request. Since the survey application home
    page doesn''t have any information to display for any of those, the **Request
    Vars** display for it is not very interesting. Instead, here is an example from
    the admin application, which does use a session, and so it actually has something
    to display:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![The Request Vars panel](img/7566_08_14.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Here you can see the `sessionid` cookie that was set as a result of the admin
    application using the `django.contrib.sessions` application, and you can also
    see the individual session variables that have been set in the session.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The Templates panel
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Templates** brings up a display of information about template
    processing for the request. Returning to the survey home page as an example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![The Templates panel](img/7566_08_15.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: The **Template paths** section lists the paths specified in the `TEMPLATE_DIRS`
    setting; since we have not added anything to that setting, it is empty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The **Templates** section shows all of the templates rendered for the response.
    Each template is listed, showing the name specified by the application for rendering
    first. Clicking on this name will bring up a display of the actual template file
    contents. Under the application-specified name is the full file path for the template.
    Finally, each template also has a **Toggle Context** link that can be used to
    see the details of the context used by each of the rendered templates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The **Context processors** section shows all of the installed context processors.
    Under each is a **Toggle Context** link that when clicked will show the context
    variables that the associated context processor adds to the context.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note that the context processors are listed regardless of whether the application
    used a `RequestContext` to render the response. Thus, their being listed on this
    page does not imply that the variables they set were added to the context for
    this particular response.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The Signals panel
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Signals** brings up a display of the signal configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![The Signals panel](img/7566_08_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: All of the defined Django signals are listed. For each, the arguments provided
    are shown along with the receivers that have been connected to the signal.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Note that this display does not indicate anything about what signals were actually
    triggered during the production of the current page. It simply shows how the signals
    are configured.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The Logging panel
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the **Logging** panel shows any messages sent via Python's `logging`
    module during the course of the request processing. Since we have not yet investigated
    using logging in the survey application, and since as of Django 1.1, Django itself
    does not use the Python logging module, there is nothing for us to see on this
    panel yet.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Redirect handling by the debug toolbar
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now recall the reason we started investigating the debug toolbar: we found
    that our original approach to tracking SQL queries for a page did not work for
    pages that returned an HTTP redirect instead of rendering a template. How does
    the debug toolbar handle this better? To see this, click on the **Television Trends**
    link on the home page, select answers for the two questions, and press **Submit**.
    The result will be:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_17.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'This page shows an example of why it is sometimes necessary to use the **Hide**
    option on the toolbar, since the toolbar itself obscures part of the message on
    the page. Hiding the toolbar shows that the full message is:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**The Django Debug Toolbar has intercepted a redirect to the above URL for
    debug viewing purposes. You can click the above link to continue with the redirect
    as normal. If you''d like to disable this feature, set the DEBUG_TOOLBAR_CONFIG
    dictionary''s key INTERCEPT_REDIRECTS to False.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'What the debug toolbar has done here is intercepted the redirect request and
    replaced it with a rendered response containing a link to the location specified
    in the original redirect. The toolbar itself is still in place and available to
    investigate whatever information we might like to see about the processing of
    the request that generated the redirect. For example, we can click on the **SQL**
    section and see:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_18.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: These are the SQL queries that were needed to process the inbound posted form.
    Not surprisingly, the first four are exactly the same as what we saw for generating
    the form in the first place, since the same code path is initially followed for
    both GET and POST requests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'It is only after those queries are issued that the `display_active_survey`
    view has different code paths for GET and POST. Specifically, in the case of a
    POST, the code is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The fifth and sixth queries listed on this page are retrieving the specific
    answer instances that were selected on the submitted form. Unlike the GET case,
    where all answers for a given question were being retrieved in the fifth and sixth
    queries, these queries specify an answer `id` in the SQL WHERE clause as well
    as a question `id`. In the POST case, it is not necessary to retrieve all answers
    for a question; it is sufficient to retrieve only the one that was chosen.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the stack trace for these queries shows that they are resulting from
    the `if not qf.is_valid()` line of code. This makes sense, since in addition to
    validating the input, the `is_valid` method normalizes the posted data before
    placing it in the form's `cleaned_data` attribute. In the case of a `ModelChoiceField`,
    the normalized value is the chosen model object instance, so it is necessary for
    the validation code to retrieve the chosen object from the database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'After both submitted forms are found to be valid, the `else` leg of this code
    runs. Here, the vote count for each chosen answer is incremented, and the updated
    `answer` instance is saved to the database. This code, then, must be responsible
    for the final four queries previously shown. This can be confirmed by checking
    the stack trace for those four queries: all point to the `answer.save()` line
    of code.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: But why are four SQL statements, two SELECT and two UPDATE, needed to save two
    answers to the database? The UPDATE statements are self-explanatory, but the SELECT
    statements that precede them are a bit curious. In each case, the constant 1 is
    selected from the `survey_answer` table with a WHERE clause specifying a primary
    key value that matches the `survey` that is in the process of being saved. What
    is the intent of this query?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: What the Django code is doing here is attempting to determine if the `answer`
    being saved already exists in the database or if it is new. Django can tell by
    whether any results are returned from the SELECT if it needs to use an UPDATE
    or an INSERT when saving the model instance to the database. Selecting the constant
    value is more efficient than actually retrieving the result when the only information
    needed is whether the result exists.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: You might think the Django code should know, just based on the fact that the
    primary key value is already set for the model instance, that the instance reflects
    data that is already in the database. However, Django models can use manually-assigned
    primary key values, so the fact that the primary key value has been assigned does
    not guarantee the model has already been saved to the database. Therefore, there
    is an extra SELECT to determine the model status before saving the data.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The survey application code, though, certainly knows that all of the `answer`
    instances it is saving when processing a survey response are already saved in
    the database. When saving, the survey code can indicate that the instance must
    be saved via an UPDATE and not an INSERT by specifying `force_update` on the save
    call:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we make that change and try submitting another survey, we see that the SELECT
    queries have been eliminated from processing for this case, reducing the total
    number of queries needed from 10 to 8:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_19.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: (Yes, I realize that earlier I said now was not the time for making optimizations,
    yet here I went ahead and made one. This one was just too easy to pass up.)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered all of the panels displayed by default by the Django Debug
    Toolbar, and seen how its default handling of returned redirects allows investigation
    of the processing that led up to the redirect. It is a very flexible tool: it
    supports adding panels, changing what panels are displayed, changing when the
    toolbar is displayed, and configuration of various other options. Discussing all
    of this is beyond the scope of what is covered here. Hopefully what has been covered
    gives you a taste for the power of this tool. If you are interested in learning
    more details on how to configure it, the README linked from its home page is a
    good place to start.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: For now we will leave the Django Debug Toolbar and continue with a discussion
    of how to track the internal state of our application code through logging. For
    this we will want to first see how the logging appears without the toolbar, so
    at this point we should comment out the toolbar middleware in `settings.py`. (Note
    that it is not necessary to remove the `debug_toolbar` listing from `INSTALLED_APPS`,
    since this is only necessary for the application template loader to find templates
    specified by the middleware.)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Tracking internal code state
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes even all of the information available from a tool like the Django
    Debug Toolbar is not enough to figure out what is going wrong to produce incorrect
    results during processing of a request. The problem probably lies somewhere in
    the application code, but from visual inspection we just cannot figure out what
    is wrong. To solve the problem we need to get more information about the internal
    state of the application code. Perhaps we need to see what the flow of control
    is through the functions in the application, or see what values are calculated
    for some intermediate results that ultimately cause the code to go down a wrong
    path.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: How do we get this kind of information? One way is to run the code under a debugger,
    and actually step through it line by line to see what it is doing. This approach
    will be covered in detail in the next chapter. It is very powerful, but can be
    time-consuming and is not practical in all situations. For example, it is difficult
    to use for problems that crop up only during production.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to get the code to report, or log, what it is doing. This is
    the approach that will be covered in this section. This approach does not provide
    access to the full range of information that would be available under a debugger,
    but with good choices of what to log, it can provide enough clues to solve many
    problems. It can also be used more easily for production-only problems than the
    approach of running under a debugger.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Resist the urge to sprinkle prints
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running under the development server, the output from `print` appears on
    the console, so it is easily accessible. Thus, when faced with some Django application
    code that is misbehaving during development, it is tempting to simply start adding
    ad-hoc `print` statements at key points in an attempt to figure out what is going
    on inside the code. While very tempting, it is usually a bad idea.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Why is it a bad idea? First, the problem rarely becomes obvious with just one
    or two `print` statements. It may seem at first that if we just know if the code
    gets to here or there, all will be clear. But it isn't, and we wind up adding
    more and more `print` statements, perhaps printing out values of variables, and
    both the code itself and the development server console become a mess of ad-hoc
    debug information.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Then, once the problem is solved, all of those `print` statements need to be
    removed. We generally don't want them cluttering up either the code or the console
    with their output. Removing them all is a nuisance, but necessary, since some
    production environments disallow access to `sys.stdout`. Thus, a stray `print`
    left over from development debugging can cause a server error during production.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the same or a similar problem comes up again, and it was solved in
    the past by the "sprinkle `print`" method, virtually all of the work done before
    may need to be re-done again in order to figure out what is wrong this time. The
    previous experience might give us a better idea of what `print` statements to
    put where, but if we've already deleted them after solving the first problem,
    a fair amount of work may be involved in re-doing essentially the same thing for
    the next variant of the problem that arises. This is a waste of effort.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: This sequence highlights a few main problems with the "sprinkle `print`" method
    of development debugging. First, the developer needs to decide, right at the point
    where the `print` is added, under what conditions it should be produced and where
    the output should go. It's possible to bracket added `print` statements with conditionals
    such as `if settings.DEBUG`, which might allow the added debugging support to
    remain in the code long-term, but this is a nuisance and adds clutter to the code,
    so it tends not to be done. It's also possible to specify in the `print` that
    the output should be routed someplace other than the default of `sys.stdout`,
    but again that is more work and tends not to be done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: These problems lead to sprinkled `print` statements that are immediately removed
    when a problem is solved, leaving the code in a state where by default it reports
    nothing about its operation. Then when the next problem occurs, the developer
    has to start all over again with adding reporting of debug information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: A far better approach is to use some disciplined logging throughout development,
    so that by default, at least when `DEBUG` is turned on, the code reports something
    about what it is doing. If it does so, then it is quite possible that no additional
    debug information needs to be collected in order to solve problems that crop up.
    Furthermore, use of a logging facility allows for the configuration of under what
    conditions messages should be output, and where they should go, to be separated
    from the actual logging statements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Simple logging configuring for development
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A preferred alternative to `print` statements for debugging, then, is to use
    the python `logging` module. The actual logging calls are as easy to make as they
    are with `print`. For example, a `print` to track calls into `display_active_survey`
    might look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here the print reports the function that has been called; along with the `request.method`
    and the primary key of the survey it has been passed. On the development server
    console, the output for getting an active survey page would be:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The equivalent call, only using Python `logging`, might be:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here the `logging.debug` call is used to specify that the passed string is a
    debug-level message. The concept of levels allows the calling code to assign a
    measure of importance to the message without actually making any decisions about
    whether the message should be output in the current circumstances. Rather, that
    decision is made by the logging facility, based on the currently set threshold
    level for logging.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `logging` module provides a set of convenience methods for logging
    messages with the default defined levels. These are, in increasing order of level:
    `debug`, `info`, `warning`, `error`, and `critical`. Thus, this `logging.debug`
    message will only be output if the `logging` module''s level threshold has been
    set to include debug-level messages.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem with using this `logging.debug` statement in place of a `print`
    is that by default the logging module level threshold is set to `warning`. Thus,
    only `warning`, `error`, and `critical` messages are output by default. We need
    to configure the `logging` module to output debug-level statements in order for
    this message to appear on the console. An easy way to do this is to add a call
    to `logging.basicConfig` in the `settings.py` file. We can make the call contingent
    on `DEBUG` being turned on:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With that code added to `settings.py`, and the `logging.debug` call in the
    `display_active_survey` function, the development console will now show the message
    when the `display_active_survey` function is entered:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `DEBUG:root:` prefix on the message is a result of the default
    formatting applied to logged messages. `DEBUG` indicates the level associated
    with the message and `root` identifies the logger that was used to log the message.
    Since the `logging.debug` call does not specify any particular logger, the default
    of `root` was used.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Other parameters to `logging.basicConfig` could be used to change the formatting
    of the message, but full coverage of all the features of Python logging is beyond
    the scope of what we need to cover here. For our purposes, the default formatting
    will be fine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that can be specified in the logging configuration is where the
    messages should be routed. We did not do so here, since the default of `sys.stderr`
    is sufficient for development debugging purposes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to log
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By switching from `print` to `logging`, we've removed the need for the developer
    adding the logging to decide under exactly what conditions the logged information
    should be produced, and where exactly it should go. The developer simply needs
    to identify the level of importance associated with the message, and then the
    logging facility itself will decide what to do with the logged information. The
    next question, then, is what should be logged?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is hard to know what information will be most useful to log when
    writing code. As developers we might make some guesses, but until we get some
    experience with the code as it actually runs, it is hard to be sure. Yet, as previously
    mentioned, it can be very helpful for code to have some built-in reporting of
    basic information about what it is doing. Thus, it is good to have some guidelines
    to follow for logging that should be included by default when initially writing
    code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: One such guideline might be to log entry and exit to all "significant" functions.
    The entry log message should include the values for any key parameters, and the
    exit log message should give some indication of what the function returned. With
    just this type of entry and exit logging (assuming a reasonably good split of
    code into manageable functions), we'll be able to get a pretty clear picture of
    the flow of control through the code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Manually adding entry and exit logging, however, is a nuisance. It can also
    add clutter to the code. In reality, it is unlikely that a guideline to log all
    significant function entries and exits will be happily followed, unless it is
    much easier to do than adding the type of logging message previously noted for
    entry to `display_active_survey`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Python provides facilities to make it easy to do exactly what we
    are looking for here. Functions can be wrapped in other functions, allowing the
    wrapping function to do things such as log entry and exit, with parameter and
    return information. Furthermore, the Python decorator syntax allows such wrapping
    to be accomplished with minimal added code clutter. In the next section, we will
    develop some simple logging wrappers for use with our existing survey application
    code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Decorators to log function entry and exit
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One disadvantage of using general-purpose wrappers instead of embedding entry/exit
    logging in the functions themselves is that it makes it more difficult to accomplish
    fine-grained control over what parameter and return information is logged. It
    is easy to write a general wrapper that logs all parameters, or no parameters,
    but it is difficult to impossible to write one that logs some subset of the parameters,
    for example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Why not just log all parameters? The problem with this is that some often-used
    parameters in Django applications, such as request objects, have a very verbose
    representation. Logging their full values would produce too much output. It's
    better to start with a general-purpose wrapping logger that does not log any parameter
    values, in addition to maybe one or more special-purpose ones that can be used
    for functions with predictable parameters to log key information in those parameters.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: For example, a special-purpose wrapper for logging entry and exit to view functions
    is likely worthwhile. A view always gets an `HttpRequest` object as its first
    parameter. While logging the full object is not helpful, logging the request method
    is both short and useful. Furthermore, since additional parameters to the view
    function come from the requested URL, they are probably not too verbose to log
    as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: What about return values—should they be logged? Probably not in general for
    a Django application, which will often have functions that return `HttpResponse`
    objects. These are generally too large to be helpful when logged. However, it
    is typically useful to log at least some information about return values, such
    as their type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We've come up with two wrappers, then, to start with. The first, which will
    be named `log_call`, will log the entry to and exit from a function. No entry
    parameter information will be logged by `log_call`, but it will log the type of
    result it returns. The second wrapper will be more specialized, and will be used
    for wrapping view functions. This one will be named `log_view`. It will log the
    request method and any additional parameters passed to the wrapped view, as well
    as the type of its return value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Where should this code go? Again, it is not tied in any way to the survey application,
    so it makes sense to put it in `gen_utils`. We''ll create a file in `gen_utils`
    then, named `logutils.py`, that can hold any general logging utility code. We''ll
    start with an implementation of the `log_call` wrapper previously described:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This implementation uses the class-based style of writing wrapping functions.
    Using this style, the wrapper is defined as a class that implements `__init__`
    and `__call__` methods. The `__init__` method is called at the time the wrapper
    is created, and is passed the function it is wrapping. The `__call__` method is
    called when the wrapped function is actually called. The `__call__` implementation
    is responsible for doing whatever the wrapping function requires, calling the
    wrapped function, and returning its result.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the implementation is split into two classes: the base `LoggingDecorator`
    that implements `__init__`, and then `log_call`, which inherits `__init__` from
    `LoggingDecorator` and implements `__call__`. The reason for this split is so
    that we can share the common `__init__` for multiple logging wrappers. All the
    `__init__` does is save a reference to the wrapped function to be used later when
    `__call__` is called.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The `log_call __call__` implementation, then, first logs a message that the
    function was called. The name of the wrapped function can be found in its `__name__`
    attribute. The wrapped function is then called, and its return value is saved
    in `rv`. A second message is logged noting the type returned by the called function.
    Finally, the value returned by the wrapped function is returned.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log_view` wrapper is very similar to `log_call`, differing only in the
    details of what it logs:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here the first logged message includes, in addition to the name of the wrapped
    function, the `method` attribute of the first positional argument and the keyword
    arguments passed to the wrapped function. This wrapper, since it is intended to
    be used for wrapping view functions, assumes the first positional argument is
    an `HttpRequest` object, which has a `method` attribute.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Further, this code assumes all other arguments will be passed as keyword arguments.
    We know that this will be the case for the survey application code, since all
    of the survey URL patterns specify named groups. A more general view wrapper would
    need to log `args` (except the first one, an `HttpRequest` object) as well, if
    it wanted to support non-named groups used in the URL pattern configuration. For
    the survey application, this would just result in logging information that is
    always the same, so it has been omitted here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Applying the decorators to the Survey code
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s add these decorators to the survey view functions and see what some
    typical output from browsing looks like. Adding the decorators is easy. First,
    in `views.py`, add an import for the decorators near the top of the file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, for all functions that are actually views, add `@log_view` above the
    function definition. (This syntax assumes the Python version in use is 2.4 or
    higher.) For example, for the home page, view definition becomes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Do the same for `survey_detail` and `survey_thanks`. For the utility functions
    `display_active_survey` and `display_completed_survey`, use `@log_call` instead.
    For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now when we browse around the survey site, we will have messages logged on
    the console that track basic information about what code is being called. For
    example, we might see:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This shows that the home page view was called, and returned an `HttpResponse`.
    Following the survey application''s logged messages, we see the normal printout
    from the development server noting that a `GET` for `/` returned a response with
    code `200` (HTTP OK) and containing `1184` bytes. Next, we might see:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This shows the `survey_detail` view being called with a `GET`, likely from a
    link on the home page returned by the previous response. Further, we can see that
    the particular survey requested has a primary key of `1`. The next log message
    reveals that this must be an active survey, since `display_active_survey` is called.
    It returns an `HttpResponse`, as does the `survey_detail` view, and again the
    last survey log message is followed by Django's own printout summarizing the request
    and its outcome.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we might see:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Again this looks like a natural progression from the previous response: a `POST`
    for the same survey that was retrieved by the previous request. The `POST` indicates
    that the user is submitting a survey response. However, the return type of `HttpResponse`
    that is logged indicates that there is some problem with the submission. (We know
    an `HttpResponse` to a POST only occurs when a form is found to be invalid in
    `display_active_survey`.)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This might be a place where we would want to add additional logging beyond the
    entry/exit information, to track the specific reasons why a posted form was deemed
    invalid. In its current form, all we can know is that the returned response, since
    it was slightly larger than the original (`2466` versus `2197` bytes), likely
    included an error annotation noting what needed to be fixed on the form in order
    for it to be valid.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we might see:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This starts out as a repeat of the previous request, a `POST` to the `survey_detail`
    view for the survey with primary key `1`. However, this time an `HttpResponseRedirect`
    is returned, indicating that the user must have corrected whatever problem existed
    in the first submission.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we would likely see:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shows the request that the browser will automatically make on receiving
    the redirect returned by the previous request. We see the `survey_thanks` view
    logging a `GET` for the same survey as all the previous requests, and an `HttpResponse`
    being returned.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can see how with very little effort we can add some basic logging that
    provides a general overview of the flow of control through our Django application
    code. Note that the logging decorators defined here are not perfect. For example,
    they don't support decoration of methods instead of functions, they impose some
    overhead even when no logging is desired, and they have some side-effects resulting
    from turning functions into classes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: All of these drawbacks can be overcome with some care in the development of
    the wrappers. However, the details of that are beyond the scope of what we can
    cover here. The ones presented here have the advantage of being reasonably simple
    to understand, and functional enough to hopefully demonstrate the usefulness of
    having an easy built-in logging mechanism to see the flow of control, along with
    perhaps some key parameters, through the code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Logging in the debug toolbar
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that we skipped over any examination of the debug toolbar's logging panel
    since we had no logging in the survey application code. Let's return now to the
    debug toolbar and see how the added logging appears there.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'First, though, let''s add an additional log message to note what causes a POST
    request for an active survey to fail. As mentioned in this previous section, this
    could be useful to know. So, in the `display_active_survey` function add a logging
    call after a form is found to be invalid:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: (Note it will also be necessary to add an `import logging` before use of `logging`.)
    With that additional log message, we should be able to get specific information
    about why a particular survey submission was considered invalid.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Now re-activate the debug toolbar by un-commenting its middleware in `settings.py`,
    browse to an active survey page, and attempt to force production of that log message
    by submitting an incomplete survey. When the response is returned, clicking on
    the toolbar''s **Logging** panel will bring up a page that looks like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging in the debug toolbar](img/7566_08_20.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: On this page, we can see that in addition to the messages themselves and their
    assigned levels, the toolbar also reports the date and time they were logged in
    addition to the location in the code where they were generated. Since most of
    these log messages are coming from the wrapping functions, the location information
    here is not particularly useful. However, the newly added log message is correctly
    matched to where it appears in the code. Indeed the logged message makes it clear
    that the problem with the form was a missing choice for an answer.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now reached the end of discussing techniques for getting more information
    about how Django application code is running. In this chapter, we:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Developed some template utility code to track what SQL requests are made during
    production of a page
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned that creating re-usable general utility code can turn into more work
    than it might first seem to require
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how the Django Debug Toolbar can be used to get the same information
    as in our home-grown code in addition to more information, with much less effort
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the usefulness of applying a general logging framework during code
    development, as opposed to relying on the ad-hoc "sprinkle `print`" method of
    debugging problems
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the use of these tools and techniques, we are able to glean a great deal
    of information about the working of our code. Having a good understanding of how
    the code behaves when it is working properly makes it much easier to debug problems
    when they occur. Furthermore, checking on exactly what the code is doing even
    when it seems, from all outward appearances, to be working correctly, may reveal
    hidden issues that could become big problems as the code moves from development
    to production.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, even all of the information available by using these techniques
    is insufficient to solve a problem at hand. In those cases, the next step may
    be to run the code under a debugger. This is the topic of the next chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
