- en: 'Chapter 8. When Problems Hide: Getting More Information'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes code does not trigger a debug page to be displayed, but it also does
    not produce the correct results. In fact even when code does seem to be working
    correctly, at least in terms of the visible results shown in the browser, behind
    the scenes it may be doing unexpected things that could lead to trouble down the
    road. For example, if a page requires many (or very time-consuming) SQL queries,
    then it may seem to be working fine during development but then quickly cause
    server overload in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice, then, to get into the habit of checking up on how code is
    behaving, even when external results are not showing any problems. First, this
    practice can reveal hidden problems that are best known about sooner rather than
    later. Second, knowing what the normal code path looks like is very valuable when
    tracking down where things have gone wrong when a problem does crop up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter focuses on ways to get more information about what Django application
    code is doing. Specifically, in this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Develop template code that can be used to include information about all of the
    SQL queries needed to render a page in the page itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use the Django Debug Toolbar for gathering similar information,
    and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss techniques for adding logging to Django application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking SQL queries for a request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a typical Django application, database interactions are of key importance.
    Ensuring that the database queries being made are correct helps to ensure that
    the application results are correct. Further, ensuring that the database queries
    produced for the application are efficient helps to make sure that the application
    will be able to support the desired number of concurrent users.
  prefs: []
  type: TYPE_NORMAL
- en: Django provides support in this area by making the database query history available
    for examination. [Chapter 6](ch06.html "Chapter 6. Django Debugging Overview"),
    *Django Debugging Overview*, introduced this history and showed how it could be
    accessed from a Python shell session. This type of access is useful to see the
    SQL that is issued as a result of calling a particular model method. However,
    it is not helpful in learning about the bigger picture of what SQL queries are
    made during the processing of a particular request.
  prefs: []
  type: TYPE_NORMAL
- en: This section will show how to include information about the SQL queries needed
    for production of a page in the page itself. We will alter our existing survey
    application templates to include query information, and examine the query history
    for some of the existing survey application views. Though we are not aware of
    any problems with the existing views, we may learn something in the process of
    verifying that they issue the queries we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Settings for accessing query history in templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the query history can be accessed from a template, we need to ensure
    some required settings are configured properly. Three settings are needed in order
    for the SQL query information to be available in a template. First, the debug
    context processor, `django.core.context_processors.debug`, must be included in
    the `TEMPLATE_CONTEXT_PROCESSORS` setting. This context processor is included
    in the default value for `TEMPLATE_CONTEXT_PROCESSORS`. We have not changed that
    setting; therefore we do not need to do anything to enable this context processor
    in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, the IP address of the machine sending the request must be listed in
    the `INTERNAL_IPS` setting. This is not a setting we have used before, and it
    is empty by default, so we will need to add it to the settings file. When testing
    using the same machine as where the development server runs, setting `INTERNAL_IPS`
    to include the loopback address is sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you also test from other machines, you will need to include their IP addresses
    in this setting as well.
  prefs: []
  type: TYPE_NORMAL
- en: Third and finally, `DEBUG` must be `True` in order for the SQL query history
    to be available in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'When those three settings conditions are met, the SQL query history may be
    available in templates via a template variable named `sql_queries`. This variable
    contains a list of dictionaries. Each dictionary contains two keys: `sql` and
    `time`. The value for `sql` is the SQL query itself, and the value for `time`
    is the number of seconds the query took to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `sql_queries` context variable is set by the debug context processor.
    Context processors are only called during template rendering when a `RequestContext`
    is used to render the template. Up until now, we have not used `RequestContexts`
    in our survey application views, since they were not necessary for the code so
    far. But in order to access the query history from the template, we will need
    to start using `RequestContexts`. Therefore, in addition to modifying the templates,
    we will need to change the view code slightly in order to include query history
    in the generated pages for the survey application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries for the home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by seeing what queries are issued in order to generate the `survey`
    application home page. Recall that the home page view code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three `QuerySets` rendered in the template, so we would expect to
    see that this view generates three SQL queries. In order to check that, we must
    first change the view to use a `RequestContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only change here is to add the `RequestContext(request)` as a third parameter
    to `render_to_response`, after adding an `import` for it earlier in the file.
    When we make this change, we may as well also change the `render_to_response`
    lines for the other views to use `RequestContexts` as well. That way when we get
    to the point of examining the SQL queries for each, we will not get tripped up
    by having forgotten to make this small change.
  prefs: []
  type: TYPE_NORMAL
- en: Second, we'll need to display the information from `sql_queries` somewhere in
    our `survey/home.html` template. But where? We don't necessarily want this information
    displayed in the browser along with the genuine application data, since that could
    get confusing. One way to include it in the response but not have it be automatically
    visible on the browser page is to put it in an HTML comment. Then the browser
    will not display it on the page, but it can be seen by viewing the HTML source
    for the displayed page.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first attempt at implementing this, we might change the top of `survey/home.html`
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This template code prints out the contents of `sql_queries` within an HTML comment
    at the very beginning of the `content` block supplied by `survey/home.html`. First,
    the number of queries is noted by filtering the list through the `length` filter.
    Then the code iterates through each dictionary in the `sql_queries` list and displays
    `sql`, followed by a note in parentheses about the `time` taken for each query.
  prefs: []
  type: TYPE_NORMAL
- en: 'How well does that work? If we try it out by retrieving the survey home page
    (after ensuring the development server is running), and use the browser''s menu
    item for viewing the HTML source for the page, we might see that the comment block
    contains something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the exact number of queries displayed here will depend on the version
    of Django you are running. This result is from Django 1.1.1; later versions of
    Django may not show any queries displayed here. Furthermore, the history of the
    browser's interaction with the site will affect the queries issued. This result
    is from a browser that had been used to access the admin application, and the
    last interaction with the admin application was to log out. You may see additional
    queries if the browser had been used to access the admin application but the user
    had not logged out. Finally, the database in use can also affect the specific
    queries issued and their exact formatting. This result is from a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not exactly what we expected. First, a minor annoyance, but `1 queries`
    is wrong, it should be `1 query`. Perhaps that wouldn''t annoy you, particularly
    just in internal or debug information, but it would annoy me. I would change the
    template code that displays the query count to use correct pluralization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, since the template needs to use the `length` result multiple times, it
    is first cached in the `qcount` variable by using a `{% with %}` block. Then it
    is displayed, and it is used as the variable input to the `pluralize` filter that
    will put the correct letters on the end of `quer` depending on the `qcount` value.
    Now the comment block will show `0 queries`, `1 query`, `2 queries`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: With that minor annoyance out of the way, we can concentrate on the next, larger,
    issue, which is that the displayed query is not a query we were expecting. Furthermore,
    the three queries we were expecting, to retrieve the lists of completed, active,
    and upcoming surveys, are nowhere to be seen. What's going on? We'll take each
    of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: The query that is shown is accessing the `django_session` table. This table
    is used by the `django.contrib.sessions` application. Even though the survey application
    does not use this application, it is listed in our `INSTALLED_APPS`, since it
    is included in the `settings.py` file that `startproject` generates. Also, the
    middleware that the `sessions` application uses is listed in `MIDDLEWARE_CLASSES`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sessions` application stores the session identifier in a cookie, named
    `sessionid` by default, that is sent to the browser as soon as any application
    uses a session. The browser will return the cookie in all requests to the same
    server. If the cookie is present in a request, the session middleware will use
    it to retrieve the session data. This is the query we see previously listed: the
    session middleware is retrieving the data for the session identified by the session
    cookie sent by the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: But the survey application does not use sessions, so how did the browser get
    a session cookie in the first place? The answer is that the admin application
    uses sessions, and this browser had previously been used to access the admin application.
    At that time, the `sessionid` cookie was set in a response, and the browser faithfully
    returns it on all subsequent requests. Thus, it seems likely that this `django_session`
    table query is due to a `sessionid` cookie set as a side-effect of using the admin
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we confirm that? If we find and delete the cookie from the browser and
    reload the page, we should see that this SQL query is no longer listed. Without
    the cookie in the request, whatever code was triggering access to the session
    data won''t have anything to look up. And since the survey application does not
    use sessions, none of its responses should include a new session cookie, which
    would cause subsequent requests to include a session lookup. Is this reasoning
    correct? If we try it, we will see that the comment block changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we seem to have confirmed, to some extent, what happened to cause a `django_session`
    table query during processing of a survey application response. We did not track
    down what exact code accessed the session identified by the cookie—it could have
    been middleware or a context processor, but we probably don't need to know the
    details. It's enough to keep in mind that there are other applications running
    in our project besides the one we are working on, and they may cause database
    interactions independent of our own code. If we observe behavior which looks like
    it might cause a problem for our code, we can investigate further, but for this
    particular case we will just avoid using the admin application for now, as we
    would like to focus attention on the queries our own code is generating.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the query that was listed, what about the expected ones
    that were not listed? The missing queries are due to a combination of the lazy
    evaluation property of `QuerySets` and the exact placement of the `comment` block
    that lists the contents of `sql_queries`. We put the `comment` block at the top
    of the `content` block in the home page, to make it easy to find the SQL query
    information when looking at the page source. The template is rendered after the
    three `QuerySets` are created by the view, so it might seem that the comment placed
    at the top should show the SQL queries for the three `QuerySets`.
  prefs: []
  type: TYPE_NORMAL
- en: However, `QuerySets` are lazy; simply creating a `QuerySet` does not immediately
    cause interaction with the database. Rather, sending the SQL to the database is
    delayed until the `QuerySet` results are actually accessed. For the survey home
    page, that does not happen until the parts of the template that loop through each
    `QuerySet` are rendered. Those parts are all below where we placed the `sql_queries`
    information, so the corresponding SQL queries had not yet been issued. The fix
    for this is to move the placement of the `comment` block to the very bottom of
    the `content` block.
  prefs: []
  type: TYPE_NORMAL
- en: When we do that we should also fix two other issues with the query display.
    First, notice that the query displayed above has `&gt;` shown instead of the `>`
    symbol that would actually have been in the query sent to the database. Furthermore,
    if the database in use is one (such as PostgreSQL) that uses straight quotes instead
    of back quotes for quoting, all of the back quotes in the query would be shown
    as `&quot;`. This is due to Django's automatic escaping of HTML markup characters.
    This is unnecessary and hard to read in our HTML comment, so we can suppress it
    by sending the `sql` query value through the `safe` filter.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the query is very long. In order to avoid needing to scroll to the right
    in order to see the entire query, we can also filter the `sql` value through `wordwrap`
    to introduce some line breaks and make the output more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make these changes, remove the added comment block from the top of the `content`
    block in the `survey/home.html` template and instead change the bottom of this
    template to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we again reload the survey home page and view the source for the returned
    page, we will see the queries listed in a comment at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is good, those look like exactly what we expect to see for queries for
    the home page. Now that we seem to have some working template code to show queries,
    we will consider packaging up this snippet so that it can easily be reused elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging the template query display for reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now got a small block of template code that we can put in any template
    to easily see what SQL queries were needed to produce a page. However, it is not
    so small that it can be easily re-typed whenever it might come in handy. Therefore,
    it would be good to package it up in a form where it can be conveniently included
    wherever and whenever it might be needed. The Django template `{% include %}`
    tag makes this easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Where should the snippet go? Note that this template snippet is completely general
    and not in any way tied to the survey application. While it would be easy to simply
    include it among the survey templates, putting it there will make it harder to
    reuse for future projects. A better approach is to put it in an independent application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an entirely new application just for this one snippet may seem a bit
    extreme. However, it is common during development to create small utility functions
    or template snippets that don't really belong in the main application. So it is
    likely during development of a real project that there would be other such things
    that should logically be placed somewhere besides the main application. It's helpful
    to have someplace else to put them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Django application, then, to hold any general utility code
    that does not logically belong within the survey application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since its purpose is to hold general utility code, we've named the new application
    `gen_utils`. It can serve as a place to put any non-survey-specific code that
    seems like it might be potentially re-usable elsewhere. Note that as time goes
    on and more and more stuff accumulates in an application like this, it may become
    apparent that some subset of it would be useful to package into its own independent,
    self-contained application with a more descriptive name than `gen_utils`. But
    for now it is enough to start with one place to put utility code that is not really
    tied to the survey application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can create a `templates` directory within `gen_utils`, and a `gen_utils`
    directory under `templates`, and create a file, `showqueries.html`, to hold the
    template snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've made one change here from the previous code placed directly in the `survey/home.html`
    template, which is to place the entire HTML `comment` block inside an `{% if sql_qureies
    %}` block. If the `sql_queries` variable has not been included in the template
    context, then there is no reason to produce the comment at all.
  prefs: []
  type: TYPE_NORMAL
- en: As part of packaging code for reuse, it's also good practice to double-check
    and make sure that the code is truly reusable and not going to fail in odd ways
    if given unexpected or unusual input. Taking a look at that snippet, is there
    anything that might be found in an arbitrary `sql_queries` input that could cause
    a problem?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes. If a SQL query value contains the HTML end-of-comment delimiter,
    then the comment block will be terminated early. This could result in the browser
    rendering what was intended to be a comment as part of the page content displayed
    to the user. To see this, we can try inserting a model `filter` call that includes
    the HTML end-of-comment delimiter into the home page view code, and see what the
    browser shows.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what is the HTML end-of-comment delimiter? You might guess that it is `-->`,
    but in fact it is just the two dashes in a row. Technically, the `<!` and `>`
    are defined as the beginning and end of markup declaration, while the dashes mark
    the beginning and end of the comment. Thus, a query that contains two dashes in
    a row should trigger the behavior we are worried about here. To test this, add
    this line of code to the `home` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note nothing has to be done with the results of the call; the added code must
    simply ensure that the query containing the two dashes is actually sent to the
    database. This added line does that by retrieving the count of results matching
    the pattern containing two dashes. With that added line in the `home` view, Firefox
    will display the survey home page like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging the template query display for reuse](img/7566_08_01(revised).jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two dashes in a row in a SQL query value caused Firefox to prematurely terminate
    the comment block, and data we had intended to be still inside the comment has
    appeared in the browser page. In order to avoid this, we need to ensure that two
    dashes in a row never appear in the SQL query values included in the comment block.
  prefs: []
  type: TYPE_NORMAL
- en: A quick glance through the built-in Django filters doesn't reveal any that could
    be used to replace a string of two dashes with something else. The `cut` filter
    could be used to remove them, but simply removing them would make the `sql` value
    misleading as there would be no indication that the characters had been removed
    from the string. Therefore, it seems we will need to develop a custom filter for
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put the custom filter in the `gen_utils` application. Filters and template
    tags must be placed in a `templatetags` module in an application, so we must first
    create the `templatetags` directory. Then, we can put an implementation for a
    `replace_dashes` filter into a file named `gentags.py` within `gen_utils/templatetags`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The bulk of this code is the standard boilerplate `import`, `register` assignment,
    and `@register.filter` decoration needed to register the `replace_dashes` function
    so that it is available for use as a filter. The function itself simply replaces
    any occurrences of a pair of dashes in a string with `~~double-dash~~` instead.
    Since there is no way to escape the dashes so that they will not be interpreted
    as the end of the comment yet still appear as dashes, we replace them with a string
    describing what had been there. The last line marks the `replace_dashes` filter
    as safe, meaning it does not introduce any HTML markup characters that would need
    to be escaped in its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to change the template snippet in `gen_utils/showqueries.html`
    to load and use this filter for display of the SQL query values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only changes here are the addition of the `{% load gentags %}` line and
    the addition of `replace_dashes` in the sequence of filters applied to `qdict.sql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can remove the comment snippet from the `survey/home.html` template.
    Instead, we will put the new general snippet in the `survey/base.html` template,
    so this becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Placing `{% include %}` in the base template will cause every template that
    inherits from base to automatically have the comment block added, assuming that
    the other conditions of `DEBUG` being turned on, the requesting IP address being
    listed in `INTERNAL_IPS`, and the response being rendered with a `RequestContext`,
    are met. We'd likely want to remove this before putting the application in a production
    environment, but during development it can come in handy to have easy automatic
    access to the SQL queries used to generate any page.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the repackaged template code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How well does the repackaged version of the code work? If we try to reload
    our survey home page now, we will find that we have forgotten a couple of things.
    The first attempt brings up a Django debug page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the repackaged template code](img/7566_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is an instance of one of the special debug pages mentioned in the last
    chapter. It is a `TemplateSyntaxError` resulting from an exception being raised
    during rendering. The original exception was caught and turned into a `TemplateSyntaxError`,
    and the original traceback is shown as part of the exception value. Looking at
    that, we can see that the original exception was `TemplateDoesNotExist`. For some
    reason, the `gen_utils/showqueries.html` template file was not found by the template
    loader.
  prefs: []
  type: TYPE_NORMAL
- en: Paging further down on the debug page received here, we learn why the template
    engine behavior of wrapping original exceptions in a `TemplateSyntaxError` can
    sometimes be aggravating. Because the exception that was ultimately raised was
    a `TemplateSyntaxError`, not a `TemplateDoesNotExist`, this debug page does not
    have the template loader postmortem that would detail exactly what template loaders
    were tried, and what files they attempted to load while searching for `gen_utils/showqueries.html`.
    So, we've lost some helpful debug information due to the way `TemplateSyntaxError`
    exceptions are used to wrap others.
  prefs: []
  type: TYPE_NORMAL
- en: If we needed to, we could force production of the template loader postmortem
    for this template file by attempting to render it directly from a view, instead
    of by including it in another template. So we could, with a little work, get the
    information that has unfortunately not been included in this particular debug
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in this case it is not necessary, since the reason for the exception is
    not particularly obscure: we didn''t do anything to ensure that the templates
    in the new `gen_utils` application would be found. We did not include `gen_utils`
    in `INSTALLED_APPS` so that its `templates` directory would be searched by the
    application template loader, nor did we put the path to the `gen_utils templates`
    directory into the `TEMPLATE_DIRS` setting. We need to do one of these things
    in order to have the new template file found. Since `gen_utils` also now has a
    filter, and in order for that to be loaded `gen_utils` will need to be in `INSTALLED_APPS`,
    we will fix the `TemplateDoesNotExist` exception by including `gen_utils` in `INSTALLED_APPS`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we make that change, does the new code work? Not quite. Attempting to
    reload the page now brings up a different debug page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the repackaged template code](img/7566_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This one is a little more mysterious. The displayed template is `gen_utils/showqueries.html`,
    so we have gotten farther than in the previous case. But for some reason, the
    attempt to `{% load gentags %}` is failing. The error message states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**''gentags'' is not a valid tag library: Could not load template library from
    django.templatetags.gentags, No module named gentags**.'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the rare cases where you do not want to entirely believe what
    the error message seems to be saying. It seems to be implying that the problem
    is that there is no `gentags.py` file in `django.templatetags`. A natural next
    thought may be that it is required to place custom template tag and filter libraries
    inside Django's own source tree. However, that would be a very odd requirement
    and the documentation clearly contradicts it, since it states that custom tags
    and filters should be placed in the application's `templatetags` directory. Are
    we supposed to use something other than a plain `{% load %}` tag to force Django
    to search beyond its own `templatetags` directory for a tag library?
  prefs: []
  type: TYPE_NORMAL
- en: No, in this case the error is just misleading. Although `django.templatetags`
    is the only module named in the error message, in fact the Django code attempted
    to load `gentags` from a `templatetags` directory under each application listed
    in `INSTALLED_APPS`. So the question is not why did Django fail to look for `gentags`
    under the `gen_utils/templatetags` directory, but why did an attempt to load `gentags`
    from `genutils.templatetags` fail?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to answer that question by trying the same code that Django
    is running during `{% load %}` from a Python shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, an attempt to import `gentags` from `gen_utils.templatetags` is
    failing. Python claims the `templatetags` module does not exist. But the directory
    certainly exists, and `gentags.py` exists, so what is missing? The answer is an
    `__init__.py` file in that directory to make Python recognize it as a module.
    Creating that file and re-trying the import from the shell shows that the import
    will now work.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, attempting to simply reload the page in a browser causes the same
    debug page to be re-displayed. This is also one of the rare cases where the development
    server needs to be manually stopped and re-started in order for it to pick up
    on the changes made. That done, we can finally re-load the survey home page and
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the repackaged template code](img/7566_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re back to the page being served without an exception being raised, and
    there is no more stray debug information from the `sql_queries` being included
    in an HTML comment. If we look further, at the HTML source for the page, we will
    see something like the following at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That looks good. The `replace_dashes` filter successfully got rid of the two
    dashes in a row, so the browser no longer thinks the comment block was terminated
    before it was intended to be. Now we can move on to checking the SQL queries needed
    to produce the other survey pages.
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries for the active Survey form display page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on the link to the one active survey brings up the active survey page
    for that survey:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL queries for the active Survey form display page](img/7566_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the source for this page, we see that six SQL queries were needed
    to produce it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we match up those queries to the code used to produce the page? Yes, in
    this case it is reasonably straightforward to see where each query comes from.
    The very first query is looking up a survey based on its primary key, and corresponds
    to the `get_object_or_404` call in the very first line in the `survey_detail`
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is an active survey, the thread of control then proceeds to the
    `display_active_survey` function, which contains the following code to build the
    forms for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The call to `enumerate(survey.question_set.all())` is responsible for the second
    SQL query for this page, which retrieves all of the questions for the survey being
    displayed. The call to `q.answer_set.count()` within the `for` loop explains the
    third and fourth SQL queries, which retrieve the count of answers for each question
    in the survey.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two queries, then, retrieve the set of answers for each question in
    the survey. We might first think that these queries are issued when the `QuestionVoteForm`
    for each question in the survey is created. The `__init__` routine for a `QuestionVoteForm`
    contains this line, to initialize the set of answers for the question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, that line of code does not result in a call to the database. It simply
    sets the `queryset` attribute for the form's `answer` field to a `QuerySet` value.
    Since `QuerySets` are lazy, this does not cause a database hit. This is confirmed
    by the fact that both queries that request `COUNT(*)` are issued before the queries
    that retrieve the actual answer information. If the creation of `QuestionVoteForm`
    caused the retrieval of the answer information, then the last two queries would
    not be last, but rather would be interleaved with the `COUNT(*)` queries. The
    trigger for issuing the queries that retrieve the answer information, then, is
    the rendering of the answer values in the `survey/active_survey.html` template.
  prefs: []
  type: TYPE_NORMAL
- en: If we were focused on optimization, at this point we might try to see if we
    could reduce the number of queries needed for this page. Retrieving the count
    of answers and then the answer information itself in two separate queries seems
    inefficient compared to simply retrieving the answer information and deriving
    the count based on the returned information. It seems like we could produce this
    page with four queries instead of six.
  prefs: []
  type: TYPE_NORMAL
- en: However, since we are focused on understanding the current behavior as an aid
    to debugging, we are not going to divert into an optimization discussion here.
    Even if we were developing a real project, at this point in development it would
    not be a good time to work on such optimizations. The inefficiency here is not
    so bad as to be termed a bug, so it is best just to note it as a possible thing
    to look at in the future, when a full picture of the overall performance of the
    application can be determined. At that point the inefficiencies that are the most
    expensive are the ones that will be worth taking the time to investigate improving.
  prefs: []
  type: TYPE_NORMAL
- en: SQL queries for posting survey answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we now choose some answers for the survey questions and press the **Submit**
    button, we get the **Thanks** page in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SQL queries for posting survey answers](img/7566_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the source for this page, we find a single SQL query, to retrieve
    a `survey` given the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The line of code associated with that query is obvious; it is the `get_object_or_404`
    in the `survey_thanks` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But what about all the SQL queries involved in processing the form data when
    it was submitted? Long before the `survey_thanks` view was called, `display_active_survey`
    must have run in order to receive the posted form data and update the database
    for the selected answers. Yet we don't see any of the SQL queries needed for that
    among the queries shown for the thanks page.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is because the `display_active_survey` function, in the
    case where the form processing is successful and the database is updated, does
    not render a template directly but rather returns an `HttpResponseRedirect`. The
    web browser, on receiving the HTTP redirect response, automatically fetches the
    location identified in the redirect.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, there are two full request/response cycles that take place in between
    pressing the **Submit** button on the browser and seeing the thanks page appear.
    The thanks page itself can show the SQL queries that were executed during its
    (the second) request/response cycle, but it cannot show any of the ones that happened
    in the first request/response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: That's disappointing. At this point, we've gone to a fair amount of trouble
    developing what seemed at first like it was going to be a quite simple little
    bit of utility code. Now, we find that it is not going to work for some of the
    most interesting views in an application—the ones that actually update the database.
    What do we do?
  prefs: []
  type: TYPE_NORMAL
- en: We certainly don't want to just give up on seeing the SQL queries for pages
    that successfully process posted data. But nor do we want to spend much more development
    effort on this utility code. Although we have learned a few things along the way,
    we've started to stray a bit too much from our main application. Fortunately,
    we don't need to do either of these. Instead, we can simply install and start
    using an already-developed general debugging tool for Django applications, the
    Django Debug Toolbar. This tool is the focus of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Django Debug Toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rob Hudson's Django Debug Toolbar is a very useful general purpose debugging
    tool for Django applications. As with the code we developed earlier in this chapter,
    it lets you see the SQL queries that were needed to produce a page. However, as
    we will see, it also goes far beyond that, providing easy access to much more
    information about the SQL queries and other aspects of request processing. Furthermore,
    the debug toolbar has a far more advanced way of displaying the information than
    simply embedding it in HTML comments. The capabilities are best shown by example,
    so we will immediately proceed with installing the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Django Debug Toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolbar can be found on the Python package index site: [http://pypi.python.org/pypi/django-debug-toolbar](http://pypi.python.org/pypi/django-debug-toolbar).
    Once installed, activating the debug toolbar in a Django project is accomplished
    with the addition of just a couple of settings.'
  prefs: []
  type: TYPE_NORMAL
- en: First, the debug toolbar middleware, `debug_toolbar.middleware.DebugToolbarMiddleware`,
    must be added to the `MIDDLEWARE_CLASSES` setting. The documentation for the toolbar
    notes that it should be placed after any other middleware that encodes the response
    content, so it is best to place it last in the middleware sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `debug_toolbar` application needs to be added to `INSTALLED_APPS`.
    The `debug_toolbar` application uses Django templates to render its information,
    thus it needs to be listed in `INSTALLED_APPS` so that its templates will be found
    by the application template loader.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the debug toolbar requires that the requesting IP address be listed in
    `INTERNAL_IPS`. Since we already made this settings change earlier in the chapter,
    nothing needs to be done now for this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the debug toolbar is displayed only when `DEBUG` is `True`. We've been
    running with debug turned on, so again we don't have to make any changes here.
    Note also that the debug toolbar allows you to customize under what conditions
    the debug toolbar is displayed. It's possible, then, to set things up so that
    the toolbar will be displayed for requesting IP addresses not in `INTERNAL_IPS`
    or when debug is not turned on, but for our purposes the default configuration
    is fine so we will not change anything.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that is not required is for the application itself to use a `RequestContext`
    in order for things such as the SQL query information to be available in the toolbar.
    The debug toolbar runs as middleware, and thus is not dependent on the application
    using a `RequestContext` in order for it to generate its information. Thus, the
    changes made to the survey views to specify `RequestContexts` on `render_to_response`
    calls would not have been needed if we started off first with the Django Debug
    Toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Debug toolbar appearance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the debug toolbar is added to the middleware and installed applications
    settings, we can see what it looks like by simply visiting any page in the survey
    application. Let''s start with the home page. The returned page should now look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug toolbar appearance](img/7566_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note this screenshot shows the appearance of the 0.8.0 version of the debug
    toolbar. Earlier versions looked considerably different, so if your results do
    not look like this you may be using a different version than 0.8.0\. The version
    that you have will most likely be newer than what was available when this was
    written, and there may be additional toolbar panels or functions that are not
    covered here.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the debug toolbar appears on the right-hand side of the browser
    window. It consists of a series of panels that can be individually enabled or
    disabled by changing the toolbar configuration. The ones shown here are the ones
    that are enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before taking a closer look at some of the individual panels, notice that the
    toolbar contains an option to hide it at the top. If **Hide** is selected, the
    toolbar reduces itself to a small tab-like indication to show that it is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug toolbar appearance](img/7566_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This can be very useful for cases where the expanded version of the toolbar
    obscures application content on the page. All of the information provided by the
    toolbar is still accessible, after clicking again on the **DjDT** tab; it is just
    out of the way for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the panels will provide detailed information when they are clicked.
    A few also provide summary information in the main toolbar display. As of debug
    toolbar version 0.8.0, the first panel listed, **Django Version**, only provides
    summary information. There is no more detailed information available by clicking
    on it. As you can see in the screenshot, Django 1.1.1 is the version in use here.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the current latest source version of the debug toolbar already provides
    more information for this panel than the 0.8.0 release. Since 0.8.0, this panel
    has been renamed to **Versions**, and can be clicked to provide more details.
    These additional details include version information for the toolbar itself and
    for any other installed Django applications that provide version information.
  prefs: []
  type: TYPE_NORMAL
- en: The other three panels that show summary information are the **Time**, **SQL**,
    and **Logging** panels. Thus, we can see at a glance from the first appearance
    of the page that 60 milliseconds of CPU time were used to produce this page (111
    milliseconds total elapsed time), that the page required four queries, which took
    1.95 milliseconds, and that zero messages were logged during the request.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will dig into exactly what information is provided
    by each of the panels when clicked. We'll start first with the SQL panel, since
    it is one of the most interesting and provides the same information (in addition
    to a lot more) that we worked earlier in this chapter to access on our own.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we click on the **SQL** section of the debug toolbar, the page will change
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At a glance, this is a much nicer display of the SQL queries for the page than
    what we came up with earlier. The queries themselves are highlighted so that SQL
    keywords stand out, making them easier to read. Also, since they are not embedded
    inside an HTML comment, their content does not need to be altered in any way—there
    was no need to change the content of the query containing the double dash in order
    to avoid it causing display problems. (Now would probably be a good time to remove
    that added query, before we forget why we added it.)
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the times listed for each query are more specific than what
    was available in Django's default query history. The debug toolbar replaces Django's
    query recording with its own, and provides timings in units of milliseconds instead
    of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The display also includes a graphical representation of how long each query
    took, in the form of horizontal bars that appear above each query. This representation
    makes it easy to see when there are one or more queries that are much more expensive
    than the others. In fact, if a query takes an excessive amount of time, its bar
    will be colored red. In this case, there is not a great deal of difference in
    the query times, and none took particularly long, so all the bars are of similar
    length, and are colored gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digging deeper, some of the information we had to manually figure out earlier
    in this chapter is just a click away on this SQL query display. Specifically,
    the answer to the question of what line of our code triggered a particular SQL
    query to be issued. Each of the displayed queries has a **Toggle Stacktrace**
    option, which when clicked will show the stack trace associated with the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see that all queries are made by the `home` method in the survey
    `views.py` file. Note that the toolbar filters out levels in the stack trace that
    are within Django itself, which explains why each of these has only one level
    shown. The first query is triggered by **Line 61**, which contains the `filter`
    call added to test what will happen if a query containing two dashes in a row
    was logged. The remaining queries are all attributed to **Line 66**, which is
    the last line of the `render_to_response` call in the `home` view. These queries,
    as we figured out earlier, are all made during the rendering of the template.
    (Your line numbers may vary from those shown here, depending on where in the file
    various functions were placed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, this SQL query display makes available information that we had not
    even gotten around to wanting yet. Under the **Action** column are links to **SELECT**,
    **EXPLAIN**, and **PROFILE** each query. Clicking on the **SELECT** link shows
    what the database returns when the query is actually executed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The SQL panel](img/7566_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, clicking on **EXPLAIN** and **PROFILE** displays what the database
    reports when asked to explain or profile the selected query, respectively. The
    exact display, and how to interpret the results, will differ from database to
    database. (In fact, the **PROFILE** option is not available with all databases—it
    happens to be supported by the database in use here, MySQL.) Interpreting the
    results from **EXPLAIN** and **PROFILE** is beyond the scope of what's covered
    here, but it is useful to know that if you ever need to dig deep into the performance
    characteristics of a query, the debug toolbar makes it easy to do so.
  prefs: []
  type: TYPE_NORMAL
- en: We've now gotten a couple of pages deep into the SQL query display. How do we
    get back to the actual application page? Clicking on the circled **>>** at the
    upper-right of the main page display will return to the previous SQL query page,
    and the circled **>>** will turn into a circled **X**. Clicking the circled **X**
    on any panel detail page closes the details and returns to displaying the application
    data. Alternatively, clicking again on the panel area on the toolbar for the currently
    displayed panel will have the same effect as clicking on the circled symbol in
    the display area. Finally, if you prefer using the keyboard to the mouse, pressing
    *Esc* has the same effect as clicking the circled symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completely explored the SQL panel, let's take a brief look
    at each of the other panels provided by the debug toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: The Time panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on the **Time** panel brings up more detailed information on where
    time was spent during production of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Time panel](img/7566_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The total CPU time is split between user and system time, the total elapsed
    (wall clock) time is listed, and the number of voluntary and involuntary context
    switches are displayed. For a page that is taking too long to generate, these
    additional details about where the time is being spent can help point towards
    a cause.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the detailed information provided by this panel comes from the Python
    `resource` module. This is a Unix-specific Python module that is not available
    on non-Unix-type systems. Thus on Windows, for example, the debug toolbar time
    panel will only show summary information, and no further details will be available.
  prefs: []
  type: TYPE_NORMAL
- en: The Settings panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clicking on **Settings** brings up a scrollable display of all the settings
    in effect. The code used to create this display is identical to the code used
    to display the settings on a Django debug page, so the display here will be identical
    to what you would see on a debug page.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Headers panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **HTTP Headers** brings up a display of all the HTTP headers for
    the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP Headers panel](img/7566_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a subset of the information available in the **META** section of a debug
    page. As mentioned in the previous chapter, the `request.META` dictionary contains
    all of the HTTP headers for a request in addition to other information that has
    nothing to do with the request, since `request.META` is initially copied from
    the `os.environ` dictionary. The debug toolbar has chosen to filter the displayed
    information to include only information pertinent to the HTTP request, as shown
    in the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The Request Vars panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Request Vars** brings up a display of cookies, session variables,
    GET variables, and POST data for the request. Since the survey application home
    page doesn''t have any information to display for any of those, the **Request
    Vars** display for it is not very interesting. Instead, here is an example from
    the admin application, which does use a session, and so it actually has something
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Request Vars panel](img/7566_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you can see the `sessionid` cookie that was set as a result of the admin
    application using the `django.contrib.sessions` application, and you can also
    see the individual session variables that have been set in the session.
  prefs: []
  type: TYPE_NORMAL
- en: The Templates panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Templates** brings up a display of information about template
    processing for the request. Returning to the survey home page as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Templates panel](img/7566_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Template paths** section lists the paths specified in the `TEMPLATE_DIRS`
    setting; since we have not added anything to that setting, it is empty.
  prefs: []
  type: TYPE_NORMAL
- en: The **Templates** section shows all of the templates rendered for the response.
    Each template is listed, showing the name specified by the application for rendering
    first. Clicking on this name will bring up a display of the actual template file
    contents. Under the application-specified name is the full file path for the template.
    Finally, each template also has a **Toggle Context** link that can be used to
    see the details of the context used by each of the rendered templates.
  prefs: []
  type: TYPE_NORMAL
- en: The **Context processors** section shows all of the installed context processors.
    Under each is a **Toggle Context** link that when clicked will show the context
    variables that the associated context processor adds to the context.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the context processors are listed regardless of whether the application
    used a `RequestContext` to render the response. Thus, their being listed on this
    page does not imply that the variables they set were added to the context for
    this particular response.
  prefs: []
  type: TYPE_NORMAL
- en: The Signals panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking on **Signals** brings up a display of the signal configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Signals panel](img/7566_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All of the defined Django signals are listed. For each, the arguments provided
    are shown along with the receivers that have been connected to the signal.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this display does not indicate anything about what signals were actually
    triggered during the production of the current page. It simply shows how the signals
    are configured.
  prefs: []
  type: TYPE_NORMAL
- en: The Logging panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the **Logging** panel shows any messages sent via Python's `logging`
    module during the course of the request processing. Since we have not yet investigated
    using logging in the survey application, and since as of Django 1.1, Django itself
    does not use the Python logging module, there is nothing for us to see on this
    panel yet.
  prefs: []
  type: TYPE_NORMAL
- en: Redirect handling by the debug toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now recall the reason we started investigating the debug toolbar: we found
    that our original approach to tracking SQL queries for a page did not work for
    pages that returned an HTTP redirect instead of rendering a template. How does
    the debug toolbar handle this better? To see this, click on the **Television Trends**
    link on the home page, select answers for the two questions, and press **Submit**.
    The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This page shows an example of why it is sometimes necessary to use the **Hide**
    option on the toolbar, since the toolbar itself obscures part of the message on
    the page. Hiding the toolbar shows that the full message is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Django Debug Toolbar has intercepted a redirect to the above URL for
    debug viewing purposes. You can click the above link to continue with the redirect
    as normal. If you''d like to disable this feature, set the DEBUG_TOOLBAR_CONFIG
    dictionary''s key INTERCEPT_REDIRECTS to False.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What the debug toolbar has done here is intercepted the redirect request and
    replaced it with a rendered response containing a link to the location specified
    in the original redirect. The toolbar itself is still in place and available to
    investigate whatever information we might like to see about the processing of
    the request that generated the redirect. For example, we can click on the **SQL**
    section and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the SQL queries that were needed to process the inbound posted form.
    Not surprisingly, the first four are exactly the same as what we saw for generating
    the form in the first place, since the same code path is initially followed for
    both GET and POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is only after those queries are issued that the `display_active_survey`
    view has different code paths for GET and POST. Specifically, in the case of a
    POST, the code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The fifth and sixth queries listed on this page are retrieving the specific
    answer instances that were selected on the submitted form. Unlike the GET case,
    where all answers for a given question were being retrieved in the fifth and sixth
    queries, these queries specify an answer `id` in the SQL WHERE clause as well
    as a question `id`. In the POST case, it is not necessary to retrieve all answers
    for a question; it is sufficient to retrieve only the one that was chosen.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling the stack trace for these queries shows that they are resulting from
    the `if not qf.is_valid()` line of code. This makes sense, since in addition to
    validating the input, the `is_valid` method normalizes the posted data before
    placing it in the form's `cleaned_data` attribute. In the case of a `ModelChoiceField`,
    the normalized value is the chosen model object instance, so it is necessary for
    the validation code to retrieve the chosen object from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After both submitted forms are found to be valid, the `else` leg of this code
    runs. Here, the vote count for each chosen answer is incremented, and the updated
    `answer` instance is saved to the database. This code, then, must be responsible
    for the final four queries previously shown. This can be confirmed by checking
    the stack trace for those four queries: all point to the `answer.save()` line
    of code.'
  prefs: []
  type: TYPE_NORMAL
- en: But why are four SQL statements, two SELECT and two UPDATE, needed to save two
    answers to the database? The UPDATE statements are self-explanatory, but the SELECT
    statements that precede them are a bit curious. In each case, the constant 1 is
    selected from the `survey_answer` table with a WHERE clause specifying a primary
    key value that matches the `survey` that is in the process of being saved. What
    is the intent of this query?
  prefs: []
  type: TYPE_NORMAL
- en: What the Django code is doing here is attempting to determine if the `answer`
    being saved already exists in the database or if it is new. Django can tell by
    whether any results are returned from the SELECT if it needs to use an UPDATE
    or an INSERT when saving the model instance to the database. Selecting the constant
    value is more efficient than actually retrieving the result when the only information
    needed is whether the result exists.
  prefs: []
  type: TYPE_NORMAL
- en: You might think the Django code should know, just based on the fact that the
    primary key value is already set for the model instance, that the instance reflects
    data that is already in the database. However, Django models can use manually-assigned
    primary key values, so the fact that the primary key value has been assigned does
    not guarantee the model has already been saved to the database. Therefore, there
    is an extra SELECT to determine the model status before saving the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The survey application code, though, certainly knows that all of the `answer`
    instances it is saving when processing a survey response are already saved in
    the database. When saving, the survey code can indicate that the instance must
    be saved via an UPDATE and not an INSERT by specifying `force_update` on the save
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we make that change and try submitting another survey, we see that the SELECT
    queries have been eliminated from processing for this case, reducing the total
    number of queries needed from 10 to 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redirect handling by the debug toolbar](img/7566_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Yes, I realize that earlier I said now was not the time for making optimizations,
    yet here I went ahead and made one. This one was just too easy to pass up.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered all of the panels displayed by default by the Django Debug
    Toolbar, and seen how its default handling of returned redirects allows investigation
    of the processing that led up to the redirect. It is a very flexible tool: it
    supports adding panels, changing what panels are displayed, changing when the
    toolbar is displayed, and configuration of various other options. Discussing all
    of this is beyond the scope of what is covered here. Hopefully what has been covered
    gives you a taste for the power of this tool. If you are interested in learning
    more details on how to configure it, the README linked from its home page is a
    good place to start.'
  prefs: []
  type: TYPE_NORMAL
- en: For now we will leave the Django Debug Toolbar and continue with a discussion
    of how to track the internal state of our application code through logging. For
    this we will want to first see how the logging appears without the toolbar, so
    at this point we should comment out the toolbar middleware in `settings.py`. (Note
    that it is not necessary to remove the `debug_toolbar` listing from `INSTALLED_APPS`,
    since this is only necessary for the application template loader to find templates
    specified by the middleware.)
  prefs: []
  type: TYPE_NORMAL
- en: Tracking internal code state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes even all of the information available from a tool like the Django
    Debug Toolbar is not enough to figure out what is going wrong to produce incorrect
    results during processing of a request. The problem probably lies somewhere in
    the application code, but from visual inspection we just cannot figure out what
    is wrong. To solve the problem we need to get more information about the internal
    state of the application code. Perhaps we need to see what the flow of control
    is through the functions in the application, or see what values are calculated
    for some intermediate results that ultimately cause the code to go down a wrong
    path.
  prefs: []
  type: TYPE_NORMAL
- en: How do we get this kind of information? One way is to run the code under a debugger,
    and actually step through it line by line to see what it is doing. This approach
    will be covered in detail in the next chapter. It is very powerful, but can be
    time-consuming and is not practical in all situations. For example, it is difficult
    to use for problems that crop up only during production.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to get the code to report, or log, what it is doing. This is
    the approach that will be covered in this section. This approach does not provide
    access to the full range of information that would be available under a debugger,
    but with good choices of what to log, it can provide enough clues to solve many
    problems. It can also be used more easily for production-only problems than the
    approach of running under a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Resist the urge to sprinkle prints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running under the development server, the output from `print` appears on
    the console, so it is easily accessible. Thus, when faced with some Django application
    code that is misbehaving during development, it is tempting to simply start adding
    ad-hoc `print` statements at key points in an attempt to figure out what is going
    on inside the code. While very tempting, it is usually a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it a bad idea? First, the problem rarely becomes obvious with just one
    or two `print` statements. It may seem at first that if we just know if the code
    gets to here or there, all will be clear. But it isn't, and we wind up adding
    more and more `print` statements, perhaps printing out values of variables, and
    both the code itself and the development server console become a mess of ad-hoc
    debug information.
  prefs: []
  type: TYPE_NORMAL
- en: Then, once the problem is solved, all of those `print` statements need to be
    removed. We generally don't want them cluttering up either the code or the console
    with their output. Removing them all is a nuisance, but necessary, since some
    production environments disallow access to `sys.stdout`. Thus, a stray `print`
    left over from development debugging can cause a server error during production.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when the same or a similar problem comes up again, and it was solved in
    the past by the "sprinkle `print`" method, virtually all of the work done before
    may need to be re-done again in order to figure out what is wrong this time. The
    previous experience might give us a better idea of what `print` statements to
    put where, but if we've already deleted them after solving the first problem,
    a fair amount of work may be involved in re-doing essentially the same thing for
    the next variant of the problem that arises. This is a waste of effort.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence highlights a few main problems with the "sprinkle `print`" method
    of development debugging. First, the developer needs to decide, right at the point
    where the `print` is added, under what conditions it should be produced and where
    the output should go. It's possible to bracket added `print` statements with conditionals
    such as `if settings.DEBUG`, which might allow the added debugging support to
    remain in the code long-term, but this is a nuisance and adds clutter to the code,
    so it tends not to be done. It's also possible to specify in the `print` that
    the output should be routed someplace other than the default of `sys.stdout`,
    but again that is more work and tends not to be done.
  prefs: []
  type: TYPE_NORMAL
- en: These problems lead to sprinkled `print` statements that are immediately removed
    when a problem is solved, leaving the code in a state where by default it reports
    nothing about its operation. Then when the next problem occurs, the developer
    has to start all over again with adding reporting of debug information.
  prefs: []
  type: TYPE_NORMAL
- en: A far better approach is to use some disciplined logging throughout development,
    so that by default, at least when `DEBUG` is turned on, the code reports something
    about what it is doing. If it does so, then it is quite possible that no additional
    debug information needs to be collected in order to solve problems that crop up.
    Furthermore, use of a logging facility allows for the configuration of under what
    conditions messages should be output, and where they should go, to be separated
    from the actual logging statements.
  prefs: []
  type: TYPE_NORMAL
- en: Simple logging configuring for development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A preferred alternative to `print` statements for debugging, then, is to use
    the python `logging` module. The actual logging calls are as easy to make as they
    are with `print`. For example, a `print` to track calls into `display_active_survey`
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the print reports the function that has been called; along with the `request.method`
    and the primary key of the survey it has been passed. On the development server
    console, the output for getting an active survey page would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent call, only using Python `logging`, might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here the `logging.debug` call is used to specify that the passed string is a
    debug-level message. The concept of levels allows the calling code to assign a
    measure of importance to the message without actually making any decisions about
    whether the message should be output in the current circumstances. Rather, that
    decision is made by the logging facility, based on the currently set threshold
    level for logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `logging` module provides a set of convenience methods for logging
    messages with the default defined levels. These are, in increasing order of level:
    `debug`, `info`, `warning`, `error`, and `critical`. Thus, this `logging.debug`
    message will only be output if the `logging` module''s level threshold has been
    set to include debug-level messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem with using this `logging.debug` statement in place of a `print`
    is that by default the logging module level threshold is set to `warning`. Thus,
    only `warning`, `error`, and `critical` messages are output by default. We need
    to configure the `logging` module to output debug-level statements in order for
    this message to appear on the console. An easy way to do this is to add a call
    to `logging.basicConfig` in the `settings.py` file. We can make the call contingent
    on `DEBUG` being turned on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With that code added to `settings.py`, and the `logging.debug` call in the
    `display_active_survey` function, the development console will now show the message
    when the `display_active_survey` function is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `DEBUG:root:` prefix on the message is a result of the default
    formatting applied to logged messages. `DEBUG` indicates the level associated
    with the message and `root` identifies the logger that was used to log the message.
    Since the `logging.debug` call does not specify any particular logger, the default
    of `root` was used.
  prefs: []
  type: TYPE_NORMAL
- en: Other parameters to `logging.basicConfig` could be used to change the formatting
    of the message, but full coverage of all the features of Python logging is beyond
    the scope of what we need to cover here. For our purposes, the default formatting
    will be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that can be specified in the logging configuration is where the
    messages should be routed. We did not do so here, since the default of `sys.stderr`
    is sufficient for development debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By switching from `print` to `logging`, we've removed the need for the developer
    adding the logging to decide under exactly what conditions the logged information
    should be produced, and where exactly it should go. The developer simply needs
    to identify the level of importance associated with the message, and then the
    logging facility itself will decide what to do with the logged information. The
    next question, then, is what should be logged?
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is hard to know what information will be most useful to log when
    writing code. As developers we might make some guesses, but until we get some
    experience with the code as it actually runs, it is hard to be sure. Yet, as previously
    mentioned, it can be very helpful for code to have some built-in reporting of
    basic information about what it is doing. Thus, it is good to have some guidelines
    to follow for logging that should be included by default when initially writing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One such guideline might be to log entry and exit to all "significant" functions.
    The entry log message should include the values for any key parameters, and the
    exit log message should give some indication of what the function returned. With
    just this type of entry and exit logging (assuming a reasonably good split of
    code into manageable functions), we'll be able to get a pretty clear picture of
    the flow of control through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Manually adding entry and exit logging, however, is a nuisance. It can also
    add clutter to the code. In reality, it is unlikely that a guideline to log all
    significant function entries and exits will be happily followed, unless it is
    much easier to do than adding the type of logging message previously noted for
    entry to `display_active_survey`.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Python provides facilities to make it easy to do exactly what we
    are looking for here. Functions can be wrapped in other functions, allowing the
    wrapping function to do things such as log entry and exit, with parameter and
    return information. Furthermore, the Python decorator syntax allows such wrapping
    to be accomplished with minimal added code clutter. In the next section, we will
    develop some simple logging wrappers for use with our existing survey application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators to log function entry and exit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One disadvantage of using general-purpose wrappers instead of embedding entry/exit
    logging in the functions themselves is that it makes it more difficult to accomplish
    fine-grained control over what parameter and return information is logged. It
    is easy to write a general wrapper that logs all parameters, or no parameters,
    but it is difficult to impossible to write one that logs some subset of the parameters,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Why not just log all parameters? The problem with this is that some often-used
    parameters in Django applications, such as request objects, have a very verbose
    representation. Logging their full values would produce too much output. It's
    better to start with a general-purpose wrapping logger that does not log any parameter
    values, in addition to maybe one or more special-purpose ones that can be used
    for functions with predictable parameters to log key information in those parameters.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a special-purpose wrapper for logging entry and exit to view functions
    is likely worthwhile. A view always gets an `HttpRequest` object as its first
    parameter. While logging the full object is not helpful, logging the request method
    is both short and useful. Furthermore, since additional parameters to the view
    function come from the requested URL, they are probably not too verbose to log
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: What about return values—should they be logged? Probably not in general for
    a Django application, which will often have functions that return `HttpResponse`
    objects. These are generally too large to be helpful when logged. However, it
    is typically useful to log at least some information about return values, such
    as their type.
  prefs: []
  type: TYPE_NORMAL
- en: We've come up with two wrappers, then, to start with. The first, which will
    be named `log_call`, will log the entry to and exit from a function. No entry
    parameter information will be logged by `log_call`, but it will log the type of
    result it returns. The second wrapper will be more specialized, and will be used
    for wrapping view functions. This one will be named `log_view`. It will log the
    request method and any additional parameters passed to the wrapped view, as well
    as the type of its return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where should this code go? Again, it is not tied in any way to the survey application,
    so it makes sense to put it in `gen_utils`. We''ll create a file in `gen_utils`
    then, named `logutils.py`, that can hold any general logging utility code. We''ll
    start with an implementation of the `log_call` wrapper previously described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This implementation uses the class-based style of writing wrapping functions.
    Using this style, the wrapper is defined as a class that implements `__init__`
    and `__call__` methods. The `__init__` method is called at the time the wrapper
    is created, and is passed the function it is wrapping. The `__call__` method is
    called when the wrapped function is actually called. The `__call__` implementation
    is responsible for doing whatever the wrapping function requires, calling the
    wrapped function, and returning its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the implementation is split into two classes: the base `LoggingDecorator`
    that implements `__init__`, and then `log_call`, which inherits `__init__` from
    `LoggingDecorator` and implements `__call__`. The reason for this split is so
    that we can share the common `__init__` for multiple logging wrappers. All the
    `__init__` does is save a reference to the wrapped function to be used later when
    `__call__` is called.'
  prefs: []
  type: TYPE_NORMAL
- en: The `log_call __call__` implementation, then, first logs a message that the
    function was called. The name of the wrapped function can be found in its `__name__`
    attribute. The wrapped function is then called, and its return value is saved
    in `rv`. A second message is logged noting the type returned by the called function.
    Finally, the value returned by the wrapped function is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log_view` wrapper is very similar to `log_call`, differing only in the
    details of what it logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here the first logged message includes, in addition to the name of the wrapped
    function, the `method` attribute of the first positional argument and the keyword
    arguments passed to the wrapped function. This wrapper, since it is intended to
    be used for wrapping view functions, assumes the first positional argument is
    an `HttpRequest` object, which has a `method` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Further, this code assumes all other arguments will be passed as keyword arguments.
    We know that this will be the case for the survey application code, since all
    of the survey URL patterns specify named groups. A more general view wrapper would
    need to log `args` (except the first one, an `HttpRequest` object) as well, if
    it wanted to support non-named groups used in the URL pattern configuration. For
    the survey application, this would just result in logging information that is
    always the same, so it has been omitted here.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the decorators to the Survey code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s add these decorators to the survey view functions and see what some
    typical output from browsing looks like. Adding the decorators is easy. First,
    in `views.py`, add an import for the decorators near the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for all functions that are actually views, add `@log_view` above the
    function definition. (This syntax assumes the Python version in use is 2.4 or
    higher.) For example, for the home page, view definition becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Do the same for `survey_detail` and `survey_thanks`. For the utility functions
    `display_active_survey` and `display_completed_survey`, use `@log_call` instead.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we browse around the survey site, we will have messages logged on
    the console that track basic information about what code is being called. For
    example, we might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the home page view was called, and returned an `HttpResponse`.
    Following the survey application''s logged messages, we see the normal printout
    from the development server noting that a `GET` for `/` returned a response with
    code `200` (HTTP OK) and containing `1184` bytes. Next, we might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This shows the `survey_detail` view being called with a `GET`, likely from a
    link on the home page returned by the previous response. Further, we can see that
    the particular survey requested has a primary key of `1`. The next log message
    reveals that this must be an active survey, since `display_active_survey` is called.
    It returns an `HttpResponse`, as does the `survey_detail` view, and again the
    last survey log message is followed by Django's own printout summarizing the request
    and its outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Again this looks like a natural progression from the previous response: a `POST`
    for the same survey that was retrieved by the previous request. The `POST` indicates
    that the user is submitting a survey response. However, the return type of `HttpResponse`
    that is logged indicates that there is some problem with the submission. (We know
    an `HttpResponse` to a POST only occurs when a form is found to be invalid in
    `display_active_survey`.)'
  prefs: []
  type: TYPE_NORMAL
- en: This might be a place where we would want to add additional logging beyond the
    entry/exit information, to track the specific reasons why a posted form was deemed
    invalid. In its current form, all we can know is that the returned response, since
    it was slightly larger than the original (`2466` versus `2197` bytes), likely
    included an error annotation noting what needed to be fixed on the form in order
    for it to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we might see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This starts out as a repeat of the previous request, a `POST` to the `survey_detail`
    view for the survey with primary key `1`. However, this time an `HttpResponseRedirect`
    is returned, indicating that the user must have corrected whatever problem existed
    in the first submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, we would likely see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This shows the request that the browser will automatically make on receiving
    the redirect returned by the previous request. We see the `survey_thanks` view
    logging a `GET` for the same survey as all the previous requests, and an `HttpResponse`
    being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can see how with very little effort we can add some basic logging that
    provides a general overview of the flow of control through our Django application
    code. Note that the logging decorators defined here are not perfect. For example,
    they don't support decoration of methods instead of functions, they impose some
    overhead even when no logging is desired, and they have some side-effects resulting
    from turning functions into classes.
  prefs: []
  type: TYPE_NORMAL
- en: All of these drawbacks can be overcome with some care in the development of
    the wrappers. However, the details of that are beyond the scope of what we can
    cover here. The ones presented here have the advantage of being reasonably simple
    to understand, and functional enough to hopefully demonstrate the usefulness of
    having an easy built-in logging mechanism to see the flow of control, along with
    perhaps some key parameters, through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in the debug toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that we skipped over any examination of the debug toolbar's logging panel
    since we had no logging in the survey application code. Let's return now to the
    debug toolbar and see how the added logging appears there.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, though, let''s add an additional log message to note what causes a POST
    request for an active survey to fail. As mentioned in this previous section, this
    could be useful to know. So, in the `display_active_survey` function add a logging
    call after a form is found to be invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: (Note it will also be necessary to add an `import logging` before use of `logging`.)
    With that additional log message, we should be able to get specific information
    about why a particular survey submission was considered invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now re-activate the debug toolbar by un-commenting its middleware in `settings.py`,
    browse to an active survey page, and attempt to force production of that log message
    by submitting an incomplete survey. When the response is returned, clicking on
    the toolbar''s **Logging** panel will bring up a page that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging in the debug toolbar](img/7566_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On this page, we can see that in addition to the messages themselves and their
    assigned levels, the toolbar also reports the date and time they were logged in
    addition to the location in the code where they were generated. Since most of
    these log messages are coming from the wrapping functions, the location information
    here is not particularly useful. However, the newly added log message is correctly
    matched to where it appears in the code. Indeed the logged message makes it clear
    that the problem with the form was a missing choice for an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now reached the end of discussing techniques for getting more information
    about how Django application code is running. In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Developed some template utility code to track what SQL requests are made during
    production of a page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned that creating re-usable general utility code can turn into more work
    than it might first seem to require
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned how the Django Debug Toolbar can be used to get the same information
    as in our home-grown code in addition to more information, with much less effort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the usefulness of applying a general logging framework during code
    development, as opposed to relying on the ad-hoc "sprinkle `print`" method of
    debugging problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the use of these tools and techniques, we are able to glean a great deal
    of information about the working of our code. Having a good understanding of how
    the code behaves when it is working properly makes it much easier to debug problems
    when they occur. Furthermore, checking on exactly what the code is doing even
    when it seems, from all outward appearances, to be working correctly, may reveal
    hidden issues that could become big problems as the code moves from development
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, even all of the information available by using these techniques
    is insufficient to solve a problem at hand. In those cases, the next step may
    be to run the code under a debugger. This is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
