- en: Automating Application Delivery with F5 LTM and Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will outline how to automate F5 BIG-IP platforms running
    as **load balancers** (**LBs**) or **Local Traffic Manager** (**LTM**) appliances.
    We will explore how to interact with F5 LTM nodes using Ansible and how to onboard
    these devices and accelerate application deployment hosted by these devices, using
    various Ansible modules. We will base our illustration on the following sample
    network diagram. The diagram shows single F5 LTM nodes connected to **direct current**
    (**DC**) switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27890347-0c13-4b72-946d-5d198bf422b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The main recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and authenticating to BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring generic system options on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring interfaces and trunks on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring **virtual local area networks** (**VLANs**) and **self-internet
    protocols** (**self-IPs**) on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring static routes on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying nodes on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a load balancing pool on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring virtual servers on BIG-IP devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving operational data from BIG-IP nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code used in the recipes in this chapter can be found on the following
    GitHub repository: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch5_f5](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch5_f5).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the software releases on which this chapter is based:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F5 BIG-IP device running BIG-IP 13.1.1, Build 0.0.4 final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2RE5tOL](https://bit.ly/2RE5tOL)'
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible network inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build and structure our Ansible inventory
    to describe our sample F5 BIG-IP nodes. Building an Ansible inventory is a mandatory
    step in telling Ansible how to connect to the managed devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a new folder that will host all the files that we will create
    in this chapter. The new folder is named `ch5_f5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the new folder, `ch5_f5`, we create a `hosts` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `Ansible.cfg` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have a single LTM node in our network topology, this simplifies our
    Ansible inventory file. In our `hosts` file, we create a single group (called
    `ltm`) and we specify a single node in it, which is called `ltm01`. We specify
    the management IP addresses for the nodes, using the `Ansible_host` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The management port on the BIG-IP device must have this IP address configured,
    and IP connectivity between the Ansible control machine and the BIG-IP node is
    established over this management port.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create the `Ansible.cfg` file and configure it to point to our `hosts`
    file, to be used as an Ansible inventory file. We disable the setup module, which
    is not needed when running Ansible against network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting and authenticating to BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to connect to BIG-IP nodes from Ansible
    via the **Representational State Transfer** (**REST**) API exposed by BIG-IP device,
    in order to start managing the devices from Ansible. We are going to use usernames
    and passwords to authenticate to the BIG-IP node in our topology.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along with this recipe, an Ansible inventory file should
    be constructed as per the previous recipe. IP reachability must be established
    between the Ansible control machine and all the devices in the network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the `ch5_f5` folder, create a `group_vars` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `group_vars/all.yml` file with the following connection parameters
    settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook with the name `pb_f5_onboard.yml`, with the following
    task to create new system users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_f5_onboard.yml` playbook with the following task to update the
    admin user account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible uses the  REST API on the F5 LTM nodes in order to manage the BIG-IP
    nodes. Ansible establishes an HTTPS connection to the BIG-IP node and uses it
    as the transport mechanism to invoke the REST API on the BIG-IP node. In order
    to establish the HTTPS connection with the BIG-IP system, we need to provide some
    parameters in order for Ansible to initiate and establish a connection with the
    BIG-IP node. These parameters include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Username/password to authenticate with the BIG-IP REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address and port, over which we can reach the REST API endpoint on the BIG-IP
    node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we validate the certificate for the BIG-IP node negotiated over the
    HTTPS session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We include all these parameters in a dictionary called `conn_parameters`, which
    we include in the `group_vars/all.yml` file, so as to be applied on any BIG-IP
    node.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a new LTM device comes with the `admin/admin` default username and
    password for the **graphical user interface** (**GUI**) and REST API access. We
    use these credentials as the user and password variables inside the `conn_parameters`
    dictionary, and we specify the `Ansible_host` variable as the IP address over
    which the REST API can be established over port `443`. Finally, we disable certificate
    validation, since the certificate on the BIG-IP node is self-signed.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new variable called `users`, which holds all the new users that
    we want to configure on our LTM, along with their role/privilege. In this case,
    we want to provide administrative privileges for the Ansible user across all the
    partitions on the LTM node.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new playbook for onboarding a new LTM node. In the first task, we
    create the new users using the `bigip_user` module, and we provide the parameters
    to establish the HTTPS connection, using the `provider` attribute. We loop over
    all the users in our `users` variable to provision them.
  prefs: []
  type: TYPE_NORMAL
- en: The second task also uses the `bigip_user` module in order to update the default
    `admin` profile on the LTM and to change this default password to a new password
    specified in the `admin_passwd` variable.
  prefs: []
  type: TYPE_NORMAL
- en: On the playbook level, we are setting the connection to `local`. This is because
    we are going to establish the HTTPS connection from the Ansible control machine,
    and we want to prevent Ansible from using **Secure Shell** (**SSH**) to connect
    to the LTM node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the new Ansible user created on the BIG-IP node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e027eff4-2fc6-421a-8c26-9ce4f291d62f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the details of the Ansible user created using
    the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/42db9ea5-67fc-498c-a7ca-f76a2b83a20d.png)'
  prefs: []
  type: TYPE_IMG
- en: We are using a plaintext password for simplicity; however, a plaintext password
    should never be used. Ansible Vault should be used to secure the password.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After adding the new Ansible user, we update the `conn_parameters` dictionary
    with the new user that we have created. We can start managing the LTM nodes with
    this user, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Configuring generic system options on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure some basic system options such
    as hostname, **Domain Name System** (**DNS**), and the **Network Time Protocol**
    (**NTP**) on BIG-IP nodes. We will understand how to set up all these system-level
    parameters using the various Ansible modules available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up. IP connectivity between Ansible and the BIG-IP nodes is already established,
    with the correct user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/all.yml` file with the following system-level parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new folder called `tasks` and create an `f5_system.yml` file with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `pb_f5_onboard.yml` file, add the following highlighted tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to configure the various system parameters on BIG-IP nodes, we use
    a separate module for each task. We group all these tasks in a single file called
    `f5_system.yml` under the `tasks` folder, and inside this file, we use three separate
    tasks/modules, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bigip_hostname` to set up the hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_device_dns` to set up the DNS server that the BIG-IP node will use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_device_ntp` to set up the NTP servers on the BIG-IP node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these modules take the `conn_parameters` dictionary to correctly set up
    how to communicate with the REST API of the BIG-IP node. In our sample topology,
    we use a single server as the DNS and NTP. We describe it using the `nms_servers`
    variable in the `group_vars/all.yml` file, to apply to all our nodes in our Ansible
    inventory.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure the hostname, we need to supply a **fully qualified domain
    name** (**FQDN**) for the device. So, we configure our domain again under the
    `group_vars/all.yml` file and use it in conjunction with the device name to set
    up its hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this playbook, we can see that the configuration is applied to
    the BIG-IP node. The following screenshot shows that the Host Name is correctly
    provisioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a93c4e9f-0d35-49f2-af99-2e69cdd359dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The NTP configuration is deployed correctly, as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23fdad58-75d6-4d81-b37b-0751bb0068ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The DNS is configured correctly, as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f9537f9-1277-4ef7-b402-6987b1abdf07.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring interfaces and trunks on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to set up trunks on BIG-IP devices. Trunk
    ports on BIG-IP nodes are used to provide increased redundancy for the device,
    by combining multiple interfaces into a single logical interface. It is very similar
    to port channels in traditional network vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up. IP connectivity between Ansible and the BIG-IP nodes is already established,
    with the correct user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `host_vars` folder and create a `ltm01.yml` file with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `tasks` folder, add a new file called `f5_interfaces.yml` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_f5_onboard.yml` playbook with the following new task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define the host-specific data for the LTM device under the `host_vars` folder,
    in a file called `ltm01.yml`. In this file, we define the physical interface on
    the LTM node under the `phy_interfaces` variable. We define another variable called
    `trunks` in order to define the trunks available on the device. In the `trunks`
    variable, we reference the `phy_interfaces` variable in order to limit data duplication.
  prefs: []
  type: TYPE_NORMAL
- en: In the `f5_interfaces.yml` task file, we add a new task using the `bigip_trunk`
    module to provision the required trunks on the BIG-IP node. We loop over the `trunks`
    data structure to provision all the required trunk ports. In this task, we supply
    different parameters that adjust the trunk properties (such as disable the **Link
    Aggregation Control Protocol** (**LACP**)) and set up the correct method to distribute
    the frames across the trunk ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the playbook, we can see that the required trunk Interfaces are
    provisioned, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/70a5696e-b909-4f39-9818-07a08c18d74d.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the `bigip_trunk` Ansible module, and the different
    options regarding how to deploy trunk ports on the BIG-IP nodes, please refer
    to the following URL: [https://docs.Ansible.com/Ansible/latest/modules/bigip_trunk_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_trunk_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VLANs and self-IPs on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to configure VLANs on BIG-IP nodes. VLANs
    on the BIG-IP nodes are fundamental for traffic separation for the different applications
    hosted by the BIG-IP LTM nodes. They are fundamental to designating external (internet-facing)
    and internal (server-facing) domains. We will also outline how to assign an IP
    address on the VLAN interfaces that we provision.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up. IP connectivity between Ansible and the BIG-IP nodes is already established,
    with the correct user credentials. As all the VLANs in this setup will be deployed
    on trunk ports, we need to have the trunk ports already provisioned, as per the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `host_vars/ltm01.yml` file under the `host_vars` folder with the
    following VLAN data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `f5_interfaces.yml` file under the `tasks` folder with the task
    to provision VLANs, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `f5_interfaces.yml` file under the `tasks` folder with the task
    to provision the IP addresses on the respective VLANs, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We add the `vlans` data structure in `host_vars/ltm01.yml` to declare all the
    VLANs that we need to provision on the LTM node, along with the IP addresses associated
    with this VLAN.
  prefs: []
  type: TYPE_NORMAL
- en: We update the `f5_interfaces.yml` file with a task using the `bigip_vlan` module
    to provision the VLANs on the BIG-IP node, and we loop over the `vlans` data structure
    to extract all the required parameters to set up the needed VLANs. Next, we add
    another task using the `bigip_selfip` Ansible module to deploy the IP addresses
    on the VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the playbook again, we can see the VLANs and self-IPs on the
    BIG-IP node, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fe846472-f643-46dc-8c0a-34c03e1bb338.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The correct IP address is configured correctly on the VLAN interface, as per
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e02acc83-96e3-449d-b708-9ff502f6b703.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more options regarding how to deploy VLANs and self-IPs on the BIG-IP nodes,
    please refer to the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bigip-vlan`'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/bigip_vlan_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_vlan_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '`bigip-selfip`'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.Ansible.com/Ansible/latest/modules/bigip_selfip_module.html#bigip-selfip-module](https://docs.ansible.com/ansible/latest/modules/bigip_selfip_module.html#bigip-selfip-module)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring static routes on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After deploying the VLANs and IP addresses on the BIG-IP device, we need to
    configure routing on the BIG-IP nodes in order to reach the external destination.
    We use static routes in our topology in order to provision the required routing
    on the LTM node. In this recipe, we will outline how to configure static routes
    on BIG-IP devices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and IP connectivity between Ansible and the BIG-IP nodes is already established,
    with the correct user credentials. Furthermore, we need to deploy the VLANs and
    IP addresses in the BIG-IP node, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `host_vars/ltm01.yml` file with the following routing data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_f5_onboard.yml` file with the following task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We add the `routes` data structure under the `host_vars/ltm01.yml` file to declare
    all the static routes that need to be provisioned on the LTM node.
  prefs: []
  type: TYPE_NORMAL
- en: We update the `pb_f5_onboard.yml` playbook with a task to provision the static
    routes using the `bigip_static_route` module, and we loop over the `routes` data
    structure to provision all the needed routes on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the playbook again, we can see the correct static routes, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e89a8c6-85b8-4d73-949c-e8fe27fc2cba.png)'
  prefs: []
  type: TYPE_IMG
- en: Deploying nodes on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using BIG-IP LTM to deploy an application requires load balancing of the application
    traffic across multiple servers. This requires us to define the servers/instances
    that are hosting the application. In BIG-IP, these instances are called nodes
    and they identify each server with a unique IP address. In this recipe, we are
    going to start deploying a new application (web server) on the BIG-IP device,
    and we will provision the nodes that are carrying this service using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic setup for the BIG-IP should be already completed as per the previous
    recipes, and the correct VLANs to reach these nodes (physical servers) must be
    deployed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new YAML file called `web_app.yml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Ansible playbook called `pb_f5_deploy_app.yml` with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define all the parameters for our new web application that should be hosted
    on the BIG-IP LTM device in a YAML file called `web_app.yaml`. In this file, we
    include a `pool_members` parameter to outline the web servers that will house
    the application. We use this parameter to create the nodes on the BIG-IP LTM.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new playbook for application deployment, called `pb_f5_deploy_app.yml`.
    We include the `web_app.yml` file so as to have access to all the parameters defined
    for this app. We create a new task using the `bigip_node` module to provision
    a new node on the BIG-IP appliance, and we loop through the `pool_members` parameter
    derived from the `web_app.yml` file to provision all the required nodes on the
    BIG-IP appliance. In order to connect to the BIG-IP node, we use the same previous
    provider attribute with the `conn_parameters` parameter defined in the `group_vars/all.yml` file
    to establish the connection with the BIG-IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this playbook, we create all the required nodes, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e0103c7-336a-4e03-92e5-caf6650a098a.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a load balancing pool on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating a node on the BIG-IP, we need to create a load balancing pool
    for the application that we are deploying and assign pool members from the nodes
    that we have created into this pool. In this recipe, we will outline how to provision
    load balancing pools on the BIG-IP nodes, and how to assign members to the load
    balancing pool.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that all the previous recipes have been implemented and
    that the nodes on the BIG-IP are already provisioned, as per the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_f5_deploy_app.yml` playbook with the following task to create
    a new pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_f5_deploy_app.yml` playbook with the following task to assign
    pool members to the newly created pool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we create a load balancing pool on the BIG-IP system using the
    `bigip_pool` module, and we specify the load balancing technique that should be
    used on this pool. In this example, we are using the `round-robin` technique.
    We create the pool name using the different parameters extracted from the `web_app.yml`
    file (mainly the website and `vip_port`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we assign the pool members to this newly created pool using the `bigip_pool_member`
    module and loop through all the `pool_members` defined in the `web_app.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that all these procedures create a consistent method for defining
    the pool names, as well as assigning the required pool members to the correct
    pool member. All the information is retrieved from a single definition file that
    describes and outlines how the service should be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running these two tasks, we will see that the pool is correctly created with
    the correct pool members, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f819655c-1d20-4c4d-a3cf-3ae7b81da67f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the current members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd97973c-1947-4845-8522-000e93f7e12a.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we outlined the basic use for the Ansible modules to provision
    load balancing pools on the BIG-IP nodes. However, there are more options available
    for these modules, such as specifying the load balancing ratio for each member,
    as well as attaching monitors for the overall pool. Please consult the following
    URLs for more options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bigip_pool`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_pool_module.htmlb](https://docs.ansible.com/ansible/latest/modules/bigip_pool_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_pool_member`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_pool_member_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_pool_member_module.html#bigip-pool-member-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring virtual servers on BIG-IP devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last part in deploying an application on the BIG-IP LTM for load balancing
    is configuring the virtual server on the BIG-IP LTM node, and creating a **virtual
    IP** (**VIP**) on the BIG-IP node for this virtual server. In this recipe, we
    outline how to deploy the virtual server using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that all the previous recipes are completed, and a load
    balancing pool and pool members are already configured.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `pb_f5_deploy_app.yml` playbook with the following task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `bigip_virtual_server` module to provision the required virtual server
    on the BIG-IP appliance, by specifying the parameters defined in the `web_app.yml`
    file. We also define and provision the profiles that need to be applied to the
    newly created virtual server. These profiles are the HTTP and SSL profiles. These
    profiles are already created by default on the BIG-IP node, and in a case where
    we need to create custom profiles, we need to create these in a separate task,
    using the appropriate Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this last task, we can see that the Virtual Server is created, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3f6ccbc6-1552-4b76-b73d-4748a42fc8bb.png)'
  prefs: []
  type: TYPE_IMG
- en: In this last task, we have created a functional service VIP on the LTM node,
    in order to start processing HTTP requests for our new website and to load balance
    the traffic across all the instances in the load balancing group.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we discussed the basic use of the Ansible module to provision
    virtual servers on the BIG-IP nodes. However, there are more options available
    in order to tweak the configuration for the virtual server that needs to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more Ansible modules that let you create profiles you can use to
    attach to the virtual server, and the following are some links for these modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bigip_virtual_server`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_virtual_server_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_virtual_server_module.html#bigip-virtual-server-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_profile_http`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_profile_http_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_profile_http_module.html#bigip-profile-http-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_profile_client_ssl`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_profile_client_ssl_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_profile_client_ssl_module.html#bigip-profile-client-ssl-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigip_profile_server_ssl`: [https://docs.Ansible.com/Ansible/latest/modules/bigip_profile_server_ssl_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_profile_server_ssl_module.html#bigip-profile-server-ssl-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving operational data from BIG-IP nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we outline how to retrieve operational data for different components
    on the BIG-IP appliance in terms of the network state of the BIG-IP nodes, such
    as interfaces and VLANs, as well as data relating to the components responsible
    for application delivery, such as virtual servers and pools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this recipe, an Ansible inventory is assumed to be already
    set up, and IP connectivity between Ansible and the BIG-IP nodes is already established,
    with the correct user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Ansible playbook, `pb_f5_validate.yml`, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with a new task to filter the interface facts, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_f5_validate.yml` playbook with a new task to validate the interface
    status, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The REST API supported on the BIG-IP node uses different methods to retrieve
    operational data from the device, and it outputs all this data in JSON format.
    The following snippet outlines the interface status gathered from the BIG-IP nodes
    using the `bigip_device_facts` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve the operational facts from the BIG-IP nodes using `bigip_device_facts`,
    and we restrict only the data retrieved from the node using `gather_subset`. We
    include the `interfaces` option only to get the interface data. We save all the
    retrieved output to the `bigip_facts` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new fact for the device, called `net_intfs`. The only use of this
    new fact is to filter the interface facts retrieved from the previous task to
    the interface that we have defined for our device in the `phy_interfaces` parameter
    (which is defined under the `host_vars` folder). This new parameter will include
    only the interface facts for the interfaces that we declared in our design.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `assert` module to validate that all the interfaces that we defined
    for our application are enabled and operational from the retrieved data, and we
    loop over the `net_intfs` variable (which is a list) to loop over all the interfaces
    and confirm that they are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we need to get the operational data for the application that we have deployed
    on the LTM node, we create a new playbook to validate the application deployment
    as shown in the following code, using the `bigip_device_facts` module. We limit
    the data retrieved to only the virtual servers. We validate the data using the
    `assert` statement, as we did in the previous playbook. The following code shows
    the playbook contents for application deployment validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new playbook, `pb_f5_app_validate.yml`, with the following task
    to collect `virtual-servers` facts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We update the playbook with the following tasks to filter the `virtual-servers`
    facts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We update the playbook with the following task to validate the state of the
    virtual server for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These validation playbooks can be extended to validate multiple parameters on
    the virtual servers. Also, we can validate other components such as LTM load balancing
    pools, to build a more comprehensive validation for the application deployed.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the Ansible `bigip_device_facts` module and all
    the information that we can retrieve from the BIG-IP node, please visit the following
    website: [https://docs.Ansible.com/Ansible/latest/modules/bigip_device_facts_module.html](https://docs.ansible.com/ansible/latest/modules/bigip_device_facts_module.html#bigip-device-facts-module).
  prefs: []
  type: TYPE_NORMAL
