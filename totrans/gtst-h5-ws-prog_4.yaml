- en: Chapter 4. Data Transfer – Sending, Receiving, and Decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern web development is all about content. No matter what kind of application
    you are building, users will stop using it unless they get what they want. In
    the old days of the web, the content someone could publish on his/her website
    was extremely limited. Nowadays, content is a lot more than static text and images;
    you can exchange messages, watch videos, download programs, and much more. As
    a web developer, you should be able to deliver the desired content in a fast and
    efficient way. The WebSocket protocol supports a variety of transferable data,
    taking the burden to speed the whole process as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter's demo, you are going to handle image and video data via WebSockets.
    Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of data can WebSockets transfer?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WebSocket protocol supports text and binary data. In JavaScript, text is
    referred to as String, while binary data is represented by the ArrayBuffer and
    Blob classes (the first one is still experimental). Using plain text and binary
    format, you can transfer and decode almost any type of HTML5 media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always keep in your mind that WebSockets only support one binary format at
    a time and you have to explicitly declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another was to do it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Throughout this book, we'll demonstrate specific examples for using each and
    every data type.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already taken a glimpse of transmitting plain text data in the previous
    chapters, where you exchanged simple chat messages. Apart from this, strings are
    tremendously helpful when dealing with human-readable data formats such as **XML**
    and **JSON**.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that whenever the `onmessage` event is raised, the client needs to
    check the data type and act accordingly. JavaScript can easily determine that
    a data type is of `string` type using the strict equal operator (that is, `===`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an average experience with core JavaScript, you''ll probably notice
    that you could have used the following expression instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although this code is pretty valid, it wouldn't work in your case. The reason
    is that the `instanceof` expression requires the object on the left to have been
    created using the JavaScript string constructor. In your case, the data is generated
    from the server, so you can only determine their underlying type instead of their
    JavaScript class.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**) is a lightweight format for transferring
    human-readable data between computers. It is structured in key-value pairs, usually
    describing properties and values. Due to its efficiency, JSON is the dominant
    format for transferring data between server and client. The most popular RESTful
    APIs, including Facebook, Twitter, and Github, nowadays fully support JSON. Moreover,
    JSON is a subset of JavaScript, so you can parse it immediately without using
    external parsers!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the web server somehow sends the following JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the preceding notation contains two key-value pairs. Guess what?
    In your chat demo, it represents the chat data received from another user. You
    are going to use this information in a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following code shows how you can handle a JSON object and extract its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: socket.onmessage = function(event) {
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is straightforward. Using the `eval` function, you create
    a JSON object from the input string. What `eval` really does is invoke the JavaScript
    compiler and execute the enclosed string arguments. The properties of the generated
    object are the names of the JSON keys and each property holds its corresponding
    value.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to JSON, you can parse XML-encoded strings using JavaScript. We won't
    go deeper into XML parsing, as this would be out of this book's scope. Parsing
    XML is not difficult, though it requires different techniques for different browsers
    (**DOMParser** versus **ActiveXObject**). The best method is using a third-party
    library such as **jQuery**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In both XML and JSON cases, the server should send you a string value, not the
    actual XML/JSON file (which would be of binary type, of course)!
  prefs: []
  type: TYPE_NORMAL
- en: ArrayBuffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ArrayBuffer contains structured binary data. The key term here is **structured**,
    which means that the enclosed bits are given in an order, so that you can retrieve
    portions of them. In order to manipulate an ArrayBuffer for specific formats,
    you need to create the corresponding `ArrayBufferView` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'ArrayBuffers are really handy for storing image files. Suppose that your chat-room
    guests can exchange images by dragging and dropping image files on the chat window.
    Following code explains how JavaScript handles the drop event in HTML5 browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you firstly create an event handler for the drop
    event. The event handler takes one parameter, which lets you access the dropped
    files. You only drop one single image, so you need the zero-indexed file. After
    that, you create a file reader that reads the file's data as an ArrayBuffer. When
    the reader has finished processing the file, you handle the `onload` event where
    you send the image to the web server using your WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about FileReader at [http://www.html5rocks.com/en/tutorials/file/dndfiles/](http://www.html5rocks.com/en/tutorials/file/dndfiles/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the drop effect that raises the send method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ArrayBuffer](img/6962OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dropping an image to the browser and sending it to the server
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data as ArrayBuffers is fairly simple. Note that you check using `instanceof`,
    rather than the strict equal operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Blobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Blobs** (**Binary Large Objects**) contain totally raw data in their most
    native form. A blob might theoretically be anything, even a non-JavaScript object.
    As a result, interpreting blob data might be quite tricky. As a thumb rule, you''d
    better know exactly what the server is supposed to send, otherwise you''ll need
    to make fairly non-concrete assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the big advantage of blob data is their file size. Binary format is
    machine-level format, so there are almost no abstraction layers used that would
    increase its size.
  prefs: []
  type: TYPE_NORMAL
- en: When you transmit multimedia over the web, you need the highest speed possible,
    in order to achieve the best user experience. The WebSocket blobs do not create
    extra burden for your Internet connection and they rely on the client for proper
    interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following code shows how you can display an incoming image, sent as a set of
    raw bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet generates an image by properly interpreting the incoming
    raw data. You have used some brand-new HTML5 JavaScript methods to easily handle
    the blob. Let's be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: At first, you verify that the server message is an instance of blob, similar
    to the way you checked for the buffered array. Then, you store the raw data to
    a local variable, named `blob`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to display the blob in an image format, you need to decode it properly.
    The new JavaScript API makes basic image manipulation a piece of cake. Instead
    of reading the bytes, you create a plain URL to the specified data source. This
    URL is alive as long as the HTML document is alive. That means you cannot retrieve
    it after closing your browser window.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.URL` property is currently supported in all the major browsers,
    though **Google Chrome** has named it `window.webkitURL`. The `createObjectURL`
    method generates a URL for the temporary file specified as a parameter. You do
    not need to provide any further details or write any further code! JavaScript
    represents the blob you received as a normal browser URL!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using the DOM manipulation methods you already know, you create an
    image element, you provide it with the new URL, and you insert it right at the
    end of the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `createObjectURL` method is supported in Chrome 23+, Firefox 8+, Internet
    Explorer 10+, Opera 16+ and Safari 6+, as well as in their mobile counterparts
    (except IE and Opera).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out and you''ll see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blobs](img/6962OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The incoming blob data, displayed as an HTML image
  prefs: []
  type: TYPE_NORMAL
- en: Video streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many web designers and developers argue that the future of the web is video.
    Until now, video was delivered using third-party plugins and technologies such
    as Flash or Silverlight. Although these technologies worked pretty well on the
    desktop browsers, they required extra software and were a catastrophe (in terms
    of battery life) for mobile and tablet devices. After Apple decided to drop Flash
    support for iPhone and iPad, HTML5 became the only available gate for delivering
    videos and rich graphics over the web.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of WebSockets, it makes sense to stream video across different clients
    using a fast and efficient way. Live video streaming is currently supposed to
    be one of the last reasons Flash is still alive. Let's see how you can stream
    live video data from the server to the clients in the WebSocket way.
  prefs: []
  type: TYPE_NORMAL
- en: A video is nothing more than a collection of consecutive images. Each of these
    images is called a **frame**. When a number of frames (usually more than 20) are
    displayed per second, the human eye cannot distinguish the distinct images and
    thinks of it like a continuous flow. That's the technique you are going to use
    for streaming a video file from the server to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server sends 20 or more frames (images) per second, so that the client
    is constantly awaiting for new messages. Remember the code you wrote for displaying
    images? Well, in a real-time video stream context, you do not need to store the
    data as URLs until the web page is closed. Rather, it''s a good practice to dispose
    the frame URLs when you do not use them any more. Also, there is no need to create
    the `<img>` element using JavaScript, as you can place it in our markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '…and create a reference in your JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here is the modified onmessage client event, which will be raised 20 or
    more times per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is similar to the one you used to drop an image on the HTML document.
    There are two things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: You have created a reference for the `<img>` element, in order to constantly
    modify its `src` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After every `src` assignment, you release the image by calling the `revokeObjectURL`
    function. This function cleans up the memory assigned to the specified URL, and
    lets the browser know it doesn't need to keep the URL's reference any more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows video streaming using consecutive frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Video streaming](img/6962OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it makes the point, this might not be the optimal way to stream video.
    For a more professional approach, have a look at WebRTC ([http://www.webrtc.org](http://www.webrtc.org)),
    a great multimedia development API, implemented by Google, Mozilla, and Opera.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering where is the server code that handles the requests, receives
    the images, and updates the video frames. We deliberately left out the server-side
    part in order to focus on the client-side JavaScript code. For the purposes of
    our chat demo web app, we'll now show you both the client and the server code.
    Once more, note that you can use the programming language and frameworks of your
    choice to implement the WebSocket server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a close look at the new parts you'll implement.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the nickname and message using JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At first, you'll add one more text field to the HTML document, in order for
    the user to type his/her preferred nickname. You'll send the nickname along with
    the text message by encoding them in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new text input just before the message input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a reference to the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And finally, send the nickname and the message to the server, as you did a few
    pages ago!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The server now needs to transmit this message to the clients. Nothing is changed
    from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The clients decode the JSON string and display the message accordingly. You
    have added a prettier presentation style for showing the text in the chat area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sending images to the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the `ondrop` event we discussed previously? For consistency reasons,
    here is the same functionality using Blobs instead of ArrayBuffers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with HTML5 drag-and-drop, remember to always prevent the default
    drag-and-drop behavior! Unless you explicitly define that you want to override
    the default functionality, whatever you implement will not be shown correctly.
    Fortunately, preventing the predefined actions from happening is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The server needs to distribute the blob image to all the clients. `Fleck` library
    introduces the `OnBinary` event, which is raised when binary data is received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The method works similar to the `OnMessage` method. The only difference is that
    it takes a byte array (data) instead of string as a parameter. An array of bytes
    is the most native and efficient image representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the rest of the clients receive the image, a new `<img>` element will
    be created. You have already seen the way, so you update the `onmessage` function
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you had a detailed look at the various data formats the WebSocket
    protocol supports. You implemented various examples using string and binary data
    (text, images, and videos), found out how you can properly encode and decode the
    client-side data, and finally extended the chat demo to manipulate images and
    videos. The next chapter discusses security considerations over the web that will
    make your apps even more robust.
  prefs: []
  type: TYPE_NORMAL
