- en: System Types for C and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a system program, simple things, such as integer types, become complicated.
    This entire chapter is devoted toward common problems that arise when performing
    system programming, especially when performing system programming for multiple
    CPU architectures, operating systems, and user space/kernel communications, such
    as system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter consists of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of the default types that C and C++ provide, including types
    that most programmers are familiar with, such as `char` and `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A review of some of the standard integer types provided by `stdint.h` to address
    limitations with the default types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure packing and the complications associated with optimizations and type
    conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and execute the examples in this chapter, the reader must have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples and code
    snippets, please go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring C and C++ default types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C and C++ languages come with several built-in types that come with the
    language, without the need for additional header files or language features. In
    this section, we will be discussing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`char`, `wchar_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short int`, `int`, `long int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`, `double`, `long double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool` (C++ only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic type in C and C++ is the following character type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A `char` is an integer type that, on most platforms, is 8 bits in size, and must
    be capable of taking on the value range of [`0`, `255`] for unsigned, and [`-127`,
    `127`] for signed. The difference between a `char` and the other integer types
    is that a `char` has a special meaning, corresponding with the **American Standard
    Code for Information Interchange** (**ASCII**). In the preceding example, the
    uppercase letter `B` is represented by the 8-bit value `0x42`. It should be noted
    that although a `char` can be used to simply represent an 8-bit integer type,
    its default meaning is a character type; that''s why it has a special meaning.
    For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we represented the same integer type, `0x42`, using
    both an `int` (to be explained later) and a `char`. These two values are, however,
    output to `stdout` in two different ways. The integer is output as an integer
    while, using the same APIs, the `char` is output as its ASCII representation.
    In addition, arrays of `char` types are considered to be an ASCII string type
    in both C and C++, which also has a special meaning. The following code shows
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, we understand the following. We define an ASCII
    string using a `char` pointer (an unbounded array type would also work in this
    case); `std::cout` understands how to handle this type by default, and a `char` array
    has a special meaning. Changing the array type to an `int` would not compile,
    as the compiler would not know how to convert the string to an array on integers,
    and `std::cout` would not know, by default, how to handle the array of integers,
    even though, on some platforms, an `int` and a `char` might actually be the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Like a `bool` and `short int`, the character type is not always the most efficient
    type to use when representing an 8-bit integer, and as alluded to in the previous
    code, on some platforms, it is possible for a `char` to actually be larger than
    8 bits, a topic that will be discussed in further detail when we discuss integers.
  prefs: []
  type: TYPE_NORMAL
- en: To further investigate the `char` type, as well as the other types being discussed
    in this section, let's leverage the `std::numeric_limits{}` class. This class
    provides a simple wrapper around `limits.h`, which provides us with a means to
    query how a type is implemented on a given platform in real time using a collection
    of static member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we leverage `std::numeric_limits{}` to tell us the
    min and max value for both a signed and unsigned `char` (it should be noted that
    all examples in this book were performed on a standard Intel 64-bit CPU, and it
    is assumed that these same examples can, in fact, be executed on different platforms
    for which the values being returned might be different). The `std::numeric_limits{}`
    class can provide real-time information about a type, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Signed or unsigned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion limits, such as rounding and the total number of digits needed to
    represent the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Min and max information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the preceding example, a `char` on a 64-bit Intel CPU is 1 byte
    in size (that is, 8 bits), and takes on the values [`0`, `255`] for an unsigned
    `char` and [`-127`, `127`] for a signed `char`, as stated by the specification.
    Let''s look at a wide `char` or `wchar_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A `wchar_t` represents Unicode characters and its size depends on the operating
    system. On most Unix-based systems, a `wchar_t` is 4 bytes, and can represent
    a UTF-32 character type, as shown in the previous example, while on Windows, a
    `wchar_t` is 2 bytes in size, and can represent a UTF-16 character type. Executing
    the previous example on either of these operating systems will result in a different
    output.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely important, and this issue defines the fundamental theme of
    this entire chapter; the default types that C and C++ provide are different depending
    on the CPU architecture, the operating system, and in some cases, if the application
    is running in user space or in the kernel (for example, when a 32-bit application
    is executing on a 64-bit kernel). Never assume, while system programming, that
    when interfacing with a system call, that your application's definition of a specific
    type is the same as the type the API assumes. Quite often, this assumption will
    prove to be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To further explain how the default C and C++ types are defined by their environment,
    and not by their size, let's look at the integer types. There are three main integer
    types—`short int`, `int`, and `long int` (excluding `long long int`, which on
    Windows is actually a `long int`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A `short int` is typically smaller than an `int`, and on most platforms, represents
    2 bytes. For example, go through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous example, the code gets the min, max, and size of both
    a signed `short int` and an unsigned `short int`. The results of this code demonstrates
    that on an Intel 64-bit CPU running Ubuntu, a `short int`, whether it is signed
    or unsigned, returns a 2 byte representation.
  prefs: []
  type: TYPE_NORMAL
- en: Intel CPUs provide an interesting advantage over other CPU architectures, as
    an Intel CPU is known as a **complex instruction set computer** (**CISC**), meaning
    that the Intel **instruction set architecture** (**ISA**) provides a long list
    of complicated instructions, designed to provide both compilers and by-hand authors
    of Intel assembly with advanced features. Among these features is the ability
    for an Intel processor to perform **arithmetic logic unit** (**ALU**) operations
    (including memory-based operations) at the byte level, even though most Intel
    CPUs are either 32-bit or 64-bit. Not all CPU architectures provide this same
    level of granularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this better, let''s look at the following example involving a `short
    int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we take a `short int`, set it to the value `42`, output
    this value to `stdout` using `std::cout`, increment the `short int` by `1`, and
    then output the result to `stdout` using `std::cout` again. This is a simple example,
    but under the hood, a lot is occurring. In this case, a 2 byte value, executing
    on a system that contains 8 byte (that is, 64 bit) registers must be initialized
    to `42`, stored in memory, incremented, and then stored in memory again to be
    output to `stdout`. All of these operations must involve CPU registers to perform
    these actions.
  prefs: []
  type: TYPE_NORMAL
- en: On an Intel-based CPU (either 32-bit or 64-bit), these operations likely involve
    the use of the 2 byte versions of the CPU's registers. Specifically, Intel's CPUs
    might be 32-bit or 64-bit, but they provide registers that are 1, 2, 4, and 8
    bytes in size (specifically on 64-bit CPUs). In the previous example, this means
    that the CPU loads a 2 byte register with `42`, stores this value to memory (using
    a 2 byte memory operation), increments the 2 byte register by `1`, and then stores
    the 2 byte register back into memory again.
  prefs: []
  type: TYPE_NORMAL
- en: On a **reduced instruction set computer** (**RISC**), this same operation might
    be far more complicated, as 2 byte registers do not exist. To load, store, increment,
    and store again only 2 bytes of data would require the use of additional instructions.
    Specifically, on a 32 bit CPU, a 32 bit value would have to be loaded into a register,
    and when this value is stored in memory, the upper 32 bit (or lower, depending
    on alignment) would have to be saved and restored to ensure that only 2 bytes
    of memory were actually being affected. The additional alignment checks, that
    is, memory reading, masking, and storing, would result in a substantial performance
    impact if a lot of operations were taking place.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, C and C++ provide the default `int` type, which typically represents
    a CPU register. That is, if the architecture is 32 bit, an `int` is 32 bit and
    vice versa (with the exception of 64 bit, which will be explained shortly). It
    should be noted that CISC architectures, such as Intel, are free to implement
    ALU operations with granularity smaller than the CPU's register size however they
    wish, which means that under the hood, the same alignment checks and masking operations
    could still be taking place. The take home point is that unless you have a very
    specific reason to use a `short int` (for which there are a few reasons to do
    so; a topic we will discuss at the end of this chapter), instead of an `int`,
    an `int` type is, in most cases, more efficient than using a smaller type; even
    if you don't need a full 4 or 8 bytes, it's still faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, an `int` is showing as 4 bytes on a 64 bit Intel CPU.
    The reason for this is backward compatibility, meaning that on some RISC architectures,
    the default register size, resulting in the most efficient processing, might not
    be an `int` but rather a `long int`. The problem is that to determine this in
    real time is painful (as the instructions being used are done so at compile-time).
    Let''s look at the `long int` to explain this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, on a 64 bit Intel CPU running on Ubuntu, the
    `long int` is an 8 byte value. This is not true on Windows, which represents a
    `long int` as 32 bit, with the `long long int` being 64 bits (once again for backward
    compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: When system programming, the size of the data you are working with is usually
    extremely important, and as shown in this section, unless you know exactly what
    CPU, operating system, and mode your application will be running on, it's nearly
    impossible to know the size of your integer types when using the default types
    provided by C and C++. Most of these types should not be used when system programming
    with the exception of `int`, which almost always represents a data type with the
    same bit width as the registers on your CPU, or at a minimum, a data type that
    doesn't require additional alignment checks and masking to perform simple arithmetic
    operations. In the next section, we will discuss additional types that overcome
    these size issues, and we will discuss their pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: Floating – point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When system programming, floating point numbers are rarely used, but we will
    briefly discuss them here for reference. Floating point numbers increase the size
    of the possible value that can be stored by reducing the accuracy. For example,
    with a floating point number, it is possible to store a number that represents
    `1.79769e+308`, which is simply not possible with an integer value, even with
    a `long long int`. To accomplish this, however, it is not possible to subtract
    this value by `1` and see a difference in the number's value, and the floating
    point number cannot represent such a large value while still maintaining the same
    granularity as an integer value. Another benefit of floating point numbers is
    their ability to represent sub-integer numbers, which is useful when dealing with
    more complicated, mathematical calculations (a task that is rarely needed for
    system programming, as most kernels don't work with floating point numbers to
    prevent floating point errors from occurring within the kernel, ultimately resulting
    in a lack of system calls that take floating point values).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly three different types of floating point numbers—`float`, `double`,
    and `long double`. For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we leverage `std::numeric_limits` to examine the `float` type,
    which on an Intel 64 bit CPU is a 4 byte value. The `double` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `long double`, the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the previous code, on an Intel 64 bit CPU, the `long double` is
    a 16 byte value (or 128 bits), which can store an absolutely massive number.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard C language doesn't define a Boolean type natively. C++, however,
    does, and is defined using the `bool` keyword. When writing in C, a Boolean can
    be represented using any integer type, with `false` typically representing `0`,
    and `true` typically representing `1`. As an interesting side note, some CPUs
    are capable of comparing a register or memory location to `0` faster than `1`,
    meaning that on some CPUs, it's actually faster for Boolean arithmetic and branching
    to result in `false` in the *typical* case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a `bool` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, a Boolean using C++ on a 64 bit Intel CPU is
    1 byte in size, and can take on a value of `0` or `1`. It should be noted, for
    the same reasons as already identified, a Boolean could be 32-bits or even 64-bits,
    depending on the CPU architecture. On an Intel CPU, which is capable of supporting
    register sizes of 8 bits (that is, 1 byte), a Boolean only needs to be 1 byte
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: The total size of a Boolean is important to note, with respect to storing Booleans
    in a file on disk. A Boolean technically only needs a single bit to store its
    value, but rarely (if any) CPU architectures support bit-style register and memory
    access, meaning a Boolean typically consumes more than a single bit, and in some
    cases could consume as many as 64 bits. If the size of your resulting file is
    important, storing a Boolean using the built-in Boolean type may not be preferred
    (ultimately resulting in the need for bit masking).
  prefs: []
  type: TYPE_NORMAL
- en: Learning standard integer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To address the uncertainty of the default types provided by C and C++, both
    provide the standard integer types, which are accessible from the `stdint.h` header
    file. This header defines the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int8_t`, `uint8_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int16_t`, `uint16_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32_t`, `uint32_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64_t`, `uint64_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, `stdint.h` provides both *least* and *fast* versions of the aforementioned
    types, and a max type and integer pointer type, which is all out-of-scope for
    this book. The previous types do exactly what you would expect; they define the
    width of integer types with a specific number of bits. For example, an `int8_t` is
    a signed 8 bit integer. No matter what the CPU architecture, operating system,
    or mode is, these types are always the same (with the only thing not being defined
    is their endianness, which is usually only needed when working with networking
    and external devices).
  prefs: []
  type: TYPE_NORMAL
- en: In general, if the size of the data type you are working with is important,
    use the standard integer types instead of the default types provided by the language.
    Although the standard types do solve a lot of the problems already identified,
    they do have their own issues. Specifically, `stdint.h` is a compiler provided
    header file, with a different header being defined for each CPU architecture and
    operating system combination possible. The types defined in this file are typically
    represented using the default types under the hood. This can be done because the
    compiler knows if an `int32_t` is an `int`, or a `long int`. To demonstrate this,
    let's create an application that's capable of comparing integer types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeinfo` header will provide us with C++ supported type information,
    which will ultimately provide us with the root type for a specific integer type.
    The problem is that `typeinfo` provides us with the mangled versions of this type
    information. To demangle this information, we will need the `cxxabi.h` header,
    which provides access to the demangler built into C++ itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function returns the root name for a provided type `T`. This is
    done by first getting the type''s name from C++, and then using the demangler
    to convert the mangled type information into its human-readable form. Finally,
    the resulting name is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function checks to see if both the name and size of the type are
    the same, as they do not need to be the same (for example, the size could be the
    same, but the type''s root might not be). It should be noted that we add some
    strange characters to the output of this function (which outputs to `stdout`).
    These strange characters tell the console to output in the color red in the event
    that a match was not found, providing a simple means to see which types are the
    same, and which types are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will compare each standard integer type with the expected (or more
    appropriately stated, *typical*) default type to see if the types are in fact
    the same on any given architecture. This example can be run on any architecture
    to see what the differences are between the default types and the standard integer
    types so that we can look for discrepancies if this information is needed when
    system programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follow (for an Intel-based 64 bit CPU on Ubuntu) for a `uint8_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the results of a `char`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following code shows the results for the remaining `int` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the types are the same, with some notable exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two tests were provided specifically to ensure that an error would,
    in fact, be detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Ubuntu, an `int64_t` is implemented using `long` and not a `long long`, which
    means that on Ubuntu, a `long` and a `long long` mean the same thing. This is
    not the case with Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important thing to recognize with this demonstration is that the output
    doesn't include the standard integer type names, but instead only contains the
    default type names. This is because, as previously demonstrated, the compiler
    implements an `int32_t` on an Intel 64 bit CPU on Ubuntu using an `int`, and to
    the compiler, these types are one and the same. The difference is, on another
    CPU architecture and operating system, an `int32_t` might be implemented using
    a `long int`.
  prefs: []
  type: TYPE_NORMAL
- en: If you care about the size of an integer type, use a standard integer type,
    and let the header file pick which default type to use for you. If you don't care
    about the size of the integer type, or an API dictates the type, leverage the
    default type instead. In the next section, we will show you how even standard
    integer types do not guarantee a specific size, and the rules just described can
    break down using a common system programming pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Structure packing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard integers provide a compiler-supported method for dictating the
    size of an integer type at compile time. Specifically, they map bit widths to
    default types so that the coder doesn''t have to do this manually. The standard
    types, however, do not always guarantee the width of a type, and structures are
    a good example of this. To better understand this issue, let''s look at a simple
    example of a structure with some data in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a structure with two 64 bit integers in
    it. We then, using the `sizeof()` function, output the size of the structure to
    `stdout` using `std::cout`. As expected, the total size, in bytes, of the structure
    is `16`. It should be noted that, like the rest of this book, the examples in
    this section are all being executed on a 64 bit Intel CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the same example, but with one of the data types being
    changed to a 16 bit integer instead of a 64 bit integer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we have a structure that has two data types,
    but they do not match. We then output the size of the data structure to `stdout`
    using `std::cout`, and the reported size is 16 bytes. The problem is that we expect
    10 bytes, as we defined the structure as being the combination of a 64-bit (8
    bytes) and a 16-bit (2 bytes) integer.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the compiler is replacing the 16 bit integer with a 64 bit integer.
    The reason for this is the base type for C and C++ is an `int`, and the compiler
    is allowed to change a type smaller than an `int` with an `int`, even though we
    explicitly declared the second integer as a 16 bit integer. To explain this in
    other words, the use of `unit16_t` does not demand the use of a 16 bit integer,
    but rather it is a `typedef` for `short int` on a 64 bit Intel-based CPU running
    Ubuntu, and based on the C and C++ specifications, the compiler is allowed to
    change a `short int` to an `int` at will.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which we specify our integers also does not matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the previous example, the compiler once again states that the total
    size of the structure is 16 bytes when, in fact, we expect 10\. In this example,
    the compiler is even more likely to make this type of substitution because it
    is capable of identifying that there is an alignment issue. Specifically, the
    CPU this code was compiled on was a 64 bit CPU, which means that replacing the
    `uint16_t` with a `unit64_t` could possibly improve memory caching, and align
    `data2` on a 64 bit boundary instead of a 16 bit boundary, which would span two
    64 bit memory locations if the structure is properly aligned in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structures are not the only way to reproduce this type of substitution. Let''s
    examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a 16-bit integer and set it to `42`. We
    then created another integer and set it to our 16-bit integer plus `42`. The value
    `42` can be represented as an 8-bit integer, but it's not. Instead, the compiler
    represents `42` as an `int`, which in this case means that the system this code
    was compiled on is 4 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler represents `42` as an `int`, and `int` plus an `int16_t`, which
    results in an `int`, as that is the higher width type. In the previous example,
    we define our `result` variable using `auto`, which ensures that the resulting
    type reflects the type the compiler created as a consequence of this arithmetic.
    We could have defined `result` as another `int16_t`, which would have worked unless
    we turned on integer type conversion warnings. Doing so would have resulted in
    a conversion warning as the compiler constructs an `int` as a consequence of adding
    `s` plus `42`, and then would have to automatically convert the resulting `int` back
    to an `int16_t`, which would be performing a narrowing conversion, which could
    result in an overflow (hence the warning).
  prefs: []
  type: TYPE_NORMAL
- en: All of these issues are a consequence of the compiler's ability to perform type
    conversions from a smaller width type to a higher width type in order to optimize
    performance to reduce the possibility of overflows. In this case, a numeric value
    is always an `int` unless the value requires more storage (for example, replace
    `42` with `0xFFFFFFFF00000000`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of conversion is not always guaranteed. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have a structure with two 16 bit integers. The total
    size of the structure is reported as 4 bytes, which is exactly what we would expect.
    In this case, the compiler doesn't see a benefit to changing the size of either
    of the integers and thus leaves them alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bit fields also do not change the compiler''s ability to perform this type
    of conversion, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a structure with two integers (a 16-bit
    integer and a 64-bit integer), but instead of just defining the 16-bit integer,
    we also defined bit fields, giving us direct access to specific bits within the
    integer (a practice that should be avoided when system programming for reasons
    that are about to be explained). Defining these bit fields does not prevent the
    compiler from changing the total size of the first integer from 16 bits to 64
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the previous example is that bit fields are often a pattern
    used by system programmers when interfacing directly with hardware. In the previous
    example, the second 64-bit integer is expected to be at 2 bytes from the top of
    the structure. In this case, however, the second 64-bit integer is actually 8
    bytes from the top of the structure. If we used this structure to interface directly
    with hardware, a hard to find logic bug would be the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to overcome this problem is to pack the structure. The following example
    demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous example is similar to the first example in this section. A structure
    was created with a 64 bit integer and a 16 bit integer. In the previous example,
    the resulting size of the structure was 16 bytes, as the compiler replaced the
    16 bit integer with a 64 bit integer instead. In the previous example, to fix
    this issue, we wrap the structure with the `#pragma pack` and `#pragma pop` macros.
    These macros tell the compiler (since we passed a `1` to the macro, which indicates
    a byte) to pack the structure using a byte granularity, telling the compiler it
    is not allowed to make a substitution optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this method, changing the order of the variables to the more likely scenario
    for which the compiler would attempt this type of optimization still results in
    a structure that is not converted, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the previous example, the size of the structure is still 10 bytes,
    regardless of the order of the integers.
  prefs: []
  type: TYPE_NORMAL
- en: Combining structure packing with the standard integer types is sufficient (assuming
    endianness is not an issue)  to directly interface with the hardware, but this
    type of pattern is still discouraged in favor of building accessors and leveraging
    bit masks that provide the user with a means to ensure that direct access to hardware
    registers is occurring in a controlled manner without the compiler getting in
    the way, or optimizations producing undesired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain why packed structures and bit fields should be avoided, let''s look
    at an alignment issue with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a structure with a 16 bit integer and a
    64-bit integer, and then packed the structure to ensure the total size of the
    structure is 10 bytes, and each data field is properly aligned. The total alignment
    of the structure is, however, not cache aligned, which is demonstrated in the
    previous example by creating an instance of the structure on the stack and then
    outputting the structure's address to `stdout` using `std::cout`. As shown, the
    address is byte aligned, not cache aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cache align the structure, we will leverage the `alignas()` function, which
    will be explained in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we added the `alignas()` function to the definition
    of the structure, which cache aligns the structure on the stack. We also output
    the total size of the structure as with previous examples, and as shown, the structure
    is no longer packed. In other words, the use of `#pragma pack#` does not guarantee
    the structure will, in fact, be packed. As in all cases, the compiler is free
    to make changes as needed, and even the `#pragma pack` macro is a hint, not a
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous case, it should be noted that the compiler actually adds additional
    memory to the end of the structure, meaning that the data members in the structure
    are still in their correct locations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the address of each data member is output to `stdout`,
    and as expected, the first data member is aligned to `0`, and the second data
    member is 2 bytes from the top of the structure, even though the total size of
    the structure is 16 bytes, meaning that the compiler is getting the extra 6 bytes
    by adding addition integers to the bottom of the structure. Although this might
    seem benign if an array of these structures were created, and it was assumed the
    structures were 10 bytes in size due to the use of `#pragma pack`, a hard to find
    logic bug would be introduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this chapter, a note about pointers should be provided with respect
    to their size. Specifically, the size of a pointer depends entirely on the CPU
    architecture, operating system, and mode the application is running in. Let''s
    examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we stored a pointer and an integer and output the total
    size of the structure to `stdout` using `std::cout`. The resulting size of this
    structure is 16 bytes on a 64-bit Intel CPU running Ubuntu. The total size of
    this structure on a 32-bit Intel CPU running Ubuntu would be 12 bytes, as the
    pointer would only be 4 bytes in size. Worse, if the application were compiled
    as a 32-bit application, but executed on a 64-bit kernel, the application would
    see this structure as 12 bytes, and the kernel would see this structure as 16
    bytes. Attempting to pass this structure to the kernel would result in a bug,
    as the application and kernel would see the structure differently.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the different integer types (and briefly reviewed
    the floating point types) that are provided by C and C++ for system programming.
    We started with a discussion on the default types provided by C and C++ and the
    pros and cons associated with these types, including the common `int` type, explaining
    what it is, and how it is used. Next, we discussed the standard integer types
    provided by `stdint.h` and how they address some of the issues with the default
    types. Finally, we concluded this chapter with a discussion on structure packing
    and the issues associated with type conversions and optimizations that the compiler
    can make in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover changes made by C++17, a C++ specific technique
    called **Resource Acquisition Is Initialization** (**RAII**) and provide an overview
    of the **Guideline Support Library** (**GSL**).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a `short int` and an `int`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the size of an `int`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the size of a `signed int` and an `unsigned int` different?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an `int32_t` and an `int`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is an `int16_t` guaranteed to be 16 bits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `#pragma pack` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it possible to guarantee structure packing in all cases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
