- en: Chapter 8. System and Password Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using local password-attack tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking password hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Social-Engineer Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using BeEF for Browser Exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking NTLM hashes using rainbow tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on obtaining the hashes and then cracking them
    to obtain access. This information can be put to much use, because there is a
    very high possibility of getting other systems in the same network that use the
    same password. Let us proceed to see how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Using local password-attack tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will see a few tools both for Windows and Linux that will
    perform password-guessing attacks. For Linux, we will use a tool called **sucrack**,
    and for Windows we will use **fgdump** and **pwdump**. Sucrack is used to crack
    passwords via the `su` command, which is a multithreaded tool. SU is a tool in
    Linux that allows you to run commands using a substitute user. But first let us
    understand these tools: Sucrack is a password cracker. Fgdump and pwdump are tools
    that dump the SAM hashes from LSASS memory. **JTR** (**John the Ripper**) is a
    cracker for SAM hashes. **Windows Credentials Editor** (**WCE**) is a security
    tool to list logon sessions and add, change, list, and delete associated credentials
    (for example, LM/NT hashes, plaintext passwords, and Kerberos tickets). Let us
    begin with the practical approach.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate this, we will require a Windows XP machine and our Kali Linux
    distro. The reader might also need to port `PwDump.exe` and `FgDump.exe` from
    Kali Linux to Windows XP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For demo purposes, we have changed the password to `987654321`. Enter the following
    command to commence the sucrack attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the attack is completed and the password matches one of those in the dictionary,
    we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can do the same for any user we want by entering his/her username
    in the `-u` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us see how the same can be done on Windows machines. The binaries for `wce.exe`,
    `PwDump.exe` and `FgDump.exe` can be found in Kali Linux at the `/usr/share/windows-binaries/`
    path. Import the same to the Windows machine to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have the tools, ensure that the terminal is pointing towards the
    same folder the files have been put in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now open the test file created, with a notepad, in the same folder where the
    `PWDump.exe` command was executed:![How to do it...](img/image_08_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This shows us that `PwDump.exe` extracts all the passwords and is shown in the
    NTLM hashed state; the same can be used on the NTLM decrypt websites, where they
    have tons of stored hashes with clear text passwords. These websites store a huge
    database of cracked hashes, which are compared to get the original string. One
    thing to keep in mind is that NTLM hashes are one-way hashes and cannot be decrypted
    back; the only way to get the actual password is if one has the word and its corresponding
    hash. One famous website is [https://hashkiller.co.uk](https://hashkiller.co.uk)
    . It has approximately 312.072 billion unique decrypted NTLM hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at fgdump and its workings. Before we continue, we need to
    know that fgdump is the newer version of pwdump; it has an added functionality
    of displaying password histories if they are available. Enter the following command
    in the command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create three files: two pwdump files and one cache-dump file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On opening the pwdump file, we get the same NTLM hashes that we got in the previous
    tool we ran; the same can be entered on NTLM cracking sites to achieve the clear-text
    password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have made use of a few parameters. Let us understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`-a`: This uses ANSI escape codes for nice-looking statistics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`: This shows the number of worker threads to run with'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: This shows the statistics display interval in seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: This shows the user account to `su` to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us understand the parameter used for `Pwdump.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-o`: This is used to write into a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127.0.0.1`: Enter the IP address of the compromised machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more options in sucrack, pwdump, and fgdump that can be explored.
    Simply issue the commands `sucrack`, `Pwdump -h`, and `fgdump -h` in the respective
    windows and in the terminal to get all the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking password hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we are going to see how we can crack the hashes for a clear-text
    password. We will be using John the Ripper. John the Ripper (JTR) is a fast password
    cracker, currently available for many flavors of Unix, Windows, DOS, and OpenVMS.
    Its primary purpose is to detect weak Unix passwords. Besides several crypt (3)
    password hash types most commonly found on various Unix systems, supported out
    of the box are Windows LM hashes, plus lots of other hashes and ciphers in the
    community-enhanced version.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will require the hash obtained on the Windows machine to be ported to our
    Kali machine, after which we can commence with a comparison of the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us begin with one of the most efficient tools when it comes to cracking
    passwords, JTR. For the given example, we have taken the hash dump received previously.
    The file has been renamed `crackme` for ease of readability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the passwords are retrieved in clear text; for example, `dhruv:
    1` and `dhruv: 2` form an entire password, `Administrator`; it is similar for
    the others. The password is split like this because of the NTLM hash mechanism.
    The entire hash is actually divided into an 8:8 segment, where if the password
    is bigger than eight chars, the other section is used to hash the password as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: John the Ripper supports cracking of different types of hashes, with NTLM being
    one of them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding recipe, we used the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|john crackme`: Where `crackme` is the password file that contains the hashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: John the Ripper is an intelligent tool; it detects the type of encryption used
    and performs the cracking phase automatically.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot more information can be found on John the Ripper by using the `man john`
    or `john --help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Social-Engineering Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Social-Engineering Toolkit** (**SET**), as the name implies, focuses on exploiting
    the human nature of curiosity. SET was written by David Kennedy (ReL1K) and, with
    a lot of help from the community, it has incorporated attacks. In this recipe,
    we will look at how a malicious executable is created and how the attacker waits
    for the victim to execute the file. We will also look at how an attacker tricks
    a user to attain a reverse shell by luring the victim to visit a malicious website.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will make use of Windows OS with Internet Explorer 6 and
    a Kali Linux machine; `Setoolkit` is installed by default as a part of Kali.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start Social-Engineering Toolkit using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this activity, we will look at how to use `Social-Engineering Attacks` to
    host a fake website and exploit the user''s IE, if vulnerable, and gain a reverse
    shell to his account. We will go with `Social-Engineering Attacks`, which is option
    1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will now select the website attack vector, that is, 2, which then looks as
    follows:![How to do it...](img/image_08_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will select the `Metasploit Browser Exploit Method` option 2:![How to
    do it...](img/image_08_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, we will clone the site and fill up the necessary information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Screenshot for the same is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will select the `Internet explorer 6 vulnerability of Aurora memory corruption
    (2010-01-14)`, option number 37, and select the Metasploit **Windows Shell Reverse_TCP**,
    option 1, and specify any desired port, preferably above 1,000, as the ones below
    1,000 are registered for operating systems. The output will be as shown in the
    following screenshot:![How to do it...](img/image_08_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the setup of the malicious website is complete, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that our configuration at the attacker end is complete, all we have to do
    is call the victim on the malicious website. For this exercise, our victim is
    a Windows Machine with IE version 6:![How to do it...](img/image_08_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The malicious script is executed and, if all the conditions, such as an Internet
    Explorer browser, vulnerable version of the browser, and no antivirus detection
    are matched, we get a reverse shell as our payload, as previously mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On checking to ensure that it is the same system, let''s run an ipconfig:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the whole exercise is self-explanatory; we create or host a
    fake website in order to steal information or gain remote access to the system.
    This should be taken with the utmost care in corporate environments. There are
    no special commands executed; the flow is followed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a scenario where the attacker wants to attack a server, however,
    there are only three or four people who have access to that server on the firewall.
    The attacker would social-engineer, forcing one of the four users to access the
    website, and might be lucky enough to gain a shell. Once done, the attacker will
    be able to route his attack over the targeted server via the compromised machine.
  prefs: []
  type: TYPE_NORMAL
- en: Social-Engineering Toolkit not only restricts you to browser-based exploitation,
    it even contains modules such as Phishing, mass mailers, Arduino-based attacks,
    wireless attacks, and so on. Since this chapter is restricted to exploitation,
    we have taken a recipe to look at how exploitation can be done via SET.
  prefs: []
  type: TYPE_NORMAL
- en: Using BeEF for browser exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**BeEF** stands for **Browser Exploitation Framework**. It is a pen testing
    tool that focuses mainly on browser and related exploitation. Nowadays, there
    are a growing number of threats toward the client browser comprised of mobile
    clients, web clients, and so on. BeEF allows us to pen test the targets using
    client-side attack vectors such as creating users, executing malicious script,
    and so on. BeEF mainly focuses on web-client-based exploitation, for example,
    browser level.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BeEF XSS is already a part of Kali Linux. For this exercise, we are using a
    Windows machine with a Firefox browser. We will be hooking the client via the
    Firefox browser. On accessing the hook, the JavaScript is executed and the hook
    is deployed. If there are any issues while running the BeEF-XSS framework, refer
    to the guide at [https://github.com/beefproject/beef/wiki/Installation](https://github.com/beefproject/beef/wiki/Installation)
    .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initiate the BeEF framework by entering the following in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now open the Firefox browser in Kali and visit the UI panel, as stated in the
    output. Enter the username password as `beef:beef`:![How to do it...](img/image_08_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To hook a browser, we will have to make it load the hook URL of BeEF; we will
    do the same with our Windows machine. We make the browser visit the hook URL of
    our BeEF framework:![How to do it...](img/image_08_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we can see, the framework has detected a hook and attached itself to it,
    and we can now browse the different capabilities provided by the BeEF to attack
    the user using the browser. Note: It is also possible to create a persistent hook
    by force-loading a hidden pop-up window from the exploit modules available so
    that when the user browses away from the hook-injected page, the attacker still
    has the session:![How to do it...](img/image_08_022.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now managed to hook the client to the BeEF framework. Usually, this
    hook is an XSS vector and is pasted as an iframe over any application where a
    user would visit, and then as an attacker continues to attack the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let us make a pop-up box over the client to see its workings. The reader should
    click on the IP of the browser that is hooked and go to the commands tab. Under
    the hooked domain, there is an option to **Create Alert Dialogue**. Click it,
    set your parameters straight, and click on **Execute**. Check to see if the hooked
    browser got an alert prompt or not:![How to do it...](img/image_08_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the script is executed, the victim browser will have an alert-dialog box,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So yes, it's working. Now there are various modules available in the command
    section. They are separated by colored balls, green, orange, red, and gray. Green
    symbolizes that the command module works against the target and should be invisible
    to the user; orange, the command module works against the target but may be visible
    to the user; gray, the command module is yet to be verified against this target;
    and red, the command module does not work against this target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Considering that the hooked browser is being operated by an admin for this activity,
    we are going to use the hook to create a user with remote-desktop capability.
    In our environment, we have Internet Explorer running on Windows XP with ActiveX
    enabled. To perform this activity, select the hook of the machine, then go to
    **Commands** | **Module Tree** | **Exploits** | **Local Host** | **ActiveX Command
    Execution**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **ActiveX Command Execution**, set the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The option for setting the same can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now proceed to attempt a remote desktop connection to the remote system,
    using the `rdesktop` command in Kali. Enter the username, password, and IP to
    connect to the machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully managed to gain access to the system via a client browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'BeEF uses JavaScript hook.js, which, when accessed by a browser, gives control
    to the BeEF framework. With the hook available, one can use the various functions
    available in the command module. They vary in ranging capabilities, right from
    enumeration to system exploitation, cookie stealing to session stealing, man-in-the-middle
    attacks, and so on. The easiest way the attacker gets the hook is via the XSS
    attack vector, causing them to load an iframe and attach a hook. Hooks can be
    made persistent, even if they browse away from the infected website. This part
    can be done as homework for the reader. The preceding exercise is self-explanatory:
    there are no extra commands involved that need more explanation.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BeEF is a great pen-testing tool when it comes to client-side pen testing. In
    most cases, we demonstrate that XSS is possible. This is the next step, which
    shows how it is possible to root a remote system and steal from the browser via
    a simple XSS and JavaScript. More information can be found on the BeEF framework
    wiki.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking NTLM hashes using rainbow tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this activity, we will be using **Ophcrack**, along with a small rainbow
    table. Ophcrack is a free Windows password cracker based on rainbow tables. It
    is a very efficient implementation of rainbow tables done by the inventors of
    the method. It comes with a **graphical user interface** (**GUI**) and runs on
    multiple platforms. It is available by default in the Kali Linux distro. This
    recipe will focus on cracking the password using Ophcrack, with the help of rainbow
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we are going to crack a Windows XP password. The rainbow table
    `db` can be downloaded from [http://ophcrack.sourceforge.net/tables.php](http://ophcrack.sourceforge.net/tables.php)
    . The Ophcrack tool is available in our Kali Linux Distro.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, download the `tables_xp_free_fast` file from Ophcrack sourceforge tables
    and put it in your Kali machine. Unzip it using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We already have the hash we will use from our compromised XP machine. Now,
    to run the Ophcrack with the preceding rainbow table, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A GUI that looks like the following screenshot will now load. Load your retrieved
    password hash using any of the hash-dumping methods. In this case, pwdump:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_08_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the password hashes are loaded, the screen will look as follows:![How to
    do it...](img/image_08_029.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Tables**, select the **XP free fast** table, click on **Install**,
    and browse to the path where we downloaded the rainbow-table file from ophcrack:![How
    to do it...](img/image_08_030.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we click on a crack option available in the GUI and the cracking will begin:![How
    to do it...](img/image_08_031.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see, almost midway, we have managed to find a commonly used password
    using Ophcrack, with the help of the rainbow tables.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool is pretty much self-explanatory and works flawlessly without any trouble.
    It uses our found hashes' NT/LM and matches them with the rainbow table provided.
    When the hashes match, the rainbow table looks up the corresponding name that
    caused the hash and we end up getting our value in clear text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we have demonstrated using the smallest available size of rainbow table.
    The size of rainbow tables can range from 300 MB to 3 TB; plus, a premium account
    of Ophcrack tables can result in huge sizes of rainbow tables. This can be checked
    out on their previously shared sourceforge link.
  prefs: []
  type: TYPE_NORMAL
